uint64_t nw_protocol_waiting_for_output_is_valid(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  if (a1)
  {
    v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 216) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_register_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v5 = *(void **)(a1 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(a1 + 88);
      if (v6) {
        *(void *)(a1 + 88) = v6 + 1;
      }
    }

    if (a2)
    {
      v7 = *(void **)(a2 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a2 + 88);
        if (v8) {
          *(void *)(a2 + 88) = v8 + 1;
        }
      }

      if (a3)
      {
        uint64_t v9 = *(void *)(a1 + 24);
        if (v9)
        {
          v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 144);
          if (v10)
          {
            uint64_t v11 = v10(a1, a2);
            if (v7 == &nw_protocol_ref_counted_handle)
            {
LABEL_13:
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v17 = *(void *)(a2 + 88);
                if (v17)
                {
                  uint64_t v18 = v17 - 1;
                  *(void *)(a2 + 88) = v18;
                  if (!v18)
                  {
                    v19 = *(void (***)(void))(a2 + 64);
                    if (v19)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v19[2](v19);
                      _Block_release(v19);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      v20 = *(const void **)(a2 + 64);
                      if (v20) {
                        _Block_release(v20);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }
            }

uint64_t nw_protocol_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v5 = *(void **)(a1 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(a1 + 88);
      if (v6) {
        *(void *)(a1 + 88) = v6 + 1;
      }
    }

    if (a2)
    {
      v7 = *(void **)(a2 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a2 + 88);
        if (v8) {
          *(void *)(a2 + 88) = v8 + 1;
        }
      }

      if (a3)
      {
        uint64_t v9 = *(void *)(a1 + 24);
        if (v9)
        {
          v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 152);
          if (v10)
          {
            uint64_t v11 = v10(a1, a2);
            if (v7 == &nw_protocol_ref_counted_handle)
            {
LABEL_13:
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v17 = *(void *)(a2 + 88);
                if (v17)
                {
                  uint64_t v18 = v17 - 1;
                  *(void *)(a2 + 88) = v18;
                  if (!v18)
                  {
                    v19 = *(void (***)(void))(a2 + 64);
                    if (v19)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v19[2](v19);
                      _Block_release(v19);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      v20 = *(const void **)(a2 + 64);
                      if (v20) {
                        _Block_release(v20);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }
            }

uint64_t nw_protocol_register_notification_quiet(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  if (a2)
  {
    v7 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 144);
    if (v7)
    {
      uint64_t v8 = *(void **)(a1 + 40);
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a1 + 88);
        if (v9) {
          *(void *)(a1 + 88) = v9 + 1;
        }
      }

      v10 = *(void **)(a2 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(a2 + 88);
        if (v11) {
          *(void *)(a2 + 88) = v11 + 1;
        }
      }

      if (a3)
      {
        uint64_t v6 = v7(a1, a2);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v17 = *(void *)(a1 + 88);
            if (v17)
            {
              uint64_t v18 = v17 - 1;
              *(void *)(a1 + 88) = v18;
              if (!v18)
              {
                v19 = *(void (***)(void))(a1 + 64);
                if (v19)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v19[2](v19);
                  _Block_release(v19);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  v20 = *(const void **)(a1 + 64);
                  if (v20) {
                    _Block_release(v20);
                  }
                }

                free((void *)a1);
              }
            }
          }

          return v6;
        }

uint64_t nw_protocol_register_notification_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 144) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_unregister_notification_quiet(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  if (a2)
  {
    v7 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 152);
    if (v7)
    {
      uint64_t v8 = *(void **)(a1 + 40);
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a1 + 88);
        if (v9) {
          *(void *)(a1 + 88) = v9 + 1;
        }
      }

      v10 = *(void **)(a2 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(a2 + 88);
        if (v11) {
          *(void *)(a2 + 88) = v11 + 1;
        }
      }

      if (a3)
      {
        uint64_t v6 = v7(a1, a2);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v17 = *(void *)(a1 + 88);
            if (v17)
            {
              uint64_t v18 = v17 - 1;
              *(void *)(a1 + 88) = v18;
              if (!v18)
              {
                v19 = *(void (***)(void))(a1 + 64);
                if (v19)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v19[2](v19);
                  _Block_release(v19);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  v20 = *(const void **)(a1 + 64);
                  if (v20) {
                    _Block_release(v20);
                  }
                }

                free((void *)a1);
              }
            }
          }

          return v6;
        }

uint64_t nw_protocol_unregister_notification_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 152) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_notify(void *a1, uint64_t a2, int a3)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = a2;
    uint64_t v4 = (uint64_t)a1;
    v5 = (void *)a1[5];
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = a1[11];
      if (v6) {
        a1[11] = v6 + 1;
      }
    }

    if (a2)
    {
      v7 = *(void **)(a2 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a2 + 88);
        if (v8) {
          *(void *)(a2 + 88) = v8 + 1;
        }
      }

      if (a3)
      {
        uint64_t v9 = a1[3];
        if (v9)
        {
          v10 = *(void (**)(void *, uint64_t))(v9 + 160);
          if (v10)
          {
            v10(a1, a2);
            goto LABEL_13;
          }
        }

        __nwlog_obj();
        v19 = *(const char **)(v4 + 16);
        *(_DWORD *)buf = 136446722;
        uint32_t v50 = "__nw_protocol_notify";
        if (!v19) {
          v19 = "invalid";
        }
        __int16 v51 = 2082;
        v52 = (void *)v19;
        __int16 v53 = 2048;
        uint64_t v54 = v4;
        v20 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v47 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_108;
          }
          os_log_type_t v23 = *(const char **)(v4 + 16);
          if (!v23) {
            os_log_type_t v23 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint32_t v50 = "__nw_protocol_notify";
          __int16 v51 = 2082;
          v52 = (void *)v23;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
LABEL_87:
          v44 = v21;
          os_log_type_t v45 = v22;
          uint32_t v46 = 32;
LABEL_107:
          _os_log_impl(&dword_181A5C000, v44, v45, v24, buf, v46);
          goto LABEL_108;
        }

        if (!v47)
        {
          v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_108;
          }
          v42 = *(const char **)(v4 + 16);
          if (!v42) {
            v42 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint32_t v50 = "__nw_protocol_notify";
          __int16 v51 = 2082;
          v52 = (void *)v42;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
          goto LABEL_87;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v34 = os_log_type_enabled(v21, type);
        if (!backtrace_string)
        {
          if (!v34) {
            goto LABEL_108;
          }
          BOOL v43 = *(const char **)(v4 + 16);
          if (!v43) {
            BOOL v43 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint32_t v50 = "__nw_protocol_notify";
          __int16 v51 = 2082;
          v52 = (void *)v43;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
          goto LABEL_87;
        }

        if (v34)
        {
          v35 = *(const char **)(v4 + 16);
          if (!v35) {
            v35 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          uint32_t v50 = "__nw_protocol_notify";
          __int16 v51 = 2082;
          v52 = (void *)v35;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          __int16 v55 = 2082;
          v56 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
LABEL_108:
        if (!v20) {
          goto LABEL_13;
        }
        goto LABEL_109;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint32_t v50 = "__nw_protocol_notify";
      v20 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        uint32_t v50 = "__nw_protocol_notify";
        os_log_type_t v24 = "%{public}s called with null type";
      }

      else if (v47)
      {
        v40 = (char *)__nw_create_backtrace_string();
        __int16 v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v41 = os_log_type_enabled(v31, type);
        if (v40)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            uint32_t v50 = "__nw_protocol_notify";
            __int16 v51 = 2082;
            v52 = v40;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v40);
          if (!v20)
          {
LABEL_13:
            if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v15 = *(void *)(v3 + 88);
              if (v15)
              {
                uint64_t v16 = v15 - 1;
                *(void *)(v3 + 88) = v16;
                if (!v16)
                {
                  uint64_t v17 = *(void (***)(void))(v3 + 64);
                  if (v17)
                  {
                    *(void *)(v3 + 64) = 0LL;
                    v17[2](v17);
                    _Block_release(v17);
                  }

                  if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                  {
                    uint64_t v18 = *(const void **)(v3 + 64);
                    if (v18) {
                      _Block_release(v18);
                    }
                  }

void nw_protocol_notify_quiet(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    return;
  }
  if (!a2) {
    return;
  }
  uint64_t v6 = *(void (**)(uint64_t, uint64_t))(v4 + 160);
  if (!v6) {
    return;
  }
  v7 = *(void **)(a1 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v8 = *(void *)(a1 + 88);
    if (v8) {
      *(void *)(a1 + 88) = v8 + 1;
    }
  }

  uint64_t v9 = *(void **)(a2 + 40);
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v10 = *(void *)(a2 + 88);
    if (v10) {
      *(void *)(a2 + 88) = v10 + 1;
    }
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "__nw_protocol_notify";
    v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "__nw_protocol_notify";
      os_log_type_t v22 = "%{public}s called with null type";
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v24 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "__nw_protocol_notify";
          __int16 v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_48;
      }

      if (!v24)
      {
LABEL_48:
        if (v19) {
          free(v19);
        }
        goto LABEL_13;
      }

      *(_DWORD *)buf = 136446210;
      v28 = "__nw_protocol_notify";
      os_log_type_t v22 = "%{public}s called with null type, no backtrace";
    }

    else
    {
      v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "__nw_protocol_notify";
      os_log_type_t v22 = "%{public}s called with null type, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_48;
  }

  v6(a1, a2);
LABEL_13:
  if (v9 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v11 = *(void *)(a2 + 88);
    if (v11)
    {
      uint64_t v12 = v11 - 1;
      *(void *)(a2 + 88) = v12;
      if (!v12)
      {
        uint64_t v13 = *(void (***)(void))(a2 + 64);
        if (v13)
        {
          *(void *)(a2 + 64) = 0LL;
          v13[2](v13);
          _Block_release(v13);
        }

        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          uint64_t v14 = *(const void **)(a2 + 64);
          if (v14) {
            _Block_release(v14);
          }
        }

        free((void *)a2);
      }
    }
  }

  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v15 = *(void *)(a1 + 88);
    if (v15)
    {
      uint64_t v16 = v15 - 1;
      *(void *)(a1 + 88) = v16;
      if (!v16)
      {
        uint64_t v17 = *(void (***)(void))(a1 + 64);
        if (v17)
        {
          *(void *)(a1 + 64) = 0LL;
          v17[2](v17);
          _Block_release(v17);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v18 = *(const void **)(a1 + 64);
          if (v18) {
            _Block_release(v18);
          }
        }

        free((void *)a1);
      }
    }
  }

uint64_t nw_protocol_notify_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 160) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_updated_path(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v5 = *(void **)(a1 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(a1 + 88);
      if (v6) {
        *(void *)(a1 + 88) = v6 + 1;
      }
    }

    if (a2)
    {
      v7 = *(void **)(a2 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a2 + 88);
        if (v8) {
          *(void *)(a2 + 88) = v8 + 1;
        }
      }

      if (a3)
      {
        uint64_t v9 = *(void *)(a1 + 24);
        if (v9)
        {
          uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 168);
          if (v10)
          {
            uint64_t v11 = v10(a1, a2);
            if (v7 == &nw_protocol_ref_counted_handle)
            {
LABEL_13:
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v17 = *(void *)(a2 + 88);
                if (v17)
                {
                  uint64_t v18 = v17 - 1;
                  *(void *)(a2 + 88) = v18;
                  if (!v18)
                  {
                    v19 = *(void (***)(void))(a2 + 64);
                    if (v19)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v19[2](v19);
                      _Block_release(v19);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      v20 = *(const void **)(a2 + 64);
                      if (v20) {
                        _Block_release(v20);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }
            }

uint64_t nw_protocol_updated_path_quiet(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  if (a3)
  {
    if (a2)
    {
      v7 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 168);
      if (v7)
      {
        uint64_t v8 = *(void **)(a1 + 40);
        if (v8 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v9 = *(void *)(a1 + 88);
          if (v9) {
            *(void *)(a1 + 88) = v9 + 1;
          }
        }

        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v10 = *(void *)(a2 + 88);
          if (v10) {
            *(void *)(a2 + 88) = v10 + 1;
          }
          uint64_t v5 = v7(a1, a2);
          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v12 = *(void *)(a2 + 88);
            if (v12)
            {
              uint64_t v13 = v12 - 1;
              *(void *)(a2 + 88) = v13;
              if (!v13)
              {
                uint64_t v14 = *(void (***)(void))(a2 + 64);
                if (v14)
                {
                  *(void *)(a2 + 64) = 0LL;
                  v14[2](v14);
                  _Block_release(v14);
                }

                if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                {
                  uint64_t v15 = *(const void **)(a2 + 64);
                  if (v15) {
                    _Block_release(v15);
                  }
                }

                free((void *)a2);
              }
            }
          }
        }

        else
        {
          uint64_t v5 = v7(a1, a2);
        }

        if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v16 = *(void *)(a1 + 88);
          if (v16)
          {
            uint64_t v17 = v16 - 1;
            *(void *)(a1 + 88) = v17;
            if (!v17)
            {
              uint64_t v18 = *(void (***)(void))(a1 + 64);
              if (v18)
              {
                *(void *)(a1 + 64) = 0LL;
                v18[2](v18);
                _Block_release(v18);
              }

              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                v19 = *(const void **)(a1 + 64);
                if (v19) {
                  _Block_release(v19);
                }
              }

              free((void *)a1);
            }
          }
        }
      }
    }
  }

  return v5;
}

uint64_t nw_protocol_updated_path_is_valid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      LODWORD(v3) = *(void *)(v3 + 168) != 0LL;
    }
  }

  else
  {
    LODWORD(v3) = 0;
  }

  if (!a2) {
    LODWORD(v3) = 0;
  }
  if (a3) {
    return v3;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_link_state(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = a2;
    uint64_t v4 = (uint64_t)a1;
    uint64_t v5 = (void *)a1[5];
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = a1[11];
      if (v6) {
        a1[11] = v6 + 1;
      }
    }

    if (a2)
    {
      v7 = *(void **)(a2 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a2 + 88);
        if (v8) {
          *(void *)(a2 + 88) = v8 + 1;
        }
      }

      if (a3)
      {
        uint64_t v9 = a1[3];
        if (v9)
        {
          uint64_t v10 = *(void (**)(void *, uint64_t))(v9 + 104);
          if (v10)
          {
            v10(a1, a2);
            goto LABEL_13;
          }
        }

        __nwlog_obj();
        v19 = *(const char **)(v4 + 16);
        *(_DWORD *)buf = 136446722;
        uint32_t v50 = "__nw_protocol_link_state";
        if (!v19) {
          v19 = "invalid";
        }
        __int16 v51 = 2082;
        v52 = (void *)v19;
        __int16 v53 = 2048;
        uint64_t v54 = v4;
        v20 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v47 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_108;
          }
          os_log_type_t v23 = *(const char **)(v4 + 16);
          if (!v23) {
            os_log_type_t v23 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint32_t v50 = "__nw_protocol_link_state";
          __int16 v51 = 2082;
          v52 = (void *)v23;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid link_state callback";
LABEL_87:
          v44 = v21;
          os_log_type_t v45 = v22;
          uint32_t v46 = 32;
LABEL_107:
          _os_log_impl(&dword_181A5C000, v44, v45, v24, buf, v46);
          goto LABEL_108;
        }

        if (!v47)
        {
          os_log_type_t v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_108;
          }
          v42 = *(const char **)(v4 + 16);
          if (!v42) {
            v42 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint32_t v50 = "__nw_protocol_link_state";
          __int16 v51 = 2082;
          v52 = (void *)v42;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid link_state callback, backtrace limit exceeded";
          goto LABEL_87;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v34 = os_log_type_enabled(v21, type);
        if (!backtrace_string)
        {
          if (!v34) {
            goto LABEL_108;
          }
          BOOL v43 = *(const char **)(v4 + 16);
          if (!v43) {
            BOOL v43 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint32_t v50 = "__nw_protocol_link_state";
          __int16 v51 = 2082;
          v52 = (void *)v43;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid link_state callback, no backtrace";
          goto LABEL_87;
        }

        if (v34)
        {
          v35 = *(const char **)(v4 + 16);
          if (!v35) {
            v35 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          uint32_t v50 = "__nw_protocol_link_state";
          __int16 v51 = 2082;
          v52 = (void *)v35;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          __int16 v55 = 2082;
          v56 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid link_state callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
LABEL_108:
        if (!v20) {
          goto LABEL_13;
        }
        goto LABEL_109;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint32_t v50 = "__nw_protocol_link_state";
      v20 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        uint32_t v50 = "__nw_protocol_link_state";
        os_log_type_t v24 = "%{public}s called with null link_info";
      }

      else if (v47)
      {
        v40 = (char *)__nw_create_backtrace_string();
        uint64_t v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v41 = os_log_type_enabled(v31, type);
        if (v40)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            uint32_t v50 = "__nw_protocol_link_state";
            __int16 v51 = 2082;
            v52 = v40;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null link_info, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v40);
          if (!v20)
          {
LABEL_13:
            if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v15 = *(void *)(v3 + 88);
              if (v15)
              {
                uint64_t v16 = v15 - 1;
                *(void *)(v3 + 88) = v16;
                if (!v16)
                {
                  uint64_t v17 = *(void (***)(void))(v3 + 64);
                  if (v17)
                  {
                    *(void *)(v3 + 64) = 0LL;
                    v17[2](v17);
                    _Block_release(v17);
                  }

                  if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                  {
                    uint64_t v18 = *(const void **)(v3 + 64);
                    if (v18) {
                      _Block_release(v18);
                    }
                  }

void nw_protocol_link_state_quiet(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4)
    {
      if (a3)
      {
        if (a2)
        {
          uint64_t v6 = *(void (**)(uint64_t, uint64_t))(v4 + 104);
          if (v6)
          {
            v7 = *(void **)(a1 + 40);
            if (v7 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v8 = *(void *)(a1 + 88);
              if (v8) {
                *(void *)(a1 + 88) = v8 + 1;
              }
            }

            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9) {
                *(void *)(a2 + 88) = v9 + 1;
              }
              v6(a1, a2);
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v10 = *(void *)(a2 + 88);
                if (v10)
                {
                  uint64_t v11 = v10 - 1;
                  *(void *)(a2 + 88) = v11;
                  if (!v11)
                  {
                    uint64_t v12 = *(void (***)(void))(a2 + 64);
                    if (v12)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v12[2](v12);
                      _Block_release(v12);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      uint64_t v13 = *(const void **)(a2 + 64);
                      if (v13) {
                        _Block_release(v13);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }
            }

            else
            {
              v6(a1, a2);
            }

            if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v14 = *(void *)(a1 + 88);
              if (v14)
              {
                uint64_t v15 = v14 - 1;
                *(void *)(a1 + 88) = v15;
                if (!v15)
                {
                  uint64_t v16 = *(void (***)(void))(a1 + 64);
                  if (v16)
                  {
                    *(void *)(a1 + 64) = 0LL;
                    v16[2](v16);
                    _Block_release(v16);
                  }

                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    uint64_t v17 = *(const void **)(a1 + 64);
                    if (v17) {
                      _Block_release(v17);
                    }
                  }

                  free((void *)a1);
                }
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_link_state_is_valid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      LODWORD(v3) = *(void *)(v3 + 104) != 0LL;
    }
  }

  else
  {
    LODWORD(v3) = 0;
  }

  if (!a2) {
    LODWORD(v3) = 0;
  }
  if (a3) {
    return v3;
  }
  else {
    return 0LL;
  }
}

BOOL nw_protocol_one_to_one_callbacks_new()
{
  v0 = calloc(1uLL, 0x110uLL);
  v1 = v0;
  if (v0)
  {
    void *v0 = nw_protocol_default_add_input_handler;
    v0[1] = nw_protocol_default_remove_input_handler;
    v0[8] = nw_protocol_default_input_available;
    v0[9] = nw_protocol_default_output_available;
    v0[10] = nw_protocol_default_get_input_frames;
    v0[11] = nw_protocol_default_get_output_frames;
    v0[12] = nw_protocol_default_finalize_output_frames;
    v0[13] = nw_protocol_default_link_state;
    v0[16] = nw_protocol_default_get_local;
    v0[17] = nw_protocol_default_get_remote;
    v0[14] = nw_protocol_default_get_parameters;
    v0[15] = nw_protocol_default_get_path;
    v0[24] = nw_protocol_default_output_finished;
    v0[25] = nw_protocol_default_get_output_local;
    v0[2] = nw_protocol_default_replace_input_handler;
    v0[3] = nw_protocol_default_connect;
    v0[4] = nw_protocol_default_disconnect;
    v0[5] = nw_protocol_default_connected;
    v0[6] = nw_protocol_default_disconnected;
    v0[7] = nw_protocol_default_error;
    v0[32] = nw_protocol_default_reset;
    v0[33] = nw_protocol_default_input_flush;
    v0[22] = nw_protocol_default_supports_external_data;
    v0[23] = nw_protocol_default_input_finished;
    v0[26] = nw_protocol_default_get_output_interface;
    v0[27] = nw_protocol_default_waiting_for_output;
    v0[18] = nw_protocol_default_register_notification;
    v0[19] = nw_protocol_default_unregister_notification;
    v0[20] = nw_protocol_default_notify;
    v0[21] = nw_protocol_default_updated_path;
    v0[28] = nw_protocol_default_copy_info;
    v0[29] = nw_protocol_default_add_listen_handler;
    v0[30] = nw_protocol_default_remove_listen_handler;
    v0[31] = nw_protocol_default_get_message_properties;
    return (BOOL)v1;
  }

  uint64_t v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    MEMORY[0x100] = 0u;
    MEMORY[0xF0] = 0u;
    MEMORY[0xE0] = 0u;
    MEMORY[0xD0] = 0u;
    MEMORY[0xC0] = 0u;
    MEMORY[0xB0] = 0u;
    MEMORY[0xA0] = 0u;
    MEMORY[0x90] = 0u;
    MEMORY[0x80] = 0u;
    MEMORY[0x70] = 0u;
    MEMORY[0x60] = 0u;
    MEMORY[0x50] = 0u;
    MEMORY[0x40] = 0u;
    MEMORY[0x30] = 0u;
    MEMORY[0x20] = 0u;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    nw_protocol_set_default_one_to_one_callbacks(0LL);
    return (BOOL)v1;
  }

  __break(1u);
  return result;
}

void nw_protocol_callbacks_set_add_input_handler(void *a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *a1 = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
        uint64_t v5 = "%{public}s called with null add_input_handler";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
        uint64_t v5 = "%{public}s called with null add_input_handler, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null add_input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
        uint64_t v5 = "%{public}s called with null add_input_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_add_input_handler";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_replace_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 16) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
        uint64_t v5 = "%{public}s called with null replace_input_handler";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
        uint64_t v5 = "%{public}s called with null replace_input_handler, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null replace_input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
        uint64_t v5 = "%{public}s called with null replace_input_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_replace_input_handler";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_remove_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 8) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
        uint64_t v5 = "%{public}s called with null remove_input_handler";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
        uint64_t v5 = "%{public}s called with null remove_input_handler, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null remove_input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
        uint64_t v5 = "%{public}s called with null remove_input_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_input_handler";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_add_listen_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 232) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
        uint64_t v5 = "%{public}s called with null add_listen_handler";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
        uint64_t v5 = "%{public}s called with null add_listen_handler, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null add_listen_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
        uint64_t v5 = "%{public}s called with null add_listen_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_add_listen_handler";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_remove_listen_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 240) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
        uint64_t v5 = "%{public}s called with null remove_listen_handler";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
        uint64_t v5 = "%{public}s called with null remove_listen_handler, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null remove_listen_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
        uint64_t v5 = "%{public}s called with null remove_listen_handler, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_remove_listen_handler";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_input_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 80) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
        uint64_t v5 = "%{public}s called with null get_input_frames";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
        uint64_t v5 = "%{public}s called with null get_input_frames, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_input_frames, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
        uint64_t v5 = "%{public}s called with null get_input_frames, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_input_frames";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 88) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
        uint64_t v5 = "%{public}s called with null get_output_frames";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
        uint64_t v5 = "%{public}s called with null get_output_frames, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_output_frames, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
        uint64_t v5 = "%{public}s called with null get_output_frames, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_frames";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 96) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
        uint64_t v5 = "%{public}s called with null finalize_output_frames";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
        uint64_t v5 = "%{public}s called with null finalize_output_frames, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null finalize_output_frames, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
        uint64_t v5 = "%{public}s called with null finalize_output_frames, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_finalize_output_frames";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 112) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
        uint64_t v5 = "%{public}s called with null get_parameters";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
        uint64_t v5 = "%{public}s called with null get_parameters, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
        uint64_t v5 = "%{public}s called with null get_parameters, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_parameters";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_path(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 120) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_path";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_path";
        uint64_t v5 = "%{public}s called with null get_path";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_path";
        uint64_t v5 = "%{public}s called with null get_path, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_path";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_path";
        uint64_t v5 = "%{public}s called with null get_path, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_path";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_path";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_path";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_path";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_path";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_remote_endpoint(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 136) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
        uint64_t v5 = "%{public}s called with null get_remote_endpoint";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
        uint64_t v5 = "%{public}s called with null get_remote_endpoint, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_remote_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
        uint64_t v5 = "%{public}s called with null get_remote_endpoint, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_remote_endpoint";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_local_endpoint(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 128) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
        uint64_t v5 = "%{public}s called with null get_local_endpoint";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
        uint64_t v5 = "%{public}s called with null get_local_endpoint, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_local_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
        uint64_t v5 = "%{public}s called with null get_local_endpoint, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_local_endpoint";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_output_local_endpoint(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 200) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
        uint64_t v5 = "%{public}s called with null get_output_local_endpoint";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
        uint64_t v5 = "%{public}s called with null get_output_local_endpoint, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_output_local_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
        uint64_t v5 = "%{public}s called with null get_output_local_endpoint, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_local_endpoint";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_output_interface(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 208) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
        uint64_t v5 = "%{public}s called with null get_output_interface";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
        uint64_t v5 = "%{public}s called with null get_output_interface, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_output_interface, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
        uint64_t v5 = "%{public}s called with null get_output_interface, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_output_interface";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 24) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_connect";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_connect";
        uint64_t v5 = "%{public}s called with null connect";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_connect";
        uint64_t v5 = "%{public}s called with null connect, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_connect";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null connect, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_connect";
        uint64_t v5 = "%{public}s called with null connect, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_connect";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_connect";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_connect";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_connect";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_connect";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_connected(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 40) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_connected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_connected";
        uint64_t v5 = "%{public}s called with null connected";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_connected";
        uint64_t v5 = "%{public}s called with null connected, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_connected";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null connected, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_connected";
        uint64_t v5 = "%{public}s called with null connected, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_connected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_connected";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_connected";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_connected";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_connected";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_disconnect(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 32) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
        uint64_t v5 = "%{public}s called with null disconnect";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
        uint64_t v5 = "%{public}s called with null disconnect, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null disconnect, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
        uint64_t v5 = "%{public}s called with null disconnect, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnect";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 48) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
        uint64_t v5 = "%{public}s called with null disconnected";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
        uint64_t v5 = "%{public}s called with null disconnected, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null disconnected, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
        uint64_t v5 = "%{public}s called with null disconnected, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_disconnected";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_input_available(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 64) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_input_available";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_available";
        uint64_t v5 = "%{public}s called with null input_available";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_available";
        uint64_t v5 = "%{public}s called with null input_available, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_input_available";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null input_available, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_available";
        uint64_t v5 = "%{public}s called with null input_available, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_input_available";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_available";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_available";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_available";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_input_available";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_output_available(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 72) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_output_available";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_output_available";
        uint64_t v5 = "%{public}s called with null output_available";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_output_available";
        uint64_t v5 = "%{public}s called with null output_available, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_output_available";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null output_available, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_output_available";
        uint64_t v5 = "%{public}s called with null output_available, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_output_available";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_output_available";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_output_available";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_output_available";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_output_available";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_input_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 184) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
        uint64_t v5 = "%{public}s called with null input_finished";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
        uint64_t v5 = "%{public}s called with null input_finished, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null input_finished, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
        uint64_t v5 = "%{public}s called with null input_finished, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_input_finished";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_output_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 192) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
        uint64_t v5 = "%{public}s called with null output_finished";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
        uint64_t v5 = "%{public}s called with null output_finished, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null output_finished, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
        uint64_t v5 = "%{public}s called with null output_finished, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_output_finished";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_input_flush(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 264) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
        uint64_t v5 = "%{public}s called with null input_flush";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
        uint64_t v5 = "%{public}s called with null input_flush, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null input_flush, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
        uint64_t v5 = "%{public}s called with null input_flush, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_input_flush";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_error(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 56) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_error";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_error";
        uint64_t v5 = "%{public}s called with null error";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_error";
        uint64_t v5 = "%{public}s called with null error, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_error";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null error, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_error";
        uint64_t v5 = "%{public}s called with null error, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_error";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_error";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_error";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_error";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_error";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_reset(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 256) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_reset";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_reset";
        uint64_t v5 = "%{public}s called with null reset";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_reset";
        uint64_t v5 = "%{public}s called with null reset, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_reset";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null reset, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_reset";
        uint64_t v5 = "%{public}s called with null reset, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_reset";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_reset";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_reset";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_reset";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_reset";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_get_message_properties(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 248) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
        uint64_t v5 = "%{public}s called with null get_message_properties";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
        uint64_t v5 = "%{public}s called with null get_message_properties, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null get_message_properties, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
        uint64_t v5 = "%{public}s called with null get_message_properties, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_get_message_properties";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_copy_info(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 224) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
        uint64_t v5 = "%{public}s called with null copy_info";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
        uint64_t v5 = "%{public}s called with null copy_info, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null copy_info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
        uint64_t v5 = "%{public}s called with null copy_info, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_copy_info";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_supports_external_data(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 176) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
        uint64_t v5 = "%{public}s called with null supports_external_data";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
        uint64_t v5 = "%{public}s called with null supports_external_data, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null supports_external_data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
        uint64_t v5 = "%{public}s called with null supports_external_data, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_supports_external_data";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_waiting_for_output(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 216) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
        uint64_t v5 = "%{public}s called with null waiting_for_output";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
        uint64_t v5 = "%{public}s called with null waiting_for_output, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null waiting_for_output, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
        uint64_t v5 = "%{public}s called with null waiting_for_output, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_waiting_for_output";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_register_notification(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 144) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
        uint64_t v5 = "%{public}s called with null register_notification";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
        uint64_t v5 = "%{public}s called with null register_notification, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null register_notification, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
        uint64_t v5 = "%{public}s called with null register_notification, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_register_notification";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_unregister_notification(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 152) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
        uint64_t v5 = "%{public}s called with null unregister_notification";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
        uint64_t v5 = "%{public}s called with null unregister_notification, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null unregister_notification, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
        uint64_t v5 = "%{public}s called with null unregister_notification, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_unregister_notification";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_notify(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 160) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_notify";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_notify";
        uint64_t v5 = "%{public}s called with null notify";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_notify";
        uint64_t v5 = "%{public}s called with null notify, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_notify";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null notify, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_notify";
        uint64_t v5 = "%{public}s called with null notify, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_notify";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_notify";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_notify";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_notify";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_notify";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_updated_path(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 168) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
        uint64_t v5 = "%{public}s called with null updated_path";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
        uint64_t v5 = "%{public}s called with null updated_path, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null updated_path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
        uint64_t v5 = "%{public}s called with null updated_path, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_updated_path";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_callbacks_set_link_state(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 104) = a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_link_state";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_link_state";
        uint64_t v5 = "%{public}s called with null link_state";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_link_state";
        uint64_t v5 = "%{public}s called with null link_state, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_callbacks_set_link_state";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null link_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_callbacks_set_link_state";
        uint64_t v5 = "%{public}s called with null link_state, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_callbacks_set_link_state";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_link_state";
      uint64_t v5 = "%{public}s called with null callbacks";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_link_state";
      uint64_t v5 = "%{public}s called with null callbacks, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_protocol_callbacks_set_link_state";
      uint64_t v5 = "%{public}s called with null callbacks, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_protocol_callbacks_set_link_state";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

uint64_t nw_protocol_new(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v25 = "nw_protocol_new";
    char v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v25 = "nw_protocol_new";
        uint64_t v13 = "%{public}s called with null instance_size";
LABEL_38:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      }

void nw_protocol_set_identifier(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)(a1 + 16) = a2;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_set_identifier";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_identifier";
      uint64_t v5 = "%{public}s called with null protocol";
      goto LABEL_17;
    }

    if (!v8)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_identifier";
      uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v11 = "__nw_protocol_set_identifier";
        __int16 v12 = 2082;
        uint64_t v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_identifier";
      uint64_t v5 = "%{public}s called with null protocol, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

void nw_protocol_set_callbacks(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)(a1 + 24) = a2;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_set_callbacks";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_callbacks";
      uint64_t v5 = "%{public}s called with null protocol";
      goto LABEL_17;
    }

    if (!v8)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_callbacks";
      uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v11 = "__nw_protocol_set_callbacks";
        __int16 v12 = 2082;
        uint64_t v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_callbacks";
      uint64_t v5 = "%{public}s called with null protocol, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

void nw_protocol_set_handle(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)(a1 + 40) = a2;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_set_handle";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_handle";
      uint64_t v5 = "%{public}s called with null protocol";
      goto LABEL_17;
    }

    if (!v8)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_handle";
      uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v11 = "__nw_protocol_set_handle";
        __int16 v12 = 2082;
        uint64_t v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_handle";
      uint64_t v5 = "%{public}s called with null protocol, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t nw_protocol_downcast(uint64_t result)
{
  if (result)
  {
    if (*(_UNKNOWN **)(result + 40) == &nw_protocol_ref_counted_handle) {
      result += 96LL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void nw_protocol_destroy(uint64_t a1, void *aBlock)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    unint64_t v4 = atomic_load(&nw_protocol_get_zombie_callbacks(void)::once_flag);
    if (v4 != -1LL)
    {
      *(void *)buf = &v17;
      *(void *)os_log_type_t type = buf;
      std::__call_once( &nw_protocol_get_zombie_callbacks(void)::once_flag,  type,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<nw_protocol_get_zombie_callbacks(void)::$_0 &&>>);
    }

    *(void *)(a1 - 72) = &nw_protocol_get_zombie_callbacks(void)::callbacks;
    if (aBlock) {
      aBlock = _Block_copy(aBlock);
    }
    char v5 = *(_BYTE *)(a1 - 24);
    if ((v5 & 1) != 0)
    {
      size_t v6 = *(const void **)(a1 - 32);
      if (v6)
      {
        _Block_release(v6);
        char v5 = *(_BYTE *)(a1 - 24);
      }
    }

    *(void *)(a1 - 32) = aBlock;
    *(_BYTE *)(a1 - 24) = v5 | 1;
    if (*(_UNKNOWN **)(a1 - 56) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *(void *)(a1 - 8);
      if (v7)
      {
        uint64_t v8 = v7 - 1;
        *(void *)(a1 - 8) = v8;
        if (!v8)
        {
          if (aBlock)
          {
            *(void *)(a1 - 32) = 0LL;
            (*((void (**)(void *))aBlock + 2))(aBlock);
            _Block_release(aBlock);
            if ((*(_BYTE *)(a1 - 24) & 1) != 0)
            {
              BOOL v9 = *(const void **)(a1 - 32);
              if (v9) {
                _Block_release(v9);
              }
            }
          }

          *(void *)(a1 - 32) = 0LL;
          char v10 = (char *)(a1 - 96);
          goto LABEL_18;
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_destroy";
  uint64_t v11 = (const char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v11, type, &v17))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_destroy";
      uint64_t v14 = "%{public}s called with null instance";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      goto LABEL_33;
    }

    if (!v17)
    {
      __int16 v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_destroy";
      uint64_t v14 = "%{public}s called with null instance, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type[0];
    BOOL v16 = os_log_type_enabled(v12, type[0]);
    if (!backtrace_string)
    {
      if (!v16) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_destroy";
      uint64_t v14 = "%{public}s called with null instance, no backtrace";
      goto LABEL_32;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_destroy";
      __int16 v20 = 2082;
      BOOL v21 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
  }

void std::__call_once_proxy[abi:nn180100]<std::tuple<nw_protocol_get_zombie_callbacks(void)::$_0 &&>>()
{
  nw_protocol_get_zombie_callbacks(void)::callbacks = (uint64_t)nw_protocol_zombie_add_input_handler;
  unk_18C45EBF0 = nw_protocol_zombie_remove_input_handler;
  qword_18C45EC28 = (uint64_t)nw_protocol_zombie_input_available;
  unk_18C45EC30 = nw_protocol_zombie_output_available;
  qword_18C45EC38 = (uint64_t)nw_protocol_zombie_get_input_frames;
  unk_18C45EC40 = nw_protocol_zombie_get_output_frames;
  qword_18C45EC48 = (uint64_t)nw_protocol_zombie_finalize_output_frames;
  unk_18C45EC50 = nw_protocol_zombie_link_state;
  qword_18C45EC68 = (uint64_t)nw_protocol_zombie_get_local_endpoint;
  unk_18C45EC70 = nw_protocol_zombie_get_remote_endpoint;
  qword_18C45EC58 = (uint64_t)nw_protocol_zombie_get_parameters;
  unk_18C45EC60 = nw_protocol_zombie_get_path;
  qword_18C45ECA8 = (uint64_t)nw_protocol_zombie_output_finished;
  unk_18C45ECB0 = nw_protocol_zombie_get_output_local_endpoint;
  qword_18C45EBF8 = (uint64_t)nw_protocol_zombie_replace_input_handler;
  unk_18C45EC00 = nw_protocol_zombie_connect;
  qword_18C45EC08 = (uint64_t)nw_protocol_zombie_disconnect;
  unk_18C45EC10 = nw_protocol_zombie_connected;
  qword_18C45EC18 = (uint64_t)nw_protocol_zombie_disconnected;
  unk_18C45EC20 = nw_protocol_zombie_error;
  qword_18C45ECE8 = (uint64_t)nw_protocol_zombie_reset;
  unk_18C45ECF0 = nw_protocol_zombie_input_flush;
  qword_18C45EC98 = (uint64_t)nw_protocol_zombie_supports_external_data;
  unk_18C45ECA0 = nw_protocol_zombie_input_finished;
  qword_18C45ECB8 = (uint64_t)nw_protocol_zombie_get_output_interface;
  unk_18C45ECC0 = nw_protocol_zombie_waiting_for_output;
  qword_18C45EC78 = (uint64_t)nw_protocol_zombie_register_notification;
  unk_18C45EC80 = nw_protocol_zombie_unregister_notification;
  qword_18C45EC88 = (uint64_t)nw_protocol_zombie_notify;
  unk_18C45EC90 = nw_protocol_zombie_updated_path;
  qword_18C45ECC8 = (uint64_t)nw_protocol_zombie_copy_info;
  unk_18C45ECD0 = nw_protocol_zombie_add_listen_handler;
  qword_18C45ECD8 = (uint64_t)nw_protocol_zombie_remove_listen_handler;
  unk_18C45ECE0 = nw_protocol_zombie_get_message_properties;
}

uint64_t nw_protocol_zombie_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  char v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    char v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  os_log_type_t v24 = "nw_protocol_zombie_add_input_handler";
  __int16 v25 = 2080;
  __int16 v26 = identifier;
  __int16 v27 = 2048;
  __int16 v28 = a1;
  __int16 v29 = 2080;
  uint64_t v30 = v5;
  __int16 v31 = 2048;
  os_log_type_t v32 = a2;
  size_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v6, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      char v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        char v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      os_log_type_t v24 = "nw_protocol_zombie_add_input_handler";
      __int16 v25 = 2080;
      __int16 v26 = v9;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      uint64_t v30 = v10;
      __int16 v31 = 2048;
      os_log_type_t v32 = a2;
      uint64_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      char v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        char v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      os_log_type_t v24 = "nw_protocol_zombie_add_input_handler";
      __int16 v25 = 2080;
      __int16 v26 = v16;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      uint64_t v30 = v17;
      __int16 v31 = 2048;
      os_log_type_t v32 = a2;
      uint64_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      os_log_type_t v24 = "nw_protocol_zombie_add_input_handler";
      __int16 v25 = 2080;
      __int16 v26 = v18;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      uint64_t v30 = v19;
      __int16 v31 = 2048;
      os_log_type_t v32 = a2;
      uint64_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v14 = a1->identifier;
      }
      uint64_t v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        uint64_t v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      os_log_type_t v24 = "nw_protocol_zombie_add_input_handler";
      __int16 v25 = 2080;
      __int16 v26 = v14;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      uint64_t v30 = v15;
      __int16 v31 = 2048;
      os_log_type_t v32 = a2;
      __int16 v33 = 2082;
      BOOL v34 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, input_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  uint64_t v7 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    uint64_t v7 = a2->identifier;
  }
  os_log_type_t v8 = (nw_protocol_identifier *)"invalid";
  if (a3 && a3->identifier) {
    os_log_type_t v8 = a3->identifier;
  }
  *(_DWORD *)buf = 136447746;
  __int16 v31 = "nw_protocol_zombie_replace_input_handler";
  __int16 v32 = 2080;
  __int16 v33 = identifier;
  __int16 v34 = 2048;
  uint64_t v35 = a1;
  __int16 v36 = 2080;
  BOOL v37 = v7;
  __int16 v38 = 2048;
  BOOL v39 = a2;
  __int16 v40 = 2080;
  BOOL v41 = v8;
  __int16 v42 = 2048;
  BOOL v43 = a3;
  BOOL v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v9, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_60;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      BOOL v13 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v13 = a2->identifier;
      }
      uint64_t v14 = (nw_protocol_identifier *)"invalid";
      if (a3 && a3->identifier) {
        uint64_t v14 = a3->identifier;
      }
      *(_DWORD *)buf = 136447746;
      __int16 v31 = "nw_protocol_zombie_replace_input_handler";
      __int16 v32 = 2080;
      __int16 v33 = v12;
      __int16 v34 = 2048;
      uint64_t v35 = a1;
      __int16 v36 = 2080;
      BOOL v37 = v13;
      __int16 v38 = 2048;
      BOOL v39 = a2;
      __int16 v40 = 2080;
      BOOL v41 = v14;
      __int16 v42 = 2048;
      BOOL v43 = a3;
      uint64_t v15 = "%{public}s protocol %s:%p, old_input_handler %s:%p, new_input_handler %s:%p";
LABEL_59:
      _os_log_impl(&dword_181A5C000, v10, v11, v15, buf, 0x48u);
      goto LABEL_60;
    }

    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_60;
      }
      char v21 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v21 = a1->identifier;
      }
      uint64_t v22 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        uint64_t v22 = a2->identifier;
      }
      os_log_type_t v23 = (nw_protocol_identifier *)"invalid";
      if (a3 && a3->identifier) {
        os_log_type_t v23 = a3->identifier;
      }
      *(_DWORD *)buf = 136447746;
      __int16 v31 = "nw_protocol_zombie_replace_input_handler";
      __int16 v32 = 2080;
      __int16 v33 = v21;
      __int16 v34 = 2048;
      uint64_t v35 = a1;
      __int16 v36 = 2080;
      BOOL v37 = v22;
      __int16 v38 = 2048;
      BOOL v39 = a2;
      __int16 v40 = 2080;
      BOOL v41 = v23;
      __int16 v42 = 2048;
      BOOL v43 = a3;
      uint64_t v15 = "%{public}s protocol %s:%p, old_input_handler %s:%p, new_input_handler %s:%p, backtrace limit exceeded";
      goto LABEL_59;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v10 = (os_log_s *)gLogObj;
    os_log_type_t v11 = type;
    BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v17) {
        goto LABEL_60;
      }
      os_log_type_t v24 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v24 = a1->identifier;
      }
      __int16 v25 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v25 = a2->identifier;
      }
      __int16 v26 = (nw_protocol_identifier *)"invalid";
      if (a3 && a3->identifier) {
        __int16 v26 = a3->identifier;
      }
      *(_DWORD *)buf = 136447746;
      __int16 v31 = "nw_protocol_zombie_replace_input_handler";
      __int16 v32 = 2080;
      __int16 v33 = v24;
      __int16 v34 = 2048;
      uint64_t v35 = a1;
      __int16 v36 = 2080;
      BOOL v37 = v25;
      __int16 v38 = 2048;
      BOOL v39 = a2;
      __int16 v40 = 2080;
      BOOL v41 = v26;
      __int16 v42 = 2048;
      BOOL v43 = a3;
      uint64_t v15 = "%{public}s protocol %s:%p, old_input_handler %s:%p, new_input_handler %s:%p, no backtrace";
      goto LABEL_59;
    }

    if (v17)
    {
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      __int16 v20 = (nw_protocol_identifier *)"invalid";
      if (a3 && a3->identifier) {
        __int16 v20 = a3->identifier;
      }
      *(_DWORD *)buf = 136448002;
      __int16 v31 = "nw_protocol_zombie_replace_input_handler";
      __int16 v32 = 2080;
      __int16 v33 = v18;
      __int16 v34 = 2048;
      uint64_t v35 = a1;
      __int16 v36 = 2080;
      BOOL v37 = v19;
      __int16 v38 = 2048;
      BOOL v39 = a2;
      __int16 v40 = 2080;
      BOOL v41 = v20;
      __int16 v42 = 2048;
      BOOL v43 = a3;
      __int16 v44 = 2082;
      os_log_type_t v45 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s protocol %s:%p, old_input_handler %s:%p, new_input_handler %s:%p, dumping backtrace:%{public}s",  buf,  0x52u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  uint64_t v7 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    uint64_t v7 = a2->identifier;
  }
  *(_DWORD *)buf = 136447490;
  __int16 v26 = "nw_protocol_zombie_remove_input_handler";
  __int16 v27 = 2080;
  char v28 = identifier;
  __int16 v29 = 2048;
  uint64_t v30 = a1;
  __int16 v31 = 2080;
  __int16 v32 = v7;
  __int16 v33 = 2048;
  __int16 v34 = a2;
  __int16 v35 = 1024;
  int v36 = a3;
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v12 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_remove_input_handler";
      __int16 v27 = 2080;
      char v28 = v11;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v12;
      __int16 v33 = 2048;
      __int16 v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, input_protocol %s:%p, destroy %{BOOL}d";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v9, v10, v13, buf, 0x3Au);
      goto LABEL_45;
    }

    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_remove_input_handler";
      __int16 v27 = 2080;
      char v28 = v18;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v19;
      __int16 v33 = 2048;
      __int16 v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, input_protocol %s:%p, destroy %{BOOL}d, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_45;
      }
      __int16 v20 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v20 = a1->identifier;
      }
      char v21 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        char v21 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_remove_input_handler";
      __int16 v27 = 2080;
      char v28 = v20;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v21;
      __int16 v33 = 2048;
      __int16 v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, input_protocol %s:%p, destroy %{BOOL}d, no backtrace";
      goto LABEL_44;
    }

    if (v15)
    {
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447746;
      __int16 v26 = "nw_protocol_zombie_remove_input_handler";
      __int16 v27 = 2080;
      char v28 = v16;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v17;
      __int16 v33 = 2048;
      __int16 v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      __int16 v37 = 2082;
      __int16 v38 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s protocol %s:%p, input_protocol %s:%p, destroy %{BOOL}d, dumping backtrace:%{public}s",  buf,  0x44u);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  char v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    char v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_input_available";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  size_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_available";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_available";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_available";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_input_available";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, output_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  char v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    char v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_output_available";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  size_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_output_available";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_output_available";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_output_available";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_output_available";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, output_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  char v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    char v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_input_finished";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  size_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_finished";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_finished";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_finished";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_input_finished";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, output_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  char v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    char v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_output_finished";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  size_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_output_finished";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_output_finished";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_output_finished";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_output_finished";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, output_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_input_flush(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  char v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    char v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_input_flush";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  size_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_flush";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_flush";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v18 = a1->identifier;
      }
      BOOL v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_input_flush";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, output_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_input_flush";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, output_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_input_frames( nw_protocol *a1, nw_protocol *a2, int a3, int a4, int a5, nw_frame_array_s *a6)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  __int16 v12 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    __int16 v12 = a2->identifier;
  }
  *(_DWORD *)buf = 136448002;
  __int16 v31 = "nw_protocol_zombie_get_input_frames";
  __int16 v32 = 2080;
  __int16 v33 = identifier;
  __int16 v34 = 2048;
  __int16 v35 = a1;
  __int16 v36 = 2080;
  __int16 v37 = v12;
  __int16 v38 = 2048;
  uint64_t v39 = a2;
  __int16 v40 = 1024;
  int v41 = a3;
  __int16 v42 = 1024;
  int v43 = a4;
  __int16 v44 = 1024;
  int v45 = a5;
  BOOL v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v13, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)gLogObj;
      os_log_type_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136448002;
      __int16 v31 = "nw_protocol_zombie_get_input_frames";
      __int16 v32 = 2080;
      __int16 v33 = v16;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v17;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      uint64_t v18 = "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v14, v15, v18, buf, 0x46u);
      goto LABEL_45;
    }

    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)gLogObj;
      os_log_type_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      char v23 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v23 = a1->identifier;
      }
      __int16 v24 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v24 = a2->identifier;
      }
      *(_DWORD *)buf = 136448002;
      __int16 v31 = "nw_protocol_zombie_get_input_frames";
      __int16 v32 = 2080;
      __int16 v33 = v23;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v24;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      uint64_t v18 = "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u,"
            " backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)gLogObj;
    os_log_type_t v15 = type;
    BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v20) {
        goto LABEL_45;
      }
      __int16 v25 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v25 = a1->identifier;
      }
      __int16 v26 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v26 = a2->identifier;
      }
      *(_DWORD *)buf = 136448002;
      __int16 v31 = "nw_protocol_zombie_get_input_frames";
      __int16 v32 = 2080;
      __int16 v33 = v25;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v26;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      uint64_t v18 = "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u, no backtrace";
      goto LABEL_44;
    }

    if (v20)
    {
      char v21 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v21 = a1->identifier;
      }
      uint64_t v22 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        uint64_t v22 = a2->identifier;
      }
      *(_DWORD *)buf = 136448258;
      __int16 v31 = "nw_protocol_zombie_get_input_frames";
      __int16 v32 = 2080;
      __int16 v33 = v21;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v22;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      __int16 v46 = 2082;
      char v47 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u, dum ping backtrace:%{public}s",  buf,  0x50u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_output_frames( nw_protocol *a1, nw_protocol *a2, int a3, int a4, int a5, nw_frame_array_s *a6)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  __int16 v12 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    __int16 v12 = a2->identifier;
  }
  *(_DWORD *)buf = 136448002;
  __int16 v31 = "nw_protocol_zombie_get_output_frames";
  __int16 v32 = 2080;
  __int16 v33 = identifier;
  __int16 v34 = 2048;
  __int16 v35 = a1;
  __int16 v36 = 2080;
  __int16 v37 = v12;
  __int16 v38 = 2048;
  uint64_t v39 = a2;
  __int16 v40 = 1024;
  int v41 = a3;
  __int16 v42 = 1024;
  int v43 = a4;
  __int16 v44 = 1024;
  int v45 = a5;
  BOOL v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v13, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)gLogObj;
      os_log_type_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136448002;
      __int16 v31 = "nw_protocol_zombie_get_output_frames";
      __int16 v32 = 2080;
      __int16 v33 = v16;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v17;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      uint64_t v18 = "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v14, v15, v18, buf, 0x46u);
      goto LABEL_45;
    }

    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)gLogObj;
      os_log_type_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      char v23 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v23 = a1->identifier;
      }
      __int16 v24 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v24 = a2->identifier;
      }
      *(_DWORD *)buf = 136448002;
      __int16 v31 = "nw_protocol_zombie_get_output_frames";
      __int16 v32 = 2080;
      __int16 v33 = v23;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v24;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      uint64_t v18 = "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u,"
            " backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)gLogObj;
    os_log_type_t v15 = type;
    BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v20) {
        goto LABEL_45;
      }
      __int16 v25 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v25 = a1->identifier;
      }
      __int16 v26 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v26 = a2->identifier;
      }
      *(_DWORD *)buf = 136448002;
      __int16 v31 = "nw_protocol_zombie_get_output_frames";
      __int16 v32 = 2080;
      __int16 v33 = v25;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v26;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      uint64_t v18 = "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u, no backtrace";
      goto LABEL_44;
    }

    if (v20)
    {
      char v21 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v21 = a1->identifier;
      }
      uint64_t v22 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        uint64_t v22 = a2->identifier;
      }
      *(_DWORD *)buf = 136448258;
      __int16 v31 = "nw_protocol_zombie_get_output_frames";
      __int16 v32 = 2080;
      __int16 v33 = v21;
      __int16 v34 = 2048;
      __int16 v35 = a1;
      __int16 v36 = 2080;
      __int16 v37 = v22;
      __int16 v38 = 2048;
      uint64_t v39 = a2;
      __int16 v40 = 1024;
      int v41 = a3;
      __int16 v42 = 1024;
      int v43 = a4;
      __int16 v44 = 1024;
      int v45 = a5;
      __int16 v46 = 2082;
      char v47 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s protocol %s:%p, input_protocol %s:%p, minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u, dum ping backtrace:%{public}s",  buf,  0x50u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  uint64_t v18 = "nw_protocol_zombie_finalize_output_frames";
  __int16 v19 = 2080;
  BOOL v20 = identifier;
  __int16 v21 = 2048;
  uint64_t v22 = a1;
  unint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v4, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      uint64_t v7 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        uint64_t v7 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v18 = "nw_protocol_zombie_finalize_output_frames";
      __int16 v19 = 2080;
      BOOL v20 = v7;
      __int16 v21 = 2048;
      uint64_t v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v5, v6, v8, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v18 = "nw_protocol_zombie_finalize_output_frames";
      __int16 v19 = 2080;
      BOOL v20 = v12;
      __int16 v21 = 2048;
      uint64_t v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v10) {
        goto LABEL_30;
      }
      BOOL v13 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v13 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v18 = "nw_protocol_zombie_finalize_output_frames";
      __int16 v19 = 2080;
      BOOL v20 = v13;
      __int16 v21 = 2048;
      uint64_t v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v10)
    {
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      uint64_t v18 = "nw_protocol_zombie_finalize_output_frames";
      __int16 v19 = 2080;
      BOOL v20 = v11;
      __int16 v21 = 2048;
      uint64_t v22 = a1;
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_get_message_properties(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v4 = "invalid";
  if (a1 && *(void *)(a1 + 16)) {
    unint64_t v4 = *(const char **)(a1 + 16);
  }
  char v5 = "invalid";
  if (a2 && *(void *)(a2 + 16)) {
    char v5 = *(const char **)(a2 + 16);
  }
  *(_DWORD *)buf = 136447234;
  __int16 v23 = "nw_protocol_zombie_get_message_properties";
  __int16 v24 = 2080;
  uint64_t v25 = v4;
  __int16 v26 = 2048;
  uint64_t v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  uint64_t v31 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v9 = *(const char **)(a1 + 16);
      }
      BOOL v10 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        BOOL v10 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447234;
      __int16 v23 = "nw_protocol_zombie_get_message_properties";
      __int16 v24 = 2080;
      uint64_t v25 = v9;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v16 = *(const char **)(a1 + 16);
      }
      BOOL v17 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        BOOL v17 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447234;
      __int16 v23 = "nw_protocol_zombie_get_message_properties";
      __int16 v24 = 2080;
      uint64_t v25 = v16;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        uint64_t v18 = *(const char **)(a1 + 16);
      }
      __int16 v19 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v19 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447234;
      __int16 v23 = "nw_protocol_zombie_get_message_properties";
      __int16 v24 = 2080;
      uint64_t v25 = v18;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        uint64_t v14 = *(const char **)(a1 + 16);
      }
      char v15 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        char v15 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v23 = "nw_protocol_zombie_get_message_properties";
      __int16 v24 = 2080;
      uint64_t v25 = v14;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, input_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_link_state(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v4 = "invalid";
  if (a1 && *(void *)(a1 + 16)) {
    unint64_t v4 = *(const char **)(a1 + 16);
  }
  char v5 = "invalid";
  if (a2 && *(void *)(a2 + 16)) {
    char v5 = *(const char **)(a2 + 16);
  }
  *(_DWORD *)buf = 136447234;
  __int16 v23 = "nw_protocol_zombie_link_state";
  __int16 v24 = 2080;
  uint64_t v25 = v4;
  __int16 v26 = 2048;
  uint64_t v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  uint64_t v31 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v9 = *(const char **)(a1 + 16);
      }
      BOOL v10 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        BOOL v10 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447234;
      __int16 v23 = "nw_protocol_zombie_link_state";
      __int16 v24 = 2080;
      uint64_t v25 = v9;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v16 = *(const char **)(a1 + 16);
      }
      BOOL v17 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        BOOL v17 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447234;
      __int16 v23 = "nw_protocol_zombie_link_state";
      __int16 v24 = 2080;
      uint64_t v25 = v16;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      uint64_t v18 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        uint64_t v18 = *(const char **)(a1 + 16);
      }
      __int16 v19 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v19 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447234;
      __int16 v23 = "nw_protocol_zombie_link_state";
      __int16 v24 = 2080;
      uint64_t v25 = v18;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      uint64_t v14 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        uint64_t v14 = *(const char **)(a1 + 16);
      }
      char v15 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        char v15 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v23 = "nw_protocol_zombie_link_state";
      __int16 v24 = 2080;
      uint64_t v25 = v14;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      uint64_t v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, other_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_parameters(nw_protocol *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  BOOL v17 = "nw_protocol_zombie_get_parameters";
  __int16 v18 = 2080;
  __int16 v19 = identifier;
  __int16 v20 = 2048;
  __int16 v21 = a1;
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v3, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v6 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v6 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_parameters";
      __int16 v18 = 2080;
      __int16 v19 = v6;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v4, v5, v7, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_parameters";
      __int16 v18 = 2080;
      __int16 v19 = v11;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_parameters";
      __int16 v18 = 2080;
      __int16 v19 = v12;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v9)
    {
      BOOL v10 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v10 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      BOOL v17 = "nw_protocol_zombie_get_parameters";
      __int16 v18 = 2080;
      __int16 v19 = v10;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_local_endpoint(nw_protocol *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  BOOL v17 = "nw_protocol_zombie_get_local_endpoint";
  __int16 v18 = 2080;
  __int16 v19 = identifier;
  __int16 v20 = 2048;
  __int16 v21 = a1;
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v3, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v6 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v6 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v6;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v4, v5, v7, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v11;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v12;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v9)
    {
      BOOL v10 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v10 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      BOOL v17 = "nw_protocol_zombie_get_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v10;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  BOOL v17 = "nw_protocol_zombie_get_remote_endpoint";
  __int16 v18 = 2080;
  __int16 v19 = identifier;
  __int16 v20 = 2048;
  __int16 v21 = a1;
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v3, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v6 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v6 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_remote_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v6;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v4, v5, v7, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_remote_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v11;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_remote_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v12;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v9)
    {
      BOOL v10 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v10 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      BOOL v17 = "nw_protocol_zombie_get_remote_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v10;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_path(nw_protocol *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  BOOL v17 = "nw_protocol_zombie_get_path";
  __int16 v18 = 2080;
  __int16 v19 = identifier;
  __int16 v20 = 2048;
  __int16 v21 = a1;
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v3, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v6 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v6 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_path";
      __int16 v18 = 2080;
      __int16 v19 = v6;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v4, v5, v7, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_path";
      __int16 v18 = 2080;
      __int16 v19 = v11;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_path";
      __int16 v18 = 2080;
      __int16 v19 = v12;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v9)
    {
      BOOL v10 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v10 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      BOOL v17 = "nw_protocol_zombie_get_path";
      __int16 v18 = 2080;
      __int16 v19 = v10;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_updated_path(nw_protocol *a1, nw_protocol *a2, nw_path *a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  uint64_t v7 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    uint64_t v7 = a2->identifier;
  }
  *(_DWORD *)buf = 136447490;
  __int16 v26 = "nw_protocol_zombie_updated_path";
  __int16 v27 = 2080;
  __int16 v28 = identifier;
  __int16 v29 = 2048;
  __int16 v30 = a1;
  __int16 v31 = 2080;
  __int16 v32 = v7;
  __int16 v33 = 2048;
  uint64_t v34 = a2;
  __int16 v35 = 2112;
  __int16 v36 = a3;
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v12 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_updated_path";
      __int16 v27 = 2080;
      __int16 v28 = v11;
      __int16 v29 = 2048;
      __int16 v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v12;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 2112;
      __int16 v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, path %@";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v9, v10, v13, buf, 0x3Eu);
      goto LABEL_45;
    }

    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_updated_path";
      __int16 v27 = 2080;
      __int16 v28 = v18;
      __int16 v29 = 2048;
      __int16 v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v19;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 2112;
      __int16 v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, path %@, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_45;
      }
      __int16 v20 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v20 = a1->identifier;
      }
      __int16 v21 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v21 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_updated_path";
      __int16 v27 = 2080;
      __int16 v28 = v20;
      __int16 v29 = 2048;
      __int16 v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v21;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 2112;
      __int16 v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, path %@, no backtrace";
      goto LABEL_44;
    }

    if (v15)
    {
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447746;
      __int16 v26 = "nw_protocol_zombie_updated_path";
      __int16 v27 = 2080;
      __int16 v28 = v16;
      __int16 v29 = 2048;
      __int16 v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v17;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 2112;
      __int16 v36 = a3;
      __int16 v37 = 2082;
      __int16 v38 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s protocol %s:%p, other_protocol %s:%p, path %@, dumping backtrace:%{public}s",  buf,  0x48u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_output_local_endpoint(nw_protocol *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  BOOL v17 = "nw_protocol_zombie_get_output_local_endpoint";
  __int16 v18 = 2080;
  __int16 v19 = identifier;
  __int16 v20 = 2048;
  __int16 v21 = a1;
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v3, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v6 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v6 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_output_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v6;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v4, v5, v7, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_output_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v11;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_output_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v12;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v9)
    {
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v10 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      BOOL v17 = "nw_protocol_zombie_get_output_local_endpoint";
      __int16 v18 = 2080;
      __int16 v19 = v10;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      __int16 v22 = 2082;
      char v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_get_output_interface(nw_protocol *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  BOOL v17 = "nw_protocol_zombie_get_output_interface";
  __int16 v18 = 2080;
  __int16 v19 = identifier;
  __int16 v20 = 2048;
  __int16 v21 = a1;
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v3, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v6 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v6 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_output_interface";
      __int16 v18 = 2080;
      __int16 v19 = v6;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v4, v5, v7, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_output_interface";
      __int16 v18 = 2080;
      __int16 v19 = v11;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_get_output_interface";
      __int16 v18 = 2080;
      __int16 v19 = v12;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v9)
    {
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v10 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      BOOL v17 = "nw_protocol_zombie_get_output_interface";
      __int16 v18 = 2080;
      __int16 v19 = v10;
      __int16 v20 = 2048;
      __int16 v21 = a1;
      __int16 v22 = 2082;
      char v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  os_log_type_t v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    os_log_type_t v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  uint64_t v24 = "nw_protocol_zombie_connect";
  __int16 v25 = 2080;
  __int16 v26 = identifier;
  __int16 v27 = 2048;
  __int16 v28 = a1;
  __int16 v29 = 2080;
  __int16 v30 = v5;
  __int16 v31 = 2048;
  __int16 v32 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v6, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v24 = "nw_protocol_zombie_connect";
      __int16 v25 = 2080;
      __int16 v26 = v9;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v10;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v24 = "nw_protocol_zombie_connect";
      __int16 v25 = 2080;
      __int16 v26 = v16;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v17;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v24 = "nw_protocol_zombie_connect";
      __int16 v25 = 2080;
      __int16 v26 = v18;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v19;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      char v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      uint64_t v24 = "nw_protocol_zombie_connect";
      __int16 v25 = 2080;
      __int16 v26 = v14;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v15;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      __int16 v33 = 2082;
      uint64_t v34 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, other_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  os_log_type_t v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    os_log_type_t v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_disconnect";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_disconnect";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_disconnect";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_disconnect";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      char v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_disconnect";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, other_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  os_log_type_t v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    os_log_type_t v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_connected";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_connected";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_connected";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_connected";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      char v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_connected";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, other_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  os_log_type_t v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    os_log_type_t v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  char v23 = "nw_protocol_zombie_disconnected";
  __int16 v24 = 2080;
  __int16 v25 = identifier;
  __int16 v26 = 2048;
  __int16 v27 = a1;
  __int16 v28 = 2080;
  __int16 v29 = v5;
  __int16 v30 = 2048;
  __int16 v31 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v6, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_disconnected";
      __int16 v24 = 2080;
      __int16 v25 = v9;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v10;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v20)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_disconnected";
      __int16 v24 = 2080;
      __int16 v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v17;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      char v23 = "nw_protocol_zombie_disconnected";
      __int16 v24 = 2080;
      __int16 v25 = v18;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      char v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      char v23 = "nw_protocol_zombie_disconnected";
      __int16 v24 = 2080;
      __int16 v25 = v14;
      __int16 v26 = 2048;
      __int16 v27 = a1;
      __int16 v28 = 2080;
      __int16 v29 = v15;
      __int16 v30 = 2048;
      __int16 v31 = a2;
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, other_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  uint64_t v7 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    uint64_t v7 = a2->identifier;
  }
  *(_DWORD *)buf = 136447490;
  __int16 v25 = "nw_protocol_zombie_error";
  __int16 v26 = 2080;
  __int16 v27 = identifier;
  __int16 v28 = 2048;
  __int16 v29 = a1;
  __int16 v30 = 2080;
  __int16 v31 = v7;
  __int16 v32 = 2048;
  __int16 v33 = a2;
  __int16 v34 = 1024;
  int v35 = a3;
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v8, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v12 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v25 = "nw_protocol_zombie_error";
      __int16 v26 = 2080;
      __int16 v27 = v11;
      __int16 v28 = 2048;
      __int16 v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v12;
      __int16 v32 = 2048;
      __int16 v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, error %{errno}d";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v9, v10, v13, buf, 0x3Au);
      goto LABEL_45;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v25 = "nw_protocol_zombie_error";
      __int16 v26 = 2080;
      __int16 v27 = v18;
      __int16 v28 = 2048;
      __int16 v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v19;
      __int16 v32 = 2048;
      __int16 v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, error %{errno}d, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_45;
      }
      char v20 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v20 = a1->identifier;
      }
      char v21 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        char v21 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v25 = "nw_protocol_zombie_error";
      __int16 v26 = 2080;
      __int16 v27 = v20;
      __int16 v28 = 2048;
      __int16 v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v21;
      __int16 v32 = 2048;
      __int16 v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, error %{errno}d, no backtrace";
      goto LABEL_44;
    }

    if (v15)
    {
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447746;
      __int16 v25 = "nw_protocol_zombie_error";
      __int16 v26 = 2080;
      __int16 v27 = v16;
      __int16 v28 = 2048;
      __int16 v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v17;
      __int16 v32 = 2048;
      __int16 v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      __int16 v36 = 2082;
      __int16 v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s protocol %s:%p, other_protocol %s:%p, error %{errno}d, dumping backtrace:%{public}s",  buf,  0x44u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_reset(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  os_log_type_t v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    os_log_type_t v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  __int16 v24 = "nw_protocol_zombie_reset";
  __int16 v25 = 2080;
  __int16 v26 = identifier;
  __int16 v27 = 2048;
  __int16 v28 = a1;
  __int16 v29 = 2080;
  __int16 v30 = v5;
  __int16 v31 = 2048;
  __int16 v32 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v6, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v24 = "nw_protocol_zombie_reset";
      __int16 v25 = 2080;
      __int16 v26 = v9;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v10;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v24 = "nw_protocol_zombie_reset";
      __int16 v25 = 2080;
      __int16 v26 = v16;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v17;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v24 = "nw_protocol_zombie_reset";
      __int16 v25 = 2080;
      __int16 v26 = v18;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v19;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, other_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      char v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v24 = "nw_protocol_zombie_reset";
      __int16 v25 = 2080;
      __int16 v26 = v14;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v15;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      __int16 v33 = 2082;
      __int16 v34 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, other_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_supports_external_data(nw_protocol *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  BOOL v17 = "nw_protocol_zombie_supports_external_data";
  __int16 v18 = 2080;
  __int16 v19 = identifier;
  __int16 v20 = 2048;
  char v21 = a1;
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v3, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v6 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v6 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_supports_external_data";
      __int16 v18 = 2080;
      __int16 v19 = v6;
      __int16 v20 = 2048;
      char v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v4, v5, v7, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_supports_external_data";
      __int16 v18 = 2080;
      __int16 v19 = v11;
      __int16 v20 = 2048;
      char v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v17 = "nw_protocol_zombie_supports_external_data";
      __int16 v18 = 2080;
      __int16 v19 = v12;
      __int16 v20 = 2048;
      char v21 = a1;
      uint64_t v7 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v9)
    {
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v10 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      BOOL v17 = "nw_protocol_zombie_supports_external_data";
      __int16 v18 = 2080;
      __int16 v19 = v10;
      __int16 v20 = 2048;
      char v21 = a1;
      __int16 v22 = 2082;
      char v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  os_log_type_t v5 = (nw_protocol_identifier *)"invalid";
  if (a2 && a2->identifier) {
    os_log_type_t v5 = a2->identifier;
  }
  *(_DWORD *)buf = 136447234;
  uint64_t v24 = "nw_protocol_zombie_waiting_for_output";
  __int16 v25 = 2080;
  __int16 v26 = identifier;
  __int16 v27 = 2048;
  __int16 v28 = a1;
  __int16 v29 = 2080;
  __int16 v30 = v5;
  __int16 v31 = 2048;
  __int16 v32 = a2;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v6, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v9 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v9 = a1->identifier;
      }
      os_log_type_t v10 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        os_log_type_t v10 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v24 = "nw_protocol_zombie_waiting_for_output";
      __int16 v25 = 2080;
      __int16 v26 = v9;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v10;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v11, buf, 0x34u);
      goto LABEL_45;
    }

    if (!v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v16 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v16 = a1->identifier;
      }
      BOOL v17 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v17 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v24 = "nw_protocol_zombie_waiting_for_output";
      __int16 v25 = 2080;
      __int16 v26 = v16;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v17;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_45;
      }
      __int16 v18 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v18 = a1->identifier;
      }
      __int16 v19 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        __int16 v19 = a2->identifier;
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v24 = "nw_protocol_zombie_waiting_for_output";
      __int16 v25 = 2080;
      __int16 v26 = v18;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v19;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      os_log_type_t v11 = "%{public}s protocol %s:%p, input_protocol %s:%p, no backtrace";
      goto LABEL_44;
    }

    if (v13)
    {
      char v14 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        char v14 = a1->identifier;
      }
      BOOL v15 = (nw_protocol_identifier *)"invalid";
      if (a2 && a2->identifier) {
        BOOL v15 = a2->identifier;
      }
      *(_DWORD *)buf = 136447490;
      uint64_t v24 = "nw_protocol_zombie_waiting_for_output";
      __int16 v25 = 2080;
      __int16 v26 = v14;
      __int16 v27 = 2048;
      __int16 v28 = a1;
      __int16 v29 = 2080;
      __int16 v30 = v15;
      __int16 v31 = 2048;
      __int16 v32 = a2;
      __int16 v33 = 2082;
      __int16 v34 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s protocol %s:%p, input_protocol %s:%p, dumping backtrace:%{public}s",  buf,  0x3Eu);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_copy_info(uint64_t a1, int a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v4 = "invalid";
  if (a1 && *(void *)(a1 + 16)) {
    unint64_t v4 = *(const char **)(a1 + 16);
  }
  *(_DWORD *)buf = 136446978;
  __int16 v19 = "nw_protocol_zombie_copy_info";
  __int16 v20 = 2080;
  char v21 = v4;
  __int16 v22 = 2048;
  uint64_t v23 = a1;
  __int16 v24 = 1024;
  int v25 = a2;
  os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v5, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v8 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        os_log_type_t v8 = *(const char **)(a1 + 16);
      }
      *(_DWORD *)buf = 136446978;
      __int16 v19 = "nw_protocol_zombie_copy_info";
      __int16 v20 = 2080;
      char v21 = v8;
      __int16 v22 = 2048;
      uint64_t v23 = a1;
      __int16 v24 = 1024;
      int v25 = a2;
      BOOL v9 = "%{public}s protocol %s:%p, type %d";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v6, v7, v9, buf, 0x26u);
      goto LABEL_30;
    }

    if (!v16)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      BOOL v13 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v13 = *(const char **)(a1 + 16);
      }
      *(_DWORD *)buf = 136446978;
      __int16 v19 = "nw_protocol_zombie_copy_info";
      __int16 v20 = 2080;
      char v21 = v13;
      __int16 v22 = 2048;
      uint64_t v23 = a1;
      __int16 v24 = 1024;
      int v25 = a2;
      BOOL v9 = "%{public}s protocol %s:%p, type %d, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = (os_log_s *)gLogObj;
    os_log_type_t v7 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v11) {
        goto LABEL_30;
      }
      char v14 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        char v14 = *(const char **)(a1 + 16);
      }
      *(_DWORD *)buf = 136446978;
      __int16 v19 = "nw_protocol_zombie_copy_info";
      __int16 v20 = 2080;
      char v21 = v14;
      __int16 v22 = 2048;
      uint64_t v23 = a1;
      __int16 v24 = 1024;
      int v25 = a2;
      BOOL v9 = "%{public}s protocol %s:%p, type %d, no backtrace";
      goto LABEL_29;
    }

    if (v11)
    {
      __int16 v12 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        __int16 v12 = *(const char **)(a1 + 16);
      }
      *(_DWORD *)buf = 136447234;
      __int16 v19 = "nw_protocol_zombie_copy_info";
      __int16 v20 = 2080;
      char v21 = v12;
      __int16 v22 = 2048;
      uint64_t v23 = a1;
      __int16 v24 = 1024;
      int v25 = a2;
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s protocol %s:%p, type %d, dumping backtrace:%{public}s",  buf,  0x30u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_register_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v6 = "invalid";
  if (a1 && *(void *)(a1 + 16)) {
    os_log_type_t v6 = *(const char **)(a1 + 16);
  }
  os_log_type_t v7 = "invalid";
  if (a2 && *(void *)(a2 + 16)) {
    os_log_type_t v7 = *(const char **)(a2 + 16);
  }
  *(_DWORD *)buf = 136447490;
  __int16 v26 = "nw_protocol_zombie_register_notification";
  __int16 v27 = 2080;
  uint64_t v28 = v6;
  __int16 v29 = 2048;
  uint64_t v30 = a1;
  __int16 v31 = 2080;
  __int16 v32 = v7;
  __int16 v33 = 2048;
  uint64_t v34 = a2;
  __int16 v35 = 1024;
  int v36 = a3;
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v11 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v11 = *(const char **)(a1 + 16);
      }
      __int16 v12 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v12 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_register_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v11;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v12;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v9, v10, v13, buf, 0x3Au);
      goto LABEL_45;
    }

    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      __int16 v18 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        __int16 v18 = *(const char **)(a1 + 16);
      }
      __int16 v19 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v19 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_register_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v18;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v19;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_45;
      }
      __int16 v20 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        __int16 v20 = *(const char **)(a1 + 16);
      }
      char v21 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        char v21 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_register_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v20;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v21;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, no backtrace";
      goto LABEL_44;
    }

    if (v15)
    {
      char v16 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        char v16 = *(const char **)(a1 + 16);
      }
      BOOL v17 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        BOOL v17 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447746;
      __int16 v26 = "nw_protocol_zombie_register_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v16;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v17;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      __int16 v37 = 2082;
      uint64_t v38 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, dumping backtrace:%{public}s",  buf,  0x44u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v6 = "invalid";
  if (a1 && *(void *)(a1 + 16)) {
    os_log_type_t v6 = *(const char **)(a1 + 16);
  }
  os_log_type_t v7 = "invalid";
  if (a2 && *(void *)(a2 + 16)) {
    os_log_type_t v7 = *(const char **)(a2 + 16);
  }
  *(_DWORD *)buf = 136447490;
  __int16 v26 = "nw_protocol_zombie_unregister_notification";
  __int16 v27 = 2080;
  uint64_t v28 = v6;
  __int16 v29 = 2048;
  uint64_t v30 = a1;
  __int16 v31 = 2080;
  __int16 v32 = v7;
  __int16 v33 = 2048;
  uint64_t v34 = a2;
  __int16 v35 = 1024;
  int v36 = a3;
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v11 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v11 = *(const char **)(a1 + 16);
      }
      __int16 v12 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v12 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_unregister_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v11;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v12;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v9, v10, v13, buf, 0x3Au);
      goto LABEL_45;
    }

    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      __int16 v18 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        __int16 v18 = *(const char **)(a1 + 16);
      }
      __int16 v19 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v19 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_unregister_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v18;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v19;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_45;
      }
      __int16 v20 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        __int16 v20 = *(const char **)(a1 + 16);
      }
      char v21 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        char v21 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      __int16 v26 = "nw_protocol_zombie_unregister_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v20;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v21;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, no backtrace";
      goto LABEL_44;
    }

    if (v15)
    {
      char v16 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        char v16 = *(const char **)(a1 + 16);
      }
      BOOL v17 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        BOOL v17 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447746;
      __int16 v26 = "nw_protocol_zombie_unregister_notification";
      __int16 v27 = 2080;
      uint64_t v28 = v16;
      __int16 v29 = 2048;
      uint64_t v30 = a1;
      __int16 v31 = 2080;
      __int16 v32 = v17;
      __int16 v33 = 2048;
      uint64_t v34 = a2;
      __int16 v35 = 1024;
      int v36 = a3;
      __int16 v37 = 2082;
      uint64_t v38 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, dumping backtrace:%{public}s",  buf,  0x44u);
    }

    free(backtrace_string);
  }

void nw_protocol_zombie_notify(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v6 = "invalid";
  if (a1 && *(void *)(a1 + 16)) {
    os_log_type_t v6 = *(const char **)(a1 + 16);
  }
  os_log_type_t v7 = "invalid";
  if (a2 && *(void *)(a2 + 16)) {
    os_log_type_t v7 = *(const char **)(a2 + 16);
  }
  *(_DWORD *)buf = 136447490;
  int v25 = "nw_protocol_zombie_notify";
  __int16 v26 = 2080;
  __int16 v27 = v6;
  __int16 v28 = 2048;
  uint64_t v29 = a1;
  __int16 v30 = 2080;
  __int16 v31 = v7;
  __int16 v32 = 2048;
  uint64_t v33 = a2;
  __int16 v34 = 1024;
  int v35 = a3;
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v8, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      BOOL v11 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        BOOL v11 = *(const char **)(a1 + 16);
      }
      __int16 v12 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v12 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      int v25 = "nw_protocol_zombie_notify";
      __int16 v26 = 2080;
      __int16 v27 = v11;
      __int16 v28 = 2048;
      uint64_t v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v12;
      __int16 v32 = 2048;
      uint64_t v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v9, v10, v13, buf, 0x3Au);
      goto LABEL_45;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      __int16 v18 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        __int16 v18 = *(const char **)(a1 + 16);
      }
      __int16 v19 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        __int16 v19 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      int v25 = "nw_protocol_zombie_notify";
      __int16 v26 = 2080;
      __int16 v27 = v18;
      __int16 v28 = 2048;
      uint64_t v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v19;
      __int16 v32 = 2048;
      uint64_t v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_45;
      }
      __int16 v20 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        __int16 v20 = *(const char **)(a1 + 16);
      }
      char v21 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        char v21 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447490;
      int v25 = "nw_protocol_zombie_notify";
      __int16 v26 = 2080;
      __int16 v27 = v20;
      __int16 v28 = 2048;
      uint64_t v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v21;
      __int16 v32 = 2048;
      uint64_t v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      BOOL v13 = "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, no backtrace";
      goto LABEL_44;
    }

    if (v15)
    {
      char v16 = "invalid";
      if (a1 && *(void *)(a1 + 16)) {
        char v16 = *(const char **)(a1 + 16);
      }
      BOOL v17 = "invalid";
      if (a2 && *(void *)(a2 + 16)) {
        BOOL v17 = *(const char **)(a2 + 16);
      }
      *(_DWORD *)buf = 136447746;
      int v25 = "nw_protocol_zombie_notify";
      __int16 v26 = 2080;
      __int16 v27 = v16;
      __int16 v28 = 2048;
      uint64_t v29 = a1;
      __int16 v30 = 2080;
      __int16 v31 = v17;
      __int16 v32 = 2048;
      uint64_t v33 = a2;
      __int16 v34 = 1024;
      int v35 = a3;
      __int16 v36 = 2082;
      __int16 v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s protocol %s:%p, other_protocol %s:%p, type %d, dumping backtrace:%{public}s",  buf,  0x44u);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "nw_protocol_zombie_add_listen_handler";
  __int16 v19 = 2080;
  __int16 v20 = identifier;
  __int16 v21 = 2048;
  char v22 = a1;
  unint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v4, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v7 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v7 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v18 = "nw_protocol_zombie_add_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v7;
      __int16 v21 = 2048;
      char v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v5, v6, v8, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v18 = "nw_protocol_zombie_add_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v12;
      __int16 v21 = 2048;
      char v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v10) {
        goto LABEL_30;
      }
      BOOL v13 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v13 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v18 = "nw_protocol_zombie_add_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v13;
      __int16 v21 = 2048;
      char v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v10)
    {
      BOOL v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v18 = "nw_protocol_zombie_add_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v11;
      __int16 v21 = 2048;
      char v22 = a1;
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_zombie_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  identifier = (nw_protocol_identifier *)"invalid";
  if (a1 && a1->identifier) {
    identifier = a1->identifier;
  }
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "nw_protocol_zombie_remove_listen_handler";
  __int16 v19 = 2080;
  __int16 v20 = identifier;
  __int16 v21 = 2048;
  char v22 = a1;
  unint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v4, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      os_log_type_t v7 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        os_log_type_t v7 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v18 = "nw_protocol_zombie_remove_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v7;
      __int16 v21 = 2048;
      char v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v5, v6, v8, buf, 0x20u);
      goto LABEL_30;
    }

    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_30;
      }
      __int16 v12 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        __int16 v12 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v18 = "nw_protocol_zombie_remove_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v12;
      __int16 v21 = 2048;
      char v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v10) {
        goto LABEL_30;
      }
      BOOL v13 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v13 = a1->identifier;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v18 = "nw_protocol_zombie_remove_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v13;
      __int16 v21 = 2048;
      char v22 = a1;
      os_log_type_t v8 = "%{public}s protocol %s:%p, no backtrace";
      goto LABEL_29;
    }

    if (v10)
    {
      BOOL v11 = (nw_protocol_identifier *)"invalid";
      if (a1 && a1->identifier) {
        BOOL v11 = a1->identifier;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v18 = "nw_protocol_zombie_remove_listen_handler";
      __int16 v19 = 2080;
      __int16 v20 = v11;
      __int16 v21 = 2048;
      char v22 = a1;
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s protocol %s:%p, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
  }

uint64_t nw_protocol_upcast(uint64_t a1)
{
  if (a1) {
    return a1 - 96;
  }
  else {
    return 0LL;
  }
}

void *nw_protocol_new_objc(Class cls, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!cls)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v38 = "nw_protocol_new_objc";
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v38 = "nw_protocol_new_objc";
      char v22 = "%{public}s called with null cls";
    }

    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v28 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_protocol_new_objc";
          __int16 v39 = 2082;
          __int16 v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cls, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_67:
        if (v19) {
          goto LABEL_68;
        }
        return 0LL;
      }

      if (!v28) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v38 = "nw_protocol_new_objc";
      char v22 = "%{public}s called with null cls, no backtrace";
    }

    else
    {
      __int16 v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v38 = "nw_protocol_new_objc";
      char v22 = "%{public}s called with null cls, backtrace limit exceeded";
    }

    goto LABEL_66;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v38 = "nw_protocol_new_objc";
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        __int16 v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_new_objc";
        char v22 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_66;
      }

      uint64_t v29 = (char *)__nw_create_backtrace_string();
      __int16 v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v30 = os_log_type_enabled(v20, type);
      if (!v29)
      {
        if (!v30) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_new_objc";
        char v22 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_66;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v38 = "nw_protocol_new_objc";
        __int16 v39 = 2082;
        __int16 v40 = v29;
        __int16 v31 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
LABEL_44:
        _os_log_impl(&dword_181A5C000, v20, v21, v31, buf, 0x16u);
      }

void nw_protocol_new_objc::$_0::__invoke(char *this, objc_object *a2, objc_selector *a3)
{
  if ((v4 & 1) == 0
  {
    nw_protocol_new_objc::$_0::operator() const(objc_object *,objc_selector *)::destroy = (uint64_t)sel_registerName("destroy");
  }

  os_log_type_t v5 = (const char *)nw_protocol_new_objc::$_0::operator() const(objc_object *,objc_selector *)::destroy;
  Class = object_getClass(this);
  if (class_getInstanceMethod(Class, v5)) {
    [this v5];
  }
  objc_destructInstance(this);
  if (this)
  {
    if (*((_UNKNOWN **)this - 7) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *((void *)this - 1);
      if (v7)
      {
        uint64_t v8 = v7 - 1;
        *((void *)this - 1) = v8;
        if (!v8)
        {
          BOOL v9 = (void (**)(void))*((void *)this - 4);
          if (v9)
          {
            *((void *)this - 4) = 0LL;
            v9[2](v9);
            _Block_release(v9);
          }

          if ((*(this - 24) & 1) != 0)
          {
            BOOL v10 = (const void *)*((void *)this - 4);
            if (v10) {
              _Block_release(v10);
            }
          }

          *((void *)this - 4) = 0LL;
          free(this - 96);
        }
      }
    }
  }

uint64_t nw_protocol_get_identifier(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 16);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_get_identifier";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_identifier";
        os_log_type_t v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "__nw_protocol_get_identifier";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_identifier";
        os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_identifier";
        os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_protocol_get_callbacks(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 24);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_get_callbacks";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_callbacks";
        os_log_type_t v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "__nw_protocol_get_callbacks";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_callbacks";
        os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_callbacks";
        os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

const char *nw_protocol_get_name(uint64_t a1)
{
  uint64_t result = "invalid";
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3) {
      return (const char *)v3;
    }
  }

  return result;
}

uint64_t nw_protocol_get_handle(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 40);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_get_handle";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_handle";
        os_log_type_t v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "__nw_protocol_get_handle";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_handle";
        os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_handle";
        os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void nw_protocol_set_flow_id(_OWORD *a1, _OWORD *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *a1 = *a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_set_flow_id";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id";
        os_log_type_t v5 = "%{public}s called with null flow_id";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id";
        os_log_type_t v5 = "%{public}s called with null flow_id, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v13 = "nw_protocol_set_flow_id";
          __int16 v14 = 2082;
          unsigned __int8 v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null flow_id, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id";
        os_log_type_t v5 = "%{public}s called with null flow_id, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_set_flow_id";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id";
      os_log_type_t v5 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id";
      os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    os_log_type_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id";
      os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v13 = "nw_protocol_set_flow_id";
      __int16 v14 = 2082;
      unsigned __int8 v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_set_flow_id_from_protocol(_OWORD *a1, _OWORD *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *a1 = *a2;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
        os_log_type_t v5 = "%{public}s called with null from_protocol";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
        os_log_type_t v5 = "%{public}s called with null from_protocol, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
          __int16 v14 = 2082;
          unsigned __int8 v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null from_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
        os_log_type_t v5 = "%{public}s called with null from_protocol, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      os_log_type_t v5 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    os_log_type_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      __int16 v14 = 2082;
      unsigned __int8 v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_get_flow_id(_OWORD *a1, _OWORD *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *a2 = *a1;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_get_flow_id";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_get_flow_id";
        os_log_type_t v5 = "%{public}s called with null destination";
        goto LABEL_32;
      }

      if (!v10)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_get_flow_id";
        os_log_type_t v5 = "%{public}s called with null destination, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v13 = "nw_protocol_get_flow_id";
          __int16 v14 = 2082;
          unsigned __int8 v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null destination, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_get_flow_id";
        os_log_type_t v5 = "%{public}s called with null destination, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_get_flow_id";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_get_flow_id";
      os_log_type_t v5 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_get_flow_id";
      os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    os_log_type_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_get_flow_id";
      os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v13 = "nw_protocol_get_flow_id";
      __int16 v14 = 2082;
      unsigned __int8 v15 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

void nw_protocol_set_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4 != a2)
    {
      if (v4)
      {
        if (*(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v6 = *(void *)(v4 + 88);
          if (v6)
          {
            uint64_t v7 = v6 - 1;
            *(void *)(v4 + 88) = v7;
            if (!v7)
            {
              char v8 = *(void (***)(void))(v4 + 64);
              if (v8)
              {
                *(void *)(v4 + 64) = 0LL;
                v8[2](v8);
                _Block_release(v8);
              }

              if ((*(_BYTE *)(v4 + 72) & 1) != 0)
              {
                BOOL v9 = *(const void **)(v4 + 64);
                if (v9) {
                  _Block_release(v9);
                }
              }

              free((void *)v4);
            }
          }
        }
      }

      *(void *)(a1 + 48) = a2;
      if (a2 && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v5 = *(void *)(a2 + 88);
        if (v5) {
          *(void *)(a2 + 88) = v5 + 1;
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "__nw_protocol_set_input_handler";
  char v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "__nw_protocol_set_input_handler";
      BOOL v13 = "%{public}s called with null protocol";
      goto LABEL_31;
    }

    if (!v16)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "__nw_protocol_set_input_handler";
      BOOL v13 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v15 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v19 = "__nw_protocol_set_input_handler";
        __int16 v20 = 2082;
        os_log_type_t v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_32;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "__nw_protocol_set_input_handler";
      BOOL v13 = "%{public}s called with null protocol, no backtrace";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    }
  }

uint64_t nw_protocol_get_input_handler(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 48);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_get_input_handler";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_input_handler";
        uint64_t v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "__nw_protocol_get_input_handler";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_input_handler";
        uint64_t v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_input_handler";
        uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void nw_protocol_set_output_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4 != a2)
    {
      if (v4)
      {
        if (*(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v6 = *(void *)(v4 + 88);
          if (v6)
          {
            uint64_t v7 = v6 - 1;
            *(void *)(v4 + 88) = v7;
            if (!v7)
            {
              char v8 = *(void (***)(void))(v4 + 64);
              if (v8)
              {
                *(void *)(v4 + 64) = 0LL;
                v8[2](v8);
                _Block_release(v8);
              }

              if ((*(_BYTE *)(v4 + 72) & 1) != 0)
              {
                BOOL v9 = *(const void **)(v4 + 64);
                if (v9) {
                  _Block_release(v9);
                }
              }

              free((void *)v4);
            }
          }
        }
      }

      *(void *)(a1 + 32) = a2;
      if (a2 && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v5 = *(void *)(a2 + 88);
        if (v5) {
          *(void *)(a2 + 88) = v5 + 1;
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "__nw_protocol_set_output_handler";
  char v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "__nw_protocol_set_output_handler";
      BOOL v13 = "%{public}s called with null protocol";
      goto LABEL_31;
    }

    if (!v16)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "__nw_protocol_set_output_handler";
      BOOL v13 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v15 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v19 = "__nw_protocol_set_output_handler";
        __int16 v20 = 2082;
        os_log_type_t v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_32;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "__nw_protocol_set_output_handler";
      BOOL v13 = "%{public}s called with null protocol, no backtrace";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    }
  }

uint64_t nw_protocol_get_output_handler(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 32);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_get_output_handler";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_output_handler";
        uint64_t v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "__nw_protocol_get_output_handler";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_output_handler";
        uint64_t v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_output_handler";
        uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void nw_protocol_set_output_handler_context(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)(a1 + 56) = a2;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_set_output_handler_context";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_output_handler_context";
      uint64_t v5 = "%{public}s called with null protocol";
      goto LABEL_17;
    }

    if (!v8)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_output_handler_context";
      uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v11 = "__nw_protocol_set_output_handler_context";
        __int16 v12 = 2082;
        BOOL v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "__nw_protocol_set_output_handler_context";
      uint64_t v5 = "%{public}s called with null protocol, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t nw_protocol_get_output_handler_context(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 56);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_protocol_get_output_handler_context";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_output_handler_context";
        uint64_t v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "__nw_protocol_get_output_handler_context";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_output_handler_context";
        uint64_t v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_protocol_get_output_handler_context";
        uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_protocol_retain(uint64_t result)
{
  if (result)
  {
    if (*(_UNKNOWN **)(result + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v1 = *(void *)(result + 88);
      if (v1) {
        *(void *)(result + 88) = v1 + 1;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void nw_protocol_release(void *a1)
{
  if (a1)
  {
    if ((_UNKNOWN *)a1[5] == &nw_protocol_ref_counted_handle)
    {
      uint64_t v2 = a1[11];
      if (v2)
      {
        uint64_t v3 = v2 - 1;
        a1[11] = v3;
        if (!v3)
        {
          os_log_type_t v4 = (void (**)(void))a1[8];
          if (v4)
          {
            a1[8] = 0LL;
            v4[2](v4);
            _Block_release(v4);
          }

          if ((a1[9] & 1) != 0)
          {
            uint64_t v5 = (const void *)a1[8];
            if (v5) {
              _Block_release(v5);
            }
          }

          free(a1);
        }
      }
    }
  }

BOOL nw_quic_info_allocate()
{
  v0 = calloc(1uLL, 0x10uLL);
  if (v0) {
    goto LABEL_2;
  }
  uint64_t v2 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  uint64_t v3 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
LABEL_2:
    void *v0 = nw_array_create();
    return (BOOL)v0;
  }

  __break(1u);
  return result;
}

void nw_quic_info_destroy(uint64_t *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_array_remove_all_objects(*a1);
    if (*a1) {
      os_release((void *)*a1);
    }
    free(a1);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "nw_quic_info_destroy";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "nw_quic_info_destroy";
      uint64_t v5 = "%{public}s called with null quic_info";
      goto LABEL_18;
    }

    if (!v8)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "nw_quic_info_destroy";
      uint64_t v5 = "%{public}s called with null quic_info, backtrace limit exceeded";
      goto LABEL_18;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v11 = "nw_quic_info_destroy";
        __int16 v12 = 2082;
        BOOL v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null quic_info, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_19;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "nw_quic_info_destroy";
      uint64_t v5 = "%{public}s called with null quic_info, no backtrace";
LABEL_18:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

void sub_181E1F66C(_Unwind_Exception *a1)
{
}

void sub_181E1F700(_Unwind_Exception *a1)
{
}

BOOL __currentProcessHasSSIDEntitlement_block_invoke()
{
  BOOL result = NWUtilsCurrentProcessHasEntitlement(@"com.apple.wlan.authentication")
        || NWUtilsCurrentProcessHasEntitlement(@"com.apple.private.corewifi");
  currentProcessHasSSIDEntitlement_hasSSIDEntitlement = result;
  return result;
}

id NWMonitorStatusToString(unint64_t a1)
{
  if (a1 < 3) {
    return *((id *)&off_189BB74B0 + a1);
  }
  objc_msgSend(NSString, "stringWithFormat:", @"Unknown[%ld]", a1);
  return (id)objc_claimAutoreleasedReturnValue();
}

nw_ws_response_t nw_ws_response_create(nw_ws_response_status_t status, const char *selected_subprotocol)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (status == nw_ws_response_status_invalid)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v33 = "nw_ws_response_create";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v31.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(v31.receiver) == 17)
    {
      __nwlog_obj();
      BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v31.receiver;
      if (os_log_type_enabled(v15, (os_log_type_t)v31.receiver))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v33 = "nw_ws_response_create";
        _os_log_impl(&dword_181A5C000, v15, receiver, "%{public}s called with null status", buf, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = (os_log_type_t)v31.receiver;
      BOOL v24 = os_log_type_enabled(v15, (os_log_type_t)v31.receiver);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v33 = "nw_ws_response_create";
          __int16 v34 = 2082;
          char v35 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s called with null status, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_31;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v33 = "nw_ws_response_create";
        _os_log_impl(&dword_181A5C000, v15, v23, "%{public}s called with null status, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = (os_log_type_t)v31.receiver;
      if (os_log_type_enabled(v15, (os_log_type_t)v31.receiver))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v33 = "nw_ws_response_create";
        _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null status, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_44;
  }

  os_log_type_t v4 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_ws_response);
  if (!v4) {
    return 0LL;
  }
  v31.os_log_type_t receiver = v4;
  v31.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_ws_response;
  uint64_t v5 = (nw_ws_response *)objc_msgSendSuper2(&v31, sel_init);
  if (!v5)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v33 = "-[NWConcrete_nw_ws_response initWithStatus:selectedProtocol:]";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if ((__nwlog_fault(v14, &type, &v29) & 1) == 0) {
      goto LABEL_44;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v33 = "-[NWConcrete_nw_ws_response initWithStatus:selectedProtocol:]";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s [super init] failed", buf, 0xCu);
      }

void sub_181E22A98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_ws_response_status_t nw_ws_response_get_status(nw_ws_response_t response)
{
  if (response) {
    LODWORD(response) = *((_DWORD *)response + 2);
  }
  return response;
}

const char *__cdecl nw_ws_response_get_selected_subprotocol(nw_ws_response_t response)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_ws_response_t v1 = response;
  nw_ws_response_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (const char *)*((void *)v1 + 2);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_ws_response_get_selected_subprotocol";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_ws_response_get_selected_subprotocol";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null response", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_ws_response_get_selected_subprotocol";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null response, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_ws_response_get_selected_subprotocol";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null response, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_ws_response_get_selected_subprotocol";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null response, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_ws_response_add_additional_header(nw_ws_response_t response, const char *name, const char *value)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  nw_ws_response_t v5 = response;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v33 = "nw_ws_response_add_additional_header";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v33 = "nw_ws_response_add_additional_header";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null response", buf, 0xCu);
      }
    }

    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v33 = "nw_ws_response_add_additional_header";
          __int16 v34 = 2082;
          char v35 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null response, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_62:
        if (!v12) {
          goto LABEL_12;
        }
LABEL_63:
        free(v12);
        goto LABEL_12;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v33 = "nw_ws_response_add_additional_header";
        _os_log_impl(&dword_181A5C000, v13, v20, "%{public}s called with null response, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v33 = "nw_ws_response_add_additional_header";
        _os_log_impl( &dword_181A5C000,  v13,  v27,  "%{public}s called with null response, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E23514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ws_response_enumerate_additional_headers( nw_ws_response_t response, nw_ws_additional_header_enumerator_t enumerator)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v3 = response;
  nw_ws_additional_header_enumerator_t v4 = enumerator;
  nw_ws_response_t v5 = (uint64_t (**)(void, void, void))v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_ws_response_enumerate_additional_headers";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_ws_response_enumerate_additional_headers";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null response", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v29 = "nw_ws_response_enumerate_additional_headers";
          __int16 v30 = 2082;
          objc_super v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null response, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v13)
        {
LABEL_6:
          BOOL v8 = 0;
          goto LABEL_7;
        }

void sub_181E23A3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *nw_group_type_to_string(unsigned int a1)
{
  if (a1 > 4) {
    return "unknown";
  }
  else {
    return off_189BB74C8[a1];
  }
}

void sub_181E2415C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_group_descriptor_allows_endpoint(void *a1, void *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  nw_ws_response_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    char v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v40 = "nw_group_descriptor_allows_endpoint";
    xpc_object_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_group_descriptor_allows_endpoint";
        _os_log_impl(&dword_181A5C000, v8, v27, "%{public}s called with null descriptor", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (!v37)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_group_descriptor_allows_endpoint";
        _os_log_impl( &dword_181A5C000,  v8,  v35,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v31 = type;
    BOOL v32 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_group_descriptor_allows_endpoint";
        _os_log_impl(&dword_181A5C000, v8, v31, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v40 = "nw_group_descriptor_allows_endpoint";
      __int16 v41 = 2082;
      __int16 v42 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v8,  v31,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_65;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v40 = "nw_group_descriptor_allows_endpoint";
    xpc_object_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_group_descriptor_allows_endpoint";
        _os_log_impl(&dword_181A5C000, v8, v29, "%{public}s called with null endpoint", buf, 0xCu);
      }

void sub_181E24ABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_group_descriptor_t nw_group_descriptor_create_multicast(nw_endpoint_t multicast_group)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  nw_ws_response_t v1 = multicast_group;
  if (v1)
  {
    nw_ws_response_t v2 = -[NWConcrete_nw_group_descriptor initWithType:member:groupID:]( (uint64_t *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_group_descriptor),  1,  v1,  0LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v15 = "nw_group_descriptor_create_multicast";
  nw_ws_response_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v15 = "nw_group_descriptor_create_multicast";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null multicast_group", buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          id v15 = "nw_group_descriptor_create_multicast";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null multicast_group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        id v15 = "nw_group_descriptor_create_multicast";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null multicast_group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v15 = "nw_group_descriptor_create_multicast";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null multicast_group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E24DA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_group_descriptor_t nw_group_descriptor_create_multiplex(nw_endpoint_t remote_endpoint)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  nw_ws_response_t v1 = remote_endpoint;
  if (v1)
  {
    nw_ws_response_t v2 = -[NWConcrete_nw_group_descriptor initWithType:member:groupID:]( (uint64_t *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_group_descriptor),  2,  v1,  0LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v15 = "nw_group_descriptor_create_multiplex";
  nw_ws_response_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v15 = "nw_group_descriptor_create_multiplex";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null remote_endpoint", buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          id v15 = "nw_group_descriptor_create_multiplex";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        id v15 = "nw_group_descriptor_create_multiplex";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null remote_endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        id v15 = "nw_group_descriptor_create_multiplex";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null remote_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E25060(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *nw_group_descriptor_create_apple_id(void *a1, _OWORD *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (v3)
  {
    id v4 = -[NWConcrete_nw_group_descriptor initWithType:member:groupID:]( (uint64_t *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_group_descriptor),  3,  v3,  a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v17 = "nw_group_descriptor_create_apple_id";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_group_descriptor_create_apple_id";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null apple_id", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v17 = "nw_group_descriptor_create_apple_id";
          __int16 v18 = 2082;
          id v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null apple_id, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_group_descriptor_create_apple_id";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null apple_id, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_group_descriptor_create_apple_id";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null apple_id, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E25324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *nw_group_descriptor_create_application_service(void *a1, _OWORD *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (v3)
  {
    id v4 = -[NWConcrete_nw_group_descriptor initWithType:member:groupID:]( (uint64_t *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_group_descriptor),  3,  v3,  a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v17 = "nw_group_descriptor_create_application_service";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_group_descriptor_create_application_service";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v17 = "nw_group_descriptor_create_application_service";
          __int16 v18 = 2082;
          id v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_group_descriptor_create_application_service";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_group_descriptor_create_application_service";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E255E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *nw_group_descriptor_create_with_type(int a1, _OWORD *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1) {
    return -[NWConcrete_nw_group_descriptor initWithType:member:groupID:]( (uint64_t *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_group_descriptor),  a1,  0LL,  a2);
  }
  __nwlog_obj();
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v13 = "nw_group_descriptor_create_with_type";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_ws_response_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v13 = "nw_group_descriptor_create_with_type";
        os_log_type_t v7 = "%{public}s called with null (type != nw_group_type_invalid)";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      }
    }

    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_ws_response_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v6 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v13 = "nw_group_descriptor_create_with_type";
            __int16 v14 = 2082;
            id v15 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null (type != nw_group_type_invalid), dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v9) {
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v13 = "nw_group_descriptor_create_with_type";
        os_log_type_t v7 = "%{public}s called with null (type != nw_group_type_invalid), no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      nw_ws_response_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v13 = "nw_group_descriptor_create_with_type";
        os_log_type_t v7 = "%{public}s called with null (type != nw_group_type_invalid), backtrace limit exceeded";
        goto LABEL_16;
      }
    }

uint64_t *nw_group_descriptor_copy(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  nw_ws_response_t v1 = a1;
  nw_ws_response_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_group_descriptor_copy";
    char v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v10, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_group_descriptor_copy";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null descriptor", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_group_descriptor_copy";
            __int16 v21 = 2082;
            os_log_type_t v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_group_descriptor_copy";
          _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_group_descriptor_copy";
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E25B9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_group_descriptor_get_type(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_ws_response_t v1 = a1;
  nw_ws_response_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[2];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_group_descriptor_get_type";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_get_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_group_descriptor_get_type";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_get_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_get_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_group_descriptor_get_id(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *a2 = *((_OWORD *)v3 + 1);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_group_descriptor_get_id";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_get_id";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_group_descriptor_get_id";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_get_id";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_get_id";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_group_descriptor_supports_known_membership(void *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_ws_response_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_group_descriptor_supports_known_membership";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_group_descriptor_supports_known_membership";
        _os_log_impl(&dword_181A5C000, v6, v15, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v23 = "nw_group_descriptor_supports_known_membership";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v17,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_group_descriptor_supports_known_membership";
        _os_log_impl(&dword_181A5C000, v6, v17, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_group_descriptor_supports_known_membership";
        _os_log_impl( &dword_181A5C000,  v6,  v19,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }

BOOL nw_group_descriptor_add_endpoint(nw_group_descriptor_t descriptor, nw_endpoint_t endpoint)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  nw_group_descriptor_t v3 = descriptor;
  id v4 = endpoint;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    char v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null descriptor", buf, 0xCu);
      }

      goto LABEL_51;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
        _os_log_impl( &dword_181A5C000,  v15,  v24,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
        _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }

      goto LABEL_51;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
      __int16 v30 = 2082;
      os_log_type_t v31 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_39;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null endpoint", buf, 0xCu);
      }

void sub_181E26BF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_group_descriptor_supports_multiple_members(NWConcrete_nw_group_descriptor *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1->type;
  if (v2 == 4 || v2 == 2) {
    goto LABEL_11;
  }
  if (v2)
  {
    uint64_t v7 = 1LL;
    goto LABEL_13;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_group_descriptor_supports_multiple_members";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v4, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_supports_multiple_members";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s Invalid group descriptor type", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_group_descriptor_supports_multiple_members";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s Invalid group descriptor type, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v4) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_supports_multiple_members";
        _os_log_impl(&dword_181A5C000, v5, v10, "%{public}s Invalid group descriptor type, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_supports_multiple_members";
        _os_log_impl( &dword_181A5C000,  v5,  v12,  "%{public}s Invalid group descriptor type, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v4) {
LABEL_10:
  }
    free(v4);
LABEL_11:
  uint64_t v7 = 0LL;
LABEL_13:

  return v7;
}

void nw_group_descriptor_remove_endpoint(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_group_descriptor_remove_endpoint";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_group_descriptor_remove_endpoint";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v23 = "nw_group_descriptor_remove_endpoint";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_group_descriptor_remove_endpoint";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_group_descriptor_remove_endpoint";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t nw_group_descriptor_set_members(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      os_log_type_t v6 = (unsigned __int8 *)v3[4];
      v26[0] = MEMORY[0x1895F87A8];
      v26[1] = 3221225472LL;
      v26[2] = __nw_group_descriptor_set_members_block_invoke;
      v26[3] = &unk_189BC85B0;
      uint64_t v7 = v3;
      os_log_type_t v27 = v7;
      if (nw_array_apply(v6, (uint64_t)v26))
      {
        if ((nw_group_descriptor_supports_multiple_members(v7) & 1) != 0)
        {
          objc_storeStrong(v3 + 4, a2);
          uint64_t v8 = 1LL;
LABEL_15:

          goto LABEL_16;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          uint64_t v10 = v7->type;
          else {
            os_log_type_t v11 = off_189BB74C8[v10];
          }
          *(_DWORD *)buf = 136446466;
          os_log_type_t v31 = "nw_group_descriptor_set_members";
          __int16 v32 = 2080;
          os_log_type_t v33 = (void *)v11;
          _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Group descriptor of type %s does not support multiple members",  buf,  0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_group_descriptor_set_members";
          _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Invalid endpoint type for group descriptor",  buf,  0xCu);
        }
      }

      uint64_t v8 = 0LL;
      goto LABEL_15;
    }

    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_group_descriptor_set_members";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v14, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_group_descriptor_set_members";
          _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null endpoints", buf, 0xCu);
        }

BOOL __nw_group_descriptor_set_members_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return nw_group_descriptor_allows_endpoint(*(void **)(a1 + 32), a3);
}

void nw_group_descriptor_enumerate_endpoints( nw_group_descriptor_t descriptor, nw_group_descriptor_enumerate_endpoints_block_t enumerate_block)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  nw_group_descriptor_t v3 = descriptor;
  nw_group_descriptor_enumerate_endpoints_block_t v4 = enumerate_block;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_group_descriptor_enumerate_endpoints";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_group_descriptor_enumerate_endpoints";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_group_descriptor_enumerate_endpoints";
          __int16 v27 = 2082;
          char v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_group_descriptor_enumerate_endpoints";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_group_descriptor_enumerate_endpoints";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_group_descriptor_enumerate_endpoints_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t nw_group_descriptor_copy_member(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_group_descriptor_copy_member";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_group_descriptor_copy_member";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null descriptor", buf, 0xCu);
      }

      goto LABEL_45;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_group_descriptor_copy_member";
        _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_group_descriptor_copy_member";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }

      goto LABEL_45;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_group_descriptor_copy_member";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_33;
  }

  if (nw_group_descriptor_supports_multiple_members(v1))
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_group_descriptor_copy_member";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_group_descriptor_copy_member";
        _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called on group descriptor that supports multiple endpoints",  buf,  0xCu);
      }

id nw_group_descriptor_copy_members(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    id v3 = v1[4];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_group_descriptor_copy_members";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_copy_members";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_group_descriptor_copy_members";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_copy_members";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_group_descriptor_copy_members";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_multicast_group_descriptor_set_specific_source( nw_group_descriptor_t multicast_descriptor, nw_endpoint_t source)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = multicast_descriptor;
  uint64_t v4 = source;
  if (v3)
  {
    objc_storeStrong(v3 + 5, source);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_multicast_group_descriptor_set_specific_source";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_set_specific_source";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null multicast_descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_multicast_group_descriptor_set_specific_source";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_set_specific_source";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_set_specific_source";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null multicast_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_multicast_group_descriptor_get_specific_source(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    id v3 = v1[5];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_multicast_group_descriptor_get_specific_source";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_get_specific_source";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null multicast_descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_multicast_group_descriptor_get_specific_source";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_get_specific_source";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_get_specific_source";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null multicast_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_multicast_group_descriptor_set_disable_unicast_traffic( nw_group_descriptor_t multicast_descriptor, BOOL disable_unicast_traffic)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_group_descriptor_t v3 = multicast_descriptor;
  nw_group_descriptor_t v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 48) = *((_BYTE *)v3 + 48) & 0xFE | disable_unicast_traffic;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_multicast_group_descriptor_set_disable_unicast_traffic";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_set_disable_unicast_traffic";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null multicast_descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_multicast_group_descriptor_set_disable_unicast_traffic";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_set_disable_unicast_traffic";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_set_disable_unicast_traffic";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null multicast_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_multicast_group_descriptor_get_disable_unicast_traffic(nw_group_descriptor_t multicast_descriptor)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_group_descriptor_t v1 = multicast_descriptor;
  nw_group_descriptor_t v2 = v1;
  if (v1)
  {
    BOOL v3 = *((_BYTE *)v1 + 48) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_multicast_group_descriptor_get_disable_unicast_traffic";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_get_disable_unicast_traffic";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null multicast_descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_multicast_group_descriptor_get_disable_unicast_traffic";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_get_disable_unicast_traffic";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null multicast_descriptor, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_multicast_group_descriptor_get_disable_unicast_traffic";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null multicast_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

nw_privacy_context_t nw_privacy_context_create(const char *description)
{
  BOOL v1 = -[NWConcrete_nw_context initWithIdentifier:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_context), description);
  nw_context_set_isolate_protocol_cache((void *)v1, 1);
  nw_context_activate((void *)v1);
  return (nw_privacy_context_t)v1;
}

void sub_181E29480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_privacy_context_flush_cache(nw_privacy_context_t privacy_context)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  BOOL v1 = privacy_context;
  if (v1)
  {
    if (v1 == (nw_privacy_context *)&__block_literal_global_11084)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      BOOL v1 = (nw_privacy_context *)(id)nw_context_copy_implicit_context::implicit_context;
    }

    BOOL v11 = v1;
    BOOL v2 = nw_context_copy_cache_context(v1);
    nw_context_purge_all_endpoints((void *)v2);

    return;
  }

  __nwlog_obj();
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v15 = "nw_privacy_context_flush_cache";
  nw_group_descriptor_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v4, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "nw_privacy_context_flush_cache";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null privacy_context", buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v15 = "nw_privacy_context_flush_cache";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null privacy_context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "nw_privacy_context_flush_cache";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null privacy_context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "nw_privacy_context_flush_cache";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null privacy_context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E2978C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void nw_privacy_context_disable_logging(nw_privacy_context_t privacy_context)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  BOOL v1 = privacy_context;
  BOOL v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "nw_privacy_context_disable_logging";
    nw_group_descriptor_t v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v4, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_privacy_context_disable_logging";
          _os_log_impl(&dword_181A5C000, v5, v12, "%{public}s called with null privacy_context", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (!v17)
      {
        __nwlog_obj();
        uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_privacy_context_disable_logging";
          _os_log_impl( &dword_181A5C000,  v5,  v16,  "%{public}s called with null privacy_context, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_privacy_context_disable_logging";
          _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s called with null privacy_context, no backtrace",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "nw_privacy_context_disable_logging";
        __int16 v21 = 2082;
        char v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s called with null privacy_context, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181E29CA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_privacy_context_require_encrypted_name_resolution( nw_privacy_context_t privacy_context, BOOL require_encrypted_name_resolution, nw_resolver_config_t fallback_resolver_config)
{
  BOOL v4 = require_encrypted_name_resolution;
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v5 = privacy_context;
  os_log_type_t v6 = fallback_resolver_config;
  if (v5)
  {
    if (v5 == (nw_privacy_context *)&__block_literal_global_11084)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      uint64_t v5 = (nw_privacy_context *)(id)nw_context_copy_implicit_context::implicit_context;
    }

    nw_context_require_encrypted_name_resolution(v5, v4, v6);
    goto LABEL_7;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v18 = "nw_privacy_context_require_encrypted_name_resolution";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_privacy_context_require_encrypted_name_resolution";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null privacy_context", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v18 = "nw_privacy_context_require_encrypted_name_resolution";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null privacy_context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_privacy_context_require_encrypted_name_resolution";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null privacy_context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_privacy_context_require_encrypted_name_resolution";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null privacy_context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E29FAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_privacy_context_add_proxy(nw_privacy_context_t privacy_context, nw_proxy_config_t proxy_config)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = privacy_context;
  BOOL v4 = proxy_config;
  if (v3)
  {
    if (v3 == (nw_privacy_context *)&__block_literal_global_11084)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      id v3 = (nw_privacy_context *)(id)nw_context_copy_implicit_context::implicit_context;
    }

    nw_context_add_proxy(v3, v4);
    goto LABEL_7;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_privacy_context_add_proxy";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_privacy_context_add_proxy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null privacy_context", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_privacy_context_add_proxy";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null privacy_context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_privacy_context_add_proxy";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null privacy_context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_privacy_context_add_proxy";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null privacy_context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E2A2B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_privacy_context_clear_proxies(nw_privacy_context_t privacy_context)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  BOOL v1 = privacy_context;
  if (v1)
  {
    BOOL v2 = v1;
    if (v1 == (nw_privacy_context *)&__block_literal_global_11084)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      BOOL v2 = (nw_privacy_context *)(id)nw_context_copy_implicit_context::implicit_context;
    }

    nw_context_clear_proxies(v2);
    goto LABEL_7;
  }

  __nwlog_obj();
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_privacy_context_clear_proxies";
  BOOL v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_privacy_context_clear_proxies";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null privacy_context", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_privacy_context_clear_proxies";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null privacy_context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_privacy_context_clear_proxies";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null privacy_context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_privacy_context_clear_proxies";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null privacy_context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E2A598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181E2AA9C(_Unwind_Exception *exception_object)
{
}

void nw::release_if_needed<nw_protocol *>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v3 = *(void *)(v1 + 88);
      if (v3)
      {
        uint64_t v4 = v3 - 1;
        *(void *)(v1 + 88) = v4;
        if (!v4)
        {
          uint64_t v5 = *(const void **)(v1 + 64);
          if (v5)
          {
            os_log_type_t v6 = _Block_copy(v5);
            uint64_t v7 = *(void **)(v1 + 64);
            *(void *)(v1 + 64) = 0LL;

            os_log_type_t v8 = _Block_copy(v6);
            os_log_type_t v10 = (void (**)(void))_Block_copy(v8);

            v10[2](v10);
            BOOL v9 = *(void **)(v1 + 64);
            if ((*(_BYTE *)(v1 + 72) & 1) != 0)
            {
              if (v9)
              {
                *(void *)(v1 + 64) = 0LL;

                BOOL v9 = *(void **)(v1 + 64);
              }
            }
          }

          else
          {
            BOOL v9 = 0LL;
          }

          *(void *)(v1 + 64) = 0LL;

          free((void *)v1);
        }
      }
    }

    *a1 = 0LL;
  }

void sub_181E2BFB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr(uint64_t a1)
{
  id v2 = *(id *)a1;
  if ((*(_BYTE *)(a1 + 8) & 1) != 0 && v2)
  {
    *(void *)a1 = 0LL;

    id v2 = *(id *)a1;
  }

  *(void *)a1 = 0LL;

  return a1;
}

void nw_protocol_path_state_dispose(void *a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_protocol_path_state_dispose";
    char v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_protocol_path_state_dispose";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v27 = "nw_protocol_path_state_dispose";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v11) {
          goto LABEL_6;
        }
LABEL_41:
        free(v11);
        goto LABEL_6;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_protocol_path_state_dispose";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_protocol_path_state_dispose";
        _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E2C55C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_tear_down_path_inner(void *a1, uint64_t a2)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v61) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if ((_BYTE)v61)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type[0];
      BOOL v32 = os_log_type_enabled(v19, type[0]);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_82:
        if (!v18) {
          goto LABEL_120;
        }
LABEL_83:
        free(v18);
        goto LABEL_120;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
        _os_log_impl(&dword_181A5C000, v19, v31, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
        _os_log_impl( &dword_181A5C000,  v19,  v39,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E2D1EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_11356( uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)v3 + 4);
  char v6 = (void *)*((void *)v3 + 5);
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    char v6 = (void *)*((void *)v3 + 5);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v6;
  }

  *char v6 = v5;
  *((void *)v3 + 4) = 0LL;
  *((void *)v3 + 5) = 0LL;
  nw_frame_finalize((uint64_t)v3);

  return 1LL;
}

uint64_t nw_protocol_instance_stub_get_handle(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 1);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_protocol_instance_stub_get_handle";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_instance_stub_get_handle";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null stub", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_protocol_instance_stub_get_handle";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null stub, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_instance_stub_get_handle";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null stub, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_instance_stub_get_handle";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null stub, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void nw_protocol_instance_flush_batched_input(void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    if ((v1->flow_in_connected & 0x10000000) != 0)
    {
      nw_protocol_instance_flush_batched_input_internal(v1);
      BYTE3(v2->flow_in_connected) |= 0x10u;
      var10 = (void (*)(NWConcrete_nw_protocol_instance *))v2->parent_definition->extended_state->var10;
      if (var10) {
        var10(v2);
      }
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_instance_flush_batched_input";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_instance_flush_batched_input";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v15 = "nw_protocol_instance_flush_batched_input";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_instance_flush_batched_input";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_instance_flush_batched_input";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E2DB94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_flush_batched_input_internal(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v84 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  parent_definition = v1->parent_definition;
  var11 = (void (*)(NWConcrete_nw_protocol_instance *))parent_definition->extended_state->var11;
  if (var11)
  {
    var11(v1);
    parent_definition = v2->parent_definition;
  }

  char v5 = BYTE3(v2->flow_in_connected) & 0xEF;
  BYTE3(v2->flow_in_connected) = v5;
  if (parent_definition->variant == 3)
  {
    tqh_last = (char *)v2->pending_outbound_frames.tqh_last;
    v68[0] = MEMORY[0x1895F87A8];
    v68[1] = 3221225472LL;
    v68[2] = ___ZL49nw_protocol_instance_flush_batched_input_internalP31NWConcrete_nw_protocol_instance_block_invoke;
    v68[3] = &unk_189BC86F0;
    v69 = v2;
    nw_hash_table_apply(tqh_last, (uint64_t)v68);

    goto LABEL_45;
  }

  if ((v2->flow_in_connected & 0x80000) == 0) {
    goto LABEL_45;
  }
  if (v2->empty_frame_pool.tqh_first)
  {
    os_log_type_t v7 = *(void **)&v2[-1].log_str[41];
    if (v7)
    {
      os_log_type_t v8 = (void *)v7[5];
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v10 = v7[11];
        if (v10) {
          v7[11] = v10 + 1;
        }
        char v9 = -1;
      }

      else
      {
        char v9 = 0;
      }

      *(void *)v74 = v7;
      char v75 = v9;
      os_log_type_t v11 = *(void **)&v2[-1].log_str[33];
      if (v11 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v13 = *(void *)&v2[-1].log_str[81];
        if (v13) {
          *(void *)&v2[-1].log_str[81] = v13 + 1;
        }
        char v12 = -1;
      }

      else
      {
        char v12 = 0;
      }

      p_paths_log_id_num = &v2[-1].paths_log_id_num;
      char v73 = v12;
      uint64_t v14 = v7[3];
      if (v14)
      {
        os_log_type_t v15 = *(void (**)(void *, unsigned __int16 *))(v14 + 64);
        if (v15)
        {
          v15(v7, &v2[-1].paths_log_id_num);
LABEL_21:
          if (v11 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
          }
          if (v8 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v74);
          }
LABEL_25:
          char v5 = BYTE3(v2->flow_in_connected);
          goto LABEL_26;
        }
      }

      __nwlog_obj();
      os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
      __int16 v26 = (const char *)v7[2];
      __int16 v27 = "invalid";
      *(_DWORD *)buf = 136446722;
      v77 = "__nw_protocol_input_available";
      if (v26) {
        __int16 v27 = v26;
      }
      __int16 v78 = 2082;
      v79 = (void *)v27;
      __int16 v80 = 2048;
      v81 = v7;
      os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v70 = 0;
      if (__nwlog_fault(v28, &type, &v70))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v30 = type;
          if (os_log_type_enabled(v29, type))
          {
            os_log_type_t v31 = (const char *)v7[2];
            if (!v31) {
              os_log_type_t v31 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v77 = "__nw_protocol_input_available";
            __int16 v78 = 2082;
            v79 = (void *)v31;
            __int16 v80 = 2048;
            v81 = v7;
            _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s protocol %{public}s (%p) has invalid input_available callback",  buf,  0x20u);
          }
        }

        else if (v70)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v43 = type;
          BOOL v44 = os_log_type_enabled(v29, type);
          if (backtrace_string)
          {
            if (v44)
            {
              int v45 = (const char *)v7[2];
              if (!v45) {
                int v45 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              v77 = "__nw_protocol_input_available";
              __int16 v78 = 2082;
              v79 = (void *)v45;
              __int16 v80 = 2048;
              v81 = v7;
              __int16 v82 = 2082;
              v83 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v29,  v43,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            goto LABEL_113;
          }

          if (v44)
          {
            char v64 = (const char *)v7[2];
            if (!v64) {
              char v64 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v77 = "__nw_protocol_input_available";
            __int16 v78 = 2082;
            v79 = (void *)v64;
            __int16 v80 = 2048;
            v81 = v7;
            _os_log_impl( &dword_181A5C000,  v29,  v43,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v60 = type;
          if (os_log_type_enabled(v29, type))
          {
            uint64_t v61 = (const char *)v7[2];
            if (!v61) {
              uint64_t v61 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v77 = "__nw_protocol_input_available";
            __int16 v78 = 2082;
            v79 = (void *)v61;
            __int16 v80 = 2048;
            v81 = v7;
            _os_log_impl( &dword_181A5C000,  v29,  v60,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

void sub_181E2E818( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v16 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  if (v14 == v12) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }
  if (v13 == v12) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);
  }

  _Unwind_Resume(a1);
}

uint64_t ___ZL49nw_protocol_instance_flush_batched_input_internalP31NWConcrete_nw_protocol_instance_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v101 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  object = (void *)nw_hash_node_get_object(a2);
  __int16 v6 = *(_WORD *)(extra + 52);
  if ((v6 & 0x10) == 0) {
    return 1LL;
  }
  os_log_type_t v7 = object;
  if (*(void *)(extra + 16))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = v8 - 96;
    }
    else {
      uint64_t v9 = 0LL;
    }
    if (object)
    {
      uint64_t v10 = (void *)object[5];
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v12 = object[11];
        if (v12) {
          object[11] = v12 + 1;
        }
        char v11 = -1;
      }

      else
      {
        char v11 = 0;
      }

      *(void *)v91 = object;
      char v92 = v11;
      if (v8)
      {
        uint64_t v13 = *(void **)(v9 + 40);
        if (v13 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v15 = *(void *)(v9 + 88);
          if (v15) {
            *(void *)(v9 + 88) = v15 + 1;
          }
          char v14 = -1;
        }

        else
        {
          char v14 = 0;
        }

        *(void *)v88 = v9;
        char v89 = v14;
        uint64_t v16 = object[3];
        if (v16)
        {
          __int16 v17 = *(void (**)(void *))(v16 + 64);
          if (v17)
          {
            v17(object);
LABEL_21:
            if (v13 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)v88);
            }
LABEL_23:
            if (v10 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)v91);
            }
LABEL_25:
            __int16 v6 = *(_WORD *)(extra + 52);
            goto LABEL_26;
          }
        }

        __nwlog_obj();
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = (const char *)v7[2];
        *(_DWORD *)buf = 136446722;
        v94 = "__nw_protocol_input_available";
        if (!v30) {
          os_log_type_t v30 = "invalid";
        }
        __int16 v95 = 2082;
        v96 = (void *)v30;
        __int16 v97 = 2048;
        v98 = v7;
        os_log_type_t v31 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v87 = 0;
        if (__nwlog_fault(v31, &type, &v87))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            BOOL v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v33 = type;
            if (os_log_type_enabled(v32, type))
            {
              os_log_type_t v34 = (const char *)v7[2];
              if (!v34) {
                os_log_type_t v34 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_input_available";
              __int16 v95 = 2082;
              v96 = (void *)v34;
              __int16 v97 = 2048;
              v98 = v7;
              _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s protocol %{public}s (%p) has invalid input_available callback",  buf,  0x20u);
            }
          }

          else if (v87)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v50 = type;
            BOOL v51 = os_log_type_enabled(v32, type);
            if (backtrace_string)
            {
              if (v51)
              {
                BOOL v52 = (const char *)v7[2];
                if (!v52) {
                  BOOL v52 = "invalid";
                }
                *(_DWORD *)buf = 136446978;
                v94 = "__nw_protocol_input_available";
                __int16 v95 = 2082;
                v96 = (void *)v52;
                __int16 v97 = 2048;
                v98 = v7;
                __int16 v99 = 2082;
                v100 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v32,  v50,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(backtrace_string);
              goto LABEL_137;
            }

            if (v51)
            {
              v81 = (const char *)v7[2];
              if (!v81) {
                v81 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_input_available";
              __int16 v95 = 2082;
              v96 = (void *)v81;
              __int16 v97 = 2048;
              v98 = v7;
              _os_log_impl( &dword_181A5C000,  v32,  v50,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace",  buf,  0x20u);
            }
          }

          else
          {
            __nwlog_obj();
            BOOL v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v77 = type;
            if (os_log_type_enabled(v32, type))
            {
              __int16 v78 = (const char *)v7[2];
              if (!v78) {
                __int16 v78 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_input_available";
              __int16 v95 = 2082;
              v96 = (void *)v78;
              __int16 v97 = 2048;
              v98 = v7;
              _os_log_impl( &dword_181A5C000,  v32,  v77,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded",  buf,  0x20u);
            }
          }
        }

LABEL_161:
    if (v42) {
      free(v42);
    }
    goto LABEL_25;
  }

  account_id = (const char *)nw_parameters_get_account_id(*((void **)handle + 40));
  if (account_id && !strncmp(account_id, "FT-P2P", 7uLL))
  {
    os_log_type_t v75 = (void *)*((void *)handle + 40);
    if (v75)
    {
      v111 = 0LL;
      v112 = &v111;
      v113 = 0x2000000000LL;
      v114 = 0;
      v107 = 0LL;
      v108 = &v107;
      v109 = 0x2000000000LL;
      v110 = 0LL;
      BOOL v76 = v75;
      os_log_type_t v77 = (nw_protocol_stack *)v76[19];

      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL46nw_masque_enable_spin_bit_for_ft_p2p_if_neededP9nw_masque_block_invoke;
      v124 = (const char *)&unk_189BBA4E8;
      *((void *)&v125 + 1) = &v107;
      v126 = handle;
      *(void *)&v125 = &v111;
      nw_protocol_stack_iterate_application_protocols(v77, buf);
      if (*((_BYTE *)v112 + 24))
      {
        if (v108[3])
        {
          __int16 v78 = 0LL;
        }

        else
        {
          uint64_t v84 = nw_protocol_stack_copy_transport_protocol(v77);
          __int16 v78 = v84;
          if (v84
            && (nw_protocol_options_is_quic(v84)
             || nw_protocol_options_is_quic_connection(v78)
             || nw_protocol_options_is_quic_stream(v78)))
          {
            v108[3] = (uint64_t)v78;
            if ((v20[2] & 1) == 0)
            {
              if (gLogDatapath)
              {
                os_log_type_t v85 = v20;
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                os_log_type_t v86 = (os_log_s *)gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                {
                  char v87 = v108[3];
                  *(_DWORD *)os_log_type_t type = 136446978;
                  v116 = "nw_masque_enable_spin_bit_for_ft_p2p_if_needed";
                  v117 = 2082;
                  v118 = handle + 531;
                  v119 = 2080;
                  v120 = " ";
                  v121 = 2048;
                  v122 = v87;
                  _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sfound quic as transport protocol: %p",  (uint8_t *)type,  0x2Au);
                }

                os_log_type_t v20 = v85;
              }
            }
          }
        }

        os_log_type_t v79 = *(_DWORD *)v20;
        if (v108[3])
        {
          if ((v79 & 0x10000) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            __int16 v80 = (os_log_s *)gprivacy_proxyLogObj;
            if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              v116 = handle + 531;
              v117 = 2080;
              v118 = " ";
              _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_INFO,  "%{public}s%soverriding spin bit for quic below masque",  (uint8_t *)type,  0x16u);
            }
          }

          v81 = nw_quic_stream_copy_shared_connection_options((void *)v108[3]);
          nw_quic_connection_set_disable_spin_bit(v81, 1);

          os_log_type_t v82 = nw_quic_stream_copy_shared_connection_options((void *)v108[3]);
          nw_quic_connection_set_spin_bit_value(v82, 1);
        }

        else if ((v79 & 0x10000) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          v88 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            v116 = handle + 531;
            v117 = 2080;
            v118 = " ";
            _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_ERROR,  "%{public}s%scould not find quic options below masque",  (uint8_t *)type,  0x16u);
          }
        }

        if (v78) {
          os_release(v78);
        }
      }

      else if ((v20[2] & 1) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        os_log_type_t v83 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          v116 = handle + 531;
          v117 = 2080;
          v118 = " ";
          _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_ERROR,  "%{public}s%sdid not find self in protocol stack",  (uint8_t *)type,  0x16u);
        }
      }

      if (v77) {
        os_release(v77);
      }
      _Block_object_dispose(&v107, 8);
      _Block_object_dispose(&v111, 8);
      goto LABEL_200;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_enable_spin_bit_for_ft_p2p_if_needed";
    v96 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v111) = 0;
    if (__nwlog_fault(v96, type, &v111))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __int16 v97 = (os_log_s *)__nwlog_obj();
        v98 = type[0];
        if (!os_log_type_enabled(v97, type[0])) {
          goto LABEL_252;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_enable_spin_bit_for_ft_p2p_if_needed";
        __int16 v99 = "%{public}s called with null masque->parameters";
        goto LABEL_251;
      }

      if (!(_BYTE)v111)
      {
        __int16 v97 = (os_log_s *)__nwlog_obj();
        v98 = type[0];
        if (!os_log_type_enabled(v97, type[0])) {
          goto LABEL_252;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_enable_spin_bit_for_ft_p2p_if_needed";
        __int16 v99 = "%{public}s called with null masque->parameters, backtrace limit exceeded";
        goto LABEL_251;
      }

      v104 = (char *)__nw_create_backtrace_string();
      __int16 v97 = (os_log_s *)__nwlog_obj();
      v98 = type[0];
      v105 = os_log_type_enabled(v97, type[0]);
      if (v104)
      {
        if (v105)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_enable_spin_bit_for_ft_p2p_if_needed";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v104;
          _os_log_impl( &dword_181A5C000,  v97,  v98,  "%{public}s called with null masque->parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v104);
        goto LABEL_252;
      }

      if (v105)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_enable_spin_bit_for_ft_p2p_if_needed";
        __int16 v99 = "%{public}s called with null masque->parameters, no backtrace";
LABEL_251:
        _os_log_impl(&dword_181A5C000, v97, v98, v99, buf, 0xCu);
      }
    }

        *(_DWORD *)buf = 136446466;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = (char *)v90;
        uint64_t v57 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
        goto LABEL_162;
      }

      BOOL v52 = (os_log_s *)__nwlog_obj();
      __int16 v53 = uu;
      if (!os_log_type_enabled(v52, (os_log_type_t)uu)) {
        goto LABEL_163;
      }
      v71 = a1->default_input_handler;
      os_log_type_t v72 = "invalid";
      if (v71)
      {
        BOOL v73 = v71->identifier;
        if (v73) {
          os_log_type_t v72 = (const char *)v73;
        }
      }

      free(v79);
      if (!v71) {
        goto LABEL_199;
      }
      goto LABEL_198;
    }

    os_log_type_t v72 = (os_log_s *)__nwlog_obj();
    BOOL v73 = v105[0];
    if (!os_log_type_enabled(v72, v105[0])) {
      goto LABEL_197;
    }
    *(_DWORD *)buf = 136446210;
    v108 = "nw_http1_get_http1_protocol";
    v74 = "%{public}s called with null handle";
LABEL_196:
    _os_log_impl(&dword_181A5C000, v72, v73, v74, buf, 0xCu);
    goto LABEL_197;
  }

  uint64_t v3 = *((_DWORD *)handle + 6);
  uint64_t v4 = a1->handle;
  if (v3 == 1) {
    goto LABEL_10;
  }
  if (v3 != 2)
  {
    if (v3 != 3)
    {
LABEL_199:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v108 = "nw_protocol_http1_output_finished";
      BOOL v52 = (char *)_os_log_send_and_compose_impl();
      v105[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (v105[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v75 = (os_log_s *)gLogObj;
        BOOL v76 = v105[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, v105[0])) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_http1_output_finished";
        os_log_type_t v55 = "%{public}s called with null http1";
        goto LABEL_233;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v75 = (os_log_s *)gLogObj;
        BOOL v76 = v105[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, v105[0])) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_http1_output_finished";
        os_log_type_t v55 = "%{public}s called with null http1, backtrace limit exceeded";
        goto LABEL_233;
      }

      __int16 v97 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v75 = (os_log_s *)gLogObj;
      BOOL v76 = v105[0];
      v98 = os_log_type_enabled((os_log_t)gLogObj, v105[0]);
      if (!v97)
      {
        if (!v98) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_http1_output_finished";
        os_log_type_t v55 = "%{public}s called with null http1, no backtrace";
        goto LABEL_233;
      }

      if (v98)
      {
        *(_DWORD *)buf = 136446466;
        v108 = "nw_protocol_http1_output_finished";
        v109 = 2082;
        *(void *)v110 = v97;
        _os_log_impl( &dword_181A5C000,  v75,  v76,  "%{public}s called with null http1, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v97);
      goto LABEL_235;
    }

    char v5 = *((void *)handle + 2);
    if (v5)
    {
      uint64_t v4 = (void *)(v5 + 480);
      goto LABEL_10;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v108 = "nw_http1_get_http1_protocol";
    v71 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v105[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v72 = (os_log_s *)__nwlog_obj();
      BOOL v73 = v105[0];
      if (!os_log_type_enabled(v72, v105[0])) {
        goto LABEL_197;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_http1_get_http1_protocol";
      v74 = "%{public}s called with null handle->http1_connection";
      goto LABEL_196;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v72 = (os_log_s *)__nwlog_obj();
      BOOL v73 = v105[0];
      if (!os_log_type_enabled(v72, v105[0])) {
        goto LABEL_197;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_http1_get_http1_protocol";
      v74 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
      goto LABEL_196;
    }

    os_log_type_t v79 = (char *)__nw_create_backtrace_string();
    os_log_type_t v72 = (os_log_s *)__nwlog_obj();
    BOOL v73 = v105[0];
    char v89 = os_log_type_enabled(v72, v105[0]);
    if (!v79)
    {
      if (!v89) {
        goto LABEL_197;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_http1_get_http1_protocol";
      v74 = "%{public}s called with null handle->http1_connection, no backtrace";
      goto LABEL_196;
    }

    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      v108 = "nw_http1_get_http1_protocol";
      v109 = 2082;
      *(void *)v110 = v79;
      v81 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
      goto LABEL_160;
    }

    goto LABEL_161;
  }

  __int16 v6 = *((void *)handle + 1);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v108 = "nw_http1_get_http1_protocol";
    v71 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v105[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v72 = (os_log_s *)__nwlog_obj();
      BOOL v73 = v105[0];
      if (!os_log_type_enabled(v72, v105[0])) {
        goto LABEL_197;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_http1_get_http1_protocol";
      v74 = "%{public}s called with null handle->http1_stream";
      goto LABEL_196;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v72 = (os_log_s *)__nwlog_obj();
      BOOL v73 = v105[0];
      if (!os_log_type_enabled(v72, v105[0])) {
        goto LABEL_197;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_http1_get_http1_protocol";
      v74 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_196;
    }

    os_log_type_t v79 = (char *)__nw_create_backtrace_string();
    os_log_type_t v72 = (os_log_s *)__nwlog_obj();
    BOOL v73 = v105[0];
    v90 = os_log_type_enabled(v72, v105[0]);
    if (!v79)
    {
      if (!v90) {
        goto LABEL_197;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_http1_get_http1_protocol";
      v74 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_196;
    }

    if (v90)
    {
      *(_DWORD *)buf = 136446466;
      v108 = "nw_http1_get_http1_protocol";
      v109 = 2082;
      *(void *)v110 = v79;
      v81 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_160;
    }

    goto LABEL_161;
  }

  uint64_t v4 = (void *)(v6 + 248);
LABEL_10:
  if (!*v4) {
    goto LABEL_199;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v108 = "nw_protocol_http1_output_finished";
    BOOL v52 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v105[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v75 = (os_log_s *)__nwlog_obj();
      BOOL v76 = v105[0];
      if (!os_log_type_enabled(v75, v105[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_protocol_http1_output_finished";
      os_log_type_t v55 = "%{public}s called with null other_protocol";
    }

    else if (type[0])
    {
      os_log_type_t v58 = (char *)__nw_create_backtrace_string();
      os_log_type_t v75 = (os_log_s *)__nwlog_obj();
      BOOL v76 = v105[0];
      os_log_type_t v83 = os_log_type_enabled(v75, v105[0]);
      if (v58)
      {
        if (!v83) {
          goto LABEL_227;
        }
        *(_DWORD *)buf = 136446466;
        v108 = "nw_protocol_http1_output_finished";
        v109 = 2082;
        *(void *)v110 = v58;
        os_log_type_t v60 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_225;
      }

      if (!v83) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_protocol_http1_output_finished";
      os_log_type_t v55 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      os_log_type_t v75 = (os_log_s *)__nwlog_obj();
      BOOL v76 = v105[0];
      if (!os_log_type_enabled(v75, v105[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446210;
      v108 = "nw_protocol_http1_output_finished";
      os_log_type_t v55 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }

    goto LABEL_233;
  }

  if (v3 != 2)
  {
    if (v3 != 3)
    {
LABEL_217:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v108 = "nw_protocol_http1_output_finished";
      BOOL v52 = (char *)_os_log_send_and_compose_impl();
      v105[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (v105[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v75 = (os_log_s *)gLogObj;
        BOOL v76 = v105[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, v105[0])) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_http1_output_finished";
        os_log_type_t v55 = "%{public}s called with null http1_stream";
        goto LABEL_233;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v75 = (os_log_s *)gLogObj;
        BOOL v76 = v105[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, v105[0])) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_http1_output_finished";
        os_log_type_t v55 = "%{public}s called with null http1_stream, backtrace limit exceeded";
        goto LABEL_233;
      }

      os_log_type_t v58 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v75 = (os_log_s *)gLogObj;
      BOOL v76 = v105[0];
      __int16 v99 = os_log_type_enabled((os_log_t)gLogObj, v105[0]);
      if (!v58)
      {
        if (!v99) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_http1_output_finished";
        os_log_type_t v55 = "%{public}s called with null http1_stream, no backtrace";
        goto LABEL_233;
      }

      if (!v99) {
        goto LABEL_227;
      }
      *(_DWORD *)buf = 136446466;
      v108 = "nw_protocol_http1_output_finished";
      v109 = 2082;
      *(void *)v110 = v58;
      os_log_type_t v60 = "%{public}s called with null http1_stream, dumping backtrace:%{public}s";
      goto LABEL_225;
    }

    os_log_type_t v7 = *((void *)handle + 2);
    if (v7)
    {
      uint64_t v8 = (uint64_t *)(v7 + 488);
      goto LABEL_17;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v108 = "nw_http1_get_stream_for_protocol";
    uint64_t v84 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v84, v105, type))
    {
      if (v105[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v85 = (os_log_s *)__nwlog_obj();
        os_log_type_t v86 = v105[0];
        if (!os_log_type_enabled(v85, v105[0])) {
          goto LABEL_215;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_http1_get_stream_for_protocol";
        char v87 = "%{public}s called with null handle->http1_connection";
        goto LABEL_214;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v85 = (os_log_s *)__nwlog_obj();
        os_log_type_t v86 = v105[0];
        if (!os_log_type_enabled(v85, v105[0])) {
          goto LABEL_215;
        }
        *(_DWORD *)buf = 136446210;
        v108 = "nw_http1_get_stream_for_protocol";
        char v87 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_214;
      }

      v91 = (char *)__nw_create_backtrace_string();
      os_log_type_t v85 = (os_log_s *)__nwlog_obj();
      os_log_type_t v86 = v105[0];
      char v92 = os_log_type_enabled(v85, v105[0]);
      if (v91)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446466;
          v108 = "nw_http1_get_stream_for_protocol";
          v109 = 2082;
          *(void *)v110 = v91;
          _os_log_impl( &dword_181A5C000,  v85,  v86,  "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v91);
        goto LABEL_215;
      }

      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_http1_get_stream_for_protocol";
        char v87 = "%{public}s called with null handle->http1_connection, no backtrace";
LABEL_214:
        _os_log_impl(&dword_181A5C000, v85, v86, v87, buf, 0xCu);
      }
    }

    if (!v30) {
      goto LABEL_163;
    }
    goto LABEL_162;
  }

  __int16 v6 = *((void *)handle + 1);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v82 = "nw_http1_get_http1_protocol";
    os_log_type_t v30 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v71) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v31 = (os_log_s *)__nwlog_obj();
      BOOL v32 = type[0];
      if (!os_log_type_enabled(v31, type[0])) {
        goto LABEL_161;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v82 = "nw_http1_get_http1_protocol";
      os_log_type_t v33 = "%{public}s called with null handle->http1_stream";
      goto LABEL_160;
    }

    if (!(_BYTE)v71)
    {
      os_log_type_t v31 = (os_log_s *)__nwlog_obj();
      BOOL v32 = type[0];
      if (!os_log_type_enabled(v31, type[0])) {
        goto LABEL_161;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v82 = "nw_http1_get_http1_protocol";
      os_log_type_t v33 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_160;
    }

    os_log_type_t v40 = (char *)__nw_create_backtrace_string();
    os_log_type_t v31 = (os_log_s *)__nwlog_obj();
    BOOL v32 = type[0];
    uint64_t v61 = os_log_type_enabled(v31, type[0]);
    if (!v40)
    {
      if (!v61) {
        goto LABEL_161;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v82 = "nw_http1_get_http1_protocol";
      os_log_type_t v33 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_160;
    }

    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v82 = "nw_http1_get_http1_protocol";
      os_log_type_t v83 = 2082;
      uint64_t v84 = v40;
      __int16 v42 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_123;
    }

    goto LABEL_124;
  }

  handle = (_DWORD *)(v6 + 248);
LABEL_10:
  os_log_type_t v7 = *(void *)handle;
  if (!v7) {
    goto LABEL_163;
  }
  if (a2)
  {
    *(void *)os_log_type_t type = 0LL;
    BOOL v76 = type;
    os_log_type_t v77 = 0x2000000000LL;
    __int16 v78 = 0LL;
    v71 = 0LL;
    os_log_type_t v72 = &v71;
    BOOL v73 = 0x2000000000LL;
    v74 = 0LL;
    v64[0] = MEMORY[0x1895F87A8];
    v64[1] = 0x40000000LL;
    os_log_type_t v65 = (uint64_t (*)(void *))___ZL40nw_protocol_http1_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
    os_log_type_t v66 = &unk_189BBD9F8;
    os_log_type_t v69 = v7;
    BOOL v70 = a2;
    BOOL v67 = type;
    uint64_t v68 = &v71;
    tqh_first = a2->tqh_first;
    do
    {
      if (!tqh_first) {
        break;
      }
      uint64_t v9 = (nw_frame *)*((void *)tqh_first + 4);
      uint64_t v10 = v65(v64);
      tqh_first = v9;
    }

    while ((v10 & 1) != 0);
    if (!a2->tqh_first) {
      goto LABEL_47;
    }
    if (*((void *)v76 + 3))
    {
      char v11 = v72[3];
      if (v11)
      {
        if ((*(_WORD *)(v11 + 428) & 2) != 0)
        {
          if ((*(_BYTE *)(v11 + 158) & 1) == 0)
          {
            if (gLogDatapath)
            {
              uint64_t v16 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
              {
                __int16 v17 = v72[3];
                uint64_t v18 = (char *)(v17 + 74);
                uint64_t v19 = *(void *)(v17 + 256);
                os_log_type_t v20 = *(_DWORD *)(*(void *)(v17 + 248) + 372LL);
                if (v19) {
                  LODWORD(v19) = *(_DWORD *)(v19 + 860);
                }
                char v21 = *(_DWORD *)(v17 + 424);
                *(_DWORD *)buf = 136447490;
                os_log_type_t v82 = "nw_protocol_http1_finalize_output_frames";
                os_log_type_t v83 = 2082;
                uint64_t v84 = v18;
                os_log_type_t v85 = 2080;
                os_log_type_t v86 = " ";
                char v87 = 1024;
                v88 = v20;
                char v89 = 1024;
                v90 = v19;
                v91 = 1024;
                char v92 = v21;
                _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> passing through frames",  buf,  0x32u);
              }
            }
          }

    free(v13);
    goto LABEL_162;
  }

  clientUUID = v4->_clientUUID;
  if (clientUUID)
  {
    os_log_type_t v7 = clientUUID;
    uuid_parse(-[NSString UTF8String](v7, "UTF8String"), uu);
  }

  v145 = v3;
  directInterface = v5->_directInterface;
  if (directInterface)
  {
    uint64_t v9 = directInterface;
    -[PBCodable data](v9, "data");
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    v147 = +[NWInterface interfaceWithProtocolBufferData:](&OBJC_CLASS___NWInterface, "interfaceWithProtocolBufferData:", v10);
  }

  else
  {
    v147 = 0LL;
  }

  delegateInterface = v5->_delegateInterface;
  if (delegateInterface)
  {
    uint64_t v18 = delegateInterface;
    -[PBCodable data](v18, "data");
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    v146 = +[NWInterface interfaceWithProtocolBufferData:](&OBJC_CLASS___NWInterface, "interfaceWithProtocolBufferData:", v19);
  }

  else
  {
    v146 = 0LL;
  }

  if (!-[NSMutableArray count](v5->_agents, "count"))
  {
    xdict = 0LL;
    goto LABEL_145;
  }

  xdict = xpc_dictionary_create(0LL, 0LL, 0LL);
  v157 = 0u;
  v158 = 0u;
  v159 = 0u;
  v160 = 0u;
  v143 = v5;
  obj = v5->_agents;
  v153 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v157,  v162,  16LL);
  if (!v153)
  {
LABEL_143:

    char v5 = v143;
LABEL_145:
    endpoint = v5->_endpoint;
    if (endpoint)
    {
      v118 = endpoint;
      v119 = -[PBCodable data](v118, "data");
      v120 = +[NWEndpoint endpointWithProtocolBufferData:](&OBJC_CLASS___NWEndpoint, "endpointWithProtocolBufferData:", v119);
    }

    else
    {
      v120 = 0LL;
    }

    parameters = v5->_parameters;
    if (parameters)
    {
      v122 = parameters;
      v123 = -[PBCodable data](v122, "data");
      v124 = +[NWParameters parametersWithProtocolBufferData:]( &OBJC_CLASS___NWParameters,  "parametersWithProtocolBufferData:",  v123);
    }

    else
    {
      v124 = 0LL;
    }

    objc_msgSend(v120, "internalEndpoint", v138, v139);
    v152 = (void *)objc_claimAutoreleasedReturnValue();
    [v124 internalParameters];
    obja = (id)objc_claimAutoreleasedReturnValue();
    v154 = v124;
    lengtha = v120;
    if ((*(_BYTE *)&v5->_has & 1) != 0) {
      status = v5->_status;
    }
    else {
      status = 0;
    }
    direct = v5->_direct;
    local = v5->_local;
    ipuint64_t v4 = v5->_ipv4;
    ip__int16 v6 = v5->_ipv6;
    [v147 internalInterface];
    v129 = (void *)objc_claimAutoreleasedReturnValue();
    [v146 internalInterface];
    v130 = (void *)objc_claimAutoreleasedReturnValue();
    v131 = nw_path_create_static(v152, obja, status, uu, direct, local, ipv4, ipv6, v129, v130, xdict);

    v132 = -[NWPath initWithPath:](objc_alloc(&OBJC_CLASS___NWPath), "initWithPath:", v131);
    char v11 = v145;
    goto LABEL_163;
  }

  v151 = *(void *)v158;
  os_log_type_t v20 = &OBJC_IVAR___NWConcrete_nw_browse_result_txt_record;
LABEL_18:
  char v21 = 0LL;
  while (1)
  {
    if (*(void *)v158 != v151) {
      objc_enumerationMutation(obj);
    }
    uint64_t v22 = *(void *)(*((void *)&v157 + 1) + 8 * v21);
    if (v22 && (uint64_t v23 = *(void **)(v22 + 16)) != 0LL)
    {
      char v24 = v23;
      uint64_t v25 = [v24 length];
    }

    else
    {
      uint64_t v25 = 0LL;
    }

    uint64_t v26 = (unsigned __int8 *)calloc(1uLL, v25 + 8);
    if (v26)
    {
      length = v25 + 8;
      if (v22) {
        goto LABEL_28;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v111 = (os_log_s *)(id)gLogObj;
      os_log_type_enabled(v111, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v165 = "strict_calloc";
      v166 = 2048;
      v167 = 1LL;
      v168 = 2048;
      v169 = v25 + 8;
      LODWORD(v139) = 32;
      v138 = buf;
      v112 = (void *)_os_log_send_and_compose_impl();

      nw_ws_response_t result = (NWPath *)__nwlog_abort((uint64_t)v112);
      if ((_DWORD)result) {
        goto LABEL_172;
      }
      free(v112);
      length = v25 + 8;
      if (v22)
      {
LABEL_28:
        __int16 v27 = *(void **)(v22 + 32);
        goto LABEL_29;
      }
    }

    __int16 v27 = 0LL;
LABEL_29:
    os_log_type_t v28 = v27;
    uuid_parse((const char *)[v28 UTF8String], v26);
    uint64_t v29 = xpc_dictionary_create(0LL, 0LL, 0LL);
    if (v22)
    {
      os_log_type_t v30 = *(id *)(v22 + v20[743]);
      os_log_type_t v31 = v30;
      if (v30) {
        BOOL v32 = (void *)*((void *)v30 + 1);
      }
      else {
        BOOL v32 = 0LL;
      }
    }

    else
    {
      os_log_type_t v31 = 0LL;
      BOOL v32 = 0LL;
    }

    os_log_type_t v33 = v32;

    if ([v33 UTF8String])
    {
      os_log_type_t v34 = (unsigned __int8 *)[v33 UTF8String];
      if (!v34)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v114 = (os_log_s *)(id)gLogObj;
        os_log_type_enabled(v114, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v165 = "_strict_strlcpy";
        LODWORD(v139) = 12;
        v138 = buf;
        v115 = (void *)_os_log_send_and_compose_impl();

        nw_ws_response_t result = (NWPath *)__nwlog_abort((uint64_t)v115);
        if ((_DWORD)result) {
          goto LABEL_172;
        }
        free(v115);
        os_log_type_t v20 = &OBJC_IVAR___NWConcrete_nw_browse_result_txt_record;
      }

      BOOL v35 = *v34;
      v26[16] = v35;
      if (v35)
      {
        os_log_type_t v36 = v34[1];
        v26[17] = v36;
        if (v36)
        {
          BOOL v37 = v34[2];
          v26[18] = v37;
          if (v37)
          {
            uint64_t v38 = v34[3];
            v26[19] = v38;
            if (v38)
            {
              os_log_type_t v39 = v34[4];
              v26[20] = v39;
              if (v39)
              {
                os_log_type_t v40 = v34[5];
                v26[21] = v40;
                if (v40)
                {
                  os_log_type_t v41 = v34[6];
                  v26[22] = v41;
                  if (v41)
                  {
                    __int16 v42 = v34[7];
                    v26[23] = v42;
                    if (v42)
                    {
                      os_log_type_t v43 = v34[8];
                      v26[24] = v43;
                      if (v43)
                      {
                        os_log_type_t v44 = v34[9];
                        v26[25] = v44;
                        if (v44)
                        {
                          int v45 = v34[10];
                          v26[26] = v45;
                          if (v45)
                          {
                            __int16 v46 = v34[11];
                            v26[27] = v46;
                            if (v46)
                            {
                              os_log_type_t v47 = v34[12];
                              v26[28] = v47;
                              if (v47)
                              {
                                os_log_type_t v48 = v34[13];
                                v26[29] = v48;
                                if (v48)
                                {
                                  os_log_type_t v49 = v34[14];
                                  v26[30] = v49;
                                  if (v49)
                                  {
                                    os_log_type_t v50 = v34[15];
                                    v26[31] = v50;
                                    if (v50)
                                    {
                                      BOOL v51 = v34[16];
                                      v26[32] = v51;
                                      if (v51)
                                      {
                                        BOOL v52 = v34[17];
                                        v26[33] = v52;
                                        if (v52)
                                        {
                                          __int16 v53 = v34[18];
                                          v26[34] = v53;
                                          if (v53)
                                          {
                                            uint64_t v54 = v34[19];
                                            v26[35] = v54;
                                            if (v54)
                                            {
                                              os_log_type_t v55 = v34[20];
                                              v26[36] = v55;
                                              if (v55)
                                              {
                                                os_log_type_t v56 = v34[21];
                                                v26[37] = v56;
                                                if (v56)
                                                {
                                                  uint64_t v57 = v34[22];
                                                  v26[38] = v57;
                                                  if (v57)
                                                  {
                                                    os_log_type_t v58 = v34[23];
                                                    v26[39] = v58;
                                                    if (v58)
                                                    {
                                                      BOOL v59 = v34[24];
                                                      v26[40] = v59;
                                                      if (v59)
                                                      {
                                                        os_log_type_t v60 = v34[25];
                                                        v26[41] = v60;
                                                        if (v60)
                                                        {
                                                          uint64_t v61 = v34[26];
                                                          v26[42] = v61;
                                                          if (v61)
                                                          {
                                                            os_log_type_t v62 = v34[27];
                                                            v26[43] = v62;
                                                            if (v62)
                                                            {
                                                              BOOL v63 = v34[28];
                                                              v26[44] = v63;
                                                              if (v63)
                                                              {
                                                                char v64 = v34[29];
                                                                v26[45] = v64;
                                                                if (v64)
                                                                {
                                                                  os_log_type_t v65 = v34[30];
                                                                  v26[46] = v65;
                                                                  if (v65) {
                                                                    v26[47] = 0;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (v22)
    {
      os_log_type_t v66 = *(id *)(v22 + v20[743]);
      BOOL v67 = v66;
      if (v66) {
        uint64_t v68 = (void *)*((void *)v66 + 2);
      }
      else {
        uint64_t v68 = 0LL;
      }
    }

    else
    {
      BOOL v67 = 0LL;
      uint64_t v68 = 0LL;
    }

    os_log_type_t v69 = v68;

    if ([v69 UTF8String])
    {
      BOOL v70 = (unsigned __int8 *)[v69 UTF8String];
      if (!v70)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v141 = (os_log_s *)(id)gLogObj;
        os_log_type_enabled(v141, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v165 = "_strict_strlcpy";
        LODWORD(v139) = 12;
        v138 = buf;
        v116 = (void *)_os_log_send_and_compose_impl();

        nw_ws_response_t result = (NWPath *)__nwlog_abort((uint64_t)v116);
        if ((_DWORD)result) {
          goto LABEL_172;
        }
        free(v116);
      }

      v71 = *v70;
      v26[48] = v71;
      if (v71)
      {
        os_log_type_t v72 = v70[1];
        v26[49] = v72;
        if (v72)
        {
          BOOL v73 = v70[2];
          v26[50] = v73;
          if (v73)
          {
            v74 = v70[3];
            v26[51] = v74;
            if (v74)
            {
              os_log_type_t v75 = v70[4];
              v26[52] = v75;
              if (v75)
              {
                BOOL v76 = v70[5];
                v26[53] = v76;
                if (v76)
                {
                  os_log_type_t v77 = v70[6];
                  v26[54] = v77;
                  if (v77)
                  {
                    __int16 v78 = v70[7];
                    v26[55] = v78;
                    if (v78)
                    {
                      os_log_type_t v79 = v70[8];
                      v26[56] = v79;
                      if (v79)
                      {
                        __int16 v80 = v70[9];
                        v26[57] = v80;
                        if (v80)
                        {
                          v81 = v70[10];
                          v26[58] = v81;
                          if (v81)
                          {
                            os_log_type_t v82 = v70[11];
                            v26[59] = v82;
                            if (v82)
                            {
                              os_log_type_t v83 = v70[12];
                              v26[60] = v83;
                              if (v83)
                              {
                                uint64_t v84 = v70[13];
                                v26[61] = v84;
                                if (v84)
                                {
                                  os_log_type_t v85 = v70[14];
                                  v26[62] = v85;
                                  if (v85)
                                  {
                                    os_log_type_t v86 = v70[15];
                                    v26[63] = v86;
                                    if (v86)
                                    {
                                      char v87 = v70[16];
                                      v26[64] = v87;
                                      if (v87)
                                      {
                                        v88 = v70[17];
                                        v26[65] = v88;
                                        if (v88)
                                        {
                                          char v89 = v70[18];
                                          v26[66] = v89;
                                          if (v89)
                                          {
                                            v90 = v70[19];
                                            v26[67] = v90;
                                            if (v90)
                                            {
                                              v91 = v70[20];
                                              v26[68] = v91;
                                              if (v91)
                                              {
                                                char v92 = v70[21];
                                                v26[69] = v92;
                                                if (v92)
                                                {
                                                  v93 = v70[22];
                                                  v26[70] = v93;
                                                  if (v93)
                                                  {
                                                    v94 = v70[23];
                                                    v26[71] = v94;
                                                    if (v94)
                                                    {
                                                      __int16 v95 = v70[24];
                                                      v26[72] = v95;
                                                      if (v95)
                                                      {
                                                        v96 = v70[25];
                                                        v26[73] = v96;
                                                        if (v96)
                                                        {
                                                          __int16 v97 = v70[26];
                                                          v26[74] = v97;
                                                          if (v97)
                                                          {
                                                            v98 = v70[27];
                                                            v26[75] = v98;
                                                            if (v98)
                                                            {
                                                              __int16 v99 = v70[28];
                                                              v26[76] = v99;
                                                              if (v99)
                                                              {
                                                                v100 = v70[29];
                                                                v26[77] = v100;
                                                                if (v100)
                                                                {
                                                                  uint64_t v101 = v70[30];
                                                                  v26[78] = v101;
                                                                  if (v101) {
                                                                    v26[79] = 0;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    v102 = v22 ? *(void **)(v22 + 24) : 0LL;
    v103 = v102;
    if ([v103 UTF8String]) {
      break;
    }
LABEL_111:
    if (v22)
    {
      if (*(_BYTE *)(v22 + 40)) {
        *((_DWORD *)v26 + 52) |= 2u;
      }
      if (*(_BYTE *)(v22 + 43)) {
        *((_DWORD *)v26 + 52) |= 8u;
      }
      if (*(_BYTE *)(v22 + 44)) {
        *((_DWORD *)v26 + 52) |= 0x10u;
      }
      if (*(_BYTE *)(v22 + 41)) {
        *((_DWORD *)v26 + 52) |= 0x40u;
      }
      if (*(_BYTE *)(v22 + 42)) {
        *((_DWORD *)v26 + 52) |= 0x80u;
      }
      *((_DWORD *)v26 + 53) = v25;
      if (!v25) {
        goto LABEL_125;
      }
      v108 = *(void **)(v22 + 16);
    }

    else
    {
      *((_DWORD *)v26 + 53) = v25;
      if (!v25) {
        goto LABEL_125;
      }
      v108 = 0LL;
    }

    v109 = v108;
    [v109 getBytes:v26 + 216 length:v25];

LABEL_125:
    xpc_dictionary_set_data(v29, "data", v26, length);
    free(v26);
    v110 = (const char *)[v28 UTF8String];
    if (v110) {
      xpc_dictionary_set_value(xdict, v110, v29);
    }

    ++v21;
    os_log_type_t v20 = &OBJC_IVAR___NWConcrete_nw_browse_result_txt_record;
    if (v21 == v153)
    {
      v153 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v157,  v162,  16LL);
      if (!v153) {
        goto LABEL_143;
      }
      goto LABEL_18;
    }
  }

  v104 = (unsigned __int8 *)[v103 UTF8String];
  if (v104) {
    goto LABEL_107;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v142 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v142, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v165 = "_strict_strlcpy";
  LODWORD(v139) = 12;
  v138 = buf;
  v140 = (void *)_os_log_send_and_compose_impl();

  nw_ws_response_t result = (NWPath *)__nwlog_abort((uint64_t)v140);
  if (!(_DWORD)result)
  {
    free(v140);
LABEL_107:
    v105 = v26 + 80;
    v106 = 128LL;
    while (1)
    {
      v107 = *v104;
      *v105 = v107;
      if (!v107) {
        goto LABEL_111;
      }
      ++v105;
      ++v104;
      if ((unint64_t)--v106 <= 1)
      {
        *v105 = 0;
        goto LABEL_111;
      }
    }
  }

    free(v66);
    if (!v59) {
      goto LABEL_181;
    }
    goto LABEL_179;
  }

  if (!v74)
  {
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
    }
    os_log_type_t v75 = (os_log_s *)(id)gbrowserLogObj;
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      BOOL v76 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v76;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v107;
      _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] new: removed %@ from new_results",  buf,  0x1Cu);
    }
  }

  xpc_dictionary_set_uint64(*((xpc_object_t *)v5 + 20), a2, uint64 | 4);
  if (!nw_parameters_get_logging_disabled(*((void *)v5 + 5)))
  {
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
    }
    os_log_type_t v77 = (os_log_s *)(id)gbrowserLogObj;
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
    {
      __int16 v78 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v78;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = a2;
      *(_WORD *)&buf[28] = 2112;
      *(void *)&buf[30] = v6;
      _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] changes_map: %s result_removed(%@)",  buf,  0x26u);
    }
  }

  os_log_type_t v79 = nw_browser_copy_old_result_locked((NWConcrete_nw_browser *)v5, a2);
  __int16 v80 = v79 == 0LL;

  uint64_t v8 = v107;
  if (v80) {
    xpc_dictionary_set_value(*((xpc_object_t *)v5 + 20), a2, 0LL);
  }
  nw_dictionary_set_value(*((void *)v5 + 21), a2, 0LL);
  os_log_type_t v56 = 1LL;
LABEL_183:

  return v56;
}

    if (v58) {
      free(v58);
    }
    goto LABEL_35;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v115 = "nw_protocol_http3_disconnected";
  os_log_type_t v49 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v112 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v50 = (os_log_s *)__nwlog_obj();
    BOOL v51 = type;
    if (!os_log_type_enabled(v50, type)) {
      goto LABEL_153;
    }
    *(_DWORD *)buf = 136446210;
    v115 = "nw_protocol_http3_disconnected";
    BOOL v52 = "%{public}s called with null http3";
    goto LABEL_152;
  }

  if (!v112)
  {
    os_log_type_t v50 = (os_log_s *)__nwlog_obj();
    BOOL v51 = type;
    if (!os_log_type_enabled(v50, type)) {
      goto LABEL_153;
    }
    *(_DWORD *)buf = 136446210;
    v115 = "nw_protocol_http3_disconnected";
    BOOL v52 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_152;
  }

  os_log_type_t v82 = (char *)__nw_create_backtrace_string();
  os_log_type_t v50 = (os_log_s *)__nwlog_obj();
  BOOL v51 = type;
  os_log_type_t v83 = os_log_type_enabled(v50, type);
  if (!v82)
  {
    if (!v83) {
      goto LABEL_153;
    }
    *(_DWORD *)buf = 136446210;
    v115 = "nw_protocol_http3_disconnected";
    BOOL v52 = "%{public}s called with null http3, no backtrace";
    goto LABEL_152;
  }

  if (v83)
  {
    *(_DWORD *)buf = 136446466;
    v115 = "nw_protocol_http3_disconnected";
    v116 = 2082;
    v117 = v82;
    _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null http3, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v82);
  if (v49) {
    goto LABEL_154;
  }
}

  __break(1u);
  return result;
}

            free(v86);
            goto LABEL_162;
          }

          __nwlog_obj();
          os_log_type_t v85 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
          LODWORD(v121) = 12;
          v120 = buf;
          os_log_type_t v86 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v128 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            char v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v88 = type;
            if (os_log_type_enabled(v87, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
              _os_log_impl(&dword_181A5C000, v87, v88, "%{public}s called with null metadata", buf, 0xCu);
            }
          }

          else if (v128)
          {
            __int16 v99 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            char v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v100 = type;
            uint64_t v101 = os_log_type_enabled(v87, type);
            if (v99)
            {
              if (v101)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v99;
                _os_log_impl( &dword_181A5C000,  v87,  v100,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v99);
              goto LABEL_160;
            }

            if (v101)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
              _os_log_impl(&dword_181A5C000, v87, v100, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            char v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v109 = type;
            if (os_log_type_enabled(v87, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
              _os_log_impl( &dword_181A5C000,  v87,  v109,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
            }
          }

      goto LABEL_70;
    }

    if (!v91)
    {
      __nwlog_obj();
      os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v72 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl( &dword_181A5C000,  v36,  v72,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_161;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v67 = type;
    uint64_t v68 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v36, v67, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_161;
    }

    if (v68)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v94 = 2082;
      __int16 v95 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v36,  v67,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

                  _Block_object_dispose(v323, 8);
                  os_log_type_t v86 = (nw_protocol *)*p_output_handler;
                  goto LABEL_162;
                }

                __nwlog_obj();
                v184 = v281->identifier->name;
                *(_DWORD *)v330 = 136446722;
                *(void *)&v330[4] = "__nw_protocol_get_input_frames";
                if (!v184) {
                  v184 = "invalid";
                }
                v331 = 2082;
                v332 = (nw_protocol *)v184;
                v333 = 2048;
                v334 = v281;
                v185 = (const char *)_os_log_send_and_compose_impl();
                v321[0] = OS_LOG_TYPE_ERROR;
                v320 = OS_LOG_TYPE_DEFAULT;
                v280 = (char *)v185;
                if (__nwlog_fault(v185, v321, &v320))
                {
                  if (v321[0] == OS_LOG_TYPE_FAULT)
                  {
                    v186 = (os_log_s *)__nwlog_obj();
                    v187 = v321[0];
                    if (os_log_type_enabled(v186, v321[0]))
                    {
                      v188 = v281->identifier->name;
                      if (!v188) {
                        v188 = "invalid";
                      }
                      *(_DWORD *)v330 = 136446722;
                      *(void *)&v330[4] = "__nw_protocol_get_input_frames";
                      v331 = 2082;
                      v332 = (nw_protocol *)v188;
                      v333 = 2048;
                      v334 = v281;
                      v189 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_388:
                      v245 = v186;
                      v246 = v187;
LABEL_389:
                      _os_log_impl(&dword_181A5C000, v245, v246, v189, v330, 0x20u);
                    }
                  }

                  else if (v320)
                  {
                    v212 = (char *)__nw_create_backtrace_string();
                    v213 = (os_log_s *)__nwlog_obj();
                    v278 = v321[0];
                    v214 = os_log_type_enabled(v213, v321[0]);
                    if (v212)
                    {
                      if (v214)
                      {
                        v215 = v281->identifier->name;
                        if (!v215) {
                          v215 = "invalid";
                        }
                        *(_DWORD *)v330 = 136446978;
                        *(void *)&v330[4] = "__nw_protocol_get_input_frames";
                        v331 = 2082;
                        v332 = (nw_protocol *)v215;
                        v333 = 2048;
                        v334 = v281;
                        v335 = 2082;
                        v336 = v212;
                        _os_log_impl( &dword_181A5C000,  v213,  v278,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s",  v330,  0x2Au);
                      }

                      free(v212);
                      goto LABEL_390;
                    }

                    if (v214)
                    {
                      v251 = v281->identifier->name;
                      if (!v251) {
                        v251 = "invalid";
                      }
                      *(_DWORD *)v330 = 136446722;
                      *(void *)&v330[4] = "__nw_protocol_get_input_frames";
                      v331 = 2082;
                      v332 = (nw_protocol *)v251;
                      v333 = 2048;
                      v334 = v281;
                      v189 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
                      v245 = v213;
                      v246 = v278;
                      goto LABEL_389;
                    }
                  }

                  else
                  {
                    v186 = (os_log_s *)__nwlog_obj();
                    v187 = v321[0];
                    if (os_log_type_enabled(v186, v321[0]))
                    {
                      v244 = v281->identifier->name;
                      if (!v244) {
                        v244 = "invalid";
                      }
                      *(_DWORD *)v330 = 136446722;
                      *(void *)&v330[4] = "__nw_protocol_get_input_frames";
                      v331 = 2082;
                      v332 = (nw_protocol *)v244;
                      v333 = 2048;
                      v334 = v281;
                      v189 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
                      goto LABEL_388;
                    }
                  }
                }

                if (v65) {
                  free(v65);
                }
                goto LABEL_46;
              }

              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              v115 = "__nw_protocol_finalize_output_frames";
              os_log_type_t v31 = _os_log_send_and_compose_impl();
              v113 = OS_LOG_TYPE_ERROR;
              v112 = 0;
              if (__nwlog_fault((const char *)v31, &v113, &v112))
              {
                if (v113 == OS_LOG_TYPE_FAULT)
                {
                  v74 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v75 = v113;
                  if (!os_log_type_enabled(v74, v113)) {
                    goto LABEL_168;
                  }
                  *(_DWORD *)buf = 136446210;
                  v115 = "__nw_protocol_finalize_output_frames";
                  BOOL v76 = "%{public}s called with null protocol";
                  goto LABEL_167;
                }

                if (!v112)
                {
                  v74 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v75 = v113;
                  if (!os_log_type_enabled(v74, v113)) {
                    goto LABEL_168;
                  }
                  *(_DWORD *)buf = 136446210;
                  v115 = "__nw_protocol_finalize_output_frames";
                  BOOL v76 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_167;
                }

                os_log_type_t v85 = (char *)__nw_create_backtrace_string();
                v74 = (os_log_s *)__nwlog_obj();
                os_log_type_t v75 = v113;
                os_log_type_t v86 = os_log_type_enabled(v74, v113);
                if (v85)
                {
                  if (v86)
                  {
                    *(_DWORD *)buf = 136446466;
                    v115 = "__nw_protocol_finalize_output_frames";
                    v116 = 2082;
                    v117 = v85;
                    _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v85);
                  if (!v31) {
                    goto LABEL_48;
                  }
LABEL_78:
                  free((void *)v31);
LABEL_48:
                  _Block_object_dispose(v109, 8);
                  goto LABEL_49;
                }

                if (v86)
                {
                  *(_DWORD *)buf = 136446210;
                  v115 = "__nw_protocol_finalize_output_frames";
                  BOOL v76 = "%{public}s called with null protocol, no backtrace";
LABEL_167:
                  _os_log_impl(&dword_181A5C000, v74, v75, v76, buf, 0xCu);
                }
              }

void sub_181E2F84C(_Unwind_Exception *exception_object)
{
}

uint64_t nw_protocol_implementation_finalize_pending_frames(void *a1)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  uint64_t v3 = v1 + 208;
  if (!*((void *)v1 + 26))
  {
    uint64_t v7 = 1LL;
    goto LABEL_15;
  }

  if ((v1[405] & 0x80000000) == 0 && gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      __int16 v42 = "nw_protocol_implementation_finalize_pending_frames";
      __int16 v43 = 2082;
      os_log_type_t v44 = v2 + 407;
      __int16 v45 = 2080;
      __int16 v46 = " ";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing outbound frames (batched)",  buf,  0x20u);
    }
  }

  uint64_t v4 = (const char *)*((void *)v2 - 8);
  if (!v4)
  {
    __nwlog_obj();
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v42 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

    v38[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v28, v38, &type))
    {
      if (v38[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = v38[0];
        if (os_log_type_enabled(v29, v38[0]))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v42 = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = v38[0];
        BOOL v33 = os_log_type_enabled(v29, v38[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v42 = "__nw_protocol_finalize_output_frames";
            __int16 v43 = 2082;
            os_log_type_t v44 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_69;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v42 = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = v38[0];
        if (os_log_type_enabled(v29, v38[0]))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v42 = "__nw_protocol_finalize_output_frames";
          _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t __nw_protocol_implementation_finalize_pending_frames_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t v6 = extra + 104;
  if (!*(void *)(extra + 104)) {
    return 1LL;
  }
  uint64_t v7 = extra;
  uint64_t v8 = *(void *)(a1 + 32);
  if ((!v8 || (*(char *)(v8 + 405) & 0x80000000) == 0) && gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      BOOL v28 = v27 == 0;
      if (v27) {
        uint64_t v29 = (const char *)(v27 + 407);
      }
      else {
        uint64_t v29 = "";
      }
      *(_DWORD *)buf = 136446978;
      __int16 v47 = "nw_protocol_implementation_finalize_pending_frames_block_invoke";
      __int16 v48 = 2082;
      uint64_t v49 = (void *)v29;
      if (v28) {
        os_log_type_t v30 = "";
      }
      else {
        os_log_type_t v30 = " ";
      }
      __int16 v50 = 2080;
      BOOL v51 = v30;
      __int16 v52 = 2048;
      uint64_t v53 = object;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing outbound frames for %lx (batched)",  buf,  0x2Au);
    }
  }

  uint64_t v9 = *(const char **)(v7 + 32);
  if (v9)
  {
    uint64_t v10 = (void *)*((void *)v9 + 5);
    if (v10 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v12 = *((void *)v9 + 11);
      if (v12) {
        *((void *)v9 + 11) = v12 + 1;
      }
      char v11 = -1;
    }

    else
    {
      char v11 = 0;
    }

    *(void *)__int16 v43 = v9;
    char v44 = v11;
    uint64_t v13 = *((void *)v9 + 3);
    if (v13)
    {
      char v14 = *(void (**)(const char *, uint64_t))(v13 + 96);
      if (v14)
      {
        v14(v9, v6);
LABEL_14:
        if (v10 == &nw_protocol_ref_counted_handle) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v43);
        }
        return 1LL;
      }
    }

    __nwlog_obj();
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v17 = (const char *)*((void *)v9 + 2);
    *(_DWORD *)buf = 136446722;
    __int16 v47 = "__nw_protocol_finalize_output_frames";
    if (!v17) {
      os_log_type_t v17 = "invalid";
    }
    __int16 v48 = 2082;
    uint64_t v49 = (void *)v17;
    __int16 v50 = 2048;
    BOOL v51 = v9;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v18, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          os_log_type_t v21 = (const char *)*((void *)v9 + 2);
          if (!v21) {
            os_log_type_t v21 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v47 = "__nw_protocol_finalize_output_frames";
          __int16 v48 = 2082;
          uint64_t v49 = (void *)v21;
          __int16 v50 = 2048;
          BOOL v51 = v9;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback",  buf,  0x20u);
        }
      }

      else if (v42)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        BOOL v33 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v33)
          {
            if (*((void *)v9 + 2)) {
              os_log_type_t v34 = (const char *)*((void *)v9 + 2);
            }
            else {
              os_log_type_t v34 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            __int16 v47 = "__nw_protocol_finalize_output_frames";
            __int16 v48 = 2082;
            uint64_t v49 = (void *)v34;
            __int16 v50 = 2048;
            BOOL v51 = v9;
            __int16 v52 = 2082;
            uint64_t v53 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v32,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_64;
        }

        if (v33)
        {
          if (*((void *)v9 + 2)) {
            os_log_type_t v40 = (const char *)*((void *)v9 + 2);
          }
          else {
            os_log_type_t v40 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v47 = "__nw_protocol_finalize_output_frames";
          __int16 v48 = 2082;
          uint64_t v49 = (void *)v40;
          __int16 v50 = 2048;
          BOOL v51 = v9;
          _os_log_impl( &dword_181A5C000,  v19,  v32,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v19, type))
        {
          char v39 = (const char *)*((void *)v9 + 2);
          if (!v39) {
            char v39 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v47 = "__nw_protocol_finalize_output_frames";
          __int16 v48 = 2082;
          uint64_t v49 = (void *)v39;
          __int16 v50 = 2048;
          BOOL v51 = v9;
          _os_log_impl( &dword_181A5C000,  v19,  v38,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

void sub_181E30634(_Unwind_Exception *exception_object)
{
}

uint64_t nw_protocol_instance_wait_for_early_data(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v16 = "nw_protocol_instance_wait_for_early_data";
    char v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v16 = "nw_protocol_instance_wait_for_early_data";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v16 = "nw_protocol_instance_wait_for_early_data";
            __int16 v17 = 2082;
            uint64_t v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v16 = "nw_protocol_instance_wait_for_early_data";
          _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v16 = "nw_protocol_instance_wait_for_early_data";
          _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E30908(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_reset_after_early_data(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 405) &= ~8u;
    if (*((_DWORD *)v1[1] + 16) == 3) {
      nw_hash_table_apply(v1[29], (uint64_t)&__block_literal_global_58);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_protocol_instance_reset_after_early_data";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_reset_after_early_data";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_protocol_instance_reset_after_early_data";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_reset_after_early_data";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_instance_reset_after_early_data";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_protocol_instance_reset_after_early_data_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  *(_WORD *)(extra + 52) &= ~0x10u;
  return 1LL;
}

void nw_protocol_instance_assert_fallback_agent(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = (void **)v1;
    uint64_t v4 = v3;
    if ((*((_BYTE *)v3[1] + 184) & 0x10) != 0
      && nw_parameters_get_multipath(v3[6])
      && *(void *)(*((void *)v4[1] + 10) + 208LL))
    {
      char v5 = *((_BYTE *)v4 + 405);

      if ((v5 & 4) == 0)
      {
        __int128 v22 = 0uLL;
        if (nw_path_get_fallback_agent(v4[36], &v22))
        {
          if ((*((char *)v4 + 405) & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v6 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446722;
              uint64_t v17 = "nw_protocol_instance_assert_fallback_agent";
              __int16 v18 = 2082;
              uint64_t v19 = (char *)v4 + 407;
              __int16 v20 = 2080;
              os_log_type_t v21 = " ";
              _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%sasserting fallback agent",  buf,  0x20u);
            }
          }

          nw_path_agent_action((NWConcrete_nw_path *)v4[36], (const unsigned __int8 *)&v22, 131);
        }
      }
    }

    else
    {
    }

    goto LABEL_13;
  }

  __nwlog_obj();
  os_log_type_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_protocol_instance_assert_fallback_agent";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v22) = 16;
  char v15 = 0;
  if (__nwlog_fault(v8, &v22, &v15))
  {
    if (v22 == 17)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v22;
      if (os_log_type_enabled(v9, (os_log_type_t)v22))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_assert_fallback_agent";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v22;
      BOOL v13 = os_log_type_enabled(v9, (os_log_type_t)v22);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_protocol_instance_assert_fallback_agent";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_assert_fallback_agent";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v22;
      if (os_log_type_enabled(v9, (os_log_type_t)v22))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_assert_fallback_agent";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E30F84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_unassert_fallback_agent(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = (void **)v1;
    uint64_t v4 = v3;
    if ((*((_BYTE *)v3[1] + 184) & 0x10) != 0
      && nw_parameters_get_multipath(v3[6])
      && *(void *)(*((void *)v4[1] + 10) + 208LL))
    {
      char v5 = *((_BYTE *)v4 + 405);

      if ((v5 & 4) == 0)
      {
        __int128 v22 = 0uLL;
        if (nw_path_get_fallback_agent(v4[36], &v22))
        {
          if ((*((char *)v4 + 405) & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v6 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446722;
              uint64_t v17 = "nw_protocol_instance_unassert_fallback_agent";
              __int16 v18 = 2082;
              uint64_t v19 = (char *)v4 + 407;
              __int16 v20 = 2080;
              os_log_type_t v21 = " ";
              _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%sunasserting fallback agent",  buf,  0x20u);
            }
          }

          nw_path_agent_action((NWConcrete_nw_path *)v4[36], (const unsigned __int8 *)&v22, 132);
        }
      }
    }

    else
    {
    }

    goto LABEL_13;
  }

  __nwlog_obj();
  os_log_type_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_protocol_instance_unassert_fallback_agent";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v22) = 16;
  char v15 = 0;
  if (__nwlog_fault(v8, &v22, &v15))
  {
    if (v22 == 17)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v22;
      if (os_log_type_enabled(v9, (os_log_type_t)v22))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_unassert_fallback_agent";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v22;
      BOOL v13 = os_log_type_enabled(v9, (os_log_type_t)v22);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_protocol_instance_unassert_fallback_agent";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_unassert_fallback_agent";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v22;
      if (os_log_type_enabled(v9, (os_log_type_t)v22))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_instance_unassert_fallback_agent";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E31328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_protocol_instance_copy_interface_for_path(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_interface_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_interface_for_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_interface_for_path";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_interface_for_path";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_instance_copy_interface_for_path";
      __int16 v26 = 2082;
      uint64_t v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_interface_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_interface_for_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path", buf, 0xCu);
      }

id nw_protocol_instance_copy_override_endpoint_for_path(void *a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v26 = "nw_protocol_instance_copy_override_endpoint_for_path";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_protocol_instance_copy_override_endpoint_for_path";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_39;
    }

    if (!v23)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_protocol_instance_copy_override_endpoint_for_path";
        _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_protocol_instance_copy_override_endpoint_for_path";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_39;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v26 = "nw_protocol_instance_copy_override_endpoint_for_path";
      __int16 v27 = 2082;
      uint64_t v28 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_27;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v26 = "nw_protocol_instance_copy_override_endpoint_for_path";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_protocol_instance_copy_override_endpoint_for_path";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null path", buf, 0xCu);
      }

uint64_t nw_protocol_instance_get_priority_for_path(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_get_priority_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_priority_for_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_priority_for_path";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_priority_for_path";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_instance_get_priority_for_path";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_get_priority_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_priority_for_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path", buf, 0xCu);
      }

id nw_protocol_instance_copy_local_cid_for_path(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_local_cid_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_local_cid_for_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_local_cid_for_path";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_local_cid_for_path";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_instance_copy_local_cid_for_path";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_local_cid_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_local_cid_for_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path", buf, 0xCu);
      }

id nw_protocol_instance_copy_remote_cid_for_path(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_remote_cid_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_remote_cid_for_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_remote_cid_for_path";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_remote_cid_for_path";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_instance_copy_remote_cid_for_path";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_remote_cid_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_remote_cid_for_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path", buf, 0xCu);
      }

id nw_protocol_instance_copy_initial_data_for_path(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_initial_data_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_initial_data_for_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_initial_data_for_path";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_initial_data_for_path";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_instance_copy_initial_data_for_path";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_copy_initial_data_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_copy_initial_data_for_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path", buf, 0xCu);
      }

uint64_t nw_protocol_instance_get_sockfd_for_path(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_get_sockfd_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_sockfd_for_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_sockfd_for_path";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_sockfd_for_path";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_instance_get_sockfd_for_path";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_instance_get_sockfd_for_path";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_instance_get_sockfd_for_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path", buf, 0xCu);
      }

void nw_protocol_instance_set_current_path(void *a1, uint64_t a2)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    if (a2)
    {
      uint64_t v5 = nw_protocol_implementation_lookup_path(v3, a2, 0LL);
      if (v5)
      {
        uint64_t v6 = v5;
        uint64_t v7 = (os_unfair_lock_s *)*(id *)(v5 + 96);
        id v8 = v7;
        if (v7)
        {
          BOOL v9 = v7;
          os_unfair_lock_lock(v8 + 24);
          id v10 = v9[6];
          os_unfair_lock_unlock(v8 + 24);
        }

        else
        {
          id v10 = 0LL;
        }

        os_log_type_t v15 = (os_unfair_lock_s *)*(id *)(v6 + 16);
        int v16 = SBYTE5(v4->flow_in_connected);
        if (v15)
        {
          os_log_type_t v14 = v15;
          if ((v16 & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v17 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136447490;
              os_log_type_t v83 = "nw_protocol_instance_set_current_path";
              __int16 v84 = 2082;
              os_log_type_t v85 = (char *)&v4->flow_in_connected + 7;
              __int16 v86 = 2080;
              char v87 = " ";
              __int16 v88 = 2048;
              p_os_unfair_lock_opaque = (_DWORD *)a2;
              __int16 v90 = 2112;
              v91 = v14;
              __int16 v92 = 2112;
              id v93 = v10;
              _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sNew current protocol_path %lx using interface %@, path %@",  buf,  0x3Eu);
            }

            LOBYTE(v16) = BYTE5(v4->flow_in_connected);
          }

          if (v8)
          {
            if ((v16 & 0x80) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v18 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
              {
                wakeup = v4->wakeup;
                *(_DWORD *)buf = 136447234;
                os_log_type_t v83 = "nw_protocol_instance_set_current_path";
                __int16 v84 = 2082;
                os_log_type_t v85 = (char *)&v4->flow_in_connected + 7;
                __int16 v86 = 2080;
                char v87 = " ";
                __int16 v88 = 2112;
                p_os_unfair_lock_opaque = wakeup;
                __int16 v90 = 2112;
                v91 = v8;
                _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sOverriding %@ with evaluator %@",  buf,  0x34u);
              }
            }

            nw_path_flow_registration_override_evaluator(v4->wakeup, v8);
            nw_path_flow_registration_override_interface_types(v4->wakeup, 0, 0, 0, 0, 0);
            if (SBYTE5(v4->flow_in_connected) < 0) {
              goto LABEL_41;
            }
LABEL_38:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v31 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446978;
              os_log_type_t v83 = "nw_protocol_instance_set_current_path";
              __int16 v84 = 2082;
              os_log_type_t v85 = (char *)&v4->flow_in_connected + 7;
              __int16 v86 = 2080;
              char v87 = " ";
              __int16 v88 = 2112;
              p_os_unfair_lock_opaque = &v14->_os_unfair_lock_opaque;
              _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%sCalling notify nw_protocol_notification_type_migration %@",  buf,  0x2Au);
            }

            goto LABEL_41;
          }

          if ((v16 & 0x80) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v21 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
            {
              char v22 = v4->wakeup;
              *(_DWORD *)buf = 136447234;
              os_log_type_t v83 = "nw_protocol_instance_set_current_path";
              __int16 v84 = 2082;
              os_log_type_t v85 = (char *)&v4->flow_in_connected + 7;
              __int16 v86 = 2080;
              char v87 = " ";
              __int16 v88 = 2112;
              p_os_unfair_lock_opaque = v22;
              __int16 v90 = 2112;
              v91 = v14;
              _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sOverriding %@ with properties from interface %@",  buf,  0x34u);
            }
          }

          nw_path_flow_registration_override_evaluator(v4->wakeup, 0LL);
          id v23 = v4->wakeup;
          os_log_type_t v24 = v14;
          __int16 v26 = (unsigned __int16 *)((char *)&v24[21]._os_unfair_lock_opaque + 1);
          __int16 v25 = *(_WORD *)((char *)&v24[21]._os_unfair_lock_opaque + 1);

          __int16 v27 = v24;
          LODWORD(v26) = *v26;

          uint64_t v28 = v27;
          os_log_type_t v30 = v28 + 96;
          int v29 = *((_DWORD *)v28 + 24);

          os_log_type_t v14 = v28;
          LODWORD(v30) = *v30;

          nw_path_flow_registration_override_interface_types( v23,  v25 & 1,  (v26 >> 1) & 1,  v29 == 1,  (_DWORD)v30 == 2,  0);
          id v8 = 0LL;
          if ((SBYTE5(v4->flow_in_connected) & 0x80000000) == 0) {
            goto LABEL_38;
          }
LABEL_41:
          if (v4->parent_definition->variant == 3)
          {
            tqh_last = (char *)v4->pending_outbound_frames.tqh_last;
            v73[0] = MEMORY[0x1895F87A8];
            v73[1] = 3221225472LL;
            v73[2] = __nw_protocol_instance_set_current_path_block_invoke;
            v73[3] = &unk_189BB7560;
            v74 = v4;
            os_log_type_t v14 = v14;
            os_log_type_t v75 = v14;
            nw_hash_table_apply(tqh_last, (uint64_t)v73);

            goto LABEL_62;
          }

          BOOL v33 = *(const char **)&v4[-1].log_str[41];
          if (v33)
          {
            os_log_type_t v34 = (void *)*((void *)v33 + 5);
            if (v34 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v36 = *((void *)v33 + 11);
              if (v36) {
                *((void *)v33 + 11) = v36 + 1;
              }
              char v35 = -1;
            }

            else
            {
              char v35 = 0;
            }

            *(void *)os_log_type_t type = v33;
            char v81 = v35;
            BOOL v37 = *(void **)&v4[-1].log_str[33];
            if (v37 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v39 = *(void *)&v4[-1].log_str[81];
              if (v39) {
                *(void *)&v4[-1].log_str[81] = v39 + 1;
              }
              char v38 = -1;
            }

            else
            {
              char v38 = 0;
            }

            p_paths_log_id_num = &v4[-1].paths_log_id_num;
            char v79 = v38;
            uint64_t v40 = *((void *)v33 + 3);
            if (v40)
            {
              os_log_type_t v41 = *(void (**)(const char *, unsigned __int16 *, uint64_t, os_unfair_lock_s *, uint64_t))(v40 + 160);
              if (v41)
              {
                v41(v33, &v4[-1].paths_log_id_num, 24LL, v14, 8LL);
                goto LABEL_57;
              }
            }

            __nwlog_obj();
            __int16 v46 = (void *)objc_claimAutoreleasedReturnValue();
            __int16 v47 = (const char *)*((void *)v33 + 2);
            *(_DWORD *)buf = 136446722;
            os_log_type_t v83 = "__nw_protocol_notify";
            if (!v47) {
              __int16 v47 = "invalid";
            }
            __int16 v84 = 2082;
            os_log_type_t v85 = (void *)v47;
            __int16 v86 = 2048;
            char v87 = v33;
            os_log_type_t v72 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t v77 = OS_LOG_TYPE_ERROR;
            char v76 = 0;
            __int16 v48 = (char *)v72;
            if (!__nwlog_fault(v72, &v77, &v76))
            {
LABEL_124:
              if (v48) {
                free(v48);
              }
LABEL_57:
              if (v37 == &nw_protocol_ref_counted_handle)
              {
                nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
                if (v34 != &nw_protocol_ref_counted_handle) {
                  goto LABEL_62;
                }
              }

              else if (v34 != &nw_protocol_ref_counted_handle)
              {
                goto LABEL_62;
              }

              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              goto LABEL_62;
            }

            if (v77 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v50 = v77;
              if (os_log_type_enabled(v49, v77))
              {
                BOOL v51 = (const char *)*((void *)v33 + 2);
                if (!v51) {
                  BOOL v51 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v83 = "__nw_protocol_notify";
                __int16 v84 = 2082;
                os_log_type_t v85 = (void *)v51;
                __int16 v86 = 2048;
                char v87 = v33;
                _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s protocol %{public}s (%p) has invalid notify callback",  buf,  0x20u);
              }
            }

            else if (v76)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v71 = v77;
              BOOL v61 = os_log_type_enabled(v49, v77);
              if (backtrace_string)
              {
                if (v61)
                {
                  os_log_type_t v62 = (const char *)*((void *)v33 + 2);
                  if (!v62) {
                    os_log_type_t v62 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  os_log_type_t v83 = "__nw_protocol_notify";
                  __int16 v84 = 2082;
                  os_log_type_t v85 = (void *)v62;
                  __int16 v86 = 2048;
                  char v87 = v33;
                  __int16 v88 = 2082;
                  p_os_unfair_lock_opaque = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v49,  v71,  "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                }

                free(backtrace_string);
                goto LABEL_123;
              }

              if (v61)
              {
                os_log_type_t v69 = (const char *)*((void *)v33 + 2);
                if (!v69) {
                  os_log_type_t v69 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v83 = "__nw_protocol_notify";
                __int16 v84 = 2082;
                os_log_type_t v85 = (void *)v69;
                __int16 v86 = 2048;
                char v87 = v33;
                _os_log_impl( &dword_181A5C000,  v49,  v71,  "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace",  buf,  0x20u);
              }
            }

            else
            {
              __nwlog_obj();
              uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v67 = v77;
              if (os_log_type_enabled(v49, v77))
              {
                uint64_t v68 = (const char *)*((void *)v33 + 2);
                if (!v68) {
                  uint64_t v68 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v83 = "__nw_protocol_notify";
                __int16 v84 = 2082;
                os_log_type_t v85 = (void *)v68;
                __int16 v86 = 2048;
                char v87 = v33;
                _os_log_impl( &dword_181A5C000,  v49,  v67,  "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded",  buf,  0x20u);
              }
            }

LABEL_123:
            __int16 v48 = (char *)v72;
            goto LABEL_124;
          }

          __nwlog_obj();
          os_log_type_t v56 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "__nw_protocol_notify";
          uint64_t v57 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(p_paths_log_id_num) = 0;
          if (__nwlog_fault(v57, type, &p_paths_log_id_num))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v59 = type[0];
              if (os_log_type_enabled(v58, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v83 = "__nw_protocol_notify";
                _os_log_impl(&dword_181A5C000, v58, v59, "%{public}s called with null protocol", buf, 0xCu);
              }
            }

            else if ((_BYTE)p_paths_log_id_num)
            {
              BOOL v63 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v64 = type[0];
              BOOL v65 = os_log_type_enabled(v58, type[0]);
              if (v63)
              {
                if (v65)
                {
                  *(_DWORD *)buf = 136446466;
                  os_log_type_t v83 = "__nw_protocol_notify";
                  __int16 v84 = 2082;
                  os_log_type_t v85 = v63;
                  _os_log_impl( &dword_181A5C000,  v58,  v64,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v63);
                goto LABEL_132;
              }

              if (v65)
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v83 = "__nw_protocol_notify";
                _os_log_impl( &dword_181A5C000,  v58,  v64,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              os_log_type_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v70 = type[0];
              if (os_log_type_enabled(v58, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v83 = "__nw_protocol_notify";
                _os_log_impl( &dword_181A5C000,  v58,  v70,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

BOOL nw_protocol_implementation_lookup_path( NWConcrete_nw_protocol_instance *a1, uint64_t current_path, unint64_t *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  uint64_t v6 = (char *)v5;
  if (!current_path)
  {
    current_path = (uint64_t)v5->current_path;
    if (a3) {
      *a3 = current_path;
    }
  }

  BOOL node = nw_hash_table_get_node((uint64_t)v5->flow_registration, current_path, 8LL);
  if (node)
  {
    BOOL v8 = node + 32;
  }

  else
  {
    if ((v6[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        int v11 = 136446978;
        os_log_type_t v12 = "nw_protocol_implementation_lookup_path";
        __int16 v13 = 2082;
        os_log_type_t v14 = v6 + 407;
        __int16 v15 = 2080;
        int v16 = " ";
        __int16 v17 = 2048;
        uint64_t v18 = current_path;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sNo path found for %lx",  (uint8_t *)&v11,  0x2Au);
      }
    }

    BOOL v8 = 0LL;
  }

  return v8;
}

uint64_t __nw_protocol_instance_set_current_path_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    uint64_t v5 = v4 - 96;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (object)
  {
    uint64_t v6 = object;
    uint64_t v7 = (void *)object[5];
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = object[11];
      if (v9) {
        object[11] = v9 + 1;
      }
      char v8 = -1;
    }

    else
    {
      char v8 = 0;
    }

    *(void *)uint64_t v49 = object;
    char v50 = v8;
    if (v4)
    {
      id v10 = *(void **)(v5 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v12 = *(void *)(v5 + 88);
        if (v12) {
          *(void *)(v5 + 88) = v12 + 1;
        }
        char v11 = -1;
      }

      else
      {
        char v11 = 0;
      }

      *(void *)__int16 v46 = v5;
      char v47 = v11;
      uint64_t v13 = object[3];
      if (v13)
      {
        os_log_type_t v14 = *(void (**)(void *))(v13 + 160);
        if (v14)
        {
          v14(object);
LABEL_19:
          if (v10 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v46);
          }
LABEL_21:
          if (v7 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v49);
          }
          return 1LL;
        }
      }

      __nwlog_obj();
      int v16 = (void *)objc_claimAutoreleasedReturnValue();
      __int16 v17 = (const char *)v6[2];
      *(_DWORD *)buf = 136446722;
      __int16 v52 = "__nw_protocol_notify";
      if (!v17) {
        __int16 v17 = "invalid";
      }
      __int16 v53 = 2082;
      os_log_type_t v54 = (void *)v17;
      __int16 v55 = 2048;
      os_log_type_t v56 = v6;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v45 = 0;
      if (__nwlog_fault(v18, &type, &v45))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v19, type))
          {
            os_log_type_t v21 = (const char *)v6[2];
            if (!v21) {
              os_log_type_t v21 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v52 = "__nw_protocol_notify";
            __int16 v53 = 2082;
            os_log_type_t v54 = (void *)v21;
            __int16 v55 = 2048;
            os_log_type_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s protocol %{public}s (%p) has invalid notify callback",  buf,  0x20u);
          }
        }

        else if (v45)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v31 = type;
          BOOL v32 = os_log_type_enabled(v19, type);
          if (backtrace_string)
          {
            if (v32)
            {
              BOOL v33 = (const char *)v6[2];
              if (!v33) {
                BOOL v33 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              __int16 v52 = "__nw_protocol_notify";
              __int16 v53 = 2082;
              os_log_type_t v54 = (void *)v33;
              __int16 v55 = 2048;
              os_log_type_t v56 = v6;
              __int16 v57 = 2082;
              os_log_type_t v58 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            goto LABEL_70;
          }

          if (v32)
          {
            char v42 = (const char *)v6[2];
            if (!v42) {
              char v42 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v52 = "__nw_protocol_notify";
            __int16 v53 = 2082;
            os_log_type_t v54 = (void *)v42;
            __int16 v55 = 2048;
            os_log_type_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v19, type))
          {
            os_log_type_t v41 = (const char *)v6[2];
            if (!v41) {
              os_log_type_t v41 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v52 = "__nw_protocol_notify";
            __int16 v53 = 2082;
            os_log_type_t v54 = (void *)v41;
            __int16 v55 = 2048;
            os_log_type_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v40,  "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

void sub_181E34DD0(_Unwind_Exception *exception_object)
{
}

uint64_t nw_protocol_instance_create_extra_path(void *a1, uint64_t a2, void *a3)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a3;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v37 = "nw_protocol_instance_create_extra_path";
    os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__buf) = 16;
    char v35 = 0;
    if (__buf == 17)
    {
      __nwlog_obj();
      char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = __buf;
      if (os_log_type_enabled(v22, (os_log_type_t)__buf))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v37 = "nw_protocol_instance_create_extra_path";
        _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v35)
    {
      __nwlog_obj();
      char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = __buf;
      if (os_log_type_enabled(v22, (os_log_type_t)__buf))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v37 = "nw_protocol_instance_create_extra_path";
        _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v27 = __buf;
    BOOL v28 = os_log_type_enabled(v22, (os_log_type_t)__buf);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v37 = "nw_protocol_instance_create_extra_path";
        _os_log_impl(&dword_181A5C000, v22, v27, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v37 = "nw_protocol_instance_create_extra_path";
      __int16 v38 = 2082;
      BOOL v39 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_42;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v37 = "nw_protocol_instance_create_extra_path";
    os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__buf) = 16;
    char v35 = 0;
    if (__buf == 17)
    {
      __nwlog_obj();
      char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = __buf;
      if (os_log_type_enabled(v22, (os_log_type_t)__buf))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v37 = "nw_protocol_instance_create_extra_path";
        _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null existing_path", buf, 0xCu);
      }

void sub_181E355D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_establish_path(void *a1, uint64_t a2)
{
  uint64_t v227 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = (char *)v3;
  if (!v3)
  {
    __nwlog_obj();
    v127 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
    v128 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst) = 16;
    LOBYTE(v219) = 0;
    if (__dst == 17)
    {
      __nwlog_obj();
      v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v130 = __dst;
      if (os_log_type_enabled(v129, (os_log_type_t)__dst))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
        _os_log_impl(&dword_181A5C000, v129, v130, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if ((_BYTE)v219)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v134 = __dst;
      BOOL v135 = os_log_type_enabled(v129, (os_log_type_t)__dst);
      if (backtrace_string)
      {
        if (v135)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v129,  v134,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_247:
        if (!v128) {
          goto LABEL_18;
        }
LABEL_248:
        free(v128);
        goto LABEL_18;
      }

      if (v135)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
        _os_log_impl(&dword_181A5C000, v129, v134, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v139 = __dst;
      if (os_log_type_enabled(v129, (os_log_type_t)__dst))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
        _os_log_impl( &dword_181A5C000,  v129,  v139,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E37A0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void *a49, uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59)
{
  if (a21 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>(&a59);
  }

  _Block_object_dispose(&a52, 8);
  _Block_object_dispose((const void *)(v61 - 224), 8);
  _Block_object_dispose((const void *)(v61 - 192), 8);

  _Unwind_Resume(a1);
}

BOOL __nw_protocol_instance_establish_path_block_invoke(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t protocol_handle = nw_protocol_options_get_protocol_handle(a4);
  uint64_t v7 = a1[4];
  if (v7) {
    uint64_t v8 = v7 - 96;
  }
  else {
    uint64_t v8 = 0LL;
  }
  if (v8 == protocol_handle)
  {
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
    *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = a2;
  }

  return v8 != protocol_handle;
}

uint64_t __nw_protocol_instance_establish_path_block_invoke_2( uint64_t a1, unint64_t a2, void *a3, void *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v7 = a3;
  id v8 = a4;
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) < a2)
  {
    uint64_t v9 = nw_protocol_instance_attach_protocol( *(void **)(a1 + 32),  v7,  v8,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL),  *(char **)(a1 + 64),  *(void *)(a1 + 72));
    if (!v9)
    {
      uint64_t v16 = 0LL;
      *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
      goto LABEL_15;
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v9;
    uint64_t v10 = *(void *)(a1 + 32);
    if (!v10 || (*(char *)(v10 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        BOOL v13 = v12 == 0;
        if (v12) {
          os_log_type_t v14 = (const char *)(v12 + 407);
        }
        else {
          os_log_type_t v14 = "";
        }
        int v18 = 136446978;
        uint64_t v19 = "nw_protocol_instance_establish_path_block_invoke_2";
        __int16 v20 = 2082;
        os_log_type_t v21 = v14;
        if (v13) {
          uint64_t v15 = "";
        }
        else {
          uint64_t v15 = " ";
        }
        __int16 v22 = 2080;
        os_log_type_t v23 = v15;
        __int16 v24 = 2114;
        id v25 = v7;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAttached application protocol: %{public}@",  (uint8_t *)&v18,  0x2Au);
      }
    }
  }

  uint64_t v16 = 1LL;
LABEL_15:

  return v16;
}

void sub_181E37E00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_set_protocol_instance(void *a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  if (!v8)
  {
    __nwlog_obj();
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_protocol_instance_set_protocol_instance";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v19, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_protocol_instance_set_protocol_instance";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null protocol_parameters", buf, 0xCu);
        }
      }

      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v31 = "nw_protocol_instance_set_protocol_instance";
            __int16 v32 = 2082;
            id v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_protocol_instance_set_protocol_instance";
          _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null protocol_parameters, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_protocol_instance_set_protocol_instance";
          _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null protocol_parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_protocol_instance_bring_up_channel(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v252 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  path = a4;
  if (v7)
  {
    if (!a2)
    {
      __nwlog_obj();
      int v110 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
      char v107 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v223) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v111 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
          _os_log_impl(&dword_181A5C000, v108, v111, "%{public}s called with null path", buf, 0xCu);
        }

        goto LABEL_220;
      }

      if (!(_BYTE)v223)
      {
        __nwlog_obj();
        uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v132 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
          _os_log_impl( &dword_181A5C000,  v108,  v132,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_220;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v120 = type[0];
      BOOL v121 = os_log_type_enabled(v108, type[0]);
      if (!backtrace_string)
      {
        if (v121)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
          _os_log_impl(&dword_181A5C000, v108, v120, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }

        goto LABEL_220;
      }

      if (v121)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v108,  v120,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_169;
    }

    if (!a3)
    {
      __nwlog_obj();
      uint64_t v112 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
      char v107 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v223) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v113 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
          _os_log_impl(&dword_181A5C000, v108, v113, "%{public}s called with null path_state", buf, 0xCu);
        }

        goto LABEL_220;
      }

      if (!(_BYTE)v223)
      {
        __nwlog_obj();
        uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v133 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
          _os_log_impl( &dword_181A5C000,  v108,  v133,  "%{public}s called with null path_state, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_220;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v122 = type[0];
      BOOL v123 = os_log_type_enabled(v108, type[0]);
      if (!backtrace_string)
      {
        if (v123)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
          _os_log_impl(&dword_181A5C000, v108, v122, "%{public}s called with null path_state, no backtrace", buf, 0xCu);
        }

        goto LABEL_220;
      }

      if (v123)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v108,  v122,  "%{public}s called with null path_state, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_169;
    }

    if (path)
    {
      if ((v7[405] & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          id v9 = *(char **)(a3 + 16);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v7 + 407;
          *(_WORD *)&buf[22] = 2080;
          v239 = " ";
          __int16 v240 = 2112;
          v241 = v9;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sReceived nexus assignment, bringing up channel for %@",  buf,  0x2Au);
        }
      }

      __int128 v250 = *((_OWORD *)v7 - 6);
      __int128 v249 = 0uLL;
      nw_path_flow_registration_get_id(*(void **)(a3 + 24), &v249);
      v191 = v7 - 96;
      *((_OWORD *)v7 - 6) = v249;
      *((void *)v7 + 40) = a2;
      nw_endpoint_t v10 = nw_path_copy_effective_remote_endpoint(path);
      size_t v11 = (void *)*((void *)v7 + 41);
      *((void *)v7 + 41) = v10;

      nw_endpoint_t v12 = nw_path_copy_effective_local_endpoint(path);
      int v13 = (void *)*((void *)v7 + 42);
      *((void *)v7 + 42) = v12;

      id v14 = *((id *)v7 + 6);
      BOOL v15 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v14,  0,  0);

      uint64_t v16 = (void *)*((void *)v7 + 43);
      *((void *)v7 + 43) = v15;

      nw_parameters_require_interface(*((nw_parameters_t *)v7 + 43), *(nw_interface_t *)(a3 + 16));
      int protocol_level = nw_path_flow_registration_get_protocol_level(path, *(void **)(a3 + 24));
      *(void *)os_log_type_t type = 0LL;
      v228 = type;
      uint64_t v229 = 0x2020000000LL;
      v230 = v7 - 96;
      uint64_t v223 = 0LL;
      v224 = &v223;
      uint64_t v225 = 0x2020000000LL;
      char v226 = 0;
      v222[0] = 0LL;
      v222[1] = v222;
      v222[2] = 0x2020000000LL;
      v222[3] = 0LL;
      int v18 = (void *)*((void *)v7 + 6);
      uint64_t v19 = MEMORY[0x1895F87A8];
      v218[0] = MEMORY[0x1895F87A8];
      v218[1] = 3221225472LL;
      v218[2] = ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke;
      v218[3] = &unk_189BB7588;
      __int16 v20 = v7;
      __int128 v219 = v20;
      uint64_t v220 = &v223;
      char v221 = v222;
      nw_parameters_internal_iterate_protocol_stack(v18, 4, 0, v218);
      if (*((_BYTE *)v224 + 24))
      {
        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2020000000LL;
        LOBYTE(v239) = 0;
        os_log_type_t v21 = (void *)*((void *)v7 + 43);
        v211[0] = v19;
        v211[1] = 3221225472LL;
        v211[2] = ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_2;
        v211[3] = &unk_189BB75B0;
        __int128 v213 = v222;
        __int16 v22 = v20;
        v212 = v22;
        v214 = type;
        __int16 v215 = buf;
        uint64_t v216 = a2;
        uint64_t v217 = a3;
        nw_parameters_internal_iterate_protocol_stack(v21, 4, 0, v211);
        if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
        {
          if ((v7[405] & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v23 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v244 = 136446722;
              *(void *)&v244[4] = "nw_protocol_instance_bring_up_channel";
              __int16 v245 = 2082;
              v246 = v22 + 407;
              __int16 v247 = 2080;
              v248 = " ";
              _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to attach application protocol",  v244,  0x20u);
            }
          }

          nw_protocol_instance_tear_down_path_inner(v22, a3);
          *(_OWORD *)v191 = v250;
          __int16 v24 = (void *)*((void *)v7 + 41);
          *((void *)v7 + 40) = 0LL;
          *((void *)v7 + 41) = 0LL;

          os_log_type_t v25 = (void *)*((void *)v7 + 42);
          *((void *)v7 + 42) = 0LL;

          BOOL v26 = (void *)*((void *)v7 + 43);
          *((void *)v7 + 43) = 0LL;

LABEL_24:
          _Block_object_dispose(buf, 8);
LABEL_291:

          _Block_object_dispose(v222, 8);
          _Block_object_dispose(&v223, 8);
          _Block_object_dispose(type, 8);
          goto LABEL_292;
        }

        _Block_object_dispose(buf, 8);
      }

      if ((protocol_level - 1) <= 2)
      {
        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2020000000LL;
        LOBYTE(v239) = 0;
        os_log_type_t v27 = (void *)*((void *)v7 + 43);
        v205[0] = v19;
        v205[1] = 3221225472LL;
        v205[2] = ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_251;
        v205[3] = &unk_189BB7698;
        char v28 = v20;
        char v206 = v28;
        v207 = type;
        uint64_t v209 = a2;
        uint64_t v210 = a3;
        v208 = buf;
        nw_parameters_internal_iterate_protocol_stack(v27, 3, 0, v205);
        if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
        {
          if ((v7[405] & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v29 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v244 = 136446722;
              *(void *)&v244[4] = "nw_protocol_instance_bring_up_channel";
              __int16 v245 = 2082;
              v246 = v28 + 407;
              __int16 v247 = 2080;
              v248 = " ";
              _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to attach transport protocol",  v244,  0x20u);
            }
          }

          nw_protocol_instance_tear_down_path_inner(v28, a3);
          *(_OWORD *)v191 = v250;
          BOOL v30 = (void *)*((void *)v7 + 41);
          *((void *)v7 + 40) = 0LL;
          *((void *)v7 + 41) = 0LL;

          os_log_type_t v31 = (void *)*((void *)v7 + 42);
          *((void *)v7 + 42) = 0LL;

          __int16 v32 = (void *)*((void *)v7 + 43);
          *((void *)v7 + 43) = 0LL;

          goto LABEL_24;
        }

        _Block_object_dispose(buf, 8);
        if ((protocol_level - 1) <= 1)
        {
          *(void *)buf = 0LL;
          *(void *)&buf[8] = buf;
          *(void *)&buf[16] = 0x2020000000LL;
          LOBYTE(v239) = 0;
          id v33 = (void *)*((void *)v7 + 43);
          v199[0] = v19;
          v199[1] = 3221225472LL;
          v199[2] = ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_252;
          v199[3] = &unk_189BB7698;
          uint64_t v34 = v28;
          v200 = v34;
          v201 = type;
          uint64_t v203 = a2;
          uint64_t v204 = a3;
          v202 = buf;
          nw_parameters_internal_iterate_protocol_stack(v33, 2, 0, v199);
          if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
          {
            if ((v7[405] & 0x80000000) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v35 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v244 = 136446722;
                *(void *)&v244[4] = "nw_protocol_instance_bring_up_channel";
                __int16 v245 = 2082;
                v246 = v34 + 407;
                __int16 v247 = 2080;
                v248 = " ";
                _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to attach internet protocol",  v244,  0x20u);
              }
            }

            nw_protocol_instance_tear_down_path_inner(v34, a3);
            *(_OWORD *)v191 = v250;
            BOOL v36 = (void *)*((void *)v7 + 41);
            *((void *)v7 + 40) = 0LL;
            *((void *)v7 + 41) = 0LL;

            int v37 = (void *)*((void *)v7 + 42);
            *((void *)v7 + 42) = 0LL;

            uint64_t v38 = (void *)*((void *)v7 + 43);
            *((void *)v7 + 43) = 0LL;

            goto LABEL_24;
          }

          _Block_object_dispose(buf, 8);
          if (protocol_level == 1)
          {
            *(void *)buf = 0LL;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000LL;
            LOBYTE(v239) = 0;
            uint64_t v39 = (void *)*((void *)v7 + 43);
            v193[0] = v19;
            v193[1] = 3221225472LL;
            v193[2] = ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_253;
            v193[3] = &unk_189BB7698;
            nw_endpoint_t v40 = v34;
            v194 = v40;
            v195 = type;
            uint64_t v197 = a2;
            uint64_t v198 = a3;
            uint64_t v196 = buf;
            nw_parameters_internal_iterate_protocol_stack(v39, 1, 0, v193);
            if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
            {
              if ((v7[405] & 0x80000000) == 0)
              {
                __nwlog_obj();
                os_log_type_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v244 = 136446722;
                  *(void *)&v244[4] = "nw_protocol_instance_bring_up_channel";
                  __int16 v245 = 2082;
                  v246 = v40 + 407;
                  __int16 v247 = 2080;
                  v248 = " ";
                  _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to attach link protocol",  v244,  0x20u);
                }
              }

              nw_protocol_instance_tear_down_path_inner(v40, a3);
              *(_OWORD *)v191 = v250;
              int v42 = (void *)*((void *)v7 + 41);
              *((void *)v7 + 40) = 0LL;
              *((void *)v7 + 41) = 0LL;

              uint64_t v43 = (void *)*((void *)v7 + 42);
              *((void *)v7 + 42) = 0LL;

              __int16 v44 = (void *)*((void *)v7 + 43);
              *((void *)v7 + 43) = 0LL;

              goto LABEL_24;
            }

            _Block_object_dispose(buf, 8);
          }
        }
      }

      uint64_t v45 = *((void *)v228 + 3);
      id v46 = v20;
      uint64_t v47 = path;
      unsigned int v233 = 0;
      if (!nw_path_flow_registration_get_nexus_instance( v47,  *(NWConcrete_nw_path_flow_registration **)(a3 + 24),  &uu,  &v233))
      {
        if ((v7[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v52 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_instance_attach_channel_protocol";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v46 + 407;
            *(_WORD *)&buf[22] = 2080;
            v239 = " ";
            _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%snexus is not ready",  buf,  0x20u);
          }
        }

        goto LABEL_285;
      }

      id v48 = nw_path_copy_flow_for_registration(v47, *(NWConcrete_nw_path_flow_registration **)(a3 + 24));
      uint64_t v49 = v48;
      if (v48)
      {
        id v50 = v48;
        uint64_t v51 = v50[1];
        if (!v51 || !*((_DWORD *)v50 + 40)) {
          uint64_t v51 = 0LL;
        }
      }

      else
      {
        uint64_t v51 = 0LL;
      }

      uint64_t v232 = 0LL;
      uint64_t v231 = 0LL;
      char can_support_user_packet_pool = nw_path_flow_registration_can_support_user_packet_pool(v47, *(void **)(a3 + 24));
      BYTE4(v232) = BYTE4(v232) & 0xFE | can_support_user_packet_pool;
      else {
        char v54 = 0;
      }
      BYTE4(v232) = BYTE4(v232) & 0xFD | v54;
      uint64_t v231 = v51;
      LODWORD(v232) = 16;
      __int16 v55 = v47;
      id v189 = v55[3];

      id v56 = v55;
      id v190 = v56[2];

      BOOL v57 = nw_parameters_copy_context(v190);
      BOOL v58 = nw_channel_create_with_attributes(v57, (unsigned __int8 *)&uu, v233, (uint64_t)&v231);
      uint64_t v59 = *(void **)(a3 + 48);
      *(void *)(a3 + 48) = v58;

      uint64_t v60 = *(void *)(a3 + 48);
      int v61 = v7[405];
      if (!v60)
      {
        if ((v61 & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v71 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_instance_attach_channel_protocol";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v46 + 407;
            *(_WORD *)&buf[22] = 2080;
            v239 = " ";
            _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sfailed to open channel",  buf,  0x20u);
          }
        }

        goto LABEL_284;
      }

      if ((v61 & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v62 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_attach_channel_protocol";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v46 + 407;
          *(_WORD *)&buf[22] = 2080;
          v239 = " ";
          __int16 v240 = 1024;
          LODWORD(v241) = protocol_level;
          _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sopened channel at level %u",  buf,  0x26u);
        }

        uint64_t v60 = *(void *)(a3 + 48);
      }

      nw_channel_set_close_automatically(v60, 1);
      nw_channel_set_defer_input_available(*(void *)(a3 + 48), 1);
      nw_channel_set_protocol_level(*(void *)(a3 + 48), protocol_level);
      if (protocol_level == 2)
      {
        if (nw_protocol_ip_identifier::onceToken[0] != -1) {
          dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
        }
        BOOL has_protocol_in_stack = nw_parameters_has_protocol_in_stack(v190, &nw_protocol_ip_identifier::identifier);
        if (v189) {
          BOOL v64 = has_protocol_in_stack;
        }
        else {
          BOOL v64 = 0;
        }
        if (v64)
        {
          id v65 = v189;
          int v66 = [v65 type];

          if (v66 == 1)
          {
            int address_family = nw_endpoint_get_address_family(v65);
            uint64_t v68 = *(void **)(a3 + 24);
            if (nw_protocol_ip_identifier::onceToken[0] != -1) {
              dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
            }
            if (address_family == 2) {
              int v69 = 1;
            }
            else {
              int v69 = 2;
            }
            uint64_t stats_region = nw_channel_get_stats_region(*(void *)(a3 + 48), v69);
            nw_path_flow_registration_set_stats_region( v68,  2,  (__int128 *)&nw_protocol_ip_identifier::identifier,  stats_region);
          }
        }
      }

      else if ((protocol_level & 0xFFFFFFFE) != 2)
      {
        goto LABEL_87;
      }

      os_log_type_t v72 = (void *)nw_protocol_tcp_identifier();
      if (nw_parameters_has_protocol_in_stack(v190, v72))
      {
        uint64_t v73 = *(void **)(a3 + 24);
        v74 = (__int128 *)nw_protocol_tcp_identifier();
        int v75 = 3;
      }

      else
      {
        if (nw_protocol_udp_identifier::onceToken != -1) {
          dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
        }
        if (!nw_parameters_has_protocol_in_stack(v190, &nw_protocol_udp_identifier::identifier))
        {
          if (nw_parameters_get_upper_transport_protocol(v190) == 253)
          {
            upper_transport_protocol_identifier = (__int128 *)nw_parameters_get_upper_transport_protocol_identifier(v190);
            id v93 = *(void **)(a3 + 24);
            uint64_t v94 = nw_channel_get_stats_region(*(void *)(a3 + 48), 5);
            nw_path_flow_registration_set_stats_region(v93, 3, upper_transport_protocol_identifier, v94);
            __int16 v95 = *(void **)(a3 + 24);
            if (nw_protocol_udp_identifier::onceToken != -1) {
              dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
            }
            uint64_t v96 = nw_channel_get_stats_region(*(void *)(a3 + 48), 4);
            nw_path_flow_registration_set_stats_region(v95, 3, (__int128 *)&nw_protocol_udp_identifier::identifier, v96);
          }

LABEL_319:
                  if (v163) {
                    free(v163);
                  }
                  goto LABEL_129;
                }

                __nwlog_obj();
                v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v160 = v237;
                if (os_log_type_enabled(v128, v237))
                {
                  BOOL v161 = (const char *)*((void *)v78 + 2);
                  if (!v161) {
                    BOOL v161 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v161;
                  *(_WORD *)&buf[22] = 2048;
                  v239 = v78;
                  _os_log_impl( &dword_181A5C000,  v128,  v160,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback, backtrace limit exceeded",  buf,  0x20u);
                }
              }

              goto LABEL_264;
            }

            __nwlog_obj();
            os_log_type_t v139 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
            v188 = (char *)_os_log_send_and_compose_impl();

            v235[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t v237 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v188, v235, &v237))
            {
              if (v235[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                os_log_type_t v140 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v141 = v235[0];
                if (os_log_type_enabled(v140, v235[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                  _os_log_impl(&dword_181A5C000, v140, v141, "%{public}s called with null input_protocol", buf, 0xCu);
                }
              }

              else
              {
                if (v237)
                {
                  os_log_type_t v150 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v151 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v152 = v235[0];
                  BOOL v153 = os_log_type_enabled(v151, v235[0]);
                  if (v150)
                  {
                    if (v153)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v150;
                      _os_log_impl( &dword_181A5C000,  v151,  v152,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v150);
                    goto LABEL_296;
                  }

                  if (v153)
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                    _os_log_impl( &dword_181A5C000,  v151,  v152,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  v151 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v172 = v235[0];
                  if (os_log_type_enabled(v151, v235[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                    _os_log_impl( &dword_181A5C000,  v151,  v172,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
                  }
                }
              }
            }

      if (v114)
      {
        BOOL v153 = *(void *)(*((void *)&uu + 1) + 24LL);
        if (v153)
        {
          v154 = v129;
          while (*v154)
          {
            ++v154;
            if (!--v153) {
              goto LABEL_328;
            }
          }

          if (v153 >= 2) {
            *v154++ = 44;
          }
          void *v154 = 0;
        }

        goto LABEL_328;
      }

      goto LABEL_339;
    }

    if (!v32 && (!v3 || !*v3))
    {
      nw_masque_add_client_application_header_to_request(*(void **)(*(void *)(a1 + 40) + 320LL), *(void **)(a1 + 48));
      return 1LL;
    }

    if (!v33 && (!v3 || !*v3))
    {
      nw_masque_add_multipath_header_to_request(*(void *)(a1 + 40), *(void **)(a1 + 48));
      return 1LL;
    }

    if (!v35 && (!v3 || !*v3))
    {
      nw_masque_add_listener_association_header_to_request(*(void *)(a1 + 40), *(void **)(a1 + 48));
      return 1LL;
    }

void sub_181E3A804( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&STACK[0x260], 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x210], 8);

  _Unwind_Resume(a1);
}

id *nw_protocol_instance_copy_association(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[5];
    if (v3)
    {
      uint64_t v4 = nw_endpoint_copy_association_with_evaluator(v3, v2[6], 0LL);
      goto LABEL_4;
    }

    __nwlog_obj();
    nw_endpoint_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_instance_copy_association";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null instance->endpoint", buf, 0xCu);
        }

void sub_181E3AE10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_establish_path_block_invoke_62(uint64_t a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  if (!v7 || (*(char *)(v7 + 405) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      nw_endpoint_t v10 = "";
      BOOL v11 = v9 == 0;
      if (v9) {
        nw_endpoint_t v12 = (const char *)(v9 + 407);
      }
      else {
        nw_endpoint_t v12 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path_block_invoke";
      if (!v11) {
        nw_endpoint_t v10 = " ";
      }
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v12;
      *(_WORD *)&buf[22] = 2080;
      os_log_type_t v29 = (uint64_t (*)(uint64_t, uint64_t))v10;
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sAssociation update", buf, 0x20u);
    }
  }

  os_log_type_t v13 = (id *)v5;
  id v14 = v13[9];
  uint64_t v15 = *(void *)(a1 + 32);
  BOOL v16 = *(void **)(v15 + 72);
  *(void *)(v15 + 72) = 0LL;

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  os_log_type_t v29 = __Block_byref_object_copy__11696;
  BOOL v30 = __Block_byref_object_dispose__11697;
  id v31 = 0LL;
  if (v14 && object_getClass(v14) == (Class)MEMORY[0x1895F9220])
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = __nw_protocol_instance_establish_path_block_invoke_63;
    applier[3] = &unk_189BBF1E8;
    char v19 = v13;
    id v20 = *(id *)(a1 + 32);
    os_log_type_t v21 = buf;
    xpc_array_apply(v14, applier);

    os_log_type_t v17 = v19;
LABEL_17:

    goto LABEL_18;
  }

  if ((*((char *)v13 + 405) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (id *)(id)gLogObj;
    if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int16 v22 = 136446722;
      __int16 v23 = "nw_protocol_instance_establish_path_block_invoke";
      __int16 v24 = 2082;
      uint64_t v25 = (char *)v13 + 407;
      __int16 v26 = 2080;
      os_log_type_t v27 = " ";
      _os_log_impl( &dword_181A5C000,  (os_log_t)v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNo saved paths to update",  v22,  0x20u);
    }

    goto LABEL_17;
  }

void sub_181E3B0F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, id a26)
{
  _Block_object_dispose(&a21, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__11696(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__11697(uint64_t a1)
{
}

uint64_t __nw_protocol_instance_establish_path_block_invoke_63(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  uint64_t value = xpc_uint64_get_value(v4);
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6 || (*(char *)(v6 + 405) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      BOOL v9 = v8 == 0;
      if (v8) {
        nw_endpoint_t v10 = (const char *)(v8 + 407);
      }
      else {
        nw_endpoint_t v10 = "";
      }
      *(_DWORD *)buf = 136446978;
      uint64_t v47 = "nw_protocol_instance_establish_path_block_invoke";
      __int16 v48 = 2082;
      uint64_t v49 = v10;
      if (v9) {
        BOOL v11 = "";
      }
      else {
        BOOL v11 = " ";
      }
      __int16 v50 = 2080;
      uint64_t v51 = v11;
      __int16 v52 = 2048;
      uint64_t v53 = value;
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sChecking path %lx", buf, 0x2Au);
    }

    uint64_t v6 = *(void *)(a1 + 32);
  }

  uint64_t node = nw_hash_table_get_node(*(void *)(v6 + 296), value, 8LL);
  if (node)
  {
    uint64_t v13 = node;
    id v14 = *(void **)(node + 56);
    if (v14)
    {
      uint64_t v15 = (NWConcrete_nw_path *)nw_path_flow_registration_force_update(v14);
      int v44 = 0;
      if (nw_path_flow_registration_get_nexus_instance( v15,  *(NWConcrete_nw_path_flow_registration **)(v13 + 56),  &v45,  &v44))
      {
        uint64_t v16 = *(void *)(a1 + 40);
        if (!v16 || (*(char *)(v16 + 405) & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v17 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v18 = *(void *)(a1 + 40);
            char v19 = "";
            BOOL v20 = v18 == 0;
            if (v18) {
              os_log_type_t v21 = (const char *)(v18 + 407);
            }
            else {
              os_log_type_t v21 = "";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v47 = "nw_protocol_instance_establish_path_block_invoke";
            if (!v20) {
              char v19 = " ";
            }
            __int16 v48 = 2082;
            uint64_t v49 = v21;
            __int16 v50 = 2080;
            uint64_t v51 = v19;
            _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sPath has nexus assignment",  buf,  0x20u);
          }
        }

        nw_protocol_instance_bring_up_channel(*(void **)(a1 + 32), value, v13 + 32, v15);
      }

      else
      {
        uint64_t v33 = *(void *)(a1 + 32);
        if (!v33 || (*(char *)(v33 + 405) & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v34 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v35 = *(void *)(a1 + 32);
            BOOL v36 = "";
            BOOL v37 = v35 == 0;
            if (v35) {
              uint64_t v38 = (const char *)(v35 + 407);
            }
            else {
              uint64_t v38 = "";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v47 = "nw_protocol_instance_establish_path_block_invoke";
            if (!v37) {
              BOOL v36 = " ";
            }
            __int16 v48 = 2082;
            uint64_t v49 = v38;
            __int16 v50 = 2080;
            uint64_t v51 = v36;
            _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNo nexus assignment yet",  buf,  0x20u);
          }
        }

        uint64_t v39 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
        if (!v39)
        {
          xpc_object_t v40 = xpc_array_create(0LL, 0LL);
          uint64_t v41 = *(void *)(*(void *)(a1 + 48) + 8LL);
          int v42 = *(void **)(v41 + 40);
          *(void *)(v41 + 40) = v40;

          uint64_t v39 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
        }

        xpc_array_set_uint64(v39, 0xFFFFFFFFFFFFFFFFLL, value);
      }

      goto LABEL_60;
    }

    uint64_t v28 = *(void *)(a1 + 32);
    if (!v28 || (*(char *)(v28 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (NWConcrete_nw_path *)(id)gLogObj;
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v29 = *(void *)(a1 + 32);
        BOOL v30 = v29 == 0;
        if (v29) {
          id v31 = (const char *)(v29 + 407);
        }
        else {
          id v31 = "";
        }
        *(_DWORD *)buf = 136446978;
        uint64_t v47 = "nw_protocol_instance_establish_path_block_invoke";
        __int16 v48 = 2082;
        uint64_t v49 = v31;
        if (v30) {
          uint64_t v32 = "";
        }
        else {
          uint64_t v32 = " ";
        }
        __int16 v50 = 2080;
        uint64_t v51 = v32;
        __int16 v52 = 2048;
        uint64_t v53 = value;
        os_log_type_t v27 = "%{public}s %{public}s%sNo flow registration found for path %lx";
LABEL_46:
        _os_log_impl(&dword_181A5C000, (os_log_t)v15, OS_LOG_TYPE_ERROR, v27, buf, 0x2Au);
        goto LABEL_60;
      }

      goto LABEL_60;
    }
  }

  else
  {
    uint64_t v22 = *(void *)(a1 + 32);
    if (!v22 || (*(char *)(v22 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (NWConcrete_nw_path *)(id)gLogObj;
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v23 = *(void *)(a1 + 32);
        BOOL v24 = v23 == 0;
        if (v23) {
          uint64_t v25 = (const char *)(v23 + 407);
        }
        else {
          uint64_t v25 = "";
        }
        *(_DWORD *)buf = 136446978;
        uint64_t v47 = "nw_protocol_instance_establish_path_block_invoke";
        __int16 v48 = 2082;
        uint64_t v49 = v25;
        if (v24) {
          __int16 v26 = "";
        }
        else {
          __int16 v26 = " ";
        }
        __int16 v50 = 2080;
        uint64_t v51 = v26;
        __int16 v52 = 2048;
        uint64_t v53 = value;
        os_log_type_t v27 = "%{public}s %{public}s%sNo path found for path %lx";
        goto LABEL_46;
      }

void sub_181E3B638(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke( void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t protocol_handle = nw_protocol_options_get_protocol_handle(a4);
  uint64_t v7 = a1[4];
  if (v7) {
    uint64_t v8 = v7 - 96;
  }
  else {
    uint64_t v8 = 0LL;
  }
  if (v8 == protocol_handle)
  {
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
    *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = a2;
  }

  return v8 != protocol_handle;
}

uint64_t ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_2( uint64_t a1, unint64_t a2, void *a3, void *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v7 = a3;
  id v8 = a4;
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) < a2)
  {
    BOOL v9 = nw_protocol_instance_attach_protocol( *(void **)(a1 + 32),  v7,  v8,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL),  *(char **)(a1 + 64),  *(void *)(a1 + 72));
    if (!v9)
    {
      uint64_t v16 = 0LL;
      *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
      goto LABEL_15;
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v9;
    uint64_t v10 = *(void *)(a1 + 32);
    if (!v10 || (*(char *)(v10 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        BOOL v13 = v12 == 0;
        if (v12) {
          id v14 = (const char *)(v12 + 407);
        }
        else {
          id v14 = "";
        }
        int v18 = 136446978;
        char v19 = "nw_protocol_instance_bring_up_channel_block_invoke_2";
        __int16 v20 = 2082;
        os_log_type_t v21 = v14;
        if (v13) {
          uint64_t v15 = "";
        }
        else {
          uint64_t v15 = " ";
        }
        __int16 v22 = 2080;
        uint64_t v23 = v15;
        __int16 v24 = 2114;
        id v25 = v7;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAttached application protocol: %{public}@",  (uint8_t *)&v18,  0x2Au);
      }
    }
  }

  uint64_t v16 = 1LL;
LABEL_15:

  return v16;
}

void sub_181E3B86C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_251( uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v6 = a3;
  id v7 = a4;
  id v8 = nw_protocol_instance_attach_protocol( *(void **)(a1 + 32),  v6,  v7,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(char **)(a1 + 56),  *(void *)(a1 + 64));
  BOOL v9 = v8;
  if (v8)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v8;
    uint64_t v10 = *(void *)(a1 + 32);
    if (!v10 || (*(char *)(v10 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        BOOL v13 = v12 == 0;
        if (v12) {
          id v14 = (const char *)(v12 + 407);
        }
        else {
          id v14 = "";
        }
        int v17 = 136446978;
        int v18 = "nw_protocol_instance_bring_up_channel_block_invoke";
        __int16 v19 = 2082;
        __int16 v20 = v14;
        if (v13) {
          uint64_t v15 = "";
        }
        else {
          uint64_t v15 = " ";
        }
        __int16 v21 = 2080;
        __int16 v22 = v15;
        __int16 v23 = 2114;
        id v24 = v6;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAttached transport protocol: %{public}@",  (uint8_t *)&v17,  0x2Au);
      }
    }
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  return v9 != 0LL;
}

void sub_181E3BA1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_252( uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v6 = a3;
  id v7 = a4;
  id v8 = nw_protocol_instance_attach_protocol( *(void **)(a1 + 32),  v6,  v7,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(char **)(a1 + 56),  *(void *)(a1 + 64));
  BOOL v9 = v8;
  if (v8)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v8;
    uint64_t v10 = *(void *)(a1 + 32);
    if (!v10 || (*(char *)(v10 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        BOOL v13 = v12 == 0;
        if (v12) {
          id v14 = (const char *)(v12 + 407);
        }
        else {
          id v14 = "";
        }
        int v17 = 136446978;
        int v18 = "nw_protocol_instance_bring_up_channel_block_invoke";
        __int16 v19 = 2082;
        __int16 v20 = v14;
        if (v13) {
          uint64_t v15 = "";
        }
        else {
          uint64_t v15 = " ";
        }
        __int16 v21 = 2080;
        __int16 v22 = v15;
        __int16 v23 = 2114;
        id v24 = v6;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAttached internet protocol: %{public}@",  (uint8_t *)&v17,  0x2Au);
      }
    }
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  return v9 != 0LL;
}

void sub_181E3BBCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL37nw_protocol_instance_bring_up_channelP31NWConcrete_nw_protocol_instancemP22nw_protocol_path_statePU21objcproto10OS_nw_path8NSObject_block_invoke_253( uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v6 = a3;
  id v7 = a4;
  id v8 = nw_protocol_instance_attach_protocol( *(void **)(a1 + 32),  v6,  v7,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(char **)(a1 + 56),  *(void *)(a1 + 64));
  BOOL v9 = v8;
  if (v8)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v8;
    uint64_t v10 = *(void *)(a1 + 32);
    if (!v10 || (*(char *)(v10 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        BOOL v13 = v12 == 0;
        if (v12) {
          id v14 = (const char *)(v12 + 407);
        }
        else {
          id v14 = "";
        }
        int v17 = 136446978;
        int v18 = "nw_protocol_instance_bring_up_channel_block_invoke";
        __int16 v19 = 2082;
        __int16 v20 = v14;
        if (v13) {
          uint64_t v15 = "";
        }
        else {
          uint64_t v15 = " ";
        }
        __int16 v21 = 2080;
        __int16 v22 = v15;
        __int16 v23 = 2114;
        id v24 = v6;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAttached link protocol: %{public}@",  (uint8_t *)&v17,  0x2Au);
      }
    }
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  return v9 != 0LL;
}

void sub_181E3BD7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *nw_protocol_instance_attach_protocol( void *a1, void *a2, void *a3, uint64_t a4, char *a5, uint64_t a6)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  BOOL v11 = a1;
  id v12 = a2;
  id v13 = a3;
  identifier = nw_protocol_definition_get_identifier(v12);
  uint64_t internal = nw_protocol_create_internal((uint64_t)identifier, *((void **)v11 + 41), *((const char **)v11 + 43), 1);
  if (internal)
  {
    uint64_t v16 = (const char *)internal;
    nw_protocol_instance_set_protocol_instance(v11, v13, v12, internal);
    int v17 = (void *)*((void *)v16 + 5);
    if (v17 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v21 = *((void *)v16 + 11);
      if (v21) {
        *((void *)v16 + 11) = v21 + 1;
      }
      char v18 = -1;
    }

    else
    {
      char v18 = 0;
    }

    uint64_t v60 = v16;
    char v61 = v18;
    if (a4)
    {
      __int16 v22 = *(void **)(a4 + 40);
      if (v22 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v24 = *(void *)(a4 + 88);
        if (v24) {
          *(void *)(a4 + 88) = v24 + 1;
        }
        char v23 = -1;
      }

      else
      {
        char v23 = 0;
      }

      *(void *)BOOL v57 = a4;
      char v58 = v23;
      uint64_t v25 = (uint64_t (**)(const char *, uint64_t))*((void *)v16 + 3);
      if (v25)
      {
        uint64_t v26 = *v25;
        if (v26)
        {
          int v27 = v26(v16, a4);
          if (v22 != &nw_protocol_ref_counted_handle)
          {
LABEL_22:
            if (v17 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)&v60);
            }
            if (!*(void *)(a6 + 32))
            {
              if (*((_UNKNOWN **)v16 + 5) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v30 = *((void *)v16 + 11);
                if (v30) {
                  *((void *)v16 + 11) = v30 + 1;
                }
                char v29 = 1;
                char v28 = -1;
              }

              else
              {
                char v28 = 0;
                char v29 = 0;
              }

              *(void *)buf = v16;
              buf[8] = v28;
              char v31 = *(_BYTE *)(a6 + 40);
              if ((v31 & 1) != 0)
              {
                nw::release_if_needed<nw_protocol *>((uint64_t *)(a6 + 32));
                char v31 = *(_BYTE *)(a6 + 40);
              }

              *(void *)(a6 + 32) = v16;
              *(_BYTE *)(a6 + 40) = v29 | v31 & 0xFE;
            }

            if (v27) {
              __int16 v20 = v16;
            }
            else {
              __int16 v20 = 0LL;
            }
            goto LABEL_36;
          }

void nw_protocol_instance_tear_down_path(void *a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v27 = "nw_protocol_instance_tear_down_path";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "nw_protocol_instance_tear_down_path";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          int v27 = "nw_protocol_instance_tear_down_path";
          __int16 v28 = 2082;
          char v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v8) {
          goto LABEL_9;
        }
LABEL_44:
        free(v8);
        goto LABEL_9;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "nw_protocol_instance_tear_down_path";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "nw_protocol_instance_tear_down_path";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E3CB74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_tear_down_path_block_invoke(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 296);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_27;
    }
    uint64_t v9 = *(void *)(a1 + 32);
    os_log_type_t v10 = "";
    BOOL v11 = v9 == 0;
    if (v9) {
      os_log_type_t v12 = (const char *)(v9 + 407);
    }
    else {
      os_log_type_t v12 = "";
    }
    int v22 = 136446722;
    uint64_t v23 = "nw_protocol_instance_tear_down_path_block_invoke";
    if (!v11) {
      os_log_type_t v10 = " ";
    }
    __int16 v24 = 2082;
    uint64_t v25 = v12;
    __int16 v26 = 2080;
    int v27 = v10;
    id v13 = "%{public}s %{public}s%sNo path table found";
    os_log_type_t v14 = v8;
    uint32_t v15 = 32;
    goto LABEL_26;
  }

  BOOL node = nw_hash_table_get_node(v3, *(void *)(a1 + 40), 8LL);
  if (!node)
  {
    uint64_t v16 = *(void *)(a1 + 32);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
LABEL_27:

      return;
    }

    uint64_t v17 = *(void *)(a1 + 32);
    uint64_t v18 = *(void *)(a1 + 40);
    BOOL v19 = v17 == 0;
    if (v17) {
      os_log_type_t v20 = (const char *)(v17 + 407);
    }
    else {
      os_log_type_t v20 = "";
    }
    uint64_t v23 = "nw_protocol_instance_tear_down_path_block_invoke";
    __int16 v24 = 2082;
    uint64_t v21 = " ";
    int v22 = 136446978;
    if (v19) {
      uint64_t v21 = "";
    }
    uint64_t v25 = v20;
    __int16 v26 = 2080;
    int v27 = v21;
    __int16 v28 = 2048;
    uint64_t v29 = v18;
    id v13 = "%{public}s %{public}s%sNo path found for %lx";
    os_log_type_t v14 = v8;
    uint32_t v15 = 42;
LABEL_26:
    _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_INFO, v13, (uint8_t *)&v22, v15);
    goto LABEL_27;
  }

  uint64_t v5 = node;
  nw_protocol_instance_tear_down_path_inner(*(void **)(a1 + 32), node + 32);
  if (*(_DWORD *)(v5 + 160) == 3)
  {
    *(_DWORD *)(v5 + 160) = 1;
    uint64_t v6 = *(void *)(a1 + 32);
    if ((*(_BYTE *)(v6 + 404) & 8) == 0)
    {
      if (*(void *)(v6 + 16)) {
        (*(void (**)(void))(*(void *)(*(void *)(v6 + 8) + 80LL) + 208LL))();
      }
    }
  }

  uint64_t v7 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v7 + 404) & 8) != 0) {
    nw_protocol_implementation_destroy((NWConcrete_nw_protocol_instance *)v7);
  }
}

void nw_protocol_implementation_destroy(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v21, type, &v29))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type[0];
        BOOL v26 = os_log_type_enabled(v22, type[0]);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }

        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          _os_log_impl( &dword_181A5C000,  v22,  v28,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E3D3B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_protocol_implementation_has_active_pathsP31NWConcrete_nw_protocol_instance_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  if (*(_DWORD *)(extra + 128) != 3 && !*(void *)(extra + 32)) {
    return 1LL;
  }
  uint64_t result = 0LL;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  return result;
}

void nw_protocol_instance_ignore_future_path_changes(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    char v3 = v1[405];
    if ((v3 & 4) == 0)
    {
      if ((v1[405] & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v4 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v16 = "nw_protocol_instance_ignore_future_path_changes";
          __int16 v17 = 2082;
          uint64_t v18 = v2 + 407;
          __int16 v19 = 2080;
          os_log_type_t v20 = " ";
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%sIgnoring future path changes for protocol",  buf,  0x20u);
        }

        char v3 = v2[405];
      }

      v2[405] = v3 | 4;
    }

    goto LABEL_8;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_protocol_instance_ignore_future_path_changes";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_instance_ignore_future_path_changes";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_protocol_instance_ignore_future_path_changes";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_instance_ignore_future_path_changes";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_instance_ignore_future_path_changes";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void *nw_protocol_instance_copy_endpoint(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1) {
    return nw_endpoint_copy(*(void **)(a1 + 40));
  }
  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v13 = "nw_protocol_instance_copy_endpoint";
  char v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v13 = "nw_protocol_instance_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          char v13 = "nw_protocol_instance_copy_endpoint";
          __int16 v14 = 2082;
          uint32_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        char v13 = "nw_protocol_instance_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v4, v7, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v13 = "nw_protocol_instance_copy_endpoint";
        _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_instance_get_maximum_message_size(void *a1, uint64_t a2)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  char v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    int v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v73 = "nw_protocol_instance_get_maximum_message_size";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v68) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type[0];
      if (os_log_type_enabled(v24, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v73 = "nw_protocol_instance_get_maximum_message_size";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_139;
    }

    if (!(_BYTE)v68)
    {
      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v53 = type[0];
      if (os_log_type_enabled(v24, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v73 = "nw_protocol_instance_get_maximum_message_size";
        _os_log_impl( &dword_181A5C000,  v24,  v53,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_139;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v37 = type[0];
    BOOL v38 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v73 = "nw_protocol_instance_get_maximum_message_size";
        _os_log_impl(&dword_181A5C000, v24, v37, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_139;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v73 = "nw_protocol_instance_get_maximum_message_size";
      __int16 v74 = 2082;
      int v75 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v24,  v37,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_140;
  }

  if (a2)
  {
    uint64_t v5 = nw_protocol_implementation_lookup_path(v3, a2, 0LL);
    if (!v5) {
      goto LABEL_142;
    }
    int v6 = *(void **)(v5 + 32);
    uint64_t v65 = 0LL;
    if (v6)
    {
      os_log_type_t v7 = (void *)v6[5];
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v10 = v6[11];
        if (v10) {
          v6[11] = v10 + 1;
        }
        char v8 = -1;
      }

      else
      {
        char v8 = 0;
      }

      p_paths_log_id_num = &v4[-1].paths_log_id_num;
      *(void *)os_log_type_t type = v6;
      char v71 = v8;
      os_log_type_t v12 = *(void **)&v4[-1].log_str[33];
      if (v12 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = *(void *)&v4[-1].log_str[81];
        if (v14) {
          *(void *)&v4[-1].log_str[81] = v14 + 1;
        }
        char v13 = -1;
      }

      else
      {
        char v13 = 0;
      }

      uint64_t v68 = &v4[-1].paths_log_id_num;
      char v69 = v13;
      uint64_t v15 = v6[3];
      if (v15)
      {
        uint64_t v16 = *(void (**)(void *, unsigned __int16 *, uint64_t *))(v15 + 248);
        if (v16)
        {
LABEL_31:
          v16(v6, p_paths_log_id_num, &v65);
          goto LABEL_32;
        }
      }

      __nwlog_obj();
      BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
      int v27 = (const char *)v6[2];
      *(_DWORD *)buf = 136446722;
      uint64_t v73 = "__nw_protocol_get_message_properties";
      if (!v27) {
        int v27 = "invalid";
      }
      __int16 v74 = 2082;
      int v75 = (void *)v27;
      __int16 v76 = 2048;
      os_log_type_t v77 = v6;
      os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v67 = OS_LOG_TYPE_ERROR;
      char v66 = 0;
      if (__nwlog_fault(v28, &v67, &v66))
      {
        if (v67 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v30 = v67;
          if (os_log_type_enabled(v29, v67))
          {
            char v31 = (const char *)v6[2];
            if (!v31) {
              char v31 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v73 = "__nw_protocol_get_message_properties";
            __int16 v74 = 2082;
            int v75 = (void *)v31;
            __int16 v76 = 2048;
            os_log_type_t v77 = v6;
            _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback",  buf,  0x20u);
          }

void sub_181E3E7CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  if (v10 == v9) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }
  if (v8 == v9) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);
  }

  _Unwind_Resume(a1);
}

int *nw_protocol_instance_get_stats(void *a1, int a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  int v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v22 = "nw_protocol_instance_get_stats";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v11, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          int v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            int v22 = "nw_protocol_instance_get_stats";
            __int16 v23 = 2082;
            __int16 v24 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          int v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          int v22 = "nw_protocol_instance_get_stats";
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E3EADC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_get_stats_region(void *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  char v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_instance_get_stats_region";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_protocol_instance_get_stats_region";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_protocol_instance_get_stats_region";
            __int16 v21 = 2082;
            int v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_protocol_instance_get_stats_region";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_protocol_instance_get_stats_region";
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_protocol_instance_get_multipath_service(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v18 = "nw_protocol_instance_get_multipath_service";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_protocol_instance_get_multipath_service";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            char v18 = "nw_protocol_instance_get_multipath_service";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_protocol_instance_get_multipath_service";
          _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_protocol_instance_get_multipath_service";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_protocol_instance_access_state(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_instance_access_state";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v17 = "nw_protocol_instance_access_state";
        uint64_t v8 = "%{public}s called with null instance";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v17 = "nw_protocol_instance_access_state";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v5) {
          return 0LL;
        }
LABEL_35:
        free(v5);
        return 0LL;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v17 = "nw_protocol_instance_access_state";
        uint64_t v8 = "%{public}s called with null instance, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v17 = "nw_protocol_instance_access_state";
        uint64_t v8 = "%{public}s called with null instance, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

uint64_t nw_protocol_instance_access_globals(void *a1, void *a2)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  char v3 = a1;
  id v4 = a2;
  uint64_t v5 = (uint64_t (**)(void, void))v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "nw_protocol_instance_access_globals";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_90;
    }

    if (!v39)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_protocol_instance_access_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v34,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_181A5C000, v13, v24, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_90;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v42 = "nw_protocol_instance_access_globals";
      __int16 v43 = 2082;
      int v44 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181E3FF94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_get_buffer_manager(void *a1, unsigned int a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = (void *)*((void *)v3 + 15);
    if (v5)
    {
      uint64_t buffer_manager_with_context = nw_frame_get_buffer_manager_with_context(v5, a2);
      goto LABEL_4;
    }

    __nwlog_obj();
    BOOL v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_instance_get_buffer_manager";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_protocol_instance_get_buffer_manager";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null instance->context", buf, 0xCu);
        }

uint64_t nw_protocol_instance_access_cached_content(void *a1, void *a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v51 = "nw_protocol_instance_access_cached_content";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_104;
    }

    if (!v48)
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v41,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v28 = type;
    BOOL v29 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl(&dword_181A5C000, v13, v28, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_104;
    }

    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v51 = "nw_protocol_instance_access_cached_content";
      __int16 v52 = 2082;
      os_log_type_t v53 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181E4112C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_set_cached_content(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  int v6 = (void **)v5;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v46 = "nw_protocol_instance_set_cached_content";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v46 = "nw_protocol_instance_set_cached_content";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v46 = "nw_protocol_instance_set_cached_content";
          __int16 v47 = 2082;
          char v48 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_87:
        if (!v12) {
          goto LABEL_8;
        }
LABEL_88:
        free(v12);
        goto LABEL_8;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v46 = "nw_protocol_instance_set_cached_content";
        _os_log_impl(&dword_181A5C000, v13, v26, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v46 = "nw_protocol_instance_set_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v38,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E41C0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_access_flow_state(void *a1, uint64_t a2, void *a3)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a3;
  uint64_t v7 = (uint64_t (**)(void, void))v6;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl( &dword_181A5C000,  v15,  v24,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
      __int16 v30 = 2082;
      os_log_type_t v31 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_32;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null access_block", buf, 0xCu);
      }

void sub_181E421C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_protocol_instance_copy_definition(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[1];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_instance_copy_definition";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_copy_definition";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_instance_copy_definition";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_copy_definition";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_copy_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_set_limit_outbound_data(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 64;
    }
    else {
      char v5 = 0;
    }
    *((_BYTE *)v3 + 402) = *((_BYTE *)v3 + 402) & 0xBF | v5;
    goto LABEL_6;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_instance_set_limit_outbound_data";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_protocol_instance_set_limit_outbound_data";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_set_reserve_header_size(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((void *)v3 + 10) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_instance_set_reserve_header_size";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_reserve_header_size";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_instance_set_reserve_header_size";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_reserve_header_size";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_reserve_header_size";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_set_reserve_footer_size(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((void *)v3 + 11) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_instance_set_reserve_footer_size";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_reserve_footer_size";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_instance_set_reserve_footer_size";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_reserve_footer_size";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_reserve_footer_size";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_set_maximum_content_size(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((void *)v3 + 12) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_instance_set_maximum_content_size";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_maximum_content_size";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_instance_set_maximum_content_size";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_maximum_content_size";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_instance_set_maximum_content_size";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_set_is_datagram(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 0x80;
    }
    else {
      char v5 = 0;
    }
    *((_BYTE *)v3 + 402) = v5 & 0x80 | *((_BYTE *)v3 + 402) & 0x7F;
    goto LABEL_6;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_instance_set_is_datagram";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_protocol_instance_set_is_datagram";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_notify_updated_metadata(void *a1)
{
}

void nw_protocol_instance_notify_updated_internal(void *a1, unsigned int a2, int a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  char v5 = a1;
  id v6 = (char *)v5;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_notify_updated_internal";
    BOOL v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (__nwlog_fault(v21, type, &v34))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_notify_updated_internal";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if (v34)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type[0];
        BOOL v28 = os_log_type_enabled(v22, type[0]);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_instance_notify_updated_internal";
            __int16 v38 = 2082;
            os_log_type_t v39 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_notify_updated_internal";
          _os_log_impl(&dword_181A5C000, v22, v27, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_notify_updated_internal";
          _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t ___ZL44nw_protocol_instance_notify_updated_internalP31NWConcrete_nw_protocol_instance31nw_protocol_notification_type_tb_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 44) && (*(_WORD *)(nw_hash_node_get_extra(a2) + 52) & 0x800) == 0) {
    return 1LL;
  }
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = v5 ? v5 - 96 : 0LL;
  if (!object) {
    return 1LL;
  }
  uint64_t v7 = object[3];
  if (!v7) {
    return 1LL;
  }
  if (!v5) {
    return 1LL;
  }
  os_log_type_t v8 = *(void (**)(void))(v7 + 160);
  if (!v8) {
    return 1LL;
  }
  int v9 = *(_DWORD *)(a1 + 40);
  os_log_type_t v10 = (void *)object[5];
  if (v10 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v12 = object[11];
    if (v12) {
      object[11] = v12 + 1;
    }
    char v11 = -1;
  }

  else
  {
    char v11 = 0;
  }

  os_log_type_t v31 = object;
  char v32 = v11;
  if (*(_UNKNOWN **)(v6 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v15 = *(void *)(v6 + 88);
    char v14 = 0;
    if (v15) {
      *(void *)(v6 + 88) = v15 + 1;
    }
    char v13 = -1;
  }

  else
  {
    char v13 = 0;
    char v14 = 1;
  }

  uint64_t v29 = v6;
  char v30 = v13;
  if (!v9)
  {
    __nwlog_obj();
    __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v34 = "__nw_protocol_notify";
    char v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v18, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          char v34 = "__nw_protocol_notify";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null type", buf, 0xCu);
        }
      }

      else
      {
        char v26 = v10;
        if (v27)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v23 = type;
          BOOL v24 = os_log_type_enabled(v22, type);
          if (backtrace_string)
          {
            if (v24)
            {
              *(_DWORD *)buf = 136446466;
              char v34 = "__nw_protocol_notify";
              __int16 v35 = 2082;
              char v36 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            os_log_type_t v10 = v26;
            free(backtrace_string);
            goto LABEL_43;
          }

          if (v24)
          {
            *(_DWORD *)buf = 136446210;
            char v34 = "__nw_protocol_notify";
            _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null type, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            char v34 = "__nw_protocol_notify";
            _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s called with null type, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        os_log_type_t v10 = v26;
      }
    }

void sub_181E439F0(_Unwind_Exception *exception_object)
{
}

void sub_181E439FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if ((v21 & 1) == 0) {
    nw::release_if_needed<nw_protocol *>(&a17);
  }
  if (v19 == v20) {
    nw::release_if_needed<nw_protocol *>(&a19);
  }
  _Unwind_Resume(exception_object);
}

void nw_protocol_instance_notify_updated_message_properties(void *a1, int a2)
{
}

void nw_protocol_instance_notify_connection_id_changed(void *a1, uint64_t a2, void *a3)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  uint64_t v6 = a3;
  size_t size = dispatch_data_get_size(v6);
  if (!size)
  {
    __nwlog_obj();
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446210;
    *(void *)&void applier[4] = "strict_calloc";
    uint64_t v20 = (void *)_os_log_send_and_compose_impl();

    free(v20);
  }

  os_log_type_t v8 = calloc(1uLL, size);
  if (v8) {
    goto LABEL_3;
  }
  __nwlog_obj();
  char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446722;
  *(void *)&void applier[4] = "strict_calloc";
  *(_WORD *)&applier[12] = 2048;
  *(void *)&applier[14] = 1LL;
  *(_WORD *)&applier[22] = 2048;
  char v69 = (void *)size;
  os_log_type_t v22 = (void *)_os_log_send_and_compose_impl();

  if (__nwlog_abort((uint64_t)v22))
  {
LABEL_116:
    __break(1u);
    JUMPOUT(0x181E446B0LL);
  }

  free(v22);
LABEL_3:
  *(void *)BOOL v64 = 0LL;
  uint64_t v65 = v64;
  uint64_t v66 = 0x2000000000LL;
  uint64_t v67 = 0LL;
  uint64_t v60 = 0LL;
  char v61 = (uint64_t *)&v60;
  uint64_t v62 = 0x2000000000LL;
  os_log_type_t v63 = v8;
  if (v6)
  {
    *(void *)applier = MEMORY[0x1895F87A8];
    *(void *)&applier[8] = 0x40000000LL;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    char v69 = &unk_189BBF598;
    *((void *)&v70 + 1) = &v60;
    size_t v71 = size;
    *(void *)&__int128 v70 = v64;
    dispatch_data_apply(v6, applier);
    uint64_t v9 = *((void *)v65 + 3);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  _Block_object_dispose(&v60, 8);
  _Block_object_dispose(v64, 8);
  if (v9 != size) {
    goto LABEL_28;
  }
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(void *)&void applier[4] = "__nw_protocol_get_output_handler";
    char v30 = (char *)_os_log_send_and_compose_impl();

    v64[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v60) = 0;
    if (__nwlog_fault(v30, v64, &v60))
    {
      if (v64[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = v64[0];
        if (os_log_type_enabled(v31, v64[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&void applier[4] = "__nw_protocol_get_output_handler";
          _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null protocol", applier, 0xCu);
        }
      }

      else if ((_BYTE)v60)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v39 = v64[0];
        BOOL v40 = os_log_type_enabled(v31, v64[0]);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&void applier[4] = "__nw_protocol_get_output_handler";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v31,  v39,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  applier,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_91;
        }

        if (v40)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&void applier[4] = "__nw_protocol_get_output_handler";
          _os_log_impl(&dword_181A5C000, v31, v39, "%{public}s called with null protocol, no backtrace", applier, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = v64[0];
        if (os_log_type_enabled(v31, v64[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&void applier[4] = "__nw_protocol_get_output_handler";
          _os_log_impl( &dword_181A5C000,  v31,  v47,  "%{public}s called with null protocol, backtrace limit exceeded",  applier,  0xCu);
        }
      }
    }

void nw_protocol_instance_report_ready(void *a1, unint64_t a2)
{
  uint64_t v84 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v77 = "nw_protocol_instance_report_ready";
    os_log_type_t v31 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(p_paths_log_id_num) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled(v32, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v77 = "nw_protocol_instance_report_ready";
        _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if ((_BYTE)p_paths_log_id_num)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = type[0];
      BOOL v39 = os_log_type_enabled(v32, type[0]);
      if (backtrace_string)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v77 = "nw_protocol_instance_report_ready";
          __int16 v78 = 2082;
          char v79 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v32,  v38,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_119:
        if (!v31) {
          goto LABEL_46;
        }
        goto LABEL_120;
      }

      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v77 = "nw_protocol_instance_report_ready";
        _os_log_impl(&dword_181A5C000, v32, v38, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = type[0];
      if (os_log_type_enabled(v32, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v77 = "nw_protocol_instance_report_ready";
        _os_log_impl( &dword_181A5C000,  v32,  v56,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E4555C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_instance_report_ready_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  __int16 v5 = *(_WORD *)(extra + 52);
  if ((v5 & 0x10) == 0)
  {
    uint64_t v6 = extra;
    if ((v5 & 4) != 0)
    {
      uint64_t object = (nw_protocol *)nw_hash_node_get_object(a2);
      uint64_t v9 = (void **)*(id *)(a1 + 32);
      if (nw_protocol_definition_get_message_is_stream(v9[1]) && *(v9 - 6) == object)
      {

        unint64_t v10 = -2LL;
      }

      else
      {

        unint64_t v10 = (unint64_t)object;
        if (*(void *)(a1 + 40) != -1LL && object != (nw_protocol *)-2LL) {
          return 1LL;
        }
      }

      *(_WORD *)(v6 + 52) |= 0x10u;
      id v11 = *(NWConcrete_nw_protocol_instance **)(a1 + 32);
      if (v11) {
        p_paths_log_id_num = (nw_protocol *)&v11[-1].paths_log_id_num;
      }
      else {
        p_paths_log_id_num = 0LL;
      }
      nw_protocol_implementation_report_connected(v11, p_paths_log_id_num, object, v10);
    }

    else
    {
      uint64_t v7 = *(void *)(a1 + 32);
      if ((!v7 || (*(char *)(v7 + 405) & 0x80000000) == 0) && gLogDatapath)
      {
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v15 = *(void *)(a1 + 32);
          uint64_t v16 = *(void *)(a1 + 40);
          BOOL v17 = v15 == 0;
          if (v15) {
            __int16 v18 = (const char *)(v15 + 407);
          }
          else {
            __int16 v18 = "";
          }
          uint64_t v21 = "nw_protocol_instance_report_ready_block_invoke";
          __int16 v22 = 2082;
          __int16 v19 = " ";
          int v20 = 136446978;
          if (v17) {
            __int16 v19 = "";
          }
          char v23 = v18;
          __int16 v24 = 2080;
          uint64_t v25 = v19;
          __int16 v26 = 2048;
          uint64_t v27 = v16;
          _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDelaying the delivery of connected() on flow %llx",  (uint8_t *)&v20,  0x2Au);
        }

        __int16 v5 = *(_WORD *)(v6 + 52);
      }

      *(_WORD *)(v6 + 52) = v5 | 0x30;
    }
  }

  return 1LL;
}

void nw_protocol_instance_update_available_paths(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if ((*((_BYTE *)v1->parent_definition + 184) & 0x10) == 0
    || !nw_parameters_get_multipath(v1->destroy_timer)
    || !v2->parent_definition->extended_state->var26)
  {

    goto LABEL_41;
  }

  char v3 = BYTE5(v2->flow_in_connected);

  if ((v3 & 4) == 0)
  {
    if (v2->flow_registration) {
      goto LABEL_6;
    }
    BOOL internal = nw_hash_table_create_internal( 5u,  144,  (const void *(*)(const void *, unsigned int *))nw_protocol_get_key,  (unsigned int (*)(const void *, unsigned int))nw_protocol_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_matches_key,  0LL);
    if (internal)
    {
      *(_DWORD *)(internal + 48) &= ~2u;
      v2->flow_registration = (OS_nw_path_flow_registration *)internal;
      if (v2->wakeup_block && *(void *)&v2[-1].log_str[25])
      {
        __buf[0] = 0LL;
        arc4random_buf(__buf, 8uLL);
        LOBYTE(v69[0]) = 0;
        BOOL v32 = nw_hash_table_add_object((uint64_t)v2->flow_registration, __buf[0], (char *)v69);
        if (LOBYTE(v69[0]))
        {
          os_log_type_t v33 = (_OWORD *)v32;
          if (v32)
          {
            *(_OWORD *)(v32 + 144) = 0u;
            *(_OWORD *)(v32 + 160) = 0u;
            *(_OWORD *)(v32 + 112) = 0u;
            *(_OWORD *)(v32 + 128) = 0u;
            *(_OWORD *)(v32 + 80) = 0u;
            *(_OWORD *)(v32 + 96) = 0u;
            *(_OWORD *)(v32 + 48) = 0u;
            *(_OWORD *)(v32 + 64) = 0u;
            *(_OWORD *)(v32 + 32) = 0u;
            id v34 = nw_path_copy_interface(v2->wakeup_block);
            __int16 v35 = (void *)*((void *)v33 + 6);
            *((void *)v33 + 6) = v34;

            *((_DWORD *)v33 + 40) = 3;
            uint64_t v36 = *(void *)&v2[-1].log_str[25];
            if (v36 && *(_UNKNOWN **)(v36 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v48 = *(void *)(v36 + 88);
              if (v48) {
                *(void *)(v36 + 88) = v48 + 1;
              }
              char v38 = 1;
              char v37 = -1;
            }

            else
            {
              char v37 = 0;
              char v38 = 0;
            }

            *(void *)buf = v36;
            buf[8] = v37;
            char v49 = *((_BYTE *)v33 + 72);
            if ((v49 & 1) != 0)
            {
              nw::release_if_needed<nw_protocol *>((uint64_t *)v33 + 8);
              char v49 = *((_BYTE *)v33 + 72);
            }

            *((void *)v33 + 8) = v36;
            *((_BYTE *)v33 + 72) = v38 | v49 & 0xFE;
            *((_BYTE *)v33 + 169) &= ~8u;
            if ((SBYTE5(v2->flow_in_connected) & 0x80000000) == 0)
            {
              __nwlog_obj();
              __int16 v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v51 = *((void *)v33 + 6);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = (char *)&v2->flow_in_connected + 7;
                *(_WORD *)&buf[22] = 2080;
                __int16 v78 = " ";
                __int16 v79 = 2048;
                uint64_t v80 = __buf[0];
                __int16 v81 = 2112;
                uint64_t v82 = v51;
                _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAdded path %lx as primary path over %@",  buf,  0x34u);
              }
            }

            uint64_t v4 = __buf[0];
            *((void *)v33 + 17) = 0LL;
            tqh_last = v2->pending_inbound_frames.tqh_last;
            v2->current_path = (OS_nw_path *)v4;
            v2->paths_table = (nw_hash_table *)v4;
            *((void *)v33 + 18) = (char *)v33 + 136;
            if (tqh_last)
            {
              *((void *)v33 + 17) = tqh_last;
              *((void *)v2->pending_inbound_frames.tqh_last + 5) = (char *)v33 + 136;
              *((void *)v33 + 18) = *(void *)&v2->pending_inbound_frame_count;
              v2->pending_inbound_frames.tqh_last = 0LL;
              *(void *)&v2->pending_inbound_frame_size_t count = &v2->pending_inbound_frames.tqh_last;
            }

            goto LABEL_7;
          }
        }

        if ((SBYTE5(v2->flow_in_connected) & 0x80000000) == 0)
        {
          __nwlog_obj();
          os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = (char *)&v2->flow_in_connected + 7;
            *(_WORD *)&buf[22] = 2080;
            __int16 v78 = " ";
            __int16 v79 = 2048;
            uint64_t v80 = __buf[0];
            _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to add path %lx to paths table",  buf,  0x2Au);
          }
        }
      }

void sub_181E46208(_Unwind_Exception *a1)
{
  if ((v2 & 1) == 0) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)(v3 - 176));
  }

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_copy_path(void *a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = (char *)v3;
  if (!v3)
  {
    __nwlog_obj();
    id v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
    id v16 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v16, &type, &v33))
    {
LABEL_48:
      if (!v16) {
        goto LABEL_50;
      }
LABEL_49:
      free(v16);
      goto LABEL_50;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      xpc_object_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_181A5C000, v17, v29, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_47;
    }

    if (!v33)
    {
      __nwlog_obj();
      xpc_object_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl( &dword_181A5C000,  v17,  v32,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    xpc_object_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v30 = type;
    BOOL v31 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_181A5C000, v17, v30, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_47;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
      __int16 v36 = 2082;
      char v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v30,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_28;
  }

  __int16 v5 = (void *)v3[15];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = v6;
    if (((_BYTE)v6[17] & 8) == 0) {
      dispatch_assert_queue_V2(v6[1]);
    }
  }

  if (a2 != -1)
  {
    if (*(_DWORD *)(*((void *)v4 + 1) + 64LL) == 3)
    {
      uint64_t node = nw_hash_table_get_node(*((void *)v4 + 29), a2, 8LL);
      if (node)
      {
        os_log_type_t v8 = *(void **)(node + 16);
        if (v8)
        {
          uint64_t v14 = v8[3];
          if (v14)
          {
            unint64_t v10 = *(void (**)(void))(v14 + 120);
            if (v10)
            {
              xpc_object_t v11 = (void *)v8[5];
              if (v11 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v25 = v8[11];
                if (v25) {
                  v8[11] = v25 + 1;
                }
                char v12 = -1;
              }

              else
              {
                char v12 = 0;
              }

              goto LABEL_43;
            }
          }
        }
      }

      else if ((v4[405] & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v23 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
          __int16 v36 = 2082;
          char v37 = v4 + 407;
          __int16 v38 = 2080;
          BOOL v39 = " ";
          __int16 v40 = 2048;
          uint64_t v41 = a2;
          _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sCannot access path, flow %llx does not exist",  buf,  0x2Au);
        }
      }

void sub_181E469B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  if (v8 == v9) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }

  _Unwind_Resume(a1);
}

void nw_protocol_implementation_report_connected( NWConcrete_nw_protocol_instance *a1, nw_protocol *a2, nw_protocol *a3, unint64_t a4)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  uint64_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v60 = "nw_protocol_implementation_report_connected";
    id v28 = (char *)_os_log_send_and_compose_impl();

    v57[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v55) = 0;
    if (v57[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if ((_BYTE)v55)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = v57[0];
      BOOL v40 = os_log_type_enabled(v29, v57[0]);
      if (backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v60 = "nw_protocol_implementation_report_connected";
          __int16 v61 = 2082;
          uint64_t v62 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v39,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_111:
        if (!v28) {
          goto LABEL_31;
        }
LABEL_112:
        free(v28);
        goto LABEL_31;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl(&dword_181A5C000, v29, v39, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = v57[0];
      if (os_log_type_enabled(v29, v57[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "nw_protocol_implementation_report_connected";
        _os_log_impl( &dword_181A5C000,  v29,  v49,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6 || (*(char *)(v6 + 405) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = (const char *)(v8 + 407);
      BOOL v10 = v8 == 0;
      if (!v8) {
        uint64_t v9 = "";
      }
      xpc_object_t v11 = " ";
      if (v10) {
        xpc_object_t v11 = "";
      }
      uint64_t v12 = *(unsigned int *)(extra + 128);
      else {
        char v13 = off_189BB7998[v12];
      }
      uint64_t v14 = *(void *)(extra + 16);
      int v15 = *(char *)(extra + 136);
      uint64_t v16 = *(void *)(extra + 120);
      int v18 = 136448002;
      int v19 = "nw_protocol_instance_update_available_paths_block_invoke";
      __int16 v20 = 2082;
      BOOL v21 = v9;
      __int16 v22 = 2080;
      char v23 = v11;
      __int16 v24 = 2048;
      uint64_t v25 = object;
      __int16 v26 = 2080;
      uint64_t v27 = v13;
      __int16 v28 = 2112;
      uint64_t v29 = v14;
      __int16 v30 = 1024;
      int v31 = v15;
      __int16 v32 = 2112;
      uint64_t v33 = v16;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s\tPath %lx %s over %@ p:%d (%@)",  (uint8_t *)&v18,  0x4Eu);
    }
  }

  return 1LL;
}

void ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_254( uint64_t a1, void *a2, const unsigned __int8 *a3, void *a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v7 = a2;
  id v8 = a4;
  uint64_t v9 = *(void *)(a1 + 32);
  if (!v9 || (*(char *)(v9 + 405) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      int is_null = uuid_is_null(a3);
      char v13 = " ";
      int v16 = 136447490;
      xpc_object_t v17 = "nw_protocol_instance_update_available_paths_block_invoke";
      __int16 v18 = 2082;
      uint64_t v14 = (const char *)(v11 + 407);
      if (!v11) {
        uint64_t v14 = "";
      }
      int v19 = v14;
      if (!v11) {
        char v13 = "";
      }
      __int16 v20 = 2080;
      BOOL v21 = v13;
      int v15 = "channel";
      __int16 v22 = 2112;
      id v23 = v7;
      __int16 v24 = 2112;
      if (is_null) {
        int v15 = "socket";
      }
      id v25 = v8;
      __int16 v26 = 2080;
      uint64_t v27 = v15;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s\t%@ (%@) (%s)",  (uint8_t *)&v16,  0x3Eu);
    }
  }
}

void sub_181E478A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_256( uint64_t a1, void *a2)
{
  uint64_t v117 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = nw_interface_option_details_copy_remote_endpoint(v3);
  id v5 = nw_interface_option_details_copy_interface(v3);
  else {
    BOOL v6 = 0;
  }
  id obj = v5;
  if (!v6 || (id v7 = *(void **)(a1 + 40)) == 0LL)
  {
LABEL_9:
    uint64_t v102 = 0LL;
    char v103 = &v102;
    uint64_t v104 = 0x2020000000LL;
    uint64_t v105 = 0LL;
    uint64_t v98 = 0LL;
    char v99 = &v98;
    uint64_t v100 = 0x2020000000LL;
    uint64_t v101 = 0LL;
    BOOL v10 = *(char **)(*(void *)(a1 + 32) + 296LL);
    v92[0] = MEMORY[0x1895F87A8];
    v92[1] = 3221225472LL;
    v92[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_257;
    v92[3] = &unk_189BB83D8;
    id v93 = v5;
    id v94 = v4;
    id v11 = v3;
    id v95 = v11;
    uint64_t v96 = &v102;
    uint64_t v97 = &v98;
    nw_hash_table_apply(v10, (uint64_t)v92);
    uint64_t v12 = v103[3];
    if (!v12)
    {
      uint64_t __buf = 0LL;
      arc4random_buf(&__buf, 8uLL);
      char v106 = 0;
      uint64_t v13 = nw_hash_table_add_object(*(void *)(*(void *)(a1 + 32) + 296LL), __buf, &v106);
      if (!v106 || (uint64_t v14 = v13) == 0)
      {
        uint64_t v67 = *(void *)(a1 + 32);
        if (!v67 || (*(char *)(v67 + 405) & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v68 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          {
            uint64_t v69 = *(void *)(a1 + 32);
            char v70 = (const char *)(v69 + 407);
            os_log_type_t v71 = "";
            if (!v69) {
              char v70 = "";
            }
            uint64_t v108 = "nw_protocol_instance_update_available_paths_block_invoke_2";
            __int16 v109 = 2082;
            *(_DWORD *)buf = 136446978;
            if (v69) {
              os_log_type_t v71 = " ";
            }
            int v110 = (void *)v70;
            __int16 v111 = 2080;
            uint64_t v112 = v71;
            __int16 v113 = 2048;
            uint64_t v114 = __buf;
            _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to add path %lx to paths table",  buf,  0x2Au);
          }
        }

        goto LABEL_79;
      }

      *(_OWORD *)(v13 + 32) = 0u;
      uint64_t v15 = v13 + 32;
      *(_OWORD *)(v13 + 48) = 0u;
      int v16 = (uint64_t *)(v13 + 48);
      *(_OWORD *)(v13 + 144) = 0u;
      *(_OWORD *)(v13 + 160) = 0u;
      *(_OWORD *)(v13 + 112) = 0u;
      *(_OWORD *)(v13 + 128) = 0u;
      *(_OWORD *)(v13 + 80) = 0u;
      *(_OWORD *)(v13 + 96) = 0u;
      *(_OWORD *)(v13 + 64) = 0u;
      objc_storeStrong((id *)(v13 + 48), v5);
      nw_interface_option_details_get_nexus_agent(v11, (_OWORD *)(v14 + 32));
      objc_storeStrong((id *)(v14 + 152), v4);
      *(_BYTE *)(v14 + 168) = nw_interface_option_details_get_priority(v11);
      id v17 = nw_interface_option_details_copy_local_cid(v11);
      __int16 v18 = *(void **)(v14 + 96);
      *(void *)(v14 + 96) = v17;

      id v19 = nw_interface_option_details_copy_remote_cid(v11);
      __int16 v20 = *(void **)(v14 + 104);
      *(void *)(v14 + 104) = v19;

      id v21 = nw_interface_option_details_copy_initial_data(v11);
      __int16 v22 = *(void **)(v14 + 112);
      *(void *)(v14 + 112) = v21;

      id v23 = nw_interface_option_details_copy_evaluator(v11);
      __int16 v24 = *(void **)(v14 + 128);
      *(void *)(v14 + 128) = v23;

      int sockfd = nw_interface_option_details_get_sockfd(v11);
      *(void *)(v14 + 136) = 0LL;
      uint64_t v26 = v14 + 136;
      *(_BYTE *)(v26 + 33) &= ~8u;
      *(_DWORD *)(v26 + 24) = 1;
      *(_DWORD *)(v26 + 28) = sockfd;
      *(void *)(v26 + 8) = v26;
      xpc_array_set_uint64(*(xpc_object_t *)(a1 + 48), 0xFFFFFFFFFFFFFFFFLL, __buf);
      uint64_t v27 = *(void *)(a1 + 32);
      if (!v27 || (*(char *)(v27 + 405) & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v28 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v29 = *(void *)(a1 + 32);
          __int16 v30 = (const char *)(v29 + 407);
          BOOL v6 = v29 == 0;
          int v31 = " ";
          uint64_t v32 = *v16;
          if (v6)
          {
            __int16 v30 = "";
            int v31 = "";
          }

          *(_DWORD *)buf = 136447234;
          uint64_t v108 = "nw_protocol_instance_update_available_paths_block_invoke";
          __int16 v109 = 2082;
          int v110 = (void *)v30;
          __int16 v111 = 2080;
          uint64_t v112 = v31;
          __int16 v113 = 2048;
          uint64_t v114 = __buf;
          __int16 v115 = 2112;
          uint64_t v116 = v32;
          _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDetected path %lx over %@",  buf,  0x34u);
        }
      }

      v103[3] = v15;
      v99[3] = __buf;
    }

    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL))
    {
      uint64_t v33 = *(void *)(a1 + 32);
      uint64_t v34 = *(void *)(v33 + 312);
      __int16 v35 = v99;
      uint64_t v36 = v99[3];
      if (v34 != v36)
      {
        if (v34)
        {
          *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v34;
          uint64_t v36 = v35[3];
          uint64_t v33 = *(void *)(a1 + 32);
        }

        *(void *)(v33 + 312) = v36;
        uint64_t v37 = *(void *)(a1 + 32);
        if (!v37 || (*(char *)(v37 + 405) & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v38 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v39 = *(void *)(a1 + 32);
            BOOL v40 = v39 == 0;
            if (v39) {
              uint64_t v41 = (const char *)(v39 + 407);
            }
            else {
              uint64_t v41 = "";
            }
            os_log_type_t v42 = " ";
            if (v40) {
              os_log_type_t v42 = "";
            }
            uint64_t v43 = v99[3];
            uint64_t v44 = *(void *)(v103[3] + 16);
            *(_DWORD *)buf = 136447234;
            uint64_t v108 = "nw_protocol_instance_update_available_paths_block_invoke";
            __int16 v109 = 2082;
            int v110 = (void *)v41;
            __int16 v111 = 2080;
            uint64_t v112 = v42;
            __int16 v113 = 2048;
            uint64_t v114 = v43;
            __int16 v115 = 2112;
            uint64_t v116 = v44;
            _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sMarking path %lx as primary path over %@",  buf,  0x34u);
          }
        }

        if (v12) {
          xpc_array_set_uint64(*(xpc_object_t *)(a1 + 48), 0xFFFFFFFFFFFFFFFFLL, v99[3]);
        }
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
    }

    else if (v12)
    {
      uint64_t v45 = v99[3];
      if (v45 == *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL))
      {
        uint64_t v46 = *(void *)(a1 + 32);
        if (!v46 || (*(char *)(v46 + 405) & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v47 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v48 = *(void *)(a1 + 32);
            BOOL v49 = v48 == 0;
            if (v48) {
              os_log_type_t v50 = (const char *)(v48 + 407);
            }
            else {
              os_log_type_t v50 = "";
            }
            os_log_type_t v51 = " ";
            if (v49) {
              os_log_type_t v51 = "";
            }
            uint64_t v52 = v99[3];
            uint64_t v53 = *(void *)(v103[3] + 16);
            *(_DWORD *)buf = 136447234;
            uint64_t v108 = "nw_protocol_instance_update_available_paths_block_invoke";
            __int16 v109 = 2082;
            int v110 = (void *)v50;
            __int16 v111 = 2080;
            uint64_t v112 = v51;
            __int16 v113 = 2048;
            uint64_t v114 = v52;
            __int16 v115 = 2112;
            uint64_t v116 = v53;
            _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sPath %lx over %@ is no longer primary",  buf,  0x34u);
          }

          uint64_t v45 = v99[3];
        }

        xpc_array_set_uint64(*(xpc_object_t *)(a1 + 48), 0xFFFFFFFFFFFFFFFFLL, v45);
      }
    }

    uint64_t v54 = *(void *)(*(void *)(a1 + 72) + 8LL);
    if (*(_BYTE *)(v54 + 24) || (uint64_t v55 = v103[3], *(_DWORD *)(v55 + 128) != 3))
    {
LABEL_79:

      _Block_object_dispose(&v98, 8);
      _Block_object_dispose(&v102, 8);
      goto LABEL_80;
    }

    *(_BYTE *)(v54 + 24) = 1;
    *(void *)(*(void *)(a1 + 32) + 304LL) = v99[3];
    uint64_t v56 = *(void *)(a1 + 32);
    if (v56 && *(char *)(v56 + 405) < 0)
    {
LABEL_63:
      uint64_t v64 = *(void *)(v55 + 32);
      uint64_t v65 = *(void *)(v56 - 64);
      if (v65 != v64)
      {
        if (v65)
        {
          if (*(_UNKNOWN **)(v65 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v78 = *(void *)(v65 + 88);
            if (v78)
            {
              uint64_t v79 = v78 - 1;
              *(void *)(v65 + 88) = v79;
              if (!v79)
              {
                uint64_t v80 = *(void (***)(void))(v65 + 64);
                if (v80)
                {
                  *(void *)(v65 + 64) = 0LL;
                  v80[2](v80);
                  _Block_release(v80);
                }

                if ((*(_BYTE *)(v65 + 72) & 1) != 0)
                {
                  __int16 v81 = *(const void **)(v65 + 64);
                  if (v81) {
                    _Block_release(v81);
                  }
                }

                free((void *)v65);
              }
            }
          }
        }

        *(void *)(v56 - 64) = v64;
        if (v64)
        {
          if (*(_UNKNOWN **)(v64 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v66 = *(void *)(v64 + 88);
            if (v66) {
              *(void *)(v64 + 88) = v66 + 1;
            }
          }
        }
      }

      goto LABEL_79;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v57 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v58 = *(void *)(a1 + 32);
      BOOL v59 = v58 == 0;
      if (v58) {
        os_log_type_t v60 = (const char *)(v58 + 407);
      }
      else {
        os_log_type_t v60 = "";
      }
      __int16 v61 = " ";
      if (v59) {
        __int16 v61 = "";
      }
      uint64_t v62 = v99[3];
      uint64_t v63 = *(void *)(v103[3] + 16);
      *(_DWORD *)buf = 136447234;
      uint64_t v108 = "nw_protocol_instance_update_available_paths_block_invoke";
      __int16 v109 = 2082;
      int v110 = (void *)v60;
      __int16 v111 = 2080;
      uint64_t v112 = v61;
      __int16 v113 = 2048;
      uint64_t v114 = v62;
      __int16 v115 = 2112;
      uint64_t v116 = v63;
      _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sMarking path %lx as default path over %@",  buf,  0x34u);
    }

    uint64_t v56 = *(void *)(a1 + 32);
    if (v56)
    {
      uint64_t v55 = v103[3];
      goto LABEL_63;
    }

    __nwlog_obj();
    uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v108 = "__nw_protocol_set_output_handler";
    uint64_t v83 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__buf) = 16;
    char v106 = 0;
    if (__nwlog_fault(v83, &__buf, &v106))
    {
      if (__buf == 17)
      {
        __nwlog_obj();
        uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v85 = __buf;
        if (os_log_type_enabled(v84, (os_log_type_t)__buf))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v108 = "__nw_protocol_set_output_handler";
          _os_log_impl(&dword_181A5C000, v84, v85, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if (v106)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v87 = __buf;
        BOOL v88 = os_log_type_enabled(v84, (os_log_type_t)__buf);
        if (backtrace_string)
        {
          if (v88)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v108 = "__nw_protocol_set_output_handler";
            __int16 v109 = 2082;
            int v110 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v84,  v87,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_117;
        }

        if (v88)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v108 = "__nw_protocol_set_output_handler";
          _os_log_impl(&dword_181A5C000, v84, v87, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v89 = __buf;
        if (os_log_type_enabled(v84, (os_log_type_t)__buf))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v108 = "__nw_protocol_set_output_handler";
          _os_log_impl( &dword_181A5C000,  v84,  v89,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E484A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, void *a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a28, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_259( uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t v21 = 0LL;
  __int16 v22 = &v21;
  uint64_t v23 = 0x2020000000LL;
  char v24 = 0;
  id v5 = *(void **)(a1 + 32);
  BOOL v6 = (void *)v5[36];
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3221225472LL;
  v17[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_2;
  v17[3] = &unk_189BB7760;
  id v19 = &v21;
  uint64_t v20 = extra;
  __int16 v18 = v5;
  nw_path_enumerate_interface_options_with_details(v6, v17);
  if (!*((_BYTE *)v22 + 24) && (*(_BYTE *)(extra + 137) & 8) == 0)
  {
    uint64_t object = nw_hash_node_get_object(a2);
    xpc_array_set_uint64(*(xpc_object_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, object);
    *(_DWORD *)(extra + 128) = 2;
    *(_BYTE *)(extra + 137) |= 8u;
    uint64_t v8 = *(void *)(a1 + 32);
    if (!v8 || (*(char *)(v8 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        id v11 = "";
        uint64_t v12 = *(void *)(extra + 16);
        BOOL v13 = v10 == 0;
        if (v10) {
          uint64_t v14 = (const char *)(v10 + 407);
        }
        else {
          uint64_t v14 = "";
        }
        uint64_t v15 = *(void *)(extra + 120);
        if (!v13) {
          id v11 = " ";
        }
        *(_DWORD *)buf = 136447234;
        uint64_t v26 = "nw_protocol_instance_update_available_paths_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = v14;
        __int16 v29 = 2080;
        __int16 v30 = v11;
        __int16 v31 = 2112;
        uint64_t v32 = v12;
        __int16 v33 = 2112;
        uint64_t v34 = v15;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRemoving path over %@ (override endpoint %@)",  buf,  0x34u);
      }
    }
  }

  _Block_object_dispose(&v21, 8);
  return 1LL;
}

void sub_181E48708( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_260( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t value = xpc_uint64_get_value(v4);
  if (*(void *)(a1 + 40) != value)
  {
    nw_hash_table_get_node(*(void *)(*(void *)(a1 + 32) + 296LL), value, 8LL);
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 80LL) + 208LL))();
  }

  return 1LL;
}

void sub_181E487C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_2_261( uint64_t a1)
{
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_3;
  applier[3] = &unk_189BC8CB8;
  id v1 = *(void **)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  xpc_array_apply(v1, applier);
}

void sub_181E4883C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void nw_protocol_instance_async(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "nw_protocol_instance_async";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "nw_protocol_instance_async";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v28 = "nw_protocol_instance_async";
          __int16 v29 = 2082;
          __int16 v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_56:
        free(v7);
        goto LABEL_5;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "nw_protocol_instance_async";
        _os_log_impl(&dword_181A5C000, v8, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "nw_protocol_instance_async";
        _os_log_impl( &dword_181A5C000,  v8,  v22,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E48F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_3( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t value = xpc_uint64_get_value(v4);
  (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 80LL) + 208LL))();
  BOOL node = nw_hash_table_get_node(*(void *)(*(void *)(a1 + 32) + 296LL), value, 8LL);
  if (node)
  {
    uint64_t v7 = node;
    nw_protocol_path_state_dispose(*(void **)(a1 + 32), node + 32);
    nw_hash_table_remove_node(*(void *)(*(void *)(a1 + 32) + 296LL), v7);
  }

  return 1LL;
}

void sub_181E48FC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_2( void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = nw_interface_option_details_copy_interface(v3);
  id v5 = nw_interface_option_details_copy_remote_endpoint(v3);
  uint64_t v6 = a1[4];
  if ((!v6 || (*(char *)(v6 + 405) & 0x80000000) == 0) && gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = a1[4];
      uint64_t v12 = "";
      os_log_type_t v13 = (const char *)(v11 + 407);
      uint64_t v14 = a1[6];
      BOOL v15 = v11 == 0;
      uint64_t v16 = *(void *)(v14 + 16);
      if (v15) {
        os_log_type_t v13 = "";
      }
      uint64_t v17 = *(void *)(v14 + 120);
      if (!v15) {
        uint64_t v12 = " ";
      }
      int v18 = 136447746;
      BOOL v19 = "nw_protocol_instance_update_available_paths_block_invoke_2";
      __int16 v20 = 2082;
      BOOL v21 = v13;
      __int16 v22 = 2080;
      os_log_type_t v23 = v12;
      __int16 v24 = 2112;
      id v25 = v4;
      __int16 v26 = 2112;
      uint64_t v27 = v16;
      __int16 v28 = 2112;
      id v29 = v5;
      __int16 v30 = 2112;
      uint64_t v31 = v17;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sComparing interface %@ with %@ and endpoint %@ with %@",  (uint8_t *)&v18,  0x48u);
    }
  }

  if (nw_interface_shallow_compare(v4, *(void **)(a1[6] + 16LL))
    && (!v5 || nw_endpoint_is_equal(v5, *(void **)(a1[6] + 120LL), 0LL)))
  {
    uint64_t v7 = (dispatch_data_s *)nw_interface_option_details_copy_local_cid(v3);
    if (nw_dispatch_data_is_equal(v7, *(dispatch_data_s **)(a1[6] + 64LL)))
    {
      uint64_t v8 = (dispatch_data_s *)nw_interface_option_details_copy_remote_cid(v3);
      BOOL is_equal = nw_dispatch_data_is_equal(v8, *(dispatch_data_s **)(a1[6] + 72LL));

      if (is_equal) {
        *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
      }
    }

    else
    {
    }
  }
}

void sub_181E491D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_257( uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  if (nw_interface_shallow_compare(*(void **)(a1 + 32), *(void **)(extra + 16))
    && nw_endpoint_is_equal(*(void **)(a1 + 40), *(void **)(extra + 120), 0LL))
  {
    id v5 = (dispatch_data_s *)nw_interface_option_details_copy_local_cid(*(void **)(a1 + 48));
    if (nw_dispatch_data_is_equal(v5, *(dispatch_data_s **)(extra + 64)))
    {
      uint64_t v6 = (dispatch_data_s *)nw_interface_option_details_copy_remote_cid(*(void **)(a1 + 48));
      BOOL is_equal = nw_dispatch_data_is_equal(v6, *(dispatch_data_s **)(extra + 72));

      if (is_equal)
      {
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = extra;
        *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = nw_hash_node_get_object(a2);
        nw_interface_option_details_get_nexus_agent(*(void **)(a1 + 48), (_OWORD *)extra);
        return 0LL;
      }
    }

    else
    {
    }
  }

  return 1LL;
}

void nw_protocol_instance_report_done(void *a1, unint64_t a2, void *a3)
{
  uint64_t v114 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a3;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
    uint64_t v58 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v60 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_181A5C000, v59, v60, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if ((_BYTE)v103)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v65 = type[0];
      BOOL v66 = os_log_type_enabled(v59, type[0]);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
          __int16 v108 = 2082;
          __int16 v109 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v59,  v65,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_171:
        if (!v58) {
          goto LABEL_104;
        }
        goto LABEL_172;
      }

      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_181A5C000, v59, v65, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v80 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl( &dword_181A5C000,  v59,  v80,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_protocol_instance_report_done_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  *(_WORD *)(extra + 52) |= 0x200u;
  uint64_t object = nw_hash_node_get_object(a2);
  if (!object) {
    return 1LL;
  }
  id v6 = (void *)object;
  uint64_t v7 = *(void **)(a1 + 32);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = v8 ? v8 - 96 : 0LL;
    uint64_t v10 = *(void *)(object + 24);
    if (v10)
    {
      if (v8 && *(void *)(v10 + 56))
      {
        uint64_t v11 = v7;
        uint64_t v12 = v11[3];

        os_log_type_t v13 = (void *)v6[5];
        if (v13 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v15 = v6[11];
          if (v15) {
            v6[11] = v15 + 1;
          }
          char v14 = -1;
        }

        else
        {
          char v14 = 0;
        }

        uint64_t v49 = v6;
        char v50 = v14;
        if (*(_UNKNOWN **)(v9 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v18 = *(void *)(v9 + 88);
          char v17 = 0;
          if (v18) {
            *(void *)(v9 + 88) = v18 + 1;
          }
          char v16 = -1;
        }

        else
        {
          char v16 = 0;
          char v17 = 1;
        }

        uint64_t v47 = v9;
        char v48 = v16;
        uint64_t v19 = v6[3];
        if (v19)
        {
          __int16 v20 = *(void (**)(void *, uint64_t, uint64_t))(v19 + 56);
          if (v20)
          {
            v20(v6, v9, v12);
LABEL_22:
            if ((v17 & 1) == 0) {
              nw::release_if_needed<nw_protocol *>(&v47);
            }
            if (v13 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)&v49);
            }
            goto LABEL_26;
          }
        }

        __nwlog_obj();
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
        __int16 v33 = (const char *)v6[2];
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_error";
        if (!v33) {
          __int16 v33 = "invalid";
        }
        __int16 v52 = 2082;
        uint64_t v53 = v33;
        __int16 v54 = 2048;
        char v55 = v6;
        uint64_t v34 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v45 = 0;
        if (__nwlog_fault(v34, &type, &v45))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v36 = type;
            if (os_log_type_enabled(v35, type))
            {
              uint64_t v37 = (const char *)v6[2];
              if (!v37) {
                uint64_t v37 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_error";
              __int16 v52 = 2082;
              uint64_t v53 = v37;
              __int16 v54 = 2048;
              char v55 = v6;
              _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s protocol %{public}s (%p) has invalid error callback",  buf,  0x20u);
            }
          }

          else if (v45)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v39 = type;
            BOOL v40 = os_log_type_enabled(v35, type);
            if (backtrace_string)
            {
              if (v40)
              {
                char v41 = (const char *)v6[2];
                if (!v41) {
                  char v41 = "invalid";
                }
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "__nw_protocol_error";
                __int16 v52 = 2082;
                uint64_t v53 = v41;
                __int16 v54 = 2048;
                char v55 = v6;
                __int16 v56 = 2082;
                os_log_type_t v57 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v35,  v39,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(backtrace_string);
              goto LABEL_73;
            }

            if (v40)
            {
              uint64_t v44 = (const char *)v6[2];
              if (!v44) {
                uint64_t v44 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_error";
              __int16 v52 = 2082;
              uint64_t v53 = v44;
              __int16 v54 = 2048;
              char v55 = v6;
              _os_log_impl( &dword_181A5C000,  v35,  v39,  "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace",  buf,  0x20u);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v35, type))
            {
              uint64_t v43 = (const char *)v6[2];
              if (!v43) {
                uint64_t v43 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_error";
              __int16 v52 = 2082;
              uint64_t v53 = v43;
              __int16 v54 = 2048;
              char v55 = v6;
              _os_log_impl( &dword_181A5C000,  v35,  v42,  "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded",  buf,  0x20u);
            }
          }
        }

void sub_181E4A968( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19)
{
}

id nw_protocol_instance_copy_options(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    id v5 = (void *)v3[15];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = v6;
      if (((_BYTE)v6[17] & 8) == 0) {
        dispatch_assert_queue_V2(v6[1]);
      }
    }

    if (a2 != -1 && *(_DWORD *)(v4[1] + 64LL) == 3)
    {
      uint64_t node = nw_hash_table_get_node(v4[29], a2, 8LL);
      if (node)
      {
        uint64_t v9 = *(void **)(node + 40);
LABEL_12:
        id v10 = v9;
        goto LABEL_13;
      }

void sub_181E4AEC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_get_level(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  char v2 = v1;
  if (v1)
  {
    id v3 = (void *)*((void *)v1 + 15);
    if (v3)
    {
      id v4 = v3;
      id v5 = v4;
      if (((_BYTE)v4[17] & 8) == 0) {
        dispatch_assert_queue_V2(v4[1]);
      }
    }

    uint64_t v6 = v2[94];
    goto LABEL_7;
  }

  __nwlog_obj();
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_protocol_instance_get_level";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v19 = "nw_protocol_instance_get_level";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_protocol_instance_get_level";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E4B194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_add_inbound(void *a1, uint64_t a2, void *a3, void *a4, int a5, int a6)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  os_log_type_t v11 = a1;
  uint64_t v12 = a3;
  os_log_type_t v13 = a4;
  if (!v11)
  {
    __nwlog_obj();
    __int16 v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
    uint64_t v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v64 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_181A5C000, v63, v64, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v80)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v68 = type[0];
      BOOL v69 = os_log_type_enabled(v63, type[0]);
      if (backtrace_string)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
          __int16 v84 = 2082;
          os_log_type_t v85 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v63,  v68,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_150:
        if (!v62) {
          goto LABEL_100;
        }
LABEL_151:
        free(v62);
        goto LABEL_100;
      }

      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_181A5C000, v63, v68, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v77 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl( &dword_181A5C000,  v63,  v77,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E4BCEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  if (v12 == v11) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }
  if (v10 == v11) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);
  }

  _Unwind_Resume(a1);
}

void nw_protocol_instance_add_outbound(void *a1, void *a2, void *a3, uint64_t a4, int a5, int a6)
{
  uint64_t v108 = *MEMORY[0x1895F89C0];
  uint64_t v11 = a1;
  uint64_t v12 = a2;
  os_log_type_t v13 = a3;
  if (!v11)
  {
    __nwlog_obj();
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uint64_t v105 = 136446210;
    *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
    BOOL v40 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v105 = 136446210;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null instance", v105, 0xCu);
      }
    }

    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = buf[0];
      BOOL v47 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)uint64_t v105 = 136446466;
          *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
          *(_WORD *)&v105[12] = 2082;
          *(void *)&v105[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v41,  v46,  "%{public}s called with null instance, dumping backtrace:%{public}s",  v105,  0x16u);
        }

        free(backtrace_string);
LABEL_190:
        if (!v40) {
          goto LABEL_58;
        }
LABEL_191:
        free(v40);
        goto LABEL_58;
      }

      if (v47)
      {
        *(_DWORD *)uint64_t v105 = 136446210;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_181A5C000, v41, v46, "%{public}s called with null instance, no backtrace", v105, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v51 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v105 = 136446210;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl( &dword_181A5C000,  v41,  v51,  "%{public}s called with null instance, backtrace limit exceeded",  v105,  0xCu);
      }
    }

BOOL ___ZL47nw_protocol_implementation_lookup_path_by_frameP31NWConcrete_nw_protocol_instancePU22objcproto11OS_nw_frame8NSObjectPm_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(nw_hash_node_get_extra(a2) + 56);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v4 == v5) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  }
  return v4 != v5;
}

uint64_t nw_protocol_instance_add_new_flow(void *a1, char a2, int a3, void *a4, void *a5, void *a6)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  uint64_t v11 = a1;
  id v12 = a4;
  os_log_type_t v13 = a5;
  id v14 = a6;
  if (!v11)
  {
    __nwlog_obj();
    os_log_type_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v55 = "nw_protocol_instance_add_new_flow";
    uint64_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (__nwlog_fault(v45, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          char v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if (v52)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v46, type);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            char v55 = "nw_protocol_instance_add_new_flow";
            __int16 v56 = 2082;
            os_log_type_t v57 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v46,  v49,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_83;
        }

        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          char v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_181A5C000, v46, v49, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          char v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl( &dword_181A5C000,  v46,  v51,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E4DB68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_definition_get_variant(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  char v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[16];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_protocol_definition_get_variant";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_protocol_definition_get_variant";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_definition_get_variant";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_set_flow_is_datagram(void *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  os_log_type_t v8 = (char *)v7;
  if (!v7)
  {
    __nwlog_obj();
    __int16 v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
    unint64_t v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type[0];
      BOOL v29 = os_log_type_enabled(v23, type[0]);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
          __int16 v39 = 2082;
          BOOL v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_64:
        if (!v22) {
          goto LABEL_18;
        }
LABEL_65:
        free(v22);
        goto LABEL_18;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
        _os_log_impl(&dword_181A5C000, v23, v28, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
        _os_log_impl( &dword_181A5C000,  v23,  v33,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_instance_update_outbound_data_limit(void *a1, uint64_t a2, int a3)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  uint64_t v6 = (char *)v5;
  if (v5)
  {
    if (a2)
    {
      uint64_t v7 = (void *)v5[15];
      if (v7)
      {
        os_log_type_t v8 = v7;
        uint64_t v9 = v8;
        if (((_BYTE)v8[17] & 8) == 0) {
          dispatch_assert_queue_V2(v8[1]);
        }
      }

      if ((v6[402] & 0x40) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_protocol_instance_update_outbound_data_limit";
        BOOL v11 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v53 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v13 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s Outbound data limit updates is not opted in",  buf,  0xCu);
          }

void sub_181E4F090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_instance_update_outbound_data_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t extra = nw_hash_node_get_extra(a2);
  if (gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(_DWORD *)(extra + 40);
      int v11 = *(_DWORD *)(a1 + 48);
      uint64_t v12 = *(void *)(a1 + 40);
      int v13 = 136446978;
      id v14 = "nw_protocol_instance_update_outbound_data_limit_block_invoke";
      __int16 v15 = 1024;
      int v16 = v10;
      __int16 v17 = 1024;
      int v18 = v11;
      __int16 v19 = 2048;
      uint64_t v20 = v12;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s Increase current outbound limit %u to %u bytes for flow %llx",  (uint8_t *)&v13,  0x22u);
    }
  }

  *(_DWORD *)(extra + 40) = *(_DWORD *)(a1 + 48);
  __int16 v6 = *(_WORD *)(extra + 52);
  if ((v6 & 0x80) != 0 && (*(_WORD *)(extra + 52) & 0x100) == 0)
  {
    if (*(_DWORD *)(a1 + 48))
    {
      if (object)
      {
        uint64_t v7 = *(void *)(object + 24);
        if (v7)
        {
          if (*(void *)(a1 + 32) && *(void *)(v7 + 72))
          {
            *(_WORD *)(extra + 52) = v6 | 0x100;
            *(_BYTE *)(*(void *)(a1 + 32) + 405LL) |= 1u;
          }
        }
      }
    }
  }

  return 1LL;
}

BOOL nw_protocol_instance_set_flow_for_key(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  __int16 v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_181A5C000, v23, v30, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (!v46)
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl( &dword_181A5C000,  v23,  v43,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_51;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = type;
      BOOL v36 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_181A5C000, v23, v35, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        __int16 v50 = 2082;
        uint64_t v51 = (uint64_t)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v23,  v35,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_45;
    }

    goto LABEL_52;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_181A5C000, v23, v32, "%{public}s called with null key", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (!v46)
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl( &dword_181A5C000,  v23,  v44,  "%{public}s called with null key, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_51;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_181A5C000, v23, v37, "%{public}s called with null key, no backtrace", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        __int16 v50 = 2082;
        uint64_t v51 = (uint64_t)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v23,  v37,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_45;
    }

    goto LABEL_52;
  }

  if (!a3)
  {
    __nwlog_obj();
    os_log_type_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_181A5C000, v23, v34, "%{public}s called with null flow", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (!v46)
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl( &dword_181A5C000,  v23,  v45,  "%{public}s called with null flow, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_51;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type;
      BOOL v40 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_181A5C000, v23, v39, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v49 = "nw_protocol_instance_set_flow_for_key";
        __int16 v50 = 2082;
        uint64_t v51 = (uint64_t)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v23,  v39,  "%{public}s called with null flow, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_45;
    }

void sub_181E4FEB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_DWORD *nw_protocol_custom_mapping_get_key(unsigned int *a1, unsigned int *a2)
{
  unsigned int v3 = *a1;
  BOOL result = a1 + 1;
  *a2 = v3;
  return result;
}

uint64_t nw_protocol_custom_mapping_key_hash(uint8x8_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 > 7)
  {
    if (a2 >= 0x20)
    {
      int32x4_t v5 = 0uLL;
      uint64_t v2 = a2 & 0xFFFFFFE0;
      int32x4_t v6 = 0uLL;
      size_t v7 = a1 + 2;
      uint64_t v8 = v2;
      int32x4_t v9 = 0uLL;
      int32x4_t v10 = 0uLL;
      int32x4_t v11 = 0uLL;
      int32x4_t v12 = 0uLL;
      int32x4_t v13 = 0uLL;
      int32x4_t v14 = 0uLL;
      do
      {
        uint8x16_t v15 = *(uint8x16_t *)v7[-2].i8;
        uint16x8_t v16 = vmovl_u8(*(uint8x8_t *)v15.i8);
        uint16x8_t v17 = vmovl_high_u8(v15);
        uint16x8_t v18 = vmovl_u8(*v7);
        uint16x8_t v19 = vmovl_high_u8(*(uint8x16_t *)v7->i8);
        int32x4_t v10 = (int32x4_t)vaddw_high_u16((uint32x4_t)v10, v17);
        int32x4_t v9 = (int32x4_t)vaddw_u16((uint32x4_t)v9, *(uint16x4_t *)v17.i8);
        int32x4_t v6 = (int32x4_t)vaddw_high_u16((uint32x4_t)v6, v16);
        int32x4_t v5 = (int32x4_t)vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v16.i8);
        int32x4_t v14 = (int32x4_t)vaddw_high_u16((uint32x4_t)v14, v19);
        int32x4_t v13 = (int32x4_t)vaddw_u16((uint32x4_t)v13, *(uint16x4_t *)v19.i8);
        int32x4_t v12 = (int32x4_t)vaddw_high_u16((uint32x4_t)v12, v18);
        int32x4_t v11 = (int32x4_t)vaddw_u16((uint32x4_t)v11, *(uint16x4_t *)v18.i8);
        v7 += 4;
        v8 -= 32LL;
      }

      while (v8);
      uint64_t v3 = vaddvq_s32( vaddq_s32( vaddq_s32(vaddq_s32(v11, v5), vaddq_s32(v13, v9)),  vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10))));
      if (v2 == a2) {
        return v3;
      }
      if ((a2 & 0x18) == 0) {
        goto LABEL_14;
      }
    }

    else
    {
      LODWORD(v3) = 0;
      uint64_t v2 = 0LL;
    }

    uint64_t v20 = v2;
    uint64_t v2 = a2 & 0xFFFFFFF8;
    int32x4_t v21 = 0uLL;
    int32x4_t v22 = (int32x4_t)v3;
    uint64_t v23 = v20 - v2;
    os_log_type_t v24 = (uint8x8_t *)((char *)a1 + v20);
    do
    {
      uint8x8_t v25 = *v24++;
      uint16x8_t v26 = vmovl_u8(v25);
      int32x4_t v21 = (int32x4_t)vaddw_high_u16((uint32x4_t)v21, v26);
      int32x4_t v22 = (int32x4_t)vaddw_u16((uint32x4_t)v22, *(uint16x4_t *)v26.i8);
      v23 += 8LL;
    }

    while (v23);
    uint64_t v3 = vaddvq_s32(vaddq_s32(v22, v21));
    if (v2 == a2) {
      return v3;
    }
    goto LABEL_14;
  }

  uint64_t v2 = 0LL;
  LODWORD(v3) = 0;
LABEL_14:
  uint64_t v27 = a2 - v2;
  os_log_type_t v28 = (unsigned __int8 *)a1 + v2;
  do
  {
    int v29 = *v28++;
    uint64_t v3 = (v3 + v29);
    --v27;
  }

  while (v27);
  return v3;
}

BOOL nw_protocol_custom_mapping_matches_key(char *a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)a1 == a3)
  {
    if (!a3) {
      return 1LL;
    }
    uint64_t v3 = (unsigned __int8 *)(a1 + 4);
    uint64_t v4 = a3 - 1LL;
    do
    {
      int v6 = *v3++;
      int v5 = v6;
      int v8 = *a2++;
      int v7 = v8;
      BOOL v10 = v4-- != 0;
      BOOL result = v5 == v7;
    }

    while (v5 == v7 && v10);
    return result;
  }

  __nwlog_obj();
  int32x4_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int32x4_t v22 = "nw_protocol_custom_mapping_matches_key";
  int32x4_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v13, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int32x4_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        int32x4_t v22 = "nw_protocol_custom_mapping_matches_key";
        uint16x8_t v16 = "%{public}s Cannot have custom mapping keys with different lengths";
LABEL_25:
        _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      }
    }

    else
    {
      if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int32x4_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            int32x4_t v22 = "nw_protocol_custom_mapping_matches_key";
            __int16 v23 = 2082;
            os_log_type_t v24 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Cannot have custom mapping keys with different lengths, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (!v18) {
          goto LABEL_26;
        }
        *(_DWORD *)buf = 136446210;
        int32x4_t v22 = "nw_protocol_custom_mapping_matches_key";
        uint16x8_t v16 = "%{public}s Cannot have custom mapping keys with different lengths, no backtrace";
        goto LABEL_25;
      }

      __nwlog_obj();
      int32x4_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        int32x4_t v22 = "nw_protocol_custom_mapping_matches_key";
        uint16x8_t v16 = "%{public}s Cannot have custom mapping keys with different lengths, backtrace limit exceeded";
        goto LABEL_25;
      }
    }

void nw_protocol_custom_mapping_release_object(void *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    free(a1);
    return;
  }

  __nwlog_obj();
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int32x4_t v11 = "nw_protocol_custom_mapping_release_object";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int32x4_t v11 = "nw_protocol_custom_mapping_release_object";
        int v5 = "%{public}s called with null object";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v4 = type;
        BOOL v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *(_DWORD *)buf = 136446466;
            int32x4_t v11 = "nw_protocol_custom_mapping_release_object";
            __int16 v12 = 2082;
            int32x4_t v13 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null object, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v7) {
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        int32x4_t v11 = "nw_protocol_custom_mapping_release_object";
        int v5 = "%{public}s called with null object, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int32x4_t v11 = "nw_protocol_custom_mapping_release_object";
        int v5 = "%{public}s called with null object, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

uint64_t nw_protocol_instance_get_flow_for_key(void *a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  os_log_type_t v4 = (char *)v3;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_protocol_instance_get_flow_for_key";
    int32x4_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_protocol_instance_get_flow_for_key";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (!v27)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_protocol_instance_get_flow_for_key";
        _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_protocol_instance_get_flow_for_key";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v30 = "nw_protocol_instance_get_flow_for_key";
      __int16 v31 = 2082;
      os_log_type_t v32 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_38;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint16x8_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_protocol_instance_get_flow_for_key";
    int32x4_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_protocol_instance_get_flow_for_key";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null key", buf, 0xCu);
      }

void nw_protocol_instance_clear_flow_for_key(void *a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  os_log_type_t v4 = (char *)v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v37 = "nw_protocol_instance_clear_flow_for_key";
    int32x4_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v37 = "nw_protocol_instance_clear_flow_for_key";
          __int16 v38 = 2082;
          uint64_t v39 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_66:
        if (!v11) {
          goto LABEL_14;
        }
LABEL_67:
        free(v11);
        goto LABEL_14;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_instance_enumerate_flow_keys(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    uint64_t v5 = *((void *)v3 + 30);
    if (v5 && *(_DWORD *)(v5 + 40))
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 3221225472LL;
      v15[2] = __nw_protocol_instance_enumerate_flow_keys_block_invoke;
      v15[3] = &unk_189BB7600;
      uint16x8_t v16 = v3;
      id v17 = v4;
      nw_hash_table_apply((char *)v5, (uint64_t)v15);
    }

    else if ((v3[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v6 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v21 = "nw_protocol_instance_enumerate_flow_keys";
        __int16 v22 = 2082;
        __int16 v23 = v3 + 407;
        __int16 v24 = 2080;
        os_log_type_t v25 = " ";
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFlow mapping table is empty",  buf,  0x20u);
      }
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v21 = "nw_protocol_instance_enumerate_flow_keys";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v8, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int32x4_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_protocol_instance_enumerate_flow_keys";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int32x4_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v21 = "nw_protocol_instance_enumerate_flow_keys";
          __int16 v22 = 2082;
          __int16 v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_protocol_instance_enumerate_flow_keys";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int32x4_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_protocol_instance_enumerate_flow_keys";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_protocol_instance_enumerate_flow_keys_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (a2) {
    return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a2 + 16) + 4LL,  *(void *)(a2 + 32));
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4 || (*(char *)(v4 + 405) & 0x80000000) == 0)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v6 = *(void *)(a1 + 32);
    BOOL v7 = v6 == 0;
    if (v6) {
      int v8 = (const char *)(v6 + 407);
    }
    else {
      int v8 = "";
    }
    *(_DWORD *)buf = 136446722;
    __int16 v35 = "nw_protocol_instance_enumerate_flow_keys_block_invoke";
    if (v7) {
      int32x4_t v9 = "";
    }
    else {
      int32x4_t v9 = " ";
    }
    __int16 v36 = 2082;
    __int16 v37 = v8;
    __int16 v38 = 2080;
    uint64_t v39 = v9;
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int32x4_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        BOOL v14 = v13 == 0;
        if (v13) {
          os_log_type_t v15 = (const char *)(v13 + 407);
        }
        else {
          os_log_type_t v15 = "";
        }
        *(_DWORD *)buf = 136446722;
        if (v14) {
          uint16x8_t v16 = "";
        }
        else {
          uint16x8_t v16 = " ";
        }
        __int16 v35 = "nw_protocol_instance_enumerate_flow_keys_block_invoke";
        __int16 v36 = 2082;
        __int16 v37 = v15;
        __int16 v38 = 2080;
        uint64_t v39 = v16;
        id v17 = "%{public}s %{public}s%sFound null node when enumerating custom flow mapping table";
LABEL_46:
        _os_log_impl(&dword_181A5C000, v11, v12, v17, buf, 0x20u);
      }
    }

    else
    {
      if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int32x4_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        BOOL v19 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v19)
          {
            uint64_t v20 = *(void *)(a1 + 32);
            BOOL v21 = v20 == 0;
            if (v20) {
              __int16 v22 = (const char *)(v20 + 407);
            }
            else {
              __int16 v22 = "";
            }
            if (v21) {
              __int16 v23 = "";
            }
            else {
              __int16 v23 = " ";
            }
            *(_DWORD *)buf = 136446978;
            __int16 v35 = "nw_protocol_instance_enumerate_flow_keys_block_invoke";
            __int16 v36 = 2082;
            __int16 v37 = v22;
            __int16 v38 = 2080;
            uint64_t v39 = v23;
            __int16 v40 = 2082;
            os_log_type_t v41 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %{public}s%sFound null node when enumerating custom flow mapping table, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (!v19) {
          goto LABEL_47;
        }
        uint64_t v28 = *(void *)(a1 + 32);
        os_log_type_t v29 = (const char *)(v28 + 407);
        BOOL v30 = v28 == 0;
        os_log_type_t v31 = "";
        if (v30) {
          os_log_type_t v29 = "";
        }
        *(_DWORD *)buf = 136446722;
        if (!v30) {
          os_log_type_t v31 = " ";
        }
        __int16 v35 = "nw_protocol_instance_enumerate_flow_keys_block_invoke";
        __int16 v36 = 2082;
        __int16 v37 = v29;
        __int16 v38 = 2080;
        uint64_t v39 = v31;
        id v17 = "%{public}s %{public}s%sFound null node when enumerating custom flow mapping table, no backtrace";
        goto LABEL_46;
      }

      __nwlog_obj();
      int32x4_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        uint64_t v24 = *(void *)(a1 + 32);
        BOOL v25 = v24 == 0;
        if (v24) {
          uint64_t v26 = (const char *)(v24 + 407);
        }
        else {
          uint64_t v26 = "";
        }
        *(_DWORD *)buf = 136446722;
        if (v25) {
          char v27 = "";
        }
        else {
          char v27 = " ";
        }
        __int16 v35 = "nw_protocol_instance_enumerate_flow_keys_block_invoke";
        __int16 v36 = 2082;
        __int16 v37 = v26;
        __int16 v38 = 2080;
        uint64_t v39 = v27;
        id v17 = "%{public}s %{public}s%sFound null node when enumerating custom flow mapping table, backtrace limit exceeded";
        goto LABEL_46;
      }
    }

void nw_protocol_instance_enumerate_flows(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    uint64_t v5 = *((void *)v3 + 29);
    if (v5 && *(_DWORD *)(v5 + 40))
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 3221225472LL;
      v15[2] = __nw_protocol_instance_enumerate_flows_block_invoke;
      v15[3] = &unk_189BB7600;
      uint16x8_t v16 = v3;
      id v17 = v4;
      nw_hash_table_apply((char *)v5, (uint64_t)v15);
    }

    else if ((v3[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v21 = "nw_protocol_instance_enumerate_flows";
        __int16 v22 = 2082;
        __int16 v23 = v3 + 407;
        __int16 v24 = 2080;
        BOOL v25 = " ";
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNo flows to enumerate",  buf,  0x20u);
      }
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v21 = "nw_protocol_instance_enumerate_flows";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v8, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int32x4_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_protocol_instance_enumerate_flows";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int32x4_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v21 = "nw_protocol_instance_enumerate_flows";
          __int16 v22 = 2082;
          __int16 v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_protocol_instance_enumerate_flows";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int32x4_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_protocol_instance_enumerate_flows";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_protocol_instance_enumerate_flows_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    __nwlog_obj();
    int32x4_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v10 = *(void *)(a1 + 32);
    BOOL v11 = v10 == 0;
    if (v10) {
      os_log_type_t v12 = (const char *)(v10 + 407);
    }
    else {
      os_log_type_t v12 = "";
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
    if (v11) {
      BOOL v13 = "";
    }
    else {
      BOOL v13 = " ";
    }
    __int16 v68 = 2082;
    os_log_type_t v69 = v12;
    __int16 v70 = 2080;
    os_log_type_t v71 = v13;
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (__nwlog_fault(v14, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          uint64_t v17 = *(void *)(a1 + 32);
          BOOL v18 = v17 == 0;
          if (v17) {
            BOOL v19 = (const char *)(v17 + 407);
          }
          else {
            BOOL v19 = "";
          }
          *(_DWORD *)buf = 136446722;
          if (v18) {
            uint64_t v20 = "";
          }
          else {
            uint64_t v20 = " ";
          }
          uint64_t v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          __int16 v68 = 2082;
          os_log_type_t v69 = v19;
          __int16 v70 = 2080;
          os_log_type_t v71 = v20;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s %{public}s%sNull node while enumerating flows",  buf,  0x20u);
        }
      }

      else if (v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        BOOL v34 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v34)
          {
            uint64_t v35 = *(void *)(a1 + 32);
            BOOL v36 = v35 == 0;
            if (v35) {
              __int16 v37 = (const char *)(v35 + 407);
            }
            else {
              __int16 v37 = "";
            }
            if (v36) {
              __int16 v38 = "";
            }
            else {
              __int16 v38 = " ";
            }
            *(_DWORD *)buf = 136446978;
            uint64_t v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
            __int16 v68 = 2082;
            os_log_type_t v69 = v37;
            __int16 v70 = 2080;
            os_log_type_t v71 = v38;
            __int16 v72 = 2082;
            os_log_type_t v73 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v33,  "%{public}s %{public}s%sNull node while enumerating flows, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_104;
        }

        if (v34)
        {
          uint64_t v56 = *(void *)(a1 + 32);
          BOOL v57 = v56 == 0;
          if (v56) {
            uint64_t v58 = (const char *)(v56 + 407);
          }
          else {
            uint64_t v58 = "";
          }
          *(_DWORD *)buf = 136446722;
          if (v57) {
            char v59 = "";
          }
          else {
            char v59 = " ";
          }
          uint64_t v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          __int16 v68 = 2082;
          os_log_type_t v69 = v58;
          __int16 v70 = 2080;
          os_log_type_t v71 = v59;
          _os_log_impl( &dword_181A5C000,  v15,  v33,  "%{public}s %{public}s%sNull node while enumerating flows, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v15, type))
        {
          uint64_t v47 = *(void *)(a1 + 32);
          BOOL v48 = v47 == 0;
          if (v47) {
            os_log_type_t v49 = (const char *)(v47 + 407);
          }
          else {
            os_log_type_t v49 = "";
          }
          *(_DWORD *)buf = 136446722;
          if (v48) {
            __int16 v50 = "";
          }
          else {
            __int16 v50 = " ";
          }
          uint64_t v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          __int16 v68 = 2082;
          os_log_type_t v69 = v49;
          __int16 v70 = 2080;
          os_log_type_t v71 = v50;
          _os_log_impl( &dword_181A5C000,  v15,  v46,  "%{public}s %{public}s%sNull node while enumerating flows, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

void nw_protocol_instance_set_wakeup_handler(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_protocol_instance_set_wakeup_handler";
    int32x4_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_protocol_instance_set_wakeup_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v25 = "nw_protocol_instance_set_wakeup_handler";
          __int16 v26 = 2082;
          os_log_type_t v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_protocol_instance_set_wakeup_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_protocol_instance_set_wakeup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_instance_schedule_wakeup(void *a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = (uint64_t)v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_protocol_instance_schedule_wakeup";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null instance", location, 0xCu);
      }
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)location = 136446466;
          *(void *)&location[4] = "nw_protocol_instance_schedule_wakeup";
          __int16 v35 = 2082;
          BOOL v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null instance, dumping backtrace:%{public}s",  location,  0x16u);
        }

        free(backtrace_string);
LABEL_59:
        if (!v12) {
          goto LABEL_9;
        }
LABEL_60:
        free(v12);
        goto LABEL_9;
      }

      if (v21)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_181A5C000, v13, v20, "%{public}s called with null instance, no backtrace", location, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl( &dword_181A5C000,  v13,  v27,  "%{public}s called with null instance, backtrace limit exceeded",  location,  0xCu);
      }
    }

void sub_181E533B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_schedule_wakeup_block_invoke(uint64_t a1)
{
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v1 = WeakRetained[33];
    if (v1)
    {
      if ((*((_BYTE *)WeakRetained + 404) & 0x10) != 0) {
        (*(void (**)(uint64_t, void *))(v1 + 16))(v1, WeakRetained);
      }
    }
  }
}

void sub_181E53434( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_protocol_instance_async_if_needed(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_protocol_instance_async_if_needed";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v28 = "nw_protocol_instance_async_if_needed";
          __int16 v29 = 2082;
          BOOL v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_56:
        free(v7);
        goto LABEL_5;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_181A5C000, v8, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl( &dword_181A5C000,  v8,  v22,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E53B04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_process_external_input(void *a1, void *a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v33 = "nw_protocol_instance_process_external_input";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_instance_process_external_input";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v33 = "nw_protocol_instance_process_external_input";
          __int16 v34 = 2082;
          __int16 v35 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_62:
        if (!v17) {
          goto LABEL_28;
        }
LABEL_63:
        free(v17);
        goto LABEL_28;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_instance_process_external_input";
        _os_log_impl(&dword_181A5C000, v18, v23, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_instance_process_external_input";
        _os_log_impl( &dword_181A5C000,  v18,  v28,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E542E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_set_link_flow_controlled(void *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (v3)
  {
    char v5 = v3[403];
    if (a2) {
      int v6 = 4;
    }
    else {
      int v6 = 0;
    }
    v3[403] = v5 & 0xFB | v6;
    if ((a2 & 1) == 0 && (v5 & 8) != 0)
    {
      nw_protocol_implementation_output_available((nw_protocol *)(v3 - 96), (nw_protocol *)(v3 - 96));
      char v7 = v4[403];
      v4[403] = v7 & 0xF7;
      int v6 = v7 & 4;
    }

    uint64_t v8 = *(void (**)(_BYTE *, void, BOOL))(*(void *)(*((void *)v4 + 1) + 80LL) + 136LL);
    if (v8) {
      v8(v4, 0LL, v6 != 0);
    }
    goto LABEL_10;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v20 = "nw_protocol_instance_set_link_flow_controlled";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_instance_set_link_flow_controlled";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v20 = "nw_protocol_instance_set_link_flow_controlled";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_instance_set_link_flow_controlled";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_instance_set_link_flow_controlled";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E545F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v140 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    char v5 = p_output_handler;
    int v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      parent_definition = v5->parent_definition;
      if (parent_definition)
      {
        if (parent_definition->extended_state)
        {
          BOOL v8 = nw_protocol_service_outbound_requests(v5);
          unint64_t v125 = 0LL;
          uint64_t v9 = nw_protocol_implementation_lookup_path_by_protocol(v6, a2, &v125);
          if (v9)
          {
            char v10 = *(_BYTE *)(v9 + 137);
            if ((v10 & 1) == 0) {
              goto LABEL_37;
            }
            uint64_t v11 = v9 + 104;
            if (!*(void *)(v9 + 104)) {
              goto LABEL_37;
            }
            if ((SBYTE5(v6->flow_in_connected) & 0x80000000) == 0 && gLogDatapath)
            {
              uint64_t v86 = v9;
              __nwlog_obj();
              os_log_type_t v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446978;
                os_log_type_t v133 = "nw_protocol_implementation_output_available";
                __int16 v134 = 2082;
                BOOL v135 = (char *)&v6->flow_in_connected + 7;
                __int16 v136 = 2080;
                os_log_type_t v137 = " ";
                __int16 v138 = 2048;
                unint64_t v139 = v125;
                _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing pending outbound frames for %lx",  buf,  0x2Au);
              }

              uint64_t v9 = v86;
              char v10 = *(_BYTE *)(v86 + 137);
            }

            *(_BYTE *)(v9 + 137) = v10 & 0xFE;
            os_log_type_t v12 = *(const char **)(v9 + 32);
            if (v12)
            {
              BOOL v13 = (void *)*((void *)v12 + 5);
              if (v13 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v18 = *((void *)v12 + 11);
                if (v18) {
                  *((void *)v12 + 11) = v18 + 1;
                }
                char v14 = -1;
              }

              else
              {
                char v14 = 0;
              }

              *(void *)os_log_type_t type = v12;
              char v131 = v14;
              uint64_t v19 = *((void *)v12 + 3);
              if (v19)
              {
                os_log_type_t v20 = *(void (**)(const char *, uint64_t))(v19 + 96);
                if (v20)
                {
                  v20(v12, v11);
                  goto LABEL_28;
                }
              }

              __nwlog_obj();
              uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();
              BOOL v62 = (const char *)*((void *)v12 + 2);
              *(_DWORD *)buf = 136446722;
              os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
              if (!v62) {
                BOOL v62 = "invalid";
              }
              __int16 v134 = 2082;
              BOOL v135 = (void *)v62;
              __int16 v136 = 2048;
              os_log_type_t v63 = v12;
              os_log_type_t v137 = v12;
              char v64 = (char *)_os_log_send_and_compose_impl();

              v128[0] = OS_LOG_TYPE_ERROR;
              os_log_type_t v127 = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v64, v128, &v127))
              {
                if (v128[0] == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  os_log_type_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v66 = v128[0];
                  if (os_log_type_enabled(v65, v128[0]))
                  {
                    uint64_t v67 = (const char *)*((void *)v63 + 2);
                    if (!v67) {
                      uint64_t v67 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
                    __int16 v134 = 2082;
                    BOOL v135 = (void *)v67;
                    __int16 v136 = 2048;
                    os_log_type_t v137 = v63;
                    _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback",  buf,  0x20u);
                  }
                }

                else if (v127)
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  os_log_type_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v89 = v128[0];
                  BOOL v90 = os_log_type_enabled(v65, v128[0]);
                  if (backtrace_string)
                  {
                    if (v90)
                    {
                      char v91 = (const char *)*((void *)v63 + 2);
                      if (!v91) {
                        char v91 = "invalid";
                      }
                      *(_DWORD *)buf = 136446978;
                      os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
                      __int16 v134 = 2082;
                      BOOL v135 = (void *)v91;
                      __int16 v136 = 2048;
                      os_log_type_t v137 = v63;
                      __int16 v138 = 2082;
                      unint64_t v139 = (unint64_t)backtrace_string;
                      _os_log_impl( &dword_181A5C000,  v65,  v89,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    free(backtrace_string);
                    goto LABEL_238;
                  }

                  if (v90)
                  {
                    uint64_t v117 = (const char *)*((void *)v63 + 2);
                    if (!v117) {
                      uint64_t v117 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
                    __int16 v134 = 2082;
                    BOOL v135 = (void *)v117;
                    __int16 v136 = 2048;
                    os_log_type_t v137 = v63;
                    _os_log_impl( &dword_181A5C000,  v65,  v89,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  buf,  0x20u);
                  }
                }

                else
                {
                  __nwlog_obj();
                  os_log_type_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v110 = v128[0];
                  if (os_log_type_enabled(v65, v128[0]))
                  {
                    __int16 v111 = (const char *)*((void *)v63 + 2);
                    if (!v111) {
                      __int16 v111 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
                    __int16 v134 = 2082;
                    BOOL v135 = (void *)v111;
                    __int16 v136 = 2048;
                    os_log_type_t v137 = v63;
                    _os_log_impl( &dword_181A5C000,  v65,  v110,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  buf,  0x20u);
                  }
                }
              }

LABEL_228:
                if (v57) {
                  free(v57);
                }
                goto LABEL_54;
              }

              __nwlog_obj();
              __int16 v68 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              os_log_type_t v133 = "__nw_protocol_output_available";
              uint64_t v37 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              v128[0] = OS_LOG_TYPE_DEFAULT;
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                os_log_type_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v70 = type[0];
                if (os_log_type_enabled(v69, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v133 = "__nw_protocol_output_available";
                  _os_log_impl(&dword_181A5C000, v69, v70, "%{public}s called with null protocol", buf, 0xCu);
                }

      if (v76) {
        free(v76);
      }
      *(_DWORD *)(v69 + 368) = -1;
      BOOL v13 = v74;
    }

    if ((*(_BYTE *)(v12 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v203 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v203, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v204 = *(void *)(v12 + 488);
          v205 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
          char v206 = *(_DWORD *)(v12 + 860);
          if (v204) {
            LODWORD(v204) = *(_DWORD *)(v204 + 424);
          }
          v207 = *(_DWORD *)(v69 + 368) + *(_DWORD *)(v69 + 364);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v12 + 74;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&_BYTE buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v205;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v206;
          LOWORD(v265) = 1024;
          *(_DWORD *)((char *)&v265 + 2) = v204;
          WORD3(v265) = 1024;
          DWORD2(v265) = v207;
          _os_log_impl( &dword_181A5C000,  v203,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> connection marked as not-reusable, increased pool width to %u",  buf,  0x38u);
        }
      }
    }

    os_log_type_t v141 = *(void **)(v12 + 496);
    if (v141)
    {
      v142 = *(void *)(v12 + 480);
      if (v142)
      {
        v143 = *(void *)(v142 + 200);
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL56nw_http1_match_idle_connection_with_pending_stream_asyncP19nw_http1_connection_block_invoke;
        *(void *)&_BYTE buf[24] = &unk_189BBD540;
        *(void *)&buf[32] = v143;
        nw_queue_context_async(v141, buf);
        goto LABEL_236;
      }

      v184 = v13;
      __nwlog_obj();
      *(_DWORD *)v268 = 136446210;
      *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
      os_log_type_t v185 = (char *)_os_log_send_and_compose_impl();
      v260[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (v260[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v186 = (os_log_s *)__nwlog_obj();
        v187 = v260[0];
        if (os_log_type_enabled(v186, v260[0]))
        {
          *(_DWORD *)v268 = 136446210;
          *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          v188 = "%{public}s called with null http1";
          goto LABEL_447;
        }

          if (v90) {
            free(v90);
          }
LABEL_105:
          nw_protocol_remove_instance(v2);
          os_log_type_t v65 = *(void *)(v3 + 144);
          if (!v65)
          {
LABEL_110:
            nw_http_connection_metadata_closed(*(void **)(v3 + 256));
            for (i = *(void **)(v3 + 328); i; i = (void *)*i)
              (*(void (**)(void, void))(i[4] + 16LL))(i[4], 0LL);
            if (*(void *)(v3 + 336))
            {
              __int16 v68 = *(void **)(v3 + 328);
              while (v68)
              {
                os_log_type_t v80 = v68;
                __int16 v68 = (void *)*v68;
                if ((v80[5] & 1) != 0)
                {
                  os_log_type_t v81 = (const void *)v80[4];
                  if (v81) {
                    _Block_release(v81);
                  }
                }

                operator delete(v80);
              }

              *(void *)(v3 + 328) = 0LL;
              os_log_type_t v69 = *(void *)(v3 + 320);
              if (v69)
              {
                for (j = 0LL; j != v69; ++j)
                  *(void *)(*(void *)(v3 + 312) + 8 * j) = 0LL;
              }

              *(void *)(v3 + 336) = 0LL;
            }

            os_log_type_t v71 = *(void **)(v3 + 104);
            if (v71)
            {
              os_release(v71);
              *(void *)(v3 + 104) = 0LL;
            }

            os_log_type_t v72 = *(void **)(v3 + 112);
            if (v72)
            {
              os_release(v72);
              *(void *)(v3 + 112) = 0LL;
            }

            BOOL v73 = *(void **)(v3 + 120);
            if (v73)
            {
              os_release(v73);
              *(void *)(v3 + 120) = 0LL;
            }

            __int16 v74 = *(void **)(v3 + 256);
            if (v74)
            {
              os_release(v74);
              *(void *)(v3 + 256) = 0LL;
            }

            os_log_type_t v75 = *(void **)(v3 + 280);
            if (v75)
            {
              os_release(v75);
              *(void *)(v3 + 280) = 0LL;
            }

            uint64_t v76 = *(void **)(v3 + 288);
            if (v76)
            {
              os_release(v76);
              *(void *)(v3 + 288) = 0LL;
            }

            uint64_t v77 = *(void **)(v3 + 296);
            if (v77)
            {
              os_release(v77);
              *(void *)(v3 + 296) = 0LL;
            }

            os_log_type_t v78 = *(void **)(v3 + 304);
            if (v78)
            {
              os_release(v78);
              *(void *)(v3 + 304) = 0LL;
            }

            nghttp2_session_del();
            (*(void (**)(void, void))(*(void *)(v3 + 352) + 16LL))(*(void *)(v3 + 352), 0LL);
            os_log_type_t v79 = *(const void **)(v3 + 352);
            if (v79)
            {
              _Block_release(v79);
              *(void *)(v3 + 352) = 0LL;
            }

            if ((*(__int16 *)(v3 + 388) & 0x80000000) == 0 && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              __int16 v115 = (os_log_s *)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                os_log_type_t v116 = *(_DWORD *)(v3 + 368);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v3 + 390;
                *(_WORD *)&buf[22] = 2080;
                *(void *)&_BYTE buf[24] = " ";
                LOWORD(v136) = 1024;
                *(_DWORD *)((char *)&v136 + 2) = v116;
                HIWORD(v136) = 2048;
                os_log_type_t v137 = v3;
                _os_log_impl( &dword_181A5C000,  v115,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> freeing http2 %p",  buf,  0x30u);
              }
            }

            std::__destroy_at[abi:nn180100]<nw_protocol_http2,0>(v3);
LABEL_139:
            uint64_t v40 = (void *)v3;
LABEL_140:
            free(v40);
            return;
          }

          if (*(void *)v65)
          {
            os_log_type_t v66 = *(void (**)(uint64_t, uint64_t))(*(void *)v65 + 8LL);
            if (v66)
            {
              v66(v65, v2);
LABEL_109:
              *(void *)(v3 + 144) = 0LL;
              goto LABEL_110;
            }
          }

          __nwlog_obj();
          os_log_type_t v106 = *(void *)(v3 + 144);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v106;
          BOOL v107 = (char *)_os_log_send_and_compose_impl();
          __int16 v134 = OS_LOG_TYPE_ERROR;
          v128 = 0;
          if (__nwlog_fault(v107, &v134, &v128))
          {
            if (v134 == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v108 = (os_log_s *)__nwlog_obj();
              __int16 v109 = v134;
              if (!os_log_type_enabled(v108, v134)) {
                goto LABEL_235;
              }
              os_log_type_t v110 = *(void *)(v3 + 144);
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v110;
              __int16 v111 = "%{public}s listen protocol (%p) has invalid disconnected callback";
              goto LABEL_234;
            }

            if (!v128)
            {
              os_log_type_t v108 = (os_log_s *)__nwlog_obj();
              __int16 v109 = v134;
              if (!os_log_type_enabled(v108, v134)) {
                goto LABEL_235;
              }
              char v126 = *(void *)(v3 + 144);
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v126;
              __int16 v111 = "%{public}s listen protocol (%p) has invalid disconnected callback, backtrace limit exceeded";
              goto LABEL_234;
            }

            uint64_t v117 = (char *)__nw_create_backtrace_string();
            os_log_type_t v108 = (os_log_s *)__nwlog_obj();
            __int16 v109 = v134;
            os_log_type_t v118 = os_log_type_enabled(v108, v134);
            if (v117)
            {
              if (v118)
              {
                v119 = *(void *)(v3 + 144);
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v119;
                *(_WORD *)&buf[22] = 2082;
                *(void *)&_BYTE buf[24] = v117;
                _os_log_impl( &dword_181A5C000,  v108,  v109,  "%{public}s listen protocol (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v117);
              goto LABEL_235;
            }

            if (v118)
            {
              os_log_type_t v127 = *(void *)(v3 + 144);
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v127;
              __int16 v111 = "%{public}s listen protocol (%p) has invalid disconnected callback, no backtrace";
LABEL_234:
              _os_log_impl(&dword_181A5C000, v108, v109, v111, buf, 0x16u);
            }
          }

LABEL_257:
              goto LABEL_258;
            }

            if (v127 == OS_LOG_TYPE_DEFAULT)
            {
              __nwlog_obj();
              os_log_type_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v118 = v128[0];
              if (os_log_type_enabled(v79, v128[0]))
              {
                v119 = *(const char **)(v77 + 16);
                if (!v119) {
                  v119 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
                __int16 v134 = 2082;
                BOOL v135 = (void *)v119;
                __int16 v136 = 2048;
                os_log_type_t v137 = (const char *)v77;
                _os_log_impl( &dword_181A5C000,  v79,  v118,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  buf,  0x20u);
              }

              goto LABEL_257;
            }

            __int16 v101 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            os_log_type_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v102 = v128[0];
            BOOL v103 = os_log_type_enabled(v79, v128[0]);
            if (!v101)
            {
              if (v103)
              {
                BOOL v121 = *(const char **)(v77 + 16);
                if (!v121) {
                  BOOL v121 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
                __int16 v134 = 2082;
                BOOL v135 = (void *)v121;
                __int16 v136 = 2048;
                os_log_type_t v137 = (const char *)v77;
                _os_log_impl( &dword_181A5C000,  v79,  v102,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  buf,  0x20u);
              }

              goto LABEL_257;
            }

            if (v103)
            {
              uint64_t v104 = *(const char **)(v77 + 16);
              if (!v104) {
                uint64_t v104 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              os_log_type_t v133 = "__nw_protocol_finalize_output_frames";
              __int16 v134 = 2082;
              BOOL v135 = (void *)v104;
              __int16 v136 = 2048;
              os_log_type_t v137 = (const char *)v77;
              __int16 v138 = 2082;
              unint64_t v139 = (unint64_t)v101;
              _os_log_impl( &dword_181A5C000,  v79,  v102,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v101);
          }

    if (v135) {
      free(v135);
    }
    *(_DWORD *)(v8 + 344) = -1;
    goto LABEL_260;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http1_stream_add_input_handler";
  uint64_t v229 = (char *)_os_log_send_and_compose_impl();
  aBlock[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v229, aBlock, &type))
  {
    if (aBlock[0] == 17)
    {
      v230 = (os_log_s *)__nwlog_obj();
      uint64_t v231 = aBlock[0];
      if (!os_log_type_enabled(v230, (os_log_type_t)aBlock[0])) {
        goto LABEL_431;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_add_input_handler";
      uint64_t v232 = "%{public}s called with null http1_stream->parameters";
      goto LABEL_430;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v230 = (os_log_s *)__nwlog_obj();
      uint64_t v231 = aBlock[0];
      if (!os_log_type_enabled(v230, (os_log_type_t)aBlock[0])) {
        goto LABEL_431;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_add_input_handler";
      uint64_t v232 = "%{public}s called with null http1_stream->parameters, backtrace limit exceeded";
      goto LABEL_430;
    }

    __int128 v250 = (char *)__nw_create_backtrace_string();
    v230 = (os_log_s *)__nwlog_obj();
    uint64_t v231 = aBlock[0];
    v251 = os_log_type_enabled(v230, (os_log_type_t)aBlock[0]);
    if (v250)
    {
      if (v251)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_stream_add_input_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v250;
        _os_log_impl( &dword_181A5C000,  v230,  v231,  "%{public}s called with null http1_stream->parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v250);
      goto LABEL_431;
    }

    if (v251)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_add_input_handler";
      uint64_t v232 = "%{public}s called with null http1_stream->parameters, no backtrace";
LABEL_430:
      _os_log_impl(&dword_181A5C000, v230, v231, v232, buf, 0xCu);
    }
  }

void sub_181E560C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  if ((a24 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a23);
  }

  _Unwind_Resume(a1);
}

BOOL nw_protocol_service_outbound_requests(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  p_tqh_first = (id *)&v1->pending_outbound_frames.tqh_first;
  tqh_first = (unsigned __int8 *)v1->pending_outbound_frames.tqh_first;
  if (tqh_first)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x3032000000LL;
    BOOL v13 = __Block_byref_object_copy__11696;
    char v14 = __Block_byref_object_dispose__11697;
    id v15 = 0LL;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___ZL37nw_protocol_service_outbound_requestsP31NWConcrete_nw_protocol_instance_block_invoke;
    v7[3] = &unk_189BC7960;
    uint64_t v9 = &v10;
    BOOL v8 = v1;
    nw_array_apply(tqh_first, (uint64_t)v7);
    objc_storeStrong(p_tqh_first, (id)v11[5]);
    BOOL v5 = v11[5] == 0;

    _Block_object_dispose(&v10, 8);
  }

  else
  {
    BOOL v5 = 1LL;
  }

  return v5;
}

uint64_t nw_protocol_implementation_lookup_path_by_protocol( NWConcrete_nw_protocol_instance *a1, nw_protocol *a2, unint64_t *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  BOOL v5 = a1;
  int v6 = v5;
  if (a2)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v22 = 0LL;
    flow_registration = (char *)v5->flow_registration;
    if (flow_registration)
    {
      v18[0] = MEMORY[0x1895F87A8];
      v18[1] = 3221225472LL;
      v18[2] = ___ZL50nw_protocol_implementation_lookup_path_by_protocolP31NWConcrete_nw_protocol_instanceP11nw_protocolPm_block_invoke;
      v18[3] = &unk_189BB83B0;
      v18[4] = buf;
      v18[5] = a2;
      v18[6] = a3;
      nw_hash_table_apply(flow_registration, (uint64_t)v18);
      uint64_t v8 = *(void *)(*(void *)&buf[8] + 24LL);
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_lookup_path_by_protocol";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v11, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_lookup_path_by_protocol";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_lookup_path_by_protocol";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_lookup_path_by_protocol";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_lookup_path_by_protocol";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t ___ZL43nw_protocol_implementation_output_availableP11nw_protocolS0__block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    uint64_t v5 = v4 - 96;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (object)
  {
    int v6 = object;
    char v7 = (void *)object[5];
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = object[11];
      if (v9) {
        object[11] = v9 + 1;
      }
      char v8 = -1;
    }

    else
    {
      char v8 = 0;
    }

    *(void *)BOOL v49 = object;
    char v50 = v8;
    if (v4)
    {
      uint64_t v10 = *(void **)(v5 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v12 = *(void *)(v5 + 88);
        if (v12) {
          *(void *)(v5 + 88) = v12 + 1;
        }
        char v11 = -1;
      }

      else
      {
        char v11 = 0;
      }

      *(void *)BOOL v46 = v5;
      char v47 = v11;
      uint64_t v13 = object[3];
      if (v13)
      {
        char v14 = *(void (**)(void *))(v13 + 72);
        if (v14)
        {
          v14(object);
LABEL_19:
          if (v10 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v46);
          }
LABEL_21:
          if (v7 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v49);
          }
          return 1LL;
        }
      }

      __nwlog_obj();
      BOOL v16 = (void *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = (const char *)v6[2];
      *(_DWORD *)buf = 136446722;
      BOOL v52 = "__nw_protocol_output_available";
      if (!v17) {
        os_log_type_t v17 = "invalid";
      }
      __int16 v53 = 2082;
      BOOL v54 = (void *)v17;
      __int16 v55 = 2048;
      uint64_t v56 = v6;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v45 = 0;
      if (__nwlog_fault(v18, &type, &v45))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v19, type))
          {
            uint64_t v21 = (const char *)v6[2];
            if (!v21) {
              uint64_t v21 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            BOOL v52 = "__nw_protocol_output_available";
            __int16 v53 = 2082;
            BOOL v54 = (void *)v21;
            __int16 v55 = 2048;
            uint64_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s protocol %{public}s (%p) has invalid output_available callback",  buf,  0x20u);
          }
        }

        else if (v45)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v31 = type;
          BOOL v32 = os_log_type_enabled(v19, type);
          if (backtrace_string)
          {
            if (v32)
            {
              os_log_type_t v33 = (const char *)v6[2];
              if (!v33) {
                os_log_type_t v33 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              BOOL v52 = "__nw_protocol_output_available";
              __int16 v53 = 2082;
              BOOL v54 = (void *)v33;
              __int16 v55 = 2048;
              uint64_t v56 = v6;
              __int16 v57 = 2082;
              uint64_t v58 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            goto LABEL_70;
          }

          if (v32)
          {
            uint64_t v42 = (const char *)v6[2];
            if (!v42) {
              uint64_t v42 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            BOOL v52 = "__nw_protocol_output_available";
            __int16 v53 = 2082;
            BOOL v54 = (void *)v42;
            __int16 v55 = 2048;
            uint64_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v19, type))
          {
            os_log_type_t v41 = (const char *)v6[2];
            if (!v41) {
              os_log_type_t v41 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            BOOL v52 = "__nw_protocol_output_available";
            __int16 v53 = 2082;
            BOOL v54 = (void *)v41;
            __int16 v55 = 2048;
            uint64_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v40,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

void sub_181E56D24(_Unwind_Exception *exception_object)
{
}

uint64_t ___ZL50nw_protocol_implementation_lookup_path_by_protocolP31NWConcrete_nw_protocol_instanceP11nw_protocolPm_block_invoke( void *a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t v5 = *(void *)(extra + 32);
  if (!v5) {
    return 1LL;
  }
  while (a1[5] != v5)
  {
    uint64_t v5 = *(void *)(v5 + 32);
    if (!v5) {
      return 1LL;
    }
  }

  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = extra;
  if (!a1[6]) {
    return 0LL;
  }
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t result = 0LL;
  *(void *)a1[6] = object;
  return result;
}

uint64_t ___ZL37nw_protocol_service_outbound_requestsP31NWConcrete_nw_protocol_instance_block_invoke( uint64_t a1, int a2, void *aBlock)
{
  uint64_t v4 = _Block_copy(aBlock);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  if (v6) {
    goto LABEL_4;
  }
  if (((*((uint64_t (**)(void *, void, void))v4 + 2))(v4, *(void *)(a1 + 32), 0LL) & 1) == 0)
  {
    BOOL v7 = nw_array_create();
    uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = v7;

    uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
LABEL_4:
    uint64_t v10 = _Block_copy(v5);
    nw_array_append(v6, v10);
  }

  return 1LL;
}

void sub_181E56E7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_instance_get_logging_disabled(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1) {
    return nw_parameters_get_logging_disabled(*(void *)(a1 + 48));
  }
  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_protocol_instance_get_logging_disabled";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_instance_get_logging_disabled";
          __int16 v14 = 2082;
          os_log_type_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_181A5C000, v4, v7, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_protocol_instance_get_sensitive_redacted(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1) {
    return nw_parameters_get_sensitive_redacted(*(void **)(a1 + 48));
  }
  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_protocol_instance_get_sensitive_redacted";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v13 = "nw_protocol_instance_get_sensitive_redacted";
          __int16 v14 = 2082;
          os_log_type_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_181A5C000, v4, v7, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_instance_set_preferred_addresses(void *a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  os_log_type_t v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (v5)
  {
    objc_storeStrong(v5 + 45, a2);
    objc_storeStrong(v5 + 46, a3);
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v19 = "nw_protocol_instance_set_preferred_addresses";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_instance_set_preferred_addresses";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          char v19 = "nw_protocol_instance_set_preferred_addresses";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_instance_set_preferred_addresses";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_instance_set_preferred_addresses";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

NWConcrete_nw_protocol_definition *nw_protocol_definition_create_named(int a1, unsigned __int8 *a2)
{
  *(void *)&v62[13] = *MEMORY[0x1895F89C0];
  if ((a1 - 4) > 0xFFFFFFFC)
  {
    os_log_type_t v9 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_definition);
    id v7 = v9;
    if (v9)
    {
      uuid_generate_random(v9->unique_identifier);
      name = v7->identifier.name;
      if (a2)
      {
        int v11 = *a2;
        char *name = v11;
        if (v11)
        {
          int v12 = a2[1];
          v7->identifier.name[1] = v12;
          if (v12)
          {
            int v13 = a2[2];
            v7->identifier.name[2] = v13;
            if (v13)
            {
              int v14 = a2[3];
              v7->identifier.name[3] = v14;
              if (v14)
              {
                int v15 = a2[4];
                v7->identifier.name[4] = v15;
                if (v15)
                {
                  int v16 = a2[5];
                  v7->identifier.name[5] = v16;
                  if (v16)
                  {
                    int v17 = a2[6];
                    v7->identifier.name[6] = v17;
                    if (v17)
                    {
                      int v18 = a2[7];
                      v7->identifier.name[7] = v18;
                      if (v18)
                      {
                        int v19 = a2[8];
                        v7->identifier.name[8] = v19;
                        if (v19)
                        {
                          int v20 = a2[9];
                          v7->identifier.name[9] = v20;
                          if (v20)
                          {
                            int v21 = a2[10];
                            v7->identifier.name[10] = v21;
                            if (v21)
                            {
                              int v22 = a2[11];
                              v7->identifier.name[11] = v22;
                              if (v22)
                              {
                                int v23 = a2[12];
                                v7->identifier.name[12] = v23;
                                if (v23)
                                {
                                  int v24 = a2[13];
                                  v7->identifier.name[13] = v24;
                                  if (v24)
                                  {
                                    int v25 = a2[14];
                                    v7->identifier.name[14] = v25;
                                    if (v25)
                                    {
                                      int v26 = a2[15];
                                      v7->identifier.name[15] = v26;
                                      if (v26)
                                      {
                                        int v27 = a2[16];
                                        v7->identifier.name[16] = v27;
                                        if (v27)
                                        {
                                          int v28 = a2[17];
                                          v7->identifier.name[17] = v28;
                                          if (v28)
                                          {
                                            int v29 = a2[18];
                                            v7->identifier.name[18] = v29;
                                            if (v29)
                                            {
                                              int v30 = a2[19];
                                              v7->identifier.name[19] = v30;
                                              if (v30)
                                              {
                                                int v31 = a2[20];
                                                v7->identifier.name[20] = v31;
                                                if (v31)
                                                {
                                                  int v32 = a2[21];
                                                  v7->identifier.name[21] = v32;
                                                  if (v32)
                                                  {
                                                    int v33 = a2[22];
                                                    v7->identifier.name[22] = v33;
                                                    if (v33)
                                                    {
                                                      int v34 = a2[23];
                                                      v7->identifier.name[23] = v34;
                                                      if (v34)
                                                      {
                                                        int v35 = a2[24];
                                                        v7->identifier.name[24] = v35;
                                                        if (v35)
                                                        {
                                                          int v36 = a2[25];
                                                          v7->identifier.name[25] = v36;
                                                          if (v36)
                                                          {
                                                            int v37 = a2[26];
                                                            v7->identifier.name[26] = v37;
                                                            if (v37)
                                                            {
                                                              int v38 = a2[27];
                                                              v7->identifier.name[27] = v38;
                                                              if (v38)
                                                              {
                                                                int v39 = a2[28];
                                                                v7->identifier.name[28] = v39;
                                                                if (v39)
                                                                {
                                                                  int v40 = a2[29];
                                                                  v7->identifier.name[29] = v40;
                                                                  if (v40)
                                                                  {
                                                                    int v41 = a2[30];
                                                                    v7->identifier.name[30] = v41;
                                                                    if (v41) {
                                                                      v7->identifier.name[31] = 0;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      else
      {
        uuid_unparse(v7->unique_identifier, name);
      }

      if (a1 == 3) {
        int v49 = 2;
      }
      else {
        int v49 = 1;
      }
      v7->identifier.level = 0;
      v7->identifier.mapping = v49;
      v7->variant = a1;
      char v50 = v7;
      goto LABEL_62;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v45 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v60 = "nw_protocol_definition_create_named";
    BOOL v46 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (__nwlog_fault(v46, &type, &v57))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v47 = (os_log_s *)(id)gLogObj;
        os_log_type_t v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v60 = "nw_protocol_definition_create_named";
          _os_log_impl(&dword_181A5C000, v47, v48, "%{public}s [nw_protocol_definition init] failed", buf, 0xCu);
        }
      }

      else if (v57)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v47 = (os_log_s *)(id)gLogObj;
        os_log_type_t v54 = type;
        BOOL v55 = os_log_type_enabled(v47, type);
        if (backtrace_string)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v60 = "nw_protocol_definition_create_named";
            __int16 v61 = 2082;
            *(void *)BOOL v62 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v47,  v54,  "%{public}s [nw_protocol_definition init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v46) {
            goto LABEL_62;
          }
          goto LABEL_56;
        }

        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v60 = "nw_protocol_definition_create_named";
          _os_log_impl( &dword_181A5C000,  v47,  v54,  "%{public}s [nw_protocol_definition init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v47 = (os_log_s *)(id)gLogObj;
        os_log_type_t v56 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v60 = "nw_protocol_definition_create_named";
          _os_log_impl( &dword_181A5C000,  v47,  v56,  "%{public}s [nw_protocol_definition init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v46)
    {
LABEL_62:

      return v7;
    }

void sub_181E57DF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_initialize_common_state(NWConcrete_nw_protocol_definition *a1)
{
  uint64_t v1 = a1;
  if (v1->common_state) {
    goto LABEL_4;
  }
  uint64_t v2 = (nw_protocol_definition_common_state *)calloc(1uLL, 0x58uLL);
  if (v2)
  {
LABEL_3:
    v1->common_state = v2;
LABEL_4:

    return;
  }

  __nwlog_obj();
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v4))
  {
    free(v4);
    goto LABEL_3;
  }

  __break(1u);
}

void sub_181E57F3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_definition_get_framer_create(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1[9];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 72);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_protocol_definition_get_framer_create";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_framer_create";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition->common_state", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_protocol_definition_get_framer_create";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition->common_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_framer_create";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition->common_state, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_framer_create";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition->common_state, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

NWConcrete_nw_protocol_definition *nw_protocol_definition_create(int a1)
{
  return nw_protocol_definition_create_named(a1, 0LL);
}

void nw_protocol_definition_set_is_proxy(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 184) |= 0x80u;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_definition_set_is_proxy";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_definition_set_is_proxy";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          int v14 = "nw_protocol_definition_set_is_proxy";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_definition_set_is_proxy";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_definition_set_is_proxy";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_definition_is_framer(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((_BYTE *)v1 + 184) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_protocol_definition_is_framer";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_is_framer";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_protocol_definition_is_framer";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_is_framer";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_is_framer";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_definition_set_multipath(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 16;
    }
    else {
      char v5 = 0;
    }
    *((_BYTE *)v3 + 184) = *((_BYTE *)v3 + 184) & 0xEF | v5;
    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_definition_set_multipath";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_definition_set_multipath";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_protocol_definition_set_multipath";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_definition_set_multipath";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_definition_set_multipath";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_definition_get_multipath(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[184] >> 4) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_protocol_definition_get_multipath";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_multipath";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_protocol_definition_get_multipath";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_multipath";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_multipath";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_definition_set_supports_discontiguous_data(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 32;
    }
    else {
      char v5 = 0;
    }
    *((_BYTE *)v3 + 184) = *((_BYTE *)v3 + 184) & 0xDF | v5;
    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_definition_set_supports_discontiguous_data";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_definition_set_supports_discontiguous_data";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_protocol_definition_set_supports_discontiguous_data";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_definition_set_supports_discontiguous_data";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_definition_set_supports_discontiguous_data";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_definition_get_supports_discontiguous_data(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[184] >> 5) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_protocol_definition_get_supports_discontiguous_data";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_supports_discontiguous_data";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_protocol_definition_get_supports_discontiguous_data";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_supports_discontiguous_data";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_supports_discontiguous_data";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_definition_set_globals_allocator(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  char v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_protocol_definition_set_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          int v29 = "nw_protocol_definition_set_globals_allocator";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5985C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_context_globals_allocator(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  char v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_protocol_definition_set_context_globals_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          int v29 = "nw_protocol_definition_set_context_globals_allocator";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E59F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_instance_state_allocator(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  char v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_protocol_definition_set_instance_state_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          int v29 = "nw_protocol_definition_set_instance_state_allocator";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5A604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_initialize_extended_state(NWConcrete_nw_protocol_definition *a1)
{
  id v1 = a1;
  if (v1->extended_state) {
    goto LABEL_4;
  }
  uint64_t v2 = (nw_protocol_definition_extended_state *)calloc(1uLL, 0x108uLL);
  if (v2)
  {
LABEL_3:
    v1->extended_state = v2;
LABEL_4:

    return;
  }

  __nwlog_obj();
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v4))
  {
    free(v4);
    goto LABEL_3;
  }

  __break(1u);
}

void sub_181E5A748(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_flow_state_allocator(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_protocol_definition_set_flow_state_allocator";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          int v36 = "nw_protocol_definition_set_flow_state_allocator";
          __int16 v37 = 2082;
          int v38 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v10) {
          goto LABEL_6;
        }
LABEL_73:
        free(v10);
        goto LABEL_6;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_181A5C000, v11, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl( &dword_181A5C000,  v11,  v29,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5B034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_options_allocator(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_protocol_definition_set_options_allocator";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          int v36 = "nw_protocol_definition_set_options_allocator";
          __int16 v37 = 2082;
          int v38 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v10) {
          goto LABEL_6;
        }
LABEL_73:
        free(v10);
        goto LABEL_6;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_181A5C000, v11, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl( &dword_181A5C000,  v11,  v29,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_options_equality_check(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_options_equality_check";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_options_equality_check";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_options_comparator(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_options_comparator";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_comparator";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_options_comparator";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_comparator";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_comparator";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_options_serializer(void *a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_protocol_definition_set_options_serializer";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v31 = "nw_protocol_definition_set_options_serializer";
          __int16 v32 = 2082;
          char v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10) {
          goto LABEL_5;
        }
LABEL_56:
        free(v10);
        goto LABEL_5;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_options_should_serialize(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_options_should_serialize";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_should_serialize";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_options_should_serialize";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_should_serialize";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_options_should_serialize";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_metadata_allocator(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
          __int16 v30 = 2082;
          os_log_type_t v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_metadata_initializer(void *a1, unsigned int a2, void *a3, void *a4)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
          __int16 v33 = 2082;
          uint64_t v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11) {
          goto LABEL_5;
        }
LABEL_56:
        free(v11);
        goto LABEL_5;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_181A5C000, v12, v19, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl( &dword_181A5C000,  v12,  v26,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5DB30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_metadata_serializer(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v29 = "nw_protocol_definition_set_metadata_serializer";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          char v29 = "nw_protocol_definition_set_metadata_serializer";
          __int16 v30 = 2082;
          os_log_type_t v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_metadata_copy_reply(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
          __int16 v32 = 2082;
          __int16 v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10) {
          goto LABEL_5;
        }
LABEL_56:
        free(v10);
        goto LABEL_5;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5E8C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_metadata_copy_message_options(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5ED84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_metadata_comparator(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_metadata_comparator";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_comparator";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_metadata_comparator";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_comparator";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_metadata_comparator";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_definition_set_cache_entry_deallocator(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5F6E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_should_flush_cache_entry(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_should_flush_cache_entry";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_should_flush_cache_entry";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E5FBA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_has_global_definition(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 184) |= 0x40u;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void *nw_protocol_copy_definition_for_identifier(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_protocol_copy_definition_for_identifier";
    char v11 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault((const char *)v11, &type, &v17))
    {
LABEL_38:
      if (v11) {
        free(v11);
      }
      return 0LL;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_protocol_copy_definition_for_identifier";
        os_log_type_t v14 = "%{public}s called with null identifier";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      }
    }

    else
    {
      if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v20 = "nw_protocol_copy_definition_for_identifier";
            __int16 v21 = 2082;
            BOOL v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (!v16) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_protocol_copy_definition_for_identifier";
        os_log_type_t v14 = "%{public}s called with null identifier, no backtrace";
        goto LABEL_36;
      }

      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_protocol_copy_definition_for_identifier";
        os_log_type_t v14 = "%{public}s called with null identifier, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

BOOL nw_protocol_definition_register(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = nw_protocol_register_handle( (uint64_t)v1 + 8,  v1,  (uint64_t)nw_protocol_implementation_create,  (uint64_t)nw_protocol_implementation_accept);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_register";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_register";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_register";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_register";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_register";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id *nw_protocol_implementation_create(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    if (v8)
    {
      BOOL v11 = v8;
      if (v11[16] == 3)
      {
        os_log_type_t v12 = &nw_protocol_instance_multiplex_callbacks(void)::callbacks;
      }

      else
      {
        os_log_type_t v12 = &nw_protocol_instance_one_to_one_callbacks(void)::callbacks;
      }

      uint64_t v13 = *v12;
      os_log_type_t v14 = (objc_class *)objc_opt_class();
      __int16 v15 = (id *)nw_protocol_new_objc(v14, (uint64_t)v10, (uint64_t)(v11 + 2), v13);
      BOOL v16 = v15;
      if (v15)
      {
        objc_storeStrong(v15 + 5, a3);
        objc_storeStrong(v16 + 6, a4);
        objc_storeStrong(v16 + 1, a2);
        else {
          char v17 = 0;
        }
        *((_BYTE *)v16 + 405) = v17 & 0x80 | *((_BYTE *)v16 + 405) & 0x7F;
        os_log_type_t v18 = (uint64_t (**)(void))*((void *)v16[1] + 10);
        if (v18)
        {
          uint64_t v19 = *v18;
          if (v19) {
            v16[14] = (id)v19();
          }
        }

        BOOL v20 = v16;
        v20[2] = v20;
        __int16 v21 = v20 - 12;
        goto LABEL_38;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      char v47 = "nw_protocol_implementation_create";
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v44 = 0;
      if (__nwlog_fault(v23, &type, &v44))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v24 = (os_log_s *)(id)gLogObj;
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446210;
            char v47 = "nw_protocol_implementation_create";
            _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s nw_protocol_new_objc failed", buf, 0xCu);
          }
        }

        else if (v44)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v24 = (os_log_s *)(id)gLogObj;
          os_log_type_t v27 = type;
          BOOL v28 = os_log_type_enabled(v24, type);
          if (backtrace_string)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              char v47 = "nw_protocol_implementation_create";
              __int16 v48 = 2082;
              int v49 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s nw_protocol_new_objc failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v23) {
              goto LABEL_37;
            }
            goto LABEL_36;
          }

          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            char v47 = "nw_protocol_implementation_create";
            _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s nw_protocol_new_objc failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v24 = (os_log_s *)(id)gLogObj;
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446210;
            char v47 = "nw_protocol_implementation_create";
            _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s nw_protocol_new_objc failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v23)
      {
LABEL_37:
        __int16 v21 = 0LL;
LABEL_38:

        goto LABEL_39;
      }

void sub_181E60BF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_accept(uint64_t a1, void *a2, void *a3)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!a1)
  {
    __nwlog_obj();
    id v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v32 = "nw_protocol_implementation_accept";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_implementation_accept";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null many_to_one_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_implementation_accept";
        _os_log_impl( &dword_181A5C000,  v12,  v26,  "%{public}s called with null many_to_one_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_implementation_accept";
        _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s called with null many_to_one_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v32 = "nw_protocol_implementation_accept";
      __int16 v33 = 2082;
      os_log_type_t v34 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s called with null many_to_one_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_30;
  }

  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v32 = "nw_protocol_implementation_accept";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_implementation_accept";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_implementation_accept";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_implementation_accept";
        _os_log_impl(&dword_181A5C000, v12, v21, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v32 = "nw_protocol_implementation_accept";
      __int16 v33 = 2082;
      os_log_type_t v34 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void ___ZL40nw_protocol_instance_multiplex_callbacksv_block_invoke()
{
  nw_protocol_instance_multiplex_callbacks(void)::callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler( (void *)nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_add_input_handler);
  nw_protocol_callbacks_set_replace_input_handler( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_replace_input_handler);
  nw_protocol_callbacks_set_remove_input_handler( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_remove_input_handler);
  nw_protocol_callbacks_set_connected( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_connected);
  nw_protocol_callbacks_set_disconnect( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_disconnect);
  nw_protocol_callbacks_set_disconnected( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_disconnected);
  nw_protocol_callbacks_set_link_state( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_link_state);
  nw_protocol_callbacks_set_get_message_properties( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_message_properties);
  nw_protocol_callbacks_set_waiting_for_output( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_waiting_for_output);
  nw_protocol_callbacks_set_get_input_frames( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_input_frames);
  nw_protocol_callbacks_set_get_output_frames( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_output_frames);
  nw_protocol_callbacks_set_finalize_output_frames( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_finalize_output_frames);
  nw_protocol_callbacks_set_input_available( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_input_available);
  nw_protocol_callbacks_set_input_finished( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_input_finished);
  nw_protocol_callbacks_set_input_flush( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_input_flush);
  nw_protocol_callbacks_set_output_available( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_output_available);
  nw_protocol_callbacks_set_output_finished( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_output_finished);
  nw_protocol_callbacks_set_copy_info( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_copy_info);
  nw_protocol_callbacks_set_notify( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_notify);
  nw_protocol_callbacks_set_error( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_error);
  nw_protocol_callbacks_set_updated_path( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_updated_path);
  nw_protocol_callbacks_set_connect( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_connect);
  nw_protocol_callbacks_set_add_listen_handler( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_add_listen_handler);
  nw_protocol_callbacks_set_remove_listen_handler( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_remove_listen_handler);
  nw_protocol_callbacks_set_get_parameters( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_parameters);
  nw_protocol_callbacks_set_get_local_endpoint( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_local);
  nw_protocol_callbacks_set_get_remote_endpoint( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_remote);
  nw_protocol_callbacks_set_get_path( nw_protocol_instance_multiplex_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_path);
}

uint64_t nw_protocol_implementation_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v285 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v6 = p_output_handler;
    id v7 = v6;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *((void *)v6 + 1);
      if (v8)
      {
        if (*(void *)(v8 + 80))
        {
          if (a1 != a2)
          {
            if (a2)
            {
              if (!a2->output_handler)
              {
                a2->output_handler = a1;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  callbacks = a1[1].callbacks;
                  if (callbacks) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                  }
                }
              }

              id v10 = a2->handle;
              if (v10 == &nw_protocol_ref_counted_handle)
              {
                BOOL v16 = a2[1].callbacks;
                if (v16) {
                  a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v16->add_input_handler + 1);
                }
                *(void *)os_log_type_t type = a2;
                char v11 = type[8] | 1;
              }

              else
              {
                *(void *)os_log_type_t type = a2;
                char v11 = type[8] & 0xFE;
              }

              os_log_type_t type[8] = v11;
              os_log_type_t v17 = a2->callbacks;
              if (v17)
              {
                get_parameters = (void (*)(nw_protocol *))v17->get_parameters;
                if (get_parameters)
                {
                  get_parameters(a2);
                  id v19 = (id)objc_claimAutoreleasedReturnValue();

                  if (v10 != &nw_protocol_ref_counted_handle) {
                    goto LABEL_27;
                  }
                  goto LABEL_136;
                }
              }

              __nwlog_obj();
              BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
              identifier = a2->identifier;
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
              if (!identifier) {
                identifier = (nw_protocol_identifier *)"invalid";
              }
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = identifier;
              __int16 v281 = 2048;
              v282 = a2;
              os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

              LOBYTE(v279) = 16;
              LOBYTE(v275) = 0;
              if (__nwlog_fault(v27, &v279, &v275))
              {
                if (v279 == 17)
                {
                  __nwlog_obj();
                  os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v29 = v279;
                  if (os_log_type_enabled(v28, (os_log_type_t)v279))
                  {
                    __int16 v30 = a2->identifier;
                    if (!v30) {
                      __int16 v30 = (nw_protocol_identifier *)"invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v30;
                    __int16 v281 = 2048;
                    v282 = a2;
                    _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback",  buf,  0x20u);
                  }

LABEL_560:
                        if (v234) {
                          free(v234);
                        }
                        uint64_t v127 = 0LL;
                        uint64_t v140 = 0LL;
LABEL_294:

                        BOOL v122 = v274;
                        if ((v119[402] & 2) != 0)
                        {
LABEL_305:
                          uint64_t extra = nw_hash_node_get_extra(v122);
                          *(void *)(extra + 16) = 0LL;
                          *(void *)(extra + 24) = extra + 16;
                          objc_storeStrong((id *)(extra + 8), v92);
                          int v152 = *(_WORD *)(extra + 52) & 0xFFFE | v127;
                          *(_WORD *)(extra + 52) = v152;
                          unsigned int v153 = v152 & 0xFFFFFFFD | (2 * ((v119[404] >> 1) & 1));
                          *(_WORD *)(extra + 52) = v153;
                          if ((v119[404] & 3) == 1) {
                            *(_WORD *)(extra + 52) = v153 | 8;
                          }
                          uint64_t v154 = *((void *)v7 + 1);
                          if (a2)
                          {
                            if ((*(_BYTE *)(v154 + 184) & 0x20) != 0)
                            {
                              v155 = a2->callbacks;
                              if (v155)
                              {
                                supports_external_data = (uint64_t (*)(nw_protocol *))v155->supports_external_data;
                                if (supports_external_data)
                                {
                                  v157 = a2->handle;
                                  if (v157 == &nw_protocol_ref_counted_handle)
                                  {
                                    os_log_type_t v172 = a2[1].callbacks;
                                    if (v172) {
                                      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v172->add_input_handler + 1);
                                    }
                                    *(void *)buf = a2;
                                    char v158 = buf[8] | 1;
                                  }

                                  else
                                  {
                                    *(void *)buf = a2;
                                    char v158 = buf[8] & 0xFE;
                                  }

                                  buf[8] = v158;
                                  int v173 = supports_external_data(a2);
                                  if (v157 == &nw_protocol_ref_counted_handle) {
                                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                                  }
                                  if (v173) {
                                    __int16 v174 = 1024;
                                  }
                                  else {
                                    __int16 v174 = 0;
                                  }
                                  *(_WORD *)(extra + 52) = *(_WORD *)(extra + 52) & 0xFBFF | v174;
                                  uint64_t v154 = *((void *)v7 + 1);
                                }
                              }
                            }
                          }

                          BOOL v175 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v154 + 80) + 16LL);
                          if (v175) {
                            *(void *)uint64_t extra = v175(v154, v151);
                          }
                          v176 = v119;
                          if (nw_protocol_definition_get_message_is_stream(*((void **)v7 + 1))
                            && *((nw_protocol **)v176 - 6) == a2)
                          {
                            a2 = (nw_protocol *)-2LL;
                          }

                          *((void *)v176 + 31) = a2;
                          uint64_t v178 = *((void *)v176 + 4);
                          if (v178)
                          {
                            nw_queue_cancel_source(v178, v177);
                            *((void *)v176 + 4) = 0LL;
                          }

LABEL_459:
                          v222 = v7;
                          uint64_t v223 = v222;
                          if ((*(_BYTE *)(*((void *)v7 + 1) + 184LL) & 0x10) != 0
                            && nw_parameters_get_multipath(v222[6])
                            && *(void *)(*(void *)(*((void *)v7 + 1) + 80LL) + 208LL))
                          {
                            BOOL v224 = (*((_BYTE *)v223 + 405) & 4) == 0;

                            if (v224)
                            {
                              uint64_t v225 = (nw_endpoint *)v223[5];
                              if (v225)
                              {
                                if (nw_endpoint_get_type(v225) == nw_endpoint_type_address
                                  && nw_endpoint_get_address_family(v223[5]) == 30
                                  && nw_path_is_eligible_for_CrazyIvan46(v223[36]))
                                {
                                  LODWORD(v279) = nw_path_get_interface_index(v223[36]);
                                  address = nw_endpoint_get_address((nw_endpoint_t)v223[5]);
                                  *(void *)os_log_type_t type = 0LL;
                                  int v227 = nw_nat64_copy_prefixes((unsigned int *)&v279, type);
                                  if (v227 >= 1)
                                  {
                                    uint64_t v228 = 0LL;
                                    uint64_t v229 = 16LL * v227;
                                    while (1)
                                    {
                                      int v275 = 0;
                                      if (nw_nat64_extract_v4( (unsigned int *)(*(void *)type + v228),  &address->sa_data[6],  (uint64_t)&v275)) {
                                        break;
                                      }
                                      v228 += 16LL;
                                      if (v229 == v228) {
                                        goto LABEL_478;
                                      }
                                    }

                                    *(_WORD *)buf = 528;
                                    *(_WORD *)&buf[2] = *(_WORD *)address->sa_data;
                                    *(_DWORD *)&uint8_t buf[4] = v275;
                                    *(void *)&buf[8] = 0LL;
                                    nw_endpoint_t v231 = nw_endpoint_create_address((const sockaddr *)buf);
                                    uint64_t v232 = v223[44];
                                    v223[44] = v231;
                                  }

LABEL_511:
                    if (v197) {
                      free(v197);
                    }
                    __nwlog_obj();
                    v251 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                    uint64_t v252 = (char *)_os_log_send_and_compose_impl();

                    type[0] = 16;
                    LOBYTE(v279) = 0;
                    if (__nwlog_fault(v252, type, &v279))
                    {
                      if (type[0] == 17)
                      {
                        __nwlog_obj();
                        v253 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v254 = type[0];
                        if (os_log_type_enabled(v253, (os_log_type_t)type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                          _os_log_impl(&dword_181A5C000, v253, v254, "%{public}s called with null protocol", buf, 0xCu);
                        }

LABEL_517:
                        goto LABEL_529;
                      }

                      if (!(_BYTE)v279)
                      {
                        __nwlog_obj();
                        v253 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v258 = type[0];
                        if (os_log_type_enabled(v253, (os_log_type_t)type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                          _os_log_impl( &dword_181A5C000,  v253,  v258,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
                        }

                        goto LABEL_517;
                      }

                      v255 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      v256 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v271 = type[0];
                      BOOL v257 = os_log_type_enabled(v256, (os_log_type_t)type[0]);
                      if (v255)
                      {
                        if (v257)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v255;
                          _os_log_impl( &dword_181A5C000,  v256,  v271,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v255);
                      }

                      else
                      {
                        if (v257)
                        {
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                          _os_log_impl( &dword_181A5C000,  v256,  v271,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
                        }
                      }
                    }

LABEL_529:
                    if (v252) {
                      free(v252);
                    }
                    __nwlog_obj();
                    v259 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                    v260 = (char *)_os_log_send_and_compose_impl();

                    type[0] = 16;
                    LOBYTE(v279) = 0;
                    if (__nwlog_fault(v260, type, &v279))
                    {
                      if (type[0] == 17)
                      {
                        __nwlog_obj();
                        v261 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v262 = type[0];
                        if (os_log_type_enabled(v261, (os_log_type_t)type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                          _os_log_impl(&dword_181A5C000, v261, v262, "%{public}s called with null protocol", buf, 0xCu);
                        }

  __break(1u);
  return result;
}

LABEL_535:
                        goto LABEL_547;
                      }

                      if (!(_BYTE)v279)
                      {
                        __nwlog_obj();
                        v261 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v266 = type[0];
                        if (os_log_type_enabled(v261, (os_log_type_t)type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                          _os_log_impl( &dword_181A5C000,  v261,  v266,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
                        }

                        goto LABEL_535;
                      }

                      v263 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      v264 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v272 = type[0];
                      BOOL v265 = os_log_type_enabled(v264, (os_log_type_t)type[0]);
                      if (v263)
                      {
                        if (v265)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v263;
                          _os_log_impl( &dword_181A5C000,  v264,  v272,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v263);
                      }

                      else
                      {
                        if (v265)
                        {
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                          _os_log_impl( &dword_181A5C000,  v264,  v272,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
                        }
                      }
                    }

                        __break(1u);
                        return;
                      }

                      free((void *)v176);
                      os_log_type_t v186 = (os_log_s *)__nwlog_obj();
                      if (!os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_366;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                      v187 = "%{public}s Binary message is empty";
                    }

                    else
                    {
                      os_log_type_t v186 = (os_log_s *)__nwlog_obj();
                      if (!os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_366;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                      v187 = "%{public}s Failed to decrypt oblivious response";
                    }

        if (v315) {
          free(v315);
        }
        *(_DWORD *)(v580 + 352) = -1;
        id v5 = v579;
        goto LABEL_538;
      }

      if ((*(_BYTE *)(v3 + 158) & 1) == 0)
      {
        if (*((_BYTE *)v4 + 1537))
        {
          v522 = v4;
          v523 = (os_log_s *)__nwlog_obj();
          v524 = os_log_type_enabled(v523, OS_LOG_TYPE_DEBUG);
          uint64_t v4 = v522;
          BOOL v3 = v580;
          if (v524)
          {
            v525 = *(_DWORD *)(v580 + 372);
            v526 = *(_DWORD *)(v5 + 424);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v580 + 74;
            *(_WORD *)&_BYTE buf[22] = 2080;
            v608 = (uint64_t)" ";
            *(_WORD *)v609 = 1024;
            *(_DWORD *)&v609[2] = v525;
            *(_WORD *)&v609[6] = 1024;
            *(_DWORD *)&v609[8] = v526;
            *(_WORD *)&v609[12] = 2048;
            *(void *)&v609[14] = v5;
            _os_log_impl( &dword_181A5C000,  v523,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream %u (%p)",  buf,  0x36u);
            uint64_t v4 = v522;
            BOOL v3 = v580;
          }
        }
      }

      if ((*(_WORD *)(v5 + 428) & 0x1000) == 0)
      {
        os_log_type_t v31 = v4;
        __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = v5;
        __int16 v32 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(aBlock) = 0;
        if (__nwlog_fault(v32, type, &aBlock))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __int16 v33 = (os_log_s *)__nwlog_obj();
            os_log_type_t v34 = type[0];
            if (os_log_type_enabled(v33, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v5;
              uint64_t v35 = "%{public}s stream %p not in pending list, cannot remove";
LABEL_360:
              _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0x16u);
            }
          }

          else if ((_BYTE)aBlock)
          {
            uint64_t v177 = (char *)__nw_create_backtrace_string();
            __int16 v33 = (os_log_s *)__nwlog_obj();
            os_log_type_t v34 = type[0];
            uint64_t v178 = os_log_type_enabled(v33, type[0]);
            if (v177)
            {
              if (v178)
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v5;
                *(_WORD *)&_BYTE buf[22] = 2082;
                v608 = (uint64_t)v177;
                _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v177);
              goto LABEL_361;
            }

            if (v178)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v5;
              uint64_t v35 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
              goto LABEL_360;
            }
          }

          else
          {
            __int16 v33 = (os_log_s *)__nwlog_obj();
            os_log_type_t v34 = type[0];
            if (os_log_type_enabled(v33, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v5;
              uint64_t v35 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
              goto LABEL_360;
            }
          }
        }

LABEL_566:
                    if (v241) {
                      free(v241);
                    }
                    uint64_t v217 = 0LL;
                    goto LABEL_455;
                  }

                  if (v182)
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                    _os_log_impl( &dword_181A5C000,  v167,  v181,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  os_log_type_t v167 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v184 = type[0];
                  if (os_log_type_enabled(v167, (os_log_type_t)type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                    _os_log_impl( &dword_181A5C000,  v167,  v184,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
                  }
                }

                goto LABEL_385;
              }

              os_log_type_t v71 = v19;
              os_log_type_t v72 = (nw_protocol *)*(id *)(v71[13] + 136LL);

              if (!nw_context_shares_workloop(*((void **)v7 + 15), v72))
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v73 = (id)gLogObj;
                uint64_t v74 = *((void *)v7 + 15);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = a2;
                __int16 v281 = 2112;
                v282 = v72;
                __int16 v283 = 2112;
                *(void *)v284 = v74;
                os_log_type_t v75 = (char *)_os_log_send_and_compose_impl();

                type[0] = 16;
                LOBYTE(v279) = 0;
                if (__nwlog_fault(v75, type, &v279))
                {
                  if (type[0] == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    uint64_t v76 = (os_log_s *)(id)gLogObj;
                    os_log_type_t v77 = type[0];
                    if (os_log_type_enabled(v76, (os_log_type_t)type[0]))
                    {
                      uint64_t v78 = *((void *)v7 + 15);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
                      *(_WORD *)&_BYTE buf[12] = 2048;
                      *(void *)&buf[14] = a2;
                      __int16 v281 = 2112;
                      v282 = v72;
                      __int16 v283 = 2112;
                      *(void *)v284 = v78;
                      _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s Incoming stream %p has different workloop on context %@ than original one from protoc ol create, which had workloop %@",  buf,  0x2Au);
                    }
                  }

                  else if ((_BYTE)v279)
                  {
                    os_log_type_t v79 = __nw_create_backtrace_string();
                    if (v79)
                    {
                      os_log_type_t v80 = (char *)v79;
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v81 = (os_log_s *)(id)gLogObj;
                      os_log_type_t v82 = type[0];
                      if (os_log_type_enabled(v81, (os_log_type_t)type[0]))
                      {
                        uint64_t v83 = *((void *)v7 + 15);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
                        *(_WORD *)&_BYTE buf[12] = 2048;
                        *(void *)&buf[14] = a2;
                        __int16 v281 = 2112;
                        v282 = v72;
                        __int16 v283 = 2112;
                        *(void *)v284 = v83;
                        *(_WORD *)&v284[8] = 2082;
                        *(void *)&v284[10] = v80;
                        _os_log_impl( &dword_181A5C000,  v81,  v82,  "%{public}s Incoming stream %p has different workloop on context %@ than original one from prot ocol create, which had workloop %@, dumping backtrace:%{public}s",  buf,  0x34u);
                      }

                      free(v80);
                      if (!v75) {
                        goto LABEL_158;
                      }
                      goto LABEL_157;
                    }

                    __nwlog_obj();
                    uint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v86 = type[0];
                    if (os_log_type_enabled(v76, (os_log_type_t)type[0]))
                    {
                      uint64_t v87 = *((void *)v7 + 15);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
                      *(_WORD *)&_BYTE buf[12] = 2048;
                      *(void *)&buf[14] = a2;
                      __int16 v281 = 2112;
                      v282 = v72;
                      __int16 v283 = 2112;
                      *(void *)v284 = v87;
                      _os_log_impl( &dword_181A5C000,  v76,  v86,  "%{public}s Incoming stream %p has different workloop on context %@ than original one from protoc ol create, which had workloop %@, no backtrace",  buf,  0x2Au);
                    }
                  }

                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    uint64_t v76 = (os_log_s *)(id)gLogObj;
                    os_log_type_t v84 = type[0];
                    if (os_log_type_enabled(v76, (os_log_type_t)type[0]))
                    {
                      uint64_t v85 = *((void *)v7 + 15);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
                      *(_WORD *)&_BYTE buf[12] = 2048;
                      *(void *)&buf[14] = a2;
                      __int16 v281 = 2112;
                      v282 = v72;
                      __int16 v283 = 2112;
                      *(void *)v284 = v85;
                      _os_log_impl( &dword_181A5C000,  v76,  v84,  "%{public}s Incoming stream %p has different workloop on context %@ than original one from protoc ol create, which had workloop %@, backtrace limit exceeded",  buf,  0x2Au);
                    }
                  }
                }

                if (v75) {
LABEL_157:
                }
                  free(v75);
              }

void sub_181E650B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v155 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v8 = p_output_handler;
    id v9 = v8;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v10 = *((void *)v8 + 1);
      if (v10)
      {
        if (*(void *)(v10 + 80))
        {
          if (a2)
          {
            if (a3)
            {
              if (*(_DWORD *)(v10 + 64) == 3)
              {
                if ((v8[405] & 0x80000000) == 0 && gLogDatapath)
                {
                  __nwlog_obj();
                  uint64_t v127 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                    __int16 v148 = 2082;
                    BOOL v149 = v9 + 407;
                    __int16 v150 = 2080;
                    uint64_t v151 = " ";
                    __int16 v152 = 2048;
                    *(void *)unsigned int v153 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v9, (uint64_t)a2);
                    *(_WORD *)&v153[8] = 2048;
                    *(void *)&v153[10] = a3;
                    _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReplacing input handler for flow %llx to %p",  buf,  0x34u);
                  }
                }

                output_handler_context = a2->output_handler_context;
                if (!output_handler_context)
                {
                  if ((v9[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    os_log_type_t v41 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      BOOL v149 = v9 + 407;
                      __int16 v150 = 2080;
                      uint64_t v151 = " ";
                      __int16 v152 = 2048;
                      *(void *)unsigned int v153 = a2;
                      _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p",  buf,  0x2Au);
                    }
                  }

                  goto LABEL_157;
                }

                a2->output_handler_context = 0LL;
                char v145 = 0;
                BOOL v12 = nw_hash_table_add_object(*((void *)v9 + 29), (uint64_t)a3, &v145);
                if (v145)
                {
                  os_log_type_t v13 = (void *)v12;
                  if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
                  {
                    __nwlog_obj();
                    char v131 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v132 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v9, (uint64_t)a3);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                      __int16 v148 = 2082;
                      BOOL v149 = v9 + 407;
                      __int16 v150 = 2080;
                      uint64_t v151 = " ";
                      __int16 v152 = 2048;
                      *(void *)unsigned int v153 = a3;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = v132;
                      _os_log_impl( &dword_181A5C000,  v131,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sMultiplexing protocol added protocol %p to hash table for flow %llx",  buf,  0x34u);
                    }
                  }

                  a3->output_handler_context = v13;
                  uint64_t extra = nw_hash_node_get_extra((uint64_t)v13);
                  uint64_t v15 = extra;
                  if (extra)
                  {
                    *(void *)(extra + 16) = 0LL;
                    *(void *)(extra + 24) = extra + 16;
                    BOOL v16 = (char *)(output_handler_context + 6);
                    uint64_t v17 = output_handler_context[6];
                    if (v17)
                    {
                      *(void *)(extra + 16) = v17;
                      *(void *)(output_handler_context[6] + 40LL) = extra + 16;
                      *(void *)(extra + 24) = output_handler_context[7];
                      output_handler_context[6] = 0LL;
                      output_handler_context[7] = v16;
                    }

                    os_log_type_t v18 = (void *)output_handler_context[5];
                    output_handler_context[6] = 0LL;
                    output_handler_context[7] = v16;
                    *(void *)uint64_t extra = output_handler_context[4];
                    objc_storeStrong((id *)(extra + 8), v18);
                    id v19 = (void *)output_handler_context[5];
                    output_handler_context[5] = 0LL;

                    *(_OWORD *)(v15 + 32) = *((_OWORD *)output_handler_context + 4);
                    int v20 = *(_WORD *)(v15 + 52) & 0xFFFE | *((_WORD *)output_handler_context + 42) & 1;
                    *(_WORD *)(v15 + 52) = *(_WORD *)(v15 + 52) & 0xFFFE | *((_WORD *)output_handler_context + 42) & 1;
                    unsigned int v21 = v20 & 0xFFFFFFFD | (2 * ((*((unsigned __int16 *)output_handler_context + 42) >> 1) & 1));
                    *(_WORD *)(v15 + 52) = v21;
                    unsigned int v22 = v21 & 0xFFFFFFFB | (4 * ((*((unsigned __int16 *)output_handler_context + 42) >> 2) & 1));
                    *(_WORD *)(v15 + 52) = v22;
                    unsigned int v23 = v22 & 0xFFFFFFF7 | (8 * ((*((unsigned __int16 *)output_handler_context + 42) >> 3) & 1));
                    *(_WORD *)(v15 + 52) = v23;
                    unsigned int v24 = v23 & 0xFFFFFFEF | (16 * ((*((unsigned __int16 *)output_handler_context + 42) >> 4) & 1));
                    *(_WORD *)(v15 + 52) = v24;
                    unsigned int v25 = v24 & 0xFFFFFFDF | (32 * ((*((unsigned __int16 *)output_handler_context + 42) >> 5) & 1));
                    *(_WORD *)(v15 + 52) = v25;
                    unsigned int v26 = v25 & 0xFFFFFF7F | (((*((unsigned __int16 *)output_handler_context + 42) >> 7) & 1) << 7);
                    *(_WORD *)(v15 + 52) = v26;
                    unsigned int v27 = v26 & 0xFFFFFEFF | ((HIBYTE(*((unsigned __int16 *)output_handler_context + 42)) & 1) << 8);
                    *(_WORD *)(v15 + 52) = v27;
                    unsigned int v28 = v27 & 0xFFFFFDFF | (((*((unsigned __int16 *)output_handler_context + 42) >> 9) & 1) << 9);
                    *(_WORD *)(v15 + 52) = v28;
                    unsigned int v29 = v28 & 0xFFFFFBFF | (((*((unsigned __int16 *)output_handler_context + 42) >> 10) & 1) << 10);
                    *(_WORD *)(v15 + 52) = v29;
                    *(_WORD *)(v15 + 52) = v29 & 0xF7FF | *((_WORD *)output_handler_context + 42) & 0x800;
                    goto LABEL_20;
                  }

                  __nwlog_obj();
                  int v128 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                  v143 = (char *)_os_log_send_and_compose_impl();

                  LOBYTE(v154) = 16;
                  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                  if (__nwlog_fault(v143, &v154, &type))
                  {
                    if (v154 == 17)
                    {
                      __nwlog_obj();
                      id v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v130 = v154;
                      if (os_log_type_enabled(v129, (os_log_type_t)v154))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                        _os_log_impl(&dword_181A5C000, v129, v130, "%{public}s called with null dst", buf, 0xCu);
                      }
                    }

                    else if (type)
                    {
                      backtrace_string = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      id v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v142 = v154;
                      BOOL v140 = os_log_type_enabled(v129, (os_log_type_t)v154);
                      if (backtrace_string)
                      {
                        if (v140)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                          __int16 v148 = 2082;
                          BOOL v149 = backtrace_string;
                          _os_log_impl( &dword_181A5C000,  v129,  v142,  "%{public}s called with null dst, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(backtrace_string);
                        goto LABEL_281;
                      }

                      if (v140)
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                        _os_log_impl( &dword_181A5C000,  v129,  v142,  "%{public}s called with null dst, no backtrace",  buf,  0xCu);
                      }
                    }

                    else
                    {
                      __nwlog_obj();
                      id v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v141 = v154;
                      if (os_log_type_enabled(v129, (os_log_type_t)v154))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_flow_state_move";
                        _os_log_impl( &dword_181A5C000,  v129,  v141,  "%{public}s called with null dst, backtrace limit exceeded",  buf,  0xCu);
                      }
                    }
                  }

LABEL_281:
                  if (v143) {
                    free(v143);
                  }
LABEL_20:
                  if (!a3->output_handler)
                  {
                    a3->output_handler = a1;
                    if (a1->handle == &nw_protocol_ref_counted_handle)
                    {
                      callbacks = a1[1].callbacks;
                      if (callbacks) {
                        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                      }
                    }
                  }

                  os_log_type_t v31 = a3->callbacks;
                  if (v31)
                  {
                    supports_external_data = (uint64_t (*)(nw_protocol *))v31->supports_external_data;
                    if (supports_external_data)
                    {
                      __int16 v33 = a3->handle;
                      if (v33 == &nw_protocol_ref_counted_handle)
                      {
                        os_log_type_t v62 = a3[1].callbacks;
                        if (v62) {
                          a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v62->add_input_handler + 1);
                        }
                        char v34 = -1;
                      }

                      else
                      {
                        char v34 = 0;
                      }

                      *(void *)buf = a3;
                      buf[8] = v34;
                      int v63 = supports_external_data(a3);
                      int v64 = v63;
                      if (v33 == &nw_protocol_ref_counted_handle)
                      {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                        if (v64) {
                          goto LABEL_78;
                        }
                      }

                      else if (v63)
                      {
LABEL_78:
                        __int16 v65 = *(_WORD *)(v15 + 52) | 0x400;
                        goto LABEL_81;
                      }
                    }
                  }

                  __int16 v65 = *(_WORD *)(v15 + 52) & 0xFBFF;
LABEL_81:
                  *(_WORD *)(v15 + 52) = v65;
                  if (a1->default_input_handler == a2)
                  {
                    if (a2 != a3)
                    {
                      if (a2->handle == &nw_protocol_ref_counted_handle)
                      {
                        os_log_type_t v92 = a2[1].callbacks;
                        if (v92)
                        {
                          os_log_type_t v93 = (nw_protocol_callbacks *)((char *)v92 - 1);
                          a2[1].callbacks = v93;
                          if (!v93)
                          {
                            unint64_t v94 = *(void (***)(void))a2[1].flow_id;
                            if (v94)
                            {
                              *(void *)a2[1].flow_id = 0LL;
                              v94[2](v94);
                              _Block_release(v94);
                            }

                            if ((a2[1].flow_id[8] & 1) != 0)
                            {
                              uint64_t v95 = *(const void **)a2[1].flow_id;
                              if (v95) {
                                _Block_release(v95);
                              }
                            }

                            free(a2);
                          }
                        }
                      }

                      a1->default_input_handler = a3;
                      if (a3->handle == &nw_protocol_ref_counted_handle)
                      {
                        os_log_type_t v66 = a3[1].callbacks;
                        if (v66) {
                          a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v66->add_input_handler + 1);
                        }
                      }
                    }

                    *(_OWORD *)a1->flow_id = *(_OWORD *)a3->flow_id;
                    uint64_t v67 = nw_protocol_instance_copy_path(v9, -1LL);
                    os_log_type_t v68 = (void *)*((void *)v9 + 36);
                    *((void *)v9 + 36) = v67;
                  }

                  if (nw_hash_table_remove_node(*((void *)v9 + 29), (uint64_t)output_handler_context))
                  {
                    uint64_t v69 = *((void *)v9 + 1);
                    os_log_type_t v70 = *(void (**)(uint64_t, void))(*(void *)(v69 + 80) + 32LL);
                    if (v70 && *(void *)v15)
                    {
                      v70(v69, *(void *)v15);
                    }

                    else
                    {
                      uint64_t v75 = 1LL;
                      if (v9[405] < 0 || !gLogDatapath) {
                        goto LABEL_158;
                      }
                      __nwlog_obj();
                      uint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                        __int16 v148 = 2082;
                        BOOL v149 = v9 + 407;
                        __int16 v150 = 2080;
                        uint64_t v151 = " ";
                        _os_log_impl( &dword_181A5C000,  v76,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNot calling instance replace flow state",  buf,  0x20u);
                      }
                    }

                    goto LABEL_126;
                  }

                  if ((v9[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v71 = (id)gLogObj;
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                    __int16 v148 = 2082;
                    BOOL v149 = v9 + 407;
                    __int16 v150 = 2080;
                    uint64_t v151 = " ";
                    __int16 v152 = 2048;
                    *(void *)unsigned int v153 = a2;
                    os_log_type_t v72 = (const char *)_os_log_send_and_compose_impl();

                    LOBYTE(v154) = 16;
                    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                    if (__nwlog_fault(v72, &v154, &type))
                    {
                      if (v154 == 17)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        id v73 = (os_log_s *)(id)gLogObj;
                        os_log_type_t v74 = v154;
                        if (os_log_type_enabled(v73, (os_log_type_t)v154))
                        {
                          *(_DWORD *)buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                          __int16 v148 = 2082;
                          BOOL v149 = v9 + 407;
                          __int16 v150 = 2080;
                          uint64_t v151 = " ";
                          __int16 v152 = 2048;
                          *(void *)unsigned int v153 = a2;
                          _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table",  buf,  0x2Au);
                        }
                      }

                      else if (type)
                      {
                        os_log_type_t v77 = (char *)__nw_create_backtrace_string();
                        __nwlog_obj();
                        id v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v78 = v154;
                        BOOL v79 = os_log_type_enabled(v73, (os_log_type_t)v154);
                        if (v77)
                        {
                          if (v79)
                          {
                            *(_DWORD *)buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                            __int16 v148 = 2082;
                            BOOL v149 = v9 + 407;
                            __int16 v150 = 2080;
                            uint64_t v151 = " ";
                            __int16 v152 = 2048;
                            *(void *)unsigned int v153 = a2;
                            *(_WORD *)&v153[8] = 2082;
                            *(void *)&v153[10] = v77;
                            _os_log_impl( &dword_181A5C000,  v73,  v78,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, dumping backtrace:%{public}s",  buf,  0x34u);
                          }

                          free(v77);
                          if (!v72) {
                            goto LABEL_157;
                          }
                          goto LABEL_155;
                        }

                        if (v79)
                        {
                          *(_DWORD *)buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                          __int16 v148 = 2082;
                          BOOL v149 = v9 + 407;
                          __int16 v150 = 2080;
                          uint64_t v151 = " ";
                          __int16 v152 = 2048;
                          *(void *)unsigned int v153 = a2;
                          _os_log_impl( &dword_181A5C000,  v73,  v78,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, no backtrace",  buf,  0x2Au);
                        }
                      }

                      else
                      {
                        __nwlog_obj();
                        id v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v91 = v154;
                        if (os_log_type_enabled(v73, (os_log_type_t)v154))
                        {
                          *(_DWORD *)buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_replace_input_handler";
                          __int16 v148 = 2082;
                          BOOL v149 = v9 + 407;
                          __int16 v150 = 2080;
                          uint64_t v151 = " ";
                          __int16 v152 = 2048;
                          *(void *)unsigned int v153 = a2;
                          _os_log_impl( &dword_181A5C000,  v73,  v91,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, backtrace limit exceeded",  buf,  0x2Au);
                        }
                      }
                    }

                    if (v72)
                    {
LABEL_155:
                      id v89 = (char *)v72;
                      goto LABEL_156;
                    }
                  }
            }
          }

          else
          {
            if (v12 != (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_18956)
            {
              os_log_type_t v13 = nw_parameters_create();
              if (v13)
              {
                os_log_type_t v14 = (void *)nw_protocol_boringssl_copy_definition();
                options = nw_protocol_create_options(v14);

                if (options)
                {
                  BOOL v16 = options;
                  v143 = v16;
                  if (v9 != &__block_literal_global_93) {
                    (*((void (**)(id, NWConcrete_nw_protocol_options *))v9 + 2))(v9, v16);
                  }
                  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
                    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
                  }
                  uint64_t v17 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
                  if (v17)
                  {
                    os_log_type_t v18 = (id *)*((id *)v13 + 19);
                    BOOL v140 = v18;
                    if (v18)
                    {
                      objc_storeStrong(v18 + 3, v17);
                      os_log_type_t v142 = nw_quic_stream_copy_shared_connection_options(v17);
                      nw_quic_connection_set_sec_protocol_options(v142, v143);
                      id v19 = nw_protocol_create_options((void *)g_tcp_definition);
                      os_log_type_t v141 = v19;
                      if (v19)
                      {
                        int v20 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_transform);
                        if (v20)
                        {
                          unsigned int v21 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_transform);
                          unsigned int v22 = v21;
                          if (v21)
                          {
                            if (v145)
                            {
                              unsigned int v23 = v21;
                              unsigned int v24 = v145;
                              objc_storeStrong(v23 + 4, a4);
                            }

                            unsigned int v25 = v20;
                            *((_BYTE *)v25 + 8) |= 2u;

                            nw_protocol_transform_append_protocol(v25, 3, v17);
                            unsigned int v26 = v25;
                            v26->fallback_mode = 2;

                            unsigned int v27 = v26;
                            *((_BYTE *)v25 + 8) |= 0x10u;

                            unsigned int v28 = v22;
                            *((_BYTE *)v28 + 8) |= 2u;

                            unsigned int v29 = nw_protocol_options_copy(v143);
                            nw_protocol_transform_append_protocol(v28, 4, v29);

                            nw_protocol_transform_append_protocol(v28, 3, v141);
                            __int16 v30 = v28;
                            *((_BYTE *)v28 + 8) |= 0x10u;

                            os_log_type_t v31 = nw_array_create();
                            __int16 v32 = (void *)*((void *)v13 + 20);
                            *((void *)v13 + 20) = v31;

                            nw_array_append(*((void *)v13 + 20), v27);
                            nw_array_append(*((void *)v13 + 20), v30);
                            *((_BYTE *)v13 + 92) = 2;
                            __int16 v33 = v13;
LABEL_149:

                            goto LABEL_150;
                          }

                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          os_log_type_t v72 = (id)gLogObj;
                          *(_DWORD *)buf = 136446210;
                          __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                          id v73 = (char *)_os_log_send_and_compose_impl();

                          os_log_type_t type = OS_LOG_TYPE_ERROR;
                          v147 = 0;
                          if (__nwlog_fault(v73, &type, &v147))
                          {
                            if (type == OS_LOG_TYPE_FAULT)
                            {
                              __nwlog_obj();
                              os_log_type_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              uint64_t v75 = type;
                              if (os_log_type_enabled(v74, type))
                              {
                                *(_DWORD *)buf = 136446210;
                                __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                                _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s nw_protocol_transform_create failed",  buf,  0xCu);
                              }
                            }

                            else
                            {
                              if (v147)
                              {
                                os_log_type_t v81 = (char *)__nw_create_backtrace_string();
                                __nwlog_obj();
                                os_log_type_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                uint64_t v83 = type;
                                log = v82;
                                os_log_type_t v84 = os_log_type_enabled(v82, type);
                                if (v81)
                                {
                                  if (v84)
                                  {
                                    *(_DWORD *)buf = 136446466;
                                    __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                                    uint64_t v151 = 2082;
                                    __int16 v152 = v81;
                                    _os_log_impl( &dword_181A5C000,  log,  v83,  "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
                                  }

                                  free(v81);
                                }

                                else
                                {
                                  if (v84)
                                  {
                                    *(_DWORD *)buf = 136446210;
                                    __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                                    _os_log_impl( &dword_181A5C000,  log,  v83,  "%{public}s nw_protocol_transform_create failed, no backtrace",  buf,  0xCu);
                                  }
                                }

                                goto LABEL_146;
                              }

                              __nwlog_obj();
                              os_log_type_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              __int16 v88 = type;
                              if (os_log_type_enabled(v74, type))
                              {
                                *(_DWORD *)buf = 136446210;
                                __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                                _os_log_impl( &dword_181A5C000,  v74,  v88,  "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded",  buf,  0xCu);
                              }
                            }
                          }

                      v514 = nw_parameters_copy((nw_parameters_t)v150[2]);
                      v512 = nw_parameters_copy_protocol_options_for_definition(v514, v169);
                      sec_protocol_options_set_enable_encrypted_client_hello((sec_protocol_options_t)v512, 1);
                      *(void *)v537 = 0LL;
                      *(void *)&v537[8] = v537;
                      *(void *)&v537[16] = 0x2020000000LL;
                      v537[24] = 0;
                      os_log_type_t v184 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v150[2]);
                      nw_parameters_clear_protocol_stack(v514, 5);
                      nw_parameters_clear_protocol_stack(v514, 4);
                      os_log_type_t v185 = nw_parameters_copy_default_protocol_stack(v514);
                      *(void *)buf = MEMORY[0x1895F87A8];
                      *(void *)&buf[8] = 3221225472LL;
                      *(void *)&buf[16] = ___ZL46nw_connection_run_ech_probe_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke;
                      *(void *)&_BYTE buf[24] = &unk_189BB9A48;
                      *(void *)&v524[16] = v537;
                      os_log_type_t v186 = v185;
                      *(void *)v524 = v186;
                      v518 = v512;
                      *(void *)&v524[8] = v518;
                      v513 = v184;
                      nw_protocol_stack_iterate_application_protocols(v184, buf);
                      v515 = v186;
                      probe_locked = nw_connection_create_probe_locked(v520, v514);
                      if (probe_locked)
                      {
                        os_log_type_t v188 = nw_queue_copy_current_workloop();
                        nw_connection_set_queue(probe_locked, (dispatch_queue_t)v188);

                        nw_connection_add_probe_locked(v520, (NWConcrete_nw_connection *)probe_locked);
                        id v189 = v150[3];
                        *(void *)aBlock = MEMORY[0x1895F87A8];
                        *(void *)&aBlock[8] = 3221225472LL;
                        *(void *)&aBlock[16] = ___ZL46nw_connection_run_ech_probe_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke_224;
                        v541 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BC93A0;
                        os_log_type_t v190 = probe_locked;
                        v542 = (void (*)(uint64_t))v190;
                        nw_queue_context_async(v189, aBlock);
                        BOOL v191 = v150[2];
                        if (v191 && !nw_path_parameters_get_logging_disabled(v191[13]))
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          os_log_type_t v192 = (os_log_s *)(id)gconnectionLogObj;
                          if (os_log_type_enabled(v192, OS_LOG_TYPE_INFO))
                          {
                            v193 = v520->top_id;
                            *(_DWORD *)v544 = 136446722;
                            v545 = "nw_connection_run_ech_probe_locked_on_nw_queue";
                            v546 = 1024;
                            v547 = v193;
                            v548 = 2112;
                            v549 = v190;
                            _os_log_impl( &dword_181A5C000,  v192,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Started ECH probe: %@",  v544,  0x1Cu);
                          }
                        }

                        v194 = (os_log_s *)v542;
                      }

                      else
                      {
                        v352 = v150[2];
                        if (!v352 || nw_path_parameters_get_logging_disabled(v352[13])) {
                          goto LABEL_571;
                        }
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        v194 = (os_log_s *)(id)gconnectionLogObj;
                        if (os_log_type_enabled(v194, OS_LOG_TYPE_INFO))
                        {
                          v353 = v520->top_id;
                          *(_DWORD *)aBlock = 136446466;
                          *(void *)&void aBlock[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                          *(_WORD *)&aBlock[12] = 1024;
                          *(_DWORD *)&aBlock[14] = v353;
                          _os_log_impl( &dword_181A5C000,  v194,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Could not create probe, nw_connection_create_probe_locked returned nil connection",  aBlock,  0x12u);
                        }
                      }

LABEL_571:
                      _Block_object_dispose(v537, 8);

                      goto LABEL_309;
                    }

          LOBYTE(v185) = v184;
          os_log_type_t v188 = v296;
          if (v183 >= v298) {
            goto LABEL_317;
          }
LABEL_282:
          unsigned int v153 = v188 + 2;
          const char *v183 = v185;
          if (v188 + 2 <= v296) {
            goto LABEL_317;
          }
        }

        else
        {
          BOOL v161 = v82 | 0xC0;
LABEL_235:
          *v296 = v161;
          unsigned int v153 = v296 + 1;
        }

        __int128 v154 = v298 - v153;
        v156 = v153;
        v157 = (unsigned __int8 *)v307;
        uint64_t v155 = v145;
LABEL_237:
        id v162 = lsqpack_enc_enc_str(7, v156, v154, v157, v155);
        os_log_type_t v82 = v303;
        if (v162 < 0) {
          goto LABEL_317;
        }
        BOOL v79 = &v153[v162] - v296;
        break;
      case 3LL:
        if (v297 < 1) {
          goto LABEL_317;
        }
        *v296 = 0x80;
        os_log_type_t v160 = *(_DWORD *)v68 - v82;
        if (v160 <= 0x3E)
        {
          BOOL v161 = (*(_BYTE *)v68 - v82) | 0x80;
          goto LABEL_235;
        }

        *v296 = -65;
        os_log_type_t v183 = v296 + 1;
        os_log_type_t v184 = v160 - 63;
        do
        {
          if (v183 >= v298) {
            goto LABEL_317;
          }
          *v183++ = v184 | 0x80;
          os_log_type_t v185 = v184 >> 7;
          os_log_type_t v186 = v184 >> 14;
          v184 >>= 7;
        }

        while (v186);
LABEL_279:
        os_log_type_t v188 = v183 - 1;
        if (v183 >= v298) {
          goto LABEL_317;
        }
        goto LABEL_282;
      case 4LL:
      case 5LL:
        if (v297 < 1) {
          goto LABEL_317;
        }
        *v296 = 64;
        __int16 v150 = v79;
        uint64_t v151 = lsqpack_enc_enc_str(5, v296, v297, (unsigned __int8 *)v313, v63);
        if (v151 < 0) {
          goto LABEL_317;
        }
        __int16 v152 = v150;
        unsigned int v153 = &v296[v151];
        __int128 v154 = v298 - v153;
        if (v152 == 4) {
          uint64_t v155 = v145;
        }
        else {
          uint64_t v155 = 0LL;
        }
        v156 = &v296[v151];
        v157 = (unsigned __int8 *)v307;
        goto LABEL_237;
      default:
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1989, "EEA_NONE == prog.ep_enc_action");
    }

    break;
  }

  __int128 v279 = v79;
  switch(v146)
  {
    case 0uLL:
      os_log_type_t v82 = *(_DWORD *)v68 + 1;
      os_log_type_t v163 = v312;
      os_log_type_t v164 = v293;
      goto LABEL_244;
    case 1uLL:
      os_log_type_t v164 = v293;
      *v293 = -64;
      if (v292 <= 0) {
        goto LABEL_440;
      }
      if (v82 <= 0x3E)
      {
        *v293 = v82 | 0xC0;
        os_log_type_t v172 = v293 + 1;
        os_log_type_t v163 = v312;
        goto LABEL_338;
      }

      *v293 = -1;
      id v189 = v293 + 1;
      os_log_type_t v190 = v82 - 63LL;
      os_log_type_t v163 = v312;
      os_log_type_t v165 = v291;
      if (v190 < 0x80) {
        goto LABEL_351;
      }
      while ((unint64_t)v189 < v291)
      {
        *v189++ = v190 | 0x80;
        BOOL v191 = v190 >> 7;
        uint64_t v203 = v190 >> 14;
        v190 >>= 7;
        if (!v203) {
          goto LABEL_349;
        }
      }

      goto LABEL_32;
    case 2uLL:
      os_log_type_t v164 = v293;
      if (v82 > *(_DWORD *)(v68 + 156))
      {
        os_log_type_t v163 = v312;
LABEL_244:
        os_log_type_t v165 = v291;
        *os_log_type_t v164 = 16;
        os_log_type_t v166 = *(_DWORD *)(v68 + 156);
        if (v82 <= v166) {
          __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2008, "id > enc->qpe_cur_header.base_idx");
        }
        if (v292 <= 0) {
LABEL_440:
        }
          __assert_rtn("lsqpack_enc_int", "lsqpack.c", 759, "dst < end");
        os_log_type_t v167 = v82 + ~v166;
        if (v167 <= 0xE)
        {
          os_log_type_t v168 = (v82 + ~(_BYTE)v166) | 0x10;
LABEL_306:
          *os_log_type_t v164 = v168;
          os_log_type_t v172 = v164 + 1;
          goto LABEL_338;
        }

        *os_log_type_t v164 = 31;
        id v189 = v164 + 1;
        os_log_type_t v190 = v167 - 15;
        if ((unint64_t)(v167 - 15) >= 0x80)
        {
          while ((unint64_t)v189 < v291)
          {
            *v189++ = v190 | 0x80;
            BOOL v191 = v190 >> 7;
            os_log_type_t v192 = v190 >> 14;
            v190 >>= 7;
            if (!v192) {
              goto LABEL_349;
            }
          }

          goto LABEL_32;
        }

        goto LABEL_351;
      }

      *v293 = 0x80;
      os_log_type_t v165 = v291;
      os_log_type_t v163 = v312;
      if (v292 <= 0) {
        goto LABEL_440;
      }
      v202 = *(_DWORD *)(v68 + 156) - v82;
      if (v202 <= 0x3E)
      {
        os_log_type_t v168 = (*(_BYTE *)(v68 + 156) - v82) | 0x80;
        goto LABEL_306;
      }

      *v293 = -65;
      id v189 = v293 + 1;
      os_log_type_t v190 = v202 - 63;
      if ((unint64_t)(v202 - 63) < 0x80)
      {
LABEL_351:
        LOBYTE(v191) = v190;
        uint64_t v217 = v164;
        goto LABEL_352;
      }

      do
      {
        *v189++ = v190 | 0x80;
        BOOL v191 = v190 >> 7;
        char v216 = v190 >> 14;
        v190 >>= 7;
      }

      while (v216);
LABEL_349:
      uint64_t v217 = v189 - 1;
LABEL_352:
      os_log_type_t v172 = v217 + 2;
      *id v189 = v191;
      if (v217 + 2 <= v164) {
        goto LABEL_32;
      }
LABEL_338:
      if ((unint64_t)(v295 - 1) > 1)
      {
        if (v295) {
          __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2117, "prog.ep_tab_action == ETA_NOOP");
        }
        v311 = v172 - v164;
        if ((v294 & 2) != 0) {
          goto LABEL_364;
        }
        goto LABEL_370;
      }

      char v213 = v82;
      int v64 = v301;
      if (v295 == 1) {
        v214 = v301;
      }
      else {
        v214 = 0;
      }
      int v63 = v304;
      int v215 = lsqpack_enc_push_entry(v68, v163, v61, v313, v304, v307, v214);
      if (!v215)
      {
        LODWORD(v26) = 0;
        LODWORD(v295) = v213;
        id v9 = v299;
        uint64_t v69 = v288;
        os_log_type_t v72 = v309;
LABEL_344:
        id v71 = (unint64_t)v310;
        uint64_t v76 = v312;
        if (!v305) {
          goto LABEL_125;
        }
        goto LABEL_73;
      }

      v311 = v172 - v164;
      v218 = *(_DWORD **)(v68 + 128);
      v218[13] += v215[12] + v215[13] + 32;
      if ((v294 & 4) == 0) {
        goto LABEL_363;
      }
      ++v215[9];
      *(_DWORD *)(v68 + 152) |= 2u;
      __int128 v219 = v218[15];
      id v220 = v215[6];
      if (v219)
      {
        if (v220 <= v219) {
          __assert_rtn( "lsqpack_enc_encode",  "lsqpack.c",  2111,  "new_entry->ete_id > enc->qpe_cur_header.hinfo->qhi_max_id");
        }
        v218[15] = v220;
LABEL_363:
        if ((v294 & 2) != 0)
        {
LABEL_364:
          ++*((_DWORD *)v24 + 9);
          char v221 = *(void *)(v68 + 128);
          v222 = *((_DWORD *)v24 + 6);
          uint64_t v223 = *(_DWORD *)(v221 + 60);
          if (!v223)
          {
            *(_DWORD *)(v221 + 60) = v222;
            goto LABEL_369;
          }

          if (v223 < v222)
          {
            *(_DWORD *)(v221 + 60) = v222;
            goto LABEL_370;
          }

          if (*(_DWORD *)(v221 + 56) > v222) {
LABEL_369:
          }
            *(_DWORD *)(v221 + 56) = v222;
        }
      }

      else
      {
        v218[14] = v220;
        v218[15] = v220;
        if ((v294 & 2) != 0) {
          goto LABEL_364;
        }
      }

void sub_181E67150(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v171 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v8 = p_output_handler;
    id v9 = v8;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v10 = *((void *)v8 + 1);
      if (v10)
      {
        if (*(void *)(v10 + 80))
        {
          if (a2)
          {
            if (a2->output_handler == a1)
            {
              if (a1->handle == &nw_protocol_ref_counted_handle)
              {
                callbacks = a1[1].callbacks;
                if (callbacks)
                {
                  os_log_type_t v40 = (nw_protocol_callbacks *)((char *)callbacks - 1);
                  a1[1].callbacks = v40;
                  if (!v40)
                  {
                    os_log_type_t v41 = *(void (***)(void))a1[1].flow_id;
                    if (v41)
                    {
                      *(void *)a1[1].flow_id = 0LL;
                      v41[2](v41);
                      _Block_release(v41);
                    }

                    if ((a1[1].flow_id[8] & 1) != 0)
                    {
                      os_log_type_t v42 = *(const void **)a1[1].flow_id;
                      if (v42) {
                        _Block_release(v42);
                      }
                    }

                    free(a1);
                  }
                }
              }

              a2->output_handler = 0LL;
              uint64_t v10 = *((void *)v9 + 1);
            }

            if (*(_DWORD *)(v10 + 64) == 3)
            {
              output_handler_context = a2->output_handler_context;
              if (output_handler_context)
              {
                if ((v9[405] & 0x80000000) == 0)
                {
                  if (!gLogDatapath) {
                    goto LABEL_15;
                  }
                  __nwlog_obj();
                  os_log_type_t v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v9 + 407;
                    *(_WORD *)&_BYTE buf[22] = 2080;
                    os_log_type_t v166 = " ";
                    *(_WORD *)os_log_type_t v167 = 2048;
                    *(void *)&v167[2] = nw_protocol_flow_for_protocol( (NWConcrete_nw_protocol_instance *)v9,  (uint64_t)a2);
                    _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRemove input handler for flow %llx",  buf,  0x2Au);
                  }
                }

                if (gLogDatapath)
                {
                  __nwlog_obj();
                  os_log_type_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)os_log_type_t v170 = 136446210;
                    *(void *)&v170[4] = "nw_protocol_finalize_temp_frame_array";
                    _os_log_impl(&dword_181A5C000, v82, OS_LOG_TYPE_DEBUG, "%{public}s called", v170, 0xCu);
                  }
                }

LABEL_324:
                goto LABEL_325;
              }

              if (!v161)
              {
                __nwlog_obj();
                os_log_type_t v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v148 = type;
                if (os_log_type_enabled(v137, type))
                {
                  BOOL v149 = output_handler->identifier->name;
                  if (!v149) {
                    BOOL v149 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v149;
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  os_log_type_t v166 = (const char *)output_handler;
                  _os_log_impl( &dword_181A5C000,  v137,  v148,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded",  buf,  0x20u);
                }

                goto LABEL_324;
              }

              os_log_type_t v142 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v154 = type;
              BOOL v143 = os_log_type_enabled(v137, type);
              if (!v142)
              {
                if (v143)
                {
                  __int16 v152 = output_handler->identifier->name;
                  if (!v152) {
                    __int16 v152 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v152;
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  os_log_type_t v166 = (const char *)output_handler;
                  _os_log_impl( &dword_181A5C000,  v137,  v154,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace",  buf,  0x20u);
                }

                goto LABEL_324;
              }

              if (v143)
              {
                char v144 = output_handler->identifier->name;
                if (!v144) {
                  char v144 = "invalid";
                }
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v144;
                *(_WORD *)&_BYTE buf[22] = 2048;
                os_log_type_t v166 = (const char *)output_handler;
                *(_WORD *)os_log_type_t v167 = 2082;
                *(void *)&v167[2] = v142;
                _os_log_impl( &dword_181A5C000,  v137,  v154,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(v142);
            }

    if (v124) {
      free(v124);
    }
    os_log_type_t v69 = 0LL;
    goto LABEL_205;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v22 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v163 = "nw_parameters_create_secure_http_messaging";
  int v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v160 = 0;
  if (__nwlog_fault(v23, &type, &v160))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v24 = (os_log_s *)(id)gLogObj;
      uint64_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }

      nw_frame_finalize((uint64_t)v10);
      goto LABEL_325;
    }

    id v35 = *(unsigned __int16 *)&buf[10];
    *(_WORD *)&buf[10] = 0;
    os_log_type_t v36 = buf;
    if (v34 - 2 >= 0xE)
    {
      os_log_type_t v57 = ((v34 - 2) >> 1) + 1;
      BOOL v58 = (uint16x4_t *)&buf[8];
      os_log_type_t v59 = 0uLL;
      BOOL v60 = v57 & 0xFFFFFFF8;
      os_log_type_t v61 = 0uLL;
      do
      {
        os_log_type_t v59 = (int32x4_t)vaddw_u16((uint32x4_t)v59, v58[-1]);
        os_log_type_t v61 = (int32x4_t)vaddw_u16((uint32x4_t)v61, *v58);
        v58 += 2;
        v60 -= 8LL;
      }

      while (v60);
      os_log_type_t v37 = vaddvq_s32(vaddq_s32(v61, v59));
      if ((v57 & 0xFFFFFFF8) == v57) {
        goto LABEL_85;
      }
      os_log_type_t v36 = &buf[2 * (v57 & 0xFFFFFFF8)];
      os_log_type_t v38 = v34 - 2 * (v57 & 0xFFFFFFF8);
    }

    else
    {
      os_log_type_t v37 = 0;
      os_log_type_t v38 = 4 * (buf[0] & 0xF);
    }

    os_log_type_t v62 = v38 + 2;
    do
    {
      os_log_type_t v63 = *(unsigned __int16 *)v36;
      v36 += 2;
      v37 += v63;
      v62 -= 2;
    }

    while (v62 > 3);
LABEL_85:
    if (v35 != (unsigned __int16)~(HIWORD(v37) + v37 + ((HIWORD(v37) + (unsigned __int16)v37) >> 16)))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int16 v242 = 136446466;
        *(void *)&v242[4] = "ipv4_parse";
        *(_WORD *)&v242[12] = 1024;
        *(_DWORD *)&v242[14] = v35;
        id v19 = "%{public}s Invalid ipv4 header checksum 0x%x";
        goto LABEL_110;
      }

      goto LABEL_324;
    }

    int v64 = bswap32(*(unsigned __int16 *)&buf[2]) >> 16;
    if (*(_DWORD *)address < v64)
    {
      os_log_type_t v42 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_INFO)) {
        goto LABEL_324;
      }
      *(_DWORD *)__int16 v242 = 136446722;
      *(void *)&v242[4] = "ipv4_parse";
      *(_WORD *)&v242[12] = 1024;
      *(_DWORD *)&v242[14] = v64;
      *(_WORD *)&v242[18] = 1024;
      *(_DWORD *)&v242[20] = *(_DWORD *)address;
      os_log_type_t v43 = "%{public}s Received IPv4 packet with incorrect length, expected %u received %u";
      char v44 = v242;
      goto LABEL_46;
    }

    if (*(_DWORD *)address > v64)
    {
      if (gLogDatapath)
      {
        v187 = (os_log_s *)__nwlog_obj();
        os_log_type_t v188 = os_log_type_enabled(v187, OS_LOG_TYPE_DEBUG);
        uint64_t v17 = *(_DWORD *)address;
        if (v188)
        {
          *(_DWORD *)__int16 v242 = 136446722;
          *(void *)&v242[4] = "ipv4_parse";
          *(_WORD *)&v242[12] = 1024;
          *(_DWORD *)&v242[14] = v64;
          *(_WORD *)&v242[18] = 1024;
          *(_DWORD *)&v242[20] = *(_DWORD *)address;
          _os_log_impl( &dword_181A5C000,  v187,  OS_LOG_TYPE_DEBUG,  "%{public}s Received length mismatch with IP total length %u != %u",  v242,  0x18u);
          uint64_t v17 = *(_DWORD *)address;
        }
      }

      nw_frame_claim((uint64_t)v10, v16, 0, v17 - v64);
    }

    if ((buf[12] & 0xF0) == 0xE0)
    {
      BOOL v80 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v80, OS_LOG_TYPE_INFO)) {
        goto LABEL_324;
      }
      *(_DWORD *)__int16 v242 = 136446210;
      *(void *)&v242[4] = "ipv4_parse";
      BOOL v75 = "%{public}s Invalid source address";
      os_log_type_t v76 = v242;
      goto LABEL_120;
    }

    int v21 = (*(_WORD *)&buf[6] & 0xFF3F) != 0;
    os_log_type_t v125 = *(_WORD *)&buf[4];
    if ((*(_WORD *)&buf[6] & 0xFF3F) == 0) {
      os_log_type_t v125 = 0;
    }
    int v23 = v125;
    unsigned int v22 = *(unsigned __int16 *)&buf[6] == 32;
    BOOL v224 = buf[9];
    *(_WORD *)__src[0].sa_data = 0;
    *(void *)&__src[0].sa_data[6] = 0LL;
    *(_WORD *)&__src[0].sa_len = 528;
    *(_DWORD *)&__src[0].sa_data[2] = *(_DWORD *)&buf[12];
    *(_DWORD *)&__dst[0].sa_len = 528;
    *(void *)&__dst[0].sa_data[6] = 0LL;
    *(_DWORD *)&__dst[0].sa_data[2] = *(_DWORD *)&buf[16];
    os_log_type_t v82 = (uint64_t)v10;
    os_log_type_t v83 = v34;
    goto LABEL_214;
  }

  *(_DWORD *)__int16 v242 = 0;
  __int16 v30 = nw_frame_unclaimed_bytes((uint64_t)v10, v242);
  uint64_t v32 = *(_DWORD *)v242;
  if (*(_DWORD *)v242 <= 0x27u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v18 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_324;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = *(_DWORD *)v242;
    id v19 = "%{public}s Received IPv6 packet with incorrect length %u";
    goto LABEL_38;
  }

  os_log_type_t v39 = v30;
  os_log_type_t v40 = bswap32(*(unsigned __int16 *)(v30 + 4)) >> 16;
  os_log_type_t v41 = v40 + 40;
  if ((v40 + 40) > *(_DWORD *)v242)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v42 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_324;
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v41;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = *(_DWORD *)v242;
    os_log_type_t v43 = "%{public}s Received IPv6 packet with incorrect length, expected %u received %u";
    char v44 = buf;
LABEL_46:
    _os_log_impl(&dword_181A5C000, v42, OS_LOG_TYPE_INFO, v43, v44, 0x18u);
    goto LABEL_324;
  }

  if (v40 + 80 < (unint64_t)*(unsigned int *)v242)
  {
    if (gLogDatapath)
    {
      v180 = (os_log_s *)__nwlog_obj();
      os_log_type_t v181 = os_log_type_enabled(v180, OS_LOG_TYPE_DEBUG);
      uint64_t v32 = *(_DWORD *)v242;
      if (v181)
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "ipv6_parse";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v41;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = *(_DWORD *)v242;
        _os_log_impl( &dword_181A5C000,  v180,  OS_LOG_TYPE_DEBUG,  "%{public}s Received length mismatch with IPv6 %u != %u",  buf,  0x18u);
        uint64_t v32 = *(_DWORD *)v242;
      }
    }

    nw_frame_claim((uint64_t)v10, v31, 0, v32 - v41);
  }

  BOOL v224 = *(unsigned __int8 *)(v39 + 6);
  if (v224 == 44)
  {
    unsigned int v22 = *(unsigned __int16 *)(v39 + 42) == 256;
    int v23 = *(_DWORD *)(v39 + 44);
    BOOL v224 = *(unsigned __int8 *)(v39 + 40);
    int v21 = 1;
  }

  else
  {
    int v21 = 0;
    unsigned int v22 = 0;
    int v23 = 0;
  }

  __int16 v65 = *(_DWORD *)(v39 + 8);
  os_log_type_t v66 = *(_DWORD *)(v39 + 12);
  os_log_type_t v67 = *(_DWORD *)(v39 + 16);
  if (*(void *)(v39 + 8)) {
    os_log_type_t v68 = 0;
  }
  else {
    os_log_type_t v68 = v67 == -65536;
  }
  os_log_type_t v69 = v68;
  if (*(_BYTE *)(v39 + 8) == 0xFF || v69)
  {
    os_log_type_t v74 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
      goto LABEL_324;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    BOOL v75 = "%{public}s Invalid source address";
LABEL_107:
    os_log_type_t v76 = buf;
    BOOL v77 = v74;
    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
LABEL_121:
    _os_log_impl(&dword_181A5C000, v77, v78, v75, v76, 0xCu);
    goto LABEL_324;
  }

  BOOL v70 = *(_DWORD *)(v39 + 20);
  *(void *)&__src[0].sa_len = 7708LL;
  *(void *)&__src[1].sa_data[2] = v70;
  *(_DWORD *)&__src[0].sa_data[6] = v65;
  *(_DWORD *)&__src[0].sa_data[10] = v66;
  *(_DWORD *)&__src[1].sa_len = v67;
  if ((v65 & 0xC0FF) == 0x80FE)
  {
    *(_DWORD *)&__src[1].sa_data[6] = v12;
    loga = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "ipv6_parse";
      *(_WORD *)&_BYTE buf[12] = 1040;
      *(_DWORD *)&buf[14] = __src[0].sa_len;
      *(_WORD *)&buf[18] = 2096;
      *(void *)&buf[20] = __src;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v12;
      _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEBUG,  "%{public}s Set scopeid for src %{network:sockaddr}.*P to %u",  buf,  0x22u);
    }
  }

  id v71 = *(_DWORD *)(v39 + 24);
  os_log_type_t v72 = *(_DWORD *)(v39 + 28);
  BOOL v73 = *(_DWORD *)(v39 + 32);
  if (!__PAIR64__(v72, v71) && v73 == -65536)
  {
    os_log_type_t v74 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
      goto LABEL_324;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    BOOL v75 = "%{public}s Invalid destination address";
    goto LABEL_107;
  }

  os_log_type_t v81 = *(_DWORD *)(v39 + 36);
  *(void *)&__dst[0].sa_len = 7708LL;
  *(void *)&__dst[1].sa_data[2] = v81;
  *(_DWORD *)&__dst[0].sa_data[6] = v71;
  *(_DWORD *)&__dst[0].sa_data[10] = v72;
  *(_DWORD *)&__dst[1].sa_len = v73;
  if ((v71 & 0xC0FF) == 0x80FE)
  {
    *(_DWORD *)&__dst[1].sa_data[6] = v12;
    logb = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(logb, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "ipv6_parse";
      *(_WORD *)&_BYTE buf[12] = 1040;
      *(_DWORD *)&buf[14] = __dst[0].sa_len;
      *(_WORD *)&buf[18] = 2096;
      *(void *)&buf[20] = __dst;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v12;
      _os_log_impl( &dword_181A5C000,  logb,  OS_LOG_TYPE_DEBUG,  "%{public}s Set scopeid for dst %{network:sockaddr}.*P to %u",  buf,  0x22u);
    }
  }

  nw_frame_claim((uint64_t)v10, v31, 40, 0);
  if (*(_BYTE *)(v39 + 6) != 44) {
    goto LABEL_215;
  }
  os_log_type_t v82 = (uint64_t)v10;
  os_log_type_t v83 = 8;
LABEL_214:
  nw_frame_claim(v82, v16, v83, 0);
LABEL_215:
  if (v224 != *((unsigned __int8 *)v9 + 166))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v56 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
    {
      BOOL v126 = *((unsigned __int8 *)v9 + 166);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v224;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v126;
      _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_INFO,  "%{public}s Received IP packet with protocol %u != %u",  buf,  0x18u);
    }

    goto LABEL_78;
  }

  char v11 = *((_DWORD *)v9 + 14);
LABEL_14:
  if ((v11 & 0xFFFFFFFE) != 2) {
    goto LABEL_148;
  }
  if (!v21 || v22)
  {
    char v27 = v224;
    if (v224 == 17)
    {
      *(_DWORD *)__int16 v242 = 0;
      os_log_type_t v46 = (__int16 *)nw_frame_unclaimed_bytes((uint64_t)v10, v242);
      if (*(_DWORD *)v242 < 8u
        || (char v47 = *v46, v48 = v46[1], *(_DWORD *)v242 < bswap32((unsigned __int16)v46[2]) >> 16) && !v21)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v29 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_udp_parse";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = *(_DWORD *)v242;
        id v19 = "%{public}s Received UDP packet with incorrect length %u";
        goto LABEL_55;
      }

      int sa_family = __src[0].sa_family;
      if (__src[0].sa_family == 30 && !v46[3])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v80 = (os_log_s *)gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_parse";
        BOOL v75 = "%{public}s Received IPv6 UDP packet with 0 checksum";
        goto LABEL_119;
      }

      if (!v21)
      {
        if (__src[0].sa_family == 2) {
          os_log_type_t v84 = &__src[0].sa_data[2];
        }
        else {
          os_log_type_t v84 = &__src[0].sa_data[6];
        }
        if (__dst[0].sa_family == 2) {
          os_log_type_t v85 = &__dst[0].sa_data[2];
        }
        else {
          os_log_type_t v85 = &__dst[0].sa_data[6];
        }
        if ((udp_validate_cksum_internal( (uint64_t)v10,  *(unsigned int *)v242,  (unsigned __int16 *)v84,  (unsigned __int16 *)v85,  __src[0].sa_family == 30,  0LL) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v80 = (os_log_s *)gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
            goto LABEL_324;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_udp_parse";
          BOOL v75 = "%{public}s Received UDP packet with invalid checksum";
LABEL_119:
          os_log_type_t v76 = buf;
LABEL_120:
          BOOL v77 = v80;
          os_log_type_t v78 = OS_LOG_TYPE_INFO;
          goto LABEL_121;
        }

        int sa_family = __src[0].sa_family;
      }

      if (sa_family != 30 && sa_family != 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v29 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_udp_parse";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = __src[0].sa_family;
        id v19 = "%{public}s Unsuppposed address family: %u";
        goto LABEL_55;
      }

      *(_WORD *)__src[0].sa_data = v47;
      *(_WORD *)__dst[0].sa_data = v48;
      char v27 = 17;
LABEL_145:
      if (a5 && v22)
      {
        *((_DWORD *)a5 + 14) = v23;
        a5[60] = v27;
        memcpy(a5, __src, __src[0].sa_len);
        memcpy(a5 + 28, __dst, __dst[0].sa_len);
      }

      goto LABEL_148;
    }

    if (v224 != 6) {
      goto LABEL_145;
    }
    if (__dst[0].sa_family == 2)
    {
      if ((__dst[0].sa_data[2] & 0xF0) != 0xE0) {
        goto LABEL_30;
      }
    }

    else if (__dst[0].sa_family != 30 || __dst[0].sa_data[6] != 255)
    {
LABEL_30:
      *(_DWORD *)__int16 v242 = 0;
      uint64_t v28 = (unsigned __int16 *)nw_frame_unclaimed_bytes((uint64_t)v10, v242);
      if (*(_DWORD *)v242 <= 0x13u)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v29 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = *(_DWORD *)v242;
        id v19 = "%{public}s Received TCP packet with incorrect length %u";
LABEL_55:
        dispatch_time_t v33 = buf;
        os_log_type_t v49 = (os_log_s *)v29;
        BOOL v50 = OS_LOG_TYPE_ERROR;
LABEL_112:
        _os_log_impl(&dword_181A5C000, v49, v50, v19, v33, 0x12u);
        goto LABEL_324;
      }

      os_log_type_t v51 = *v28;
      id v52 = v28[1];
      os_log_type_t v53 = *((unsigned __int8 *)v28 + 12);
      log = *((unsigned __int8 *)v28 + 13);
      if (__src[0].sa_family == 2) {
        os_log_type_t v54 = &__src[0].sa_data[2];
      }
      else {
        os_log_type_t v54 = &__src[0].sa_data[6];
      }
      if (__dst[0].sa_family == 2) {
        os_log_type_t v55 = &__dst[0].sa_data[2];
      }
      else {
        os_log_type_t v55 = &__dst[0].sa_data[6];
      }
      if ((validate_tcp_cksum( (uint64_t)v10,  *(unsigned int *)v242,  (unsigned int *)v54,  (unsigned int *)v55,  v51,  v52,  __dst[0].sa_family == 30) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v80 = (os_log_s *)gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        BOOL v75 = "%{public}s invalid tcp checksum";
        goto LABEL_119;
      }

      if (v53 < 0x50 || *(_DWORD *)v242 < ((v53 >> 2) & 0x3C))
      {
        os_log_type_t v121 = (v53 >> 2) & 0x3C;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v121;
        id v19 = "%{public}s invalid tcp offset: %u";
      }

      else
      {
        if (__src[0].sa_family == 30)
        {
          *(_WORD *)__src[0].sa_data = v51;
          char v27 = v224;
          goto LABEL_226;
        }

        char v27 = v224;
        if (__src[0].sa_family == 2)
        {
          *(_WORD *)__src[0].sa_data = v51;
LABEL_226:
          *(_WORD *)__dst[0].sa_data = v52;
          if ((~log & 3) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v80 = (os_log_s *)gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
              goto LABEL_324;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
            BOOL v75 = "%{public}s Dropping SYN|FIN";
            goto LABEL_119;
          }

          if ((log & 0x16) != 2)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v130 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
              _os_log_impl( &dword_181A5C000,  v130,  OS_LOG_TYPE_INFO,  "%{public}s Non SYN packet delivered to listener",  buf,  0xCu);
            }

            if ((log & 4) == 0) {
              nw_tcp_respond_reset((uint64_t)v10, a2, (uint64_t)(v9 + 11), (uint64_t)__dst, (uint64_t)__src);
            }
            goto LABEL_324;
          }

          goto LABEL_145;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = __src[0].sa_family;
        id v19 = "%{public}s Unsuppposed address family: %u";
      }

  if (v83) {
    free(v83);
  }
  if (v50) {
    free(v50);
  }
LABEL_242:
  char v116 = v161 - (_DWORD)v10;
  if (v116 <= 1) {
    id v117 = 1;
  }
  else {
    id v117 = v116;
  }
  *(_DWORD *)buf = v117;
  BOOL v118 = *((_DWORD *)v9 + 38);
  if (v118 != v117)
  {
    if (v117 > v118)
    {
      LODWORD(v168.msg_name) = 0;
      LODWORD(v190) = 4;
      if (getsockopt(*((_DWORD *)v9 + 43), 0xFFFF, 4098, &v168, (socklen_t *)&v190))
      {
        os_log_type_t v119 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v120 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v121 = *((_DWORD *)v9 + 43);
          *(_DWORD *)uint64_t v177 = 136446978;
          *(void *)&v177[4] = "nw_socket_set_receive_low_water_mark";
          *(_WORD *)&v177[12] = 2080;
          *(void *)&v177[14] = v9 + 308;
          *(_WORD *)&v177[22] = 1024;
          *(_DWORD *)&v177[24] = v121;
          *(_WORD *)&v177[28] = 1024;
          *(_DWORD *)&v177[30] = v119;
          _os_log_impl( &dword_181A5C000,  v120,  OS_LOG_TYPE_ERROR,  "%{public}s %s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d",  v177,  0x22u);
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v122 = *((_DWORD *)v9 + 43);
        *(_DWORD *)uint64_t v177 = 136446722;
        *(void *)&v177[4] = "nw_socket_set_receive_low_water_mark";
        *(_WORD *)&v177[12] = 1024;
        *(_DWORD *)&v177[14] = v122;
        *(_WORD *)&v177[18] = 1024;
        *(_DWORD *)&v177[20] = v119;
        BOOL v123 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(type) = 16;
        v169 = 0;
        if (__nwlog_fault(v123, &type, &v169))
        {
          if (type != 17)
          {
            if (v169)
            {
              id v129 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v124 = (os_log_s *)gLogObj;
              os_log_type_t v125 = type;
              os_log_type_t v130 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type);
              if (v129)
              {
                if (v130)
                {
                  char v131 = *(_DWORD *)(v165 + 172);
                  *(_DWORD *)uint64_t v177 = 136446978;
                  *(void *)&v177[4] = "nw_socket_set_receive_low_water_mark";
                  *(_WORD *)&v177[12] = 1024;
                  *(_DWORD *)&v177[14] = v131;
                  *(_WORD *)&v177[18] = 1024;
                  *(_DWORD *)&v177[20] = v119;
                  *(_WORD *)&v177[24] = 2082;
                  *(void *)&v177[26] = v129;
                  _os_log_impl( &dword_181A5C000,  v124,  v125,  "%{public}s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d, dumping backtrace:%{public}s",  v177,  0x22u);
                }

                free(v129);
                goto LABEL_274;
              }

              if (!v130) {
                goto LABEL_274;
              }
              BOOL v133 = *(_DWORD *)(v165 + 172);
              *(_DWORD *)uint64_t v177 = 136446722;
              *(void *)&v177[4] = "nw_socket_set_receive_low_water_mark";
              *(_WORD *)&v177[12] = 1024;
              *(_DWORD *)&v177[14] = v133;
              *(_WORD *)&v177[18] = 1024;
              *(_DWORD *)&v177[20] = v119;
              uint64_t v127 = "%{public}s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d, no backtrace";
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v124 = (os_log_s *)gLogObj;
              os_log_type_t v125 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type)) {
                goto LABEL_274;
              }
              os_log_type_t v132 = *(_DWORD *)(v165 + 172);
              *(_DWORD *)uint64_t v177 = 136446722;
              *(void *)&v177[4] = "nw_socket_set_receive_low_water_mark";
              *(_WORD *)&v177[12] = 1024;
              *(_DWORD *)&v177[14] = v132;
              *(_WORD *)&v177[18] = 1024;
              *(_DWORD *)&v177[20] = v119;
              uint64_t v127 = "%{public}s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d, backtrace limit exceeded";
            }

    _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0x12u);
    goto LABEL_325;
  }

  memset(uu, 0, sizeof(uu));
  os_log_type_t v40 = v16;
  *(_OWORD *)__int128 uu = *(_OWORD *)(v40 + 24);

  if (uuid_is_null(uu))
  {
    if (uuid_is_null(a1->flow_id) || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4369, a1, 0x10u)) {
      goto LABEL_179;
    }
    os_log_type_t v41 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v42 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(void *)v555 = (char *)a1 + 404;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v41;
      _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d",  buf,  0x1Cu);
    }

    if (v41 == 2 || v41 == 22)
    {
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v41;
        char v44 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d";
LABEL_134:
        _os_log_impl(&dword_181A5C000, v43, OS_LOG_TYPE_ERROR, v44, buf, 0x12u);
        goto LABEL_179;
      }

      goto LABEL_179;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v41;
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v556) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v57, &v556, type) & 1) == 0) {
      goto LABEL_177;
    }
    if (v556 == 17)
    {
      BOOL v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = v556;
      if (!os_log_type_enabled(v58, (os_log_type_t)v556)) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      BOOL v60 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d";
      goto LABEL_176;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = v556;
      if (!os_log_type_enabled(v58, (os_log_type_t)v556)) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      BOOL v60 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_176;
    }

    int v64 = p_output_handler;
    __int16 v65 = (char *)__nw_create_backtrace_string();
    BOOL v58 = (os_log_s *)__nwlog_obj();
    os_log_type_t v59 = v556;
    os_log_type_t v66 = os_log_type_enabled(v58, (os_log_type_t)v556);
    if (!v65)
    {
      p_output_handler = v64;
      if (!v66) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      BOOL v60 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, no backtrace";
      goto LABEL_176;
    }

    if (v66)
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      *(_WORD *)&v555[4] = 2082;
      *(void *)&v555[6] = v65;
      _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

    free(v65);
    p_output_handler = v64;
LABEL_177:
    if (!v57) {
      goto LABEL_179;
    }
    goto LABEL_178;
  }

  if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4384, uu, 0x10u)) {
    goto LABEL_179;
  }
  os_log_type_t v49 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  BOOL v50 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(void *)v555 = (char *)a1 + 404;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v49;
    _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  if (v49 != 2 && v49 != 22)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v49;
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v556) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v57, &v556, type) & 1) == 0) {
      goto LABEL_177;
    }
    if (v556 == 17)
    {
      BOOL v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = v556;
      if (!os_log_type_enabled(v58, (os_log_type_t)v556)) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v49;
      BOOL v60 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d";
    }

    else
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v58 = (os_log_s *)__nwlog_obj();
        os_log_type_t v59 = v556;
        if (!os_log_type_enabled(v58, (os_log_type_t)v556)) {
          goto LABEL_177;
        }
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v49;
        BOOL v60 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_176;
      }

      os_log_type_t v61 = p_output_handler;
      os_log_type_t v62 = (char *)__nw_create_backtrace_string();
      BOOL v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = v556;
      os_log_type_t v63 = os_log_type_enabled(v58, (os_log_type_t)v556);
      if (v62)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v49;
          *(_WORD *)&v555[4] = 2082;
          *(void *)&v555[6] = v62;
          _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v62);
        p_output_handler = v61;
        if (!v57) {
          goto LABEL_179;
        }
LABEL_178:
        free(v57);
        goto LABEL_179;
      }

      p_output_handler = v61;
      if (!v63) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v49;
      BOOL v60 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, no backtrace";
    }

  __break(1u);
  return result;
}

LABEL_300:
          if (v93) {
            free(v93);
          }
          goto LABEL_302;
        }

        __nwlog_obj();
        os_log_type_t v62 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
        os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();

        v170[0] = 16;
        LOBYTE(v163) = 0;
        if (v170[0] == 17)
        {
          __nwlog_obj();
          os_log_type_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v63 = v170[0];
          if (os_log_type_enabled(v37, (os_log_type_t)v170[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
            _os_log_impl( &dword_181A5C000,  v37,  v63,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

      free(v114);
      goto LABEL_301;
    }

    BOOL v115 = (os_log_s *)__nwlog_obj();
    char v116 = v176;
    if (!os_log_type_enabled(v115, v176)) {
      goto LABEL_299;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v178 = "nw_http1_get_http1_protocol";
    id v117 = "%{public}s called with null handle";
    goto LABEL_298;
  }

  uint64_t v12 = *((_DWORD *)handle + 6);
  uint64_t v13 = (uint64_t *)a1->handle;
  if (v12 == 1) {
    goto LABEL_10;
  }
  if (v12 != 2)
  {
    if (v12 != 3) {
      goto LABEL_301;
    }
    uint64_t v14 = *((void *)handle + 2);
    if (v14)
    {
      uint64_t v13 = (uint64_t *)(v14 + 480);
      goto LABEL_10;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v178 = "nw_http1_get_http1_protocol";
    os_log_type_t v114 = (char *)_os_log_send_and_compose_impl();
    v176 = OS_LOG_TYPE_ERROR;
    BOOL v175 = 0;
    if (__nwlog_fault(v114, &v176, &v175))
    {
      if (v176 == OS_LOG_TYPE_FAULT)
      {
        BOOL v115 = (os_log_s *)__nwlog_obj();
        char v116 = v176;
        if (!os_log_type_enabled(v115, v176)) {
          goto LABEL_299;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v178 = "nw_http1_get_http1_protocol";
        id v117 = "%{public}s called with null handle->http1_connection";
        goto LABEL_298;
      }

      if (!v175)
      {
        BOOL v115 = (os_log_s *)__nwlog_obj();
        char v116 = v176;
        if (!os_log_type_enabled(v115, v176)) {
          goto LABEL_299;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v178 = "nw_http1_get_http1_protocol";
        id v117 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_298;
      }

      os_log_type_t v120 = (char *)__nw_create_backtrace_string();
      BOOL v115 = (os_log_s *)__nwlog_obj();
      char v116 = v176;
      BOOL v133 = os_log_type_enabled(v115, v176);
      if (!v120)
      {
        if (!v133) {
          goto LABEL_299;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v178 = "nw_http1_get_http1_protocol";
        id v117 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_298;
      }

      if (v133)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v178 = "nw_http1_get_http1_protocol";
        os_log_type_t v179 = 2082;
        *(void *)v180 = v120;
        os_log_type_t v122 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
        goto LABEL_260;
      }

      goto LABEL_261;
    }

      free(backtrace_string);
      goto LABEL_375;
    }

    if (!v185) {
      goto LABEL_375;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    os_log_type_t v166 = "%{public}s called with null parameters, no backtrace";
LABEL_374:
    _os_log_impl(&dword_181A5C000, v164, v165, v166, buf, 0xCu);
LABEL_375:
    if (v163) {
      free(v163);
    }
    return 0LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v14 = (os_log_s *)gLogObj;
  uint64_t result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
  if (result)
  {
    BOOL v16 = *((_DWORD *)handle + 320);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 1289;
    *(_WORD *)&_BYTE buf[22] = 2080;
    *(void *)&_BYTE buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v16;
    _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> cannot add input handler to closed connection",  buf,  0x26u);
    return 0LL;
  }

  return result;
}

    if (v140) {
      free(v140);
    }
  }
              }
            }

            if (v135) {
              free(v135);
            }
            uint64_t v91 = 0;
            if ((v87 & 1) != 0) {
LABEL_206:
            }
              nw::release_if_needed<nw_protocol *>((uint64_t *)v373);
LABEL_207:
            if ((v376 & 1) != 0) {
LABEL_208:
            }
              nw::release_if_needed<nw_protocol *>((uint64_t *)v375);
LABEL_209:
            if ((v91 & 1) == 0)
            {
              if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v214 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
                {
                  loga = v214;
                  v286 = nw_endpoint_handler_get_id_string(v362);
                  v287 = nw_endpoint_handler_dry_run_string(v362);
                  v288 = nw_endpoint_handler_copy_endpoint(v362);
                  v289 = nw_endpoint_get_logging_description(v288);
                  v290 = nw_endpoint_handler_state_string(v362);
                  v291 = nw_endpoint_handler_mode_string(v362);
                  v292 = nw_endpoint_handler_copy_current_path(v362);
                  *(_DWORD *)buf = 136448002;
                  v378 = "nw_endpoint_handler_modify_protocol_stack";
                  v379 = 2082;
                  v380 = (char *)v286;
                  v381 = 2082;
                  v382 = v287;
                  v383 = 2082;
                  v384 = (void *)v289;
                  v385 = 2082;
                  v386 = v290;
                  v387 = 2082;
                  v388 = v291;
                  v389 = 2114;
                  v390 = v292;
                  v391 = 2082;
                  v392 = v12;
                  _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to remove pr otocol %{public}s",  buf,  0x52u);

                  goto LABEL_599;
                }

                goto LABEL_600;
              }

              goto LABEL_601;
            }

            goto LABEL_210;
          }

          __nwlog_obj();
          uint64_t v151 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v378 = "__nw_protocol_remove_input_handler";
          __int16 v152 = (char *)_os_log_send_and_compose_impl();

          v373[0] = OS_LOG_TYPE_ERROR;
          v370[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v152, v373, v370))
          {
            if (v373[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              unsigned int v153 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v154 = v373[0];
              if (os_log_type_enabled(v153, v373[0]))
              {
                *(_DWORD *)buf = 136446210;
                v378 = "__nw_protocol_remove_input_handler";
                _os_log_impl(&dword_181A5C000, v153, v154, "%{public}s called with null input_protocol", buf, 0xCu);
              }

              goto LABEL_417;
            }

            if (v370[0])
            {
              char v164 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              unsigned int v153 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v350 = v373[0];
              os_log_type_t v165 = os_log_type_enabled(v153, v373[0]);
              if (v164)
              {
                if (v165)
                {
                  *(_DWORD *)buf = 136446466;
                  v378 = "__nw_protocol_remove_input_handler";
                  v379 = 2082;
                  v380 = v164;
                  _os_log_impl( &dword_181A5C000,  v153,  v350,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v164);
                goto LABEL_418;
              }

              if (v165)
              {
                *(_DWORD *)buf = 136446210;
                v378 = "__nw_protocol_remove_input_handler";
                _os_log_impl( &dword_181A5C000,  v153,  v350,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              unsigned int v153 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v171 = v373[0];
              if (os_log_type_enabled(v153, v373[0]))
              {
                *(_DWORD *)buf = 136446210;
                v378 = "__nw_protocol_remove_input_handler";
                _os_log_impl( &dword_181A5C000,  v153,  v171,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
              }
            }

                            if (__nwlog_connection_log::onceToken != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                            }
                            logh = (id)gconnectionLogObj;
                            v244 = nw_endpoint_handler_get_id_string(v48);
                            __int16 v245 = nw_endpoint_handler_dry_run_string(v48);
                            BOOL v246 = nw_endpoint_handler_copy_endpoint(v48);
                            os_log_type_t v247 = nw_endpoint_get_logging_description(v246);
                            v248 = nw_endpoint_handler_state_string(v48);
                            os_log_type_t v249 = nw_endpoint_handler_mode_string(v48);
                            BOOL v250 = nw_endpoint_handler_copy_current_path(v48);
                            *(_DWORD *)buf = 136447746;
                            v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            v359 = 2082;
                            v360 = (char *)v244;
                            v361 = 2082;
                            v362 = v245;
                            v363 = 2082;
                            v364 = (void *)v247;
                            v365 = 2082;
                            v366 = v248;
                            v367 = 2082;
                            v368 = v249;
                            v369 = 2114;
                            v370 = v250;
                            BOOL v182 = (char *)_os_log_send_and_compose_impl();

                            type[0] = OS_LOG_TYPE_ERROR;
                            LOBYTE(v353) = 0;
                            if ((__nwlog_fault(v182, type, &v353) & 1) != 0)
                            {
                              if (type[0] == OS_LOG_TYPE_FAULT)
                              {
                                if (__nwlog_connection_log::onceToken != -1) {
                                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                }
                                os_log_type_t v183 = (os_log_s *)(id)gconnectionLogObj;
                                v251 = type[0];
                                if (os_log_type_enabled(v183, type[0]))
                                {
                                  uint64_t v252 = nw_endpoint_handler_get_id_string(v48);
                                  v253 = nw_endpoint_handler_dry_run_string(v48);
                                  logi = v183;
                                  os_log_type_t v254 = nw_endpoint_handler_copy_endpoint(v48);
                                  v255 = nw_endpoint_get_logging_description(v254);
                                  v256 = v48;
                                  BOOL v257 = nw_endpoint_handler_state_string(v48);
                                  os_log_type_t v258 = nw_endpoint_handler_mode_string(v256);
                                  v259 = nw_endpoint_handler_copy_current_path(v256);
                                  *(_DWORD *)buf = 136447746;
                                  v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                  v359 = 2082;
                                  v360 = (char *)v252;
                                  v361 = 2082;
                                  v362 = v253;
                                  v363 = 2082;
                                  v364 = (void *)v255;
                                  v365 = 2082;
                                  v366 = v257;
                                  v367 = 2082;
                                  v368 = v258;
                                  v369 = 2114;
                                  v370 = v259;
                                  _os_log_impl( &dword_181A5C000,  logi,  v251,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fai led to repair protocol stack: Could not add old input_protocol",  buf,  0x48u);

                                  os_log_type_t v183 = logi;
                                }

void sub_181E6941C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v146 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v6 = p_output_handler;
    id v7 = v6;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *((void *)v6 + 1);
      if (v8)
      {
        if (*(void *)(v8 + 80))
        {
          if (!*((void *)v6 + 36))
          {
            uint64_t v9 = nw_protocol_instance_copy_path(v6, -1LL);
            uint64_t v10 = (void *)*((void *)v7 + 36);
            *((void *)v7 + 36) = v9;
          }

          if (a1->output_handler != a2)
          {
            *(void *)os_log_type_t type = 0LL;
            uint64_t v11 = nw_protocol_implementation_lookup_path_by_protocol( (NWConcrete_nw_protocol_instance *)v7,  a2,  (unint64_t *)type);
            if (v11)
            {
              uint64_t v12 = v11;
              if (*(_DWORD *)(v11 + 128) != 3)
              {
                if ((v7[405] & 0x80000000) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v13 = (os_log_s *)(id)gLogObj;
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v14 = *(void *)(v12 + 16);
                    uint64_t v15 = *(void *)(v12 + 120);
                    *(_DWORD *)buf = 136447490;
                    os_log_type_t v135 = "nw_protocol_implementation_connected";
                    __int16 v136 = 2082;
                    os_log_type_t v137 = v7 + 407;
                    __int16 v138 = 2080;
                    BOOL v139 = " ";
                    __int16 v140 = 2048;
                    os_log_type_t v141 = *(char **)type;
                    __int16 v142 = 2112;
                    uint64_t v143 = v14;
                    __int16 v144 = 2112;
                    uint64_t v145 = v15;
                    _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sPath %lx is now established over %@:%@",  buf,  0x3Eu);
                  }
                }

                *(_DWORD *)(v12 + 128) = 3;
                BOOL v16 = (char *)*((void *)v7 + 39);
                uint64_t v17 = *(char **)type;
                (*(void (**)(char *, char *, uint64_t, BOOL))(*(void *)(*((void *)v7 + 1) + 80LL) + 208LL))( v7,  v17,  3LL,  v16 == v17);
                nw_protocol_implementation_read((NWConcrete_nw_protocol_instance *)v7, a2);
              }
            }
          }

          if (*(_DWORD *)(*((void *)v7 + 1) + 64LL) == 3)
          {
            uint64_t v18 = MEMORY[0x1895F87A8];
            id v19 = (char *)*((void *)v7 + 29);
            v127[0] = MEMORY[0x1895F87A8];
            v127[1] = 3221225472LL;
            v127[2] = ___ZL36nw_protocol_implementation_connectedP11nw_protocolS0__block_invoke;
            v127[3] = &__block_descriptor_40_e23_B16__0__nw_hash_node__8l;
            v127[4] = a2;
            nw_hash_table_apply(v19, (uint64_t)v127);
            if (a1->output_handler == a2)
            {
              v7[402] |= 0x20u;
              int v20 = (char *)*((void *)v7 + 29);
              v125[0] = v18;
              v125[1] = 3221225472LL;
              v125[2] = ___ZL36nw_protocol_implementation_connectedP11nw_protocolS0__block_invoke_2;
              v125[3] = &unk_189BC86F0;
              int v21 = v7;
              BOOL v126 = v21;
              nw_hash_table_apply(v20, (uint64_t)v125);
              nw_protocol_implementation_read(v21, a1->output_handler);
            }

            goto LABEL_42;
          }

          default_input_handler = a1->default_input_handler;
          if (default_input_handler)
          {
            int v23 = default_input_handler->handle;
            if (v23 == &nw_protocol_ref_counted_handle)
            {
              callbacks = default_input_handler[1].callbacks;
              if (callbacks) {
                default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
              }
              char v24 = -1;
            }

            else
            {
              char v24 = 0;
            }

            *(void *)os_log_type_t type = default_input_handler;
            char v133 = v24;
            if (a2)
            {
              uint64_t v26 = a2->handle;
              if (v26 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v28 = a2[1].callbacks;
                if (v28) {
                  a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v28->add_input_handler + 1);
                }
                char v27 = -1;
              }

              else
              {
                char v27 = 0;
              }

              *(void *)id v129 = a2;
              char v130 = v27;
              unsigned int v29 = default_input_handler->callbacks;
              if (v29)
              {
                connected = (void (*)(nw_protocol *, nw_protocol *))v29->connected;
                if (connected)
                {
                  connected(default_input_handler, a2);
LABEL_37:
                  if (v26 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)v129);
                  }
LABEL_39:
                  if (v23 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
LABEL_41:
                  if (a1->output_handler != a2)
                  {
LABEL_42:

                    return;
                  }

                  char v31 = v7[402];
                  v7[402] = v31 | 0x20;
                  uint64_t v32 = *((void *)v7 + 1);
                  if (*(_DWORD *)(v32 + 64) != 1 && (v31 & 8) == 0)
                  {
                    if ((v31 & 4) != 0) {
                      goto LABEL_42;
                    }
                    if (*(void *)(*(void *)(v32 + 80) + 120LL))
                    {
                      v7[402] = v31 | 0x24;
                      dispatch_time_t v33 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v32 + 80) + 120LL);
                      uint64_t server_mode = nw_parameters_get_server_mode(*((void **)v7 + 6));
                      v33(v7, -1LL, server_mode);
                      nw_protocol_implementation_read((NWConcrete_nw_protocol_instance *)v7, a1->output_handler);
                      goto LABEL_42;
                    }

                    __nwlog_obj();
                    char v44 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 136446210;
                    os_log_type_t v135 = "nw_protocol_implementation_connected";
                    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

                    type[0] = OS_LOG_TYPE_ERROR;
                    v129[0] = OS_LOG_TYPE_DEFAULT;
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      __nwlog_obj();
                      os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v47 = type[0];
                      if (os_log_type_enabled(v46, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        os_log_type_t v135 = "nw_protocol_implementation_connected";
                        _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s called with null instance->parent_definition->start",  buf,  0xCu);
                      }

LABEL_237:
            if (v84) {
              free(v84);
            }
            goto LABEL_39;
          }

          __nwlog_obj();
          BOOL v77 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v135 = "__nw_protocol_connected";
          os_log_type_t v78 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v129[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v78, type, v129))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v80 = type[0];
              if (os_log_type_enabled(v79, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v135 = "__nw_protocol_connected";
                _os_log_impl(&dword_181A5C000, v79, v80, "%{public}s called with null protocol", buf, 0xCu);
              }
            }

            else if (v129[0])
            {
              int v90 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v91 = type[0];
              BOOL v92 = os_log_type_enabled(v79, type[0]);
              if (v90)
              {
                if (v92)
                {
                  *(_DWORD *)buf = 136446466;
                  os_log_type_t v135 = "__nw_protocol_connected";
                  __int16 v136 = 2082;
                  os_log_type_t v137 = v90;
                  _os_log_impl( &dword_181A5C000,  v79,  v91,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v90);
                goto LABEL_232;
              }

              if (v92)
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v135 = "__nw_protocol_connected";
                _os_log_impl( &dword_181A5C000,  v79,  v91,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              os_log_type_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v111 = type[0];
              if (os_log_type_enabled(v79, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v135 = "__nw_protocol_connected";
                _os_log_impl( &dword_181A5C000,  v79,  v111,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

    goto LABEL_238;
  }

  id v6 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_connection);
  id v7 = (void *)*((void *)v3 + 1);
  uint64_t v8 = v5;
  uint64_t v9 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v8,  0,  0);

  uint64_t v10 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]((void **)&v6->super.isa, v7, (void *)v9, 0);
  if (v10)
  {
    uint64_t v11 = *(void *)(v10 + 8);
    uint64_t v12 = *(void *)(v10 + 16);
    nw_allow_use_of_dispatch_internal();
    if (has_modifiers == 1)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
      uint64_t v13 = (void *)g_modifier_list;
      if (g_modifier_list)
      {
        while (1)
        {
          uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t))v13[2];
          if (v14)
          {
            if ((v14(v11, v12) & 1) != 0) {
              break;
            }
          }

          uint64_t v13 = (void *)*v13;
          if (!v13) {
            goto LABEL_6;
          }
        }

        os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
        uint64_t v15 = *(void *)(v10 + 16);
        if (v15 && !nw_path_parameters_get_logging_disabled(*(void *)(v15 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v16 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v17 = *(_DWORD *)(v10 + 448);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v17;
            _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Connection parameters were modified",  buf,  0x12u);
          }
        }
      }

      else
      {
LABEL_6:
        os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
      }
    }

    uint64_t v198 = 0LL;
    os_log_type_t v199 = &v198;
    v200 = 0x2020000000LL;
    v201 = 0;
    *(void *)os_log_type_t type = 0LL;
    v193 = type;
    v194 = 0x3032000000LL;
    uint64_t v195 = __Block_byref_object_copy__24148;
    uint64_t v196 = __Block_byref_object_dispose__24149;
    uint64_t v197 = 0LL;
    uint64_t v18 = MEMORY[0x1895F87A8];
    v188[0] = MEMORY[0x1895F87A8];
    v188[1] = 3221225472LL;
    v188[2] = __nw_connection_create_with_connection_block_invoke;
    v188[3] = &unk_189BC16A8;
    os_log_type_t v190 = &v198;
    id v19 = v3;
    id v189 = v19;
    BOOL v191 = type;
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 34);
    __nw_connection_create_with_connection_block_invoke(v188);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 34);
    if (!*((_BYTE *)v199 + 24) || (int v20 = (void *)*((void *)v193 + 5)) == 0LL)
    {
      char v37 = *(void *)(v10 + 16);
      if (!v37 || nw_path_parameters_get_logging_disabled(*(void *)(v37 + 104)))
      {
        os_log_type_t v39 = 0LL;
LABEL_223:

        _Block_object_dispose(type, 8);
        _Block_object_dispose(&v198, 8);
        goto LABEL_224;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      unsigned int v22 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v38 = *(_DWORD *)(v10 + 448);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v38;
        _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Original connection not yet connected",  buf,  0x12u);
      }

      os_log_type_t v39 = 0LL;
LABEL_222:

      goto LABEL_223;
    }

    int v21 = v20;
    unsigned int v22 = (os_log_s *)v21[5];

    int v23 = v8;
    v187 = *(id *)(v23[13] + 136LL);

    if (!v22)
    {
      os_log_type_t v47 = *(void *)(v10 + 16);
      if (!v47 || nw_path_parameters_get_logging_disabled(*(void *)(v47 + 104))) {
        goto LABEL_220;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v48 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v49 = *(_DWORD *)(v10 + 448);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v49;
        _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Cannot get context from existing connection",  buf,  0x12u);
      }

      goto LABEL_219;
    }

    if (!v187)
    {
      os_log_type_t v51 = *(void *)(v10 + 16);
      if (!v51 || nw_path_parameters_get_logging_disabled(*(void *)(v51 + 104))) {
        goto LABEL_220;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v48 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        id v52 = *(_DWORD *)(v10 + 448);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v52;
        _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Cannot get context from new parameters",  buf,  0x12u);
      }

      goto LABEL_219;
    }

    if (!nw_context_shares_workloop(v22, v187))
    {
      os_log_type_t v53 = *(void *)(v10 + 16);
      if (!v53 || nw_path_parameters_get_logging_disabled(*(void *)(v53 + 104))) {
        goto LABEL_220;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v48 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v54 = *(_DWORD *)(v10 + 448);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v54;
        _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] New parameters do not share workloop with existing connection",  buf,  0x12u);
      }

      goto LABEL_219;
    }

    char v24 = *(void **)(v10 + 16);
    uint64_t v25 = *(_DWORD *)(v10 + 448);
    uint64_t v26 = *((id *)v193 + 5);
    char v27 = v24;
    os_log_type_t v185 = v26;
    os_log_type_t v186 = (id)v10;
    os_log_type_t v184 = v27;
    if (v26)
    {
      if (v27)
      {
        if (v26[29] == 2)
        {
          uint64_t v28 = nw_endpoint_flow_copy_joinable_clone_handler(v26, v27);
          unsigned int v29 = v28;
          v180 = v28;
          if (!v28 || v28->mode != 2)
          {
            if ((v26[67] & 0x20) != 0)
            {
              os_log_type_t v87 = 0LL;
              goto LABEL_203;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            log = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
            {
              if ((v26[67] & 1) != 0) {
                os_log_type_t v61 = "dry-run ";
              }
              else {
                os_log_type_t v61 = "";
              }
              os_log_type_t v62 = nw_endpoint_handler_copy_endpoint(v26);
              logging_description = nw_endpoint_get_logging_description(v62);
              int v64 = v26[30];
              else {
                __int16 v65 = off_189BBBBF0[v64];
              }
              stacka = (nw_protocol_stack_t)v65;
              os_log_type_t v69 = v26;
              os_log_type_t v70 = (os_unfair_lock_s *)v69;
              BOOL v71 = v26[29];
              BOOL v175 = logging_description;
              uint64_t v178 = v62;
              os_log_type_t v72 = "path";
              switch(v71)
              {
                case 0:
                  break;
                case 1:
                  os_log_type_t v72 = "resolver";
                  break;
                case 2:
                  os_log_type_t v72 = nw_endpoint_flow_mode_string(*((void **)v69 + 31));
                  break;
                case 3:
                  os_log_type_t v72 = "proxy";
                  break;
                case 4:
                  os_log_type_t v72 = "fallback";
                  break;
                case 5:
                  os_log_type_t v72 = "transform";
                  break;
                default:
                  os_log_type_t v72 = "unknown-mode";
                  break;
              }

              BOOL v88 = v70 + 28;
              id v89 = v70;
              os_unfair_lock_lock(v70 + 28);
              int v90 = v89[8];
              os_unfair_lock_unlock(v88);

              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_existing";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v185 + 42;
              *(_WORD *)&_BYTE buf[22] = 2082;
              v205 = v61;
              *(_WORD *)char v206 = 2082;
              *(void *)&v206[2] = v175;
              uint64_t v207 = 2082;
              v208 = stacka;
              uint64_t v209 = 2082;
              uint64_t v210 = v72;
              __int16 v211 = 2114;
              v212 = v90;
              _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Could not find joinable endpoint flow to clone from",  buf,  0x48u);
            }

            os_log_type_t v87 = 0LL;
LABEL_202:

LABEL_203:
            goto LABEL_204;
          }

          id obj = v28->mode_handler;
          log = obj;
          __int16 v30 = nw_endpoint_handler_copy_connected_flow_handler(v26);
          int v173 = v30;
          if (!v30)
          {
            if ((v26[67] & 0x20) != 0) {
              goto LABEL_178;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v176 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v176, OS_LOG_TYPE_DEBUG))
            {
              if ((v26[67] & 1) != 0) {
                os_log_type_t v73 = "dry-run ";
              }
              else {
                os_log_type_t v73 = "";
              }
              BOOL v74 = nw_endpoint_handler_copy_endpoint(v26);
              os_log_type_t v75 = nw_endpoint_get_logging_description(v74);
              BOOL v76 = v26[30];
              optionsa = (nw_protocol_options_t)v75;
              else {
                BOOL v77 = off_189BBBBF0[v76];
              }
              id v162 = v77;
              os_log_type_t v91 = v26;
              BOOL v92 = (os_unfair_lock_s *)v91;
              os_log_type_t v93 = v26[29];
              stackb = v74;
              __int16 v168 = v73;
              os_log_type_t v94 = "path";
              switch(v93)
              {
                case 0:
                  break;
                case 1:
                  os_log_type_t v94 = "resolver";
                  break;
                case 2:
                  os_log_type_t v94 = nw_endpoint_flow_mode_string(*((void **)v91 + 31));
                  break;
                case 3:
                  os_log_type_t v94 = "proxy";
                  break;
                case 4:
                  os_log_type_t v94 = "fallback";
                  break;
                case 5:
                  os_log_type_t v94 = "transform";
                  break;
                default:
                  os_log_type_t v94 = "unknown-mode";
                  break;
              }

              BOOL v109 = v92 + 28;
              os_log_type_t v110 = v92;
              os_unfair_lock_lock(v92 + 28);
              os_log_type_t v111 = v110[8];
              os_unfair_lock_unlock(v109);

              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_existing";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v185 + 42;
              *(_WORD *)&_BYTE buf[22] = 2082;
              v205 = v168;
              *(_WORD *)char v206 = 2082;
              *(void *)&v206[2] = optionsa;
              uint64_t v207 = 2082;
              v208 = (void *)v162;
              uint64_t v209 = 2082;
              uint64_t v210 = v94;
              __int16 v211 = 2114;
              v212 = v111;
              _os_log_impl( &dword_181A5C000,  v176,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no connected handler, n ot checking for effective proxy config",  buf,  0x48u);
            }

    nw_http_fields_append(*(void **)(a1 + 48), (uint64_t)a2, (uint64_t)v3);
    return 1LL;
  }

  BOOL v71 = *(void *)(a1 + 40);
  os_log_type_t v72 = *(void **)(a1 + 48);
  traffic_class = nw_parameters_get_traffic_class(*(void **)(v71 + 320));
  uint64_t result = 1LL;
  if (traffic_class <= 499)
  {
    if (traffic_class <= 199)
    {
      if (!traffic_class)
      {
        BOOL v74 = nw_http_priority_traffic_class_best_effort;
        os_log_type_t v75 = "u=6";
        goto LABEL_263;
      }

      if (traffic_class != 100) {
        return result;
      }
      BOOL v74 = nw_http_priority_traffic_class_background_system;
    }

    else
    {
      if (traffic_class != 200)
      {
        if (traffic_class == 300)
        {
          BOOL v74 = nw_http_priority_traffic_class_responsive_data;
          os_log_type_t v75 = "u=5";
        }

        else
        {
          if (traffic_class != 400) {
            return result;
          }
          BOOL v74 = nw_http_priority_traffic_class_oam;
          os_log_type_t v75 = "u=4";
        }

        goto LABEL_263;
      }

      BOOL v74 = nw_http_priority_traffic_class_background_user;
    }

    os_log_type_t v75 = "u=7";
    goto LABEL_263;
  }

  if (traffic_class > 699)
  {
    switch(traffic_class)
    {
      case 700:
        BOOL v74 = nw_http_priority_traffic_class_video;
        break;
      case 900:
        BOOL v74 = nw_http_priority_traffic_class_network_control;
        os_log_type_t v75 = "u=0";
        goto LABEL_263;
      case 800:
        BOOL v74 = nw_http_priority_traffic_class_voice;
        break;
      default:
        return result;
    }

    os_log_type_t v75 = "u=1";
    goto LABEL_263;
  }

  if (traffic_class == 500)
  {
    BOOL v74 = nw_http_priority_traffic_class_av_streaming;
    os_log_type_t v75 = "u=3";
  }

  else
  {
    if (traffic_class != 600) {
      return result;
    }
    BOOL v74 = nw_http_priority_traffic_class_responsive_av;
    os_log_type_t v75 = "u=2";
  }

        if (v88) {
          free(v88);
        }
        handle[114] = -1;
        goto LABEL_240;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_pending_stream";
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = v30;
      os_log_type_t v93 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(aBlock) = 16;
      v339[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault((const char *)v93, &aBlock, v339))
      {
        if (aBlock == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v94 = (os_log_s *)gLogObj;
          BOOL v95 = aBlock;
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock)) {
            goto LABEL_212;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_pending_stream";
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v30;
          os_log_type_t v96 = "%{public}s stream %p already in pending list, cannot add again";
          goto LABEL_210;
        }

        if (v339[0] == OS_LOG_TYPE_DEFAULT)
        {
          os_log_type_t v94 = (os_log_s *)__nwlog_obj();
          BOOL v95 = aBlock;
          if (!os_log_type_enabled(v94, (os_log_type_t)aBlock)) {
            goto LABEL_212;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_pending_stream";
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v30;
          os_log_type_t v96 = "%{public}s stream %p already in pending list, cannot add again, backtrace limit exceeded";
          goto LABEL_210;
        }

        os_log_type_t v97 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v94 = (os_log_s *)gLogObj;
        BOOL v95 = aBlock;
        os_log_type_t v98 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock);
        if (v97)
        {
          if (v98)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_pending_stream";
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(void *)&buf[14] = v30;
            *(_WORD *)&_BYTE buf[22] = 2082;
            v344 = (uint64_t)v97;
            _os_log_impl( &dword_181A5C000,  v94,  v95,  "%{public}s stream %p already in pending list, cannot add again, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v97);
          if (!v93) {
            goto LABEL_242;
          }
LABEL_213:
          free(v93);
LABEL_242:
          if ((handle[137] & 2) != 0) {
            goto LABEL_589;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v154 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
            goto LABEL_589;
          }
          uint64_t v155 = handle[115];
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = handle + 116;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v155;
          __int16 v140 = "%{public}s %{public}s%s<i%u> Not reconfiguring stream, no transport mode determined yet";
          os_log_type_t v141 = (os_log_s *)v154;
          __int16 v142 = OS_LOG_TYPE_INFO;
          uint64_t v143 = 38;
          goto LABEL_245;
        }

        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_pending_stream";
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v30;
          os_log_type_t v96 = "%{public}s stream %p already in pending list, cannot add again, no backtrace";
LABEL_210:
          os_log_type_t v134 = v94;
          os_log_type_t v135 = v95;
          __int16 v136 = 22;
LABEL_211:
          _os_log_impl(&dword_181A5C000, v134, v135, v96, buf, v136);
        }
      }

            if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
            {
              if (gLogDatapath)
              {
                os_log_type_t v163 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
                {
                  char v164 = *(void *)(v63 + 88);
                  if (v164) {
                    os_log_type_t v165 = *(_DWORD *)(v164 + 460);
                  }
                  else {
                    os_log_type_t v165 = -1;
                  }
                  v218 = *(void *)(v63 + 64);
                  *(_DWORD *)buf = 136447490;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&_BYTE buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v165;
                  *(_WORD *)&v532[6] = 2048;
                  *(void *)&v532[8] = v218;
                  *(_WORD *)&v532[16] = 2048;
                  *(void *)&v532[18] = v63;
                  _os_log_impl( &dword_181A5C000,  v163,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)",  buf,  0x3Au);
                }
              }
            }
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v78 = *(unsigned int *)(v13 + 456);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = "webtransport_session->pending_stream_count";
          *(_WORD *)&_BYTE buf[22] = 2048;
          v531 = 1LL;
          *(_WORD *)v532 = 2048;
          *(void *)&v532[2] = v78;
          os_log_type_t v79 = (char *)_os_log_send_and_compose_impl();
          iterate_block[0] = 16;
          type[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v79, iterate_block, type))
          {
            if (iterate_block[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v80 = gLogObj;
              os_log_type_t v81 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                BOOL v82 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&_BYTE buf[22] = 2048;
                v531 = 1LL;
                *(_WORD *)v532 = 2048;
                *(void *)&v532[2] = v82;
                os_log_type_t v83 = (os_log_s *)v80;
                os_log_type_t v84 = v81;
                os_log_type_t v85 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_114:
                _os_log_impl(&dword_181A5C000, v83, v84, v85, buf, 0x2Au);
              }
            }

            else if (type[0])
            {
              BOOL v88 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v89 = (os_log_s *)gLogObj;
              int v90 = iterate_block[0];
              os_log_type_t v91 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
              if (v88)
              {
                if (v91)
                {
                  BOOL v92 = *(unsigned int *)(v13 + 456);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  v531 = 1LL;
                  *(_WORD *)v532 = 2048;
                  *(void *)&v532[2] = v92;
                  *(_WORD *)&v532[10] = 2082;
                  *(void *)&v532[12] = v88;
                  _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v88);
                int v64 = v520;
                goto LABEL_115;
              }

              int v64 = v520;
              if (v91)
              {
                os_log_type_t v96 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&_BYTE buf[22] = 2048;
                v531 = 1LL;
                *(_WORD *)v532 = 2048;
                *(void *)&v532[2] = v96;
                os_log_type_t v83 = v89;
                os_log_type_t v84 = v90;
                os_log_type_t v85 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                goto LABEL_114;
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v93 = gLogObj;
              os_log_type_t v94 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                BOOL v95 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&_BYTE buf[22] = 2048;
                v531 = 1LL;
                *(_WORD *)v532 = 2048;
                *(void *)&v532[2] = v95;
                os_log_type_t v83 = (os_log_s *)v93;
                os_log_type_t v84 = v94;
                os_log_type_t v85 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_114;
              }
            }
          }

  __int16 v144 = *(void *)(v12 + 488);
  if (v144)
  {
    if ((*(_DWORD *)(v12 + 864) & 0xFFFFFFFE) == 4 || (*(_WORD *)(v144 + 428) & 0x10) != 0)
    {
      if ((*(_BYTE *)(v12 + 158) & 1) != 0 || !gLogDatapath) {
        goto LABEL_245;
      }
      v193 = (os_log_s *)__nwlog_obj();
      v194 = os_log_type_enabled(v193, OS_LOG_TYPE_DEBUG);
      __int16 v144 = *(void *)(v12 + 488);
      if (v194)
      {
        uint64_t v195 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
        uint64_t v196 = *(_DWORD *)(v12 + 860);
        if (v144) {
          uint64_t v197 = *(_DWORD *)(v144 + 424);
        }
        else {
          uint64_t v197 = 0;
        }
        *(_DWORD *)buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v12 + 74;
        *(_WORD *)&_BYTE buf[22] = 2080;
        *(void *)&_BYTE buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v195;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v196;
        LOWORD(v265) = 1024;
        *(_DWORD *)((char *)&v265 + 2) = v197;
        WORD3(v265) = 2048;
        *((void *)&v265 + 1) = v12;
        os_log_type_t v266 = 2048;
        os_log_type_t v267 = v144;
        _os_log_impl( &dword_181A5C000,  v193,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http connection %p sending disconnected to current stream (%p)",  buf,  0x46u);
        __int16 v144 = *(void *)(v12 + 488);
      }

      if (v144) {
LABEL_245:
      }
        nw_protocol_disconnected(*(void **)(v144 + 48), v144);
      else {
        nw_protocol_disconnected(0LL, 0LL);
      }
    }

    else
    {
      if ((*(_BYTE *)(v12 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v209 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v209, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v210 = *(void *)(v12 + 488);
            __int16 v211 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
            v212 = *(_DWORD *)(v12 + 860);
            if (v210) {
              char v213 = *(_DWORD *)(v210 + 424);
            }
            else {
              char v213 = 0;
            }
            *(_DWORD *)buf = 136448002;
            *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v12 + 74;
            *(_WORD *)&_BYTE buf[22] = 2080;
            *(void *)&_BYTE buf[24] = " ";
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v211;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v212;
            LOWORD(v265) = 1024;
            *(_DWORD *)((char *)&v265 + 2) = v213;
            WORD3(v265) = 2048;
            *((void *)&v265 + 1) = v12;
            os_log_type_t v266 = 2048;
            os_log_type_t v267 = v210;
            _os_log_impl( &dword_181A5C000,  v209,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http connection %p not sending disconnected up to current stream (%p) , input still available",  buf,  0x46u);
          }
        }
      }

      *v13 |= 0x80u;
    }
  }

  else if ((*(_BYTE *)(v12 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v145 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v146 = *(void *)(v12 + 488);
        v147 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
        os_log_type_t v148 = *(_DWORD *)(v12 + 860);
        if (v146) {
          LODWORD(v146) = *(_DWORD *)(v146 + 424);
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v12 + 74;
        *(_WORD *)&_BYTE buf[22] = 2080;
        *(void *)&_BYTE buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v147;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v148;
        LOWORD(v265) = 1024;
        *(_DWORD *)((char *)&v265 + 2) = v146;
        _os_log_impl( &dword_181A5C000,  v145,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> no stream on http connection, just closing",  buf,  0x32u);
      }
    }
  }

                                        goto LABEL_326;
                                      }

                                      if ((_BYTE)v350)
                                      {
                                        v259 = __nw_create_backtrace_string();
                                        if (v259)
                                        {
                                          v193 = (char *)v259;
                                          if (__nwlog_connection_log::onceToken != -1) {
                                            dispatch_once( &__nwlog_connection_log::onceToken,  &__block_literal_global_24_44325);
                                          }
                                          v194 = (os_log_s *)(id)gconnectionLogObj;
                                          v260 = type[0];
                                          if (os_log_type_enabled(v194, type[0]))
                                          {
                                            logj = v194;
                                            v261 = nw_endpoint_handler_get_id_string(v45);
                                            v326 = nw_endpoint_handler_dry_run_string(v45);
                                            os_log_type_t v262 = nw_endpoint_handler_copy_endpoint(v45);
                                            v263 = nw_endpoint_get_logging_description(v262);
                                            v264 = v45;
                                            BOOL v265 = nw_endpoint_handler_state_string(v45);
                                            os_log_type_t v266 = nw_endpoint_handler_mode_string(v45);
                                            os_log_type_t v267 = nw_endpoint_handler_copy_current_path(v264);
                                            *(_DWORD *)buf = 136448002;
                                            v355 = "nw_endpoint_start_tls_while_connected";
                                            v356 = 2082;
                                            v357 = (char *)v261;
                                            v358 = 2082;
                                            v359 = v326;
                                            v360 = 2082;
                                            v361 = (void *)v263;
                                            v362 = 2082;
                                            v363 = v265;
                                            v364 = 2082;
                                            v365 = v266;
                                            v366 = 2114;
                                            v367 = v267;
                                            v368 = 2082;
                                            v369 = v193;
                                            _os_log_impl( &dword_181A5C000,  logj,  v260,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{publ ic}@)] Failed to repair protocol stack: Could not add old input_protocol, dumping backtrace:%{public}s",  buf,  0x52u);

                                            v194 = logj;
                                          }

          os_log_type_t v108 = v207;
          goto LABEL_238;
        }

void nw_protocol_implementation_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v148 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v5 = p_output_handler;
    id v6 = (void **)v5;
    if (handle != &nw_protocol_ref_counted_handle)
    {
      __nwlog_obj();
      os_log_type_t v75 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v141 = "nw_protocol_implementation_disconnect";
      BOOL v76 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v78 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_181A5C000, v77, v78, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if ((_BYTE)v136)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v94 = type[0];
        BOOL v95 = os_log_type_enabled(v77, type[0]);
        if (backtrace_string)
        {
          if (v95)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v141 = "nw_protocol_implementation_disconnect";
            __int16 v142 = 2082;
            uint64_t v143 = (nw_protocol *)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v77,  v94,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_307:
          if (!v76) {
            goto LABEL_129;
          }
          goto LABEL_308;
        }

        if (v95)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl(&dword_181A5C000, v77, v94, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v115 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl( &dword_181A5C000,  v77,  v115,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }

LABEL_259:
  if (v72) {
    free(v72);
  }
}

void sub_181E6D150( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18)
{
  if ((a16 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a15);
  }
  if ((a18 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a17);
  }

  _Unwind_Resume(a1);
}

void nw_protocol_implementation_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v6 = p_output_handler;
    id v7 = v6;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *((void *)v6 + 1);
      if (v8)
      {
        if (*(void *)(v8 + 80))
        {
          if ((v6[405] & 0x80000000) == 0 && gLogDatapath)
          {
            __nwlog_obj();
            os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v7 + 407;
              *(_WORD *)&_BYTE buf[22] = 2080;
              os_log_type_t v80 = " ";
              _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDisconnected from output handler",  buf,  0x20u);
            }
          }

          if (*((void *)v7 + 37))
          {
            *(void *)os_log_type_t type = 0LL;
            if (nw_protocol_implementation_lookup_path_by_protocol( (NWConcrete_nw_protocol_instance *)v7,  a2,  (unint64_t *)type))
            {
              nw_protocol_instance_tear_down_path(v7, *(uint64_t *)type);
            }

            else if ((v7[405] & 0x80000000) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v10 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v7 + 407;
                *(_WORD *)&_BYTE buf[22] = 2080;
                os_log_type_t v80 = " ";
                __int16 v81 = 2048;
                os_log_type_t v82 = a2;
                _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sReceived a disconnected event from an unknown protocol %p",  buf,  0x2Au);
              }
            }

            *(void *)buf = 0LL;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000LL;
            LOBYTE(v80) = 0;
            uint64_t v11 = (char *)*((void *)v7 + 37);
            v72[0] = MEMORY[0x1895F87A8];
            v72[1] = 3221225472LL;
            v72[2] = ___ZL39nw_protocol_implementation_disconnectedP11nw_protocolS0__block_invoke;
            v72[3] = &unk_189BB76C0;
            v72[4] = buf;
            nw_hash_table_apply(v11, (uint64_t)v72);
            int v12 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
            _Block_object_dispose(buf, 8);
            if (v12) {
              goto LABEL_42;
            }
          }

          else
          {
            if (v9) {
              v9(v7, 0LL, 2LL, 1LL);
            }
          }

          v7[404] |= 4u;
          nw_protocol_remove_instance((uint64_t)a1);
          uint64_t v13 = *((void *)v7 + 3);
          if (v13) {
            (*(void (**)(uint64_t, nw_protocol *, uint64_t))(*(void *)v13 + 8LL))(v13, a1, 57LL);
          }
          if (*(_DWORD *)(*((void *)v7 + 1) + 64LL) == 3)
          {
            uint64_t v14 = (char *)*((void *)v7 + 29);
            v71[0] = MEMORY[0x1895F87A8];
            v71[1] = 3221225472LL;
            v71[2] = ___ZL39nw_protocol_implementation_disconnectedP11nw_protocolS0__block_invoke_2;
            v71[3] = &__block_descriptor_40_e23_B16__0__nw_hash_node__8l;
            v71[4] = a1;
            nw_hash_table_apply(v14, (uint64_t)v71);
LABEL_42:

            return;
          }

          default_input_handler = a1->default_input_handler;
          if (default_input_handler)
          {
            BOOL v16 = default_input_handler->handle;
            if (v16 == &nw_protocol_ref_counted_handle)
            {
              callbacks = default_input_handler[1].callbacks;
              if (callbacks) {
                default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
              }
              char v17 = -1;
            }

            else
            {
              char v17 = 0;
            }

            *(void *)os_log_type_t type = default_input_handler;
            char v78 = v17;
            id v19 = a1->handle;
            if (v19 == &nw_protocol_ref_counted_handle)
            {
              int v21 = a1[1].callbacks;
              if (v21) {
                a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v21->add_input_handler + 1);
              }
              char v20 = -1;
            }

            else
            {
              char v20 = 0;
            }

            os_log_type_t v75 = a1;
            char v76 = v20;
            unsigned int v22 = default_input_handler->callbacks;
            if (v22)
            {
              disconnected = (void (*)(nw_protocol *, nw_protocol *))v22->disconnected;
              if (disconnected)
              {
                disconnected(default_input_handler, a1);
                goto LABEL_37;
              }
            }

            __nwlog_obj();
            os_log_type_t v37 = (void *)objc_claimAutoreleasedReturnValue();
            name = default_input_handler->identifier->name;
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
            if (!name) {
              name = "invalid";
            }
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = name;
            *(_WORD *)&_BYTE buf[22] = 2048;
            os_log_type_t v80 = (const char *)default_input_handler;
            os_log_type_t v39 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v74 = OS_LOG_TYPE_ERROR;
            char v73 = 0;
            if (__nwlog_fault(v39, &v74, &v73))
            {
              if (v74 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                os_log_type_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v41 = v74;
                if (os_log_type_enabled(v40, v74))
                {
                  os_log_type_t v42 = default_input_handler->identifier->name;
                  if (!v42) {
                    os_log_type_t v42 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v42;
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  os_log_type_t v80 = (const char *)default_input_handler;
                  _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback",  buf,  0x20u);
                }
              }

              else if (v73)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                os_log_type_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v58 = v74;
                BOOL v59 = os_log_type_enabled(v40, v74);
                if (backtrace_string)
                {
                  if (v59)
                  {
                    uint64_t v60 = default_input_handler->identifier->name;
                    if (!v60) {
                      uint64_t v60 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v60;
                    *(_WORD *)&_BYTE buf[22] = 2048;
                    os_log_type_t v80 = (const char *)default_input_handler;
                    __int16 v81 = 2082;
                    os_log_type_t v82 = (nw_protocol *)backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v40,  v58,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                  }

                  free(backtrace_string);
                  goto LABEL_151;
                }

                if (v59)
                {
                  os_log_type_t v69 = default_input_handler->identifier->name;
                  if (!v69) {
                    os_log_type_t v69 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v69;
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  os_log_type_t v80 = (const char *)default_input_handler;
                  _os_log_impl( &dword_181A5C000,  v40,  v58,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace",  buf,  0x20u);
                }
              }

              else
              {
                __nwlog_obj();
                os_log_type_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v67 = v74;
                if (os_log_type_enabled(v40, v74))
                {
                  os_log_type_t v68 = default_input_handler->identifier->name;
                  if (!v68) {
                    os_log_type_t v68 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v68;
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  os_log_type_t v80 = (const char *)default_input_handler;
                  _os_log_impl( &dword_181A5C000,  v40,  v67,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded",  buf,  0x20u);
                }
              }
            }

void nw_protocol_implementation_link_state(nw_protocol *a1, nw_protocol *a2, void *a3)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (!v5)
  {
    __nwlog_obj();
    int v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_link_state";
    unsigned int v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_link_state";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null link_info", buf, 0xCu);
      }
    }

    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      BOOL v37 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_link_state";
          __int16 v57 = 2082;
          os_log_type_t v58 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v23,  v36,  "%{public}s called with null link_info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_101:
        if (!v22) {
          goto LABEL_27;
        }
LABEL_102:
        free(v22);
        goto LABEL_27;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_link_state";
        _os_log_impl(&dword_181A5C000, v23, v36, "%{public}s called with null link_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_link_state";
        _os_log_impl( &dword_181A5C000,  v23,  v49,  "%{public}s called with null link_info, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E6EE8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v5 = *(void **)(a1 + 40);
    id v6 = (void *)(a1 + 96);
    if (v5 != &nw_protocol_ref_counted_handle) {
      id v6 = 0LL;
    }
    id v7 = v6;
    uint64_t v8 = (char *)v7;
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = v7[1];
      if (v9)
      {
        if (*(void *)(v9 + 80))
        {
          if (!a3)
          {
LABEL_107:

            return;
          }

          if (*(_DWORD *)(v9 + 64) != 3)
          {
LABEL_104:
            uint64_t v48 = *((void *)v8 + 12);
            if (!v48) {
              LODWORD(v48) = -1;
            }
            *a3 = v48;
            unsigned int v49 = a3[1] & 0xFFFFFFFC | (v8[402] >> 7);
            a3[1] = v49;
            a3[1] = v49 & 0xFFFFFFF9 | (*(unsigned __int8 *)(*((void *)v8 + 1) + 184LL) >> 1) & 4;
            goto LABEL_107;
          }

          if (a2)
          {
            uint64_t v10 = *(void *)(a2 + 56);
            if (v10)
            {
              if ((*(_WORD *)(v10 + 84) & 0x800) != 0)
              {
                unsigned int v11 = a3[1] & 0xFFFFFFF8 | 1;
                *a3 = *(_DWORD *)(v10 + 76);
                a3[1] = v11;
                goto LABEL_107;
              }

              goto LABEL_104;
            }

uint64_t nw_protocol_implementation_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v5 = p_output_handler;
    id v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *((void *)v5 + 1);
      if (v7)
      {
        if (*(void *)(v7 + 80))
        {
          if (!a2
            || (output_handler_context = a2->output_handler_context) == 0LL
            || (output_handler_context[42] & 2) == 0)
          {
            uint64_t v9 = (v5[405] >> 3) & 1;
LABEL_11:

            return v9;
          }

uint64_t nw_protocol_implementation_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v126 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle == &nw_protocol_ref_counted_handle) {
      os_log_type_t v14 = &a1[1].output_handler;
    }
    else {
      os_log_type_t v14 = 0LL;
    }
    os_log_type_t v15 = v14;
    char v16 = v15;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v17 = *((void *)v15 + 1);
      if (v17)
      {
        if (*(void *)(v17 + 80))
        {
          char v18 = v15[404];
          if ((v18 & 0x40) != 0)
          {
            v15[404] = v18 & 0xBF;
            nw_protocol_implementation_read((NWConcrete_nw_protocol_instance *)v15, a1->output_handler);
            char v18 = v16[404];
          }

          v16[404] = v18 | 0x20;
          os_log_type_t v19 = a1->handle;
          if (v19 == &nw_protocol_ref_counted_handle) {
            os_log_type_t v20 = p_output_handler;
          }
          else {
            os_log_type_t v20 = 0LL;
          }
          os_log_type_t v21 = v20;
          os_log_type_t v22 = v21;
          if (v19 == &nw_protocol_ref_counted_handle)
          {
            os_log_type_t v23 = v21[1];
            os_log_type_t v24 = (char *)v21;
            if (v23)
            {
              if (v23[1].identifier)
              {
                uint64_t v115 = 0LL;
                os_log_type_t v116 = &v115;
                int v118 = 0;
                uint64_t v117 = 0x2020000000LL;
                if (*(_DWORD *)v23[1].flow_id != 3)
                {
                  os_log_type_t v35 = (nw_frame *)v21[23];
                  if (v35)
                  {
                    unsigned int v36 = *((_DWORD *)v21 + 51);
                    if (v36 >= a3)
                    {
                      if (v36 <= a4 && (unsigned int v37 = *((_DWORD *)v21 + 50), v37 <= a5))
                      {
                        *a6->tqh_last = v35;
                        v21[23]->handle = a6->tqh_last;
                        a6->tqh_last = (nw_frame **)v21[24];
                        v21[23] = 0LL;
                        v21[24] = (nw_protocol *)(v21 + 23);
                        *((_DWORD *)v116 + 6) = v37;
                        v21[25] = 0LL;
                      }

                      else
                      {
                        *(void *)os_log_type_t type = 0LL;
                        uint64_t v102 = (uint64_t)type;
                        uint64_t v103 = 0x2020000000LL;
                        LODWORD(v104) = a5;
                        uint64_t v111 = 0LL;
                        BOOL v112 = &v111;
                        uint64_t v113 = 0x2020000000LL;
                        unsigned int v114 = a4;
                        *(void *)buf = MEMORY[0x1895F87A8];
                        *(void *)&buf[8] = 3221225472LL;
                        *(void *)&buf[16] = ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_279;
                        os_log_type_t v120 = (const char *)&unk_189BB7868;
                        *((void *)&v121 + 1) = type;
                        os_log_type_t v122 = &v111;
                        os_log_type_t v124 = a1;
                        *(void *)&__int128 v121 = v21;
                        os_log_type_t v123 = (nw_protocol *)&v115;
                        os_log_type_t v125 = a6;
                        os_log_type_t v38 = v22[23];
                        do
                        {
                          if (!v38) {
                            break;
                          }
                          output_handler = v38->output_handler;
                          char v40 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                          os_log_type_t v38 = output_handler;
                        }

                        while ((v40 & 1) != 0);

                        _Block_object_dispose(&v111, 8);
                        _Block_object_dispose(type, 8);
                      }

                      goto LABEL_51;
                    }
                  }

void sub_181E719C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v164 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v13 = p_output_handler;
    uint64_t v143 = v13;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v14 = v13;
      uint64_t v15 = *((void *)v13 + 1);
      if (v15)
      {
        if (*(void *)(v15 + 80))
        {
          if (a2)
          {
            if (a6)
            {
              unsigned int v16 = v13[402];
              unsigned int v17 = *((_DWORD *)v13 + 24);
              if (*(_DWORD *)(v15 + 64) == 3)
              {
                uint64_t v18 = a5;
                output_handler_context = a2->output_handler_context;
                if (!output_handler_context)
                {
                  if (v13[405] < 0)
                  {
LABEL_136:
                    uint64_t v30 = 0LL;
                    goto LABEL_137;
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  unsigned int v31 = (os_log_s *)(id)gLogObj;
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446978;
                    uint64_t v151 = "nw_protocol_implementation_get_output_frames";
                    __int16 v152 = 2082;
                    unsigned int v153 = (nw_protocol_identifier *)(v14 + 407);
                    __int16 v154 = 2080;
                    uint64_t v155 = (nw_protocol *)" ";
                    __int16 v156 = 2048;
                    *(void *)v157 = a2;
                    _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p",  buf,  0x2Au);
                  }

                  uint64_t v30 = 0LL;
LABEL_97:
                  os_log_type_t v14 = v143;
LABEL_137:

                  return v30;
                }

                unsigned int v20 = *((unsigned __int16 *)output_handler_context + 42);
                if ((v20 & 0x200) != 0)
                {
                  if ((v13[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    unsigned int v32 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446722;
                      uint64_t v151 = "nw_protocol_implementation_get_output_frames";
                      __int16 v152 = 2082;
                      unsigned int v153 = (nw_protocol_identifier *)(v14 + 407);
                      __int16 v154 = 2080;
                      uint64_t v155 = (nw_protocol *)" ";
                      _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sIgnoring request for output frames from closed flow",  buf,  0x20u);
                    }

                    os_log_type_t v14 = v143;
                  }

                  if (a2->handle == &nw_protocol_ref_counted_handle)
                  {
                    callbacks = a2[1].callbacks;
                    if (callbacks) {
                      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                    }
                    char v33 = -1;
                  }

                  else
                  {
                    char v33 = 0;
                  }

                  *(void *)os_log_type_t type = a2;
                  char v149 = v33;
                  if (*((_UNKNOWN **)v14 - 7) == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v36 = *((void *)v14 - 1);
                    if (v36) {
                      *((void *)v14 - 1) = v36 + 1;
                    }
                    char v35 = -1;
                  }

                  else
                  {
                    char v35 = 0;
                  }

                  __int16 v146 = v14 - 96;
                  char v147 = v35;
                  unsigned int v37 = a2->callbacks;
                  if (v37)
                  {
                    error = (void (*)(nw_protocol *, char *, uint64_t))v37->error;
                    if (error)
                    {
                      error(a2, v14 - 96, 57LL);
LABEL_131:
                      char v35 = v147;
LABEL_132:
                      if ((v35 & 1) != 0) {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)&v146);
                      }
                      if ((v149 & 1) != 0) {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                      }
                      goto LABEL_136;
                    }
                  }

                  __nwlog_obj();
                  os_log_type_t v104 = (void *)objc_claimAutoreleasedReturnValue();
                  identifier = a2->identifier;
                  *(_DWORD *)buf = 136446722;
                  uint64_t v151 = "__nw_protocol_error";
                  if (!identifier) {
                    identifier = (nw_protocol_identifier *)"invalid";
                  }
                  __int16 v152 = 2082;
                  unsigned int v153 = identifier;
                  __int16 v154 = 2048;
                  uint64_t v155 = a2;
                  BOOL v106 = (char *)_os_log_send_and_compose_impl();

                  os_log_type_t v145 = OS_LOG_TYPE_ERROR;
                  char v144 = 0;
                  if (__nwlog_fault(v106, &v145, &v144))
                  {
                    if (v145 == OS_LOG_TYPE_FAULT)
                    {
                      __nwlog_obj();
                      os_log_type_t v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v108 = v145;
                      if (os_log_type_enabled(v107, v145))
                      {
                        BOOL v109 = a2->identifier;
                        if (!v109) {
                          BOOL v109 = (nw_protocol_identifier *)"invalid";
                        }
                        *(_DWORD *)buf = 136446722;
                        uint64_t v151 = "__nw_protocol_error";
                        __int16 v152 = 2082;
                        unsigned int v153 = v109;
                        __int16 v154 = 2048;
                        uint64_t v155 = a2;
                        _os_log_impl( &dword_181A5C000,  v107,  v108,  "%{public}s protocol %{public}s (%p) has invalid error callback",  buf,  0x20u);
                      }

                      goto LABEL_307;
                    }

                    if (!v144)
                    {
                      __nwlog_obj();
                      os_log_type_t v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v131 = v145;
                      if (os_log_type_enabled(v107, v145))
                      {
                        os_log_type_t v132 = a2->identifier;
                        if (!v132) {
                          os_log_type_t v132 = (nw_protocol_identifier *)"invalid";
                        }
                        *(_DWORD *)buf = 136446722;
                        uint64_t v151 = "__nw_protocol_error";
                        __int16 v152 = 2082;
                        unsigned int v153 = v132;
                        __int16 v154 = 2048;
                        uint64_t v155 = a2;
                        _os_log_impl( &dword_181A5C000,  v107,  v131,  "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded",  buf,  0x20u);
                      }

                      goto LABEL_307;
                    }

                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    os_log_type_t v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v122 = v145;
                    BOOL v123 = os_log_type_enabled(v107, v145);
                    if (!backtrace_string)
                    {
                      if (v123)
                      {
                        char v137 = a2->identifier;
                        if (!v137) {
                          char v137 = (nw_protocol_identifier *)"invalid";
                        }
                        *(_DWORD *)buf = 136446722;
                        uint64_t v151 = "__nw_protocol_error";
                        __int16 v152 = 2082;
                        unsigned int v153 = v137;
                        __int16 v154 = 2048;
                        uint64_t v155 = a2;
                        _os_log_impl( &dword_181A5C000,  v107,  v122,  "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace",  buf,  0x20u);
                      }

                      goto LABEL_307;
                    }

                    if (v123)
                    {
                      os_log_type_t v124 = a2->identifier;
                      if (!v124) {
                        os_log_type_t v124 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)buf = 136446978;
                      uint64_t v151 = "__nw_protocol_error";
                      __int16 v152 = 2082;
                      unsigned int v153 = v124;
                      __int16 v154 = 2048;
                      uint64_t v155 = a2;
                      __int16 v156 = 2082;
                      *(void *)v157 = backtrace_string;
                      _os_log_impl( &dword_181A5C000,  v107,  v122,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    goto LABEL_263;
                  }

void sub_181E73614( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
}

uint64_t nw_protocol_implementation_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v5 = p_output_handler;
    id v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *((void *)v5 + 1);
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 80);
        if (v8)
        {
          if (*(void *)(v8 + 64))
          {
            v5[403] |= 0x20u;
            *(void *)buf = 0LL;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000LL;
            uint64_t v57 = -1LL;
            v48[0] = MEMORY[0x1895F87A8];
            v48[1] = 3221225472LL;
            os_log_type_t v49 = (uint64_t (*)(void *))___ZL49nw_protocol_implementation_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
            uint64_t v50 = &unk_189BB7890;
            uint64_t v9 = v5;
            uint64_t v51 = v9;
            uint64_t v52 = buf;
            uint64_t v53 = a2;
            tqh_first = a2->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              unsigned int v11 = (nw_frame *)*((void *)tqh_first + 4);
              char v12 = v49(v48);
              tqh_first = v11;
            }

            while ((v12 & 1) != 0);
            uint64_t v13 = *(OS_nw_endpoint **)(*(void *)&buf[8] + 24LL);
            if (v13 != (OS_nw_endpoint *)-1LL && v13 != v9->preferred_ipv6_address)
            {
              if (v14) {
                v14(v9);
              }
            }

            v6[403] &= ~0x20u;
            nw_protocol_implementation_deliver_output_available(v9);
            uint64_t v15 = nw_protocol_implementation_finalize_pending_frames(v9);

            _Block_object_dispose(buf, 8);
LABEL_16:

            return v15;
          }

          __nwlog_obj();
          unsigned int v29 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
          os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v54 = 0;
          if (__nwlog_fault(v22, &type, &v54))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              int v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v30 = type;
              if (os_log_type_enabled(v23, type))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
                _os_log_impl( &dword_181A5C000,  v23,  v30,  "%{public}s called with null instance->parent_definition->extended_state->handle_outbound",  buf,  0xCu);
              }

void sub_181E74234( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v5 = p_output_handler;
    id v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      parent_definition = v5->parent_definition;
      if (parent_definition)
      {
        if (parent_definition->extended_state)
        {
          nw_protocol_implementation_read(v5, a2);
LABEL_8:

          return;
        }

        __nwlog_obj();
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        BOOL v38 = "nw_protocol_implementation_input_available";
        uint64_t v13 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v35 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v38 = "nw_protocol_implementation_input_available";
            _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_76;
        }

        if (!v35)
        {
          __nwlog_obj();
          os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v38 = "nw_protocol_implementation_input_available";
            _os_log_impl( &dword_181A5C000,  v14,  v34,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v14, type);
        if (!backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v38 = "nw_protocol_implementation_input_available";
            _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_76;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v38 = "nw_protocol_implementation_input_available";
          __int16 v39 = 2082;
          BOOL v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        BOOL v38 = "nw_protocol_implementation_input_available";
        uint64_t v13 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v35 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v17 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v38 = "nw_protocol_implementation_input_available";
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_76;
        }

        if (!v35)
        {
          __nwlog_obj();
          os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v38 = "nw_protocol_implementation_input_available";
            _os_log_impl( &dword_181A5C000,  v14,  v33,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v14, type);
        if (!backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v38 = "nw_protocol_implementation_input_available";
            _os_log_impl( &dword_181A5C000,  v14,  v27,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_76;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v38 = "nw_protocol_implementation_input_available";
          __int16 v39 = 2082;
          BOOL v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v27,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      free(backtrace_string);
      if (!v13) {
        goto LABEL_8;
      }
      goto LABEL_78;
    }

    __nwlog_obj();
    char v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v38 = "nw_protocol_implementation_input_available";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v35)
    {
      int v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v14, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v38 = "nw_protocol_implementation_input_available";
          __int16 v39 = 2082;
          BOOL v40 = v23;
          _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
LABEL_77:
        if (!v13) {
          goto LABEL_8;
        }
LABEL_78:
        free(v13);
        goto LABEL_8;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v38 = "nw_protocol_implementation_input_available";
        _os_log_impl( &dword_181A5C000,  v14,  v32,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E74B44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v116 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v5 = p_output_handler;
    id v6 = v5;
    if (handle != &nw_protocol_ref_counted_handle)
    {
      __nwlog_obj();
      __int16 v56 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_input_finished";
      os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (__nwlog_fault(v11, type, &v104))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v57 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl(&dword_181A5C000, v12, v57, "%{public}s called with null instance", buf, 0xCu);
          }

          goto LABEL_114;
        }

        if (!(_BYTE)v104)
        {
          __nwlog_obj();
          char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v92 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v92,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v69 = type[0];
        BOOL v70 = os_log_type_enabled(v12, type[0]);
        if (!backtrace_string)
        {
          if (v70)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl(&dword_181A5C000, v12, v69, "%{public}s called with null instance, no backtrace", buf, 0xCu);
          }

          goto LABEL_114;
        }

        if (v70)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          __int16 v110 = 2082;
          uint64_t v111 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v69,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
      }

      goto LABEL_115;
    }

    uint64_t v7 = *((void *)v5 + 1);
    if (!v7)
    {
      __nwlog_obj();
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_input_finished";
      os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v59 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl(&dword_181A5C000, v12, v59, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }

        goto LABEL_114;
      }

      if (!(_BYTE)v104)
      {
        __nwlog_obj();
        char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v93 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl( &dword_181A5C000,  v12,  v93,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_114;
      }

      BOOL v71 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v72 = type[0];
      BOOL v73 = os_log_type_enabled(v12, type[0]);
      if (!v71)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl( &dword_181A5C000,  v12,  v72,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
        }

        goto LABEL_114;
      }

      if (v73)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        __int16 v110 = 2082;
        uint64_t v111 = v71;
        _os_log_impl( &dword_181A5C000,  v12,  v72,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_171;
    }

    if (!*(void *)(v7 + 80))
    {
      __nwlog_obj();
      uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_input_finished";
      os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v61 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl( &dword_181A5C000,  v12,  v61,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
        }

        goto LABEL_114;
      }

      if (!(_BYTE)v104)
      {
        __nwlog_obj();
        char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v94 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl( &dword_181A5C000,  v12,  v94,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_114;
      }

      BOOL v71 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v74 = type[0];
      BOOL v75 = os_log_type_enabled(v12, type[0]);
      if (!v71)
      {
        if (v75)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl( &dword_181A5C000,  v12,  v74,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
        }

        goto LABEL_114;
      }

      if (v75)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        __int16 v110 = 2082;
        uint64_t v111 = v71;
        _os_log_impl( &dword_181A5C000,  v12,  v74,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_171;
    }

    if (!a2)
    {
      __nwlog_obj();
      os_log_type_t v62 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_input_finished";
      os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v63 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl(&dword_181A5C000, v12, v63, "%{public}s called with null output_protocol", buf, 0xCu);
        }

        goto LABEL_114;
      }

      if (!(_BYTE)v104)
      {
        __nwlog_obj();
        char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v95 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl( &dword_181A5C000,  v12,  v95,  "%{public}s called with null output_protocol, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_114;
      }

      BOOL v71 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v76 = type[0];
      BOOL v77 = os_log_type_enabled(v12, type[0]);
      if (!v71)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          _os_log_impl( &dword_181A5C000,  v12,  v76,  "%{public}s called with null output_protocol, no backtrace",  buf,  0xCu);
        }

        goto LABEL_114;
      }

      if (v77)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        __int16 v110 = 2082;
        uint64_t v111 = v71;
        _os_log_impl( &dword_181A5C000,  v12,  v76,  "%{public}s called with null output_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_171;
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        __int16 v110 = 2048;
        uint64_t v111 = v6;
        _os_log_impl(&dword_181A5C000, v64, OS_LOG_TYPE_DEBUG, "%{public}s Instance %p input finished", buf, 0x16u);
      }

      uint64_t v7 = *((void *)v6 + 1);
    }

    int v8 = *(_DWORD *)(v7 + 64);
    if (v8 == 2)
    {
      os_log_type_t v14 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v7 + 80) + 128LL);
      if (v14)
      {
        if ((v14(v6, -1LL, 1LL) & 1) != 0) {
          goto LABEL_117;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v104) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v16 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        if (!(_BYTE)v104)
        {
          __nwlog_obj();
          char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v46 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v46,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        BOOL v40 = __nw_create_backtrace_string();
        if (!v40)
        {
          __nwlog_obj();
          char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v51 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v51,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, no backtrace",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        os_log_type_t v31 = (char *)v40;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v32 = (os_log_s *)(id)gLogObj;
        os_log_type_t v41 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          __int16 v110 = 2082;
          uint64_t v111 = v31;
          _os_log_impl( &dword_181A5C000,  v32,  v41,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v104) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v22 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null instance->parent_definition->stop",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        if (!(_BYTE)v104)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v43 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v43,  "%{public}s called with null instance->parent_definition->stop, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        os_log_type_t v34 = __nw_create_backtrace_string();
        if (!v34)
        {
          __nwlog_obj();
          char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v48 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v48,  "%{public}s called with null instance->parent_definition->stop, no backtrace",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        os_log_type_t v31 = (char *)v34;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v32 = (os_log_s *)(id)gLogObj;
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          __int16 v110 = 2082;
          uint64_t v111 = v31;
          _os_log_impl( &dword_181A5C000,  v32,  v35,  "%{public}s called with null instance->parent_definition->stop, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      goto LABEL_83;
    }

    if (v8 == 3)
    {
      uint64_t v9 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v7 + 80) + 128LL);
      if (!v9)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v104) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v20 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null instance->parent_definition->stop",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        if (!(_BYTE)v104)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v42 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v42,  "%{public}s called with null instance->parent_definition->stop, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        BOOL v30 = __nw_create_backtrace_string();
        if (!v30)
        {
          __nwlog_obj();
          char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v47 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v47,  "%{public}s called with null instance->parent_definition->stop, no backtrace",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        os_log_type_t v31 = (char *)v30;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v32 = (os_log_s *)(id)gLogObj;
        os_log_type_t v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          __int16 v110 = 2082;
          uint64_t v111 = v31;
          _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null instance->parent_definition->stop, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_83;
      }

      if ((v9(v6, -1LL, 1LL) & 1) != 0) {
        goto LABEL_117;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v10 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_input_finished";
      os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (__nwlog_fault(v11, type, &v104))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v13 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS", buf, 0xCu);
          }

LABEL_244:
    if (v80) {
      free(v80);
    }
    goto LABEL_55;
  }

  __nwlog_obj();
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v109 = "nw_protocol_implementation_input_finished";
  uint64_t v53 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v104) = 0;
  if (__nwlog_fault(v53, type, &v104))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v55 = type[0];
      if (os_log_type_enabled(v54, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)v104)
    {
      uint64_t v65 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v66 = type[0];
      BOOL v67 = os_log_type_enabled(v54, type[0]);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_input_finished";
          __int16 v110 = 2082;
          uint64_t v111 = v65;
          _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v65);
        goto LABEL_215;
      }

      if (v67)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        _os_log_impl(&dword_181A5C000, v54, v66, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v91 = type[0];
      if (os_log_type_enabled(v54, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v109 = "nw_protocol_implementation_input_finished";
        _os_log_impl( &dword_181A5C000,  v54,  v91,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        if (v92) {
          free(v92);
        }
        os_log_type_t v20 = v106;
        goto LABEL_160;
      }

      if (!(_BYTE)v111)
      {
        os_log_type_t v93 = (os_log_s *)__nwlog_obj();
        os_log_type_t v94 = type[0];
        if (os_log_type_enabled(v93, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_set_config_epoch_value";
          os_log_type_t v95 = "%{public}s called with null masque->context, backtrace limit exceeded";
          goto LABEL_243;
        }

        goto LABEL_244;
      }

      os_log_type_t v100 = (char *)__nw_create_backtrace_string();
      os_log_type_t v93 = (os_log_s *)__nwlog_obj();
      os_log_type_t v94 = type[0];
      os_log_type_t v101 = os_log_type_enabled(v93, type[0]);
      if (!v100)
      {
        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_set_config_epoch_value";
          os_log_type_t v95 = "%{public}s called with null masque->context, no backtrace";
          goto LABEL_243;
        }

        goto LABEL_244;
      }

      if (v101)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_masque_set_config_epoch_value";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v100;
        char v102 = "%{public}s called with null masque->context, dumping backtrace:%{public}s";
LABEL_228:
        _os_log_impl(&dword_181A5C000, v93, v94, v102, buf, 0x16u);
      }
    }

    free(v100);
    goto LABEL_244;
  }

  if (v110) {
    free(v110);
  }
  return 0LL;
}

    if (v94) {
      free(v94);
    }
    goto LABEL_246;
  }

  if (*(_DWORD *)(v26 + 12) < 0x13u || (*(_BYTE *)v26 & 0xFE) != 0x12)
  {
LABEL_246:
    v294 = 0LL;
    goto LABEL_247;
  }

  v294 = nw_array_create();
  uint64_t v27 = (*(_DWORD *)(v26 + 12) - 18);
  uint64_t v28 = v27 - 5;
  if (v27 == 5) {
    goto LABEL_247;
  }
  os_log_type_t v29 = 0LL;
  BOOL v30 = 0LL;
  v292 = v26 + 34;
  v291 = v26 + 39;
  v293 = v26 + 35;
  while (1)
  {
    if (v27 < 5 || v28 < v29)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v39 = (id)gLogObj;
      *(_DWORD *)out = 136446722;
      *(void *)&out[4] = "nw_necp_buffer_get_tlv_value";
      *(_WORD *)&out[12] = 2048;
      *(void *)&out[14] = v29;
      *(_WORD *)&out[22] = 2048;
      *(void *)&out[24] = v27;
      BOOL v40 = (char *)_os_log_send_and_compose_impl();

      v413[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v40, v413, &type))
      {
        if (v413[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v41 = (os_log_s *)(id)gLogObj;
          os_log_type_t v42 = v413[0];
          if (os_log_type_enabled(v41, (os_log_type_t)v413[0]))
          {
            *(_DWORD *)out = 136446722;
            *(void *)&out[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&out[12] = 2048;
            *(void *)&out[14] = v29;
            *(_WORD *)&out[22] = 2048;
            *(void *)&out[24] = v27;
            _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu",  out,  0x20u);
          }
        }

        else if (type)
        {
          os_log_type_t v44 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v41 = (os_log_s *)(id)gLogObj;
          os_log_type_t v45 = v413[0];
          os_log_type_t v46 = os_log_type_enabled(v41, (os_log_type_t)v413[0]);
          if (v44)
          {
            if (v46)
            {
              *(_DWORD *)out = 136446978;
              *(void *)&out[4] = "nw_necp_buffer_get_tlv_value";
              *(_WORD *)&out[12] = 2048;
              *(void *)&out[14] = v29;
              *(_WORD *)&out[22] = 2048;
              *(void *)&out[24] = v27;
              *(_WORD *)&out[32] = 2082;
              *(void *)&out[34] = v44;
              _os_log_impl( &dword_181A5C000,  v41,  v45,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, dumping backtrace:%{public}s",  out,  0x2Au);
            }

            free(v44);
            if (!v40) {
              goto LABEL_83;
            }
            goto LABEL_82;
          }

          if (v46)
          {
            *(_DWORD *)out = 136446722;
            *(void *)&out[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&out[12] = 2048;
            *(void *)&out[14] = v29;
            *(_WORD *)&out[22] = 2048;
            *(void *)&out[24] = v27;
            _os_log_impl( &dword_181A5C000,  v41,  v45,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, no backtrace",  out,  0x20u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v41 = (os_log_s *)(id)gLogObj;
          os_log_type_t v51 = v413[0];
          if (os_log_type_enabled(v41, (os_log_type_t)v413[0]))
          {
            *(_DWORD *)out = 136446722;
            *(void *)&out[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&out[12] = 2048;
            *(void *)&out[14] = v29;
            *(_WORD *)&out[22] = 2048;
            *(void *)&out[24] = v27;
            _os_log_impl( &dword_181A5C000,  v41,  v51,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, backtrace limit exceeded",  out,  0x20u);
          }
        }
      }

      if (!v40)
      {
LABEL_83:
        os_log_type_t v43 = 0;
        uint64_t v52 = 0LL;
        uint64_t v53 = 0LL;
        goto LABEL_120;
      }

void sub_181E76898( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18)
{
  if ((a16 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a15);
  }
  if ((a18 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a17);
  }

  _Unwind_Resume(a1);
}

void nw_protocol_implementation_input_flush(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v4 = p_output_handler;
    id v5 = v4;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (v6)
      {
        if (*(void *)(v6 + 80))
        {
LABEL_7:

          return;
        }

        __nwlog_obj();
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_protocol_implementation_input_flush";
        char v12 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v34 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v37 = "nw_protocol_implementation_input_flush";
            _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }
        }

        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v28 = type;
          BOOL v29 = os_log_type_enabled(v13, type);
          if (backtrace_string)
          {
            if (v29)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v37 = "nw_protocol_implementation_input_flush";
              __int16 v38 = 2082;
              os_log_type_t v39 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
LABEL_76:
            if (!v12) {
              goto LABEL_7;
            }
LABEL_77:
            free(v12);
            goto LABEL_7;
          }

          if (v29)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v37 = "nw_protocol_implementation_input_flush";
            _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v37 = "nw_protocol_implementation_input_flush";
            _os_log_impl( &dword_181A5C000,  v13,  v33,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }
        }

void nw_protocol_implementation_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v116 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v5 = p_output_handler;
    uint64_t v6 = (void **)v5;
    if (handle != &nw_protocol_ref_counted_handle)
    {
      __nwlog_obj();
      __int16 v56 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_output_finished";
      os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (__nwlog_fault(v18, type, &v104))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v57 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl(&dword_181A5C000, v19, v57, "%{public}s called with null instance", buf, 0xCu);
          }

          goto LABEL_108;
        }

        if (!(_BYTE)v104)
        {
          __nwlog_obj();
          id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v92 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v92,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v69 = type[0];
        BOOL v70 = os_log_type_enabled(v19, type[0]);
        if (!backtrace_string)
        {
          if (v70)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl(&dword_181A5C000, v19, v69, "%{public}s called with null instance, no backtrace", buf, 0xCu);
          }

          goto LABEL_108;
        }

        if (v70)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          __int16 v110 = 2082;
          uint64_t v111 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v69,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
      }

      goto LABEL_109;
    }

    uint64_t v7 = (void *)*((void *)v5 + 1);
    if (!v7)
    {
      __nwlog_obj();
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_output_finished";
      os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v59 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl(&dword_181A5C000, v19, v59, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }

        goto LABEL_108;
      }

      if (!(_BYTE)v104)
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v93 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v93,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      BOOL v71 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v72 = type[0];
      BOOL v73 = os_log_type_enabled(v19, type[0]);
      if (!v71)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v72,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      if (v73)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_output_finished";
        __int16 v110 = 2082;
        uint64_t v111 = v71;
        _os_log_impl( &dword_181A5C000,  v19,  v72,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_165;
    }

    if (!v7[10])
    {
      __nwlog_obj();
      uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_output_finished";
      os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v61 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v61,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      if (!(_BYTE)v104)
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v94 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v94,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      BOOL v71 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v74 = type[0];
      BOOL v75 = os_log_type_enabled(v19, type[0]);
      if (!v71)
      {
        if (v75)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v74,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      if (v75)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_output_finished";
        __int16 v110 = 2082;
        uint64_t v111 = v71;
        _os_log_impl( &dword_181A5C000,  v19,  v74,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_165;
    }

    if (!a2)
    {
      __nwlog_obj();
      os_log_type_t v62 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_output_finished";
      os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v63 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl(&dword_181A5C000, v19, v63, "%{public}s called with null input_protocol", buf, 0xCu);
        }

        goto LABEL_108;
      }

      if (!(_BYTE)v104)
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v95 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v95,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      BOOL v71 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v76 = type[0];
      BOOL v77 = os_log_type_enabled(v19, type[0]);
      if (!v71)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v76,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      if (v77)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_output_finished";
        __int16 v110 = 2082;
        uint64_t v111 = v71;
        _os_log_impl( &dword_181A5C000,  v19,  v76,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_165;
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        BOOL v109 = "nw_protocol_implementation_output_finished";
        __int16 v110 = 2048;
        uint64_t v111 = (char *)v6;
        _os_log_impl(&dword_181A5C000, v64, OS_LOG_TYPE_DEBUG, "%{public}s Instance %p output finished", buf, 0x16u);
      }

      uint64_t v7 = v6[1];
    }

    int v8 = *((_DWORD *)v7 + 16);
    if (v8 == 2)
    {
      os_log_type_t v16 = *(uint64_t (**)(void **, uint64_t, uint64_t))(v7[10] + 128LL);
      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v25 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        BOOL v109 = "nw_protocol_implementation_output_finished";
        os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v104) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v19 = (os_log_s *)(id)gLogObj;
          os_log_type_t v26 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v26,  "%{public}s called with null instance->parent_definition->stop",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        if (!(_BYTE)v104)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v19 = (os_log_s *)(id)gLogObj;
          os_log_type_t v45 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v45,  "%{public}s called with null instance->parent_definition->stop, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        __int16 v38 = __nw_create_backtrace_string();
        if (!v38)
        {
          __nwlog_obj();
          id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v49 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v49,  "%{public}s called with null instance->parent_definition->stop, no backtrace",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        os_log_type_t v35 = (char *)v38;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v36 = (os_log_s *)(id)gLogObj;
        os_log_type_t v39 = type[0];
        if (os_log_type_enabled(v36, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          __int16 v110 = 2082;
          uint64_t v111 = v35;
          _os_log_impl( &dword_181A5C000,  v36,  v39,  "%{public}s called with null instance->parent_definition->stop, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_82;
      }

      if ((v16(v6, -1LL, 2LL) & 1) != 0) {
        goto LABEL_111;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v17 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_output_finished";
      os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (__nwlog_fault(v18, type, &v104))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v19 = (os_log_s *)(id)gLogObj;
          os_log_type_t v20 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        if (!(_BYTE)v104)
        {
          __nwlog_obj();
          id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v47 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v47,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        os_log_type_t v42 = __nw_create_backtrace_string();
        if (!v42)
        {
          __nwlog_obj();
          id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v51 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v51,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, no backtrace",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        os_log_type_t v35 = (char *)v42;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v36 = (os_log_s *)(id)gLogObj;
        os_log_type_t v43 = type[0];
        if (os_log_type_enabled(v36, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          BOOL v109 = "nw_protocol_implementation_output_finished";
          __int16 v110 = 2082;
          uint64_t v111 = v35;
          _os_log_impl( &dword_181A5C000,  v36,  v43,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_82;
      }

      goto LABEL_109;
    }

    if (v8 == 3)
    {
      uint64_t v9 = *(uint64_t (**)(NWConcrete_nw_protocol_instance *, uint64_t, uint64_t))(v7[10] + 128LL);
      if (v9)
      {
        os_log_type_t v10 = v6;
        if (nw_protocol_definition_get_message_is_stream(v6[1])
          && *(nw_protocol **)&v10[-1].log_str[41] == a2)
        {
          uint64_t v11 = -2LL;
        }

        else
        {
          uint64_t v11 = (uint64_t)a2;
        }

        char v12 = v9(v10, v11, 2LL);
        if (gLogDatapath) {
          char v13 = v12;
        }
        else {
          char v13 = 1;
        }
        if ((v13 & 1) == 0)
        {
          __nwlog_obj();
          os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v15 = nw_protocol_flow_for_protocol(v10, (uint64_t)a2);
            *(_DWORD *)buf = 136446466;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            __int16 v110 = 2048;
            uint64_t v111 = (char *)v15;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s Flow %llx elected to defer stop, ignoring output_finished anyway",  buf,  0x16u);
          }
        }

        goto LABEL_111;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v23 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      BOOL v109 = "nw_protocol_implementation_output_finished";
      os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (__nwlog_fault(v18, type, &v104))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v19 = (os_log_s *)(id)gLogObj;
          os_log_type_t v24 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null instance->parent_definition->stop",  buf,  0xCu);
          }

void sub_181E78D4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18)
{
  if ((a16 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a15);
  }
  if ((a18 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a17);
  }

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_copy_info(void *a1, int a2, uint64_t a3)
{
  uint64_t v106 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v6 = (void *)a1[5];
    uint64_t v7 = a1 + 12;
    if (v6 != &nw_protocol_ref_counted_handle) {
      uint64_t v7 = 0LL;
    }
    int v8 = v7;
    uint64_t v9 = (char *)v8;
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v10 = v8[1];
      if (v10)
      {
        uint64_t v11 = *(void **)(v10 + 80);
        if (v11)
        {
          if (a2 <= 253)
          {
            if (a2 == 4)
            {
              id v19 = (void *)a1[4];
              if (v19)
              {
                uint64_t v20 = v19[3];
                if (v20)
                {
                  uint64_t v21 = *(uint64_t (**)(void))(v20 + 224);
                  if (v21)
                  {
                    char v22 = (void *)v19[5];
                    if (v22 == &nw_protocol_ref_counted_handle)
                    {
                      uint64_t v41 = v19[11];
                      if (v41) {
                        v19[11] = v41 + 1;
                      }
                      char v23 = -1;
                    }

                    else
                    {
                      char v23 = 0;
                    }

                    *(void *)buf = v19;
                    buf[8] = v23;
                    uint64_t v36 = v21();
                    if (v22 == &nw_protocol_ref_counted_handle) {
                      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    }
                    if (v36) {
                      goto LABEL_187;
                    }
                    uint64_t v11 = *(void **)(*((void *)v9 + 1) + 80LL);
                  }
                }
              }

              os_log_type_t v42 = (uint64_t (*)(char *))v11[25];
              if (v42)
              {
                uint64_t v40 = v42(v9);
                goto LABEL_62;
              }

              goto LABEL_186;
            }

            if (a2 == 5)
            {
              char v12 = (void *)a1[4];
              if (v12 && (uint64_t v13 = v12[3]) != 0 && (v14 = *(uint64_t (**)(void))(v13 + 224)) != 0LL)
              {
                uint64_t v15 = (void *)v12[5];
                if (v15 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v39 = v12[11];
                  if (v39) {
                    v12[11] = v39 + 1;
                  }
                  char v16 = -1;
                }

                else
                {
                  char v16 = 0;
                }

                *(void *)buf = v12;
                buf[8] = v16;
                uint64_t v34 = v14();
                if (v15 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
                if (v35) {
                  goto LABEL_52;
                }
              }

              else
              {
                uint64_t v34 = 0LL;
                os_log_type_t v35 = (uint64_t (*)(char *, uint64_t, uint64_t))v11[24];
                if (v35)
                {
LABEL_52:
                  uint64_t v40 = v35(v9, v34, a3);
LABEL_62:
                  uint64_t v36 = v40;
LABEL_187:

                  return v36;
                }
              }

void sub_181E79D34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_notify( void *a1, nw_protocol *a2, unsigned int a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v142 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v9 = (void *)a1[5];
    uint64_t v10 = a1 + 12;
    if (v9 == &nw_protocol_ref_counted_handle) {
      uint64_t v11 = a1 + 12;
    }
    else {
      uint64_t v11 = 0LL;
    }
    char v12 = v11;
    uint64_t v13 = (char *)v12;
    if (v9 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v14 = v12[1];
      if (v14)
      {
        if (*(void *)(v14 + 80))
        {
          if (a2)
          {
            if ((*((char *)v12 + 405) & 0x80000000) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v15 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                if (a3 > 0x1A) {
                  char v16 = "unknown";
                }
                else {
                  char v16 = off_189BBE330[a3];
                }
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_notify";
                __int16 v136 = 2082;
                char v137 = v13 + 407;
                __int16 v138 = 2080;
                char v139 = " ";
                __int16 v140 = 2082;
                os_log_type_t v141 = v16;
                _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sreceived notification %{public}s",  buf,  0x2Au);
              }
            }

            switch(a3)
            {
              case 6u:
                os_log_type_t v26 = *(void (**)(char *))(*(void *)(*((void *)v13 + 1) + 80LL) + 160LL);
                if (!v26) {
                  goto LABEL_77;
                }
                v26(v13);
                goto LABEL_122;
              case 7u:
                if (*(_DWORD *)(*((void *)v13 + 1) + 64LL) == 3)
                {
                  BOOL node = nw_hash_table_get_node(*((void *)v13 + 29), (uint64_t)a2, 8LL);
                  if (node)
                  {
                    callbacks = a2->callbacks;
                    if (callbacks)
                    {
                      supports_external_data = (uint64_t (*)(nw_protocol *))callbacks->supports_external_data;
                      if (supports_external_data)
                      {
                        uint64_t v30 = node;
                        handle = a2->handle;
                        if (handle == &nw_protocol_ref_counted_handle)
                        {
                          os_log_type_t v60 = a2[1].callbacks;
                          if (v60) {
                            a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v60->add_input_handler + 1);
                          }
                          char v32 = -1;
                        }

                        else
                        {
                          char v32 = 0;
                        }

                        *(void *)buf = a2;
                        buf[8] = v32;
                        int v61 = supports_external_data(a2);
                        if (handle == &nw_protocol_ref_counted_handle) {
                          nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                        }
                        if (v61) {
                          __int16 v62 = 1024;
                        }
                        else {
                          __int16 v62 = 0;
                        }
                        *(_WORD *)(v30 + 84) = *(_WORD *)(v30 + 84) & 0xFBFF | v62;
                      }
                    }
                  }
                }

                else if (*((nw_protocol **)v13 - 6) == a2)
                {
                  char v46 = a2->callbacks;
                  if (v46)
                  {
                    os_log_type_t v47 = (uint64_t (*)(nw_protocol *))v46->supports_external_data;
                    if (v47)
                    {
                      uint64_t v48 = a2->handle;
                      if (v48 == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v65 = a2[1].callbacks;
                        if (v65) {
                          a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v65->add_input_handler + 1);
                        }
                        char v49 = -1;
                      }

                      else
                      {
                        char v49 = 0;
                      }

                      *(void *)buf = a2;
                      buf[8] = v49;
                      int v66 = v47(a2);
                      if (v48 == &nw_protocol_ref_counted_handle) {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                      }
                      if (v66) {
                        char v67 = 2;
                      }
                      else {
                        char v67 = 0;
                      }
                      char v64 = v13[403] & 0xFD | v67;
                      goto LABEL_121;
                    }
                  }
                }

                goto LABEL_122;
              case 0xDu:
              case 0xFu:
              case 0x10u:
                id v17 = (void *)a1[4];
                if (!v17) {
                  goto LABEL_122;
                }
                uint64_t v18 = v17[3];
                if (!v18) {
                  goto LABEL_122;
                }
                id v19 = *(void (**)(void))(v18 + 160);
                if (!v19) {
                  goto LABEL_122;
                }
                uint64_t v20 = (void *)v17[5];
                if (v20 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v22 = v17[11];
                  if (v22) {
                    v17[11] = v22 + 1;
                  }
                  char v21 = -1;
                }

                else
                {
                  char v21 = 0;
                }

                *(void *)buf = v17;
                buf[8] = v21;
                char v23 = a2->handle;
                if (v23 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v25 = a2[1].callbacks;
                  if (v25) {
                    a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v25->add_input_handler + 1);
                  }
                  char v24 = -1;
                }

                else
                {
                  char v24 = 0;
                }

                *(void *)os_log_type_t type = a2;
                char v134 = v24;
                v19();
                if (v23 == &nw_protocol_ref_counted_handle)
                {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  if (v20 == &nw_protocol_ref_counted_handle) {
LABEL_34:
                  }
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }

                else if (v20 == &nw_protocol_ref_counted_handle)
                {
                  goto LABEL_34;
                }

void nw_protocol_implementation_error(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v89 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v7 = p_output_handler;
    int v8 = v7;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *((void *)v7 + 1);
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 80);
        if (v10)
        {
          if (a2)
          {
            if (!(_DWORD)a3)
            {
              if ((v7[405] & 0x80000000) == 0 && gLogDatapath)
              {
                __nwlog_obj();
                uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_error";
                  __int16 v83 = 2082;
                  BOOL v84 = v8 + 407;
                  __int16 v85 = 2080;
                  os_log_type_t v86 = " ";
                  _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSupressing error 0",  buf,  0x20u);
                }
              }

              goto LABEL_37;
            }

            if (*(void *)(v10 + 72))
            {
              *(void *)buf = 0LL;
              nw_protocol_implementation_lookup_path_by_protocol( (NWConcrete_nw_protocol_instance *)v7,  a2,  (unint64_t *)buf);
              uint64_t v12 = *(void *)buf;
              posix_error = nw_error_create_posix_error(a3);
              v11(v8, -1LL, v12, posix_error);
            }

            if ((v8[402] & 0x20) != 0)
            {
LABEL_37:

              return;
            }

            if (*(_DWORD *)(*((void *)v8 + 1) + 64LL) == 3)
            {
              uint64_t v14 = (char *)*((void *)v8 + 29);
              v73[0] = MEMORY[0x1895F87A8];
              v73[1] = 3221225472LL;
              v73[2] = ___ZL32nw_protocol_implementation_errorP11nw_protocolS0_i_block_invoke;
              v73[3] = &unk_189BB78B8;
              BOOL v74 = v8;
              int v75 = a3;
              nw_hash_table_apply(v14, (uint64_t)v73);

              goto LABEL_37;
            }

            uint64_t v16 = *((void *)v8 - 6);
            if (v16)
            {
              if (*(_UNKNOWN **)(v16 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v18 = *(void *)(v16 + 88);
                if (v18) {
                  *(void *)(v16 + 88) = v18 + 1;
                }
                char v17 = -1;
              }

              else
              {
                char v17 = 0;
              }

              *(void *)os_log_type_t type = v16;
              char v81 = v17;
              if (*((_UNKNOWN **)v8 - 7) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v20 = *((void *)v8 - 1);
                if (v20) {
                  *((void *)v8 - 1) = v20 + 1;
                }
                char v19 = -1;
              }

              else
              {
                char v19 = 0;
              }

              os_log_type_t v78 = v8 - 96;
              char v79 = v19;
              uint64_t v21 = *(void *)(v16 + 24);
              if (v21)
              {
                uint64_t v22 = *(void (**)(uint64_t, char *, uint64_t))(v21 + 56);
                if (v22)
                {
                  v22(v16, v8 - 96, a3);
                  char v19 = v79;
LABEL_33:
                  if ((v19 & 1) != 0) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)&v78);
                  }
                  if ((v81 & 1) != 0) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
                  goto LABEL_37;
                }
              }

              __nwlog_obj();
              os_log_type_t v50 = (void *)objc_claimAutoreleasedReturnValue();
              char v51 = *(const char **)(v16 + 16);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_error";
              if (!v51) {
                char v51 = "invalid";
              }
              __int16 v83 = 2082;
              BOOL v84 = (void *)v51;
              __int16 v85 = 2048;
              os_log_type_t v86 = (const char *)v16;
              uint64_t v52 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v77 = OS_LOG_TYPE_ERROR;
              char v76 = 0;
              if (__nwlog_fault(v52, &v77, &v76))
              {
                if (v77 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v54 = v77;
                  if (os_log_type_enabled(v53, v77))
                  {
                    char v55 = *(const char **)(v16 + 16);
                    if (!v55) {
                      char v55 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_error";
                    __int16 v83 = 2082;
                    BOOL v84 = (void *)v55;
                    __int16 v85 = 2048;
                    os_log_type_t v86 = (const char *)v16;
                    _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s protocol %{public}s (%p) has invalid error callback",  buf,  0x20u);
                  }
                }

                else if (v76)
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v64 = v77;
                  BOOL v65 = os_log_type_enabled(v53, v77);
                  if (backtrace_string)
                  {
                    if (v65)
                    {
                      int v66 = *(const char **)(v16 + 16);
                      if (!v66) {
                        int v66 = "invalid";
                      }
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_error";
                      __int16 v83 = 2082;
                      BOOL v84 = (void *)v66;
                      __int16 v85 = 2048;
                      os_log_type_t v86 = (const char *)v16;
                      __int16 v87 = 2082;
                      os_log_type_t v88 = backtrace_string;
                      _os_log_impl( &dword_181A5C000,  v53,  v64,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    free(backtrace_string);
                    goto LABEL_160;
                  }

                  if (v65)
                  {
                    os_log_type_t v71 = *(const char **)(v16 + 16);
                    if (!v71) {
                      os_log_type_t v71 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_error";
                    __int16 v83 = 2082;
                    BOOL v84 = (void *)v71;
                    __int16 v85 = 2048;
                    os_log_type_t v86 = (const char *)v16;
                    _os_log_impl( &dword_181A5C000,  v53,  v64,  "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace",  buf,  0x20u);
                  }
                }

                else
                {
                  __nwlog_obj();
                  uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v69 = v77;
                  if (os_log_type_enabled(v53, v77))
                  {
                    os_log_type_t v70 = *(const char **)(v16 + 16);
                    if (!v70) {
                      os_log_type_t v70 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_error";
                    __int16 v83 = 2082;
                    BOOL v84 = (void *)v70;
                    __int16 v85 = 2048;
                    os_log_type_t v86 = (const char *)v16;
                    _os_log_impl( &dword_181A5C000,  v53,  v69,  "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded",  buf,  0x20u);
                  }
                }
              }

void sub_181E7C934( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, char a22)
{
  if ((a20 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a19);
  }
  if ((a22 & 1) != 0) {
    nw::release_if_needed<nw_protocol *>(&a21);
  }

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_updated_path(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (a1)
  {
    uint64_t v6 = *(void **)(a1 + 40);
    uint64_t v7 = (void *)(a1 + 96);
    if (v6 != &nw_protocol_ref_counted_handle) {
      uint64_t v7 = 0LL;
    }
    int v8 = v7;
    uint64_t v9 = v8;
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v10 = v8[1];
      if (v10)
      {
        if (*(void *)(v10 + 80))
        {
          if (v5)
          {
            if ((*((char *)v8 + 405) & 0x80000000) == 0 && gLogDatapath)
            {
              __nwlog_obj();
              os_log_type_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                os_log_type_t v62 = "nw_protocol_implementation_updated_path";
                __int16 v63 = 2082;
                os_log_type_t v64 = (char *)v9 + 407;
                __int16 v65 = 2080;
                int v66 = " ";
                _os_log_impl(&dword_181A5C000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s", buf, 0x20u);
              }
            }

            objc_storeStrong((id *)v9 + 36, a3);
            if (*(void *)(*(void *)(v9[1] + 80LL) + 224LL))
            {
              uint64_t v11 = (void *)v9[35];
              if (v11)
              {
                *(void *)os_log_type_t type = 0LL;
                int v59 = 0;
                int ctl_command = nw_path_flow_registration_get_ctl_command(v5, v11, &type[4], type, &v59);
                int v13 = *(_DWORD *)&type[4] == 5 ? ctl_command : 0;
                if (v13 == 1)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v14 = (os_log_s *)(id)gLogObj;
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446466;
                    os_log_type_t v62 = "nw_protocol_implementation_updated_path";
                    __int16 v63 = 1024;
                    LODWORD(v64) = *(_DWORD *)type;
                    _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s receive PRC_MSGSIZE %u",  buf,  0x12u);
                  }

                  if (v9[37])
                  {
                    v56[0] = MEMORY[0x1895F87A8];
                    v56[1] = 3221225472LL;
                    v56[2] = ___ZL39nw_protocol_implementation_updated_pathP11nw_protocolS0_PU21objcproto10OS_nw_path8NSObject_block_invoke;
                    v56[3] = &unk_189BB7908;
                    os_log_type_t v57 = v9;
                    int v58 = *(_DWORD *)type;
                    nw_path_enumerate_interface_options(v5, v56);
                  }

                  else
                  {
                    (*(void (**)(void *, void, void))(*(void *)(v9[1] + 80LL) + 224LL))( v9,  0LL,  *(unsigned int *)type);
                  }
                }
              }
            }

            uint64_t v15 = (unsigned __int8 *)v5;
            unsigned int v16 = v15[474];

            uint64_t v17 = *(void *)(v9[1] + 80LL);
            uint64_t v18 = *(void (**)(void *, void))(v17 + 152);
            if (v18)
            {
              v18(v9, (v16 >> 1) & 1);
              uint64_t v17 = *(void *)(v9[1] + 80LL);
            }

            if (*(void *)(v17 + 168))
            {
              char v19 = v15;
              unsigned int v20 = v15[474];

              char v21 = *((_BYTE *)v9 + 402);
              if (((v20 >> 5) & 1) == ((v21 & 1) == 0))
              {
                *((_BYTE *)v9 + 402) = v21 & 0xFE | ((v20 & 0x20) >> 5);
                (*(void (**)(void *, BOOL))(*(void *)(v9[1] + 80LL) + 168LL))(v9, (v20 & 0x20) != 0);
              }
            }

            nw_protocol_instance_update_available_paths((NWConcrete_nw_protocol_instance *)v9);
            uint64_t v22 = 1LL;
LABEL_27:

            goto LABEL_28;
          }

          __nwlog_obj();
          os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_protocol_implementation_updated_path";
          uint64_t v29 = (char *)_os_log_send_and_compose_impl();

          type[4] = OS_LOG_TYPE_ERROR;
          type[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v29, &type[4], type))
          {
            if (type[4] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v37 = type[4];
              if (os_log_type_enabled(v30, type[4]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v62 = "nw_protocol_implementation_updated_path";
                _os_log_impl(&dword_181A5C000, v30, v37, "%{public}s called with null path", buf, 0xCu);
              }

void sub_181E7D6E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v178 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v6 = p_output_handler;
    uint64_t v7 = v6;
    if (handle != &nw_protocol_ref_counted_handle)
    {
      __nwlog_obj();
      char v76 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v169 = "nw_protocol_implementation_connect";
      os_log_type_t v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v77 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_181A5C000, v53, v77, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_151;
      }

      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v107 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v107,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v87 = type[0];
      BOOL v88 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v88)
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_181A5C000, v53, v87, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_151;
      }

      if (v88)
      {
        *(_DWORD *)buf = 136446466;
        v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        uint64_t v171 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v53,  v87,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_143;
    }

    uint64_t v8 = *((void *)v6 + 1);
    if (!v8)
    {
      __nwlog_obj();
      os_log_type_t v78 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v169 = "nw_protocol_implementation_connect";
      os_log_type_t v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v79 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_181A5C000, v53, v79, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }

        goto LABEL_151;
      }

      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v108 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v108,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v89 = type[0];
      BOOL v90 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v90)
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v89,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      if (v90)
      {
        *(_DWORD *)buf = 136446466;
        v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        uint64_t v171 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v53,  v89,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_143;
    }

    if (!*(void *)(v8 + 80))
    {
      __nwlog_obj();
      os_log_type_t v80 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v169 = "nw_protocol_implementation_connect";
      os_log_type_t v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v81 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v81,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v109 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v109,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v91 = type[0];
      BOOL v92 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v91,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      if (v92)
      {
        *(_DWORD *)buf = 136446466;
        v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        uint64_t v171 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v53,  v91,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_143;
    }

    if (!a2)
    {
      __nwlog_obj();
      os_log_type_t v82 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v169 = "nw_protocol_implementation_connect";
      os_log_type_t v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v83 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_181A5C000, v53, v83, "%{public}s called with null input_protocol", buf, 0xCu);
        }

        goto LABEL_151;
      }

      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v110 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v110,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v93 = type[0];
      BOOL v94 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v94)
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v93,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      if (v94)
      {
        *(_DWORD *)buf = 136446466;
        v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        uint64_t v171 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v53,  v93,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_143;
    }

    if (a1->output_handler != a1)
    {
      if ((v6[402] & 0x20) == 0)
      {
        if ((v6[405] & 0x80000000) == 0 && gLogDatapath)
        {
          __nwlog_obj();
          os_log_type_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v169 = "nw_protocol_implementation_connect";
            __int16 v170 = 2082;
            uint64_t v171 = v7 + 407;
            __int16 v172 = 2080;
            int v173 = (nw_protocol *)" ";
            _os_log_impl(&dword_181A5C000, v95, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sConnect", buf, 0x20u);
          }

          uint64_t v8 = *((void *)v7 + 1);
        }

        if (*(_DWORD *)(v8 + 64) == 3)
        {
          output_handler_context = a2->output_handler_context;
          int v10 = v7[405];
          if (output_handler_context)
          {
            if ((v10 & 0x80000000) == 0 && gLogDatapath)
            {
              __nwlog_obj();
              os_log_type_t v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v124 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v7, (uint64_t)a2);
                *(_DWORD *)buf = 136446978;
                v169 = "nw_protocol_implementation_connect";
                __int16 v170 = 2082;
                uint64_t v171 = v7 + 407;
                __int16 v172 = 2080;
                int v173 = (nw_protocol *)" ";
                __int16 v174 = 2048;
                BOOL v175 = (nw_protocol *)v124;
                _os_log_impl( &dword_181A5C000,  v123,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRequested connect from flow %llx",  buf,  0x2Au);
              }
            }

            output_handler_context[42] |= 4u;
            output_handler = a1->output_handler;
            if (output_handler)
            {
              uint64_t v12 = output_handler->handle;
              if (v12 == &nw_protocol_ref_counted_handle)
              {
                callbacks = output_handler[1].callbacks;
                if (callbacks) {
                  output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                }
                char v13 = -1;
              }

              else
              {
                char v13 = 0;
              }

              *(void *)os_log_type_t type = output_handler;
              char v167 = v13;
              BOOL v41 = a1->handle;
              if (v41 == &nw_protocol_ref_counted_handle)
              {
                os_log_type_t v43 = a1[1].callbacks;
                if (v43) {
                  a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v43->add_input_handler + 1);
                }
                char v42 = -1;
              }

              else
              {
                char v42 = 0;
              }

              *(void *)os_log_type_t v163 = a1;
              char v164 = v42;
              BOOL v44 = output_handler->callbacks;
              if (v44)
              {
                connect = (void (*)(nw_protocol *, nw_protocol *))v44->connect;
                if (connect)
                {
                  connect(output_handler, a1);
LABEL_90:
                  if (v41 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)v163);
                  }
                  if (v12 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
LABEL_94:
                  if (output_handler_context == a2->output_handler_context)
                  {
                    __int16 v49 = output_handler_context[42];
                    if ((v49 & 0x20) != 0)
                    {
                      if ((v7[405] & 0x80000000) == 0 && gLogDatapath)
                      {
                        __nwlog_obj();
                        uint64_t v151 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)buf = 136446722;
                          v169 = "nw_protocol_implementation_connect";
                          __int16 v170 = 2082;
                          uint64_t v171 = v7 + 407;
                          __int16 v172 = 2080;
                          int v173 = (nw_protocol *)" ";
                          _os_log_impl( &dword_181A5C000,  v151,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDelivering deferred connected event",  buf,  0x20u);
                        }

                        __int16 v49 = output_handler_context[42];
                      }

                      output_handler_context[42] = v49 & 0xFFDF;
                      unint64_t v50 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v7, (uint64_t)a2);
                      nw_protocol_implementation_report_connected((NWConcrete_nw_protocol_instance *)v7, a1, a2, v50);
                    }
                  }

                  else if ((v7[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    BOOL v46 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                    {
                      os_log_type_t v47 = a2->output_handler_context;
                      *(_DWORD *)buf = 136446978;
                      v169 = "nw_protocol_implementation_connect";
                      if (v47) {
                        BOOL v48 = "changed";
                      }
                      else {
                        BOOL v48 = "freed";
                      }
                      __int16 v170 = 2082;
                      uint64_t v171 = v7 + 407;
                      __int16 v172 = 2080;
                      int v173 = (nw_protocol *)" ";
                      __int16 v174 = 2082;
                      BOOL v175 = (nw_protocol *)v48;
                      _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%soutput_handler_context %{public}s, no deferrred connected event",  buf,  0x2Au);
                    }
                  }

                  goto LABEL_131;
                }
              }

              __nwlog_obj();
              os_log_type_t v102 = (void *)objc_claimAutoreleasedReturnValue();
              name = output_handler->identifier->name;
              *(_DWORD *)buf = 136446722;
              v169 = "__nw_protocol_connect";
              if (!name) {
                name = "invalid";
              }
              __int16 v170 = 2082;
              uint64_t v171 = (char *)name;
              __int16 v172 = 2048;
              int v173 = output_handler;
              int v161 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v165 = OS_LOG_TYPE_ERROR;
              char v162 = 0;
              if (__nwlog_fault(v161, &v165, &v162))
              {
                if (v165 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  os_log_type_t v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v157 = v165;
                  if (os_log_type_enabled(v104, v165))
                  {
                    uint64_t v105 = output_handler->identifier->name;
                    if (!v105) {
                      uint64_t v105 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    v169 = "__nw_protocol_connect";
                    __int16 v170 = 2082;
                    uint64_t v171 = (char *)v105;
                    __int16 v172 = 2048;
                    int v173 = output_handler;
                    _os_log_impl( &dword_181A5C000,  v104,  v157,  "%{public}s protocol %{public}s (%p) has invalid connect callback",  buf,  0x20u);
                  }
                }

                else
                {
                  if (v162)
                  {
                    int v126 = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    __int16 v158 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v156 = v165;
                    BOOL v127 = os_log_type_enabled(v158, v165);
                    if (v126)
                    {
                      if (v127)
                      {
                        unsigned int v128 = output_handler->identifier->name;
                        if (!v128) {
                          unsigned int v128 = "invalid";
                        }
                        *(_DWORD *)buf = 136446978;
                        v169 = "__nw_protocol_connect";
                        __int16 v170 = 2082;
                        uint64_t v171 = (char *)v128;
                        __int16 v172 = 2048;
                        int v173 = output_handler;
                        __int16 v174 = 2082;
                        BOOL v175 = (nw_protocol *)v126;
                        _os_log_impl( &dword_181A5C000,  v158,  v156,  "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                      }

                      free(v126);
                    }

                    else
                    {
                      if (v127)
                      {
                        __int16 v150 = output_handler->identifier->name;
                        if (!v150) {
                          __int16 v150 = "invalid";
                        }
                        *(_DWORD *)buf = 136446722;
                        v169 = "__nw_protocol_connect";
                        __int16 v170 = 2082;
                        uint64_t v171 = (char *)v150;
                        __int16 v172 = 2048;
                        int v173 = output_handler;
                        _os_log_impl( &dword_181A5C000,  v158,  v156,  "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace",  buf,  0x20u);
                      }
                    }

                    goto LABEL_342;
                  }

                  __nwlog_obj();
                  os_log_type_t v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v159 = v165;
                  if (os_log_type_enabled(v104, v165))
                  {
                    char v144 = output_handler->identifier->name;
                    if (!v144) {
                      char v144 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    v169 = "__nw_protocol_connect";
                    __int16 v170 = 2082;
                    uint64_t v171 = (char *)v144;
                    __int16 v172 = 2048;
                    int v173 = output_handler;
                    _os_log_impl( &dword_181A5C000,  v104,  v159,  "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded",  buf,  0x20u);
                  }
                }
              }

LABEL_358:
            if (v120) {
              free(v120);
            }
            goto LABEL_94;
          }

          if ((v10 & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v31 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446978;
              v169 = "nw_protocol_implementation_connect";
              __int16 v170 = 2082;
              uint64_t v171 = v7 + 407;
              __int16 v172 = 2080;
              int v173 = (nw_protocol *)" ";
              __int16 v174 = 2048;
              BOOL v175 = a2;
              _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p",  buf,  0x2Au);
            }

      if (v221) {
        free(v221);
      }
      goto LABEL_279;
    }

    goto LABEL_281;
  }

  v115();
  v212 = (void *)objc_claimAutoreleasedReturnValue();
  __nwlog_obj();
  os_log_type_t v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v116, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&_BYTE buf[12] = 2112;
    *(void *)&buf[14] = v212;
    _os_log_impl(&dword_181A5C000, v116, OS_LOG_TYPE_INFO, "%{public}s QUIC protocol peer path %@", buf, 0x16u);
  }

  *(void *)__int16 v242 = 0LL;
  *(void *)&v242[8] = v242;
  *(void *)&v242[16] = 0x2020000000LL;
  BOOL v117 = calloc(1uLL, 0x10uLL);
  os_log_type_t v118 = v219;
  if (v117)
  {
LABEL_192:
    os_log_type_t v243 = v117;
    v232[0] = MEMORY[0x1895F87A8];
    v232[1] = 3221225472LL;
    v232[2] = ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke_36;
    v232[3] = &unk_189BC5008;
    os_log_type_t v119 = v92;
    unsigned int v233 = v119;
    char v234 = v242;
    nw_path_enumerate_interface_options(v212, v232);
    int is_null = uuid_is_null(*(const unsigned __int8 **)(*(void *)&v242[8] + 24LL));
    if (is_null)
    {
      __nwlog_obj();
      BOOL v120 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v120, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
        _os_log_impl( &dword_181A5C000,  v120,  OS_LOG_TYPE_INFO,  "%{public}s Did not find a matching interface",  buf,  0xCu);
      }

      goto LABEL_248;
    }

    BOOL v120 = (os_log_s *)nw_path_copy_flow_registration(v118, (uint64_t)v210);
    if (v10 && (*(_DWORD *)buf = 0, (BOOL v127 = (const void *)nw_frame_unclaimed_bytes((uint64_t)v10, buf)) != 0LL))
    {
      uint64_t v207 = dispatch_data_create(v127, *(unsigned int *)buf, 0LL, 0LL);
      nw_frame_claim((uint64_t)v10, v128, *(int *)buf, 0);
      char v129 = v207;
    }

    else
    {
      char v129 = 0LL;
    }

    v208 = v129;
    BOOL v131 = nw_interface_option_details_create(v119[5], *(_OWORD **)(*(void *)&v242[8] + 24LL), logc, 0, v129, -1);
    char v206 = v131;
    if (v131)
    {
      nw_path_flow_registration_add_extra_interface_option(v120, v131);
    }

    else
    {
      uint64_t v204 = v120;
      __nwlog_obj();
      char v132 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v133 = v119[5];
        char v134 = *(void *)(*(void *)&v242[8] + 24LL);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v133;
        *(_WORD *)&_BYTE buf[22] = 1042;
        *(_DWORD *)&_BYTE buf[24] = 16;
        *(_WORD *)&buf[28] = 2098;
        *(void *)&buf[30] = v134;
        _os_log_impl( &dword_181A5C000,  v132,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to create interface option details with %@ [%{public,uuid_t}.16P]",  buf,  0x26u);
      }

      BOOL v120 = v204;
    }

    os_log_type_t v135 = nw_path_flow_registration_copy_path(v120);
    os_log_type_t v136 = v210[3];
    if (v136)
    {
      char v137 = *(void (**)(void *, void, BOOL))(v136 + 168);
      if (v137)
      {
        v137(v210, v210[6], v135);
LABEL_247:

LABEL_248:
        os_log_type_t v138 = *(void **)(*(void *)&v242[8] + 24LL);
        if (v138)
        {
          free(v138);
          *(void *)(*(void *)&v242[8] + 24LL) = 0LL;
        }

        if (!is_null)
        {
          __nwlog_obj();
          int v173 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v173, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
            _os_log_impl( &dword_181A5C000,  v173,  OS_LOG_TYPE_INFO,  "%{public}s QUIC migration handled packet",  buf,  0xCu);
          }

          nw_frame_finalize((uint64_t)v10);
          _Block_object_dispose(v242, 8);

          goto LABEL_316;
        }

        _Block_object_dispose(v242, 8);
        uint64_t v111 = v211;
        goto LABEL_252;
      }
    }

    id v189 = __nwlog_obj();
    os_log_type_t v190 = (const char *)v210[2];
    if (!v190) {
      os_log_type_t v190 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v190;
    LODWORD(v200) = 22;
    os_log_type_t v199 = buf;
    BOOL v191 = (void *)v189;
    v205 = (char *)_os_log_send_and_compose_impl();

    nw_endpoint_t v231 = OS_LOG_TYPE_ERROR;
    v230 = 0;
    if (__nwlog_fault(v205, &v231, &v230))
    {
      if (v231 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v192 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v201 = v231;
        if (os_log_type_enabled(v192, v231))
        {
          v193 = (const char *)v210[2];
          if (!v193) {
            v193 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v193;
          _os_log_impl( &dword_181A5C000,  v192,  v201,  "%{public}s protocol %{public}s has invalid updated_path callback",  buf,  0x16u);
        }
      }

      else
      {
        if (v230)
        {
          v194 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v202 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          HIDWORD(v200) = v231;
          uint64_t v195 = os_log_type_enabled(v202, v231);
          if (v194)
          {
            if (v195)
            {
              uint64_t v196 = (const char *)v210[2];
              if (!v196) {
                uint64_t v196 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v196;
              *(_WORD *)&_BYTE buf[22] = 2082;
              *(void *)&_BYTE buf[24] = v194;
              _os_log_impl( &dword_181A5C000,  v202,  BYTE4(v200),  "%{public}s protocol %{public}s has invalid updated_path callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v194);
          }

          else
          {
            if (v195)
            {
              uint64_t v198 = (const char *)v210[2];
              if (!v198) {
                uint64_t v198 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v198;
              _os_log_impl( &dword_181A5C000,  v202,  BYTE4(v200),  "%{public}s protocol %{public}s has invalid updated_path callback, no backtrace",  buf,  0x16u);
            }
          }

          goto LABEL_377;
        }

        __nwlog_obj();
        os_log_type_t v192 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v203 = v231;
        if (os_log_type_enabled(v192, v231))
        {
          uint64_t v197 = (const char *)v210[2];
          if (!v197) {
            uint64_t v197 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v197;
          _os_log_impl( &dword_181A5C000,  v192,  v203,  "%{public}s protocol %{public}s has invalid updated_path callback, backtrace limit exceeded",  buf,  0x16u);
        }
      }
    }

LABEL_350:
        if (v112) {
          free(v112);
        }
        goto LABEL_131;
      }

      if (*(_DWORD *)(v8 + 64) != 3) {
        goto LABEL_131;
      }
      uint64_t v18 = a2->output_handler_context;
      int v19 = v6[405];
      if (!v18)
      {
        if (v19 < 0) {
          goto LABEL_78;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v31 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          uint64_t v171 = v7 + 407;
          __int16 v172 = 2080;
          int v173 = (nw_protocol *)" ";
          __int16 v174 = 2048;
          BOOL v175 = a2;
          _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p",  buf,  0x2Au);
        }

        goto LABEL_48;
      }

      if ((v19 & 0x80000000) == 0 && gLogDatapath)
      {
        __nwlog_obj();
        os_log_type_t v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          uint64_t v171 = v7 + 407;
          __int16 v172 = 2080;
          int v173 = (nw_protocol *)" ";
          __int16 v174 = 2048;
          BOOL v175 = (nw_protocol *)nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v7, (uint64_t)a2);
          _os_log_impl( &dword_181A5C000,  v125,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sConnect from flow %llx",  buf,  0x2Au);
        }
      }

      __int16 v20 = v18[42];
      __int16 v21 = v20 | 4;
      v18[42] = v20 | 4;
      if ((v20 & 8) != 0)
      {
        if ((v20 & 0x10) != 0)
        {
          __int16 v21 = v20 | 0x24;
          v18[42] = v20 | 0x24;
        }

        if ((v21 & 0x20) == 0) {
          goto LABEL_131;
        }
        goto LABEL_125;
      }

      if (*(void *)(*(void *)(*((void *)v7 + 1) + 80LL) + 120LL))
      {
        uint64_t v22 = a2->handle;
        if (v22 == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v55 = a2[1].callbacks;
          if (v55) {
            a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v55->add_input_handler + 1);
          }
          *(void *)os_log_type_t type = a2;
          char v23 = v167 | 1;
        }

        else
        {
          *(void *)os_log_type_t type = a2;
          char v23 = v167 & 0xFE;
        }

        char v167 = v23;
        os_log_type_t v56 = a2->callbacks;
        if (v56)
        {
          get_parameters = (void (*)(nw_protocol *))v56->get_parameters;
          if (get_parameters)
          {
            get_parameters(a2);
            int v58 = (void *)objc_claimAutoreleasedReturnValue();
            if (v22 != &nw_protocol_ref_counted_handle) {
              goto LABEL_118;
            }
            goto LABEL_117;
          }
        }

        __nwlog_obj();
        char v132 = (void *)objc_claimAutoreleasedReturnValue();
        identifier = a2->identifier;
        *(_DWORD *)buf = 136446722;
        v169 = "__nw_protocol_get_parameters";
        if (!identifier) {
          identifier = (nw_protocol_identifier *)"invalid";
        }
        __int16 v170 = 2082;
        uint64_t v171 = (char *)identifier;
        __int16 v172 = 2048;
        int v173 = a2;
        char v134 = (char *)_os_log_send_and_compose_impl();

        v163[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v165 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v134, v163, &v165))
        {
          if (v163[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v136 = v163[0];
            if (os_log_type_enabled(v135, v163[0]))
            {
              char v137 = a2->identifier;
              if (!v137) {
                char v137 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              v169 = "__nw_protocol_get_parameters";
              __int16 v170 = 2082;
              uint64_t v171 = (char *)v137;
              __int16 v172 = 2048;
              int v173 = a2;
              _os_log_impl( &dword_181A5C000,  v135,  v136,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback",  buf,  0x20u);
            }

          if (!v42) {
            goto LABEL_385;
          }
LABEL_351:
          os_log_type_t v152 = (char *)v42;
          goto LABEL_384;
        }

        char v221 = -[NWConcrete_nw_authentication_credential initWithType:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_authentication_credential),  v54);
        nw_authentication_credential_set_persistence(v221, v56);
        if (v54 == 1)
        {
          nw_authentication_credential_set_username(v221, v55);
          nw_authentication_credential_set_password(v221, v76);
        }

        if (!(_DWORD)v108)
        {
          BOOL v113 = v221;
          goto LABEL_386;
        }

        os_log_type_t v112 = v108;
        BOOL v113 = v221;
        break;
      case 17:
        if ((_DWORD)v12 == 16)
        {
          os_log_type_t v37 = objects;
          if (!objects) {
            os_log_type_t v37 = (xpc_object_t *)xpc_array_create(0LL, 0LL);
          }
          objects = v37;
          xpc_array_set_uuid(v37, 0xFFFFFFFFFFFFFFFFLL, (const unsigned __int8 *)v22);
        }

        continue;
      case 18:
        if (!v22[(v12 - 1)])
        {
          BOOL v46 = v228;
          if (!v228) {
            BOOL v46 = xpc_array_create(0LL, 0LL);
          }
          uint64_t v228 = v46;
          xpc_array_set_string(v46, 0xFFFFFFFFFFFFFFFFLL, v22);
        }

        continue;
      default:
        continue;
    }

    do
    {
      BOOL v115 = *v109++;
      os_log_type_t v114 = v115;
      char v13 = v108 != 0LL;
      os_log_type_t v108 = v108 - 1LL;
      if (!v13 || HIDWORD(v108))
      {
        os_log_type_t v116 = v108;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v117 = (id)gLogObj;
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_authentication_credential_create_from_tlv";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = "result_length";
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&_BYTE buf[24] = 1LL;
        *(_WORD *)&buf[32] = 2048;
        *(void *)&buf[34] = v108;
        os_log_type_t v118 = (char *)_os_log_send_and_compose_impl();

        v245[0] = 16;
        v244 = 0;
        if ((__nwlog_fault(v118, v245, &v244) & 1) == 0) {
          goto LABEL_274;
        }
        if (v245[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v119 = (os_log_s *)(id)gLogObj;
          BOOL v120 = v245[0];
          if (os_log_type_enabled(v119, (os_log_type_t)v245[0]))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_authentication_credential_create_from_tlv";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "result_length";
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(void *)&_BYTE buf[24] = 1LL;
            *(_WORD *)&buf[32] = 2048;
            *(void *)&buf[34] = v108;
            _os_log_impl( &dword_181A5C000,  v119,  v120,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
          }
        }

        else
        {
          if (v244)
          {
            os_log_type_t v121 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v122 = (os_log_s *)(id)gLogObj;
            os_log_type_t v123 = v245[0];
            uint64_t v124 = os_log_type_enabled(v122, (os_log_type_t)v245[0]);
            if (v121)
            {
              if (v124)
              {
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_authentication_credential_create_from_tlv";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "result_length";
                *(_WORD *)&_BYTE buf[22] = 2048;
                *(void *)&_BYTE buf[24] = 1LL;
                *(_WORD *)&buf[32] = 2048;
                *(void *)&buf[34] = v116;
                *(_WORD *)&buf[42] = 2082;
                *(void *)&buf[44] = v121;
                _os_log_impl( &dword_181A5C000,  v122,  v123,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              BOOL v113 = v221;
              free(v121);
              if (!v118) {
                goto LABEL_276;
              }
              goto LABEL_275;
            }

            if (v124)
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_authentication_credential_create_from_tlv";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "result_length";
              *(_WORD *)&_BYTE buf[22] = 2048;
              *(void *)&_BYTE buf[24] = 1LL;
              *(_WORD *)&buf[32] = 2048;
              *(void *)&buf[34] = v116;
              _os_log_impl( &dword_181A5C000,  v122,  v123,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace",  buf,  0x2Au);
            }

            BOOL v113 = v221;
LABEL_274:
            if (!v118)
            {
LABEL_276:
              LODWORD(v108) = 0;
              goto LABEL_277;
            }

  _Block_object_dispose(&v212, 8);
  _Block_object_dispose(&v216, 8);
  _Block_object_dispose(&v220, 8);
  _Block_object_dispose(&v224, 8);
  _Block_object_dispose(&v228, 8);
  _Block_object_dispose(&v232, 8);
  _Block_object_dispose(&v236, 8);
  _Block_object_dispose(&type, 8);
  _Block_object_dispose(&v244, 8);
  _Block_object_dispose(out, 8);
LABEL_351:

  v169 = v119;
  if (nw_path_endpoint_is_always_satisfied(v169->endpoint))
  {
    BOOL v175 = 0;
    __int16 v176 = "Endpoint is always satisfied";
    uint64_t v177 = 1;
    goto LABEL_358;
  }

  if (nw_parameters_are_valid(v169->parameters))
  {
    if (nw_path_network_is_satisfied_update_reason(v169, 1LL))
    {
      LOBYTE(length[0]) = 0;
      if (nw_path_agents_are_satisfied_update_reason(v169, 1, 0, 0, (BOOL *)length))
      {
        v169->status = 1;
        nw_path_set_reason(v169, 0, "Path is satisfied", v178, v179, v180, v181, v182, (char)v196);
        goto LABEL_359;
      }

      uint64_t v195 = LOBYTE(length[0]) == 0;
LABEL_381:
      if (v195) {
        v194 = 2;
      }
      else {
        v194 = 3;
      }
    }

    else
    {
      LOBYTE(length[0]) = 0;
      if (v169->reason == 3)
      {
        updated = nw_path_agents_are_satisfied_update_reason(v169, 1, 1, 1, (BOOL *)length);
        v194 = 2;
        if (!updated)
        {
          uint64_t v195 = LOBYTE(length[0]) == 0;
          goto LABEL_381;
        }
      }

      else
      {
        v194 = 2;
      }
    }

    v169->status = v194;
  }

  else
  {
    uint64_t v177 = 0;
    __int16 v176 = "Parameters are invalid";
    BOOL v175 = 14;
LABEL_358:
    v169->status = v177;
    nw_path_set_reason(v169, v175, v176, v170, v171, v172, v173, v174, (char)v196);
  }

LABEL_369:
            goto LABEL_370;
          }

          if (v165 == OS_LOG_TYPE_DEFAULT)
          {
            __nwlog_obj();
            os_log_type_t v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v153 = v163[0];
            if (os_log_type_enabled(v135, v163[0]))
            {
              __int16 v154 = a2->identifier;
              if (!v154) {
                __int16 v154 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              v169 = "__nw_protocol_get_parameters";
              __int16 v170 = 2082;
              uint64_t v171 = (char *)v154;
              __int16 v172 = 2048;
              int v173 = a2;
              _os_log_impl( &dword_181A5C000,  v135,  v153,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded",  buf,  0x20u);
            }

            goto LABEL_369;
          }

          __int16 v146 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v160 = v163[0];
          BOOL v147 = os_log_type_enabled(v135, v163[0]);
          if (!v146)
          {
            if (v147)
            {
              uint64_t v155 = a2->identifier;
              if (!v155) {
                uint64_t v155 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              v169 = "__nw_protocol_get_parameters";
              __int16 v170 = 2082;
              uint64_t v171 = (char *)v155;
              __int16 v172 = 2048;
              int v173 = a2;
              _os_log_impl( &dword_181A5C000,  v135,  v160,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace",  buf,  0x20u);
            }

            goto LABEL_369;
          }

          if (v147)
          {
            uint64_t v148 = a2->identifier;
            if (!v148) {
              uint64_t v148 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446978;
            v169 = "__nw_protocol_get_parameters";
            __int16 v170 = 2082;
            uint64_t v171 = (char *)v148;
            __int16 v172 = 2048;
            int v173 = a2;
            __int16 v174 = 2082;
            BOOL v175 = (nw_protocol *)v146;
            _os_log_impl( &dword_181A5C000,  v135,  v160,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v146);
        }

    free(v247);
    if (!v71) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }

  if (!v290)
  {
    __nwlog_obj();
    uint64_t v252 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    os_log_type_t v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v253 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v233, v253, "%{public}s called with null parameters", buf, 0xCu);
      }

LABEL_370:
        if (v134) {
          free(v134);
        }
        int v58 = 0LL;
        if (v22 != &nw_protocol_ref_counted_handle)
        {
LABEL_118:
          if (v58)
          {
            int v59 = nw_parameters_copy_protocol_options(v58, v7, 0LL);
            objc_storeStrong((id *)v7 + 7, v59);
            os_log_type_t v60 = (void *)*((void *)v18 + 5);
            *((void *)v18 + 5) = v59;
          }

          v18[42] |= 8u;
          int v61 = *(void (**)(uint64_t *, uint64_t, void))(*(void *)(*((void *)v7 + 1) + 80LL) + 120LL);
          os_log_type_t v62 = v7;
          if (nw_protocol_definition_get_message_is_stream(*((void **)v7 + 1))
            && (nw_protocol *)*(v62 - 6) == a2)
          {
            uint64_t v63 = -2LL;
          }

          else
          {
            uint64_t v63 = (uint64_t)a2;
          }

          v61(v62, v63, v18[42] & 1);
          if (!nw_hash_table_get_node(v62[29], (uint64_t)a2, 8LL))
          {
            if ((v7[405] & 0x80000000) == 0)
            {
              __nwlog_obj();
              uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446978;
                v169 = "nw_protocol_implementation_connect";
                __int16 v170 = 2082;
                uint64_t v171 = (char *)v62 + 407;
                __int16 v172 = 2080;
                int v173 = (nw_protocol *)" ";
                __int16 v174 = 2048;
                BOOL v175 = a2;
                _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sinput_protocol %p no longer exists in flows_table",  buf,  0x2Au);
              }
            }

            goto LABEL_78;
          }

          __int16 v21 = v18[42];
          if ((v21 & 0x20) != 0)
          {
LABEL_125:
            if ((v7[405] & 0x80000000) == 0 && gLogDatapath)
            {
              __nwlog_obj();
              os_log_type_t v145 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                v169 = "nw_protocol_implementation_connect";
                __int16 v170 = 2082;
                uint64_t v171 = v7 + 407;
                __int16 v172 = 2080;
                int v173 = (nw_protocol *)" ";
                _os_log_impl( &dword_181A5C000,  v145,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDelivering deferred connected event",  buf,  0x20u);
              }

              __int16 v21 = v18[42];
            }

            v18[42] = v21 & 0xFFDF;
            os_log_type_t v64 = v7;
            if (nw_protocol_definition_get_message_is_stream(*((void **)v7 + 1))
              && *(nw_protocol **)&v64[-1].log_str[41] == a2)
            {
              unint64_t v65 = -2LL;
            }

            else
            {
              unint64_t v65 = (unint64_t)a2;
            }

            nw_protocol_implementation_report_connected(v64, a1, a2, v65);
          }

      uint64_t v217 = *(_DWORD *)(v11 + 352);
      *(_DWORD *)(v11 + 352) = v217 - 1;
      if (v217) {
        goto LABEL_388;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v218 = *(unsigned int *)(v11 + 352);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = "http1->pending_output_handler_count";
      *(_WORD *)&_BYTE buf[22] = 2048;
      v1051 = 1LL;
      *(_WORD *)v1052 = 2048;
      *(void *)&v1052[2] = v218;
      __int128 v219 = (char *)_os_log_send_and_compose_impl();
      v1065[0] = 16;
      aBlock[0] = 0;
      if (v1065[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v220 = (os_log_s *)gLogObj;
        char v221 = v1065[0];
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v1065[0]))
        {
          v222 = *(unsigned int *)(v11 + 352);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = "http1->pending_output_handler_count";
          *(_WORD *)&_BYTE buf[22] = 2048;
          v1051 = 1LL;
          *(_WORD *)v1052 = 2048;
          *(void *)&v1052[2] = v222;
          uint64_t v223 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_384:
          _os_log_impl(&dword_181A5C000, v220, v221, v223, buf, 0x2Au);
        }
      }

      else if (aBlock[0])
      {
        BOOL v224 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v220 = (os_log_s *)gLogObj;
        char v221 = v1065[0];
        uint64_t v225 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v1065[0]);
        if (v224)
        {
          if (v225)
          {
            char v226 = *(unsigned int *)(v1042 + 352);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "http1->pending_output_handler_count";
            *(_WORD *)&_BYTE buf[22] = 2048;
            v1051 = 1LL;
            *(_WORD *)v1052 = 2048;
            *(void *)&v1052[2] = v226;
            *(_WORD *)&v1052[10] = 2082;
            *(void *)&v1052[12] = v224;
            _os_log_impl( &dword_181A5C000,  v220,  v221,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v224);
          uint64_t v11 = v1042;
          goto LABEL_385;
        }

        uint64_t v11 = v1042;
        if (v225)
        {
          uint64_t v228 = *(unsigned int *)(v1042 + 352);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = "http1->pending_output_handler_count";
          *(_WORD *)&_BYTE buf[22] = 2048;
          v1051 = 1LL;
          *(_WORD *)v1052 = 2048;
          *(void *)&v1052[2] = v228;
          uint64_t v223 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_384;
        }
      }

      else
      {
        id v220 = (os_log_s *)__nwlog_obj();
        char v221 = v1065[0];
        if (os_log_type_enabled(v220, (os_log_type_t)v1065[0]))
        {
          int v227 = *(unsigned int *)(v11 + 352);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = "http1->pending_output_handler_count";
          *(_WORD *)&_BYTE buf[22] = 2048;
          v1051 = 1LL;
          *(_WORD *)v1052 = 2048;
          *(void *)&v1052[2] = v227;
          uint64_t v223 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_384;
        }
      }

  nw_frame_claim(v11, v26, v18, 0);
  __int16 v245 = *v10;
  *(void *)(v11 + 32) = *v10;
  BOOL v246 = (void *)(v245 + 40);
  char v29 = v245 == 0;
  os_log_type_t v247 = v342;
  if (!v29) {
    os_log_type_t v247 = v246;
  }
  *os_log_type_t v247 = v117;
  void *v10 = v11;
  *(void *)(v11 + 40) = v10;
LABEL_373:
  v248 = *(unsigned __int16 *)(v9 + 872);
  if ((v248 & 0x8000) != 0 && !*v10)
  {
    os_log_type_t v254 = (_WORD *)(v9 + 872);
    v255 = v248 & 0xFFFF7FFF | (*(unsigned __int8 *)(v9 + 874) << 16);
    *(_WORD *)(v9 + 872) = v248 & 0x7FFF;
    *(_BYTE *)(v9 + 874) = BYTE2(v255);
    if ((*(_BYTE *)(v9 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v331 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v331, OS_LOG_TYPE_DEBUG))
        {
          v332 = *(void *)(v9 + 488);
          v333 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
          v334 = *(_DWORD *)(v9 + 860);
          if (v332) {
            LODWORD(v332) = *(_DWORD *)(v332 + 424);
          }
          *(_DWORD *)buf = 136447490;
          v364 = "nw_http1_connection_send_final_chunk";
          v365 = 2082;
          *(void *)v366 = v9 + 74;
          *(_WORD *)&v366[8] = 2080;
          *(void *)&v366[10] = " ";
          v367 = 1024;
          *(_DWORD *)v368 = v333;
          *(_WORD *)&v368[4] = 1024;
          *(_DWORD *)&v368[6] = v334;
          LOWORD(v369) = 1024;
          *(_DWORD *)((char *)&v369 + 2) = v332;
          _os_log_impl( &dword_181A5C000,  v331,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> requesting new frame for final chunk",  buf,  0x32u);
          uint64_t v9 = v348;
        }
      }
    }

    v256 = *(void *)(v9 + 32);
    if (v256)
    {
      *(void *)&__len[1] = 0LL;
      v350 = (uint64_t)&__len[1];
      BOOL v257 = nw_protocol_get_output_frames(v256, v9, 5LL, 5LL, 1LL, (uint64_t)&__len[1]);
      os_log_type_t v258 = v257;
      v259 = *(void *)&__len[1];
      if (*(void *)&__len[1] && v257)
      {
        *(_DWORD *)os_log_type_t type = 0;
        v260 = nw_frame_unclaimed_bytes(*(uint64_t *)&__len[1], type);
        *(_DWORD *)v260 = 218762544;
        *(_BYTE *)(v260 + 4) = 10;
        if (nw_frame_claim(v259, v261, 5, 0))
        {
          nw_frame_collapse(v259);
          nw_frame_unclaim(v259, v262, 5u, 0);
          if (nw_protocol_finalize_output_frames(v256, (uint64_t)&__len[1]))
          {
            *(_WORD *)(*(void *)(v9 + 488) + 428LL) |= 0x400u;
            *v254 |= 0x20u;
            nw_http_transaction_metadata_mark_outbound_message_end(*(void **)(*(void *)(v9 + 488) + 352LL));
            v263 = *(void *)(v9 + 488);
            if (*(_BYTE *)(v263 + 168))
            {
              if (*(void *)(v263 + 160) != *(void *)(v263 + 176))
              {
                if ((*(_BYTE *)(v263 + 158) & 1) == 0)
                {
                  v264 = (os_log_s *)__nwlog_obj();
                  BOOL v265 = os_log_type_enabled(v264, OS_LOG_TYPE_ERROR);
                  v263 = *(void *)(v9 + 488);
                  if (v265)
                  {
                    os_log_type_t v266 = *(void *)(v263 + 256);
                    if (v266) {
                      LODWORD(v266) = *(_DWORD *)(v266 + 860);
                    }
                    os_log_type_t v267 = *(_DWORD *)(*(void *)(v263 + 248) + 372LL);
                    os_log_type_t v268 = *(_DWORD *)(v263 + 424);
                    if (*(_BYTE *)(v263 + 168)) {
                      os_log_type_t v269 = *(void *)(v263 + 160);
                    }
                    else {
                      os_log_type_t v269 = -1LL;
                    }
                    v297 = *(void *)(v263 + 176);
                    *(_DWORD *)buf = 136448002;
                    v364 = "nw_http1_connection_send_final_chunk";
                    v365 = 2082;
                    *(void *)v366 = v263 + 74;
                    *(_WORD *)&v366[8] = 2080;
                    *(void *)&v366[10] = " ";
                    v367 = 1024;
                    *(_DWORD *)v368 = v267;
                    *(_WORD *)&v368[4] = 1024;
                    *(_DWORD *)&v368[6] = v266;
                    LOWORD(v369) = 1024;
                    *(_DWORD *)((char *)&v369 + 2) = v268;
                    HIWORD(v369) = 2048;
                    *(void *)v370 = v269;
                    *(_WORD *)&v370[8] = 2048;
                    v371 = v297;
                    _os_log_impl( &dword_181A5C000,  v264,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> Content length header %llu does not equal body size %llu",  buf,  0x46u);
                    v263 = *(void *)(v9 + 488);
                  }
                }

                nw_protocol_error(*(void **)(v263 + 48), v263);
                nw_protocol_disconnected(*(void **)(*(void *)(v9 + 488) + 48LL), *(void *)(v9 + 488));
              }
            }
          }

          goto LABEL_375;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        v364 = "nw_http1_connection_send_final_chunk";
        v365 = 1024;
        *(_DWORD *)v366 = 5;
        BOOL v274 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v361) = 16;
        LOBYTE(v359) = 0;
        if (v361 == 17)
        {
          int v275 = (os_log_s *)__nwlog_obj();
          char v276 = v361;
          if (!os_log_type_enabled(v275, (os_log_type_t)v361)) {
            goto LABEL_437;
          }
          *(_DWORD *)buf = 136446466;
          v364 = "nw_http1_connection_send_final_chunk";
          v365 = 1024;
          *(_DWORD *)v366 = 5;
          v277 = "%{public}s claiming frame with %u bytes failed";
LABEL_435:
          v290 = v275;
          v291 = v276;
          v292 = 18;
LABEL_436:
          _os_log_impl(&dword_181A5C000, v290, v291, v277, buf, v292);
          goto LABEL_437;
        }

        if (!(_BYTE)v359)
        {
          int v275 = (os_log_s *)__nwlog_obj();
          char v276 = v361;
          if (!os_log_type_enabled(v275, (os_log_type_t)v361)) {
            goto LABEL_437;
          }
          *(_DWORD *)buf = 136446466;
          v364 = "nw_http1_connection_send_final_chunk";
          v365 = 1024;
          *(_DWORD *)v366 = 5;
          v277 = "%{public}s claiming frame with %u bytes failed, backtrace limit exceeded";
          goto LABEL_435;
        }

        v280 = (char *)__nw_create_backtrace_string();
        int v275 = (os_log_s *)__nwlog_obj();
        char v276 = v361;
        __int16 v281 = os_log_type_enabled(v275, (os_log_type_t)v361);
        if (!v280)
        {
          uint64_t v9 = v348;
          if (!v281) {
            goto LABEL_437;
          }
          *(_DWORD *)buf = 136446466;
          v364 = "nw_http1_connection_send_final_chunk";
          v365 = 1024;
          *(_DWORD *)v366 = 5;
          v277 = "%{public}s claiming frame with %u bytes failed, no backtrace";
          goto LABEL_435;
        }

        if (v281)
        {
          *(_DWORD *)buf = 136446722;
          v364 = "nw_http1_connection_send_final_chunk";
          v365 = 1024;
          *(_DWORD *)v366 = 5;
          *(_WORD *)&v366[4] = 2082;
          *(void *)&v366[6] = v280;
          v282 = "%{public}s claiming frame with %u bytes failed, dumping backtrace:%{public}s";
          __int16 v283 = v275;
          v284 = v276;
          uint64_t v285 = 28;
LABEL_415:
          _os_log_impl(&dword_181A5C000, v283, v284, v282, buf, v285);
          goto LABEL_416;
        }

        goto LABEL_416;
      }

      if (!v257)
      {
LABEL_428:
        if ((*(_BYTE *)(v9 + 158) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v286 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            v287 = *(void *)(v9 + 488);
            v288 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
            v289 = *(_DWORD *)(v9 + 860);
            if (v287) {
              LODWORD(v287) = *(_DWORD *)(v287 + 424);
            }
            *(_DWORD *)buf = 136447746;
            v364 = "nw_http1_connection_send_final_chunk";
            v365 = 2082;
            *(void *)v366 = v9 + 74;
            *(_WORD *)&v366[8] = 2080;
            *(void *)&v366[10] = " ";
            v367 = 1024;
            *(_DWORD *)v368 = v288;
            *(_WORD *)&v368[4] = 1024;
            *(_DWORD *)&v368[6] = v289;
            LOWORD(v369) = 1024;
            *(_DWORD *)((char *)&v369 + 2) = v287;
            HIWORD(v369) = 1024;
            *(_DWORD *)v370 = 5;
            _os_log_impl( &dword_181A5C000,  v286,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> output handler refused frame request for frames of length %u",  buf,  0x38u);
          }
        }

        goto LABEL_375;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v364 = "nw_http1_connection_send_final_chunk";
      v365 = 1024;
      *(_DWORD *)v366 = v258;
      os_log_type_t v270 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v361) = 0;
      if (__nwlog_fault(v270, type, &v361))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v271 = (os_log_s *)__nwlog_obj();
          os_log_type_t v272 = type[0];
          if (os_log_type_enabled(v271, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            v364 = "nw_http1_connection_send_final_chunk";
            v365 = 1024;
            *(_DWORD *)v366 = v258;
            nw_endpoint_t v273 = "%{public}s output handler reported %u frames to write, but array is empty";
LABEL_424:
            _os_log_impl(&dword_181A5C000, v271, v272, v273, buf, 0x12u);
          }
        }

        else if ((_BYTE)v361)
        {
          uint64_t v278 = (char *)__nw_create_backtrace_string();
          os_log_type_t v271 = (os_log_s *)__nwlog_obj();
          os_log_type_t v272 = type[0];
          __int128 v279 = os_log_type_enabled(v271, type[0]);
          if (v278)
          {
            if (v279)
            {
              *(_DWORD *)buf = 136446722;
              v364 = "nw_http1_connection_send_final_chunk";
              v365 = 1024;
              *(_DWORD *)v366 = v258;
              *(_WORD *)&v366[4] = 2082;
              *(void *)&v366[6] = v278;
              _os_log_impl( &dword_181A5C000,  v271,  v272,  "%{public}s output handler reported %u frames to write, but array is empty, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v278);
            goto LABEL_425;
          }

          if (v279)
          {
            *(_DWORD *)buf = 136446466;
            v364 = "nw_http1_connection_send_final_chunk";
            v365 = 1024;
            *(_DWORD *)v366 = v258;
            nw_endpoint_t v273 = "%{public}s output handler reported %u frames to write, but array is empty, no backtrace";
            goto LABEL_424;
          }
        }

        else
        {
          os_log_type_t v271 = (os_log_s *)__nwlog_obj();
          os_log_type_t v272 = type[0];
          if (os_log_type_enabled(v271, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            v364 = "nw_http1_connection_send_final_chunk";
            v365 = 1024;
            *(_DWORD *)v366 = v258;
            nw_endpoint_t v273 = "%{public}s output handler reported %u frames to write, but array is empty, backtrace limit exceeded";
            goto LABEL_424;
          }
        }
      }

    _os_log_impl(&dword_181A5C000, v149, v150, v151, buf, 0xCu);
    goto LABEL_371;
  }

  if (v6 == 2)
  {
    uint64_t v11 = *((void *)handle + 1);
    if (v11)
    {
      int v10 = (uint64_t *)(v11 + 256);
      goto LABEL_17;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
    v169 = (char *)_os_log_send_and_compose_impl();
    v237[0] = 16;
    LOBYTE(v231) = 0;
    if (__nwlog_fault(v169, v237, &v231))
    {
      if (v237[0] == 17)
      {
        __int16 v170 = (os_log_s *)__nwlog_obj();
        uint64_t v171 = v237[0];
        if (!os_log_type_enabled(v170, (os_log_type_t)v237[0])) {
          goto LABEL_353;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
        __int16 v172 = "%{public}s called with null handle->http1_stream";
        goto LABEL_352;
      }

      if (!(_BYTE)v231)
      {
        __int16 v170 = (os_log_s *)__nwlog_obj();
        uint64_t v171 = v237[0];
        if (!os_log_type_enabled(v170, (os_log_type_t)v237[0])) {
          goto LABEL_353;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
        __int16 v172 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
        goto LABEL_352;
      }

      BOOL v175 = (char *)__nw_create_backtrace_string();
      __int16 v170 = (os_log_s *)__nwlog_obj();
      uint64_t v171 = v237[0];
      __int16 v176 = os_log_type_enabled(v170, (os_log_type_t)v237[0]);
      if (v175)
      {
        if (v176)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v175;
          _os_log_impl( &dword_181A5C000,  v170,  v171,  "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v175);
        goto LABEL_353;
      }

      if (v176)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
        __int16 v172 = "%{public}s called with null handle->http1_stream, no backtrace";
LABEL_352:
        _os_log_impl(&dword_181A5C000, v170, v171, v172, buf, 0xCu);
      }
    }

      qenc_remove_overflow_entries(v68);
      BOOL v224 = v279;
      if (v287)
      {
        uint64_t v225 = *(void *)(v68 + 216);
        if (!v225) {
          __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2132, "enc->qpe_hist_els");
        }
        char v226 = *(_DWORD *)(v68 + 228);
        if (*(_DWORD *)(v68 + 144) < v226)
        {
LABEL_375:
          *(_DWORD *)(v225 + 8LL * *(unsigned int *)(v68 + 224)) = v312;
          *(_DWORD *)(v225 + 8LL * *(unsigned int *)(v68 + 224) + 4) = v61;
          int v227 = (*(_DWORD *)(v68 + 224) + 1) % *(_DWORD *)(v68 + 228);
          *(_DWORD *)(v68 + 224) = v227;
          *(_DWORD *)(v68 + 232) |= v227 == 0;
        }

        else
        {
          qenc_hist_update_size(v68, v226 + 4);
          BOOL v224 = v279;
          if (*(_DWORD *)(v68 + 228))
          {
            uint64_t v225 = *(void *)(v68 + 216);
            goto LABEL_375;
          }
        }

        ++*(_DWORD *)(v68 + 144);
      }

      uint64_t v228 = v297;
      if (v297 != v224)
      {
        while ((*(_BYTE *)(v68 + 12) & 2) != 0 && *(_DWORD *)v68 != -1)
        {
          uint64_t v229 = *(float *)(v68 + 208);
          if ((v229 != 0.0
             || *(void *)(v68 + 136)
             || *(_DWORD *)(v68 + 40) < *(_DWORD *)(v68 + 36)
             || (v230 = *(void *)(v68 + 128)) != 0 && *(_DWORD *)(v230 + 60) > *(_DWORD *)(v68 + 4))
            && v229 < *(float *)(v68 + 212))
          {
            break;
          }

          nw_endpoint_t v231 = *(uint64_t **)(v68 + 56);
          if (!v231) {
            break;
          }
          uint64_t v232 = 0LL;
          unsigned int v233 = &v296[v224];
          v314 = v297 - v224;
          uint64_t v228 = v224;
          do
          {
            if ((*((_DWORD *)v231 + 8)
                              + *((_DWORD *)v231 + 7)
                              + *(_DWORD *)(v68 + 20)
                              - (*(_DWORD *)(v68 + 32)
                               + *(_DWORD *)(v68 + 16))) >= *(_DWORD *)(v68 + 20) >> 2)
              break;
            if (!v232
              || *((_DWORD *)v231 + 12) + *((_DWORD *)v231 + 13) + 32 >= (v232[12] + v232[13] + 32))
            {
              char v234 = (uint64_t *)*v231;
              v235 = *((_DWORD *)v231 + 10);
              if (*v231)
              {
                while (1)
                {
                  if (*((_DWORD *)v234 + 10) == v235)
                  {
                    os_log_type_t v236 = *((unsigned int *)v234 + 12);
                    if ((_DWORD)v236 == *((_DWORD *)v231 + 12))
                    {
                      os_log_type_t v237 = *((unsigned int *)v234 + 13);
                      if ((_DWORD)v237 == *((_DWORD *)v231 + 13)
                        && !memcmp(v234 + 7, v231 + 7, *((unsigned int *)v234 + 12))
                        && !memcmp((char *)v234 + v236 + 56, (char *)v231 + v236 + 56, v237))
                      {
                        break;
                      }
                    }
                  }

                  char v234 = (uint64_t *)*v234;
                  if (!v234) {
                    goto LABEL_404;
                  }
                }

                os_log_type_t v149 = &v296[v297];
              }

              else
              {
LABEL_404:
                v238 = *(void *)(v68 + 216);
                os_log_type_t v149 = &v296[v297];
                if (!v238) {
                  goto LABEL_462;
                }
                BOOL v239 = 228LL;
                if (!*(_DWORD *)(v68 + 232)) {
                  BOOL v239 = 224LL;
                }
                __int16 v240 = v238 + 8LL * *(unsigned int *)(v68 + v239);
                *(_DWORD *)(v240 + 4) = v235;
                v241 = v238 - 8;
                do
                {
                  __int16 v242 = *(_DWORD *)(v241 + 12);
                  v241 += 8LL;
                }

                while (v242 != v235);
                if (v241 < v240)
                {
LABEL_462:
                  if (qenc_has_or_can_evict_at_least( v68,  (*((_DWORD *)v231 + 12) + *((_DWORD *)v231 + 13) + 32))) {
                    uint64_t v232 = v231;
                  }
                }
              }

              BOOL v224 = v228;
            }

            nw_endpoint_t v231 = (uint64_t *)v231[2];
          }

          while (v231);
          if (!v232) {
            break;
          }
          os_log_type_t v243 = *(FILE **)(v68 + 200);
          if (v243)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v243);
            fwrite("dup draining", 0xCuLL, 1uLL, *(FILE **)(v68 + 200));
            fputc(10, *(FILE **)(v68 + 200));
          }

          *unsigned int v233 = 0;
          if (v314 <= 0) {
            goto LABEL_440;
          }
          v244 = (*(_DWORD *)v68 - v232[6]);
          if (v244 > 0x1E)
          {
            *unsigned int v233 = 31;
            BOOL v246 = v233 + 1;
            os_log_type_t v247 = v244 - 31;
            if (v244 - 31 < 0x80)
            {
              LOBYTE(v244) = v244 - 31;
              os_log_type_t v249 = v233;
            }

            else
            {
              do
              {
                if (v246 >= v149) {
                  goto LABEL_429;
                }
                *v246++ = v247 | 0x80;
                v244 = v247 >> 7;
                v248 = v247 >> 14;
                v247 >>= 7;
              }

              while (v248);
              os_log_type_t v249 = v246 - 1;
            }

            if (v246 >= v149) {
              goto LABEL_429;
            }
            __int16 v245 = (_DWORD)v249 + 2;
            char *v246 = v244;
            if (v249 + 2 <= v233) {
              goto LABEL_429;
            }
          }

          else
          {
            *unsigned int v233 = *(_BYTE *)v68 - *((_BYTE *)v232 + 24);
            __int16 v245 = (_DWORD)v233 + 1;
          }

          if (!lsqpack_enc_push_entry( v68,  v232[11],  v232[10],  v232 + 14,  v232[12],  (char *)v232 + v232[12] + 56,  v232[13])
            || v245 == (_DWORD)v233)
          {
            goto LABEL_429;
          }

          qenc_remove_overflow_entries(v68);
          BOOL v224 = (v245 - (_DWORD)v233) + v228;
          if (v297 == v224)
          {
            uint64_t v228 = v297;
            goto LABEL_429;
          }
        }

        uint64_t v228 = v224;
      }

                      if (log) {
                        free(log);
                      }
                      os_log_type_t v125 = 0;
                      if ((v121 & 1) == 0)
                      {
LABEL_158:
                        if ((v351 & 1) != 0)
                        {
                          nw::release_if_needed<nw_protocol *>(&v350);
                          if ((v353 & 1) == 0)
                          {
LABEL_161:
                            logging_disabled = nw_endpoint_handler_get_logging_disabled(v45);
                            if ((v125 & 1) != 0)
                            {
                              if ((logging_disabled & 1) == 0)
                              {
                                if (__nwlog_connection_log::onceToken != -1) {
                                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                }
                                BOOL v127 = (os_log_s *)(id)gconnectionLogObj;
                                if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                                {
                                  id_string = nw_endpoint_handler_get_id_string(v45);
                                  v323 = nw_endpoint_handler_dry_run_string(v45);
                                  loga = nw_endpoint_handler_copy_endpoint(v45);
                                  logging_description = nw_endpoint_get_logging_description(loga);
                                  os_log_type_t v130 = nw_endpoint_handler_state_string(v45);
                                  BOOL v131 = nw_endpoint_handler_mode_string(v45);
                                  char v132 = nw_endpoint_handler_copy_current_path(v45);
                                  *(_DWORD *)buf = 136447746;
                                  v355 = "nw_endpoint_start_tls_while_connected";
                                  v356 = 2082;
                                  v357 = (char *)id_string;
                                  v358 = 2082;
                                  v359 = v323;
                                  v360 = 2082;
                                  v361 = (void *)logging_description;
                                  v362 = 2082;
                                  v363 = v130;
                                  v364 = 2082;
                                  v365 = v131;
                                  v366 = 2114;
                                  v367 = v132;
                                  _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Att ached TLS protocol to connected flow",  buf,  0x48u);
                                }
                              }

                              os_log_type_t v133 = v45;
                              v39->state = 2;

                              *((_DWORD *)v133 + 20) = 262147;
                              nw_endpoint_handler_report(v133, 0LL, (_WORD *)v133 + 40, 0LL);
                              if ((*((_BYTE *)v342 + 33) & 4) != 0)
                              {
                                char v134 = nw_endpoint_handler_copy_association(v133, 0);
                                os_log_type_t v135 = v134;
                                if (v134) {
                                  nw_association_mark_flow_disconnected(v134, v133);
                                }
                                *((_BYTE *)v342 + 33) &= ~4u;
                              }

                              started = nw_endpoint_flow_connect(v133);
                              goto LABEL_198;
                            }

                            if ((logging_disabled & 1) == 0)
                            {
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                              }
                              os_log_type_t v136 = (os_log_s *)(id)gconnectionLogObj;
                              if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
                              {
                                char v137 = nw_endpoint_handler_get_id_string(v45);
                                v322 = nw_endpoint_handler_dry_run_string(v45);
                                v324 = v137;
                                logb = nw_endpoint_handler_copy_endpoint(v45);
                                v321 = nw_endpoint_get_logging_description(logb);
                                os_log_type_t v138 = nw_endpoint_handler_state_string(v45);
                                char v139 = nw_endpoint_handler_mode_string(v45);
                                __int16 v140 = nw_endpoint_handler_copy_current_path(v45);
                                *(_DWORD *)buf = 136447746;
                                v355 = "nw_endpoint_start_tls_while_connected";
                                v356 = 2082;
                                v357 = (char *)v324;
                                v358 = 2082;
                                v359 = v322;
                                v360 = 2082;
                                v361 = (void *)v321;
                                v362 = 2082;
                                v363 = v138;
                                v364 = 2082;
                                v365 = v139;
                                v366 = 2114;
                                v367 = v140;
                                _os_log_impl( &dword_181A5C000,  v136,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Faile d to replace flow protocol with TLS protocol",  buf,  0x48u);
                              }
                            }

                            if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
                            {
                              os_log_type_t v153 = *(void *)(internal + 88);
                              if (v153) {
                                *(void *)(internal + 88) = v153 + 1;
                              }
                              *(void *)os_log_type_t type = internal;
                              os_log_type_t v141 = v353 | 1;
                            }

                            else
                            {
                              *(void *)os_log_type_t type = internal;
                              os_log_type_t v141 = v353 & 0xFE;
                            }

                            v353 = v141;
                            if (*(_UNKNOWN **)(v49 + 40) == &nw_protocol_ref_counted_handle)
                            {
                              uint64_t v155 = *(void *)(v49 + 88);
                              if (v155) {
                                *(void *)(v49 + 88) = v155 + 1;
                              }
                              v350 = v49;
                              __int16 v154 = v351 | 1;
                            }

                            else
                            {
                              v350 = v49;
                              __int16 v154 = v351 & 0xFE;
                            }

                            v351 = v154;
                            os_log_type_t v156 = *(void *)(internal + 24);
                            if (v156)
                            {
                              os_log_type_t v157 = *(uint64_t (**)(uint64_t, uint64_t, void))(v156 + 8);
                              if (v157)
                              {
                                __int16 v158 = v157(internal, v49, 0LL);
                                if ((v351 & 1) == 0) {
                                  goto LABEL_214;
                                }
                                goto LABEL_213;
                              }
                            }

                            __nwlog_obj();
                            v291 = (void *)objc_claimAutoreleasedReturnValue();
                            v292 = *(const char **)(internal + 16);
                            *(_DWORD *)buf = 136446722;
                            v355 = "__nw_protocol_remove_input_handler";
                            if (!v292) {
                              v292 = "invalid";
                            }
                            v356 = 2082;
                            v357 = (char *)v292;
                            v358 = 2048;
                            v359 = (const char *)internal;
                            v293 = (char *)_os_log_send_and_compose_impl();

                            v347[0] = OS_LOG_TYPE_ERROR;
                            v349 = OS_LOG_TYPE_DEFAULT;
                            if (__nwlog_fault(v293, v347, &v349))
                            {
                              if (v347[0] == OS_LOG_TYPE_FAULT)
                              {
                                __nwlog_obj();
                                v294 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                v295 = v347[0];
                                if (os_log_type_enabled(v294, v347[0]))
                                {
                                  v296 = *(const char **)(internal + 16);
                                  if (!v296) {
                                    v296 = "invalid";
                                  }
                                  *(_DWORD *)buf = 136446722;
                                  v355 = "__nw_protocol_remove_input_handler";
                                  v356 = 2082;
                                  v357 = (char *)v296;
                                  v358 = 2048;
                                  v359 = (const char *)internal;
                                  _os_log_impl( &dword_181A5C000,  v294,  v295,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback",  buf,  0x20u);
                                }

void sub_181E7FD30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v7 = p_output_handler;
    uint64_t v8 = v7;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *((void *)v7 + 1);
      if (v9)
      {
        if (*(void *)(v9 + 80))
        {
          int v10 = v7[405];
          if (!*((void *)v7 + 3))
          {
            if ((v10 & 0x80000000) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v13 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
                __int16 v46 = 2082;
                os_log_type_t v47 = v8 + 407;
                __int16 v48 = 2080;
                __int16 v49 = " ";
                _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAdded protocol listen handler",  buf,  0x20u);
              }
            }

            *((void *)v8 + 3) = a2;
            a2->protocol_handler = (nw_protocol *)(v8 - 96);
            if ((a3 & 1) != 0)
            {
              if ((v8[405] & 0x80000000) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v14 = (os_log_s *)(id)gLogObj;
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446722;
                  os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
                  __int16 v46 = 2082;
                  os_log_type_t v47 = v8 + 407;
                  __int16 v48 = 2080;
                  __int16 v49 = " ";
                  _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sListen handler prohibits joining, removing instance",  buf,  0x20u);
                }
              }

              v8[404] |= 4u;
              nw_protocol_remove_instance((uint64_t)(v8 - 96));
            }

            uint64_t v12 = 1LL;
            goto LABEL_24;
          }

          if ((v10 & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v11 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              os_log_type_t v45 = "nw_protocol_implementation_add_listen_handler";
              __int16 v46 = 2082;
              os_log_type_t v47 = v8 + 407;
              __int16 v48 = 2080;
              __int16 v49 = " ";
              _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sAlready have a listen handler, ignoring add",  buf,  0x20u);
            }
          }

uint64_t nw_protocol_implementation_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    id v5 = p_output_handler;
    uint64_t v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *((void *)v5 + 1);
      if (v7)
      {
        if (*(void *)(v7 + 80))
        {
          if (*((nw_listen_protocol **)v5 + 3) == a2)
          {
            *((void *)v5 + 3) = 0LL;
            a2->protocol_handler = 0LL;
          }

          if ((v5[405] & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v8 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              os_log_type_t v40 = "nw_protocol_implementation_remove_listen_handler";
              __int16 v41 = 2082;
              char v42 = v6 + 407;
              __int16 v43 = 2080;
              BOOL v44 = " ";
              _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRemoved protocol listen handler",  buf,  0x20u);
            }
          }

          v6[404] |= 4u;
          nw_protocol_remove_instance((uint64_t)(v6 - 96));
          uint64_t v9 = 1LL;
LABEL_14:

          return v9;
        }

        __nwlog_obj();
        __int16 v21 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_implementation_remove_listen_handler";
        unsigned int v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v37 = 0;
        if (__nwlog_fault(v16, &type, &v37))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v22 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v40 = "nw_protocol_implementation_remove_listen_handler";
              _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
            }

id nw_protocol_implementation_get_parameters(nw_protocol *a1)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v4 = p_output_handler;
    id v5 = v4;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (!v6)
      {
        __nwlog_obj();
        os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        uint64_t v67 = "nw_protocol_implementation_get_parameters";
        __int16 v21 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v25 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_136;
        }

        if (v65 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v47 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v47,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_136;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v35 = type[0];
        BOOL v36 = os_log_type_enabled(v22, type[0]);
        if (!backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v35,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_136;
        }

        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v67 = "nw_protocol_implementation_get_parameters";
          __int16 v68 = 2082;
          os_log_type_t v69 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v35,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_62;
      }

      if (!*(void *)(v6 + 80))
      {
        __nwlog_obj();
        BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        uint64_t v67 = "nw_protocol_implementation_get_parameters";
        __int16 v21 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v27 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_136;
        }

        if (v65 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v50 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v50,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_136;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v37 = type[0];
        BOOL v38 = os_log_type_enabled(v22, type[0]);
        if (!backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v37,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_136;
        }

        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v67 = "nw_protocol_implementation_get_parameters";
          __int16 v68 = 2082;
          os_log_type_t v69 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v37,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_62;
      }

      if (*((void *)v4 + 40))
      {
        uint64_t v7 = (void *)*((void *)v4 + 43);
LABEL_11:
        id v8 = v7;
LABEL_12:

        return v8;
      }

      if (*(_DWORD *)(v6 + 64) == 3)
      {
        uint64_t v7 = (void *)*((void *)v4 + 6);
        goto LABEL_11;
      }

      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        uint64_t v11 = default_input_handler->handle;
        if (v11 == &nw_protocol_ref_counted_handle)
        {
          callbacks = default_input_handler[1].callbacks;
          if (callbacks) {
            default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          char v12 = -1;
        }

        else
        {
          char v12 = 0;
        }

        *(void *)os_log_type_t type = default_input_handler;
        char v64 = v12;
        os_log_type_t v14 = default_input_handler->callbacks;
        if (v14)
        {
          get_parameters = (void (*)(nw_protocol *))v14->get_parameters;
          if (get_parameters)
          {
            get_parameters(default_input_handler);
            id v8 = (id)objc_claimAutoreleasedReturnValue();
            if (v11 != &nw_protocol_ref_counted_handle) {
              goto LABEL_12;
            }
LABEL_22:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            goto LABEL_12;
          }
        }

        __nwlog_obj();
        os_log_type_t v39 = (void *)objc_claimAutoreleasedReturnValue();
        name = default_input_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        uint64_t v67 = "__nw_protocol_get_parameters";
        if (!name) {
          name = "invalid";
        }
        __int16 v68 = 2082;
        os_log_type_t v69 = (void *)name;
        __int16 v70 = 2048;
        int v61 = default_input_handler;
        os_log_type_t v71 = default_input_handler;
        __int16 v41 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v65 = OS_LOG_TYPE_ERROR;
        char v62 = 0;
        if (__nwlog_fault(v41, &v65, &v62))
        {
          if (v65 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            char v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v43 = v65;
            if (os_log_type_enabled(v42, v65))
            {
              BOOL v44 = v61->identifier->name;
              if (!v44) {
                BOOL v44 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              uint64_t v67 = "__nw_protocol_get_parameters";
              __int16 v68 = 2082;
              os_log_type_t v69 = (void *)v44;
              __int16 v70 = 2048;
              os_log_type_t v71 = v61;
              _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback",  buf,  0x20u);
            }

id nw_protocol_implementation_get_local(nw_protocol *a1)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v4 = p_output_handler;
    id v5 = v4;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (!v6)
      {
        __nwlog_obj();
        os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
        BOOL v28 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v72 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v32 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
            _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v72 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v54 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
            _os_log_impl( &dword_181A5C000,  v29,  v54,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v42 = type[0];
        BOOL v43 = os_log_type_enabled(v29, type[0]);
        if (!backtrace_string)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
            _os_log_impl( &dword_181A5C000,  v29,  v42,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
          __int16 v74 = 2082;
          os_log_type_t v75 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v42,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_76;
      }

      if (!*(void *)(v6 + 80))
      {
        __nwlog_obj();
        BOOL v33 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
        BOOL v28 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v72 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v34 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
            _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v72 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v57 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
            _os_log_impl( &dword_181A5C000,  v29,  v57,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type[0];
        BOOL v45 = os_log_type_enabled(v29, type[0]);
        if (!backtrace_string)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
            _os_log_impl( &dword_181A5C000,  v29,  v44,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
          __int16 v74 = 2082;
          os_log_type_t v75 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v44,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_76;
      }

      if (*((void *)v4 + 40))
      {
        id v7 = *((id *)v4 + 42);
LABEL_9:

        return v7;
      }

      if (*(_DWORD *)(v6 + 64) == 3)
      {
        some_BOOL node = nw_hash_table_get_some_node(*((os_unfair_lock_s **)v4 + 29));
        if (some_node)
        {
          int v10 = *(void **)(some_node + 16);
          if (v10)
          {
            uint64_t v11 = v10[3];
            if (v11)
            {
              char v12 = *(void (**)(void))(v11 + 128);
              if (v12)
              {
                char v13 = (void *)v10[5];
                if (v13 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v22 = v10[11];
                  if (v22) {
                    v10[11] = v22 + 1;
                  }
                  char v14 = -1;
                }

                else
                {
                  char v14 = 0;
                }

                *(void *)buf = v10;
                buf[8] = v14;
                v12();
                id v7 = (id)objc_claimAutoreleasedReturnValue();
                if (v13 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
                goto LABEL_9;
              }
            }
          }
        }

        else if ((v5[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v18 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_local";
            __int16 v74 = 2082;
            os_log_type_t v75 = v5 + 407;
            __int16 v76 = 2080;
            os_log_type_t v77 = " ";
            _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to find any flow",  buf,  0x20u);
          }
        }

        goto LABEL_24;
      }

      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        unsigned int v16 = default_input_handler->handle;
        if (v16 == &nw_protocol_ref_counted_handle)
        {
          callbacks = default_input_handler[1].callbacks;
          if (callbacks) {
            default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          char v17 = -1;
        }

        else
        {
          char v17 = 0;
        }

        *(void *)os_log_type_t type = default_input_handler;
        char v71 = v17;
        os_log_type_t v20 = default_input_handler->callbacks;
        if (v20)
        {
          get_local_endpoint = (void (*)(nw_protocol *))v20->get_local_endpoint;
          if (get_local_endpoint)
          {
            get_local_endpoint(default_input_handler);
            id v7 = (id)objc_claimAutoreleasedReturnValue();
            if (v16 != &nw_protocol_ref_counted_handle) {
              goto LABEL_9;
            }
LABEL_31:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            goto LABEL_9;
          }
        }

        __nwlog_obj();
        os_log_type_t v46 = (void *)objc_claimAutoreleasedReturnValue();
        name = default_input_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
        if (!name) {
          name = "invalid";
        }
        __int16 v74 = 2082;
        os_log_type_t v75 = (char *)name;
        __int16 v76 = 2048;
        __int16 v68 = default_input_handler;
        os_log_type_t v77 = (const char *)default_input_handler;
        __int16 v48 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v72 = OS_LOG_TYPE_ERROR;
        char v69 = 0;
        if (__nwlog_fault(v48, &v72, &v69))
        {
          if (v72 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v50 = v72;
            if (os_log_type_enabled(v49, v72))
            {
              os_log_type_t v51 = v68->identifier->name;
              if (!v51) {
                os_log_type_t v51 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
              __int16 v74 = 2082;
              os_log_type_t v75 = (char *)v51;
              __int16 v76 = 2048;
              os_log_type_t v77 = (const char *)v68;
              _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback",  buf,  0x20u);
            }

id nw_protocol_implementation_get_remote(nw_protocol *a1)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v4 = p_output_handler;
    id v5 = v4;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (!v6)
      {
        __nwlog_obj();
        os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
        BOOL v28 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v72 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v32 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
            _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v72 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v54 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
            _os_log_impl( &dword_181A5C000,  v29,  v54,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v42 = type[0];
        BOOL v43 = os_log_type_enabled(v29, type[0]);
        if (!backtrace_string)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
            _os_log_impl( &dword_181A5C000,  v29,  v42,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
          __int16 v74 = 2082;
          os_log_type_t v75 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v42,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_76;
      }

      if (!*(void *)(v6 + 80))
      {
        __nwlog_obj();
        BOOL v33 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
        BOOL v28 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v72 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v34 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
            _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v72 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v57 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
            _os_log_impl( &dword_181A5C000,  v29,  v57,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type[0];
        BOOL v45 = os_log_type_enabled(v29, type[0]);
        if (!backtrace_string)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
            _os_log_impl( &dword_181A5C000,  v29,  v44,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
          __int16 v74 = 2082;
          os_log_type_t v75 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v44,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_76;
      }

      if (*((void *)v4 + 40))
      {
        id v7 = *((id *)v4 + 41);
LABEL_9:

        return v7;
      }

      if (*(_DWORD *)(v6 + 64) == 3)
      {
        some_BOOL node = nw_hash_table_get_some_node(*((os_unfair_lock_s **)v4 + 29));
        if (some_node)
        {
          int v10 = *(void **)(some_node + 16);
          if (v10)
          {
            uint64_t v11 = v10[3];
            if (v11)
            {
              char v12 = *(void (**)(void))(v11 + 136);
              if (v12)
              {
                char v13 = (void *)v10[5];
                if (v13 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v22 = v10[11];
                  if (v22) {
                    v10[11] = v22 + 1;
                  }
                  char v14 = -1;
                }

                else
                {
                  char v14 = 0;
                }

                *(void *)buf = v10;
                buf[8] = v14;
                v12();
                id v7 = (id)objc_claimAutoreleasedReturnValue();
                if (v13 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
                goto LABEL_9;
              }
            }
          }
        }

        else if ((v5[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v18 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_remote";
            __int16 v74 = 2082;
            os_log_type_t v75 = v5 + 407;
            __int16 v76 = 2080;
            os_log_type_t v77 = " ";
            _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to find any flow",  buf,  0x20u);
          }
        }

        goto LABEL_24;
      }

      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        unsigned int v16 = default_input_handler->handle;
        if (v16 == &nw_protocol_ref_counted_handle)
        {
          callbacks = default_input_handler[1].callbacks;
          if (callbacks) {
            default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          char v17 = -1;
        }

        else
        {
          char v17 = 0;
        }

        *(void *)os_log_type_t type = default_input_handler;
        char v71 = v17;
        os_log_type_t v20 = default_input_handler->callbacks;
        if (v20)
        {
          get_remote_endpoint = (void (*)(nw_protocol *))v20->get_remote_endpoint;
          if (get_remote_endpoint)
          {
            get_remote_endpoint(default_input_handler);
            id v7 = (id)objc_claimAutoreleasedReturnValue();
            if (v16 != &nw_protocol_ref_counted_handle) {
              goto LABEL_9;
            }
LABEL_31:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            goto LABEL_9;
          }
        }

        __nwlog_obj();
        os_log_type_t v46 = (void *)objc_claimAutoreleasedReturnValue();
        name = default_input_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
        if (!name) {
          name = "invalid";
        }
        __int16 v74 = 2082;
        os_log_type_t v75 = (char *)name;
        __int16 v76 = 2048;
        __int16 v68 = default_input_handler;
        os_log_type_t v77 = (const char *)default_input_handler;
        __int16 v48 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v72 = OS_LOG_TYPE_ERROR;
        char v69 = 0;
        if (__nwlog_fault(v48, &v72, &v69))
        {
          if (v72 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v50 = v72;
            if (os_log_type_enabled(v49, v72))
            {
              os_log_type_t v51 = v68->identifier->name;
              if (!v51) {
                os_log_type_t v51 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
              __int16 v74 = 2082;
              os_log_type_t v75 = (char *)v51;
              __int16 v76 = 2048;
              os_log_type_t v77 = (const char *)v68;
              _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback",  buf,  0x20u);
            }

id nw_protocol_implementation_get_path(nw_protocol *a1)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    uint64_t v4 = p_output_handler;
    id v5 = v4;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (!v6)
      {
        __nwlog_obj();
        os_log_type_t v32 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
        os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v73 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v33 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
            _os_log_impl( &dword_181A5C000,  v30,  v33,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v73 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v55 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
            _os_log_impl( &dword_181A5C000,  v30,  v55,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type[0];
        BOOL v44 = os_log_type_enabled(v30, type[0]);
        if (!backtrace_string)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
            _os_log_impl( &dword_181A5C000,  v30,  v43,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
          __int16 v75 = 2082;
          __int16 v76 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v30,  v43,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_76;
      }

      if (!*(void *)(v6 + 80))
      {
        __nwlog_obj();
        os_log_type_t v34 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
        os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v73 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v35 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
            _os_log_impl( &dword_181A5C000,  v30,  v35,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v73 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v58 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
            _os_log_impl( &dword_181A5C000,  v30,  v58,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v45 = type[0];
        BOOL v46 = os_log_type_enabled(v30, type[0]);
        if (!backtrace_string)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
            _os_log_impl( &dword_181A5C000,  v30,  v45,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
          __int16 v75 = 2082;
          __int16 v76 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v30,  v45,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_76;
      }

      id v7 = (void *)*((void *)v4 + 36);
      if (v7)
      {
        id v8 = v7;
LABEL_9:

        return v8;
      }

      if (*(_DWORD *)(v6 + 64) == 3)
      {
        some_BOOL node = nw_hash_table_get_some_node(*((os_unfair_lock_s **)v4 + 29));
        if (some_node)
        {
          uint64_t v11 = *(void **)(some_node + 16);
          if (v11)
          {
            uint64_t v12 = v11[3];
            if (v12)
            {
              char v13 = *(void (**)(void))(v12 + 120);
              if (v13)
              {
                char v14 = (void *)v11[5];
                if (v14 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v23 = v11[11];
                  if (v23) {
                    v11[11] = v23 + 1;
                  }
                  char v15 = -1;
                }

                else
                {
                  char v15 = 0;
                }

                *(void *)buf = v11;
                buf[8] = v15;
                v13();
                id v8 = (id)objc_claimAutoreleasedReturnValue();
                if (v14 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
                goto LABEL_9;
              }
            }
          }
        }

        else if ((v5[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v19 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_path";
            __int16 v75 = 2082;
            __int16 v76 = v5 + 407;
            __int16 v77 = 2080;
            __int16 v78 = " ";
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to find any flow",  buf,  0x20u);
          }
        }

        goto LABEL_24;
      }

      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        char v17 = default_input_handler->handle;
        if (v17 == &nw_protocol_ref_counted_handle)
        {
          callbacks = default_input_handler[1].callbacks;
          if (callbacks) {
            default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          char v18 = -1;
        }

        else
        {
          char v18 = 0;
        }

        *(void *)os_log_type_t type = default_input_handler;
        char v72 = v18;
        __int16 v21 = default_input_handler->callbacks;
        if (v21)
        {
          get_path = (void (*)(nw_protocol *))v21->get_path;
          if (get_path)
          {
            get_path(default_input_handler);
            id v8 = (id)objc_claimAutoreleasedReturnValue();
            if (v17 != &nw_protocol_ref_counted_handle) {
              goto LABEL_9;
            }
LABEL_31:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            goto LABEL_9;
          }
        }

        __nwlog_obj();
        os_log_type_t v47 = (void *)objc_claimAutoreleasedReturnValue();
        name = default_input_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_path";
        if (!name) {
          name = "invalid";
        }
        __int16 v75 = 2082;
        __int16 v76 = (char *)name;
        __int16 v77 = 2048;
        char v69 = default_input_handler;
        __int16 v78 = (const char *)default_input_handler;
        os_log_type_t v49 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v73 = OS_LOG_TYPE_ERROR;
        char v70 = 0;
        if (__nwlog_fault(v49, &v73, &v70))
        {
          if (v73 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v51 = v73;
            if (os_log_type_enabled(v50, v73))
            {
              os_log_type_t v52 = v69->identifier->name;
              if (!v52) {
                os_log_type_t v52 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_path";
              __int16 v75 = 2082;
              __int16 v76 = (char *)v52;
              __int16 v77 = 2048;
              __int16 v78 = (const char *)v69;
              _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s protocol %{public}s (%p) has invalid get_path callback",  buf,  0x20u);
            }

uint64_t nw_protocol_flow_for_protocol(NWConcrete_nw_protocol_instance *a1, uint64_t a2)
{
  BOOL v3 = a1;
  if (nw_protocol_definition_get_message_is_stream(v3->parent_definition)
    && *(void *)&v3[-1].log_str[41] == a2)
  {
    a2 = -2LL;
  }

  return a2;
}

void ___ZL39nw_protocol_implementation_updated_pathP11nw_protocolS0_PU21objcproto10OS_nw_path8NSObject_block_invoke( uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = (char *)v4[37];
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = ___ZL39nw_protocol_implementation_updated_pathP11nw_protocolS0_PU21objcproto10OS_nw_path8NSObject_block_invoke_2;
  v7[3] = &unk_189BB78E0;
  id v8 = v3;
  uint64_t v9 = v4;
  int v10 = *(_DWORD *)(a1 + 40);
  id v6 = v3;
  nw_hash_table_apply(v5, (uint64_t)v7);
}

uint64_t ___ZL39nw_protocol_implementation_updated_pathP11nw_protocolS0_PU21objcproto10OS_nw_path8NSObject_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  if (nw_interface_shallow_compare(*(void **)(a1 + 32), *(void **)(extra + 16)))
  {
    nw_hash_node_get_object(a2);
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 80LL) + 224LL))();
  }

  return 1LL;
}

uint64_t ___ZL32nw_protocol_implementation_errorP11nw_protocolS0_i_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    uint64_t v5 = v4 - 96;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (object)
  {
    id v6 = object;
    id v7 = (void *)object[5];
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = object[11];
      if (v9) {
        object[11] = v9 + 1;
      }
      char v8 = -1;
    }

    else
    {
      char v8 = 0;
    }

    *(void *)os_log_type_t v49 = object;
    char v50 = v8;
    if (v4)
    {
      int v10 = *(void **)(v5 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v12 = *(void *)(v5 + 88);
        if (v12) {
          *(void *)(v5 + 88) = v12 + 1;
        }
        char v11 = -1;
      }

      else
      {
        char v11 = 0;
      }

      *(void *)BOOL v46 = v5;
      char v47 = v11;
      uint64_t v13 = object[3];
      if (v13)
      {
        char v14 = *(void (**)(void *))(v13 + 56);
        if (v14)
        {
          v14(object);
LABEL_19:
          if (v10 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v46);
          }
LABEL_21:
          if (v7 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v49);
          }
          return 1LL;
        }
      }

      __nwlog_obj();
      unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue();
      char v17 = (const char *)v6[2];
      *(_DWORD *)buf = 136446722;
      os_log_type_t v52 = "__nw_protocol_error";
      if (!v17) {
        char v17 = "invalid";
      }
      __int16 v53 = 2082;
      os_log_type_t v54 = (void *)v17;
      __int16 v55 = 2048;
      os_log_type_t v56 = v6;
      char v18 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v45 = 0;
      if (__nwlog_fault(v18, &type, &v45))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v19, type))
          {
            __int16 v21 = (const char *)v6[2];
            if (!v21) {
              __int16 v21 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v52 = "__nw_protocol_error";
            __int16 v53 = 2082;
            os_log_type_t v54 = (void *)v21;
            __int16 v55 = 2048;
            os_log_type_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s protocol %{public}s (%p) has invalid error callback",  buf,  0x20u);
          }
        }

        else if (v45)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v31 = type;
          BOOL v32 = os_log_type_enabled(v19, type);
          if (backtrace_string)
          {
            if (v32)
            {
              os_log_type_t v33 = (const char *)v6[2];
              if (!v33) {
                os_log_type_t v33 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              os_log_type_t v52 = "__nw_protocol_error";
              __int16 v53 = 2082;
              os_log_type_t v54 = (void *)v33;
              __int16 v55 = 2048;
              os_log_type_t v56 = v6;
              __int16 v57 = 2082;
              os_log_type_t v58 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            goto LABEL_70;
          }

          if (v32)
          {
            os_log_type_t v42 = (const char *)v6[2];
            if (!v42) {
              os_log_type_t v42 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v52 = "__nw_protocol_error";
            __int16 v53 = 2082;
            os_log_type_t v54 = (void *)v42;
            __int16 v55 = 2048;
            os_log_type_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v19, type))
          {
            BOOL v41 = (const char *)v6[2];
            if (!v41) {
              BOOL v41 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v52 = "__nw_protocol_error";
            __int16 v53 = 2082;
            os_log_type_t v54 = (void *)v41;
            __int16 v55 = 2048;
            os_log_type_t v56 = v6;
            _os_log_impl( &dword_181A5C000,  v19,  v40,  "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

void sub_181E858E0(_Unwind_Exception *exception_object)
{
}

uint64_t ___ZL33nw_protocol_implementation_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v4 = object[3];
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        id v6 = *(void (**)(void))(v4 + 160);
        if (v6)
        {
          int v7 = *(_DWORD *)(a1 + 56);
          char v8 = (void *)object[5];
          if (v8 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v10 = object[11];
            if (v10) {
              object[11] = v10 + 1;
            }
            char v9 = -1;
          }

          else
          {
            char v9 = 0;
          }

          os_log_type_t v29 = object;
          char v30 = v9;
          char v11 = *(void **)(v5 + 40);
          if (v11 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(v5 + 88);
            if (v13) {
              *(void *)(v5 + 88) = v13 + 1;
            }
            char v12 = -1;
          }

          else
          {
            char v12 = 0;
          }

          uint64_t v27 = v5;
          char v28 = v12;
          if (v7)
          {
            v6();
            goto LABEL_17;
          }

          __nwlog_obj();
          char v15 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "__nw_protocol_notify";
          unsigned int v16 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v25 = 0;
          if (__nwlog_fault(v16, &type, &v25))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v18 = type;
              if (os_log_type_enabled(v17, type))
              {
                *(_DWORD *)buf = 136446210;
                BOOL v32 = "__nw_protocol_notify";
                _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null type", buf, 0xCu);
              }
            }

            else
            {
              os_log_type_t v24 = v8;
              if (v25)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v21 = type;
                BOOL v22 = os_log_type_enabled(v20, type);
                if (backtrace_string)
                {
                  if (v22)
                  {
                    *(_DWORD *)buf = 136446466;
                    BOOL v32 = "__nw_protocol_notify";
                    __int16 v33 = 2082;
                    os_log_type_t v34 = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  char v8 = v24;
                  free(backtrace_string);
                  goto LABEL_38;
                }

                if (v22)
                {
                  *(_DWORD *)buf = 136446210;
                  BOOL v32 = "__nw_protocol_notify";
                  _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null type, no backtrace", buf, 0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v23 = type;
                if (os_log_type_enabled(v20, type))
                {
                  *(_DWORD *)buf = 136446210;
                  BOOL v32 = "__nw_protocol_notify";
                  _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s called with null type, backtrace limit exceeded",  buf,  0xCu);
                }
              }

              char v8 = v24;
            }
          }

void sub_181E85C64(_Unwind_Exception *exception_object)
{
}

void sub_181E85C70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (v21 == v20) {
    nw::release_if_needed<nw_protocol *>(&a17);
  }
  if (v19 == v20) {
    nw::release_if_needed<nw_protocol *>(&a19);
  }
  _Unwind_Resume(exception_object);
}

void nw_protocol_implementation_read(NWConcrete_nw_protocol_instance *a1, nw_protocol *a2)
{
  uint64_t v97 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!a2)
  {
    __nwlog_obj();
    BOOL v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_read";
    os_log_type_t v62 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v91) = 16;
    v89[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v62, &v91, v89))
    {
      if (v91 == 17)
      {
        __nwlog_obj();
        os_log_type_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v64 = v91;
        if (os_log_type_enabled(v63, (os_log_type_t)v91))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_read";
          _os_log_impl(&dword_181A5C000, v63, v64, "%{public}s called with null output_handler", buf, 0xCu);
        }
      }

      else if (v89[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v66 = v91;
        BOOL v67 = os_log_type_enabled(v63, (os_log_type_t)v91);
        if (backtrace_string)
        {
          if (v67)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_read";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v63,  v66,  "%{public}s called with null output_handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_174;
        }

        if (v67)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_read";
          _os_log_impl( &dword_181A5C000,  v63,  v66,  "%{public}s called with null output_handler, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v68 = v91;
        if (os_log_type_enabled(v63, (os_log_type_t)v91))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_read";
          _os_log_impl( &dword_181A5C000,  v63,  v68,  "%{public}s called with null output_handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E86DC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL45nw_protocol_implementation_get_input_internalP31NWConcrete_nw_protocol_instanceP11nw_protocolmjjj_block_invoke( void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  id v6 = v3 + 4;
  uint64_t v5 = v3[4];
  unint64_t v7 = (void *)v3[5];
  if (v5)
  {
    *(void *)(v5 + 40) = v7;
    unint64_t v7 = (void *)v3[5];
  }

  else
  {
    *(void *)(a1[5] + 8LL) = v7;
  }

  void *v7 = v5;
  *id v6 = 0LL;
  v3[5] = 0LL;
  uint64_t v8 = a1[4];
  uint64_t v9 = *(void *)(v8 + 8);
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, void *, void *, void))(*(void *)(v9 + 80) + 56LL);
  uint64_t v11 = a1[6];
  uint64_t v12 = nw_frame_copy_metadata_for_protocol((uint64_t)v3, v9);
  v10(v8, v11, v4, v12, 0LL);

  if (!*v6 && !v4[5] && (v4[2] || v4[3])) {
    nw_frame_finalize((uint64_t)v4);
  }

  return 1LL;
}

void sub_181E86EEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_protocol_implementation_readP31NWConcrete_nw_protocol_instanceP11nw_protocol_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t v6 = extra + 104;
  if (!*(void *)(extra + 104)) {
    return 1LL;
  }
  uint64_t v7 = extra;
  uint64_t v8 = *(void *)(a1 + 32);
  if ((!v8 || (*(char *)(v8 + 405) & 0x80000000) == 0) && gLogDatapath)
  {
    __nwlog_obj();
    os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      BOOL v28 = v27 == 0;
      if (v27) {
        os_log_type_t v29 = (const char *)(v27 + 407);
      }
      else {
        os_log_type_t v29 = "";
      }
      *(_DWORD *)buf = 136446978;
      char v47 = "nw_protocol_implementation_read_block_invoke";
      __int16 v48 = 2082;
      os_log_type_t v49 = (void *)v29;
      if (v28) {
        char v30 = "";
      }
      else {
        char v30 = " ";
      }
      __int16 v50 = 2080;
      os_log_type_t v51 = v30;
      __int16 v52 = 2048;
      uint64_t v53 = object;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing pending outbound frames for %lx (one-off)",  buf,  0x2Au);
    }
  }

  uint64_t v9 = *(const char **)(v7 + 32);
  if (v9)
  {
    uint64_t v10 = (void *)*((void *)v9 + 5);
    if (v10 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v12 = *((void *)v9 + 11);
      if (v12) {
        *((void *)v9 + 11) = v12 + 1;
      }
      char v11 = -1;
    }

    else
    {
      char v11 = 0;
    }

    *(void *)os_log_type_t v43 = v9;
    char v44 = v11;
    uint64_t v13 = *((void *)v9 + 3);
    if (v13)
    {
      char v14 = *(void (**)(const char *, uint64_t))(v13 + 96);
      if (v14)
      {
        v14(v9, v6);
LABEL_14:
        if (v10 == &nw_protocol_ref_counted_handle) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v43);
        }
        return 1LL;
      }
    }

    __nwlog_obj();
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v17 = (const char *)*((void *)v9 + 2);
    *(_DWORD *)buf = 136446722;
    char v47 = "__nw_protocol_finalize_output_frames";
    if (!v17) {
      uint64_t v17 = "invalid";
    }
    __int16 v48 = 2082;
    os_log_type_t v49 = (void *)v17;
    __int16 v50 = 2048;
    os_log_type_t v51 = v9;
    char v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v18, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          uint64_t v21 = (const char *)*((void *)v9 + 2);
          if (!v21) {
            uint64_t v21 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          char v47 = "__nw_protocol_finalize_output_frames";
          __int16 v48 = 2082;
          os_log_type_t v49 = (void *)v21;
          __int16 v50 = 2048;
          os_log_type_t v51 = v9;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback",  buf,  0x20u);
        }
      }

      else if (v42)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        BOOL v33 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v33)
          {
            if (*((void *)v9 + 2)) {
              os_log_type_t v34 = (const char *)*((void *)v9 + 2);
            }
            else {
              os_log_type_t v34 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            char v47 = "__nw_protocol_finalize_output_frames";
            __int16 v48 = 2082;
            os_log_type_t v49 = (void *)v34;
            __int16 v50 = 2048;
            os_log_type_t v51 = v9;
            __int16 v52 = 2082;
            uint64_t v53 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v32,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_64;
        }

        if (v33)
        {
          if (*((void *)v9 + 2)) {
            os_log_type_t v40 = (const char *)*((void *)v9 + 2);
          }
          else {
            os_log_type_t v40 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          char v47 = "__nw_protocol_finalize_output_frames";
          __int16 v48 = 2082;
          os_log_type_t v49 = (void *)v40;
          __int16 v50 = 2048;
          os_log_type_t v51 = v9;
          _os_log_impl( &dword_181A5C000,  v19,  v32,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v19, type))
        {
          BOOL v39 = (const char *)*((void *)v9 + 2);
          if (!v39) {
            BOOL v39 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          char v47 = "__nw_protocol_finalize_output_frames";
          __int16 v48 = 2082;
          os_log_type_t v49 = (void *)v39;
          __int16 v50 = 2048;
          os_log_type_t v51 = v9;
          _os_log_impl( &dword_181A5C000,  v19,  v38,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

void sub_181E87598(_Unwind_Exception *exception_object)
{
}

void nw_protocol_implementation_deliver_output_available(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  char v3 = BYTE5(v1->flow_in_connected);
  if ((v3 & 1) != 0)
  {
    if (v1->parent_definition->variant == 3)
    {
      BYTE5(v1->flow_in_connected) = v3 & 0xFE;
      tqh_last = (char *)v1->pending_outbound_frames.tqh_last;
      v31[0] = MEMORY[0x1895F87A8];
      v31[1] = 3221225472LL;
      v31[2] = ___ZL51nw_protocol_implementation_deliver_output_availableP31NWConcrete_nw_protocol_instance_block_invoke;
      v31[3] = &unk_189BC86F0;
      os_log_type_t v32 = v1;
      nw_hash_table_apply(tqh_last, (uint64_t)v31);

      goto LABEL_2;
    }

    uint64_t v5 = *(void **)&v1[-1].log_str[41];
    if (v5)
    {
      uint64_t v6 = v5[3];
      if (v6)
      {
        if (*(void *)(v6 + 72))
        {
          BYTE5(v2->flow_in_connected) = v3 & 0xFE;
          uint64_t v7 = (void *)v5[5];
          if (v7 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v9 = v5[11];
            if (v9) {
              v5[11] = v9 + 1;
            }
            char v8 = -1;
          }

          else
          {
            char v8 = 0;
          }

          BOOL v37 = v5;
          char v38 = v8;
          uint64_t v10 = *(void **)&v2[-1].log_str[33];
          if (v10 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v12 = *(void *)&v2[-1].log_str[81];
            if (v12) {
              *(void *)&v2[-1].log_str[81] = v12 + 1;
            }
            char v11 = -1;
          }

          else
          {
            char v11 = 0;
          }

          p_paths_log_id_num = &v2[-1].paths_log_id_num;
          char v36 = v11;
          uint64_t v13 = v5[3];
          if (v13)
          {
            char v14 = *(void (**)(void))(v13 + 72);
            if (v14)
            {
              v14();
              if (v10 != &nw_protocol_ref_counted_handle) {
                goto LABEL_23;
              }
              goto LABEL_22;
            }
          }

          char v30 = v10;
          int v15 = v5;
          __nwlog_obj();
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v17 = (const char *)v15[2];
          *(_DWORD *)buf = 136446722;
          os_log_type_t v40 = "__nw_protocol_output_available";
          if (!v17) {
            uint64_t v17 = "invalid";
          }
          __int16 v41 = 2082;
          char v42 = v17;
          __int16 v43 = 2048;
          char v18 = v15;
          char v44 = v15;
          uint64_t v19 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v33 = 0;
          if (__nwlog_fault(v19, &type, &v33))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v21 = type;
              if (os_log_type_enabled(v20, type))
              {
                uint64_t v22 = (const char *)v18[2];
                if (!v22) {
                  uint64_t v22 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v40 = "__nw_protocol_output_available";
                __int16 v41 = 2082;
                char v42 = v22;
                __int16 v43 = 2048;
                char v44 = v18;
                _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid output_available callback",  buf,  0x20u);
              }

void sub_181E87A60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v18 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  if (v15 == v14) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }
  if (v16 == v14) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);
  }

  _Unwind_Resume(a1);
}

uint64_t ___ZL51nw_protocol_implementation_deliver_output_availableP31NWConcrete_nw_protocol_instance_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  if (!extra) {
    return 1LL;
  }
  if ((*(_WORD *)(extra + 52) & 0x100) == 0) {
    return 1LL;
  }
  uint64_t v6 = object;
  if (!object) {
    return 1LL;
  }
  uint64_t v7 = object[3];
  if (!v7 || !*(void *)(a1 + 32) || !*(void *)(v7 + 72)) {
    return 1LL;
  }
  *(_WORD *)(extra + 52) &= ~0x100u;
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    uint64_t v9 = v8 - 96;
  }
  else {
    uint64_t v9 = 0LL;
  }
  uint64_t v10 = (void *)object[5];
  if (v10 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v12 = object[11];
    if (v12) {
      object[11] = v12 + 1;
    }
    char v11 = -1;
  }

  else
  {
    char v11 = 0;
  }

  char v44 = object;
  char v45 = v11;
  if (!v8)
  {
    __nwlog_obj();
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v47 = "__nw_protocol_output_available";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    v41[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v26, v41, &type))
    {
      if (v41[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = v41[0];
        if (os_log_type_enabled(v27, v41[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v47 = "__nw_protocol_output_available";
          _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = v41[0];
        BOOL v35 = os_log_type_enabled(v27, v41[0]);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v47 = "__nw_protocol_output_available";
            __int16 v48 = 2082;
            os_log_type_t v49 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v27,  v34,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_73;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v47 = "__nw_protocol_output_available";
          _os_log_impl( &dword_181A5C000,  v27,  v34,  "%{public}s called with null other_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v39 = v41[0];
        if (os_log_type_enabled(v27, v41[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v47 = "__nw_protocol_output_available";
          _os_log_impl( &dword_181A5C000,  v27,  v39,  "%{public}s called with null other_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E88108(_Unwind_Exception *exception_object)
{
}

uint64_t ___ZL49nw_protocol_implementation_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v4 = (uint64_t)v3;
  if (*(_DWORD *)(*(void *)(a1[4] + 8LL) + 64LL) == 3)
  {
    uint64_t metadata = (uint64_t *)nw_frame_get_metadata((uint64_t)v3);
    uint64_t v6 = metadata;
    if (metadata)
    {
      uint64_t v7 = *metadata;
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  uint64_t v7 = -1LL;
LABEL_6:
  uint64_t v8 = *(void *)(a1[5] + 8LL);
  uint64_t v9 = *(void *)(v8 + 24);
  if (v9 != v7)
  {
    if (v9 != -1)
    {
      uint64_t v10 = *(void (**)(void))(*(void *)(*(void *)(a1[4] + 8LL) + 80LL) + 104LL);
      if (v10)
      {
        v10();
        uint64_t v8 = *(void *)(a1[5] + 8LL);
      }
    }

    *(void *)(v8 + 24) = v7;
    char v11 = *(void (**)(void))(*(void *)(*(void *)(a1[4] + 8LL) + 80LL) + 96LL);
    if (v11) {
      v11();
    }
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      uint64_t size = nw_protocol_data_get_size((void *)v4);
      int is_metadata_complete = nw_frame_is_metadata_complete(v4);
      int v24 = *(unsigned __int8 *)(v4 + 186) >> 7;
      int v25 = 136447490;
      os_log_type_t v26 = "nw_protocol_implementation_finalize_output_frames_block_invoke";
      __int16 v27 = 2048;
      uint64_t v28 = v4;
      __int16 v29 = 2048;
      uint64_t v30 = size;
      __int16 v31 = 2048;
      os_log_type_t v32 = v6;
      __int16 v33 = 1024;
      int v34 = is_metadata_complete;
      __int16 v35 = 1024;
      int v36 = v24;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s calling handle outbound with frame %p (length %zu bytes), metadata %p complete: %u, connection complete: %u",  (uint8_t *)&v25,  0x36u);
    }
  }

  uint64_t v12 = *(void *)(v4 + 32);
  uint64_t v13 = *(void **)(v4 + 40);
  char v14 = (void *)(v4 + 32);
  if (v12)
  {
    *(void *)(v12 + 40) = v13;
    uint64_t v13 = *(void **)(v4 + 40);
  }

  else
  {
    *(void *)(a1[6] + 8LL) = v13;
  }

  *uint64_t v13 = v12;
  *char v14 = 0LL;
  *(void *)(v4 + 40) = 0LL;
  uint64_t v15 = a1[4];
  uint64_t v16 = *(void *)(v15 + 8);
  uint64_t v17 = *(void (**)(uint64_t, uint64_t, uint64_t, void *, uint64_t, void))(*(void *)(v16 + 80) + 64LL);
  uint64_t v18 = nw_frame_copy_metadata_for_protocol(v4, v16);
  uint64_t v19 = nw_frame_is_metadata_complete(v4);
  v17(v15, v7, v4, v18, v19, *(unsigned __int8 *)(v4 + 186) >> 7);

  if (!*v14 && !*(void *)(v4 + 40) && (*(void *)(v4 + 16) || *(void *)(v4 + 24)))
  {
    if (nw_frame_get_finalizer_context(v4)) {
      nw_frame_finalize(v4);
    }
  }

  return 1LL;
}

void sub_181E883A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_data_get_size(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_data_get_size";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null data", buf, 0xCu);
        }
      }

      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v17 = "nw_protocol_data_get_size";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_protocol_data_get_size";
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

BOOL nw_protocol_create_outbound_data(NWConcrete_nw_protocol_instance *a1, size_t a2, char a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  uint64_t v6 = v5;
  if (!*(void *)&v5->protocol_outbound_data_limit)
  {
    __nwlog_obj();
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v42 = "nw_protocol_create_outbound_data";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v42 = "nw_protocol_create_outbound_data";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null instance->context", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (!v39)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v42 = "nw_protocol_create_outbound_data";
        _os_log_impl( &dword_181A5C000,  v17,  v36,  "%{public}s called with null instance->context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        char v42 = "nw_protocol_create_outbound_data";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null instance->context, no backtrace",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      char v42 = "nw_protocol_create_outbound_data";
      __int16 v43 = 2082;
      size_t v44 = (size_t)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null instance->context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  data_from_pool = (nw_frame **)nw_protocol_create_data_from_pool(v5, a3);
  if ((a3 & 1) != 0)
  {
    os_log_type_t v8 = v6;
    if (data_from_pool)
    {
      nw_frame_reset((uint64_t)data_from_pool, 0LL, a2, (uint64_t)nw_protocol_outbound_data_finalizer, (uint64_t)v8);
      external = data_from_pool;
LABEL_44:
      external[2] = 0LL;
      tqh_last = v6->inbound_frames.tqh_last;
      external[3] = (nw_frame *)tqh_last;
      char *tqh_last = (nw_frame *)external;
      v6->inbound_frames.tqh_last = external + 2;
LABEL_45:

      return (BOOL)external;
    }

    external = (nw_frame **)nw_frame_create_external(16, a2, (uint64_t)nw_protocol_outbound_data_finalizer, (uint64_t)v8);
    if (!external)
    {
      __nwlog_obj();
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      char v42 = "nw_protocol_create_outbound_data";
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          char v42 = "nw_protocol_create_outbound_data";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s nw_frame_create_external failed", buf, 0xCu);
        }
      }

      else if (v39)
      {
        int v24 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v17, type);
        if (v24)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            char v42 = "nw_protocol_create_outbound_data";
            __int16 v43 = 2082;
            size_t v44 = (size_t)v24;
            _os_log_impl( &dword_181A5C000,  v17,  v25,  "%{public}s nw_frame_create_external failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v24);
LABEL_75:
          if (!v16)
          {
LABEL_77:
            external = 0LL;
            goto LABEL_45;
          }

void sub_181E88EF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_protocol_create_data_from_pool(NWConcrete_nw_protocol_instance *a1, char a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (!*(void *)&a1->protocol_outbound_data_limit)
  {
    __nwlog_obj();
    BOOL v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_create_data_from_pool";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v13, type, &v27))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_create_data_from_pool";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null instance->context", buf, 0xCu);
        }
      }

      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type[0];
        BOOL v18 = os_log_type_enabled(v14, type[0]);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_create_data_from_pool";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null instance->context, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_create_data_from_pool";
          _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null instance->context, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_create_data_from_pool";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null instance->context, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_protocol_outbound_data_finalizer(void *a1, int a2, char *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  char v5 = a1;
  if (a2)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_protocol_outbound_data_finalizer";
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s Finalizing outbound frame by copying",  buf,  0xCu);
      }
    }

    unsigned int v6 = nw_frame_unclaimed_length(v5);
    uint64_t v7 = v6;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = ___ZL35nw_protocol_outbound_data_finalizerPU22objcproto11OS_nw_frame8NSObjectbPv_block_invoke;
    v12[3] = &unk_189BB7978;
    unsigned int v15 = v6;
    uint64_t v13 = v5;
    char v14 = a3;
    char v16 = a2;
    nw_protocol_request_outbound_data(v14, 0LL, v7, v12);
  }

  else
  {
    if ((!a3 || (a3[405] & 0x80000000) == 0) && gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        id v10 = a3 + 407;
        if (!a3) {
          id v10 = "";
        }
        *(_DWORD *)buf = 136446978;
        BOOL v18 = "nw_protocol_outbound_data_finalizer";
        __int16 v19 = 2082;
        os_log_type_t v20 = v10;
        uint64_t v11 = " ";
        if (!a3) {
          uint64_t v11 = "";
        }
        __int16 v21 = 2080;
        os_log_type_t v22 = v11;
        __int16 v23 = 2048;
        int v24 = v5;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing outbound frame %p without copying (drop)",  buf,  0x2Au);
      }
    }

    nw_protocol_data_finalizer(a3, v5, 0LL, (uint64_t)(a3 + 144));
  }
}

void sub_181E89544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL35nw_protocol_outbound_data_finalizerPU22objcproto11OS_nw_frame8NSObjectbPv_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v3 = a2;
  uint64_t v4 = (uint64_t)v3;
  if (v3)
  {
    if (!v3[14]
      || (*((_WORD *)v3 + 102) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v3, v3[11]))
    {
      unsigned int v7 = 0;
    }

    else
    {
      int v6 = *(_DWORD *)(v4 + 52);
      uint64_t v5 = *(unsigned int *)(v4 + 56);
      if (v6)
      {
        unsigned int v7 = v6 - (v5 + *(_DWORD *)(v4 + 60));
        uint64_t v8 = *(void *)(v4 + 112);
        if (!v8) {
          goto LABEL_17;
        }
      }

      else
      {
        unsigned int v7 = 0;
        uint64_t v8 = *(void *)(v4 + 112);
        if (!v8) {
          goto LABEL_17;
        }
      }

      if (v7 == *(_DWORD *)(a1 + 48))
      {
        uint64_t v11 = (void *)(v8 + v5);
        BOOL v12 = (const void *)nw_frame_unclaimed_bytes(*(void *)(a1 + 32), 0LL);
        memcpy(v11, v12, v7);
        if (gLogDatapath)
        {
          __nwlog_obj();
          os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            int v18 = 136446466;
            __int16 v19 = "nw_protocol_outbound_data_finalizer_block_invoke";
            __int16 v20 = 1024;
            unsigned int v21 = v7;
            _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s Copying %u bytes for outbound frame",  (uint8_t *)&v18,  0x12u);
          }
        }

        uint64_t v13 = *(void **)(a1 + 40);
        uint64_t departure_time = nw_frame_get_departure_time(*(void *)(a1 + 32));
        nw_protocol_instance_add_outbound(v13, (void *)v4, 0LL, departure_time, 0, 1);
        goto LABEL_20;
      }
    }

void sub_181E89848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_request_outbound_data(void *a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  unsigned int v7 = a1;
  id v8 = a4;
  uint64_t v9 = v8;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v43 = "nw_protocol_request_outbound_data";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v41 = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = v41;
      BOOL v27 = os_log_type_enabled(v19, v41);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v43 = "nw_protocol_request_outbound_data";
          __int16 v44 = 2082;
          uint64_t v45 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v26,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v18)
        {
LABEL_10:
          uint64_t v10 = 0LL;
          goto LABEL_11;
        }

void sub_181E89FE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_data_finalizer(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  unsigned int v7 = a1;
  id v8 = a2;
  uint64_t v9 = (uint64_t)v8;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v46 = "nw_protocol_data_finalizer";
    unsigned int v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = "nw_protocol_data_finalizer";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v46 = "nw_protocol_data_finalizer";
          __int16 v47 = 2082;
          __int16 v48 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_89:
        if (!v23) {
          goto LABEL_35;
        }
LABEL_90:
        free(v23);
        goto LABEL_35;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = "nw_protocol_data_finalizer";
        _os_log_impl(&dword_181A5C000, v24, v31, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = "nw_protocol_data_finalizer";
        _os_log_impl( &dword_181A5C000,  v24,  v40,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E8A8B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_service_requested_outbound_data(void *a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v92 = *MEMORY[0x1895F89C0];
  unsigned int v7 = a1;
  unint64_t v78 = a2;
  id v8 = a4;
  uint64_t v9 = (void (**)(void, void))v8;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
    BOOL v37 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_181A5C000, v38, v39, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_126;
    }

    if (!(_BYTE)v81)
    {
      __nwlog_obj();
      unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl( &dword_181A5C000,  v38,  v57,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_126;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v45 = type[0];
    BOOL v46 = os_log_type_enabled(v38, type[0]);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_181A5C000, v38, v45, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_126;
    }

    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
      __int16 v86 = 2082;
      char v87 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v38,  v45,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_87;
  }

  if (!a3)
  {
    __nwlog_obj();
    os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
    BOOL v37 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v41 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_181A5C000, v38, v41, "%{public}s called with null data_size", buf, 0xCu);
      }

      goto LABEL_126;
    }

    if (!(_BYTE)v81)
    {
      __nwlog_obj();
      unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v58 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl( &dword_181A5C000,  v38,  v58,  "%{public}s called with null data_size, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_126;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v47 = type[0];
    BOOL v48 = os_log_type_enabled(v38, type[0]);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_181A5C000, v38, v47, "%{public}s called with null data_size, no backtrace", buf, 0xCu);
      }

      goto LABEL_126;
    }

    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
      __int16 v86 = 2082;
      char v87 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v38,  v47,  "%{public}s called with null data_size, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_87;
  }

  if (!v8)
  {
    __nwlog_obj();
    os_log_type_t v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
    BOOL v37 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl(&dword_181A5C000, v38, v43, "%{public}s called with null available_outbound_data", buf, 0xCu);
      }

void sub_181E8B85C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_request_outbound_data_block_invoke(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  int v6 = v5;
  if (a3)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    uint64_t v7 = 1LL;
  }

  else
  {
    uint64_t v7 = nw_protocol_service_requested_outbound_data( v5,  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void **)(a1 + 32));
  }

  return v7;
}

void sub_181E8B948(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL33nw_protocol_create_data_from_poolP31NWConcrete_nw_protocol_instanceb_block_invoke( uint64_t a1, void *a2)
{
  id v4 = a2;
  int v5 = nw_frame_uses_external_data((uint64_t)v4);
  int v6 = *(unsigned __int8 *)(a1 + 40);
  if (v6 == v5) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
  }

  return v6 != v5;
}

uint64_t ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( void *a1, void *a2)
{
  int v3 = a2;
  id v4 = v3;
  if (*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) && !nw_frame_unclaimed_length(v3))
  {
    uint64_t v7 = v4[4];
    id v8 = (void *)v4[5];
    int v6 = v4 + 4;
    if (v7)
    {
      *(void *)(v7 + 40) = v8;
      id v8 = (void *)v4[5];
    }

    else
    {
      *(void *)(a1[6] + 24LL) = v8;
    }

    *id v8 = v7;
    *int v6 = 0LL;
    v4[5] = 0LL;
    --*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
    uint64_t v9 = a1[7];
    --*(_DWORD *)(a1[6] + 32LL);
    ++*(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
    uint64_t v10 = *(void **)(v9 + 8);
    v4[4] = 0LL;
    v4[5] = v10;
    void *v10 = v4;
    *(void *)(v9 + 8) = v6;
    uint64_t v5 = 1LL;
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  return v5;
}

BOOL ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_278( void *a1, void *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  int v3 = a2;
  id v4 = v3;
  if (!*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) || !*(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL))
  {
    uint64_t v7 = 0LL;
LABEL_15:

    return v7;
  }

  unsigned int v5 = nw_frame_unclaimed_length(v3);
  size_t v6 = *(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
  if (v5 <= v6)
  {
    unsigned int v12 = v5;
    uint64_t v13 = v4;
    uint64_t v9 = v13;
    uint64_t v14 = v13[4];
    unsigned int v15 = (void *)v13[5];
    if (v14)
    {
      *(void *)(v14 + 40) = v15;
      unsigned int v15 = (void *)v13[5];
    }

    else
    {
      *(void *)(a1[8] + 24LL) = v15;
    }

    *unsigned int v15 = v14;
    v13[4] = 0LL;
    v13[5] = 0LL;
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) -= v12;
    --*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
    uint64_t v16 = a1[8];
    unsigned int v17 = *(_DWORD *)(v16 + 36) - v12;
    --*(_DWORD *)(v16 + 32);
    *(_DWORD *)(v16 + 36) = v17;
    goto LABEL_13;
  }

  if (!(_DWORD)v6)
  {
    __nwlog_obj();
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "strict_calloc";
    char v22 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v22);
    if (result) {
      goto LABEL_41;
    }
    free(v22);
  }

  uint64_t v7 = (uint64_t)calloc(1uLL, v6);
  if (v7) {
    goto LABEL_6;
  }
  __nwlog_obj();
  unsigned int v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v36 = "strict_calloc";
  __int16 v37 = 2048;
  uint64_t v38 = 1LL;
  __int16 v39 = 2048;
  size_t v40 = v6;
  uint64_t v24 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v24);
  if (!result)
  {
    free(v24);
LABEL_6:
    id v8 = (_WORD *)nw_frame_create( 0,  v7,  *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL),  (uint64_t)nw_protocol_implementation_partial_input_frame_finalizer,  0LL);
    if (v8)
    {
      v8[102] |= 1u;
      uint64_t v9 = v8;
      nw_frame_inherit_metadata((uint64_t)v4, (uint64_t)v9, 0);
      uint64_t v10 = (const void *)nw_frame_unclaimed_bytes((uint64_t)v4, 0LL);
      memcpy((void *)v7, v10, *(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL));
      nw_frame_claim((uint64_t)v4, v11, *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL), 0);
      *(_DWORD *)(a1[8] + 36LL) -= *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
      *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) = 0;
LABEL_13:
      ++*(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
      uint64_t v18 = a1[9];
      v9[4] = 0LL;
      char v19 = *(void **)(v18 + 8);
      v9[5] = v19;
      void *v19 = v9;
      *(void *)(v18 + 8) = v9 + 4;
      uint64_t v7 = 1LL;
LABEL_14:

      goto LABEL_15;
    }

    __nwlog_obj();
    os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_protocol_implementation_service_input_frames_block_invoke";
    char v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v26, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v36 = "nw_protocol_implementation_service_input_frames_block_invoke";
          _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s nw_frame_create with partial data failed", buf, 0xCu);
        }
      }

      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        BOOL v31 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v36 = "nw_protocol_implementation_service_input_frames_block_invoke";
            __int16 v37 = 2082;
            uint64_t v38 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s nw_frame_create with partial data failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v36 = "nw_protocol_implementation_service_input_frames_block_invoke";
          _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s nw_frame_create with partial data failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v36 = "nw_protocol_implementation_service_input_frames_block_invoke";
          _os_log_impl( &dword_181A5C000,  v27,  v32,  "%{public}s nw_frame_create with partial data failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E8C024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_279( void *a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  int v3 = a2;
  id v4 = v3;
  if (!*(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) || !*(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL))
  {
    uint64_t v7 = 0LL;
LABEL_15:

    return v7;
  }

  unsigned int v5 = nw_frame_unclaimed_length(v3);
  size_t v6 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
  if (v5 <= v6)
  {
    unsigned int v12 = v5;
    uint64_t v13 = v4;
    uint64_t v9 = v13;
    uint64_t v14 = v13[4];
    unsigned int v15 = (void *)v13[5];
    if (v14)
    {
      *(void *)(v14 + 40) = v15;
      unsigned int v15 = (void *)v13[5];
    }

    else
    {
      *(void *)(a1[4] + 192LL) = v15;
    }

    *unsigned int v15 = v14;
    v13[4] = 0LL;
    v13[5] = 0LL;
    *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) -= v12;
    --*(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
    *(_DWORD *)(a1[4] + 204LL) -= v12;
    --*(_DWORD *)(a1[4] + 200LL);
    goto LABEL_13;
  }

  if (!(_DWORD)v6)
  {
    __nwlog_obj();
    char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "strict_calloc";
    uint64_t v20 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v20);
    if (result) {
      goto LABEL_41;
    }
    free(v20);
  }

  uint64_t v7 = (uint64_t)calloc(1uLL, v6);
  if (v7) {
    goto LABEL_6;
  }
  __nwlog_obj();
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v34 = "strict_calloc";
  __int16 v35 = 2048;
  uint64_t v36 = 1LL;
  __int16 v37 = 2048;
  size_t v38 = v6;
  char v22 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v22);
  if (!result)
  {
    free(v22);
LABEL_6:
    id v8 = (_WORD *)nw_frame_create( 0,  v7,  *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL),  (uint64_t)nw_protocol_implementation_partial_input_frame_finalizer,  0LL);
    if (v8)
    {
      v8[102] |= 1u;
      uint64_t v9 = v8;
      nw_frame_inherit_metadata((uint64_t)v4, (uint64_t)v9, 0);
      uint64_t v10 = (const void *)nw_frame_unclaimed_bytes((uint64_t)v4, 0LL);
      memcpy((void *)v7, v10, *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL));
      nw_frame_claim((uint64_t)v4, v11, *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL), 0);
      *(_DWORD *)(a1[4] + 204LL) -= *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
      *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) = 0;
LABEL_13:
      ++*(_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL);
      uint64_t v16 = a1[9];
      v9[4] = 0LL;
      unsigned int v17 = *(void **)(v16 + 8);
      v9[5] = v17;
      *unsigned int v17 = v9;
      *(void *)(v16 + 8) = v9 + 4;
      uint64_t v7 = 1LL;
LABEL_14:

      goto LABEL_15;
    }

    __nwlog_obj();
    unsigned int v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_protocol_implementation_service_input_frames_block_invoke";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v24, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_protocol_implementation_service_input_frames_block_invoke";
          _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s nw_frame_create with partial data failed", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        BOOL v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v34 = "nw_protocol_implementation_service_input_frames_block_invoke";
            __int16 v35 = 2082;
            uint64_t v36 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s nw_frame_create with partial data failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_protocol_implementation_service_input_frames_block_invoke";
          _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s nw_frame_create with partial data failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_protocol_implementation_service_input_frames_block_invoke";
          _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s nw_frame_create with partial data failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E8C5E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_partial_input_frame_finalizer(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    uint64_t v2 = (uint64_t)v1;
    uint64_t v13 = v1;
    if ((*((_WORD *)v1 + 102) & 0x100) == 0
      || !g_channel_check_validity
      || (v3 = g_channel_check_validity(v1, *((void *)v1 + 11)), uint64_t v2 = (uint64_t)v13, v3))
    {
      id v4 = *(void **)(v2 + 112);
      if (v4)
      {
        free(v4);
        uint64_t v2 = (uint64_t)v13;
      }
    }

    nw_frame_reset(v2, 0LL, 0, 0LL, 0LL);

    return;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  unsigned int v17 = "nw_protocol_implementation_partial_input_frame_finalizer";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v6, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v17 = "nw_protocol_implementation_partial_input_frame_finalizer";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null frame", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v17 = "nw_protocol_implementation_partial_input_frame_finalizer";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v17 = "nw_protocol_implementation_partial_input_frame_finalizer";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null frame, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v17 = "nw_protocol_implementation_partial_input_frame_finalizer";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL ___ZL39nw_protocol_implementation_disconnectedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(nw_hash_node_get_extra(a2) + 128);
  if (v3 != 2) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return v3 == 2;
}

uint64_t ___ZL39nw_protocol_implementation_disconnectedP11nw_protocolS0__block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  if (object)
  {
    id v4 = object;
    uint64_t v5 = *(void *)(a1 + 32);
    size_t v6 = (void *)object[5];
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = object[11];
      if (v8) {
        object[11] = v8 + 1;
      }
      char v7 = -1;
    }

    else
    {
      char v7 = 0;
    }

    *(void *)BOOL v48 = object;
    char v49 = v7;
    if (v5)
    {
      uint64_t v9 = *(void **)(v5 + 40);
      if (v9 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(v5 + 88);
        if (v11) {
          *(void *)(v5 + 88) = v11 + 1;
        }
        char v10 = -1;
      }

      else
      {
        char v10 = 0;
      }

      *(void *)os_log_type_t v45 = v5;
      char v46 = v10;
      uint64_t v12 = object[3];
      if (v12)
      {
        uint64_t v13 = *(void (**)(void *))(v12 + 48);
        if (v13)
        {
          v13(object);
LABEL_16:
          if (v9 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v45);
          }
LABEL_18:
          if (v6 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v48);
          }
          return 1LL;
        }
      }

      __nwlog_obj();
      unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v16 = (const char *)v4[2];
      *(_DWORD *)buf = 136446722;
      __int16 v51 = "__nw_protocol_disconnected";
      if (!v16) {
        uint64_t v16 = "invalid";
      }
      __int16 v52 = 2082;
      uint64_t v53 = (void *)v16;
      __int16 v54 = 2048;
      os_log_type_t v55 = v4;
      unsigned int v17 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v44 = 0;
      if (__nwlog_fault(v17, &type, &v44))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            uint64_t v20 = (const char *)v4[2];
            if (!v20) {
              uint64_t v20 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v51 = "__nw_protocol_disconnected";
            __int16 v52 = 2082;
            uint64_t v53 = (void *)v20;
            __int16 v54 = 2048;
            os_log_type_t v55 = v4;
            _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback",  buf,  0x20u);
          }
        }

        else if (v44)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v30 = type;
          BOOL v31 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v31)
            {
              os_log_type_t v32 = (const char *)v4[2];
              if (!v32) {
                os_log_type_t v32 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "__nw_protocol_disconnected";
              __int16 v52 = 2082;
              uint64_t v53 = (void *)v32;
              __int16 v54 = 2048;
              os_log_type_t v55 = v4;
              __int16 v56 = 2082;
              os_log_type_t v57 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v18,  v30,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            goto LABEL_67;
          }

          if (v31)
          {
            uint64_t v41 = (const char *)v4[2];
            if (!v41) {
              uint64_t v41 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v51 = "__nw_protocol_disconnected";
            __int16 v52 = 2082;
            uint64_t v53 = (void *)v41;
            __int16 v54 = 2048;
            os_log_type_t v55 = v4;
            _os_log_impl( &dword_181A5C000,  v18,  v30,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v39 = type;
          if (os_log_type_enabled(v18, type))
          {
            size_t v40 = (const char *)v4[2];
            if (!v40) {
              size_t v40 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v51 = "__nw_protocol_disconnected";
            __int16 v52 = 2082;
            uint64_t v53 = (void *)v40;
            __int16 v54 = 2048;
            os_log_type_t v55 = v4;
            _os_log_impl( &dword_181A5C000,  v18,  v39,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

void sub_181E8D148(_Unwind_Exception *exception_object)
{
}

uint64_t ___ZL36nw_protocol_implementation_connectedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  if (object)
  {
    id v4 = object;
    uint64_t v5 = *(void *)(a1 + 32);
    size_t v6 = (void *)object[5];
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = object[11];
      if (v8) {
        object[11] = v8 + 1;
      }
      char v7 = -1;
    }

    else
    {
      char v7 = 0;
    }

    *(void *)BOOL v48 = object;
    char v49 = v7;
    if (v5)
    {
      uint64_t v9 = *(void **)(v5 + 40);
      if (v9 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(v5 + 88);
        if (v11) {
          *(void *)(v5 + 88) = v11 + 1;
        }
        char v10 = -1;
      }

      else
      {
        char v10 = 0;
      }

      *(void *)os_log_type_t v45 = v5;
      char v46 = v10;
      uint64_t v12 = object[3];
      if (v12)
      {
        uint64_t v13 = *(void (**)(void *))(v12 + 40);
        if (v13)
        {
          v13(object);
LABEL_16:
          if (v9 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v45);
          }
LABEL_18:
          if (v6 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v48);
          }
          return 1LL;
        }
      }

      __nwlog_obj();
      unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v16 = (const char *)v4[2];
      *(_DWORD *)buf = 136446722;
      __int16 v51 = "__nw_protocol_connected";
      if (!v16) {
        uint64_t v16 = "invalid";
      }
      __int16 v52 = 2082;
      uint64_t v53 = (void *)v16;
      __int16 v54 = 2048;
      os_log_type_t v55 = v4;
      unsigned int v17 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v44 = 0;
      if (__nwlog_fault(v17, &type, &v44))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            uint64_t v20 = (const char *)v4[2];
            if (!v20) {
              uint64_t v20 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v51 = "__nw_protocol_connected";
            __int16 v52 = 2082;
            uint64_t v53 = (void *)v20;
            __int16 v54 = 2048;
            os_log_type_t v55 = v4;
            _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s protocol %{public}s (%p) has invalid connected callback",  buf,  0x20u);
          }
        }

        else if (v44)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v30 = type;
          BOOL v31 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v31)
            {
              os_log_type_t v32 = (const char *)v4[2];
              if (!v32) {
                os_log_type_t v32 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "__nw_protocol_connected";
              __int16 v52 = 2082;
              uint64_t v53 = (void *)v32;
              __int16 v54 = 2048;
              os_log_type_t v55 = v4;
              __int16 v56 = 2082;
              os_log_type_t v57 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v18,  v30,  "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            goto LABEL_67;
          }

          if (v31)
          {
            uint64_t v41 = (const char *)v4[2];
            if (!v41) {
              uint64_t v41 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v51 = "__nw_protocol_connected";
            __int16 v52 = 2082;
            uint64_t v53 = (void *)v41;
            __int16 v54 = 2048;
            os_log_type_t v55 = v4;
            _os_log_impl( &dword_181A5C000,  v18,  v30,  "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v39 = type;
          if (os_log_type_enabled(v18, type))
          {
            size_t v40 = (const char *)v4[2];
            if (!v40) {
              size_t v40 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            __int16 v51 = "__nw_protocol_connected";
            __int16 v52 = 2082;
            uint64_t v53 = (void *)v40;
            __int16 v54 = 2048;
            os_log_type_t v55 = v4;
            _os_log_impl( &dword_181A5C000,  v18,  v39,  "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

void sub_181E8D97C(_Unwind_Exception *exception_object)
{
}

uint64_t ___ZL36nw_protocol_implementation_connectedP11nw_protocolS0__block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t extra = nw_hash_node_get_extra(a2);
  __int16 v6 = *(_WORD *)(extra + 52);
  if ((v6 & 0xC) != 4) {
    return 1LL;
  }
  if (*(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 80LL) + 120LL))
  {
    uint64_t v7 = extra;
    *(_WORD *)(extra + 52) = v6 | 8;
    uint64_t v8 = *(void ***)(a1 + 32);
    uint64_t v9 = *(void (**)(void **, uint64_t, void))(*((void *)v8[1] + 10) + 120LL);
    char v10 = v8;
    if (nw_protocol_definition_get_message_is_stream(v8[1]))
    {
    }

    v9(v10, object, *(_WORD *)(v7 + 52) & 1);
    return 1LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v12 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  unsigned int v23 = "nw_protocol_implementation_connected_block_invoke_2";
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v23 = "nw_protocol_implementation_connected_block_invoke";
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null instance->parent_definition->start",  buf,  0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v23 = "nw_protocol_implementation_connected_block_invoke";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null instance->parent_definition->start, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v13) {
          return 0LL;
        }
        goto LABEL_14;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v23 = "nw_protocol_implementation_connected_block_invoke";
        _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null instance->parent_definition->start, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v23 = "nw_protocol_implementation_connected_block_invoke";
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null instance->parent_definition->start, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v13) {
LABEL_14:
  }
    free(v13);
  return 0LL;
}

uint64_t ___ZL47nw_protocol_implementation_remove_input_handlerP11nw_protocolS0_b_block_invoke( uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int16 *)(nw_hash_node_get_extra(a2) + 52);
  if ((v3 & 2) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }
  return (v3 >> 1) & 1;
}

uint64_t ___ZL28nw_protocol_purge_frame_poolP31NWConcrete_nw_protocol_instance_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = v3;
  uint64_t v5 = *((void *)v3 + 2);
  __int16 v6 = (void *)*((void *)v3 + 3);
  if (v5)
  {
    *(void *)(v5 + 24) = v6;
    __int16 v6 = (void *)*((void *)v3 + 3);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 176LL) = v6;
  }

  *__int16 v6 = v5;
  *((void *)v3 + 2) = 0LL;
  *((void *)v3 + 3) = 0LL;
  uint64_t v7 = *(void *)(a1 + 32);
  int v8 = *(_DWORD *)(v7 + 160);
  *(_DWORD *)(v7 + 160) = v8 - 1;
  if (!v8)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 32) + 160LL);
        int v12 = 136446978;
        uint64_t v13 = "nw_protocol_purge_frame_pool_block_invoke";
        __int16 v14 = 2082;
        os_log_type_t v15 = "instance->empty_frame_pool_count";
        __int16 v16 = 2048;
        uint64_t v17 = 1LL;
        __int16 v18 = 2048;
        uint64_t v19 = v11;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  (uint8_t *)&v12,  0x2Au);
      }
    }

    *(_DWORD *)(*(void *)(a1 + 32) + 160LL) = 0;
  }

  return 1LL;
}

void nw_protocol_implementation_teardown(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v96 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v3 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v89 = "nw_protocol_implementation_teardown";
    uint64_t v36 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(p_paths_log_id_num) = 0;
    if (__nwlog_fault(v36, type, &p_paths_log_id_num))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type[0];
        if (os_log_type_enabled(v37, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v89 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null instance", buf, 0xCu);
        }
      }

      else if ((_BYTE)p_paths_log_id_num)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v40 = type[0];
        BOOL v41 = os_log_type_enabled(v37, type[0]);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v89 = "nw_protocol_implementation_teardown";
            __int16 v90 = 2082;
            unint64_t v91 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v37,  v40,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_93;
        }

        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v89 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_181A5C000, v37, v40, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v52 = type[0];
        if (os_log_type_enabled(v37, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v89 = "nw_protocol_implementation_teardown";
          _os_log_impl( &dword_181A5C000,  v37,  v52,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void ___ZL47nw_protocol_implementation_remove_input_handlerP11nw_protocolS0_b_block_invoke_269(uint64_t a1)
{
}

uint64_t ___ZL47nw_protocol_implementation_remove_input_handlerP11nw_protocolS0_b_block_invoke_270( uint64_t a1, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t object = nw_hash_node_get_object(a2);
  if (v3)
  {
    uint64_t v5 = object;
    uint64_t v6 = *(void *)(v3 + 48);
    if (v6 != object)
    {
      if (v6)
      {
        if (*(_UNKNOWN **)(v6 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v12 = *(void *)(v6 + 88);
          if (v12)
          {
            uint64_t v13 = v12 - 1;
            *(void *)(v6 + 88) = v13;
            if (!v13)
            {
              os_log_type_t v14 = *(void (***)(void))(v6 + 64);
              if (v14)
              {
                *(void *)(v6 + 64) = 0LL;
                v14[2](v14);
                _Block_release(v14);
              }

              if ((*(_BYTE *)(v6 + 72) & 1) != 0)
              {
                os_log_type_t v15 = *(const void **)(v6 + 64);
                if (v15) {
                  _Block_release(v15);
                }
              }

              free((void *)v6);
            }
          }
        }
      }

      *(void *)(v3 + 48) = v5;
      if (v5)
      {
        if (*(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v7 = *(void *)(v5 + 88);
          if (v7) {
            *(void *)(v5 + 88) = v7 + 1;
          }
        }
      }
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  __int16 v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v52 = "__nw_protocol_set_input_handler";
  uint64_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v49 = 0;
  if (__nwlog_fault(v17, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "__nw_protocol_set_input_handler";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v49)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v52 = "__nw_protocol_set_input_handler";
          __int16 v53 = 2082;
          __int16 v54 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v18,  v32,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_62;
      }

      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "__nw_protocol_set_input_handler";
        _os_log_impl(&dword_181A5C000, v18, v32, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "__nw_protocol_set_input_handler";
        _os_log_impl( &dword_181A5C000,  v18,  v37,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t ___ZL35nw_protocol_implementation_teardownP31NWConcrete_nw_protocol_instance_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  char v4 = (uint64_t *)(extra + 32);
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 - 64);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "__nw_protocol_get_output_handler";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "__nw_protocol_get_output_handler";
        uint64_t v13 = "%{public}s called with null protocol";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      }
    }

    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v19 = "__nw_protocol_get_output_handler";
            __int16 v20 = 2082;
            os_log_type_t v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (!v15) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "__nw_protocol_get_output_handler";
        uint64_t v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_21;
      }

      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "__nw_protocol_get_output_handler";
        uint64_t v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

uint64_t ___ZL34nw_protocol_fail_outbound_requestsP31NWConcrete_nw_protocol_instance_block_invoke( int a1, int a2, void *aBlock)
{
  uint64_t v3 = (void (**)(void *, void, uint64_t))_Block_copy(aBlock);
  v3[2](v3, 0LL, 1LL);

  return 1LL;
}

void sub_181E8F984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_protocol_instance_one_to_one_callbacksv_block_invoke()
{
  nw_protocol_instance_one_to_one_callbacks(void)::callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler( (void *)nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_add_input_handler);
  nw_protocol_callbacks_set_replace_input_handler( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_replace_input_handler);
  nw_protocol_callbacks_set_remove_input_handler( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_remove_input_handler);
  nw_protocol_callbacks_set_connected( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_connected);
  nw_protocol_callbacks_set_disconnect( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_disconnect);
  nw_protocol_callbacks_set_disconnected( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_disconnected);
  nw_protocol_callbacks_set_link_state( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_link_state);
  nw_protocol_callbacks_set_get_message_properties( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_message_properties);
  nw_protocol_callbacks_set_waiting_for_output( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_waiting_for_output);
  nw_protocol_callbacks_set_get_input_frames( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_input_frames);
  nw_protocol_callbacks_set_get_output_frames( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_get_output_frames);
  nw_protocol_callbacks_set_finalize_output_frames( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_finalize_output_frames);
  nw_protocol_callbacks_set_input_available( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_input_available);
  nw_protocol_callbacks_set_input_finished( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_input_finished);
  nw_protocol_callbacks_set_input_flush( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_input_flush);
  nw_protocol_callbacks_set_output_available( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_output_available);
  nw_protocol_callbacks_set_output_finished( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_output_finished);
  nw_protocol_callbacks_set_copy_info( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_copy_info);
  nw_protocol_callbacks_set_notify( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_notify);
  nw_protocol_callbacks_set_error( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_error);
  nw_protocol_callbacks_set_updated_path( nw_protocol_instance_one_to_one_callbacks(void)::callbacks,  (uint64_t)nw_protocol_implementation_updated_path);
}

void nw_protocol_definition_unregister(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_protocol_unregister((void *)v1 + 1);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_protocol_definition_unregister";
  char v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_unregister";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_protocol_definition_unregister";
          __int16 v15 = 2082;
          char v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_unregister";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_definition_unregister";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_definition_set_initialize(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_definition_set_initialize";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_protocol_definition_set_initialize";
          __int16 v23 = 2082;
          __int16 v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E90240(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_destroy(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_definition_set_destroy";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_protocol_definition_set_destroy";
          __int16 v23 = 2082;
          __int16 v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E90700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_inbound(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_definition_set_handle_inbound";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_handle_inbound";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_protocol_definition_set_handle_inbound";
          __int16 v23 = 2082;
          __int16 v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_handle_inbound";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_set_handle_inbound";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E90BC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_inbound_events(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  os_log_type_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    char v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v29 = "nw_protocol_definition_set_inbound_events";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v29 = "nw_protocol_definition_set_inbound_events";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E91290(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_outbound(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_handle_outbound";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_handle_outbound";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E91754(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_outbound_events(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  char v7 = a1;
  os_log_type_t v8 = v7;
  if (v7)
  {
    nw_protocol_definition_initialize_extended_state(v7);
    v8->extended_state->var12 = a2;
    v8->extended_state->var13 = a3;
    v8->extended_state->var14 = a4;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v20 = "nw_protocol_definition_set_outbound_events";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_protocol_definition_set_outbound_events";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v20 = "nw_protocol_definition_set_outbound_events";
          __int16 v21 = 2082;
          BOOL v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_protocol_definition_set_outbound_events";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_protocol_definition_set_outbound_events";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E91A14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_error(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_definition_set_handle_error";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_protocol_definition_set_handle_error";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E91ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_start(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var15 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_start";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_start";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_start";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_start";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_start";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E92180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_stop(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var16 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_stop";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_stop";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_stop";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_stop";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_stop";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E9242C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_link_state_update(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var17 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_link_state_update";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_link_state_update";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_link_state_update";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_link_state_update";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_link_state_update";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E926D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_link_congestion_state_update(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var18 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_link_congestion_state_update";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_link_congestion_state_update";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_link_congestion_state_update";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_link_congestion_state_update";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_link_congestion_state_update";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E92984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_traffic_mgmt_update(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var19 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_traffic_mgmt_update";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_traffic_mgmt_update";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_traffic_mgmt_update";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_traffic_mgmt_update";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_traffic_mgmt_update";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E92C30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_maximum_message_size_update(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var20 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_maximum_message_size_update";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_maximum_message_size_update";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_maximum_message_size_update";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_maximum_message_size_update";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_maximum_message_size_update";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E92EDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_copy_metadata(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var22 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_copy_metadata";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_metadata";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_copy_metadata";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_metadata";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_metadata";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E93188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_path_changed_handler(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var26 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_path_changed_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_path_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_path_changed_handler";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_path_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_path_changed_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E93434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_fallback_changed_handler(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var27 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_fallback_changed_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_fallback_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_fallback_changed_handler";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_fallback_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_fallback_changed_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E936E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_message_size_handler(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var28 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_message_size_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_message_size_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_message_size_handler";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_message_size_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_message_size_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E9398C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_copy_establishment_report(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var23 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_copy_establishment_report";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_establishment_report";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_copy_establishment_report";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_establishment_report";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_establishment_report";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E93C38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_copy_data_transfer_snapshot(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var24 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E93EE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_copy_quic_info(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var25 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_copy_quic_info";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_quic_info";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_copy_quic_info";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_quic_info";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_copy_quic_info";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E94190(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_probe_connectivity_update(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var21 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_probe_connectivity_update";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_probe_connectivity_update";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_probe_connectivity_update";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_probe_connectivity_update";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_probe_connectivity_update";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E9443C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_custom_flow_map_key_size(void *a1, unsigned int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var32 = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E946E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_create_inbound_data(void *a1, size_t a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a3;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "nw_protocol_create_inbound_data";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null instance", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (!v39)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_protocol_create_inbound_data";
        _os_log_impl( &dword_181A5C000,  v14,  v36,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_75;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v42 = "nw_protocol_create_inbound_data";
      __int16 v43 = 2082;
      size_t v44 = (size_t)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181E94F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_inbound_data_finalizer(void *a1, uint64_t a2, void *a3)
{
}

void sub_181E94FCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_protocol_make_subdata(void *a1, int a2, int a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  char v7 = v5;
  if (v5)
  {
    nw_frame_claim((uint64_t)v5, v6, a2, a3);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_protocol_make_subdata";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_protocol_make_subdata";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v19 = "nw_protocol_make_subdata";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_protocol_make_subdata";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_protocol_make_subdata";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_protocol_data_copy_outbound_subdata(void *a1, void *a2, size_t a3)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  char v7 = v6;
  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v59 = "nw_protocol_data_copy_outbound_subdata";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type[4] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v25, &type[4], type))
    {
      if (type[4] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type[4];
        if (os_log_type_enabled(v26, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v59 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null data", buf, 0xCu);
        }

        goto LABEL_80;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        char v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v51 = type[4];
        if (os_log_type_enabled(v26, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v59 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl( &dword_181A5C000,  v26,  v51,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_80;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type[4];
      BOOL v32 = os_log_type_enabled(v26, type[4]);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v59 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_181A5C000, v26, v31, "%{public}s called with null data, no backtrace", buf, 0xCu);
        }

        goto LABEL_80;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v59 = "nw_protocol_data_copy_outbound_subdata";
        __int16 v60 = 2082;
        size_t v61 = (size_t)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v26,  v31,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
      }

void nw_protocol_make_superdata(void *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  char v7 = v5;
  if (v5)
  {
    nw_frame_unclaim((uint64_t)v5, v6, a2, a3);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_protocol_make_superdata";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_make_superdata";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_make_superdata";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_make_superdata";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_make_superdata";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_data_trim(void *a1, unsigned int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  char v4 = v3;
  if (v3)
  {
    id v5 = v3;
    if (nw_frame_claim((uint64_t)v5, v6, a2, 0))
    {
      nw_frame_collapse((uint64_t)v5);
      nw_frame_unclaim((uint64_t)v5, v7, a2, 0);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_protocol_data_trim";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_data_trim";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_data_trim";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_data_trim";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_data_trim";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_data_access_buffer(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = (void (**)(void, void, void))v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_protocol_data_access_buffer";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_protocol_data_access_buffer";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_47:
        if (!v10) {
          goto LABEL_34;
        }
LABEL_48:
        free(v10);
        goto LABEL_34;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_data_access_buffer";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E967E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_data_get_ecn_flag(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((_BYTE *)v1 + 186) & 3;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void nw_protocol_data_set_ecn_flag(void *a1, char a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 186) = *((_BYTE *)v3 + 186) & 0xFC | a2 & 3;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_data_set_ecn_flag";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_set_ecn_flag";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_data_set_ecn_flag";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_set_ecn_flag";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_set_ecn_flag";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void nw_protocol_data_set_compression_generation_count(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    nw_frame_set_compression_generation_count((uint64_t)v3, a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_data_set_compression_generation_count";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_set_compression_generation_count";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_data_set_compression_generation_count";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_set_compression_generation_count";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_set_compression_generation_count";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

BOOL nw_protocol_data_is_in_array(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (*((void *)v1 + 4)) {
      BOOL v3 = 1LL;
    }
    else {
      BOOL v3 = *((void *)v1 + 5) != 0LL;
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_data_is_in_array";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_is_in_array";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_data_is_in_array";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_is_in_array";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_is_in_array";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

NWConcrete_nw_protocol_data_array *nw_protocol_data_array_create()
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  v0 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_data_array);
  id v1 = v0;
  if (v0)
  {
    uint64_t v2 = v0;
    goto LABEL_10;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_data_array_create";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (os_log_s *)(id)gLogObj;
    os_log_type_t v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_data_array_create";
      _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s [nw_protocol_data_array init] failed", buf, 0xCu);
    }

BOOL nw_protocol_data_array_is_empty(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 6)) {
      BOOL v3 = 0LL;
    }
    else {
      BOOL v3 = *((void *)v1 + 1) == 0LL;
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_protocol_data_array_is_empty";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_is_empty";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_protocol_data_array_is_empty";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_is_empty";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_is_empty";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_protocol_data_array_first(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[1];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_protocol_data_array_first";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_first";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_protocol_data_array_first";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_first";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_first";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_protocol_data_array_last(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = **(id **)(*((void *)v1 + 2) + 8LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_protocol_data_array_last";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_last";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_protocol_data_array_last";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_last";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_protocol_data_array_last";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_protocol_data_array_next(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (void *)*((void *)v1 + 4);
    if (!v3 && !*((void *)v1 + 5)) {
      id v3 = 0LL;
    }
    id v4 = v3;
    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_data_array_next";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_data_array_next";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null data", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_protocol_data_array_next";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_data_array_next";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_data_array_next";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void nw_protocol_data_array_append(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_data_array_append";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_data_array_append";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v24 = "nw_protocol_data_array_append";
          __int16 v25 = 2082;
          char v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_data_array_append";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_data_array_append";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_data_array_insert_after(void *a1, void *a2, void *a3)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  os_log_type_t v6 = a2;
  uint64_t v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v34 = "nw_protocol_data_array_insert_after";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v34 = "nw_protocol_data_array_insert_after";
          __int16 v35 = 2082;
          os_log_type_t v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v13) {
          goto LABEL_7;
        }
LABEL_58:
        free(v13);
        goto LABEL_7;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_data_array_prepend(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_protocol_data_array_prepend";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_protocol_data_array_prepend";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v26 = "nw_protocol_data_array_prepend";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v10) {
          goto LABEL_7;
        }
LABEL_42:
        free(v10);
        goto LABEL_7;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_protocol_data_array_prepend";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_protocol_data_array_prepend";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_data_array_remove(void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v34 = "nw_protocol_data_array_remove";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "nw_protocol_data_array_remove";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v34 = "nw_protocol_data_array_remove";
          __int16 v35 = 2082;
          os_log_type_t v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_62:
        if (!v18) {
          goto LABEL_28;
        }
LABEL_63:
        free(v18);
        goto LABEL_28;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "nw_protocol_data_array_remove";
        _os_log_impl(&dword_181A5C000, v19, v24, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "nw_protocol_data_array_remove";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_data_array_apply(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_protocol_data_array_apply";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_protocol_data_array_apply";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v30 = "nw_protocol_data_array_apply";
          __int16 v31 = 2082;
          BOOL v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v10) {
          goto LABEL_7;
        }
LABEL_42:
        free(v10);
        goto LABEL_7;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_protocol_data_array_apply";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_protocol_data_array_apply";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_protocol_data_array_apply_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void nw_protocol_data_array_prepend_array(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v26 = "nw_protocol_data_array_prepend_array";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_protocol_data_array_prepend_array";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          id v26 = "nw_protocol_data_array_prepend_array";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v10) {
          goto LABEL_8;
        }
LABEL_43:
        free(v10);
        goto LABEL_8;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_protocol_data_array_prepend_array";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_protocol_data_array_prepend_array";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_data_array_apppend_array(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v26 = "nw_protocol_data_array_apppend_array";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_protocol_data_array_apppend_array";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          id v26 = "nw_protocol_data_array_apppend_array";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v10) {
          goto LABEL_8;
        }
LABEL_43:
        free(v10);
        goto LABEL_8;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_protocol_data_array_apppend_array";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_protocol_data_array_apppend_array";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t nw_protocol_data_array_count(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[6];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_data_array_count";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_array_count";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_data_array_count";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_array_count";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_array_count";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_data_array_data_length(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(_DWORD *)buf = 0;
    nw_frame_array_get_frame_count(v1 + 1, 1, buf);
    uint64_t v3 = *(unsigned int *)buf;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_data_array_data_length";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_array_data_length";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_data_array_data_length";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_array_data_length";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_array_data_length";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id *nw_protocol_metadata_create(void *a1, _OWORD *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = v3[10];
  if (v4) {
    size_t v5 = *(unsigned int *)(v4 + 260);
  }
  else {
    size_t v5 = 0LL;
  }
  uint64_t v6 = (objc_class *)objc_opt_class();
  Instance = (id *)class_createInstance(v6, v5);
  os_log_type_t v8 = -[NWConcrete_nw_protocol_metadata initWithDefinition:identifier:](Instance, v3, a2);

  return v8;
}

void sub_181E9ACF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_metadata_copy_message_options(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_metadata_copy_message_options";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v21)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v24 = "nw_protocol_metadata_copy_message_options";
      __int16 v25 = 2082;
      id v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  uint64_t v3 = *((void *)v1 + 1);
  if (!v3)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_metadata_copy_message_options";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null metadata->definition", buf, 0xCu);
      }

void sub_181E9B1B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_metadata_create_reply(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_metadata_create_reply";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v21)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v24 = "nw_protocol_metadata_create_reply";
      __int16 v25 = 2082;
      id v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  uint64_t v3 = *((void *)v1 + 1);
  if (!v3)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_metadata_create_reply";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null metadata->definition", buf, 0xCu);
      }

void sub_181E9B680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_metadata_copy_original(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_metadata_copy_original";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_original";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v21)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_original";
        _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_original";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v24 = "nw_protocol_metadata_copy_original";
      __int16 v25 = 2082;
      id v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  uint64_t v3 = *((void *)v1 + 1);
  if (!v3)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_metadata_copy_original";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_metadata_copy_original";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null metadata->definition", buf, 0xCu);
      }

void sub_181E9BB48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_metadata_set_original(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_metadata_set_original";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_metadata_set_original";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v25 = "nw_protocol_metadata_set_original";
          __int16 v26 = 2082;
          uint64_t v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9) {
          goto LABEL_6;
        }
LABEL_41:
        free(v9);
        goto LABEL_6;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_metadata_set_original";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_metadata_set_original";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181E9C024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_metadata_is_equal(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v6 = a2;
  uint64_t v7 = v6;
  if (v5 == v6) {
    goto LABEL_7;
  }
  uint64_t v8 = 0LL;
  if (v5 && v6)
  {
    if (!nw_protocol_definition_is_equal_unsafe(v5[1], v6[1]))
    {
      uint64_t v8 = 0LL;
      goto LABEL_9;
    }

    os_log_type_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5[1] + 160);
    if (v9)
    {
      uint64_t v8 = v9(v7[1], v5[4], v7[4], a3);
      goto LABEL_9;
    }

void sub_181E9C0D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_options *nw_protocol_create_deserialized_options(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v6 = a1;
  uint64_t v7 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_protocol_options);
  uint64_t v8 = (char *)v6;
  os_log_type_t v9 = v8;
  if (v7)
  {
    if (!*((void *)v8 + 17))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v25 = "-[NWConcrete_nw_protocol_options initWithDefinition:serializedBytes:length:]";
        __int16 v26 = 2112;
        uint64_t v27 = v9;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s No deserialize function found for %@",  buf,  0x16u);
      }

      goto LABEL_8;
    }

    v23.os_log_type_t receiver = v7;
    v23.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_protocol_options;
    os_log_type_t v10 = (NWConcrete_nw_protocol_options *)objc_msgSendSuper2(&v23, sel_init);
    uint64_t v7 = v10;
    if (v10)
    {
      objc_storeStrong((id *)&v10->definition, a1);
      v7->uint64_t handle = (void *)(*((uint64_t (**)(char *, uint64_t, uint64_t))v9 + 17))(v9, a2, a3);
      goto LABEL_9;
    }

    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "-[NWConcrete_nw_protocol_options initWithDefinition:serializedBytes:length:]";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if ((__nwlog_fault(v14, &type, &v21) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "-[NWConcrete_nw_protocol_options initWithDefinition:serializedBytes:length:]";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v25 = "-[NWConcrete_nw_protocol_options initWithDefinition:serializedBytes:length:]";
            __int16 v26 = 2082;
            uint64_t v27 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "-[NWConcrete_nw_protocol_options initWithDefinition:serializedBytes:length:]";
          _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "-[NWConcrete_nw_protocol_options initWithDefinition:serializedBytes:length:]";
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181E9C478(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_options_set_instance(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((void *)v3 + 2) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_options_set_instance";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_options_set_instance";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_options_set_instance";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_options_set_log_id(void *a1, const char *a2, const char *a3, int a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  os_log_type_t v8 = v7;
  if (v7)
  {
    if (a3 && *a3)
    {
      *((_WORD *)v7 + 68) = a4;
      snprintf(v7 + 48, 0x54uLL, "[%s%s:%u]", a2, a3, a4);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v20 = "nw_protocol_options_set_log_id";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_options_set_log_id";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v20 = "nw_protocol_options_set_log_id";
          __int16 v21 = 2082;
          char v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_options_set_log_id";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_options_set_log_id";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_options_inherit_log_id(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_options_inherit_log_id";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v23 = "nw_protocol_options_inherit_log_id";
          __int16 v24 = 2082;
          __int16 v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_protocol_options_set_proxy_endpoint(void *a1, void *a2, char a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  if (v5)
  {
    *((_BYTE *)v5 + 152) = a3;
    objc_storeStrong((id *)v5 + 3, a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_protocol_options_set_proxy_endpoint";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_options_set_proxy_endpoint";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_protocol_options_set_proxy_endpoint";
          __int16 v19 = 2082;
          char v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_options_set_proxy_endpoint";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_protocol_options_set_proxy_endpoint";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_protocol_options_proxy_endpoint_should_override_stack(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_protocol_options_proxy_endpoint_should_override_stack";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_protocol_options_proxy_endpoint_should_override_stack";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null options", buf, 0xCu);
        }
      }

      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v16 = "nw_protocol_options_proxy_endpoint_should_override_stack";
            __int16 v17 = 2082;
            os_log_type_t v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_protocol_options_proxy_endpoint_should_override_stack";
          _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_protocol_options_proxy_endpoint_should_override_stack";
          _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

id nw_protocol_options_copy_proxy_endpoint_for_stack(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (void *)v1[3];
    if (v3)
    {
      id v4 = v3;
      int v5 = [v4 type];

      id v6 = (void *)v2[3];
      if (v5 == 4)
      {
        id v7 = (id)nw_endpoint_copy_host_port_endpoint_for_url(v6);
LABEL_7:
        id v8 = v7;
        goto LABEL_8;
      }
    }

    else
    {
      id v6 = 0LL;
    }

    id v7 = v6;
    goto LABEL_7;
  }

  __nwlog_obj();
  BOOL v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v21 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v21 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_protocol_options_copy_proxy_endpoint_for_stack";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181E9D6D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_protocol_options_copy_proxy_endpoint(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[3];
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_options_copy_proxy_endpoint";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_options_copy_proxy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_options_copy_proxy_endpoint";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_options_copy_proxy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_options_copy_proxy_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_options_add_proxy_next_hop(void *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v4)
  {
    uint64_t v5 = v3[4];
    if (!v5)
    {
      BOOL v6 = nw_array_create();
      id v7 = (void *)v3[4];
      v3[4] = v6;

      uint64_t v5 = v3[4];
    }

    nw_array_append(v5, v4);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_protocol_options_add_proxy_next_hop";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_options_add_proxy_next_hop";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null proxy_next_hop", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_options_add_proxy_next_hop";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null proxy_next_hop, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_options_add_proxy_next_hop";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null proxy_next_hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_options_add_proxy_next_hop";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null proxy_next_hop, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_options_enumerate_proxy_next_hops(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_protocol_options_enumerate_proxy_next_hops";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_protocol_options_enumerate_proxy_next_hops";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_protocol_options_enumerate_proxy_next_hops";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_40:
        free(v8);
        goto LABEL_5;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_protocol_options_enumerate_proxy_next_hops";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_protocol_options_enumerate_proxy_next_hops";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_protocol_options_enumerate_proxy_next_hops_block_invoke(uint64_t a1)
{
  return 1LL;
}

void nw_protocol_identifier_copy(uint64_t a1, __int128 *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      __int128 v2 = *a2;
      __int128 v3 = a2[1];
      *(void *)(a1 + 32) = *((void *)a2 + 4);
      *(_OWORD *)a1 = v2;
      *(_OWORD *)(a1 + 16) = v3;
      return;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_identifier_copy";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_identifier_copy";
          os_log_type_t v8 = "%{public}s called with null source";
          goto LABEL_32;
        }
      }

      else
      {
        if (v14)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v7 = type;
          BOOL v13 = os_log_type_enabled(v6, type);
          if (backtrace_string)
          {
            if (v13)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v17 = "nw_protocol_identifier_copy";
              __int16 v18 = 2082;
              os_log_type_t v19 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null source, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (v5) {
              goto LABEL_35;
            }
            return;
          }

          if (!v13) {
            goto LABEL_33;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_identifier_copy";
          os_log_type_t v8 = "%{public}s called with null source, no backtrace";
          goto LABEL_32;
        }

        __nwlog_obj();
        BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_identifier_copy";
          os_log_type_t v8 = "%{public}s called with null source, backtrace limit exceeded";
          goto LABEL_32;
        }
      }

      goto LABEL_33;
    }
  }

  else
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_identifier_copy";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_protocol_identifier_copy";
        os_log_type_t v8 = "%{public}s called with null destination";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }

BOOL nw_http_authentication_parse_schemes(_CFHTTPAuthentication *a1, void *a2, char a3, int a4, int a5)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  BOOL v9 = nw_array_create();
  error.domain = 0LL;
  *(void *)&error.CFStreamError error = 0LL;
  if (CFHTTPAuthenticationIsValid(a1, &error))
  {
    SchemesDict = (const __CFDictionary *)_CFHTTPAuthenticationGetSchemesDict();
    uint64_t v11 = _CFHTTPAuthenticationCopySortedAuthSchemes();
    os_log_type_t v12 = (const __CFArray *)v11;
    if (SchemesDict && v11)
    {
      char v30 = a3;
      CFIndex v13 = 0LL;
      char v14 = (const __CFString *)*MEMORY[0x1896020C0];
      BOOL v15 = (const __CFString *)*MEMORY[0x1896020C8];
      theString2 = (const __CFString *)*MEMORY[0x1896020D0];
      __int16 v31 = (const __CFString *)*MEMORY[0x1896020D8];
      while (1)
      {
        while (1)
        {
          if (v13 >= CFArrayGetCount(v12)) {
            goto LABEL_39;
          }
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v13);
          if (ValueAtIndex) {
            break;
          }
LABEL_6:
          ++v13;
        }

        os_log_type_t v17 = ValueAtIndex;
        int v18 = 1;
        if (CFStringCompare(ValueAtIndex, v14, 1uLL) == kCFCompareEqualTo) {
          goto LABEL_25;
        }
        if (CFStringCompare(v17, v15, 1uLL) == kCFCompareEqualTo) {
          break;
        }
        if (CFStringCompare(v17, theString2, 1uLL) == kCFCompareEqualTo)
        {
          int v18 = 5;
          goto LABEL_25;
        }

        if (CFStringCompare(v17, v31, 1uLL))
        {
          if (CFStringCompare(v17, @"OAuth", 1uLL) == kCFCompareEqualTo)
          {
            int v18 = 6;
            goto LABEL_25;
          }

          if (CFStringCompare(v17, @"PrivateToken", 1uLL) == kCFCompareEqualTo)
          {
            int v18 = 8;
            goto LABEL_25;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v19 = (os_log_s *)gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_6;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_parse_schemes";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v17;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s Unsupported authentication type '%{public}@'",  buf,  0x16u);
          ++v13;
        }

        else
        {
          if ((v30 & 1) != 0)
          {
            int v18 = 4;
            goto LABEL_25;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (os_log_s *)gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_6;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_parse_schemes";
          _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_ERROR, "%{public}s Negotiate requires a URL", buf, 0xCu);
          ++v13;
        }
      }

      int v18 = 2;
LABEL_25:
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      uint64_t v37 = nw_authentication_protection_space_create(v18);
      nw_authentication_protection_space_set_endpoint(*(void **)(*(void *)&buf[8] + 24LL), a2);
      if (a4)
      {
        nw_authentication_protection_space_set_is_proxy(*(void **)(*(void *)&buf[8] + 24LL), 1);
        nw_authentication_protection_space_set_proxy_origin_is_cleartext(*(void **)(*(void *)&buf[8] + 24LL), a5);
      }

      Value = (const __CFDictionary *)CFDictionaryGetValue(SchemesDict, v17);
      if (Value && (id v22 = (const __CFString *)CFDictionaryGetValue(Value, @"Realm")) != 0LL)
      {
        v34[0] = MEMORY[0x1895F87A8];
        v34[1] = 0x40000000LL;
        v34[2] = __nw_http_authentication_parse_schemes_block_invoke;
        v34[3] = &unk_189BB79C0;
        v34[4] = buf;
        nw_utilities_get_c_string_from_cfstring(v22, 0x201u, v34);
      }

      else
      {
        char v23 = *(void **)(*(void *)&buf[8] + 24LL);
        hostname = nw_endpoint_get_hostname((nw_endpoint_t)a2);
        nw_authentication_protection_space_set_realm(v23, hostname);
      }

      nw_array_append(v9, *(void **)(*(void *)&buf[8] + 24LL));
      __int16 v25 = *(void **)(*(void *)&buf[8] + 24LL);
      if (v25)
      {
        os_release(v25);
        *(void *)(*(void *)&buf[8] + 24LL) = 0LL;
      }

      _Block_object_dispose(buf, 8);
      goto LABEL_6;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v27 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = "WWW-Authenticate";
      if (a4) {
        uint64_t v28 = "Proxy-Authenticate";
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_parse_schemes";
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&buf[14] = v28;
      _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_ERROR, "%{public}s Unable to parse %s header", buf, 0x16u);
    }

void __nw_http_authentication_parse_schemes_block_invoke(uint64_t a1, const char *a2)
{
}

BOOL nw_protocol_http_authentication_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v122 = *MEMORY[0x1895F89C0];
  BOOL v6 = (dispatch_object_s **)calloc(1uLL, 0x428uLL);
  if (!v6)
  {
    os_log_type_t v65 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "strict_calloc";
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = 1LL;
    *(_WORD *)&_BYTE buf[22] = 2048;
    uint64_t v119 = 1064LL;
    uint64_t v66 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v66);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v66);
  }

  bzero(v6, 0x428uLL);
  if (gLogDatapath)
  {
    uint64_t v67 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_authentication_create";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = (char *)v6 + 114;
      *(_WORD *)&_BYTE buf[22] = 2080;
      uint64_t v119 = (uint64_t)" ";
      _os_log_impl(&dword_181A5C000, v67, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
    }
  }

  if (nw_protocol_http_authentication_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http_authentication_identifier::onceToken, &__block_literal_global_13809);
  }
  v6[2] = (dispatch_object_s *)&nw_protocol_http_authentication_identifier::protocol_identifier;
  v6[3] = (dispatch_object_s *)&nw_protocol_http_authentication_get_callbacks(void)::protocol_callbacks;
  v6[5] = (dispatch_object_s *)v6;
  os_log_type_t v7 = (dispatch_object_s *)nw_parameters_copy_url_endpoint(a4);
  if (!v7)
  {
    if (!a3)
    {
      os_log_type_t v8 = 0LL;
      char v9 = *((_BYTE *)v6 + 792);
      if ((v9 & 1) == 0) {
        goto LABEL_13;
      }
      goto LABEL_11;
    }

    os_log_type_t v7 = (dispatch_object_s *)os_retain(a3);
  }

  os_log_type_t v8 = v7;
  char v9 = *((_BYTE *)v6 + 792);
  if ((v9 & 1) == 0) {
    goto LABEL_13;
  }
LABEL_11:
  os_log_type_t v10 = v6[98];
  if (v10)
  {
    os_release(v10);
    char v9 = *((_BYTE *)v6 + 792);
  }

void sub_181EA0030( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void nw_protocol_http_authentication_create::$_0::__invoke( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
}

void nw_protocol_http_authentication_create::$_1::__invoke( uint64_t a1, int a2, void *object, int a4, uint64_t a5)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v52[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == 17)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null protocol";
    }

    else if (v52[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      BOOL v40 = os_log_type_enabled(v27, (os_log_type_t)type[0]);
      if (backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "operator()";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_136:
        if (!v26) {
          return;
        }
        goto LABEL_137;
      }

      if (!v40) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_135;
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v52[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] != 17)
    {
      if (v52[0] == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v27 = (os_log_s *)__nwlog_obj();
        os_log_type_t v28 = type[0];
        if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
          goto LABEL_136;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v29 = "%{public}s called with null http_authentication, backtrace limit exceeded";
        goto LABEL_135;
      }

      os_log_type_t v41 = (char *)__nw_create_backtrace_string();
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      BOOL v42 = os_log_type_enabled(v27, (os_log_type_t)type[0]);
      if (!v41)
      {
        if (!v42) {
          goto LABEL_136;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v29 = "%{public}s called with null http_authentication, no backtrace";
        goto LABEL_135;
      }

      if (!v42) {
        goto LABEL_95;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v41;
      __int16 v43 = "%{public}s called with null http_authentication, dumping backtrace:%{public}s";
      goto LABEL_94;
    }

    __int16 v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type[0];
    if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
      goto LABEL_136;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    uint64_t v29 = "%{public}s called with null http_authentication";
LABEL_135:
    _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
    goto LABEL_136;
  }

  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v52[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == 17)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null metadata";
      goto LABEL_135;
    }

    if (v52[0] == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_135;
    }

    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    __int16 v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type[0];
    BOOL v44 = os_log_type_enabled(v27, (os_log_type_t)type[0]);
    if (!v41)
    {
      if (!v44) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_135;
    }

    if (!v44) {
      goto LABEL_95;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "operator()";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v41;
    __int16 v43 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_94:
    _os_log_impl(&dword_181A5C000, v27, v28, v43, buf, 0x16u);
    goto LABEL_95;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v52[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == 17)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null completion";
      goto LABEL_135;
    }

    if (v52[0] == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type[0];
      if (!os_log_type_enabled(v27, (os_log_type_t)type[0])) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_135;
    }

    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    __int16 v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type[0];
    BOOL v45 = os_log_type_enabled(v27, (os_log_type_t)type[0]);
    if (!v41)
    {
      if (!v45) {
        goto LABEL_136;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v29 = "%{public}s called with null completion, no backtrace";
      goto LABEL_135;
    }

    if (v45)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v41;
      __int16 v43 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_94;
    }

void nw_http_authentication_reissue(nw_protocol *a1)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_authentication_reissue";
    char v15 = (char *)_os_log_send_and_compose_impl();
    v41[0] = 16;
    os_log_type_t v35 = OS_LOG_TYPE_DEFAULT;
    if (v41[0] == 17)
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = v41[0];
      if (!os_log_type_enabled(v16, (os_log_type_t)v41[0])) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_reissue";
      int v18 = "%{public}s called with null protocol";
    }

    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = v41[0];
      BOOL v20 = os_log_type_enabled(v16, (os_log_type_t)v41[0]);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_reissue";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v15) {
          return;
        }
LABEL_56:
        free(v15);
        return;
      }

      if (!v20) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_reissue";
      int v18 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = v41[0];
      if (!os_log_type_enabled(v16, (os_log_type_t)v41[0])) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_reissue";
      int v18 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_http_authentication_create::$_2::__invoke( nw_protocol_http_authentication_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "operator()";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v14)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "operator()";
        int v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_37;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v10) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "operator()";
        int v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_37;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "operator()";
        __int16 v18 = 2082;
        __int16 v19 = backtrace_string;
        char v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
        _os_log_impl(&dword_181A5C000, v6, v7, v11, buf, 0x16u);
      }

uint64_t nw_protocol_http_authentication_create::$_3::__invoke( nw_protocol_http_authentication_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_authentication_create::$_4::__invoke( nw_protocol_http_authentication_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_authentication_create::$_5::__invoke( nw_protocol_http_authentication_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_authentication_create::$_6::__invoke( nw_protocol_http_authentication_create::$_6 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t __Block_byref_object_copy__97(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__98(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    __int128 v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 556LL) |= 0x10u;
  return result;
}

uint64_t ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_2(uint64_t a1, uint64_t *a2)
{
  nw_frame_set_metadata( *a2,  *(nw_protocol_metadata **)(*(void *)(a1 + 32) + 592LL),  0,  (*(_WORD *)(*(void *)(a1 + 32) + 1062LL) & 8) == 0);
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = *(_BYTE *)(v3 + 920);
  if ((v4 & 1) != 0)
  {
    int v5 = *(void **)(v3 + 912);
    if (v5)
    {
      os_release(v5);
      char v4 = *(_BYTE *)(v3 + 920);
    }
  }

  *(void *)(v3 + 912) = 0LL;
  *(_BYTE *)(v3 + 920) = v4 | 1;
  uint64_t v6 = *(void *)(a1 + 32);
  char v7 = *(_BYTE *)(v6 + 936);
  if ((v7 & 1) != 0)
  {
    int v8 = *(void **)(v6 + 928);
    if (v8)
    {
      os_release(v8);
      char v7 = *(_BYTE *)(v6 + 936);
    }
  }

  *(void *)(v6 + 92_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(v6 + 936) = v7 | 1;
  uint64_t v9 = *(void *)(a1 + 32);
  char v10 = *(_BYTE *)(v9 + 952);
  if ((v10 & 1) != 0)
  {
    char v11 = *(void **)(v9 + 944);
    if (v11)
    {
      os_release(v11);
      char v10 = *(_BYTE *)(v9 + 952);
    }
  }

  *(void *)(v9 + 944) = 0LL;
  *(_BYTE *)(v9 + 952) = v10 | 1;
  uint64_t v12 = *(void *)(a1 + 32);
  char v13 = *(_BYTE *)(v12 + 968);
  if ((v13 & 1) != 0)
  {
    char v14 = *(void **)(v12 + 960);
    if (v14)
    {
      os_release(v14);
      char v13 = *(_BYTE *)(v12 + 968);
    }
  }

  *(void *)(v12 + 960) = 0LL;
  *(_BYTE *)(v12 + 96_Block_object_dispose(va, 8) = v13 | 1;
  return 1LL;
}

uint64_t ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_3(uint64_t a1)
{
  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_52);
  }
  id v2 = (id)nw_protocol_copy_http_client_definition_definition;
  identifier = nw_protocol_definition_get_identifier(v2);
  if (v2) {
    os_release(v2);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  do
  {
    uint64_t v4 = *(void *)(v4 + 48);
    if (!v4) {
      return 1LL;
    }
  }

  while (!nw_protocols_are_equal(*(void **)(v4 + 16), identifier));
  int v5 = nw_parameters_copy_protocol_options_legacy( *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  (nw_protocol *)v4);
  uint64_t v6 = nw_http_client_options_copy_resend_handler(v5);
  BOOL v7 = v6 == 0LL;
  if (v6)
  {
    int v8 = v6;
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8LL);
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 0x40000000LL;
    v12[2] = ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_4;
    v12[3] = &__block_descriptor_tmp_103;
    void v12[4] = v9;
    (*((void (**)(void *, void, void *))v6 + 2))(v6, *(void *)(v10 + 40), v12);
    _Block_release(v8);
  }

  if (v5) {
    os_release(v5);
  }
  return v7;
}

void ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_5(uint64_t a1)
{
}

void nw_http_authentication_destroy(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v36 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        int v37 = 136446722;
        uint64_t v38 = "nw_http_authentication_destroy";
        __int16 v39 = 2082;
        uint64_t v40 = a1 + 114;
        __int16 v41 = 2080;
        BOOL v42 = " ";
        _os_log_impl(&dword_181A5C000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", (uint8_t *)&v37, 0x20u);
      }
    }
  }

  if (*(_DWORD *)(a1 + 552))
  {
    *(_BYTE *)(a1 + 556) |= 0x40u;
    if ((*(_BYTE *)(a1 + 198) & 1) == 0 && gLogDatapath)
    {
      id v2 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        int v37 = 136446722;
        uint64_t v38 = "nw_http_authentication_destroy";
        __int16 v39 = 2082;
        uint64_t v40 = a1 + 114;
        __int16 v41 = 2080;
        BOOL v42 = " ";
        _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sdeferring destroy because the request is being reissued",  (uint8_t *)&v37,  0x20u);
      }
    }
  }

  else
  {
    if ((*(_BYTE *)(a1 + 1032) & 1) != 0)
    {
      uint64_t v3 = *(const void **)(a1 + 1024);
      if (v3) {
        CFRelease(v3);
      }
    }

    *(void *)(a1 + 1024) = 0LL;
    if ((*(_BYTE *)(a1 + 1016) & 1) != 0)
    {
      uint64_t v4 = *(const void **)(a1 + 1008);
      if (v4) {
        CFRelease(v4);
      }
    }

    *(void *)(a1 + 100_Block_object_dispose(va, 8) = 0LL;
    if ((*(_BYTE *)(a1 + 1000) & 1) != 0)
    {
      int v5 = *(const void **)(a1 + 992);
      if (v5) {
        CFRelease(v5);
      }
    }

    *(void *)(a1 + 992) = 0LL;
    if ((*(_BYTE *)(a1 + 984) & 1) != 0)
    {
      uint64_t v6 = *(const void **)(a1 + 976);
      if (v6) {
        CFRelease(v6);
      }
    }

    *(void *)(a1 + 976) = 0LL;
    if ((*(_BYTE *)(a1 + 968) & 1) != 0)
    {
      BOOL v7 = *(void **)(a1 + 960);
      if (v7) {
        os_release(v7);
      }
    }

    *(void *)(a1 + 960) = 0LL;
    if ((*(_BYTE *)(a1 + 952) & 1) != 0)
    {
      int v8 = *(void **)(a1 + 944);
      if (v8) {
        os_release(v8);
      }
    }

    *(void *)(a1 + 944) = 0LL;
    if ((*(_BYTE *)(a1 + 936) & 1) != 0)
    {
      uint64_t v9 = *(void **)(a1 + 928);
      if (v9) {
        os_release(v9);
      }
    }

    *(void *)(a1 + 92_Block_object_dispose(va, 8) = 0LL;
    if ((*(_BYTE *)(a1 + 920) & 1) != 0)
    {
      uint64_t v10 = *(void **)(a1 + 912);
      if (v10) {
        os_release(v10);
      }
    }

    *(void *)(a1 + 912) = 0LL;
    if ((*(_BYTE *)(a1 + 904) & 1) != 0)
    {
      char v11 = *(const void **)(a1 + 896);
      if (v11) {
        CFRelease(v11);
      }
    }

    *(void *)(a1 + 896) = 0LL;
    if ((*(_BYTE *)(a1 + 888) & 1) != 0)
    {
      uint64_t v12 = *(const void **)(a1 + 880);
      if (v12) {
        CFRelease(v12);
      }
    }

    *(void *)(a1 + 880) = 0LL;
    if ((*(_BYTE *)(a1 + 872) & 1) != 0)
    {
      char v13 = *(void **)(a1 + 864);
      if (v13) {
        os_release(v13);
      }
    }

    *(void *)(a1 + 864) = 0LL;
    if ((*(_BYTE *)(a1 + 856) & 1) != 0)
    {
      char v14 = *(void **)(a1 + 848);
      if (v14) {
        os_release(v14);
      }
    }

    *(void *)(a1 + 84_Block_object_dispose(va, 8) = 0LL;
    if ((*(_BYTE *)(a1 + 840) & 1) != 0)
    {
      char v15 = *(void **)(a1 + 832);
      if (v15) {
        os_release(v15);
      }
    }

    *(void *)(a1 + 832) = 0LL;
    if ((*(_BYTE *)(a1 + 824) & 1) != 0)
    {
      uint64_t v16 = *(void **)(a1 + 816);
      if (v16) {
        os_release(v16);
      }
    }

    *(void *)(a1 + 816) = 0LL;
    if ((*(_BYTE *)(a1 + 808) & 1) != 0)
    {
      os_log_type_t v17 = *(void **)(a1 + 800);
      if (v17) {
        os_release(v17);
      }
    }

    *(void *)(a1 + 800) = 0LL;
    if ((*(_BYTE *)(a1 + 792) & 1) != 0)
    {
      __int16 v18 = *(void **)(a1 + 784);
      if (v18) {
        os_release(v18);
      }
    }

    *(void *)(a1 + 784) = 0LL;
    if ((*(_BYTE *)(a1 + 776) & 1) != 0)
    {
      __int16 v19 = *(dispatch_object_s **)(a1 + 768);
      if (v19) {
        dispatch_release(v19);
      }
    }

    *(void *)(a1 + 76_Block_object_dispose(va, 8) = 0LL;
    if ((*(_BYTE *)(a1 + 760) & 1) != 0)
    {
      __int16 v20 = *(const void **)(a1 + 752);
      if (v20) {
        _Block_release(v20);
      }
    }

    *(void *)(a1 + 752) = 0LL;
    if ((*(_BYTE *)(a1 + 744) & 1) != 0)
    {
      uint64_t v21 = *(void **)(a1 + 736);
      if (v21) {
        os_release(v21);
      }
    }

    *(void *)(a1 + 736) = 0LL;
    if ((*(_BYTE *)(a1 + 728) & 1) != 0)
    {
      uint64_t v22 = *(void **)(a1 + 720);
      if (v22) {
        os_release(v22);
      }
    }

    *(void *)(a1 + 720) = 0LL;
    if ((*(_BYTE *)(a1 + 712) & 1) != 0)
    {
      id v23 = *(void **)(a1 + 704);
      if (v23) {
        os_release(v23);
      }
    }

    *(void *)(a1 + 704) = 0LL;
    if ((*(_BYTE *)(a1 + 696) & 1) != 0)
    {
      __int16 v24 = *(void **)(a1 + 688);
      if (v24) {
        os_release(v24);
      }
    }

    *(void *)(a1 + 68_Block_object_dispose(va, 8) = 0LL;
    if ((*(_BYTE *)(a1 + 680) & 1) != 0)
    {
      __int16 v25 = *(void **)(a1 + 672);
      if (v25) {
        os_release(v25);
      }
    }

    *(void *)(a1 + 672) = 0LL;
    if ((*(_BYTE *)(a1 + 664) & 1) != 0)
    {
      os_log_type_t v26 = *(void **)(a1 + 656);
      if (v26) {
        os_release(v26);
      }
    }

    *(void *)(a1 + 656) = 0LL;
    if ((*(_BYTE *)(a1 + 648) & 1) != 0)
    {
      __int16 v27 = *(void **)(a1 + 640);
      if (v27) {
        os_release(v27);
      }
    }

    *(void *)(a1 + 640) = 0LL;
    if ((*(_BYTE *)(a1 + 632) & 1) != 0)
    {
      os_log_type_t v28 = *(const void **)(a1 + 624);
      if (v28) {
        CFRelease(v28);
      }
    }

    *(void *)(a1 + 624) = 0LL;
    if ((*(_BYTE *)(a1 + 616) & 1) != 0)
    {
      BOOL v29 = *(const void **)(a1 + 608);
      if (v29) {
        _Block_release(v29);
      }
    }

    *(void *)(a1 + 60_Block_object_dispose(va, 8) = 0LL;
    if ((*(_BYTE *)(a1 + 600) & 1) != 0)
    {
      char v30 = *(void **)(a1 + 592);
      if (v30) {
        os_release(v30);
      }
    }

    *(void *)(a1 + 592) = 0LL;
    if ((*(_BYTE *)(a1 + 584) & 1) != 0)
    {
      __int16 v31 = *(void **)(a1 + 576);
      if (v31) {
        os_release(v31);
      }
    }

    *(void *)(a1 + 576) = 0LL;
    if ((*(_BYTE *)(a1 + 568) & 1) != 0)
    {
      os_log_type_t v32 = *(void **)(a1 + 560);
      if (v32) {
        os_release(v32);
      }
    }

    *(void *)(a1 + 560) = 0LL;
    nw_protocol_plugin_retry::~nw_protocol_plugin_retry((nw_protocol_plugin_retry *)(a1 + 344));
    if ((*(_BYTE *)(a1 + 288) & 1) != 0)
    {
      uint64_t v33 = *(void **)(a1 + 280);
      if (v33) {
        os_release(v33);
      }
    }

    *(void *)(a1 + 280) = 0LL;
    if ((*(_BYTE *)(a1 + 272) & 1) != 0)
    {
      char v34 = *(void **)(a1 + 264);
      if (v34) {
        os_release(v34);
      }
    }

    *(void *)(a1 + 264) = 0LL;
    if ((*(_BYTE *)(a1 + 256) & 1) != 0)
    {
      os_log_type_t v35 = *(void **)(a1 + 248);
      if (v35) {
        os_release(v35);
      }
    }

    free((void *)a1);
  }

void ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_4( uint64_t a1, nw_content_context_t context)
{
}

uint64_t __Block_byref_object_copy__88(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__89(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void nw_http_authentication_apply_appsso_headers(const __CFString *a1, const void *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_authentication_apply_appsso_headers";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_apply_appsso_headers";
      uint64_t v10 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      BOOL v12 = os_log_type_enabled(v8, v17);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_apply_appsso_headers";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          return;
        }
LABEL_39:
        free(v7);
        return;
      }

      if (!v12) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_apply_appsso_headers";
      uint64_t v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_apply_appsso_headers";
      uint64_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t __Block_byref_object_copy__90(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__91(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t ___ZL34nw_http_authentication_apply_cacheP11nw_protocol_block_invoke( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  http_authentication = (_CFHTTPAuthentication *)nw_authentication_credential_cache_entry_get_http_authentication((void *)a3);
  if (CFHTTPAuthenticationIsValid(http_authentication, 0LL)
    && CFHTTPAuthenticationAppliesToRequest(http_authentication, *(CFHTTPMessageRef *)(*(void *)(a1[4] + 8LL) + 40LL)))
  {
    if (a3)
    {
      int v6 = *(_DWORD *)(a3 + 24);
      if (v6 == 4)
      {
        NegotiateHeaderForRequest = (const __CFString *)_CFHTTPAuthenticationCreateNegotiateHeaderForRequest();
        if (!NegotiateHeaderForRequest) {
          goto LABEL_34;
        }
LABEL_33:
        CFRelease(NegotiateHeaderForRequest);
        goto LABEL_34;
      }

      char v8 = *(_BYTE *)(a3 + 28);
      BOOL v9 = v8 != 0;
      id v10 = *(id *)(a3 + 16);
LABEL_8:
      if (!nw_http_authentication_apply_credentials( *(__CFHTTPMessage **)(*(void *)(a1[4] + 8LL) + 40LL),  http_authentication,  v10))
      {
        if (v10) {
          os_release(v10);
        }
        goto LABEL_34;
      }

      if (v6 == 5)
      {
        NegotiateHeaderForRequest = (const __CFString *)_CFHTTPAuthenticationCreateNTLMHeaderForRequest();
        uint64_t v11 = a1[6];
        if (!v9)
        {
LABEL_11:
          char v12 = *(_BYTE *)(v11 + 856);
          if ((v12 & 1) != 0)
          {
            char v13 = *(void **)(v11 + 848);
            if (v13)
            {
              os_release(v13);
              char v12 = *(_BYTE *)(v11 + 856);
            }
          }

          *(void *)(v11 + 84_Block_object_dispose(va, 8) = http_authentication;
          *(_BYTE *)(v11 + 856) = v12 | 1;
          uint64_t v14 = a1[6];
          char v15 = *(_BYTE *)(v14 + 664);
          if ((v15 & 1) != 0)
          {
            char v16 = *(void **)(v14 + 656);
            if (v16)
            {
              os_release(v16);
              char v15 = *(_BYTE *)(v14 + 664);
            }
          }

          *(void *)(v14 + 656) = v10;
          *(_BYTE *)(v14 + 664) = v15 | 1;
          *(_DWORD *)(a1[6] + 1044LL) = v6;
LABEL_31:
          if (!NegotiateHeaderForRequest) {
            return 1LL;
          }
          v45[0] = MEMORY[0x1895F87A8];
          v45[1] = 0x40000000LL;
          v45[2] = ___ZL34nw_http_authentication_apply_cacheP11nw_protocol_block_invoke_2;
          v45[3] = &unk_189BB7DE0;
          v45[4] = a1[5];
          char v46 = v8;
          nw_utilities_get_c_string_from_cfstring(NegotiateHeaderForRequest, 0x201u, v45);
          http_authentication = 0LL;
          goto LABEL_33;
        }
      }

      else
      {
        if (v9) {
          os_log_type_t v17 = @"Proxy-Authorization";
        }
        else {
          os_log_type_t v17 = @"Authorization";
        }
        NegotiateHeaderForRequest = CFHTTPMessageCopyHeaderFieldValue( *(CFHTTPMessageRef *)(*(void *)(a1[4] + 8LL) + 40LL),  v17);
        *(_WORD *)(a1[6] + 1062LL) |= 0x200u;
        uint64_t v11 = a1[6];
        if (!v9) {
          goto LABEL_11;
        }
      }

      char v18 = *(_BYTE *)(v11 + 872);
      if ((v18 & 1) != 0)
      {
        uint64_t v19 = *(void **)(v11 + 864);
        if (v19)
        {
          os_release(v19);
          char v18 = *(_BYTE *)(v11 + 872);
        }
      }

      *(void *)(v11 + 864) = http_authentication;
      *(_BYTE *)(v11 + 872) = v18 | 1;
      uint64_t v20 = a1[6];
      char v21 = *(_BYTE *)(v20 + 680);
      if ((v21 & 1) != 0)
      {
        uint64_t v22 = *(void **)(v20 + 672);
        if (v22)
        {
          os_release(v22);
          char v21 = *(_BYTE *)(v20 + 680);
        }
      }

      *(void *)(v20 + 672) = v10;
      *(_BYTE *)(v20 + 680) = v21 | 1;
      *(_DWORD *)(a1[6] + 1048LL) = v6;
      goto LABEL_31;
    }

    __nwlog_obj();
    __int16 v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v50 = "nw_authentication_credential_cache_entry_get_for_proxy";
    __int16 v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (__nwlog_fault(v25, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v50 = "nw_authentication_credential_cache_entry_get_for_proxy";
          os_log_type_t v28 = "%{public}s called with null cache_entry";
LABEL_50:
          _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
          goto LABEL_51;
        }

        goto LABEL_51;
      }

      if (!v47)
      {
        __nwlog_obj();
        os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v50 = "nw_authentication_credential_cache_entry_get_for_proxy";
          os_log_type_t v28 = "%{public}s called with null cache_entry, backtrace limit exceeded";
          goto LABEL_50;
        }

BOOL nw_http_authentication_apply_credentials(__CFHTTPMessage *a1, _CFHTTPAuthentication *a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t username = nw_authentication_credential_get_username(a3);
  uint64_t password = nw_authentication_credential_get_password(a3);
  char v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (username) {
    BOOL v9 = (const char *)username;
  }
  else {
    BOOL v9 = "";
  }
  id v10 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v9, 0x8000100u);
  if (password) {
    uint64_t v11 = (const char *)password;
  }
  else {
    uint64_t v11 = "";
  }
  char v12 = CFStringCreateWithCString(v8, v11, 0x8000100u);
  v16.domain = 0LL;
  *(void *)&v16.CFStreamError error = 0LL;
  int v13 = CFHTTPMessageApplyCredentials(a1, a2, v10, v12, &v16);
  if (!v13)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      char v18 = "nw_http_authentication_apply_credentials";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s CFHTTPMessageApplyCredentials() failed",  buf,  0xCu);
    }
  }

  if (v12) {
    CFRelease(v12);
  }
  if (v10) {
    CFRelease(v10);
  }
  return v13 != 0;
}

void ___ZL34nw_http_authentication_apply_cacheP11nw_protocol_block_invoke_2(uint64_t a1, char *a2)
{
  if (*(_BYTE *)(a1 + 40)) {
    uint64_t v3 = "Proxy-Authorization";
  }
  else {
    uint64_t v3 = "Authorization";
  }
  nw_http_fields_append_advanced( *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  (unint64_t)v3,  -1LL,  a2,  0xFFFFFFFFFFFFFFFFLL,  &__block_literal_global_94);
}

uint64_t ___ZL34nw_http_authentication_apply_cacheP11nw_protocol_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return nw_http_field_set_indexing_strategy(a2, 1u);
}

void ___ZL43nw_http_authentication_apply_appsso_headersPKvS0_Pv_block_invoke(uint64_t a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  v3[2] = ___ZL43nw_http_authentication_apply_appsso_headersPKvS0_Pv_block_invoke_2;
  v3[3] = &unk_189BB7D50;
  id v2 = *(const __CFString **)(a1 + 40);
  v3[4] = *(void *)(a1 + 32);
  v3[5] = a2;
  nw_utilities_get_c_string_from_cfstring(v2, 0x201u, v3);
}

void ___ZL43nw_http_authentication_apply_appsso_headersPKvS0_Pv_block_invoke_2(uint64_t a1, uint64_t a2)
{
}

void nw_protocol_http_authentication_create::$_0::operator()(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    int buf = 136446210;
    buf_4 = "operator()";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v45) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null protocol";
    }

    else if ((_BYTE)v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      BOOL v25 = os_log_type_enabled(v21, type[0]);
      if (backtrace_string)
      {
        if (v25)
        {
          int buf = 136446466;
          buf_4 = "operator()";
          __int16 v49 = 2082;
          BOOL v50 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x16u);
        }

        free(backtrace_string);
LABEL_97:
        if (!v20) {
          return;
        }
        goto LABEL_98;
      }

      if (!v25) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_96;
  }

  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4)
  {
    __nwlog_obj();
    int buf = 136446210;
    buf_4 = "operator()";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v45) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v45)
      {
        char v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_97;
        }
        int buf = 136446210;
        buf_4 = "operator()";
        id v23 = "%{public}s called with null http_authentication, backtrace limit exceeded";
        goto LABEL_96;
      }

      os_log_type_t v26 = (char *)__nw_create_backtrace_string();
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      BOOL v27 = os_log_type_enabled(v21, type[0]);
      if (!v26)
      {
        if (!v27) {
          goto LABEL_97;
        }
        int buf = 136446210;
        buf_4 = "operator()";
        id v23 = "%{public}s called with null http_authentication, no backtrace";
        goto LABEL_96;
      }

      if (!v27) {
        goto LABEL_74;
      }
      int buf = 136446466;
      buf_4 = "operator()";
      __int16 v49 = 2082;
      BOOL v50 = v26;
      os_log_type_t v28 = "%{public}s called with null http_authentication, dumping backtrace:%{public}s";
      goto LABEL_73;
    }

    char v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type[0];
    if (!os_log_type_enabled(v21, type[0])) {
      goto LABEL_97;
    }
    int buf = 136446210;
    buf_4 = "operator()";
    id v23 = "%{public}s called with null http_authentication";
LABEL_96:
    _os_log_impl(&dword_181A5C000, v21, v22, v23, (uint8_t *)&buf, 0xCu);
    goto LABEL_97;
  }

  if (!a2)
  {
    __nwlog_obj();
    int buf = 136446210;
    buf_4 = "operator()";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v45) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v45)
      {
        char v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_97;
        }
        int buf = 136446210;
        buf_4 = "operator()";
        id v23 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_96;
      }

      os_log_type_t v26 = (char *)__nw_create_backtrace_string();
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      BOOL v29 = os_log_type_enabled(v21, type[0]);
      if (!v26)
      {
        if (!v29) {
          goto LABEL_97;
        }
        int buf = 136446210;
        buf_4 = "operator()";
        id v23 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_96;
      }

      if (!v29) {
        goto LABEL_74;
      }
      int buf = 136446466;
      buf_4 = "operator()";
      __int16 v49 = 2082;
      BOOL v50 = v26;
      os_log_type_t v28 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_73;
    }

    char v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type[0];
    if (!os_log_type_enabled(v21, type[0])) {
      goto LABEL_97;
    }
    int buf = 136446210;
    buf_4 = "operator()";
    id v23 = "%{public}s called with null other_protocol";
    goto LABEL_96;
  }

  if (!a3)
  {
    __nwlog_obj();
    int buf = 136446210;
    buf_4 = "operator()";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v45) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null metadata";
      goto LABEL_96;
    }

    if (!(_BYTE)v45)
    {
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_96;
    }

    os_log_type_t v26 = (char *)__nw_create_backtrace_string();
    char v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type[0];
    BOOL v30 = os_log_type_enabled(v21, type[0]);
    if (!v26)
    {
      if (!v30) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_96;
    }

    if (!v30) {
      goto LABEL_74;
    }
    int buf = 136446466;
    buf_4 = "operator()";
    __int16 v49 = 2082;
    BOOL v50 = v26;
    os_log_type_t v28 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_73:
    _os_log_impl(&dword_181A5C000, v21, v22, v28, (uint8_t *)&buf, 0x16u);
    goto LABEL_74;
  }

  if (!a4)
  {
    __nwlog_obj();
    int buf = 136446210;
    buf_4 = "operator()";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v45) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null completion";
      goto LABEL_96;
    }

    if (!(_BYTE)v45)
    {
      char v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_96;
    }

    os_log_type_t v26 = (char *)__nw_create_backtrace_string();
    char v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type[0];
    BOOL v31 = os_log_type_enabled(v21, type[0]);
    if (!v26)
    {
      if (!v31) {
        goto LABEL_97;
      }
      int buf = 136446210;
      buf_4 = "operator()";
      id v23 = "%{public}s called with null completion, no backtrace";
      goto LABEL_96;
    }

    if (v31)
    {
      int buf = 136446466;
      buf_4 = "operator()";
      __int16 v49 = 2082;
      BOOL v50 = v26;
      os_log_type_t v28 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_73;
    }

void *nw_http_authentication_copy_protocol_metadata(nw_protocol *a1)
{
  id v1 = (unsigned __int8 *)nw_protocol_copy_info((uint64_t)a1->output_handler, 255);
  uint64_t v6 = 0LL;
  id v7 = &v6;
  uint64_t v8 = 0x3802000000LL;
  char v9 = __Block_byref_object_copy__14084;
  id v10 = __Block_byref_object_dispose__14085;
  uint64_t object = 0LL;
  char v12 = -1;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  v5[2] = ___ZL45nw_http_authentication_copy_protocol_metadataP11nw_protocol_block_invoke;
  v5[3] = &unk_189BB7A48;
  v5[4] = &v6;
  nw_array_apply(v1, (uint64_t)v5);
  id v2 = (void *)v7[5];
  if (v2) {
    uint64_t v3 = os_retain(v2);
  }
  else {
    uint64_t v3 = 0LL;
  }
  _Block_object_dispose(&v6, 8);
  if ((v12 & 1) != 0 && object) {
    os_release(object);
  }
  if (v1) {
    os_release(v1);
  }
  return v3;
}

void ___ZL40nw_http_authentication_process_challengeP11nw_protocol_block_invoke( uint64_t a1, void *object, int a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(*(void *)(a1 + 32) + 198LL) & 1) == 0)
  {
    if (gLogDatapath)
    {
      CFStreamError v16 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v17 = *(void *)(a1 + 32) + 114LL;
        int v18 = 136447234;
        uint64_t v19 = "nw_http_authentication_process_challenge_block_invoke";
        __int16 v20 = 2082;
        uint64_t v21 = v17;
        __int16 v22 = 2080;
        id v23 = " ";
        __int16 v24 = 2048;
        BOOL v25 = object;
        __int16 v26 = 1024;
        int v27 = a3;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sreturned from nw_http_authentication_process_response, new_outbound_metadata %p, cancel %d",  (uint8_t *)&v18,  0x30u);
      }
    }
  }

  if (object) {
    uint64_t v8 = os_retain(object);
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  char v10 = *(_BYTE *)(v9 + 600);
  if ((v10 & 1) != 0)
  {
    id v11 = *(void **)(v9 + 592);
    if (v11)
    {
      os_release(v11);
      char v10 = *(_BYTE *)(v9 + 600);
    }
  }

  *(void *)(v9 + 592) = v8;
  *(_BYTE *)(v9 + 600) = v10 | 1;
  if (a3)
  {
    nw_protocol_plugin_metadata_resume_input(*(void *)(a1 + 32) + 200LL, 1);
    nw_protocol_input_available(*(void **)(*(void *)(a1 + 40) + 48LL), *(void *)(a1 + 40));
  }

  else
  {
    if (a4) {
      char v12 = 1;
    }
    else {
      char v12 = 2;
    }
    uint64_t v13 = *(void *)(a1 + 32);
    *(_BYTE *)(v13 + 1060) = v12;
    *(_WORD *)(v13 + 1062) |= 0x40u;
    if ((*(_BYTE *)(*(void *)(a1 + 32) + 1062LL) & 4) == 0)
    {
      id v14 = nw_http_metadata_copy_request(object);
      nw_http_fields_remove_by_name(v14, (uint64_t)"Cookie");
      if (v14) {
        os_release(v14);
      }
    }

    nw_protocol_plugin_metadata_prepare_for_reissue(*(void *)(a1 + 32) + 200LL);
    uint64_t v15 = *(void *)(a1 + 32);
    if (*(_BYTE *)(v15 + 1060) != 1) {
      nw_http_authentication_reissue((nw_protocol *)v15);
    }
  }

uint64_t nw_http_authentication_handle_challenge( uint64_t a1, _CFHTTPAuthentication *a2, void *a3, int a4, char a5, uint64_t a6)
{
  uint64_t v134 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
    os_log_type_t v101 = (char *)_os_log_send_and_compose_impl();
    v130[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v130[0] == 17)
    {
      os_log_type_t v102 = (os_log_s *)__nwlog_obj();
      os_log_type_t v103 = v130[0];
      if (os_log_type_enabled(v102, (os_log_type_t)v130[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
        os_log_type_t v104 = "%{public}s called with null protocol";
LABEL_191:
        _os_log_impl(&dword_181A5C000, v102, v103, v104, buf, 0xCu);
      }

void sub_181EA67FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181EA680C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181EA681C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_http_authentication_apply_authorization( uint64_t a1, _CFHTTPAuthentication *a2, void *a3, int a4, int a5, int a6, int a7, uint64_t a8)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v59 = "nw_http_authentication_apply_authorization";
    int v37 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(error.domain) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(error.domain) != 17)
    {
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v38 = (os_log_s *)__nwlog_obj();
        os_log_type_t domain = error.domain;
        if (!os_log_type_enabled(v38, error.domain)) {
          goto LABEL_75;
        }
        *(_DWORD *)int buf = 136446210;
        int v59 = "nw_http_authentication_apply_authorization";
        uint64_t v40 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_74;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t domain = error.domain;
      BOOL v42 = os_log_type_enabled(v38, error.domain);
      if (!backtrace_string)
      {
        if (!v42) {
          goto LABEL_75;
        }
        *(_DWORD *)int buf = 136446210;
        int v59 = "nw_http_authentication_apply_authorization";
        uint64_t v40 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_74;
      }

      if (v42)
      {
        *(_DWORD *)int buf = 136446466;
        int v59 = "nw_http_authentication_apply_authorization";
        __int16 v60 = 2082;
        CFIndex v61 = (CFIndex)backtrace_string;
        char v43 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_64:
        _os_log_impl(&dword_181A5C000, v38, domain, v43, buf, 0x16u);
      }

uint64_t __Block_byref_object_copy__49(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__50(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(const void **)(a1 + 40);
    if (v2) {
      CFRelease(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL43nw_http_authentication_ask_appsso_for_credsP11nw_protocolPK10__CFStringbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke( uint64_t a1, CFTypeRef cf, void *a3)
{
  v20[0] = 0LL;
  v20[1] = v20;
  v20[2] = 0x3802000000LL;
  v20[3] = __Block_byref_object_copy__76;
  v20[4] = __Block_byref_object_dispose__77;
  if (cf)
  {
    CFTypeRef v5 = CFRetain(cf);
    char v6 = v22 | 1;
  }

  else
  {
    CFTypeRef v5 = 0LL;
    char v6 = -1;
  }

  CFTypeRef v21 = v5;
  char v22 = v6;
  v17[0] = 0LL;
  v17[1] = v17;
  v17[2] = 0x3802000000LL;
  v17[3] = __Block_byref_object_copy__78;
  void v17[4] = __Block_byref_object_dispose__79;
  if (a3)
  {
    uint64_t v7 = os_retain(a3);
    char v8 = v19 | 1;
  }

  else
  {
    uint64_t v7 = 0LL;
    char v8 = -1;
  }

  v11[1] = 0x40000000LL;
  __int128 v9 = *(_OWORD *)(a1 + 32);
  __int128 v15 = *(_OWORD *)(a1 + 48);
  uint64_t object = v7;
  char v19 = v8;
  v11[0] = MEMORY[0x1895F87A8];
  v11[2] = ___ZL43nw_http_authentication_ask_appsso_for_credsP11nw_protocolPK10__CFStringbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_80;
  v11[3] = &unk_189BB7D00;
  uint64_t v13 = v20;
  uint64_t v14 = v17;
  char v10 = *(void **)(v15 + 832);
  char v16 = *(_BYTE *)(a1 + 64);
  __int128 v12 = v9;
  nw_queue_context_async(v10, v11);
  _Block_object_dispose(v17, 8);
  if ((v19 & 1) != 0 && object) {
    os_release(object);
  }
  _Block_object_dispose(v20, 8);
  if ((v22 & 1) != 0)
  {
    if (v21) {
      CFRelease(v21);
    }
  }

uint64_t __Block_byref_object_copy__76(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__77(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(const void **)(a1 + 40);
    if (v2) {
      CFRelease(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t __Block_byref_object_copy__78(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__79(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL43nw_http_authentication_ask_appsso_for_credsP11nw_protocolPK10__CFStringbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_80( uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (nw_protocol_plugin_retry_end_async(*(void *)(a1 + 64) + 344LL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v3 = *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
      uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
      int v23 = 136446978;
      __int16 v24 = "nw_http_authentication_ask_appsso_for_creds_block_invoke";
      __int16 v25 = 2114;
      __int16 v26 = v3;
      __int16 v27 = 2112;
      uint64_t v28 = v4;
      __int16 v29 = 2112;
      uint64_t v30 = v5;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ handling AppSSO headers %@ error %@",  (uint8_t *)&v23,  0x2Au);
    }

    uint64_t v6 = *(void *)(a1 + 64);
    uint64_t v7 = *(unsigned int *)(v6 + 1056) + 1LL;
    uint64_t v8 = v7 << 31 >> 31;
    *(_DWORD *)(v6 + 1056) = v7;
    if (v8 != v7 || v8 < 0)
    {
      if (gLogDatapath)
      {
        CFTypeRef v21 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v22 = *(unsigned int *)(*(void *)(a1 + 64) + 1056LL);
          int v23 = 136446978;
          __int16 v24 = "nw_http_authentication_ask_appsso_for_creds_block_invoke";
          __int16 v25 = 2082;
          __int16 v26 = "http_authentication->appsso_attempt_count";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v22;
          _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  (uint8_t *)&v23,  0x2Au);
        }
      }

      *(_DWORD *)(*(void *)(a1 + 64) + 1056LL) = -1;
    }

    if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL)
      && *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL))
    {
      CFDictionaryApplyFunction( *(CFDictionaryRef *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  (CFDictionaryApplierFunction)nw_http_authentication_apply_appsso_headers,  *(void **)(a1 + 64));
      *(_DWORD *)(*(void *)(a1 + 64) + 1044LL) = 4;
      uint64_t v13 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
LABEL_23:
      v13();
      return;
    }

    int v9 = _CFHTTPAuthenticationAppSSOIsPerformDefaultHandlingError();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v10 = (os_log_s *)gLogObj;
    if (!v9)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
        uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
        uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
        int v23 = 136446978;
        __int16 v24 = "nw_http_authentication_ask_appsso_for_creds_block_invoke";
        __int16 v25 = 2114;
        __int16 v26 = v14;
        __int16 v27 = 2112;
        uint64_t v28 = v15;
        __int16 v29 = 2112;
        uint64_t v30 = v16;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ AppSSO received headers %@ error %@ canceling",  (uint8_t *)&v23,  0x2Au);
      }

      client_metadata_in_parameters = nw_http_messaging_options_find_or_create_client_metadata_in_parameters( *(void **)(*(void *)(a1 + 64) + 816LL),  *(void *)(a1 + 64));
      if (client_metadata_in_parameters)
      {
        uint64_t v18 = client_metadata_in_parameters;
        nw_http_client_metadata_set_client_error(client_metadata_in_parameters, 3);
        (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
        os_release(v18);
        return;
      }

      uint64_t v13 = *(void (**)(void))(*(void *)(a1 + 32) + 16LL);
      goto LABEL_23;
    }

    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      id v11 = *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      int v23 = 136446466;
      __int16 v24 = "nw_http_authentication_ask_appsso_for_creds_block_invoke";
      __int16 v25 = 2114;
      __int16 v26 = v11;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ AppSSO performing default handling",  (uint8_t *)&v23,  0x16u);
    }

    *(_WORD *)(*(void *)(a1 + 64) + 1062LL) |= 0x20u;
    nw_http_authentication_handle_challenge( *(void *)(a1 + 72),  *(_CFHTTPAuthentication **)(*(void *)(a1 + 64) + 848LL),  *(void **)(*(void *)(a1 + 64) + 656LL),  *(_DWORD *)(*(void *)(a1 + 64) + 1044LL),  *(_BYTE *)(a1 + 80),  *(void *)(a1 + 32));
  }

  else
  {
    uint64_t v12 = *(void *)(a1 + 64);
    if ((*(_BYTE *)(v12 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        char v19 = (os_log_s *)__nwlog_obj();
        BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG);
        uint64_t v12 = *(void *)(a1 + 64);
        if (v20)
        {
          int v23 = 136446722;
          __int16 v24 = "nw_http_authentication_ask_appsso_for_creds_block_invoke";
          __int16 v25 = 2082;
          __int16 v26 = (const char *)(v12 + 114);
          __int16 v27 = 2080;
          uint64_t v28 = (uint64_t)" ";
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalling destroy because defer_destroy was true",  (uint8_t *)&v23,  0x20u);
          uint64_t v12 = *(void *)(a1 + 64);
        }
      }
    }

    nw_http_authentication_destroy(v12);
  }

uint64_t nw_http_authentication_ask_pat_for_creds(uint64_t a1, uint64_t a2)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    parameters = (void *)nw_protocol_get_parameters(*(void *)(a1 + 40));
    uint64_t v53 = a2;
    if (parameters)
    {
      uint64_t v6 = os_retain(parameters);
      if (v6)
      {
        uint64_t v7 = v6;
        int v54 = (v6[101] >> 1) & 1;
LABEL_25:

        int is_third_party_web_content = nw_parameters_is_third_party_web_content(v7);
        CFStringRef v17 = CFURLCopyHostName(*(CFURLRef *)(v2 + 880));
        if (((is_third_party_web_content ^ 1 | v54) & 1) == 0
          && !_CFHTTPAuthenticationCheckOriginAllowedAsThirdParty())
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v23 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http_authentication_ask_pat_for_creds";
            _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s Received PAT challenge for disallowed third party",  buf,  0xCu);
          }

          client_metadata_in_parameters = nw_http_messaging_options_find_or_create_client_metadata_in_parameters( *(void **)(v2 + 816),  v2);
          if (!client_metadata_in_parameters)
          {
            unsigned __int8 v26 = 1;
            (*(void (**)(uint64_t, void, uint64_t, void))(v53 + 16))(v53, 0LL, 1LL, 0LL);
            if (!v17) {
              goto LABEL_86;
            }
            goto LABEL_85;
          }

          __int16 v25 = client_metadata_in_parameters;
          nw_http_client_metadata_set_client_error(client_metadata_in_parameters, 2);
          unsigned __int8 v26 = 1;
          (*(void (**)(uint64_t, void, uint64_t, void))(v53 + 16))(v53, 0LL, 1LL, 0LL);
          os_release(v25);
LABEL_84:
          if (!v17) {
            goto LABEL_86;
          }
          goto LABEL_85;
        }

        *(void *)int buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3802000000LL;
        __int16 v60 = __Block_byref_object_copy__49;
        CFIndex v61 = __Block_byref_object_dispose__50;
        CFStringRef v62 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], (const char *)(v2 + 114), 0x8000100u);
        v63 |= 1u;
        _CFHTTPAuthenticationGetPATSchemes();
        CFTypeRef v18 = nw_parameters_copy_main_document_cfurl(v7);
        uint64_t v19 = *(void *)(a1 + 40);
        os_log_type_t v52 = v17;
        BOOL v51 = v18;
        if (v19)
        {
          BOOL v20 = nw_http_authentication_copy_protocol_metadata((nw_protocol *)a1);
          if (v20)
          {
            CFTypeRef v21 = v20;
            *(_DWORD *)(v19 + 1040) = nw_http_connection_metadata_get_version(v20);
            pat_timestamps_array = (void *)nw_http_connection_metadata_find_or_create_pat_timestamps_array(v21);
            os_release(v21);
            goto LABEL_70;
          }

void ___ZL42nw_http_authentication_apply_authorizationP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbbbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke( uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 40)) {
    uint64_t v3 = "Proxy-Authorization";
  }
  else {
    uint64_t v3 = "Authorization";
  }
  nw_http_fields_set_value_by_name(*(void **)(*(void *)(a1 + 32) + 944LL), (uint64_t)v3, a2);
}

void ___ZL40nw_http_authentication_ask_pat_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke( void *a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (nw_protocol_plugin_retry_end_async(a1[7] + 344LL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(*(void *)(a1[5] + 8LL) + 40LL);
      *(_DWORD *)int buf = 136446978;
      CFTypeRef v18 = "nw_http_authentication_ask_pat_for_creds_block_invoke";
      __int16 v19 = 2114;
      uint64_t v20 = v7;
      __int16 v21 = 2112;
      uint64_t v22 = (const char *)a2;
      __int16 v23 = 2112;
      uint64_t v24 = a3;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ received PAT headers %@ error %@",  buf,  0x2Au);
    }

    if (!a2 || a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446210;
        CFTypeRef v18 = "nw_http_authentication_ask_pat_for_creds_block_invoke";
        _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_INFO, "%{public}s PAT default delivering response", buf, 0xCu);
      }

      (*(void (**)(void))(a1[4] + 16LL))();
      *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
    }

    else
    {
      Value = (const __CFString *)CFDictionaryGetValue(a2, @"Authorization");
      if (Value)
      {
        v16[0] = MEMORY[0x1895F87A8];
        v16[1] = 0x40000000LL;
        v16[2] = ___ZL40nw_http_authentication_ask_pat_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_61;
        v16[3] = &__block_descriptor_tmp_62;
        v16[4] = a1[7];
        nw_utilities_get_c_string_from_cfstring(Value, 0x201u, v16);
        *(_DWORD *)(a1[7] + 1044LL) = 8;
        (*(void (**)(void))(a1[4] + 16LL))();
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446210;
          CFTypeRef v18 = "nw_http_authentication_ask_pat_for_creds_block_invoke_2";
          _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, "%{public}s Unable to find authorization", buf, 0xCu);
        }

        client_metadata_in_parameters = nw_http_messaging_options_find_or_create_client_metadata_in_parameters( *(void **)(a1[7] + 816LL),  a1[7]);
        os_log_type_t v13 = client_metadata_in_parameters;
        if (client_metadata_in_parameters) {
          nw_http_client_metadata_set_client_error(client_metadata_in_parameters, 1);
        }
        (*(void (**)(void))(a1[4] + 16LL))();
        *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
        if (v13) {
          os_release(v13);
        }
      }
    }
  }

  else
  {
    uint64_t v9 = a1[7];
    if ((*(_BYTE *)(v9 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        BOOL v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
        uint64_t v9 = a1[7];
        if (v15)
        {
          *(_DWORD *)int buf = 136446722;
          CFTypeRef v18 = "nw_http_authentication_ask_pat_for_creds_block_invoke";
          __int16 v19 = 2082;
          uint64_t v20 = v9 + 114;
          __int16 v21 = 2080;
          uint64_t v22 = " ";
          _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalling destroy because defer_destroy was true",  buf,  0x20u);
          uint64_t v9 = a1[7];
        }
      }
    }

    nw_http_authentication_destroy(v9);
  }

void ___ZL40nw_http_authentication_ask_pat_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_61( uint64_t a1, uint64_t a2)
{
}

void ___ZL39nw_http_authentication_handle_challengeP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_30( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ((*(_WORD *)(v3 + 1062) & 0x10) != 0) {
    uint64_t v4 = "Proxy-Authorization";
  }
  else {
    uint64_t v4 = "Authorization";
  }
  nw_http_fields_set_value_by_name(*(void **)(v3 + 944), (uint64_t)v4, a2);
}

void ___ZL39nw_http_authentication_handle_challengeP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2( uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (nw_protocol_plugin_retry_end_async(*(void *)(a1 + 40) + 344LL))
  {
    (*(void (**)(void, void, void, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(void *)(*(void *)(a1 + 40) + 960LL),  *(_WORD *)(*(void *)(a1 + 40) + 1062LL) & 1,  1LL);
  }

  else
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if ((*(_BYTE *)(v2 + 198) & 1) == 0 && gLogDatapath)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
      uint64_t v2 = *(void *)(a1 + 40);
      if (v4)
      {
        int v5 = 136446722;
        uint64_t v6 = "nw_http_authentication_handle_challenge_block_invoke_2";
        __int16 v7 = 2082;
        uint64_t v8 = v2 + 114;
        __int16 v9 = 2080;
        char v10 = " ";
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalling destroy because defer_destroy was true",  (uint8_t *)&v5,  0x20u);
        uint64_t v2 = *(void *)(a1 + 40);
      }
    }

    nw_http_authentication_destroy(v2);
  }

uint64_t nw::retained_ptr<nw_endpoint *>::operator=(uint64_t a1, void *a2)
{
  char v4 = *(_BYTE *)(a1 + 8);
  if ((v4 & 1) != 0)
  {
    int v5 = *(void **)a1;
    if (*(void *)a1)
    {
      os_release(v5);
      char v4 = *(_BYTE *)(a1 + 8);
    }
  }

  *(void *)a1 = 0LL;
  *(void *)a1 = *a2;
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = v4 | 1;
  *a2 = 0LL;
  return a1;
}

uint64_t nw_http_authentication_ask_authbroker_for_creds(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v20 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446722;
          uint64_t v30 = "nw_http_authentication_ask_authbroker_for_creds";
          __int16 v31 = 2082;
          os_log_type_t v32 = (char *)(v1 + 114);
          __int16 v33 = 2080;
          os_log_type_t v34 = " ";
          _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }

    uint64_t v2 = (void *)nw_authentication_challenge_copy_protection_space(*(void **)(v1 + 640));
    CFStringRef v3 = CFURLCopyHostName(*(CFURLRef *)(v1 + 896));
    *(_DWORD *)(v1 + 104_Block_object_dispose(va, 8) = nw_authentication_protection_space_get_type(v2);
    char v4 = v2;
    int v5 = v4;
    if (v4)
    {
      uint64_t v6 = v4[2];
LABEL_6:

      __int16 v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFStringRef v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v6, 0x201u);
      CFURLGetPortNumber(*(CFURLRef *)(v1 + 896));
      __int16 v9 = (void *)CFURLProtectionSpaceCreate();
      CFStringRef v10 = CFStringCreateWithCString(v7, (const char *)(v1 + 114), 0x8000100u);
      nw_protocol_plugin_retry_begin_async(v1 + 344);
      _CFHTTPAuthenticationFetchProxyCredentialFromAuthBroker();
      if (v10) {
        CFRelease(v10);
      }
      if (v9) {
        os_release(v9);
      }
      if (v8) {
        CFRelease(v8);
      }
      if (v3) {
        CFRelease(v3);
      }
      if (v5) {
        os_release(v5);
      }
      return 2LL;
    }

    __nwlog_obj();
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_authentication_protection_space_get_realm";
    CFStringRef v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v17, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v30 = "nw_authentication_protection_space_get_realm";
          _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null protection_space", buf, 0xCu);
        }
      }

      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v30 = "nw_authentication_protection_space_get_realm";
            __int16 v31 = 2082;
            os_log_type_t v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v18,  v24,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_52;
        }

        if (v25)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v30 = "nw_authentication_protection_space_get_realm";
          _os_log_impl( &dword_181A5C000,  v18,  v24,  "%{public}s called with null protection_space, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v30 = "nw_authentication_protection_space_get_realm";
          _os_log_impl( &dword_181A5C000,  v18,  v26,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void ___ZL45nw_http_authentication_ask_accounts_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke( uint64_t a1, CFTypeRef cf, const void *a3)
{
  v14[0] = 0LL;
  v14[1] = v14;
  v14[2] = 0x3802000000LL;
  v14[3] = __Block_byref_object_copy__47;
  v14[4] = __Block_byref_object_dispose__48;
  if (cf)
  {
    CFTypeRef v5 = CFRetain(cf);
    char v6 = v16 | 1;
  }

  else
  {
    CFTypeRef v5 = 0LL;
    char v6 = -1;
  }

  CFTypeRef v15 = v5;
  char v16 = v6;
  v11[0] = 0LL;
  v11[1] = v11;
  v11[2] = 0x3802000000LL;
  v11[3] = __Block_byref_object_copy__49;
  void v11[4] = __Block_byref_object_dispose__50;
  if (a3)
  {
    CFTypeRef v7 = CFRetain(a3);
    char v8 = v13 | 1;
  }

  else
  {
    CFTypeRef v7 = 0LL;
    char v8 = -1;
  }

  CFTypeRef cfa = v7;
  char v13 = v8;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  v9[2] = ___ZL45nw_http_authentication_ask_accounts_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_51;
  v9[3] = &unk_189BB7BD0;
  v9[5] = v14;
  v9[6] = v11;
  v9[4] = *(void *)(a1 + 32);
  __int128 v10 = *(_OWORD *)(a1 + 40);
  nw_queue_context_async(*(void **)(v10 + 832), v9);
  _Block_object_dispose(v11, 8);
  if ((v13 & 1) != 0 && cfa) {
    CFRelease(cfa);
  }
  _Block_object_dispose(v14, 8);
  if ((v16 & 1) != 0)
  {
    if (v15) {
      CFRelease(v15);
    }
  }

void ___ZL39nw_http_authentication_handle_challengeP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_34( uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (nw_protocol_plugin_retry_end_async(*(void *)(a1 + 40) + 344LL))
  {
    (*(void (**)(void, void, void, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(void *)(*(void *)(a1 + 40) + 960LL),  0LL,  1LL);
  }

  else
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if ((*(_BYTE *)(v2 + 198) & 1) == 0 && gLogDatapath)
    {
      CFStringRef v3 = (os_log_s *)__nwlog_obj();
      BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
      uint64_t v2 = *(void *)(a1 + 40);
      if (v4)
      {
        int v5 = 136446722;
        char v6 = "nw_http_authentication_handle_challenge_block_invoke";
        __int16 v7 = 2082;
        uint64_t v8 = v2 + 114;
        __int16 v9 = 2080;
        __int128 v10 = " ";
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalling destroy because defer_destroy was true",  (uint8_t *)&v5,  0x20u);
        uint64_t v2 = *(void *)(a1 + 40);
      }
    }

    nw_http_authentication_destroy(v2);
  }

uint64_t nw_http_authentication_send_challenge(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = (os_log_s *)gLogObj;
    if (v4)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_http_authentication_send_challenge";
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s http authentication calling out to challenge handler",  buf,  0xCu);
      }

      nw_authentication_challenge_set_attempt_count(*(void **)(v4 + 640), *(_DWORD *)(v4 + 1052));
      ++*(_DWORD *)(v4 + 1052);
      nw_protocol_plugin_retry_begin_async(v4 + 344);
      char v6 = *(dispatch_queue_s **)(v4 + 768);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke;
      block[3] = &unk_189BB7CB8;
      block[5] = v4;
      block[6] = a1;
      block[4] = a2;
      dispatch_async(v6, block);
      return 2LL;
    }

    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "nw_http_authentication_send_challenge";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v18 = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __int16 v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v18;
      if (os_log_type_enabled(v9, v18))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_http_authentication_send_challenge";
        uint64_t v11 = "%{public}s called with null http_authentication";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v17)
    {
      __int16 v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v18;
      if (os_log_type_enabled(v9, v18))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_http_authentication_send_challenge";
        uint64_t v11 = "%{public}s called with null http_authentication, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v18;
    BOOL v15 = os_log_type_enabled(v9, v18);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_http_authentication_send_challenge";
        uint64_t v11 = "%{public}s called with null http_authentication, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v15)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v20 = "nw_http_authentication_send_challenge";
      __int16 v21 = 2082;
      BOOL v22 = backtrace_string;
      os_log_type_t v14 = "%{public}s called with null http_authentication, dumping backtrace:%{public}s";
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v20 = "nw_http_authentication_send_challenge";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (v18 != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      __int16 v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v18;
      if (os_log_type_enabled(v9, v18))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_http_authentication_send_challenge";
        uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v18;
    BOOL v13 = os_log_type_enabled(v9, v18);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_http_authentication_send_challenge";
        uint64_t v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v13)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v20 = "nw_http_authentication_send_challenge";
      __int16 v21 = 2082;
      BOOL v22 = backtrace_string;
      os_log_type_t v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_23:
      _os_log_impl(&dword_181A5C000, v9, v10, v14, buf, 0x16u);
    }

uint64_t ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke( uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1895F87A8];
  uint64_t v3 = 0x40000000LL;
  uint64_t v4 = ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2;
  int v5 = &unk_189BB7C90;
  __int128 v7 = *(_OWORD *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  return (*(uint64_t (**)(void))(*(void *)(v7 + 752) + 16LL))();
}

void ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2( uint64_t a1, void *a2, char a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_http_authentication_send_challenge_block_invoke_2";
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s http authentication returned from challenge handler",  (uint8_t *)&buf,  0xCu);
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v14 = 0x3802000000LL;
  BOOL v15 = __Block_byref_object_copy__66;
  char v16 = __Block_byref_object_dispose__67;
  if (a2)
  {
    __int128 v7 = os_retain(a2);
    char v8 = v18 | 1;
  }

  else
  {
    __int128 v7 = 0LL;
    char v8 = -1;
  }

  uint64_t object = v7;
  char v18 = v8;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  v10[2] = ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_68;
  v10[3] = &unk_189BB7C68;
  char v12 = a3;
  __int128 v11 = *(_OWORD *)(a1 + 40);
  __int16 v9 = *(void **)(v11 + 832);
  v10[4] = *(void *)(a1 + 32);
  v10[5] = &buf;
  nw_queue_context_async_if_needed(v9, v10);
  _Block_object_dispose(&buf, 8);
  if ((v18 & 1) != 0)
  {
    if (object) {
      os_release(object);
    }
  }

uint64_t __Block_byref_object_copy__66(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__67(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL37nw_http_authentication_send_challengeP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_68( uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
  {
    int v28 = 136446210;
    os_log_type_t v29 = "nw_http_authentication_send_challenge_block_invoke";
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s http authentication returned from challenge handler async",  (uint8_t *)&v28,  0xCu);
  }

  if (nw_protocol_plugin_retry_end_async(*(void *)(a1 + 48) + 344LL))
  {
    *(_WORD *)(*(void *)(a1 + 48) + 1062LL) = *(_WORD *)(*(void *)(a1 + 48) + 1062LL) & 0xFFFE | *(unsigned __int8 *)(a1 + 64);
    int type = nw_authentication_challenge_get_type(*(void **)(*(void *)(a1 + 48) + 640LL));
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    if (v5)
    {
      if (*(void *)(v4 + 640))
      {
        uint64_t v6 = v5;
        BOOL v7 = v6[2] == 0LL;

        uint64_t v4 = *(void *)(a1 + 48);
        if (!v7)
        {
          char v8 = *(void **)(v4 + 688);
          if (v8)
          {
            nw_authentication_credential_storage_set_default_credential( v8,  *(void **)(v4 + 640),  *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
            uint64_t v4 = *(void *)(a1 + 48);
          }
        }
      }
    }

    __int16 v9 = *(_WORD *)(v4 + 1062);
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v11 = *(void *)(v10 + 40);
    *(void *)(v10 + 40) = 0LL;
    uint64_t v12 = *(void *)(a1 + 48);
    if ((v9 & 0x10) != 0)
    {
      char v23 = *(_BYTE *)(v12 + 680);
      if ((v23 & 1) != 0)
      {
        os_log_type_t v24 = *(void **)(v12 + 672);
        if (v24)
        {
          os_release(v24);
          char v23 = *(_BYTE *)(v12 + 680);
        }
      }

      *(void *)(v12 + 672) = v11;
      *(_BYTE *)(v12 + 680) = v23 | 1;
      uint64_t v25 = *(void *)(a1 + 48);
      *(_DWORD *)(v25 + 104_Block_object_dispose(va, 8) = type;
      uint64_t v16 = *(void *)(a1 + 56);
      char v17 = *(_CFHTTPAuthentication **)(v25 + 864);
      char v18 = *(void **)(v25 + 672);
      uint64_t v19 = *(void *)(a1 + 32);
      int v20 = type;
      int v21 = 1;
    }

    else
    {
      char v13 = *(_BYTE *)(v12 + 664);
      if ((v13 & 1) != 0)
      {
        uint64_t v14 = *(void **)(v12 + 656);
        if (v14)
        {
          os_release(v14);
          char v13 = *(_BYTE *)(v12 + 664);
        }
      }

      *(void *)(v12 + 656) = v11;
      *(_BYTE *)(v12 + 664) = v13 | 1;
      uint64_t v15 = *(void *)(a1 + 48);
      *(_DWORD *)(v15 + 1044) = type;
      uint64_t v16 = *(void *)(a1 + 56);
      char v17 = *(_CFHTTPAuthentication **)(v15 + 848);
      char v18 = *(void **)(v15 + 656);
      uint64_t v19 = *(void *)(a1 + 32);
      int v20 = type;
      int v21 = 0;
    }

    nw_http_authentication_apply_authorization(v16, v17, v18, v20, 1, v21, 1, v19);
    *(_WORD *)(*(void *)(a1 + 48) + 1062LL) &= ~0x200u;
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    uint64_t v22 = *(void *)(a1 + 48);
    if ((*(_BYTE *)(v22 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t v26 = (os_log_s *)__nwlog_obj();
        BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG);
        uint64_t v22 = *(void *)(a1 + 48);
        if (v27)
        {
          int v28 = 136446722;
          os_log_type_t v29 = "nw_http_authentication_send_challenge_block_invoke";
          __int16 v30 = 2082;
          uint64_t v31 = v22 + 114;
          __int16 v32 = 2080;
          __int16 v33 = " ";
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalling destroy because defer_destroy was true",  (uint8_t *)&v28,  0x20u);
          uint64_t v22 = *(void *)(a1 + 48);
        }
      }
    }

    nw_http_authentication_destroy(v22);
  }

uint64_t __Block_byref_object_copy__47(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__48(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(const void **)(a1 + 40);
    if (v2) {
      CFRelease(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL45nw_http_authentication_ask_accounts_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_51( uint64_t *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (nw_protocol_plugin_retry_end_async(a1[7] + 344))
  {
    uint64_t v2 = *(void *)(a1[5] + 8);
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3 && *(void *)(*(void *)(a1[6] + 8) + 40LL))
    {
      *(void *)(v2 + 40) = 0LL;
      uint64_t v4 = a1[7];
      char v5 = *(_BYTE *)(v4 + 984);
      if ((v5 & 1) != 0)
      {
        uint64_t v6 = *(const void **)(v4 + 976);
        if (v6)
        {
          CFRelease(v6);
          char v5 = *(_BYTE *)(v4 + 984);
        }
      }

      *(void *)(v4 + 976) = v3;
      *(_BYTE *)(v4 + 984) = v5 | 1;
      uint64_t v7 = a1[7];
      char v8 = *(const __CFString **)(*(void *)(a1[6] + 8) + 40LL);
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 0x40000000LL;
      v15[2] = ___ZL45nw_http_authentication_ask_accounts_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_52;
      v15[3] = &__block_descriptor_tmp_53;
      void v15[4] = v7;
      nw_utilities_get_c_string_from_cfstring(v8, 0x201u, v15);
      uint64_t v9 = a1[7];
      *(_DWORD *)(v9 + 1044) = 4;
      (*(void (**)(uint64_t, void, void, void))(a1[4] + 16))(a1[4], *(void *)(v9 + 960), 0LL, 0LL);
    }

    else if (nw_authentication_challenge_try_next_protection_space(*(void **)(a1[7] + 640)))
    {
      nw_http_authentication_send_challenge(a1[8], a1[4]);
    }

    else
    {
      if ((*(_BYTE *)(a1[7] + 198) & 1) == 0)
      {
        if (gLogDatapath)
        {
          char v13 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v14 = a1[7] + 114;
            *(_DWORD *)__int128 buf = 136446722;
            char v17 = "nw_http_authentication_ask_accounts_for_creds_block_invoke_2";
            __int16 v18 = 2082;
            uint64_t v19 = v14;
            __int16 v20 = 2080;
            int v21 = " ";
            _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAccounts failed to return a credential, ran out of schemes to try",  buf,  0x20u);
          }
        }
      }

      (*(void (**)(void))(a1[4] + 16))();
    }
  }

  else
  {
    uint64_t v10 = a1[7];
    if ((*(_BYTE *)(v10 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v11 = (os_log_s *)__nwlog_obj();
        BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
        uint64_t v10 = a1[7];
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446722;
          char v17 = "nw_http_authentication_ask_accounts_for_creds_block_invoke";
          __int16 v18 = 2082;
          uint64_t v19 = v10 + 114;
          __int16 v20 = 2080;
          int v21 = " ";
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalling destroy because defer_destroy was true",  buf,  0x20u);
          uint64_t v10 = a1[7];
        }
      }
    }

    nw_http_authentication_destroy(v10);
  }

void ___ZL45nw_http_authentication_ask_accounts_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_52( uint64_t a1, uint64_t a2)
{
}

void ___ZL47nw_http_authentication_ask_authbroker_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke( void *a1, uint64_t a2)
{
  v6[0] = MEMORY[0x1895F87A8];
  v6[2] = ___ZL47nw_http_authentication_ask_authbroker_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2;
  v6[3] = &unk_189BB7B60;
  uint64_t v3 = a1[4];
  uint64_t v2 = a1[5];
  uint64_t v4 = *(void **)(v2 + 832);
  v6[1] = 0x40000000LL;
  uint64_t v5 = a1[6];
  v6[6] = a2;
  v6[7] = v5;
  v6[4] = v3;
  v6[5] = v2;
  nw_queue_context_async_if_needed(v4, v6);
}

void ___ZL47nw_http_authentication_ask_authbroker_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2( uint64_t *a1)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!nw_protocol_plugin_retry_end_async(a1[5] + 344))
  {
    uint64_t v7 = a1[5];
    if ((*(_BYTE *)(v7 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        __int16 v18 = (os_log_s *)__nwlog_obj();
        BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
        uint64_t v7 = a1[5];
        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446722;
          os_log_type_t v29 = "nw_http_authentication_ask_authbroker_for_creds_block_invoke_2";
          __int16 v30 = 2082;
          uint64_t v31 = (const char *)(v7 + 114);
          __int16 v32 = 2080;
          uint64_t v33 = (uint64_t)" ";
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalling destroy because defer_destroy was true",  buf,  0x20u);
          uint64_t v7 = a1[5];
        }
      }
    }

    nw_http_authentication_destroy(v7);
    return;
  }

  uint64_t v2 = a1[5];
  if (!a1[6])
  {
    if (!(*(_BYTE *)(v2 + 198) & 1 | (gLogDatapath == 0)))
    {
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
      uint64_t v2 = a1[5];
      if (v23)
      {
        *(_DWORD *)__int128 buf = 136446722;
        os_log_type_t v29 = "nw_http_authentication_ask_authbroker_for_creds_block_invoke_3";
        __int16 v30 = 2082;
        uint64_t v31 = (const char *)(v2 + 114);
        __int16 v32 = 2080;
        uint64_t v33 = (uint64_t)" ";
        _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sauthbroker didn't return a cred, sending challenge",  buf,  0x20u);
        uint64_t v2 = a1[5];
      }
    }

    *(_WORD *)(v2 + 1062) |= 0x80u;
    nw_http_authentication_send_challenge(a1[7], a1[4]);
    return;
  }

  if (!(*(_BYTE *)(v2 + 198) & 1 | (gLogDatapath == 0)))
  {
    __int16 v20 = (os_log_s *)__nwlog_obj();
    BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
    uint64_t v2 = a1[5];
    if (v21)
    {
      *(_DWORD *)__int128 buf = 136446722;
      os_log_type_t v29 = "nw_http_authentication_ask_authbroker_for_creds_block_invoke";
      __int16 v30 = 2082;
      uint64_t v31 = (const char *)(v2 + 114);
      __int16 v32 = 2080;
      uint64_t v33 = (uint64_t)" ";
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sapplying credential authbroker provided",  buf,  0x20u);
      uint64_t v2 = a1[5];
    }
  }

  uint64_t v3 = *(unsigned int *)(v2 + 1052) + 1LL;
  uint64_t v4 = v3 << 31 >> 31;
  *(_DWORD *)(v2 + 1052) = v3;
  if (v4 != v3 || v4 < 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v25 = *(unsigned int *)(a1[5] + 1052);
        *(_DWORD *)__int128 buf = 136446978;
        os_log_type_t v29 = "nw_http_authentication_ask_authbroker_for_creds_block_invoke";
        __int16 v30 = 2082;
        uint64_t v31 = "http_authentication->auth_challenge_count";
        __int16 v32 = 2048;
        uint64_t v33 = 1LL;
        __int16 v34 = 2048;
        uint64_t v35 = v25;
        _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
      }
    }

    *(_DWORD *)(a1[5] + 1052) = -1;
    uint64_t v5 = (const void *)a1[6];
    if (v5) {
      goto LABEL_7;
    }
  }

  else
  {
    uint64_t v5 = (const void *)a1[6];
    if (v5)
    {
LABEL_7:
      CFTypeRef v6 = CFRetain(v5);
      goto LABEL_16;
    }
  }

  CFTypeRef v6 = 0LL;
LABEL_16:
  uint64_t v8 = a1[5];
  char v9 = *(_BYTE *)(v8 + 1000);
  if ((v9 & 1) != 0)
  {
    uint64_t v10 = *(const void **)(v8 + 992);
    if (v10)
    {
      CFRelease(v10);
      char v9 = *(_BYTE *)(v8 + 1000);
    }
  }

  *(void *)(v8 + 992) = v6;
  *(_BYTE *)(v8 + 1000) = v9 | 1;
  uint64_t v11 = -[NWConcrete_nw_authentication_credential initWithType:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_authentication_credential),  1);
  uint64_t v12 = a1[5];
  char v13 = *(_BYTE *)(v12 + 680);
  if ((v13 & 1) != 0)
  {
    uint64_t v14 = *(void **)(v12 + 672);
    if (v14)
    {
      os_release(v14);
      char v13 = *(_BYTE *)(v12 + 680);
    }
  }

  *(void *)(v12 + 672) = v11;
  *(_BYTE *)(v12 + 680) = v13 | 1;
  Username = (const __CFString *)CFURLCredentialGetUsername();
  uint64_t v16 = MEMORY[0x1895F87A8];
  v27[0] = MEMORY[0x1895F87A8];
  v27[1] = 0x40000000LL;
  v27[2] = ___ZL47nw_http_authentication_ask_authbroker_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_39;
  v27[3] = &__block_descriptor_tmp_40_14075;
  v27[4] = a1[5];
  nw_utilities_get_c_string_from_cfstring(Username, 0x201u, v27);
  char v17 = (const __CFString *)CFURLCredentialCopyPassword();
  v26[0] = v16;
  v26[1] = 0x40000000LL;
  v26[2] = ___ZL47nw_http_authentication_ask_authbroker_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2_41;
  v26[3] = &__block_descriptor_tmp_42_14076;
  void v26[4] = a1[5];
  nw_utilities_get_c_string_from_cfstring(v17, 0x201u, v26);
  nw_authentication_credential_set_persistence(*(void **)(a1[5] + 672), 1);
  if (nw_http_authentication_apply_authorization( a1[7],  *(_CFHTTPAuthentication **)(a1[5] + 864),  *(void **)(a1[5] + 672),  *(_DWORD *)(a1[5] + 1048),  1,  1,  0,  a1[4]))
  {
    (*(void (**)(uint64_t, void, void, BOOL))(a1[4] + 16))( a1[4],  *(void *)(a1[5] + 960),  0LL,  (*(_DWORD *)(a1[5] + 1048) & 0xFFFFFFFE) == 4);
    if (!v17) {
      return;
    }
  }

  else
  {
    (*(void (**)(void))(a1[4] + 16))();
    if (!v17) {
      return;
    }
  }

  CFRelease(v17);
}

void ___ZL47nw_http_authentication_ask_authbroker_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_39( uint64_t a1, const char *a2)
{
}

void ___ZL47nw_http_authentication_ask_authbroker_for_credsP11nw_protocolU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2_41( uint64_t a1, const char *a2)
{
}

BOOL ___ZL39nw_http_authentication_handle_challengeP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke( uint64_t a1, void *a2)
{
  http_authentication = (_CFHTTPAuthentication *)nw_authentication_credential_cache_entry_get_http_authentication(a2);
  int IsValid = CFHTTPAuthenticationIsValid(http_authentication, 0LL);
  if (http_authentication) {
    os_release(http_authentication);
  }
  return IsValid == 0;
}

uint64_t __Block_byref_object_copy__14084(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__14085(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

BOOL ___ZL45nw_http_authentication_copy_protocol_metadataP11nw_protocol_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3;
  BOOL is_http_connection = nw_protocol_metadata_is_http_connection(a3);
  if (is_http_connection)
  {
    if (v3) {
      uint64_t v3 = os_retain(v3);
    }
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    char v7 = *(_BYTE *)(v6 + 48);
    if ((v7 & 1) != 0)
    {
      uint64_t v8 = *(void **)(v6 + 40);
      if (v8)
      {
        os_release(v8);
        char v7 = *(_BYTE *)(v6 + 48);
      }
    }

    *(void *)(v6 + 40) = v3;
    *(_BYTE *)(v6 + 4_Block_object_dispose(va, 8) = v7 | 1;
  }

  return !is_http_connection;
}

void ___ZL45nw_protocol_http_authentication_get_callbacksv_block_invoke()
{
  qword_18C593330 = (uint64_t)nw_protocol_common_get_input_frames;
  unk_18C593338 = nw_protocol_common_get_output_frames;
  qword_18C593350 = (uint64_t)nw_protocol_common_get_parameters;
  unk_18C593358 = nw_protocol_common_get_path;
  qword_18C593360 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_18C593368 = nw_protocol_common_get_remote_endpoint;
  qword_18C5932F0 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_18C5932F8 = nw_protocol_common_connect;
  qword_18C593300 = (uint64_t)nw_protocol_common_disconnect;
  unk_18C593308 = nw_protocol_common_connected;
  qword_18C593320 = (uint64_t)nw_protocol_common_input_available;
  unk_18C593328 = nw_protocol_common_output_available;
  qword_18C5933A0 = (uint64_t)nw_protocol_common_output_finished;
  unk_18C5933A8 = nw_protocol_common_get_output_local_endpoint;
  qword_18C5933E8 = (uint64_t)nw_protocol_common_input_flush;
  qword_18C593310 = (uint64_t)nw_protocol_common_disconnected;
  unk_18C593318 = nw_protocol_common_error;
  qword_18C5933D8 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_18C5933E0 = nw_protocol_common_reset;
  qword_18C5933C0 = (uint64_t)nw_protocol_common_copy_info;
  qword_18C593390 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_18C593398 = nw_protocol_common_input_finished;
  qword_18C5933B0 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_18C5933B8 = nw_protocol_common_waiting_for_output;
  qword_18C593370 = (uint64_t)nw_protocol_common_register_notification;
  unk_18C593378 = nw_protocol_common_unregister_notification;
  qword_18C593380 = (uint64_t)nw_protocol_common_notify;
  unk_18C593388 = nw_protocol_common_updated_path;
  qword_18C593340 = (uint64_t)nw_protocol_common_finalize_output_frames;
  unk_18C593348 = nw_protocol_common_link_state;
  nw_protocol_http_authentication_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  *(void *)algn_18C5932E8 = nw_protocol_http_authentication_remove_input_handler;
}

uint64_t nw_protocol_http_authentication_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 0x40000000LL;
      v15[2] = ___ZL52nw_protocol_http_authentication_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v15[3] = &__block_descriptor_tmp_109;
      void v15[4] = handle;
      v13[0] = MEMORY[0x1895F87A8];
      v13[1] = 0x40000000LL;
      v13[2] = ___ZL52nw_protocol_http_authentication_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
      v13[3] = &__block_descriptor_tmp_110;
      char v14 = a3;
      v13[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v15, (uint64_t)v13);
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
        uint64_t v8 = "%{public}s called with null http_authentication";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v16)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
        uint64_t v8 = "%{public}s called with null http_authentication, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = v17;
    BOOL v12 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
        uint64_t v8 = "%{public}s called with null http_authentication, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v12)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
      __int16 v20 = 2082;
      BOOL v21 = backtrace_string;
      uint64_t v11 = "%{public}s called with null http_authentication, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (v17 != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
        uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = v17;
    BOOL v10 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
        uint64_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v19 = "nw_protocol_http_authentication_remove_input_handler";
      __int16 v20 = 2082;
      BOOL v21 = backtrace_string;
      uint64_t v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v6, v7, v11, buf, 0x16u);
    }

void ___ZL52nw_protocol_http_authentication_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (gLogDatapath)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v9 = 136446210;
      BOOL v10 = "nw_protocol_plugin_metadata_teardown";
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v9, 0xCu);
    }
  }

  nw_protocol_plugin_metadata_reset((uint64_t *)(v2 + 200));
  *(void *)(v2 + 32_Block_object_dispose(va, 8) = 0LL;
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = *(_BYTE *)(v3 + 464);
  if ((v4 & 1) != 0)
  {
    uint64_t v5 = *(const void **)(v3 + 456);
    if (v5)
    {
      _Block_release(v5);
      char v4 = *(_BYTE *)(v3 + 464);
    }
  }

  *(void *)(v3 + 456) = 0LL;
  *(_BYTE *)(v3 + 464) = v4 | 1;
  char v6 = *(_BYTE *)(v3 + 512);
  if ((v6 & 1) != 0)
  {
    os_log_type_t v7 = *(const void **)(v3 + 504);
    if (v7)
    {
      _Block_release(v7);
      char v6 = *(_BYTE *)(v3 + 512);
    }
  }

  *(void *)(v3 + 504) = 0LL;
  *(_BYTE *)(v3 + 512) = v6 | 1;
}

void ___ZL52nw_protocol_http_authentication_remove_input_handlerP11nw_protocolS0_b_block_invoke_2( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40)) {
    nw_http_authentication_destroy(*(void *)(a1 + 32));
  }
}

double __nw_protocol_http_authentication_identifier_block_invoke()
{
  *(void *)&double result = 0x100000005LL;
  qword_18C5928CC = 0x100000005LL;
  return result;
}

void sub_181EABC8C(_Unwind_Exception *a1)
{
}

void sub_181EAC998(_Unwind_Exception *a1)
{
}

void sub_181EACAA4(_Unwind_Exception *a1)
{
}

void sub_181EACAF8(_Unwind_Exception *a1)
{
}

void sub_181EACB50(_Unwind_Exception *a1)
{
}

void sub_181EACBBC(_Unwind_Exception *a1)
{
}

void sub_181EAD420(_Unwind_Exception *a1)
{
}

void sub_181EAD5A4(_Unwind_Exception *a1)
{
}

void sub_181EAD728(_Unwind_Exception *a1)
{
}

void sub_181EAD8C0(_Unwind_Exception *a1)
{
}

void sub_181EADA34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181EADB58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181EADBFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_bonjour_service(const char *name, const char *type, const char *domain)
{
  uint64_t v112 = *MEMORY[0x1895F89C0];
  if (!name)
  {
    __nwlog_obj();
    CFIndex v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v107 = "nw_endpoint_create_bonjour_service";
    int v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_181A5C000, v10, v62, "%{public}s called with null name", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (!LOBYTE(v95.receiver))
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v68 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl( &dword_181A5C000,  v10,  v68,  "%{public}s called with null name, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_92;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v64 = typea[0];
    BOOL v65 = os_log_type_enabled(v10, typea[0]);
    if (!backtrace_string)
    {
      if (v65)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_181A5C000, v10, v64, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (v65)
    {
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v107 = "nw_endpoint_create_bonjour_service";
      __int16 v108 = 2082;
      os_log_type_t v109 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v64,  "%{public}s called with null name, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181EAF800(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_construct_composite_bonjour_name( char *fullName, unint64_t a2, char *service, char *regtype, char *domain, uint64_t a6)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (!fullName)
  {
    __nwlog_obj();
    id v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        __nwlog_obj();
        size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
          os_log_type_t v20 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_95;
        }

        goto LABEL_96;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v26 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
          os_log_type_t v20 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_95;
        }

        goto LABEL_96;
      }

      if (!v26) {
        goto LABEL_74;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
      __int16 v36 = 2082;
      int v37 = backtrace_string;
      BOOL v27 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
      goto LABEL_73;
    }

    __nwlog_obj();
    size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_96;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v20 = "%{public}s called with null buffer";
LABEL_95:
    _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
    goto LABEL_96;
  }

  unint64_t v6 = a2;
  if (!a2)
  {
    __nwlog_obj();
    BOOL v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        __nwlog_obj();
        size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
          os_log_type_t v20 = "%{public}s called with null buffer_len, backtrace limit exceeded";
          goto LABEL_95;
        }

        goto LABEL_96;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v28 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
          os_log_type_t v20 = "%{public}s called with null buffer_len, no backtrace";
          goto LABEL_95;
        }

        goto LABEL_96;
      }

      if (!v28) {
        goto LABEL_74;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
      __int16 v36 = 2082;
      int v37 = backtrace_string;
      BOOL v27 = "%{public}s called with null buffer_len, dumping backtrace:%{public}s";
      goto LABEL_73;
    }

    __nwlog_obj();
    size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_96;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v20 = "%{public}s called with null buffer_len";
    goto LABEL_95;
  }

  if (!service)
  {
    __nwlog_obj();
    id v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        __nwlog_obj();
        size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
          os_log_type_t v20 = "%{public}s called with null name, backtrace limit exceeded";
          goto LABEL_95;
        }

        goto LABEL_96;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v29 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
          os_log_type_t v20 = "%{public}s called with null name, no backtrace";
          goto LABEL_95;
        }

        goto LABEL_96;
      }

      if (!v29) {
        goto LABEL_74;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
      __int16 v36 = 2082;
      int v37 = backtrace_string;
      BOOL v27 = "%{public}s called with null name, dumping backtrace:%{public}s";
      goto LABEL_73;
    }

    __nwlog_obj();
    size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_96;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v20 = "%{public}s called with null name";
    goto LABEL_95;
  }

  if (!regtype)
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_96;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
      os_log_type_t v20 = "%{public}s called with null type";
      goto LABEL_95;
    }

    if (!v32)
    {
      __nwlog_obj();
      size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
        os_log_type_t v20 = "%{public}s called with null type, backtrace limit exceeded";
        goto LABEL_95;
      }

      goto LABEL_96;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v30 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
        os_log_type_t v20 = "%{public}s called with null type, no backtrace";
        goto LABEL_95;
      }

      goto LABEL_96;
    }

    if (!v30) {
      goto LABEL_74;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    __int16 v36 = 2082;
    int v37 = backtrace_string;
    BOOL v27 = "%{public}s called with null type, dumping backtrace:%{public}s";
LABEL_73:
    _os_log_impl(&dword_181A5C000, v18, v19, v27, buf, 0x16u);
    goto LABEL_74;
  }

  if (!domain)
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v35 = "nw_endpoint_construct_composite_bonjour_name";
        os_log_type_t v20 = "%{public}s called with null domain";
        goto LABEL_95;
      }

const char *__cdecl nw_endpoint_get_bonjour_service_name(nw_endpoint_t endpoint)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  uint64_t v1 = endpoint;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v38 = "nw_endpoint_get_bonjour_service_name";
    BOOL v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_name";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v38 = "nw_endpoint_get_bonjour_service_name";
            __int16 v39 = 2082;
            *(void *)os_log_type_t v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_name";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_name";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181EB0858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *__cdecl nw_endpoint_get_bonjour_service_type(nw_endpoint_t endpoint)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  uint64_t v1 = endpoint;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v38 = "nw_endpoint_get_bonjour_service_type";
    BOOL v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_type";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v38 = "nw_endpoint_get_bonjour_service_type";
            __int16 v39 = 2082;
            *(void *)os_log_type_t v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_type";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_type";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181EB0E78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *__cdecl nw_endpoint_get_bonjour_service_domain(nw_endpoint_t endpoint)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  uint64_t v1 = endpoint;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v38 = "nw_endpoint_get_bonjour_service_domain";
    BOOL v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_domain";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v38 = "nw_endpoint_get_bonjour_service_domain";
            __int16 v39 = 2082;
            *(void *)os_log_type_t v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_domain";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_service_domain";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181EB1498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_get_bonjour_fullname(void *a1)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v38 = "nw_endpoint_get_bonjour_fullname";
    BOOL v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_fullname";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v38 = "nw_endpoint_get_bonjour_fullname";
            __int16 v39 = 2082;
            *(void *)os_log_type_t v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_fullname";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_bonjour_fullname";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181EB1AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_ids_info_create(const char *a1, const char *a2, const char *a3)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v47 = "nw_ids_info_create";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v45.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(v45.receiver) == 17)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v45.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v45.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "nw_ids_info_create";
        _os_log_impl(&dword_181A5C000, v16, receiver, "%{public}s called with null session_id", buf, 0xCu);
      }

      goto LABEL_82;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = (os_log_type_t)v45.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v45.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "nw_ids_info_create";
        _os_log_impl( &dword_181A5C000,  v16,  v39,  "%{public}s called with null session_id, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_82;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v31 = (os_log_type_t)v45.receiver;
    BOOL v32 = os_log_type_enabled(v16, (os_log_type_t)v45.receiver);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "nw_ids_info_create";
        _os_log_impl(&dword_181A5C000, v16, v31, "%{public}s called with null session_id, no backtrace", buf, 0xCu);
      }

      goto LABEL_82;
    }

    if (v32)
    {
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v47 = "nw_ids_info_create";
      __int16 v48 = 2082;
      BOOL v49 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v16,  v31,  "%{public}s called with null session_id, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_52;
  }

  if (!a2)
  {
    __nwlog_obj();
    int v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v47 = "nw_ids_info_create";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v45.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(v45.receiver) == 17)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = (os_log_type_t)v45.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v45.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "nw_ids_info_create";
        _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null pseudonym", buf, 0xCu);
      }

      goto LABEL_82;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = (os_log_type_t)v45.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v45.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "nw_ids_info_create";
        _os_log_impl( &dword_181A5C000,  v16,  v40,  "%{public}s called with null pseudonym, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_82;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v33 = (os_log_type_t)v45.receiver;
    BOOL v34 = os_log_type_enabled(v16, (os_log_type_t)v45.receiver);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "nw_ids_info_create";
        _os_log_impl(&dword_181A5C000, v16, v33, "%{public}s called with null pseudonym, no backtrace", buf, 0xCu);
      }

      goto LABEL_82;
    }

    if (v34)
    {
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v47 = "nw_ids_info_create";
      __int16 v48 = 2082;
      BOOL v49 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v16,  v33,  "%{public}s called with null pseudonym, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_52;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (os_log_s *)(id)gLogObj;
  os_log_type_t v7 = v6;
  if (!a3)
  {
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v47 = "nw_ids_info_create";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v45.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(v45.receiver) == 17)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = (os_log_type_t)v45.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v45.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "nw_ids_info_create";
        _os_log_impl(&dword_181A5C000, v16, v20, "%{public}s called with null push_token", buf, 0xCu);
      }

void sub_181EB26DC(_Unwind_Exception *exception_object)
{
}

uint64_t nw_ids_info_get_session_id(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 1);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v16 = "nw_ids_info_get_session_id";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_session_id";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null info", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v16 = "nw_ids_info_get_session_id";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_session_id";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_session_id";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

uint64_t nw_ids_info_get_pseudonym(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 2);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v16 = "nw_ids_info_get_pseudonym";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_pseudonym";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null info", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v16 = "nw_ids_info_get_pseudonym";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_pseudonym";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_pseudonym";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

uint64_t nw_ids_info_get_push_token(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 3);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v16 = "nw_ids_info_get_push_token";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_push_token";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null info", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v16 = "nw_ids_info_get_push_token";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_push_token";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_ids_info_get_push_token";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null info, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

uint64_t __Block_byref_object_copy__14649(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__14650(uint64_t a1)
{
}

uint64_t nw_advertise_descriptor_copy_description(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    int v3 = *((_DWORD *)v1 + 2);
    if (v3 == 2)
    {
      os_log_type_t v8 = v1[7];
      if (!v8) {
        os_log_type_t v8 = "<NULL>";
      }
      asprintf((char **)buf, "%s.%s scope:%x route:%x", v1[6], v8, *((_DWORD *)v1 + 16), *((_DWORD *)v1 + 17));
    }

    else if (v3 == 1)
    {
      int v4 = "<NULL>";
      uint64_t v5 = v1[2];
      if (!v5) {
        uint64_t v5 = "<NULL>";
      }
      id v6 = v1[5];
      if (v1[4]) {
        int v4 = v1[4];
      }
      if (v6) {
        id v6 = (const char *)*((void *)v6 + 2);
      }
      if (((_BYTE)v1[9] & 1) != 0) {
        os_log_type_t v7 = " noAutoRename";
      }
      else {
        os_log_type_t v7 = "";
      }
      asprintf((char **)buf, "%s.%s.%s txtLength:%zu%s", v5, v1[3], v4, (size_t)v6, v7);
    }

    uint64_t v9 = *(void *)buf;
    goto LABEL_18;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_advertise_descriptor_copy_description";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_advertise_descriptor_copy_description";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_advertise_descriptor_copy_description";
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_advertise_descriptor_copy_description";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_advertise_descriptor_copy_description";
        _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181EB45E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_advertise_descriptor_t nw_advertise_descriptor_create_bonjour_service( const char *name, const char *type, const char *domain)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (!type)
  {
    __nwlog_obj();
    char v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v37 = "nw_advertise_descriptor_create_bonjour_service";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v35.receiver) = 16;
    os_log_type_t typea = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(v35.receiver) == 17)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v35.receiver;
      if (os_log_type_enabled(v15, (os_log_type_t)v35.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v37 = "nw_advertise_descriptor_create_bonjour_service";
        _os_log_impl(&dword_181A5C000, v15, receiver, "%{public}s called with null type", buf, 0xCu);
      }
    }

    else if (typea)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = (os_log_type_t)v35.receiver;
      BOOL v28 = os_log_type_enabled(v15, (os_log_type_t)v35.receiver);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v37 = "nw_advertise_descriptor_create_bonjour_service";
          __int16 v38 = 2082;
          os_log_type_t v39 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_41;
      }

      if (v28)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v37 = "nw_advertise_descriptor_create_bonjour_service";
        _os_log_impl(&dword_181A5C000, v15, v27, "%{public}s called with null type, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = (os_log_type_t)v35.receiver;
      if (os_log_type_enabled(v15, (os_log_type_t)v35.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v37 = "nw_advertise_descriptor_create_bonjour_service";
        _os_log_impl( &dword_181A5C000,  v15,  v31,  "%{public}s called with null type, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_54;
  }

  id v6 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_advertise_descriptor);
  if (!v6) {
    return 0LL;
  }
  v35.os_log_type_t receiver = v6;
  v35.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_advertise_descriptor;
  os_log_type_t v7 = objc_msgSendSuper2(&v35, sel_init);
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v37 = "-[NWConcrete_nw_advertise_descriptor initWithName:type:domain:]";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t typea = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if ((__nwlog_fault(v14, &typea, &v33) & 1) == 0) {
      goto LABEL_54;
    }
    if (typea == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = typea;
      if (os_log_type_enabled(v18, typea))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v37 = "-[NWConcrete_nw_advertise_descriptor initWithName:type:domain:]";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s [super init] failed", buf, 0xCu);
      }

void sub_181EB4CD8(_Unwind_Exception *exception_object)
{
}

id nw_advertise_descriptor_create_application_service_with_bundle_id(const char *a1, const char *a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v4 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_advertise_descriptor);
    if (!v4) {
      goto LABEL_52;
    }
    v41.os_log_type_t receiver = v4;
    v41.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_advertise_descriptor;
    uint64_t v5 = objc_msgSendSuper2(&v41, sel_init);
    id v6 = v5;
    if (v5)
    {
      *((_DWORD *)v5 + 2) = 2;
      os_log_type_t v7 = strdup(a1);
      if (v7)
      {
        v6[6] = v7;
        if (!a2)
        {
LABEL_8:
          uint64_t v9 = v6;
LABEL_9:

          return v9;
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
        *(_DWORD *)__int128 buf = 136446210;
        char v43 = "strict_strdup";
        os_log_type_t v20 = (void *)_os_log_send_and_compose_impl();

        id result = (id)__nwlog_abort((uint64_t)v20);
        if ((_DWORD)result)
        {
LABEL_71:
          __break(1u);
          return result;
        }

        free(v20);
        v6[6] = 0LL;
        if (!a2) {
          goto LABEL_8;
        }
      }

      os_log_type_t v8 = strdup(a2);
      if (v8)
      {
LABEL_7:
        v6[7] = v8;
        goto LABEL_8;
      }

      __nwlog_obj();
      int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      char v43 = "strict_strdup";
      __int16 v22 = (void *)_os_log_send_and_compose_impl();

      id result = (id)__nwlog_abort((uint64_t)v22);
      if (!(_DWORD)result)
      {
        free(v22);
        goto LABEL_7;
      }

      goto LABEL_71;
    }

    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v43 = "-[NWConcrete_nw_advertise_descriptor initWithApplicationServiceName:bundleId:]";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if ((__nwlog_fault(v16, &type, &v39) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v43 = "-[NWConcrete_nw_advertise_descriptor initWithApplicationServiceName:bundleId:]";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v43 = "-[NWConcrete_nw_advertise_descriptor initWithApplicationServiceName:bundleId:]";
            __int16 v44 = 2082;
            objc_super v45 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v17,  v27,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }

        if (v28)
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v43 = "-[NWConcrete_nw_advertise_descriptor initWithApplicationServiceName:bundleId:]";
          _os_log_impl(&dword_181A5C000, v17, v27, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v43 = "-[NWConcrete_nw_advertise_descriptor initWithApplicationServiceName:bundleId:]";
          _os_log_impl( &dword_181A5C000,  v17,  v30,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181EB5574(_Unwind_Exception *exception_object)
{
}

uint64_t nw_advertise_descriptor_get_invitation_scope(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v22 = "nw_advertise_descriptor_get_invitation_scope";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v22 = "nw_advertise_descriptor_get_invitation_scope";
          _os_log_impl(&dword_181A5C000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }

uint64_t nw_advertise_descriptor_get_invitation_route(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v22 = "nw_advertise_descriptor_get_invitation_route";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v22 = "nw_advertise_descriptor_get_invitation_route";
          _os_log_impl(&dword_181A5C000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }

BOOL nw_advertise_descriptor_is_equal(void *a1, void *a2, char a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = v6;
  BOOL is_equal = v5 == v6;
  if (v5 == v6 || !v5 || !v6) {
    goto LABEL_34;
  }
  os_log_type_t v9 = (const char *)*((void *)v5 + 2);
  BOOL v10 = (const char *)*((void *)v7 + 2);
  if (v9 && v10)
  {
    if (strcmp(v9, v10)) {
      goto LABEL_33;
    }
  }

  else if (v9 != v10)
  {
    goto LABEL_33;
  }

  os_log_type_t v11 = (const char *)*((void *)v5 + 3);
  os_log_type_t v12 = (const char *)*((void *)v7 + 3);
  if (v11 && v12)
  {
    if (strcmp(v11, v12)) {
      goto LABEL_33;
    }
  }

  else if (v11 != v12)
  {
    goto LABEL_33;
  }

  char v13 = (const char *)*((void *)v5 + 4);
  os_log_type_t v14 = (const char *)*((void *)v7 + 4);
  if (v13 && v14)
  {
    if (strcmp(v13, v14)) {
      goto LABEL_33;
    }
  }

  else if (v13 != v14)
  {
    goto LABEL_33;
  }

  os_log_type_t v15 = (const char *)*((void *)v5 + 6);
  os_log_type_t v16 = (const char *)*((void *)v7 + 6);
  if (v15 && v16)
  {
    if (strcmp(v15, v16)) {
      goto LABEL_33;
    }
  }

  else if (v15 != v16)
  {
    goto LABEL_33;
  }

  BOOL v17 = (const char *)*((void *)v5 + 7);
  os_log_type_t v18 = (const char *)*((void *)v7 + 7);
  if (!v17 || !v18)
  {
    if (v17 == v18) {
      goto LABEL_29;
    }
LABEL_33:
    BOOL is_equal = 0LL;
    goto LABEL_34;
  }

  if (strcmp(v17, v18)) {
    goto LABEL_33;
  }
LABEL_29:
  if (*((_DWORD *)v5 + 16) != *((_DWORD *)v7 + 16)) {
    goto LABEL_33;
  }
  int v19 = *((_DWORD *)v5 + 17);
  int v20 = *((_DWORD *)v7 + 17);
  BOOL is_equal = v19 == v20;
  if (v19 == v20 && (a3 & 1) == 0) {
    BOOL is_equal = nw_txt_record_is_equal(*((nw_txt_record_t *)v5 + 5), *((nw_txt_record_t *)v7 + 5));
  }
LABEL_34:

  return is_equal;
}

void sub_181EB60BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_advertise_descriptor_get_type(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[2];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_advertise_descriptor_get_type";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_advertise_descriptor_get_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_advertise_descriptor_get_type";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_advertise_descriptor_get_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_advertise_descriptor_get_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_advertise_descriptor_get_bonjour_name(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 2) == 1)
    {
      uint64_t v3 = *((void *)v1 + 2);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v21 = "nw_advertise_descriptor_get_bonjour_name";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v21 = "nw_advertise_descriptor_get_bonjour_name";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s invalid advertise descriptor type", buf, 0xCu);
        }

uint64_t nw_advertise_descriptor_get_bonjour_type(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 2) == 1)
    {
      uint64_t v3 = *((void *)v1 + 3);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v21 = "nw_advertise_descriptor_get_bonjour_type";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v21 = "nw_advertise_descriptor_get_bonjour_type";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s invalid advertise descriptor type", buf, 0xCu);
        }

uint64_t nw_advertise_descriptor_get_bonjour_domain(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 2) == 1)
    {
      uint64_t v3 = *((void *)v1 + 4);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v21 = "nw_advertise_descriptor_get_bonjour_domain";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v21 = "nw_advertise_descriptor_get_bonjour_domain";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s invalid advertise descriptor type", buf, 0xCu);
        }

void nw_advertise_descriptor_set_no_auto_rename( nw_advertise_descriptor_t advertise_descriptor, BOOL no_auto_rename)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  nw_advertise_descriptor_t v3 = advertise_descriptor;
  nw_advertise_descriptor_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v22 = "nw_advertise_descriptor_set_no_auto_rename";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_advertise_descriptor_set_no_auto_rename";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null advertise_descriptor", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v22 = "nw_advertise_descriptor_set_no_auto_rename";
          __int16 v23 = 2082;
          uint64_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null advertise_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_advertise_descriptor_set_no_auto_rename";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null advertise_descriptor, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_advertise_descriptor_set_no_auto_rename";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null advertise_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }

BOOL nw_advertise_descriptor_get_no_auto_rename(nw_advertise_descriptor_t advertise_descriptor)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  nw_advertise_descriptor_t v1 = advertise_descriptor;
  nw_advertise_descriptor_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 2) == 1)
    {
      BOOL v3 = *((_BYTE *)v1 + 72) & 1;
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v21 = "nw_advertise_descriptor_get_no_auto_rename";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v21 = "nw_advertise_descriptor_get_no_auto_rename";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s invalid advertise descriptor type", buf, 0xCu);
        }

void nw_advertise_descriptor_set_txt_record( nw_advertise_descriptor_t advertise_descriptor, const void *txt_record, size_t txt_length)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  nw_advertise_descriptor_t v5 = advertise_descriptor;
  id v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v26 = "nw_advertise_descriptor_set_txt_record";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v26 = "nw_advertise_descriptor_set_txt_record";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null advertise_descriptor", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v26 = "nw_advertise_descriptor_set_txt_record";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null advertise_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v10) {
          goto LABEL_8;
        }
LABEL_43:
        free(v10);
        goto LABEL_8;
      }

      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v26 = "nw_advertise_descriptor_set_txt_record";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null advertise_descriptor, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v26 = "nw_advertise_descriptor_set_txt_record";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null advertise_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181EB7F84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_advertise_descriptor_get_txt_record(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  nw_advertise_descriptor_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v25 = "nw_advertise_descriptor_get_txt_record";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v25 = "nw_advertise_descriptor_get_txt_record";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null advertise_descriptor", buf, 0xCu);
      }

      goto LABEL_40;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v25 = "nw_advertise_descriptor_get_txt_record";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null advertise_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v25 = "nw_advertise_descriptor_get_txt_record";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null advertise_descriptor, no backtrace",  buf,  0xCu);
      }

      goto LABEL_40;
    }

    if (v16)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v25 = "nw_advertise_descriptor_get_txt_record";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null advertise_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_28;
  }

  if (*((_DWORD *)v3 + 2) != 1)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v25 = "nw_advertise_descriptor_get_txt_record";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v25 = "nw_advertise_descriptor_get_txt_record";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s invalid advertise descriptor type", buf, 0xCu);
      }

void nw_advertise_descriptor_set_txt_record_object( nw_advertise_descriptor_t advertise_descriptor, nw_txt_record_t txt_record)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  nw_advertise_descriptor_t v3 = advertise_descriptor;
  nw_advertise_descriptor_t v4 = txt_record;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v22 = "nw_advertise_descriptor_set_txt_record_object";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_advertise_descriptor_set_txt_record_object";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null advertise_descriptor", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v22 = "nw_advertise_descriptor_set_txt_record_object";
          __int16 v23 = 2082;
          uint64_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null advertise_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_advertise_descriptor_set_txt_record_object";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null advertise_descriptor, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_advertise_descriptor_set_txt_record_object";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null advertise_descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }

nw_txt_record_t nw_advertise_descriptor_copy_txt_record_object(nw_advertise_descriptor_t advertise_descriptor)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  nw_advertise_descriptor_t v1 = advertise_descriptor;
  nw_advertise_descriptor_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 2) == 1)
    {
      nw_advertise_descriptor_t v3 = (nw_txt_record *)*((id *)v1 + 5);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v21 = "nw_advertise_descriptor_copy_txt_record_object";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v21 = "nw_advertise_descriptor_copy_txt_record_object";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s invalid advertise descriptor type", buf, 0xCu);
        }

nw_advertise_descriptor_t nw_advertise_descriptor_create_application_service( const char *application_service_name)
{
  if (nw_utilities_get_self_name::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44151);
  }
  nw_advertise_descriptor_create_application_service_with_bundle_id( application_service_name,  (const char *)nw_utilities_get_self_name::name);
  return (nw_advertise_descriptor_t)objc_claimAutoreleasedReturnValue();
}

const char *__cdecl nw_advertise_descriptor_get_application_service_name( nw_advertise_descriptor_t advertise_descriptor)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  nw_advertise_descriptor_t v1 = advertise_descriptor;
  nw_advertise_descriptor_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 2) == 2)
    {
      nw_advertise_descriptor_t v3 = (const char *)*((void *)v1 + 6);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v21 = "nw_advertise_descriptor_get_application_service_name";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v21 = "nw_advertise_descriptor_get_application_service_name";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s invalid advertise descriptor type", buf, 0xCu);
        }

uint64_t nw_advertise_descriptor_get_bundle_id(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_advertise_descriptor_t v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 2) == 2)
    {
      uint64_t v3 = *((void *)v1 + 7);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v21 = "nw_advertise_descriptor_get_bundle_id";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v21 = "nw_advertise_descriptor_get_bundle_id";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s invalid advertise descriptor type", buf, 0xCu);
        }

void nw_advertise_descriptor_set_invitation(void *a1, int a2, int a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v24 = "nw_advertise_descriptor_set_invitation";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v24 = "nw_advertise_descriptor_set_invitation";
          _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null descriptor", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v24 = "nw_advertise_descriptor_set_invitation";
          _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v24 = "nw_advertise_descriptor_set_invitation";
          _os_log_impl(&dword_181A5C000, v9, v18, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v24 = "nw_advertise_descriptor_set_invitation";
        __int16 v25 = 2082;
        __int16 v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

_DWORD *nw_error_create_tls_error(int a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1) {
    return -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 3, a1);
  }
  __nwlog_obj();
  nw_advertise_descriptor_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v12 = "nw_error_create_tls_error";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_advertise_descriptor_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v12 = "nw_error_create_tls_error";
        uint64_t v6 = "%{public}s called with null error_code";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_advertise_descriptor_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v12 = "nw_error_create_tls_error";
            __int16 v13 = 2082;
            os_log_type_t v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null error_code, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v8) {
          goto LABEL_17;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v12 = "nw_error_create_tls_error";
        uint64_t v6 = "%{public}s called with null error_code, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      nw_advertise_descriptor_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v12 = "nw_error_create_tls_error";
        uint64_t v6 = "%{public}s called with null error_code, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

_DWORD *nw_error_create_dns_error(int a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1) {
    return -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 2, a1);
  }
  __nwlog_obj();
  nw_advertise_descriptor_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v12 = "nw_error_create_dns_error";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_advertise_descriptor_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v12 = "nw_error_create_dns_error";
        uint64_t v6 = "%{public}s called with null dns_error";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_advertise_descriptor_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v12 = "nw_error_create_dns_error";
            __int16 v13 = 2082;
            os_log_type_t v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null dns_error, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v8) {
          goto LABEL_17;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v12 = "nw_error_create_dns_error";
        uint64_t v6 = "%{public}s called with null dns_error, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      nw_advertise_descriptor_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v12 = "nw_error_create_dns_error";
        uint64_t v6 = "%{public}s called with null dns_error, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

_DWORD *nw_error_create_error_with_inferred_domain(int a1)
{
  return nw_error_create_tls_error(a1);
}

CFErrorRef nw_error_copy_cf_error(nw_error_t error)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = error;
  nw_advertise_descriptor_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = -[nw_error description](v1, "description");
    nw_advertise_descriptor_t v4 = (void *)v3;
    unsigned int v5 = *((_DWORD *)v2 + 2) - 1;
    if (v5 < 3 && (CFIndex v6 = *((int *)v2 + 3), (_DWORD)v6))
    {
      id v7 = off_189BB8008[v5];
      BOOL v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (v3)
      {
        *(void *)values = v3;
        char v9 = CFDictionaryCreate( v8,  MEMORY[0x189604F38],  (const void **)values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      }

      else
      {
        char v9 = 0LL;
      }

      os_log_type_t v10 = CFErrorCreate(v8, v7, v6, v9);
    }

    else
    {
      os_log_type_t v10 = 0LL;
    }

    goto LABEL_10;
  }

  __nwlog_obj();
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)values = 136446210;
  *(void *)&values[4] = "nw_error_copy_cf_error";
  __int16 v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)values = 136446210;
        *(void *)&values[4] = "nw_error_copy_cf_error";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null error", values, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)values = 136446466;
          *(void *)&values[4] = "nw_error_copy_cf_error";
          __int16 v23 = 2082;
          uint64_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null error, dumping backtrace:%{public}s",  values,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v18)
      {
        *(_DWORD *)values = 136446210;
        *(void *)&values[4] = "nw_error_copy_cf_error";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null error, no backtrace", values, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)values = 136446210;
        *(void *)&values[4] = "nw_error_copy_cf_error";
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null error, backtrace limit exceeded",  values,  0xCu);
      }
    }
  }

void sub_181EBA4B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int nw_error_get_error_code(nw_error_t error)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_error_t v1 = error;
  nw_error_t v2 = v1;
  if (v1)
  {
    int v3 = *((_DWORD *)v1 + 3);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_error_get_error_code";
  CFIndex v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_code";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null error", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_error_get_error_code";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null error, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_code";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null error, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_code";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null error, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

nw_error_domain_t nw_error_get_error_domain(nw_error_t error)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_error_t v1 = error;
  nw_error_t v2 = v1;
  if (v1)
  {
    nw_error_domain_t v3 = *((_DWORD *)v1 + 2);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_error_get_error_domain";
  CFIndex v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_domain";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null error", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_error_get_error_domain";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null error, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_domain";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null error, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_error_get_error_domain";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null error, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_error_is_equal(void *a1, void *a2)
{
  nw_error_domain_t v3 = a1;
  nw_advertise_descriptor_t v4 = a2;
  if (v3 && v4)
  {
    if (v3[2] != v4[2])
    {
      uint64_t v6 = 0LL;
      goto LABEL_10;
    }

    BOOL v5 = v3[3] == v4[3];
  }

  else
  {
    BOOL v5 = v3 == v4;
  }

  uint64_t v6 = v5;
LABEL_10:

  return v6;
}

void *nw_nexus_create_with_options(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)&v53[13] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v51 = "nw_nexus_create_with_options";
    __int16 v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v23 = (os_log_s *)gLogObj;
      os_log_type_t v24 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v51 = "nw_nexus_create_with_options";
      uint64_t v25 = "%{public}s called with null name";
    }

    else if (v48)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v23 = (os_log_s *)gLogObj;
      os_log_type_t v24 = type;
      BOOL v30 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v51 = "nw_nexus_create_with_options";
          __int16 v52 = 2082;
          *(void *)uint64_t v53 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s called with null name, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_93:
        if (!v22) {
          return 0LL;
        }
LABEL_94:
        free(v22);
        return 0LL;
      }

      if (!v30) {
        goto LABEL_93;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v51 = "nw_nexus_create_with_options";
      uint64_t v25 = "%{public}s called with null name, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v23 = (os_log_s *)gLogObj;
      os_log_type_t v24 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v51 = "nw_nexus_create_with_options";
      uint64_t v25 = "%{public}s called with null name, backtrace limit exceeded";
    }

    __int16 v44 = v23;
    os_log_type_t v45 = v24;
    uint32_t v46 = 12;
LABEL_92:
    _os_log_impl(&dword_181A5C000, v44, v45, v25, buf, v46);
    goto LABEL_93;
  }

  uint64_t v8 = os_nexus_controller_create();
  if (!v8)
  {
    int v26 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v51 = "nw_nexus_create_with_options";
    __int16 v52 = 1024;
    *(_DWORD *)uint64_t v53 = v26;
    __int16 v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = (os_log_s *)gLogObj;
      os_log_type_t v28 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v51 = "nw_nexus_create_with_options";
      __int16 v52 = 1024;
      *(_DWORD *)uint64_t v53 = v26;
      uint64_t v25 = "%{public}s os_nexus_controller_create() %{darwin.errno}d";
LABEL_91:
      __int16 v44 = v27;
      os_log_type_t v45 = v28;
      uint32_t v46 = 18;
      goto LABEL_92;
    }

    if (!v48)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = (os_log_s *)gLogObj;
      os_log_type_t v28 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v51 = "nw_nexus_create_with_options";
      __int16 v52 = 1024;
      *(_DWORD *)uint64_t v53 = v26;
      uint64_t v25 = "%{public}s os_nexus_controller_create() %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_91;
    }

    objc_super v35 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v27 = (os_log_s *)gLogObj;
    os_log_type_t v28 = type;
    BOOL v36 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v35)
    {
      if (!v36) {
        goto LABEL_93;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v51 = "nw_nexus_create_with_options";
      __int16 v52 = 1024;
      *(_DWORD *)uint64_t v53 = v26;
      uint64_t v25 = "%{public}s os_nexus_controller_create() %{darwin.errno}d, no backtrace";
      goto LABEL_91;
    }

    if (v36)
    {
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v51 = "nw_nexus_create_with_options";
      __int16 v52 = 1024;
      *(_DWORD *)uint64_t v53 = v26;
      v53[2] = 2082;
      *(void *)&v53[3] = v35;
      BOOL v37 = "%{public}s os_nexus_controller_create() %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_61:
      _os_log_impl(&dword_181A5C000, v27, v28, v37, buf, 0x1Cu);
    }

void *nw_nexus_create(uint64_t a1)
{
  return nw_nexus_create_with_options(a1, 0LL, 0LL, 0LL);
}

void nw_nexus_remove_instance()
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (os_nexus_controller_free_provider_instance())
  {
    int v0 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v10 = "nw_nexus_remove_instance";
    __int16 v11 = 1024;
    int v12 = v0;
    nw_error_t v1 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v7 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_error_t v2 = (os_log_s *)gLogObj;
      os_log_type_t v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v10 = "nw_nexus_remove_instance";
      __int16 v11 = 1024;
      int v12 = v0;
      nw_advertise_descriptor_t v4 = "%{public}s os_nexus_controller_free_provider_instance() %{darwin.errno}d";
    }

    else if (v7)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_error_t v2 = (os_log_s *)gLogObj;
      os_log_type_t v3 = type;
      BOOL v6 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v6)
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v10 = "nw_nexus_remove_instance";
          __int16 v11 = 1024;
          int v12 = v0;
          __int16 v13 = 2082;
          unint64_t v14 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s os_nexus_controller_free_provider_instance() %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_16;
      }

      if (!v6)
      {
LABEL_16:
        if (v1) {
          free(v1);
        }
        return;
      }

      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v10 = "nw_nexus_remove_instance";
      __int16 v11 = 1024;
      int v12 = v0;
      nw_advertise_descriptor_t v4 = "%{public}s os_nexus_controller_free_provider_instance() %{darwin.errno}d, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_error_t v2 = (os_log_s *)gLogObj;
      os_log_type_t v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v10 = "nw_nexus_remove_instance";
      __int16 v11 = 1024;
      int v12 = v0;
      nw_advertise_descriptor_t v4 = "%{public}s os_nexus_controller_free_provider_instance() %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v2, v3, v4, buf, 0x12u);
    goto LABEL_16;
  }

BOOL nw_nexus_create_channel_to_new_instance_and_context(uint64_t a1, _DWORD *a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
    nw_advertise_descriptor_t v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v34) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v34 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = v34;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v34)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      char v7 = "%{public}s called with null nexus";
    }

    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = v34;
      BOOL v14 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v34);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          uint64_t v15 = "%{public}s called with null nexus, dumping backtrace:%{public}s";
          int v16 = (os_log_s *)v8;
          os_log_type_t v17 = v9;
          uint32_t v18 = 22;
LABEL_37:
          _os_log_impl(&dword_181A5C000, v16, v17, v15, buf, v18);
          goto LABEL_38;
        }

        goto LABEL_38;
      }

      if (!v14) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      char v7 = "%{public}s called with null nexus, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = v34;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v34)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      char v7 = "%{public}s called with null nexus, backtrace limit exceeded";
    }

    char v21 = (os_log_s *)v8;
    os_log_type_t v22 = v9;
    uint32_t v23 = 12;
LABEL_77:
    _os_log_impl(&dword_181A5C000, v21, v22, v7, buf, v23);
    goto LABEL_78;
  }

  uuid_generate_random(out);
  if (os_nexus_controller_alloc_provider_instance())
  {
    int v3 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v3;
    nw_advertise_descriptor_t v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v30 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v3;
      char v7 = "%{public}s os_nexus_controller_alloc_provider_instance() %{darwin.errno}d";
    }

    else if (v30)
    {
      __int16 v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type[0];
      BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v11)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v3;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v11;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s os_nexus_controller_alloc_provider_instance() %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v11);
        if (!v4) {
          return 0LL;
        }
        goto LABEL_79;
      }

      if (!v12)
      {
LABEL_78:
        if (!v4) {
          return 0LL;
        }
LABEL_79:
        free(v4);
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v3;
      char v7 = "%{public}s os_nexus_controller_alloc_provider_instance() %{darwin.errno}d, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v3;
      char v7 = "%{public}s os_nexus_controller_alloc_provider_instance() %{darwin.errno}d, backtrace limit exceeded";
    }

    goto LABEL_76;
  }

  getpid();
  if (os_nexus_controller_bind_provider_instance())
  {
    int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v10;
    nw_advertise_descriptor_t v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v30 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      char v7 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d";
LABEL_76:
      char v21 = v5;
      os_log_type_t v22 = v6;
      uint32_t v23 = 18;
      goto LABEL_77;
    }

    if (v30 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      char v7 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_76;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type[0];
    BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (!v20) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      char v7 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, no backtrace";
      goto LABEL_76;
    }

    if (v20)
    {
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_nexus_add_instance";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = backtrace_string;
      uint64_t v15 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_36:
      int v16 = v5;
      os_log_type_t v17 = v6;
      uint32_t v18 = 28;
      goto LABEL_37;
    }

    goto LABEL_38;
  }

  *(_OWORD *)os_log_type_t type = v34;
  *(void *)&__int128 v34 = 0LL;
  if (!os_nexus_attr_create())
  {
    int v24 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v24;
    nw_advertise_descriptor_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v30 = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v30;
      if (!os_log_type_enabled(v5, v30)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v24;
      char v7 = "%{public}s os_nexus_attr_create() %{darwin.errno}d";
      goto LABEL_76;
    }

    if (!v29)
    {
      BOOL v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v30;
      if (!os_log_type_enabled(v5, v30)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v24;
      char v7 = "%{public}s os_nexus_attr_create() %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_76;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = v30;
    BOOL v27 = os_log_type_enabled(v5, v30);
    if (!backtrace_string)
    {
      if (!v27) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v24;
      char v7 = "%{public}s os_nexus_attr_create() %{darwin.errno}d, no backtrace";
      goto LABEL_76;
    }

    if (v27)
    {
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v24;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = backtrace_string;
      uint64_t v15 = "%{public}s os_nexus_attr_create() %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_36;
    }

    goto LABEL_38;
  }

  if (os_nexus_controller_read_provider_attr())
  {
    int v19 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v19;
    nw_advertise_descriptor_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v30 = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v30;
      if (!os_log_type_enabled(v5, v30)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v19;
      char v7 = "%{public}s os_nexus_controller_read_provider_attr() %{darwin.errno}d";
      goto LABEL_76;
    }

    if (!v29)
    {
      BOOL v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v30;
      if (!os_log_type_enabled(v5, v30)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v19;
      char v7 = "%{public}s os_nexus_controller_read_provider_attr() %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_76;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = v30;
    BOOL v26 = os_log_type_enabled(v5, v30);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v19;
      char v7 = "%{public}s os_nexus_controller_read_provider_attr() %{darwin.errno}d, no backtrace";
      goto LABEL_76;
    }

    if (v26)
    {
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_nexus_create_channel_to_new_instance_and_context";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v19;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = backtrace_string;
      uint64_t v15 = "%{public}s os_nexus_controller_read_provider_attr() %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_36;
    }

BOOL nw_nexus_create_channel_to_new_instance(uint64_t a1)
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  }
  return nw_nexus_create_channel_to_new_instance_and_context( a1,  (id)nw_context_copy_implicit_context::implicit_context);
}

void nw_nexus_close_channel_and_instance(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
    nw_error_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
      BOOL v5 = "%{public}s called with null nexus";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      goto LABEL_32;
    }

    if (!v10)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
      BOOL v5 = "%{public}s called with null nexus, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v7) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
      BOOL v5 = "%{public}s called with null nexus, no backtrace";
      goto LABEL_31;
    }

    if (v7)
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null nexus, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_32:
    if (!v2) {
      return;
    }
    goto LABEL_33;
  }

  if (a2)
  {
    *(_OWORD *)__int128 buf = *(_OWORD *)(a2 + 88);
    nw_channel_close(a2, a2);
    nw_nexus_remove_instance();
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
  nw_error_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
    BOOL v5 = "%{public}s called with null channel";
    goto LABEL_31;
  }

  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
    BOOL v5 = "%{public}s called with null channel, backtrace limit exceeded";
    goto LABEL_31;
  }

  uint64_t v8 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v3 = (os_log_s *)gLogObj;
  os_log_type_t v4 = type;
  BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v8)
  {
    if (!v9) {
      goto LABEL_32;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
    BOOL v5 = "%{public}s called with null channel, no backtrace";
    goto LABEL_31;
  }

  if (v9)
  {
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_nexus_close_channel_and_instance";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v8;
    _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v8);
  if (v2) {
LABEL_33:
  }
    free(v2);
}

uint64_t nw_nexus_bind_client_port(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)&v28[13] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v26 = "nw_nexus_bind_client_port";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v26 = "nw_nexus_bind_client_port";
      char v10 = "%{public}s called with null nexus";
LABEL_48:
      BOOL v20 = v11;
      os_log_type_t v21 = v12;
      uint32_t v22 = 12;
      goto LABEL_49;
    }

    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v26 = "nw_nexus_bind_client_port";
      char v10 = "%{public}s called with null nexus, backtrace limit exceeded";
      goto LABEL_48;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v11 = (os_log_s *)gLogObj;
    os_log_type_t v12 = type;
    BOOL v14 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v14) {
        goto LABEL_50;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v26 = "nw_nexus_bind_client_port";
      char v10 = "%{public}s called with null nexus, no backtrace";
      goto LABEL_48;
    }

    if (v14)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v26 = "nw_nexus_bind_client_port";
      __int16 v27 = 2082;
      *(void *)os_log_type_t v28 = backtrace_string;
      uint64_t v15 = "%{public}s called with null nexus, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v11, v12, v15, buf, 0x16u);
    }

void nw_nexus_close(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      os_nexus_controller_destroy();
      *(void *)(a1 + 16) = 0LL;
    }

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v11 = "nw_nexus_close";
  nw_error_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v11 = "nw_nexus_close";
      BOOL v5 = "%{public}s called with null nexus";
      goto LABEL_17;
    }

    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v11 = "nw_nexus_close";
      BOOL v5 = "%{public}s called with null nexus, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v11 = "nw_nexus_close";
        __int16 v12 = 2082;
        uint64_t v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null nexus, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v11 = "nw_nexus_close";
      BOOL v5 = "%{public}s called with null nexus, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

void *nw_protocol_set_default_one_to_one_callbacks(void *result)
{
  *id result = nw_protocol_default_add_input_handler;
  result[1] = nw_protocol_default_remove_input_handler;
  result[8] = nw_protocol_default_input_available;
  result[9] = nw_protocol_default_output_available;
  result[10] = nw_protocol_default_get_input_frames;
  result[11] = nw_protocol_default_get_output_frames;
  result[12] = nw_protocol_default_finalize_output_frames;
  result[13] = nw_protocol_default_link_state;
  result[16] = nw_protocol_default_get_local;
  result[17] = nw_protocol_default_get_remote;
  result[14] = nw_protocol_default_get_parameters;
  result[15] = nw_protocol_default_get_path;
  result[24] = nw_protocol_default_output_finished;
  result[25] = nw_protocol_default_get_output_local;
  result[2] = nw_protocol_default_replace_input_handler;
  result[3] = nw_protocol_default_connect;
  result[4] = nw_protocol_default_disconnect;
  result[5] = nw_protocol_default_connected;
  result[6] = nw_protocol_default_disconnected;
  result[7] = nw_protocol_default_error;
  result[32] = nw_protocol_default_reset;
  result[33] = nw_protocol_default_input_flush;
  result[22] = nw_protocol_default_supports_external_data;
  result[23] = nw_protocol_default_input_finished;
  result[26] = nw_protocol_default_get_output_interface;
  result[27] = nw_protocol_default_waiting_for_output;
  result[18] = nw_protocol_default_register_notification;
  result[19] = nw_protocol_default_unregister_notification;
  result[20] = nw_protocol_default_notify;
  result[21] = nw_protocol_default_updated_path;
  result[28] = nw_protocol_default_copy_info;
  result[29] = nw_protocol_default_add_listen_handler;
  result[30] = nw_protocol_default_remove_listen_handler;
  result[31] = nw_protocol_default_get_message_properties;
  return result;
}

uint64_t nw_protocol_default_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!a1)
  {
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_protocol_default_add_input_handler";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_add_input_handler";
      char v8 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v21 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v25 = "nw_protocol_default_add_input_handler";
          __int16 v26 = 2082;
          __int16 v27 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v4) {
          goto LABEL_28;
        }
        return 0LL;
      }

      if (!v21) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_add_input_handler";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_add_input_handler";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    uint64_t v14 = v18;
    os_log_type_t v15 = v19;
    uint32_t v16 = 12;
    goto LABEL_26;
  }

  identifier = a1->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)__int128 buf = 136446466;
  BOOL v25 = "nw_protocol_default_add_input_handler";
  __int16 v26 = 2082;
  __int16 v27 = identifier;
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v4, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      BOOL v7 = a1->identifier;
      if (!v7) {
        BOOL v7 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_add_input_handler";
      __int16 v26 = 2082;
      __int16 v27 = v7;
      char v8 = "%{public}s Default protocol handler does not support add_input_handler for %{public}s";
LABEL_25:
      uint64_t v14 = v5;
      os_log_type_t v15 = v6;
      uint32_t v16 = 22;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v14, v15, v8, buf, v16);
      goto LABEL_27;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      __int16 v12 = a1->identifier;
      if (!v12) {
        __int16 v12 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_add_input_handler";
      __int16 v26 = 2082;
      __int16 v27 = v12;
      char v8 = "%{public}s Default protocol handler does not support add_input_handler for %{public}s, backtrace limit exceeded";
      goto LABEL_25;
    }

    os_log_type_t v9 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_27;
      }
      uint64_t v13 = a1->identifier;
      if (!v13) {
        uint64_t v13 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_add_input_handler";
      __int16 v26 = 2082;
      __int16 v27 = v13;
      char v8 = "%{public}s Default protocol handler does not support add_input_handler for %{public}s, no backtrace";
      goto LABEL_25;
    }

    if (v10)
    {
      __int16 v11 = a1->identifier;
      if (!v11) {
        __int16 v11 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v25 = "nw_protocol_default_add_input_handler";
      __int16 v26 = 2082;
      __int16 v27 = v11;
      __int16 v28 = 2082;
      char v29 = v9;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Default protocol handler does not support add_input_handler for %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v9);
  }

uint64_t nw_protocol_default_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    id v31 = "nw_protocol_default_replace_input_handler";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = "nw_protocol_default_replace_input_handler";
      __int16 v11 = "%{public}s called with null protocol";
      goto LABEL_65;
    }

    if (!v28)
    {
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = "nw_protocol_default_replace_input_handler";
      __int16 v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_65;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v24 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (!v24) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = "nw_protocol_default_replace_input_handler";
      __int16 v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_65;
    }

    if (!v24) {
      goto LABEL_52;
    }
    *(_DWORD *)__int128 buf = 136446466;
    id v31 = "nw_protocol_default_replace_input_handler";
    __int16 v32 = 2082;
    os_log_type_t v33 = (nw_protocol *)backtrace_string;
    BOOL v25 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_51;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    id v31 = "nw_protocol_default_replace_input_handler";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = "nw_protocol_default_replace_input_handler";
      __int16 v11 = "%{public}s called with null old_input_handler";
      goto LABEL_65;
    }

    if (!v28)
    {
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = "nw_protocol_default_replace_input_handler";
      __int16 v11 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
      goto LABEL_65;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v26 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = "nw_protocol_default_replace_input_handler";
      __int16 v11 = "%{public}s called with null old_input_handler, no backtrace";
      goto LABEL_65;
    }

    if (!v26) {
      goto LABEL_52;
    }
    *(_DWORD *)__int128 buf = 136446466;
    id v31 = "nw_protocol_default_replace_input_handler";
    __int16 v32 = 2082;
    os_log_type_t v33 = (nw_protocol *)backtrace_string;
    BOOL v25 = "%{public}s called with null old_input_handler, dumping backtrace:%{public}s";
LABEL_51:
    _os_log_impl(&dword_181A5C000, v21, v22, v25, buf, 0x16u);
    goto LABEL_52;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    id v31 = "nw_protocol_default_replace_input_handler";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = "nw_protocol_default_replace_input_handler";
      __int16 v11 = "%{public}s called with null new_input_handler";
      goto LABEL_65;
    }

    if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v27 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v31 = "nw_protocol_default_replace_input_handler";
          __int16 v32 = 2082;
          os_log_type_t v33 = (nw_protocol *)backtrace_string;
          BOOL v25 = "%{public}s called with null new_input_handler, dumping backtrace:%{public}s";
          goto LABEL_51;
        }

uint64_t nw_protocol_default_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!a1)
  {
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_protocol_default_remove_input_handler";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_remove_input_handler";
      char v8 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v21 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v25 = "nw_protocol_default_remove_input_handler";
          __int16 v26 = 2082;
          BOOL v27 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v4) {
          goto LABEL_28;
        }
        return 0LL;
      }

      if (!v21) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_remove_input_handler";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_remove_input_handler";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    BOOL v14 = v18;
    os_log_type_t v15 = v19;
    uint32_t v16 = 12;
    goto LABEL_26;
  }

  identifier = a1->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)__int128 buf = 136446466;
  BOOL v25 = "nw_protocol_default_remove_input_handler";
  __int16 v26 = 2082;
  BOOL v27 = identifier;
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v4, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      BOOL v7 = a1->identifier;
      if (!v7) {
        BOOL v7 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_remove_input_handler";
      __int16 v26 = 2082;
      BOOL v27 = v7;
      char v8 = "%{public}s Default protocol handler does not support remove_input_handler for %{public}s";
LABEL_25:
      BOOL v14 = v5;
      os_log_type_t v15 = v6;
      uint32_t v16 = 22;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v14, v15, v8, buf, v16);
      goto LABEL_27;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      __int16 v12 = a1->identifier;
      if (!v12) {
        __int16 v12 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_remove_input_handler";
      __int16 v26 = 2082;
      BOOL v27 = v12;
      char v8 = "%{public}s Default protocol handler does not support remove_input_handler for %{public}s, backtrace limit exceeded";
      goto LABEL_25;
    }

    os_log_type_t v9 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_27;
      }
      uint64_t v13 = a1->identifier;
      if (!v13) {
        uint64_t v13 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_remove_input_handler";
      __int16 v26 = 2082;
      BOOL v27 = v13;
      char v8 = "%{public}s Default protocol handler does not support remove_input_handler for %{public}s, no backtrace";
      goto LABEL_25;
    }

    if (v10)
    {
      __int16 v11 = a1->identifier;
      if (!v11) {
        __int16 v11 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v25 = "nw_protocol_default_remove_input_handler";
      __int16 v26 = 2082;
      BOOL v27 = v11;
      __int16 v28 = 2082;
      char v29 = v9;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Default protocol handler does not support remove_input_handler for %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v9);
  }

uint64_t nw_protocol_default_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v7 = (os_log_s *)gLogObj;
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      identifier = (nw_protocol_identifier *)"invalid";
      if (a1->identifier) {
        identifier = a1->identifier;
      }
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v19 = "nw_protocol_default_get_input_frames";
      __int16 v20 = 2082;
      BOOL v21 = identifier;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s Default protocol handler does not support get_input_frames for %{public}s",  buf,  0x16u);
    }

    return 0LL;
  }

  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v19 = "nw_protocol_default_get_input_frames";
  BOOL v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v19 = "nw_protocol_default_get_input_frames";
      uint64_t v13 = "%{public}s called with null protocol";
      goto LABEL_20;
    }

    if (!v16)
    {
      __int16 v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v19 = "nw_protocol_default_get_input_frames";
      uint64_t v13 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v15 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v19 = "nw_protocol_default_get_input_frames";
        __int16 v20 = 2082;
        BOOL v21 = (nw_protocol_identifier *)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v15)
    {
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v19 = "nw_protocol_default_get_input_frames";
      uint64_t v13 = "%{public}s called with null protocol, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    }
  }

uint64_t nw_protocol_default_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!a1)
  {
    *(_DWORD *)__int128 buf = 136446210;
    char v29 = "nw_protocol_default_get_output_frames";
    char v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v29 = "nw_protocol_default_get_output_frames";
      os_log_type_t v12 = "%{public}s called with null protocol";
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v25 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v29 = "nw_protocol_default_get_output_frames";
          __int16 v30 = 2082;
          id v31 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v8) {
          goto LABEL_28;
        }
        return 0LL;
      }

      if (!v25) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v29 = "nw_protocol_default_get_output_frames";
      os_log_type_t v12 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v29 = "nw_protocol_default_get_output_frames";
      os_log_type_t v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    BOOL v18 = v22;
    os_log_type_t v19 = v23;
    uint32_t v20 = 12;
    goto LABEL_26;
  }

  identifier = a1->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)__int128 buf = 136446466;
  char v29 = "nw_protocol_default_get_output_frames";
  __int16 v30 = 2082;
  id v31 = identifier;
  char v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v8, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      __int16 v11 = a1->identifier;
      if (!v11) {
        __int16 v11 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      char v29 = "nw_protocol_default_get_output_frames";
      __int16 v30 = 2082;
      id v31 = v11;
      os_log_type_t v12 = "%{public}s Default protocol handler does not support get_output_frames for %{public}s";
LABEL_25:
      BOOL v18 = v9;
      os_log_type_t v19 = v10;
      uint32_t v20 = 22;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v18, v19, v12, buf, v20);
      goto LABEL_27;
    }

    if (!v26)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      char v16 = a1->identifier;
      if (!v16) {
        char v16 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      char v29 = "nw_protocol_default_get_output_frames";
      __int16 v30 = 2082;
      id v31 = v16;
      os_log_type_t v12 = "%{public}s Default protocol handler does not support get_output_frames for %{public}s, backtrace limit exceeded";
      goto LABEL_25;
    }

    uint64_t v13 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v14 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v13)
    {
      if (!v14) {
        goto LABEL_27;
      }
      os_log_type_t v17 = a1->identifier;
      if (!v17) {
        os_log_type_t v17 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      char v29 = "nw_protocol_default_get_output_frames";
      __int16 v30 = 2082;
      id v31 = v17;
      os_log_type_t v12 = "%{public}s Default protocol handler does not support get_output_frames for %{public}s, no backtrace";
      goto LABEL_25;
    }

    if (v14)
    {
      BOOL v15 = a1->identifier;
      if (!v15) {
        BOOL v15 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      char v29 = "nw_protocol_default_get_output_frames";
      __int16 v30 = 2082;
      id v31 = v15;
      __int16 v32 = 2082;
      os_log_type_t v33 = v13;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s Default protocol handler does not support get_output_frames for %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v13);
  }

uint64_t nw_protocol_default_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!a1)
  {
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_protocol_default_finalize_output_frames";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_finalize_output_frames";
      char v8 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v21 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v25 = "nw_protocol_default_finalize_output_frames";
          __int16 v26 = 2082;
          BOOL v27 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v4) {
          goto LABEL_28;
        }
        return 0LL;
      }

      if (!v21) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_finalize_output_frames";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_finalize_output_frames";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    BOOL v14 = v18;
    os_log_type_t v15 = v19;
    uint32_t v16 = 12;
    goto LABEL_26;
  }

  identifier = a1->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)__int128 buf = 136446466;
  BOOL v25 = "nw_protocol_default_finalize_output_frames";
  __int16 v26 = 2082;
  BOOL v27 = identifier;
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v4, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      BOOL v7 = a1->identifier;
      if (!v7) {
        BOOL v7 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      BOOL v27 = v7;
      char v8 = "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s";
LABEL_25:
      BOOL v14 = v5;
      os_log_type_t v15 = v6;
      uint32_t v16 = 22;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v14, v15, v8, buf, v16);
      goto LABEL_27;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      os_log_type_t v12 = a1->identifier;
      if (!v12) {
        os_log_type_t v12 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      BOOL v27 = v12;
      char v8 = "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s, backtrace limit exceeded";
      goto LABEL_25;
    }

    os_log_type_t v9 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_27;
      }
      uint64_t v13 = a1->identifier;
      if (!v13) {
        uint64_t v13 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      BOOL v27 = v13;
      char v8 = "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s, no backtrace";
      goto LABEL_25;
    }

    if (v10)
    {
      __int16 v11 = a1->identifier;
      if (!v11) {
        __int16 v11 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v25 = "nw_protocol_default_finalize_output_frames";
      __int16 v26 = 2082;
      BOOL v27 = v11;
      __int16 v28 = 2082;
      char v29 = v9;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Default protocol handler does not support finalize_output_frames for %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v9);
  }

void nw_protocol_default_link_state(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 48);
    if (v1)
    {
      uint64_t v2 = *(void *)(v1 + 24);
      if (v2)
      {
        int v3 = *(void (**)(void))(v2 + 104);
        if (v3) {
          v3();
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v13 = "nw_protocol_default_link_state";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_protocol_default_link_state";
      BOOL v7 = "%{public}s called with null protocol";
      goto LABEL_19;
    }

    if (!v10)
    {
      BOOL v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_protocol_default_link_state";
      BOOL v7 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_19;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v13 = "nw_protocol_default_link_state";
        __int16 v14 = 2082;
        os_log_type_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_20;
    }

    if (v9)
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_protocol_default_link_state";
      BOOL v7 = "%{public}s called with null protocol, no backtrace";
LABEL_19:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

uint64_t nw_protocol_default_updated_path(nw_protocol *a1, nw_protocol *a2, nw_path *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v16 = "nw_protocol_default_updated_path";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "nw_protocol_default_updated_path";
      char v10 = "%{public}s called with null protocol";
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v16 = "nw_protocol_default_updated_path";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v12)
      {
LABEL_20:
        if (v7) {
          free(v7);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "nw_protocol_default_updated_path";
      char v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "nw_protocol_default_updated_path";
      char v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_20;
  }

  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      updated_path = (uint64_t (*)(void))callbacks->updated_path;
      if (updated_path) {
        return updated_path();
      }
    }
  }

  return 0LL;
}

uint64_t nw_protocol_default_get_output_interface(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v14 = "nw_protocol_default_get_output_interface";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_get_output_interface";
      char v8 = "%{public}s called with null protocol";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v14 = "nw_protocol_default_get_output_interface";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v10)
      {
LABEL_20:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_get_output_interface";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_get_output_interface";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_20;
  }

  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      get_output_interface = (uint64_t (*)(void))callbacks->get_output_interface;
    }
  }

  return 0LL;
}

void nw_protocol_default_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        connected = (void (*)(void))callbacks->connected;
        if (connected) {
          connected();
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v14 = "nw_protocol_default_connected";
  BOOL v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_connected";
      char v8 = "%{public}s called with null protocol";
      goto LABEL_19;
    }

    if (!v11)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_connected";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_19;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v14 = "nw_protocol_default_connected";
        __int16 v15 = 2082;
        uint64_t v16 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_20;
    }

    if (v10)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_connected";
      char v8 = "%{public}s called with null protocol, no backtrace";
LABEL_19:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    }
  }

uint64_t nw_protocol_default_reset(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!a1)
  {
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_protocol_default_reset";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_reset";
      char v8 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v21 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v25 = "nw_protocol_default_reset";
          __int16 v26 = 2082;
          BOOL v27 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v4) {
          goto LABEL_28;
        }
        return 0LL;
      }

      if (!v21) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_reset";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_default_reset";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    __int16 v14 = v18;
    os_log_type_t v15 = v19;
    uint32_t v16 = 12;
    goto LABEL_26;
  }

  identifier = a1->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)__int128 buf = 136446466;
  BOOL v25 = "nw_protocol_default_reset";
  __int16 v26 = 2082;
  BOOL v27 = identifier;
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v4, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      os_log_type_t v7 = a1->identifier;
      if (!v7) {
        os_log_type_t v7 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_reset";
      __int16 v26 = 2082;
      BOOL v27 = v7;
      char v8 = "%{public}s Reset is not supported on default callback for %{public}s";
LABEL_25:
      __int16 v14 = v5;
      os_log_type_t v15 = v6;
      uint32_t v16 = 22;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v14, v15, v8, buf, v16);
      goto LABEL_27;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_27;
      }
      BOOL v12 = a1->identifier;
      if (!v12) {
        BOOL v12 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_reset";
      __int16 v26 = 2082;
      BOOL v27 = v12;
      char v8 = "%{public}s Reset is not supported on default callback for %{public}s, backtrace limit exceeded";
      goto LABEL_25;
    }

    os_log_type_t v9 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_27;
      }
      char v13 = a1->identifier;
      if (!v13) {
        char v13 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v25 = "nw_protocol_default_reset";
      __int16 v26 = 2082;
      BOOL v27 = v13;
      char v8 = "%{public}s Reset is not supported on default callback for %{public}s, no backtrace";
      goto LABEL_25;
    }

    if (v10)
    {
      char v11 = a1->identifier;
      if (!v11) {
        char v11 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v25 = "nw_protocol_default_reset";
      __int16 v26 = 2082;
      BOOL v27 = v11;
      __int16 v28 = 2082;
      char v29 = v9;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Reset is not supported on default callback for %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v9);
  }

uint64_t nw_protocol_default_register_notification(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v14 = "nw_protocol_default_register_notification";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_register_notification";
      char v8 = "%{public}s called with null protocol";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v14 = "nw_protocol_default_register_notification";
          __int16 v15 = 2082;
          uint32_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v10)
      {
LABEL_20:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_register_notification";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_register_notification";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_20;
  }

  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2)
    {
      int v3 = *(uint64_t (**)(void))(v2 + 144);
      if (v3) {
        return v3();
      }
    }
  }

  return 0LL;
}

uint64_t nw_protocol_default_unregister_notification(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v14 = "nw_protocol_default_unregister_notification";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_unregister_notification";
      char v8 = "%{public}s called with null protocol";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v14 = "nw_protocol_default_unregister_notification";
          __int16 v15 = 2082;
          uint32_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v10)
      {
LABEL_20:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_unregister_notification";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v14 = "nw_protocol_default_unregister_notification";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_20;
  }

  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2)
    {
      int v3 = *(uint64_t (**)(void))(v2 + 152);
      if (v3) {
        return v3();
      }
    }
  }

  return 0LL;
}

uint64_t nw_protocol_default_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v3 = (os_log_s *)gLogObj;
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      identifier = (nw_protocol_identifier *)"invalid";
      if (a1->identifier) {
        identifier = a1->identifier;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v15 = "nw_protocol_default_add_listen_handler";
      __int16 v16 = 2082;
      uint64_t v17 = identifier;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s Default protocol handler does not support add_listen_handler for %{public}s",  buf,  0x16u);
    }

    return 0LL;
  }

  *(_DWORD *)__int128 buf = 136446210;
  __int16 v15 = "nw_protocol_default_add_listen_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v15 = "nw_protocol_default_add_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol";
      goto LABEL_20;
    }

    if (!v12)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v15 = "nw_protocol_default_add_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v15 = "nw_protocol_default_add_listen_handler";
        __int16 v16 = 2082;
        uint64_t v17 = (nw_protocol_identifier *)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v15 = "nw_protocol_default_add_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

uint64_t nw_protocol_default_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v3 = (os_log_s *)gLogObj;
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      identifier = (nw_protocol_identifier *)"invalid";
      if (a1->identifier) {
        identifier = a1->identifier;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v15 = "nw_protocol_default_remove_listen_handler";
      __int16 v16 = 2082;
      uint64_t v17 = identifier;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s Default protocol handler does not support remove_listen_handler for %{public}s",  buf,  0x16u);
    }

    return 0LL;
  }

  *(_DWORD *)__int128 buf = 136446210;
  __int16 v15 = "nw_protocol_default_remove_listen_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v15 = "nw_protocol_default_remove_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol";
      goto LABEL_20;
    }

    if (!v12)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v15 = "nw_protocol_default_remove_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v15 = "nw_protocol_default_remove_listen_handler";
        __int16 v16 = 2082;
        uint64_t v17 = (nw_protocol_identifier *)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v15 = "nw_protocol_default_remove_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

BOOL nw_protocol_http_cookie_create()
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  int v0 = calloc(1uLL, 0x1C0uLL);
  if (!v0)
  {
    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446722;
    os_log_type_t v8 = "strict_calloc";
    __int16 v9 = 2048;
    uint64_t v10 = 1LL;
    __int16 v11 = 2048;
    uint64_t v12 = 448LL;
    BOOL v5 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v5);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v5);
  }

  v0[26] = 0u;
  v0[27] = 0u;
  v0[24] = 0u;
  v0[25] = 0u;
  v0[22] = 0u;
  v0[23] = 0u;
  v0[20] = 0u;
  v0[21] = 0u;
  v0[18] = 0u;
  v0[19] = 0u;
  v0[16] = 0u;
  v0[17] = 0u;
  v0[14] = 0u;
  v0[15] = 0u;
  v0[12] = 0u;
  v0[13] = 0u;
  v0[10] = 0u;
  v0[11] = 0u;
  v0[8] = 0u;
  v0[9] = 0u;
  v0[6] = 0u;
  v0[7] = 0u;
  v0[4] = 0u;
  v0[5] = 0u;
  v0[2] = 0u;
  v0[3] = 0u;
  _OWORD *v0 = 0u;
  v0[1] = 0u;
  if (nw_protocol_http_cookie_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http_cookie_identifier::onceToken, &__block_literal_global_15656);
  }
  *((void *)v0 + 2) = &nw_protocol_http_cookie_identifier::http_cookie_protocol_identifier;
  *((void *)v0 + 3) = &nw_protocol_http_cookie_get_callbacks(void)::protocol_callbacks;
  *((void *)v0 + 5) = v0;
  if ((*((_BYTE *)v0 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446722;
        os_log_type_t v8 = "nw_protocol_http_cookie_create";
        __int16 v9 = 2082;
        uint64_t v10 = (uint64_t)v0 + 114;
        __int16 v11 = 2080;
        uint64_t v12 = (uint64_t)" ";
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
  }

  if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
  }
  id v1 = (id)nw_protocol_copy_http_cookie_definition_http_cookie_definition;
  *((void *)v0 + _Block_object_dispose(va, 8) = (char *)v0 + 104;
  nw_protocol_plugin_name_set_callbacks((uint64_t)v0, (uint64_t)nw_protocol_http_cookie_create::$_0::__invoke);
  *((void *)v0 + 25) = 0LL;
  *((void *)v0 + 9) = (char *)v0 + 200;
  *((void *)v0 + 26) = (char *)v0 + 200;
  *((void *)v0 + 27) = 0LL;
  *((void *)v0 + 2_Block_object_dispose(va, 8) = (char *)v0 + 216;
  *((void *)v0 + 29) = 0LL;
  *((void *)v0 + 30) = (char *)v0 + 232;
  *((_BYTE *)v0 + 340) = 2;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  id v2 = (id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_plugin_metadata_set_callbacks( (uint64_t)v0,  v2,  (uint64_t)nw_protocol_http_cookie_create::$_1::__invoke,  (uint64_t)nw_protocol_http_cookie_create::$_2::__invoke);
  if (v2) {
    os_release(v2);
  }
  *((void *)v0 + 10) = (char *)v0 + 344;
  if (v1) {
    os_release(v1);
  }
  return (BOOL)v0;
}

uint64_t nw_protocol_http_cookie_create::$_0::__invoke( nw_protocol_http_cookie_create::$_0 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

void nw_protocol_http_cookie_create::$_1::__invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v136 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    v132[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v132[0] != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = v132[0];
        if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_119;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = v132[0];
      BOOL v28 = os_log_type_enabled(v24, (os_log_type_t)v132[0]);
      if (!backtrace_string)
      {
        if (!v28) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_119;
      }

      if (v28)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "operator()";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_120:
      if (!v23) {
        return;
      }
      goto LABEL_121;
    }

    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = v132[0];
    if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
      goto LABEL_120;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    __int16 v26 = "%{public}s called with null protocol";
    goto LABEL_119;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    v132[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v132[0] != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = v132[0];
        if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null http_cookie, backtrace limit exceeded";
        goto LABEL_119;
      }

      char v29 = (char *)__nw_create_backtrace_string();
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = v132[0];
      BOOL v30 = os_log_type_enabled(v24, (os_log_type_t)v132[0]);
      if (!v29)
      {
        if (!v30) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null http_cookie, no backtrace";
        goto LABEL_119;
      }

      if (!v30) {
        goto LABEL_72;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v29;
      id v31 = "%{public}s called with null http_cookie, dumping backtrace:%{public}s";
      goto LABEL_71;
    }

    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = v132[0];
    if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
      goto LABEL_120;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    __int16 v26 = "%{public}s called with null http_cookie";
LABEL_119:
    _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
    goto LABEL_120;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    v132[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v132[0] != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = v132[0];
        if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_119;
      }

      char v29 = (char *)__nw_create_backtrace_string();
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = v132[0];
      BOOL v32 = os_log_type_enabled(v24, (os_log_type_t)v132[0]);
      if (!v29)
      {
        if (!v32) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_119;
      }

      if (!v32) {
        goto LABEL_72;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v29;
      id v31 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_71;
    }

    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = v132[0];
    if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
      goto LABEL_120;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    __int16 v26 = "%{public}s called with null other_protocol";
    goto LABEL_119;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    v132[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v132[0] != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = v132[0];
        if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_119;
      }

      char v29 = (char *)__nw_create_backtrace_string();
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = v132[0];
      BOOL v33 = os_log_type_enabled(v24, (os_log_type_t)v132[0]);
      if (!v29)
      {
        if (!v33) {
          goto LABEL_120;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_119;
      }

      if (!v33) {
        goto LABEL_72;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v29;
      id v31 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
      goto LABEL_71;
    }

    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = v132[0];
    if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
      goto LABEL_120;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    __int16 v26 = "%{public}s called with null metadata";
    goto LABEL_119;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    v132[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v132[0] == 17)
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = v132[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
        goto LABEL_120;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null completion";
      goto LABEL_119;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = v132[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)v132[0])) {
        goto LABEL_120;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_119;
    }

    char v29 = (char *)__nw_create_backtrace_string();
    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = v132[0];
    BOOL v34 = os_log_type_enabled(v24, (os_log_type_t)v132[0]);
    if (!v29)
    {
      if (!v34) {
        goto LABEL_120;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null completion, no backtrace";
      goto LABEL_119;
    }

    if (!v34) {
      goto LABEL_72;
    }
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "operator()";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v29;
    id v31 = "%{public}s called with null completion, dumping backtrace:%{public}s";
LABEL_71:
    _os_log_impl(&dword_181A5C000, v24, v25, v31, buf, 0x16u);
    goto LABEL_72;
  }

  id v8 = nw_http_metadata_copy_response(a3);
  if (v8)
  {
    id v9 = v8;
    int status_code = _nw_http_response_get_status_code();

    if (status_code != 101 && (status_code - 100) <= 0x63)
    {
      (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1LL, a3);
LABEL_233:
      os_release(v9);
      return;
    }

    parameters = (void *)nw_protocol_get_parameters(*(void *)(v5 + 48));
    if (parameters) {
      uint64_t v12 = os_retain(parameters);
    }
    else {
      uint64_t v12 = 0LL;
    }
    uint64_t v119 = nw_parameters_copy_protocol_options_legacy(v12, (nw_protocol *)v5);
    id v13 = nw_http_cookie_options_copy_cookie_storage(v119);
    id v14 = nw_parameters_copy_url_endpoint(v12);
    char v118 = v13;
    if (!v13)
    {
LABEL_19:
      (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1LL, a3);
      if (!v14)
      {
        BOOL v21 = v118;
        char v22 = v119;
        if (!v118)
        {
LABEL_229:
          if (!v22) {
            goto LABEL_231;
          }
          goto LABEL_230;
        }

void sub_181EC35F8(_Unwind_Exception *a1)
{
}

void nw_protocol_http_cookie_create::$_2::__invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  v111[4] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v107[0] = 0;
    if (type[0] == 17)
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null protocol";
    }

    else if (v107[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      BOOL v32 = os_log_type_enabled(v24, (os_log_type_t)type[0]);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "operator()";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_117:
        if (!v23) {
          return;
        }
        goto LABEL_118;
      }

      if (!v32) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_116;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v107[0] = 0;
    if (type[0] != 17)
    {
      if (!v107[0])
      {
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type[0];
        if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
          goto LABEL_117;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null http_cookie, backtrace limit exceeded";
        goto LABEL_116;
      }

      BOOL v33 = (char *)__nw_create_backtrace_string();
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      BOOL v34 = os_log_type_enabled(v24, (os_log_type_t)type[0]);
      if (!v33)
      {
        if (!v34) {
          goto LABEL_117;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        __int16 v26 = "%{public}s called with null http_cookie, no backtrace";
        goto LABEL_116;
      }

      if (!v34) {
        goto LABEL_70;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v33;
      BOOL v35 = "%{public}s called with null http_cookie, dumping backtrace:%{public}s";
      goto LABEL_69;
    }

    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
      goto LABEL_117;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    __int16 v26 = "%{public}s called with null http_cookie";
LABEL_116:
    _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
    goto LABEL_117;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v107[0] = 0;
    if (type[0] == 17)
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null metadata";
      goto LABEL_116;
    }

    if (!v107[0])
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_116;
    }

    BOOL v33 = (char *)__nw_create_backtrace_string();
    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v36 = os_log_type_enabled(v24, (os_log_type_t)type[0]);
    if (!v33)
    {
      if (!v36) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_116;
    }

    if (!v36) {
      goto LABEL_70;
    }
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "operator()";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v33;
    BOOL v35 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_69:
    _os_log_impl(&dword_181A5C000, v24, v25, v35, buf, 0x16u);
    goto LABEL_70;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v107[0] = 0;
    if (type[0] == 17)
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null completion";
      goto LABEL_116;
    }

    if (!v107[0])
    {
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, (os_log_type_t)type[0])) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_116;
    }

    BOOL v33 = (char *)__nw_create_backtrace_string();
    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v37 = os_log_type_enabled(v24, (os_log_type_t)type[0]);
    if (!v33)
    {
      if (!v37) {
        goto LABEL_117;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      __int16 v26 = "%{public}s called with null completion, no backtrace";
      goto LABEL_116;
    }

    if (v37)
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v33;
      BOOL v35 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_69;
    }

void sub_181EC4CEC(_Unwind_Exception *a1)
{
}

uint64_t __Block_byref_object_copy__15685(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 208), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__15686(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZZ30nw_protocol_http_cookie_createENK3__2clEP11nw_protocolS1_P20nw_protocol_metadatabU13block_pointerFv46nw_protocol_plugin_metadata_processor_result_tS3_E_block_invoke( uint64_t a1, char *__s, const char *a3)
{
  if (__s)
  {
    size_t v6 = strlen(__s);
    std::string::append(&v13, __s, v6);
    std::string::append(&v13, "=", 1uLL);
    if (a3)
    {
      size_t v7 = strlen(a3);
      std::string::append(&v13, a3, v7);
    }

    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v9 = *(void *)(v8 + 24);
    signed __int8 size = v13.__r_.__value_.__s.__size_;
    if ((char)v13.__r_.__value_.__s.__size_ < 0)
    {
      std::string::size_type v11 = v13.__r_.__value_.__l.__size_;
      if (v13.__r_.__value_.__l.__size_ + v9 > 0x3202A)
      {
LABEL_12:
        operator delete(v13.__r_.__value_.__l.__data_);
        return;
      }
    }

    else
    {
      std::string::size_type v11 = v13.__r_.__value_.__s.__size_;
    }

    *(void *)(v8 + 24) = v9 + v11 + 2;
    if (size >= 0) {
      uint64_t v12 = &v13;
    }
    else {
      uint64_t v12 = (std::string *)v13.__r_.__value_.__r.__words[0];
    }
    nw_http_fields_append_advanced( *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL),  (unint64_t)"Cookie",  -1LL,  (char *)v12,  0xFFFFFFFFFFFFFFFFLL,  &__block_literal_global_15_15695);
  }

uint64_t ___ZZ30nw_protocol_http_cookie_createENK3__2clEP11nw_protocolS1_P20nw_protocol_metadatabU13block_pointerFv46nw_protocol_plugin_metadata_processor_result_tS3_E_block_invoke_2( uint64_t a1, uint64_t a2)
{
  return nw_http_field_set_indexing_strategy(a2, 1u);
}

void ___ZL37nw_protocol_http_cookie_get_callbacksv_block_invoke()
{
  qword_18C5A2E18 = (uint64_t)nw_protocol_common_get_input_frames;
  unk_18C5A2E20 = nw_protocol_common_get_output_frames;
  qword_18C5A2E38 = (uint64_t)nw_protocol_common_get_parameters;
  unk_18C5A2E40 = nw_protocol_common_get_path;
  qword_18C5A2E48 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_18C5A2E50 = nw_protocol_common_get_remote_endpoint;
  qword_18C5A2DD8 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_18C5A2DE0 = nw_protocol_common_connect;
  qword_18C5A2DE8 = (uint64_t)nw_protocol_common_disconnect;
  unk_18C5A2DF0 = nw_protocol_common_connected;
  qword_18C5A2E08 = (uint64_t)nw_protocol_common_input_available;
  unk_18C5A2E10 = nw_protocol_common_output_available;
  qword_18C5A2E88 = (uint64_t)nw_protocol_common_output_finished;
  unk_18C5A2E90 = nw_protocol_common_get_output_local_endpoint;
  qword_18C5A2ED0 = (uint64_t)nw_protocol_common_input_flush;
  qword_18C5A2DF8 = (uint64_t)nw_protocol_common_disconnected;
  unk_18C5A2E00 = nw_protocol_common_error;
  qword_18C5A2EC0 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_18C5A2EC8 = nw_protocol_common_reset;
  qword_18C5A2EA8 = (uint64_t)nw_protocol_common_copy_info;
  qword_18C5A2E78 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_18C5A2E80 = nw_protocol_common_input_finished;
  qword_18C5A2E98 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_18C5A2EA0 = nw_protocol_common_waiting_for_output;
  qword_18C5A2E58 = (uint64_t)nw_protocol_common_register_notification;
  unk_18C5A2E60 = nw_protocol_common_unregister_notification;
  qword_18C5A2E68 = (uint64_t)nw_protocol_common_notify;
  unk_18C5A2E70 = nw_protocol_common_updated_path;
  qword_18C5A2E28 = (uint64_t)nw_protocol_common_finalize_output_frames;
  unk_18C5A2E30 = nw_protocol_common_link_state;
  nw_protocol_http_cookie_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  unk_18C5A2DD0 = nw_protocol_http_cookie_remove_input_handler;
}

uint64_t nw_protocol_http_cookie_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      if (!os_log_type_enabled(v9, v22)) {
        goto LABEL_49;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
      std::string::size_type v11 = "%{public}s called with null protocol";
LABEL_48:
      _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      goto LABEL_49;
    }

    if (!v21)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      if (os_log_type_enabled(v9, v22))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
        std::string::size_type v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v22;
    BOOL v14 = os_log_type_enabled(v9, v22);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
        std::string::size_type v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (!v14) {
      goto LABEL_35;
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
    __int16 v25 = 2082;
    __int16 v26 = backtrace_string;
    id v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v9, v10, v15, buf, 0x16u);
    goto LABEL_35;
  }

  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      if (!os_log_type_enabled(v9, v22)) {
        goto LABEL_49;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
      std::string::size_type v11 = "%{public}s called with null http_cookie";
      goto LABEL_48;
    }

    if (!v21)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      if (os_log_type_enabled(v9, v22))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
        std::string::size_type v11 = "%{public}s called with null http_cookie, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v22;
    BOOL v16 = os_log_type_enabled(v9, v22);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
        std::string::size_type v11 = "%{public}s called with null http_cookie, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (!v16) {
      goto LABEL_35;
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
    __int16 v25 = 2082;
    __int16 v26 = backtrace_string;
    id v15 = "%{public}s called with null http_cookie, dumping backtrace:%{public}s";
    goto LABEL_34;
  }

  if (a2)
  {
    if ((handle[198] & 1) == 0 && gLogDatapath)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
        __int16 v25 = 2082;
        __int16 v26 = handle + 114;
        __int16 v27 = 2080;
        BOOL v28 = " ";
        _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }

    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 0x40000000LL;
    v20[2] = ___ZL44nw_protocol_http_cookie_remove_input_handlerP11nw_protocolS0_b_block_invoke;
    v20[3] = &__block_descriptor_tmp_20_15756;
    v20[4] = handle;
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 0x40000000LL;
    v18[2] = ___ZL44nw_protocol_http_cookie_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
    v18[3] = &__block_descriptor_tmp_21_15757;
    char v19 = a3;
    v18[4] = a1;
    v18[5] = handle;
    return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v20, (uint64_t)v18);
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v22 = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (v22 != OS_LOG_TYPE_FAULT)
  {
    if (!v21)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      if (os_log_type_enabled(v9, v22))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
        std::string::size_type v11 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v22;
    BOOL v17 = os_log_type_enabled(v9, v22);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
        std::string::size_type v11 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_49;
    }

    if (v17)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v24 = "nw_protocol_http_cookie_remove_input_handler";
      __int16 v25 = 2082;
      __int16 v26 = backtrace_string;
      id v15 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

void ___ZL44nw_protocol_http_cookie_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (gLogDatapath)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v3 = 136446210;
      os_log_type_t v4 = "nw_protocol_plugin_metadata_teardown";
      _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v3, 0xCu);
    }
  }

  nw_protocol_plugin_metadata_reset((uint64_t *)(v1 + 200));
  *(void *)(v1 + 32_Block_object_dispose((const void *)(v1 - 208), 8) = 0LL;
}

void ___ZL44nw_protocol_http_cookie_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!*(_BYTE *)(a1 + 48)) {
    return;
  }
  *(void *)(*(void *)(a1 + 32) + 40LL) = 0LL;
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 288) & 1) != 0)
    {
      id v2 = *(void **)(v1 + 280);
      if (v2) {
        os_release(v2);
      }
    }

    *(void *)(v1 + 280) = 0LL;
    if ((*(_BYTE *)(v1 + 272) & 1) != 0)
    {
      int v3 = *(void **)(v1 + 264);
      if (v3) {
        os_release(v3);
      }
    }

    *(void *)(v1 + 264) = 0LL;
    if ((*(_BYTE *)(v1 + 256) & 1) != 0)
    {
      os_log_type_t v4 = *(void **)(v1 + 248);
      if (v4) {
        os_release(v4);
      }
    }

    free((void *)v1);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v14 = "nw_protocol_http_cookie_destroy";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_protocol_http_cookie_destroy";
      uint64_t v8 = "%{public}s called with null http_cookie";
      goto LABEL_26;
    }

    if (!v11)
    {
      size_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_protocol_http_cookie_destroy";
      uint64_t v8 = "%{public}s called with null http_cookie, backtrace limit exceeded";
      goto LABEL_26;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v14 = "nw_protocol_http_cookie_destroy";
        __int16 v15 = 2082;
        BOOL v16 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_27;
    }

    if (v10)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_protocol_http_cookie_destroy";
      uint64_t v8 = "%{public}s called with null http_cookie, no backtrace";
LABEL_26:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    }
  }

double __nw_protocol_http_cookie_identifier_block_invoke()
{
  *(void *)&double result = 0x100000005LL;
  qword_18C5A2DB8 = 0x100000005LL;
  return result;
}

void sub_181EC6E70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181EC7A8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181EC8120( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_socks5_connection;
  -[_Unwind_Exception dealloc](&a14, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_socks5_connection_remove_prefer_wifi_request(NWConcrete_nw_socks5_connection *a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if (v1->sc_prefer_wifi_path_evaluator)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136446466;
      uint64_t v5 = "nw_socks5_connection_remove_prefer_wifi_request";
      __int16 v6 = 2112;
      os_log_type_t v7 = v1;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ removing prefer wi-fi request",  (uint8_t *)&v4,  0x16u);
    }

    nw_path_evaluator_cancel(v1->sc_prefer_wifi_path_evaluator);
    sc_prefer_wifi_path_evaluator = v1->sc_prefer_wifi_path_evaluator;
    v1->sc_prefer_wifi_path_evaluator = 0LL;
  }
}

void sub_181EC82E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_socks5_connection_validate_udp_association_block_invoke_2(id *a1)
{
  uint64_t v49 = 0LL;
  BOOL v50 = &v49;
  uint64_t v51 = 0x2020000000LL;
  char v52 = 0;
  id v2 = a1[4];
  if (*((unsigned __int8 *)v2 + 56) != 255 && (char)v2[20] < 0)
  {
    BOOL v20 = (void *)v2[4];
    if (v20)
    {
      char v21 = v20;
      uint64_t v59 = 0LL;
      BOOL v60 = &v59;
      uint64_t v61 = 0x2020000000LL;
      char v62 = 0;
      os_log_type_t v22 = (void *)MEMORY[0x1895F87A8];
      os_log_type_t v23 = v21 + 34;
      id location = (id)MEMORY[0x1895F87A8];
      uint64_t v54 = 3221225472LL;
      os_log_type_t v55 = __nw_connection_is_cancelled_or_failed_block_invoke;
      char v56 = &unk_189BC9210;
      id v58 = &v59;
      BOOL v24 = v21;
      id v57 = v24;
      os_unfair_lock_lock(v23);
      v55((uint64_t)&location);
      os_unfair_lock_unlock(v23);
      LODWORD(v23) = *((unsigned __int8 *)v60 + 24);

      _Block_object_dispose(&v59, 8);
      if (!(_DWORD)v23)
      {
        id v25 = *((id *)a1[4] + 21);
        __int16 v26 = v25;
        if (v25)
        {
          __int16 v27 = (os_unfair_lock_s *)v25;
          uint64_t v59 = 0LL;
          BOOL v60 = &v59;
          uint64_t v61 = 0x2020000000LL;
          char v62 = 0;
          BOOL v28 = v27 + 34;
          id location = v22;
          uint64_t v54 = 3221225472LL;
          os_log_type_t v55 = __nw_connection_is_cancelled_or_failed_block_invoke;
          char v56 = &unk_189BC9210;
          id v58 = &v59;
          uint64_t v29 = v27;
          id v57 = v29;
          os_unfair_lock_lock(v28);
          __nw_connection_is_cancelled_or_failed_block_invoke((uint64_t)&location);
          os_unfair_lock_unlock(v28);
          LODWORD(v2_Block_object_dispose((const void *)(v1 - 208), 8) = *((unsigned __int8 *)v60 + 24);

          _Block_object_dispose(&v59, 8);
          if (!(_DWORD)v28) {
            *((_BYTE *)v50 + 24) = 1;
          }
        }
      }
    }
  }

  if (*((_BYTE *)v50 + 24))
  {
    int v3 = (nw_connection *)*((id *)a1[4] + 21);
    int v4 = (nw_protocol_definition *)(id)g_tcp_definition;
    nw_protocol_metadata_t v5 = nw_connection_copy_protocol_metadata(v3, v4);

    if (v5)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      id v6 = (id)nw_context_copy_implicit_context::implicit_context;
      v43[0] = MEMORY[0x1895F87A8];
      v43[1] = 3221225472LL;
      v43[2] = __nw_socks5_connection_validate_udp_association_block_invoke_4;
      v43[3] = &unk_189BC6E60;
      id v44 = a1[4];
      BOOL v45 = v3;
      os_log_type_t v46 = v5;
      nw_queue_context_async_if_needed(v6, v43);
    }

    objc_initWeak(&location, a1[4]);
    id v8 = *((id *)a1[4] + 5);
    ++*((_DWORD *)a1[4] + 22);
    uint64_t v9 = a1[4];
    uint64_t v10 = v9[10];
    if (v10)
    {
      nw_queue_cancel_source(v10, v7);
      *((void *)a1[4] + 10) = 0LL;
      uint64_t v9 = a1[4];
    }

    int v11 = *((_DWORD *)v9 + 22);
    uint64_t v12 = MEMORY[0x1895F87A8];
    v38[0] = MEMORY[0x1895F87A8];
    v38[1] = 3221225472LL;
    v38[2] = __nw_socks5_connection_validate_udp_association_block_invoke_6;
    v38[3] = &unk_189BB8170;
    objc_copyWeak(&v42, &location);
    id v39 = a1[5];
    id v41 = a1[6];
    id v13 = v8;
    id v40 = v13;
    v30[0] = v12;
    v30[1] = 3221225472LL;
    v30[2] = __nw_socks5_connection_validate_udp_association_block_invoke_4_9;
    v30[3] = &unk_189BB81C0;
    objc_copyWeak(&v36, &location);
    id v31 = a1[5];
    id v34 = a1[6];
    id v14 = v13;
    id v32 = v14;
    BOOL v35 = &v49;
    int v37 = v11;
    __int16 v15 = v3;
    BOOL v33 = v15;
    BOOL source = nw_queue_context_create_source(0LL, 2, 3, 0, v38, v30);
    dispatch_time_t v17 = dispatch_time(0x8000000000000000LL, 5000000000LL);
    nw_queue_set_timer_values(source, v17, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    nw_queue_activate_source(source, v18);
    *((void *)a1[4] + 10) = source;

    objc_destroyWeak(&v36);
    objc_destroyWeak(&v42);

    objc_destroyWeak(&location);
  }

  else
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_socks5_connection_validate_udp_association_block_invoke_3;
    block[3] = &unk_189BC8740;
    char v19 = (dispatch_queue_s *)a1[5];
    os_log_type_t v48 = (nw_connection *)a1[6];
    dispatch_async(v19, block);
    __int16 v15 = v48;
  }

  _Block_object_dispose(&v49, 8);
}

void sub_181EC87EC(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v4 - 176));
  _Block_object_dispose((const void *)(v4 - 208), 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_socks5_connection_validate_udp_association_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __nw_socks5_connection_validate_udp_association_block_invoke_4(uint64_t a1)
{
  v28[2] = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 136446722;
    BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke_4";
    __int16 v25 = 2114;
    uint64_t v26 = v3;
    __int16 v27 = 2114;
    v28[0] = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ enabling keep alives for %{public}@",  buf,  0x20u);
  }

  if (nw_tcp_reset_keepalives(*(void **)(a1 + 48), 1, 5, 1, 1))
  {
    int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
    __int16 v25 = 2114;
    uint64_t v26 = v7;
    __int16 v27 = 1024;
    LODWORD(v28[0]) = v5;
    id v8 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault((const char *)v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_20;
        }
        uint64_t v11 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v11;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        uint64_t v12 = "%{public}s %{public}@ error enabling keep alives %{darwin.errno}d";
LABEL_18:
        uint64_t v18 = v9;
        os_log_type_t v19 = v10;
        goto LABEL_19;
      }

      if (!v21)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_20;
        }
        uint64_t v17 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v17;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        uint64_t v12 = "%{public}s %{public}@ error enabling keep alives %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_18;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_20:

          if (!v8) {
            return;
          }
LABEL_14:
          free(v8);
          return;
        }

        uint64_t v20 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v20;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        uint64_t v12 = "%{public}s %{public}@ error enabling keep alives %{darwin.errno}d, no backtrace";
        uint64_t v18 = v9;
        os_log_type_t v19 = v14;
LABEL_19:
        _os_log_impl(&dword_181A5C000, v18, v19, v12, buf, 0x1Cu);
        goto LABEL_20;
      }

      if (v15)
      {
        uint64_t v16 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446978;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v16;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        WORD2(v28[0]) = 2082;
        *(void *)((char *)v28 + 6) = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s %{public}@ error enabling keep alives %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
      }

      free(backtrace_string);
    }

    if (!v8) {
      return;
    }
    goto LABEL_14;
  }

void __nw_socks5_connection_validate_udp_association_block_invoke_6(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a1 + 40);
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = __nw_socks5_connection_validate_udp_association_block_invoke_3_8;
    v9[3] = &unk_189BC93A0;
    int v5 = &v10;
    id v10 = WeakRetained;
    id v6 = v9;
    uint64_t v7 = v4;
  }

  else
  {
    id v8 = *(dispatch_queue_s **)(a1 + 32);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_socks5_connection_validate_udp_association_block_invoke_2_7;
    block[3] = &unk_189BC8740;
    int v5 = &v12;
    id v12 = *(id *)(a1 + 48);
    id v6 = block;
    uint64_t v7 = v8;
  }

  dispatch_async(v7, v6);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  os_unfair_lock_s *v5;
  os_unfair_lock_s *v6;
  char *v7;
  nw_connection *v8;
  nw_protocol_definition *v9;
  nw_protocol_metadata_t v10;
  id v11;
  nw_protocol_metadata *v12;
  dispatch_queue_s *v13;
  id v14;
  uint64_t v15;
  void block[4];
  id v17;
  uint64_t v18;
  void v19[4];
  id v20;
  id v21;
  nw_protocol_metadata *v22;
  void v23[4];
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 0;
  id v2 = *(void *)(a1 + 32);
  uint64_t v3 = MEMORY[0x1895F87A8];
  if (*(unsigned __int8 *)(v2 + 56) != 255 && *(_DWORD *)(a1 + 72) == *(_DWORD *)(v2 + 88))
  {
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4)
    {
      int v5 = v4;
      uint64_t v26 = 0LL;
      __int16 v27 = &v26;
      BOOL v28 = 0x2020000000LL;
      uint64_t v29 = 0;
      id v6 = v5 + 34;
      v23[0] = v3;
      v23[1] = 3221225472LL;
      void v23[2] = __nw_connection_is_cancelled_or_failed_block_invoke;
      v23[3] = &unk_189BC9210;
      __int16 v25 = &v26;
      uint64_t v7 = v5;
      BOOL v24 = v7;
      os_unfair_lock_lock(v6);
      __nw_connection_is_cancelled_or_failed_block_invoke((uint64_t)v23);
      os_unfair_lock_unlock(v6);
      LODWORD(v6) = *((unsigned __int8 *)v27 + 24);

      _Block_object_dispose(&v26, 8);
      if (!(_DWORD)v6)
      {
        id v8 = *(nw_connection **)(a1 + 40);
        uint64_t v9 = (nw_protocol_definition *)(id)g_tcp_definition;
        id v10 = nw_connection_copy_protocol_metadata(v8, v9);

        if (nw_context_copy_implicit_context::onceToken != -1) {
          dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
        }
        uint64_t v11 = (id)nw_context_copy_implicit_context::implicit_context;
        v19[0] = v3;
        v19[1] = 3221225472LL;
        v19[2] = __nw_socks5_connection_validate_udp_association_block_invoke_7;
        v19[3] = &unk_189BC6E60;
        uint64_t v20 = *(id *)(a1 + 32);
        char v21 = *(id *)(a1 + 40);
        id v12 = v10;
        os_log_type_t v22 = v12;
        nw_queue_context_async_if_needed(v11, v19);

        *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 1;
      }
    }
  }

  block[0] = v3;
  block[1] = 3221225472LL;
  block[2] = __nw_socks5_connection_validate_udp_association_block_invoke_10;
  block[3] = &unk_189BBF570;
  id v13 = *(dispatch_queue_s **)(a1 + 48);
  os_log_type_t v14 = *(id *)(a1 + 56);
  BOOL v15 = *(void *)(a1 + 64);
  uint64_t v17 = v14;
  uint64_t v18 = v15;
  dispatch_async(v13, block);
}

void __nw_socks5_connection_validate_udp_association_block_invoke_4_9(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a1 + 40);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_socks5_connection_validate_udp_association_block_invoke_6;
    block[3] = &unk_189BB8198;
    uint64_t v12 = *(void *)(a1 + 64);
    int v5 = &v8;
    id v8 = WeakRetained;
    int v13 = *(_DWORD *)(a1 + 80);
    id v9 = *(id *)(a1 + 48);
    id v10 = *(id *)(a1 + 32);
    id v11 = *(id *)(a1 + 56);
    dispatch_async(v4, block);
  }

  else
  {
    id v6 = *(dispatch_queue_s **)(a1 + 32);
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_socks5_connection_validate_udp_association_block_invoke_5;
    v14[3] = &unk_189BC8740;
    int v5 = &v15;
    id v15 = *(id *)(a1 + 56);
    dispatch_async(v6, v14);
  }
}

uint64_t __nw_socks5_connection_validate_udp_association_block_invoke_5(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_181EC9110( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, void *a22)
{
  _Unwind_Resume(a1);
}

void sub_181EC913C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_socks5_connection_validate_udp_association_block_invoke_7(uint64_t a1)
{
  v28[2] = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 136446722;
    BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke_7";
    __int16 v25 = 2114;
    uint64_t v26 = v3;
    __int16 v27 = 2114;
    v28[0] = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ disabling keep alives for %{public}@",  buf,  0x20u);
  }

  if (nw_tcp_reset_keepalives(*(void **)(a1 + 48), 0, 0, 0, 0))
  {
    int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
    __int16 v25 = 2114;
    uint64_t v26 = v7;
    __int16 v27 = 1024;
    LODWORD(v28[0]) = v5;
    id v8 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault((const char *)v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_20;
        }
        uint64_t v11 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v11;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        uint64_t v12 = "%{public}s %{public}@ error disabling keep alives %{darwin.errno}d";
LABEL_18:
        uint64_t v18 = v9;
        os_log_type_t v19 = v10;
        goto LABEL_19;
      }

      if (!v21)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_20;
        }
        uint64_t v17 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v17;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        uint64_t v12 = "%{public}s %{public}@ error disabling keep alives %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_18;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_20:

          if (!v8) {
            return;
          }
LABEL_14:
          free(v8);
          return;
        }

        uint64_t v20 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v20;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        uint64_t v12 = "%{public}s %{public}@ error disabling keep alives %{darwin.errno}d, no backtrace";
        uint64_t v18 = v9;
        os_log_type_t v19 = v14;
LABEL_19:
        _os_log_impl(&dword_181A5C000, v18, v19, v12, buf, 0x1Cu);
        goto LABEL_20;
      }

      if (v15)
      {
        uint64_t v16 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446978;
        BOOL v24 = "nw_socks5_connection_validate_udp_association_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v16;
        __int16 v27 = 1024;
        LODWORD(v28[0]) = v5;
        WORD2(v28[0]) = 2082;
        *(void *)((char *)v28 + 6) = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s %{public}@ error disabling keep alives %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
      }

      free(backtrace_string);
    }

    if (!v8) {
      return;
    }
    goto LABEL_14;
  }

uint64_t __nw_socks5_connection_validate_udp_association_block_invoke_10(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
}

uint64_t __nw_socks5_connection_validate_udp_association_block_invoke_2_7(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __nw_socks5_connection_validate_udp_association_block_invoke_3_8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 80LL);
  if (v3)
  {
    nw_queue_cancel_source(v3, a2);
    *(void *)(*(void *)(a1 + 32) + 80LL) = 0LL;
  }

void __nw_socks5_connection_set_cancel_handler_block_invoke(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 48);
  *(void *)(v3 + 4_Block_object_dispose((const void *)(v1 - 208), 8) = v2;
}

void __nw_socks5_connection_start_block_invoke(uint64_t a1)
{
}

void nw_socks5_connection_start_on_queue(void *a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a1;
  id v5 = a2;
  nw_connection_t v6 = v4[4];
  uint64_t v7 = MEMORY[0x1895F87A8];
  v18[0] = MEMORY[0x1895F87A8];
  v18[1] = 3221225472LL;
  v18[2] = ___ZL35nw_socks5_connection_start_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  v18[3] = &unk_189BC93A0;
  id v8 = v4;
  os_log_type_t v19 = v8;
  nw_connection_set_read_close_handler(v6, v18);
  id v9 = v4[4];
  handler[0] = v7;
  handler[1] = 3221225472LL;
  handler[2] = ___ZL35nw_socks5_connection_start_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObject_block_invoke_139;
  handler[3] = &unk_189BC9490;
  os_log_type_t v10 = v8;
  uint64_t v16 = v10;
  id v11 = v5;
  id v17 = v11;
  nw_connection_set_state_changed_handler(v9, handler);
  nw_connection_set_queue(v4[4], (dispatch_queue_t)v10[5]);
  nw_connection_start(v4[4]);
  uint64_t v12 = mach_continuous_time();
  if (v12 <= 1) {
    uint64_t v13 = 1LL;
  }
  else {
    uint64_t v13 = v12;
  }
  v10[17] = (nw_connection_t)v13;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v14 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 136446466;
    char v21 = "nw_socks5_connection_start_on_queue";
    __int16 v22 = 2114;
    os_log_type_t v23 = v10;
    _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}@ started connection", buf, 0x16u);
  }

  if (!v10[2]) {
    objc_storeStrong((id *)v10 + 2, a1);
  }
}

void sub_181EC97B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void ___ZL35nw_socks5_connection_start_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObject_block_invoke( uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(v2 + 56);
  if (v3 != 200)
  {
    if (v3 == 255) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    uint64_t v5 = *(void *)(a1 + 32);
    int v11 = 136446466;
    uint64_t v12 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v13 = 2114;
    uint64_t v14 = v5;
    nw_connection_t v6 = "%{public}s %{public}@ in connection read close before proxy connection ready, cancelling";
    goto LABEL_11;
  }

  int v7 = *(char *)(v2 + 160);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v4 = (os_log_s *)(id)gLogObj;
  BOOL v8 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v7 < 0)
  {
    if (!v8)
    {
LABEL_12:

      nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
      return;
    }

    uint64_t v10 = *(void *)(a1 + 32);
    int v11 = 136446466;
    uint64_t v12 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v13 = 2114;
    uint64_t v14 = v10;
    nw_connection_t v6 = "%{public}s %{public}@ in connection read close for associated UDP connection, cancelling";
LABEL_11:
    _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v11, 0x16u);
    goto LABEL_12;
  }

  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    int v11 = 136446466;
    uint64_t v12 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v13 = 2114;
    uint64_t v14 = v9;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ ignoring in connection read close event",  (uint8_t *)&v11,  0x16u);
  }
}

void ___ZL35nw_socks5_connection_start_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObject_block_invoke_139( uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  nw_connection_t v6 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5) {
      int v7 = "unknown";
    }
    else {
      int v7 = off_189BB9C00[a2];
    }
    uint64_t v8 = *(void *)(a1 + 32);
    int v25 = 136446722;
    uint64_t v26 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v27 = 2114;
    uint64_t v28 = v8;
    __int16 v29 = 2082;
    BOOL v30 = v7;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ in connection event %{public}s",  (uint8_t *)&v25,  0x20u);
  }

  if (a2 == 4)
  {
    nw_socks5_connection_remove_prefer_wifi_request(*(NWConcrete_nw_socks5_connection **)(a1 + 32));
    *(_BYTE *)(*(void *)(a1 + 32) + 160LL) |= 2u;
    uint64_t v9 = *(unsigned __int8 **)(a1 + 32);
    if ((~v9[160] & 3) == 0)
    {
      nw_socks5_connection_cancel_on_queue(v9, 0LL);
      goto LABEL_34;
    }

    if (!v5) {
      goto LABEL_34;
    }
    goto LABEL_13;
  }

  if (v5)
  {
    uint64_t v9 = *(unsigned __int8 **)(a1 + 32);
LABEL_13:
    int v10 = v9[56];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = (os_log_s *)(id)gLogObj;
    uint64_t v12 = v11;
    if (v10 == 200)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        int v25 = 136446722;
        uint64_t v26 = "nw_socks5_connection_start_on_queue_block_invoke";
        __int16 v27 = 2114;
        uint64_t v28 = v13;
        __int16 v29 = 2114;
        BOOL v30 = v5;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ ignoring in connection event error %{public}@",  (uint8_t *)&v25,  0x20u);
      }
    }

    else
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = *(void *)(a1 + 32);
        int v25 = 136446722;
        uint64_t v26 = "nw_socks5_connection_start_on_queue_block_invoke";
        __int16 v27 = 2114;
        uint64_t v28 = v14;
        __int16 v29 = 2114;
        BOOL v30 = v5;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ in connection event error %{public}@",  (uint8_t *)&v25,  0x20u);
      }

      nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), v5);
    }

    goto LABEL_34;
  }

  if (a2 != 3) {
    goto LABEL_34;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  int v16 = *(unsigned __int8 *)(v15 + 56);
  if (v16 != 101)
  {
    if (v16 != 1) {
      goto LABEL_34;
    }
    *(_BYTE *)(v15 + 56) = 2;
    __nwlog_obj();
    id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    uint64_t v18 = *(void *)(a1 + 32);
    int v25 = 136446466;
    uint64_t v26 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v27 = 2114;
    uint64_t v28 = v18;
    os_log_type_t v19 = "%{public}s %{public}@ connection socks connected";
    goto LABEL_27;
  }

  *(_BYTE *)(v15 + 56) = 102;
  __nwlog_obj();
  id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    uint64_t v20 = *(void *)(a1 + 32);
    int v25 = 136446466;
    uint64_t v26 = "nw_socks5_connection_start_on_queue_block_invoke";
    __int16 v27 = 2114;
    uint64_t v28 = v20;
    os_log_type_t v19 = "%{public}s %{public}@ connection shoes connected";
LABEL_27:
    _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_INFO, v19, (uint8_t *)&v25, 0x16u);
  }

void sub_181EC9E04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_socks5_connection_cancel_on_queue(void *a1, void *a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  int v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3[56] != 255)
  {
    if (v4 && !*((void *)v3 + 19)) {
      objc_storeStrong((id *)v3 + 19, a2);
    }
    uint64_t v6 = *((void *)v3 + 17);
    if (v6)
    {
      uint64_t v7 = mach_continuous_time();
      if (v7 <= 1) {
        uint64_t v8 = 1LL;
      }
      else {
        uint64_t v8 = v7;
      }
      double v9 = (double)(unint64_t)nw_delta_nanos(v6, v8) * 0.000000001;
    }

    else
    {
      double v9 = 0.0;
    }

    unint64_t v10 = *((void *)v3 + 16);
    if (*((void *)v3 + 14))
    {
      uint64_t v11 = *((void *)v3 + 15);
      if (v11)
      {
        uint64_t v12 = mach_continuous_time();
        if (v12 <= 1) {
          uint64_t v13 = 1LL;
        }
        else {
          uint64_t v13 = v12;
        }
        v10 += nw_delta_nanos(v11, v13);
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *((void *)v3 + 23);
      uint64_t v16 = *((void *)v3 + 24);
      uint64_t v17 = *((void *)v3 + 25);
      uint64_t v18 = *((void *)v3 + 26);
      uint64_t v19 = *((void *)v3 + 19);
      uint64_t v20 = *((void *)v3 + 14);
      *(_DWORD *)__int128 buf = 136448514;
      __int16 v27 = "nw_socks5_connection_cancel_on_queue";
      __int16 v28 = 2114;
      __int16 v29 = v3;
      __int16 v30 = 2048;
      uint64_t v31 = v15;
      __int16 v32 = 2048;
      uint64_t v33 = v16;
      __int16 v34 = 2048;
      uint64_t v35 = v17;
      __int16 v36 = 2048;
      uint64_t v37 = v18;
      __int16 v38 = 2048;
      double v39 = (double)v10 * 0.000000001;
      __int16 v40 = 2048;
      double v41 = v9;
      __int16 v42 = 2114;
      uint64_t v43 = v19;
      __int16 v44 = 2048;
      uint64_t v45 = v20;
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ outRead %llu, outWrite %llu, inRead %llu, inWrite %llu, busyTime %0.3fs, totalTime %0.3fs, error %{public}@, busyCount %llu",  buf,  0x66u);
    }

    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    v24[2] = ___ZL36nw_socks5_connection_cancel_on_queueP31NWConcrete_nw_socks5_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke;
    v24[3] = &unk_189BBBDE8;
    uint64_t v21 = v3;
    int v25 = v21;
    nw_socks5_connection_send_reply_on_queue(v21, 0, v24);
    v3[56] = -1;
    uint64_t v23 = *((void *)v21 + 10);
    if (v23)
    {
      nw_queue_cancel_source(v23, v22);
      *((void *)v21 + 10) = 0LL;
    }
  }
}

void sub_181ECA064( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_socks5_connection_inner_connection_read_handler_on_queue( void *a1, void *a2, int a3, int a4, size_t a5)
{
  uint64_t v187 = *MEMORY[0x1895F89C0];
  double v9 = a1;
  unint64_t v10 = a2;
  uint64_t v11 = v10;
  if (v9[56] == 255 || (v9[160] & 1) != 0) {
    goto LABEL_103;
  }
  if (v10) {
    size_t size = dispatch_data_get_size(v10);
  }
  else {
    size_t size = 0LL;
  }
  id WeakRetained = objc_loadWeakRetained((id *)v9 + 3);
  if (a4 || size < a5)
  {
    if (!a4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        uint64_t v23 = "not";
        *(_DWORD *)__int128 buf = 136447234;
        *(void *)&buf[14] = v9;
        if (a3) {
          uint64_t v23 = "is";
        }
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&_BYTE buf[24] = size;
        *(_WORD *)&buf[32] = 2048;
        *(void *)&buf[34] = a5;
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v23;
        _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ in connection read data len %zu < %zu %{public}s_complete",  buf,  0x34u);
      }

      goto LABEL_34;
    }

    if (a4 == 55 && (char)v9[160] < 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v21 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v9;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&_BYTE buf[24] = 55;
        _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ ignoring error %d", buf, 0x1Cu);
      }

      nw_socks5_connection_inner_connection_read_on_queue((NWConcrete_nw_socks5_connection *)v9);
      goto LABEL_102;
    }

    switch(a4)
    {
      case 6:
      case 32:
      case 49:
      case 50:
      case 51:
      case 53:
      case 54:
      case 57:
      case 60:
      case 61:
      case 65:
      case 96:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v24 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          int v25 = "not";
          *(_DWORD *)__int128 buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          if (a3) {
            int v25 = "is";
          }
          *(_WORD *)&_BYTE buf[22] = 2048;
          *(void *)&_BYTE buf[24] = size;
          *(_WORD *)&buf[32] = 2082;
          *(void *)&buf[34] = v25;
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = a4;
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ in connection read error (data len %zu) %{public}s_complete %{darwin.errno}d",  buf,  0x30u);
        }

        goto LABEL_34;
      default:
        __nwlog_obj();
        char v62 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)__int128 buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&buf[14] = v9;
        if (a3) {
          uint64_t v63 = "is";
        }
        else {
          uint64_t v63 = "not";
        }
        *(void *)&_BYTE buf[24] = size;
        *(_WORD *)&buf[32] = 2082;
        *(void *)&buf[34] = v63;
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = a4;
        BOOL v64 = (char *)_os_log_send_and_compose_impl();

        type[0].os_log_type_t sa_len = 16;
        __str[0] = 0;
        if (type[0].sa_len == 17)
        {
          __nwlog_obj();
          BOOL v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t sa_len = type[0].sa_len;
          if (os_log_type_enabled(v65, (os_log_type_t)type[0].sa_len))
          {
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
            *(_WORD *)&_BYTE buf[12] = 2114;
            *(void *)&buf[14] = v9;
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(void *)&_BYTE buf[24] = size;
            *(_WORD *)&buf[32] = 2082;
            *(void *)&buf[34] = v63;
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = a4;
            _os_log_impl( &dword_181A5C000,  v65,  sa_len,  "%{public}s %{public}@ in connection read error (data len %zu) %{public}s_complete %{darwin.errno}d",  buf,  0x30u);
          }
        }

        else if (__str[0])
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v145 = type[0].sa_len;
          BOOL v78 = os_log_type_enabled(v65, (os_log_type_t)type[0].sa_len);
          if (backtrace_string)
          {
            if (v78)
            {
              *(_DWORD *)__int128 buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&_BYTE buf[12] = 2114;
              *(void *)&buf[14] = v9;
              *(_WORD *)&_BYTE buf[22] = 2048;
              *(void *)&_BYTE buf[24] = size;
              *(_WORD *)&buf[32] = 2082;
              *(void *)&buf[34] = v63;
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = a4;
              *(_WORD *)&buf[48] = 2082;
              *(void *)&buf[50] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v65,  v145,  "%{public}s %{public}@ in connection read error (data len %zu) %{public}s_complete %{darwin.errno}d, dump ing backtrace:%{public}s",  buf,  0x3Au);
            }

            free(backtrace_string);
            goto LABEL_212;
          }

          if (v78)
          {
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
            *(_WORD *)&_BYTE buf[12] = 2114;
            *(void *)&buf[14] = v9;
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(void *)&_BYTE buf[24] = size;
            *(_WORD *)&buf[32] = 2082;
            *(void *)&buf[34] = v63;
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = a4;
            _os_log_impl( &dword_181A5C000,  v65,  v145,  "%{public}s %{public}@ in connection read error (data len %zu) %{public}s_complete %{darwin.errno}d, no backtrace",  buf,  0x30u);
          }
        }

        else
        {
          __nwlog_obj();
          BOOL v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v88 = type[0].sa_len;
          if (os_log_type_enabled(v65, (os_log_type_t)type[0].sa_len))
          {
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
            *(_WORD *)&_BYTE buf[12] = 2114;
            *(void *)&buf[14] = v9;
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(void *)&_BYTE buf[24] = size;
            *(_WORD *)&buf[32] = 2082;
            *(void *)&buf[34] = v63;
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = a4;
            _os_log_impl( &dword_181A5C000,  v65,  v88,  "%{public}s %{public}@ in connection read error (data len %zu) %{public}s_complete %{darwin.errno}d, backtr ace limit exceeded",  buf,  0x30u);
          }
        }

LABEL_212:
        if (v64) {
          free(v64);
        }
LABEL_34:
        if (v9[56] != 200)
        {
LABEL_101:
          nw_socks5_connection_cancel_on_queue(v9, 0LL);
          goto LABEL_102;
        }

        nw_socks5_connection_increment_busy_on_queue(v9, WeakRetained);
        uint64_t v26 = (nw_connection *)*((void *)v9 + 18);
        completion[0] = MEMORY[0x1895F87A8];
        completion[1] = 3221225472LL;
        completion[2] = ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke;
        completion[3] = &unk_189BB81E8;
        int v173 = v9;
        id v174 = WeakRetained;
        nw_connection_send(v26, 0LL, (nw_content_context_t)&__block_literal_global_3_41839, 1, completion);

LABEL_102:
LABEL_103:

        return;
    }
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    os_log_type_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v134 = "not";
      *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&buf[14] = v9;
      if (a3) {
        uint64_t v134 = "is";
      }
      *(_WORD *)&_BYTE buf[22] = 2048;
      *(void *)&_BYTE buf[24] = size;
      *(_WORD *)&buf[32] = 2082;
      *(void *)&buf[34] = v134;
      _os_log_impl( &dword_181A5C000,  v133,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ read %zu bytes %{public}s_complete from inner connection",  buf,  0x2Au);
    }
  }

  if (!v11 || !size) {
    goto LABEL_102;
  }
  int v14 = v9[56];
  switch(v9[56])
  {
    case 0u:
    case 1u:
    case 7u:
    case 8u:
    case 0x65u:
    case 0x68u:
    case 0x69u:
      goto LABEL_12;
    case 2u:
      *(_WORD *)&type[0].os_log_type_t sa_len = 0;
      if (size == 2)
      {
        nw_dispatch_data_copyout(v11, (uint64_t)type, 2LL);
        if (type[0].sa_len == 5)
        {
          int sa_family = type[0].sa_family;
          __nwlog_obj();
          uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v38 = v46;
          if (sa_family)
          {
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&_BYTE buf[12] = 2114;
              *(void *)&buf[14] = v9;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)&_BYTE buf[24] = type[0].sa_len;
              *(_WORD *)&_BYTE buf[28] = 1024;
              *(_DWORD *)&buf[30] = type[0].sa_family;
              _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ client request for version %u nMethods %u",  buf,  0x22u);
            }

            v9[56] = 3;
            nw_socks5_connection_inner_connection_read_range_on_queue( (NWConcrete_nw_socks5_connection *)v9,  type[0].sa_family,  type[0].sa_family);
            goto LABEL_102;
          }

          if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
            goto LABEL_217;
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          os_log_type_t v73 = "%{public}s %{public}@ connection received zero nMethods";
          os_log_type_t v74 = v38;
          uint32_t v75 = 22;
        }

        else
        {
          __nwlog_obj();
          __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
            goto LABEL_217;
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)&_BYTE buf[24] = type[0].sa_len;
          os_log_type_t v73 = "%{public}s %{public}@ connection received unsupported socks version %u";
          os_log_type_t v74 = v38;
          uint32_t v75 = 28;
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          goto LABEL_217;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v9;
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&_BYTE buf[24] = size;
        os_log_type_t v73 = "%{public}s %{public}@ connection received unexpected number of bytes %zu";
        os_log_type_t v74 = v38;
        uint32_t v75 = 32;
      }

      _os_log_impl(&dword_181A5C000, v74, OS_LOG_TYPE_ERROR, v73, buf, v75);
      goto LABEL_217;
    case 3u:
      if (size >= 0x100)
      {
        __nwlog_obj();
        __int16 v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          *(_WORD *)&_BYTE buf[22] = 2048;
          *(void *)&_BYTE buf[24] = size;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ connection received unexpected number of bytes %zu",  buf,  0x20u);
        }

        goto LABEL_175;
      }

      nw_dispatch_data_copyout(v11, (uint64_t)buf, 255LL);
      uint64_t v71 = 0LL;
      while (buf[v71])
      {
        if (size == ++v71)
        {
          __nwlog_obj();
          uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)&type[0].os_log_type_t sa_len = 136446466;
            *(void *)&type[0].sa_data[2] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
            *(_WORD *)&type[0].sa_data[10] = 2114;
            *(void *)&type[0].sa_data[12] = v9;
            _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ unsupported auth methods",  &type[0].sa_len,  0x16u);
          }

          goto LABEL_125;
        }
      }

      __nwlog_obj();
      BOOL v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)&type[0].os_log_type_t sa_len = 136446466;
        *(void *)&type[0].sa_data[2] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&type[0].sa_data[10] = 2114;
        *(void *)&type[0].sa_data[12] = v9;
        _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ picking auth method: none",  &type[0].sa_len,  0x16u);
      }

      v9[56] = 4;
      *(_WORD *)&type[0].os_log_type_t sa_len = 5;
      os_log_type_t v85 = dispatch_data_create(type, 2uLL, 0LL, 0LL);
      nw_socks5_connection_increment_busy_on_queue(v9, WeakRetained);
      os_log_type_t v86 = (nw_connection *)*((void *)v9 + 4);
      v154[0] = MEMORY[0x1895F87A8];
      v154[1] = 3221225472LL;
      v154[2] = ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke_154;
      v154[3] = &unk_189BB81E8;
      uint64_t v155 = v9;
      id v156 = WeakRetained;
      nw_connection_send(v86, v85, (nw_content_context_t)&__block_literal_global_41831, 1, v154);

      goto LABEL_102;
    case 4u:
      *(_DWORD *)&type[0].os_log_type_t sa_len = 0;
      if (size != 4)
      {
        __nwlog_obj();
        __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          goto LABEL_217;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v9;
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&_BYTE buf[24] = size;
        os_log_type_t v68 = "%{public}s %{public}@ connection received unexpected number of bytes %zu";
        os_log_type_t v69 = v38;
        uint32_t v70 = 32;
        goto LABEL_182;
      }

      nw_dispatch_data_copyout(v11, (uint64_t)type, 4LL);
      if (type[0].sa_len != 5)
      {
        __nwlog_obj();
        __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          goto LABEL_217;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v9;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&_BYTE buf[24] = type[0].sa_len;
        os_log_type_t v68 = "%{public}s %{public}@ connection received unsupported socks version %u";
        goto LABEL_181;
      }

      if (type[0].sa_family != 1)
      {
        __nwlog_obj();
        __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          goto LABEL_217;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v9;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&_BYTE buf[24] = type[0].sa_family;
        os_log_type_t v68 = "%{public}s %{public}@ connection received unsupported command %u";
        goto LABEL_181;
      }

      if (type[0].sa_data[1] <= 4u && ((1 << type[0].sa_data[1]) & 0x1A) != 0)
      {
        __nwlog_obj();
        uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)&_BYTE buf[24] = type[0].sa_len;
          *(_WORD *)&_BYTE buf[28] = 1024;
          *(_DWORD *)&buf[30] = type[0].sa_family;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = type[0].sa_data[1];
          _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ client request for version %u command %u addressType %u",  buf,  0x28u);
        }

        int v34 = type[0].sa_data[1];
        v9[57] = type[0].sa_data[1];
        switch(v34)
        {
          case 1:
            unsigned int v35 = 4;
            break;
          case 3:
            unsigned int v35 = 1;
            break;
          case 4:
            unsigned int v35 = 16;
            break;
          default:
            __nwlog_obj();
            id v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
            {
              int v110 = v9[57];
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&_BYTE buf[12] = 2114;
              *(void *)&buf[14] = v9;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)&_BYTE buf[24] = v110;
              _os_log_impl( &dword_181A5C000,  v109,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ address type %u not handled",  buf,  0x1Cu);
            }

            nw_socks5_connection_cancel_on_queue(v9, 0LL);
            unsigned int v35 = 0;
            break;
        }

        v9[56] = 5;
        nw_socks5_connection_inner_connection_read_range_on_queue((NWConcrete_nw_socks5_connection *)v9, v35, v35);
        goto LABEL_102;
      }

      __nwlog_obj();
      __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v9;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&_BYTE buf[24] = type[0].sa_data[1];
        os_log_type_t v68 = "%{public}s %{public}@ connection received unsupported address type %u";
LABEL_181:
        os_log_type_t v69 = v38;
        uint32_t v70 = 28;
LABEL_182:
        _os_log_impl(&dword_181A5C000, v69, OS_LOG_TYPE_ERROR, v68, buf, v70);
        goto LABEL_217;
      }

      goto LABEL_217;
    case 5u:
      int v40 = v9[57];
      if (v40 == 1 || v40 == 4)
      {
        if ((v40 != 1 || size == 4) && (v40 != 4 || size == 16)) {
          goto LABEL_150;
        }
        __nwlog_obj();
        __int16 v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          *(_WORD *)&_BYTE buf[22] = 2048;
          *(void *)&_BYTE buf[24] = size;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ connection received unexpected number of bytes %zu",  buf,  0x20u);
        }

void sub_181ECC9AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a71, 8);

  _Unwind_Resume(a1);
}

void nw_socks5_connection_inner_connection_read_range_on_queue( NWConcrete_nw_socks5_connection *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  if (a2 - 1 < a3)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v22 = "nw_socks5_connection_inner_connection_read_range_on_queue";
        __int16 v23 = 2114;
        *(void *)int v24 = v5;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ reading on inner connection",  buf,  0x16u);
      }
    }

    sc_in_connection = v5->sc_in_connection;
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = ___ZL57nw_socks5_connection_inner_connection_read_range_on_queueP31NWConcrete_nw_socks5_connectionjj_block_invoke;
    v16[3] = &unk_189BB8288;
    uint64_t v17 = v5;
    unsigned int v18 = a2;
    nw_connection_receive_internal(sc_in_connection, 0LL, a2, a3, v16);

    goto LABEL_11;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v7 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446722;
  uint64_t v22 = "nw_socks5_connection_inner_connection_read_range_on_queue";
  __int16 v23 = 1024;
  *(_DWORD *)int v24 = a2;
  *(_WORD *)&void v24[4] = 1024;
  *(_DWORD *)&v24[6] = a3;
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    double v9 = (os_log_s *)(id)gLogObj;
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v22 = "nw_socks5_connection_inner_connection_read_range_on_queue";
      __int16 v23 = 1024;
      *(_DWORD *)int v24 = a2;
      *(_WORD *)&void v24[4] = 1024;
      *(_DWORD *)&v24[6] = a3;
      _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s unexpected minBytes %u maxBytes %u", buf, 0x18u);
    }

void sub_181ECCFC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void ___ZL57nw_socks5_connection_inner_connection_read_range_on_queueP31NWConcrete_nw_socks5_connectionjj_block_invoke( uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v14 = a2;
  id v9 = a3;
  id v10 = a5;
  uint64_t v11 = v10;
  if (v10)
  {
    os_log_type_t v12 = (unsigned int *)v10;
    uint64_t v13 = v12[3];
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  nw_socks5_connection_inner_connection_read_handler_on_queue( *(void *)(a1 + 32),  v14,  a4,  v13,  *(unsigned int *)(a1 + 40));
}

void sub_181ECD074( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void nw_socks5_connection_inner_connection_read_on_queue(NWConcrete_nw_socks5_connection *a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if ((*((_BYTE *)v1 + 160) & 0x20) != 0)
  {
    int v3 = v1;
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)id v7 = 136446466;
        *(void *)&void v7[4] = "nw_socks5_connection_inner_connection_read_message_on_queue";
        *(_WORD *)&v7[12] = 2114;
        *(void *)&v7[14] = v3;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ reading message on inner connection",  v7,  0x16u);
      }
    }

    sc_in_connection = v3->sc_in_connection;
    *(void *)id v7 = MEMORY[0x1895F87A8];
    *(void *)&v7[8] = 3221225472LL;
    *(void *)&v7[16] = ___ZL59nw_socks5_connection_inner_connection_read_message_on_queueP31NWConcrete_nw_socks5_connection_block_invoke;
    uint64_t v8 = &unk_189BBF198;
    uint64_t v5 = v3;
    id v9 = v5;
    nw_connection_receive_internal(sc_in_connection, 0LL, 0xFFFFFFFF, 0xFFFFFFFF, v7);
  }

  else
  {
    nw_socks5_connection_inner_connection_read_range_on_queue(v1, 1u, 0xFFFFFFFF);
  }
}

void sub_181ECD1E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void nw_socks5_connection_increment_busy_on_queue(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v21 = a1;
  id v3 = a2;
  id v4 = v3;
  if (!v3) {
    goto LABEL_19;
  }
  id v5 = v3;
  uint64_t v6 = v5;
  if ((*((_BYTE *)v5 + 136) & 1) != 0)
  {
    int v7 = *((_DWORD *)v5 + 33);
    if (v7 != -1)
    {
      *((_DWORD *)v5 + 33) = v7 + 1;
LABEL_12:
      os_log_type_t v12 = v6;
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_socks5_server_handle_busy_changed_block_invoke;
      __int16 v25 = &unk_189BC93A0;
      uint64_t v26 = v12;
      os_unfair_lock_lock(v12 + 6);
      __nw_socks5_server_handle_busy_changed_block_invoke((uint64_t)buf);
      os_unfair_lock_unlock(v12 + 6);

      goto LABEL_13;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socks5_server_increment_busy";
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v9, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_server_increment_busy";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s ss_busy_count overflow", buf, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socks5_server_increment_busy";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s ss_busy_count overflow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v9) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }

        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_server_increment_busy";
          _os_log_impl(&dword_181A5C000, v10, v18, "%{public}s ss_busy_count overflow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_server_increment_busy";
          _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s ss_busy_count overflow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9) {
      goto LABEL_12;
    }
LABEL_11:
    free(v9);
    goto LABEL_12;
  }

void ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_socks5_connection_decrement_busy_on_queue(*(void **)(a1 + 32), *(void **)(a1 + 40));
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v27 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
      __int16 v28 = 2114;
      uint64_t v29 = v9;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ out connection write close done",  buf,  0x16u);
    }

    goto LABEL_12;
  }

  id v4 = v3;
  int v5 = v4[3];

  if ((v5 - 6) > 0x3B || ((1LL << (v5 - 6)) & 0x8C9B80004000001LL) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    uint64_t v12 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v27 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
    __int16 v28 = 2114;
    uint64_t v29 = v12;
    __int16 v30 = 1024;
    int v31 = v5;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          uint64_t v16 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v27 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v28 = 2114;
          uint64_t v29 = v16;
          __int16 v30 = 1024;
          int v31 = v5;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s %{public}@ out connection write close error %{darwin.errno}d",  buf,  0x1Cu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v19)
          {
            uint64_t v20 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v27 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v28 = 2114;
            uint64_t v29 = v20;
            __int16 v30 = 1024;
            int v31 = v5;
            __int16 v32 = 2082;
            uint64_t v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s %{public}@ out connection write close error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v19)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v27 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v28 = 2114;
          uint64_t v29 = v23;
          __int16 v30 = 1024;
          int v31 = v5;
          _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s %{public}@ out connection write close error %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          uint64_t v22 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v27 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v28 = 2114;
          uint64_t v29 = v22;
          __int16 v30 = 1024;
          int v31 = v5;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s %{public}@ out connection write close error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_181ECDA60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__16053(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__16054(uint64_t a1)
{
}

uint64_t ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke_145( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  size_t length = 0LL;
  data = (const char *)xpc_dictionary_get_data(v4, "data", &length);
  uint64_t v6 = data;
  uint64_t v7 = 1LL;
  if (data && length >= 0xD8)
  {
    unint64_t v8 = *((unsigned int *)data + 53);
    if (length == v8 + 216
      && !strcmp(data + 16, "com.apple.networkrelay")
      && ((int v9 = strcmp(v6 + 48, "CompanionProxyConfig"), (v8 - 0x10000) >= 0xFFFF0001)
        ? (BOOL v10 = v9 == 0)
        : (BOOL v10 = 0),
          v10))
    {
      nw_parameters_update_with_data( *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  (uint64_t)(v6 + 216),  v8);
      uint64_t v7 = 0LL;
    }

    else
    {
      uint64_t v7 = 1LL;
    }
  }

  return v7;
}

void sub_181ECDB64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke_150( uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = &qword_18C45F000;
  int v5 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v6 = *a2;
    if (v6 > 9) {
      uint64_t v7 = "unknown";
    }
    else {
      uint64_t v7 = off_189BB5958[v6];
    }
    uint64_t v8 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
    __int16 v62 = 2114;
    uint64_t v63 = v8;
    __int16 v64 = 2082;
    *(void *)BOOL v65 = v7;
    _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ processing shoes tlv: %{public}s",  buf,  0x20u);
  }

  switch(*a2)
  {
    case 1u:
      unsigned int v9 = *(unsigned __int16 *)(a2 + 1);
      if (v9 != 1024)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v50 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446978;
          char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v62 = 2114;
          uint64_t v63 = v50;
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = __rev16(v9);
          *(_WORD *)&v65[4] = 2048;
          *(void *)&v65[6] = 4LL;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Invalid TLV length (%u != %zu)",  buf,  0x26u);
        }

        goto LABEL_78;
      }

      int v10 = bswap32(*(_DWORD *)(a2 + 3));
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
        __int16 v62 = 2114;
        uint64_t v63 = v12;
        __int16 v64 = 1024;
        *(_DWORD *)BOOL v65 = v10;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ applying traffic class %u to inner and outer connections",  buf,  0x1Cu);
      }

      nw_parameters_set_traffic_class(*(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), v10);
      nw_connection_reset_traffic_class(*(void **)(*(void *)(a1 + 32) + 32LL), v10);
      break;
    case 2u:
      unsigned int v20 = *(unsigned __int16 *)(a2 + 1);
      if (!*(_WORD *)(a2 + 1))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v53 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446978;
          char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v62 = 2114;
          uint64_t v63 = v53;
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = __rev16(v20);
          *(_WORD *)&v65[4] = 2048;
          *(void *)&v65[6] = 1LL;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Invalid TLV length (%u < %zu)",  buf,  0x26u);
        }

        goto LABEL_78;
      }

      unsigned __int8 v21 = a2[3];
      if (v21)
      {
        if ((a2[3] & 0x80) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v22 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v23;
            _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ prohibiting expensive networks on outer connection",  buf,  0x16u);
          }

          nw_parameters_set_prohibit_expensive(*(nw_parameters_t *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), 1);
          unsigned __int8 v21 = a2[3];
        }

        if ((v21 & 0x20) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v24 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v25 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v25;
            _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ prohibiting wifi networks on outer connection",  buf,  0x16u);
          }

          nw_parameters_prohibit_interface_type( *(nw_parameters_t *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  nw_interface_type_wifi);
          unsigned __int8 v21 = a2[3];
        }

        if ((v21 & 0x40) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v26 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v27;
            _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ prohibiting cellular networks on outer connection",  buf,  0x16u);
          }

          nw_parameters_prohibit_interface_type( *(nw_parameters_t *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  nw_interface_type_cellular);
          unsigned __int8 v21 = a2[3];
        }

        if ((v21 & 0x10) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v28 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v29 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v29;
            _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ prohibiting constrained networks on outer connection",  buf,  0x16u);
          }

          nw_parameters_set_prohibit_constrained( *(nw_parameters_t *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  1);
          unsigned __int8 v21 = a2[3];
        }

        if ((v21 & 1) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v30 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v31;
            _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ requested to prefer wi-fi",  buf,  0x16u);
          }

          *(_BYTE *)(*(void *)(a1 + 32) + 160LL) |= 0x40u;
          unsigned __int8 v21 = a2[3];
        }

        if ((v21 & 2) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v32 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v33;
            _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ requested to fetch connected endpoint",  buf,  0x16u);
          }

          *(_BYTE *)(*(void *)(a1 + 32) + 161LL) |= 2u;
          unsigned __int8 v21 = a2[3];
        }

        if ((v21 & 4) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v34 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v35 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v35;
            _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ requested to fetch resolved endpoints",  buf,  0x16u);
          }

          *(_BYTE *)(*(void *)(a1 + 32) + 161LL) |= 4u;
        }
      }

      break;
    case 3u:
      if (*(_WORD *)(a2 + 1))
      {
        size_t v13 = __rev16(*(unsigned __int16 *)(a2 + 1));
        uint64_t v14 = calloc(1uLL, v13 + 1);
        if (!v14)
        {
          __nwlog_obj();
          id v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v58, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int128 buf = 136446722;
          char v61 = "strict_calloc";
          __int16 v62 = 2048;
          uint64_t v63 = 1LL;
          __int16 v64 = 2048;
          *(void *)BOOL v65 = v13 + 1;
          id v59 = (void *)_os_log_send_and_compose_impl();

          if (__nwlog_abort((uint64_t)v59))
          {
            __break(1u);
            return;
          }

          free(v59);
          id v4 = &qword_18C45F000;
        }

        memcpy(v14, a2 + 3, v13);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v15 = (os_log_s *)(id)v4[131];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v62 = 2114;
          uint64_t v63 = v16;
          __int16 v64 = 2082;
          *(void *)BOOL v65 = v14;
          _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ setting bundle id on outer connection to %{public}s",  buf,  0x20u);
        }

        nw_parameters_set_source_application_by_bundle_id_internal( *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  (const char *)v14);
        if (v14) {
          free(v14);
        }
      }

      break;
    case 5u:
      unsigned int v36 = *(unsigned __int16 *)(a2 + 1);
      if (v36 != 768)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v51 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136447234;
          char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v62 = 2114;
          uint64_t v63 = v51;
          __int16 v64 = 2080;
          *(void *)BOOL v65 = "multipath";
          *(_WORD *)&v65[8] = 1024;
          *(_DWORD *)&v65[10] = __rev16(v36);
          __int16 v66 = 2048;
          uint64_t v67 = 3LL;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Invalid TLV length for %s (%u != %zu)",  buf,  0x30u);
        }

        goto LABEL_78;
      }

      nw_multipath_service_t v37 = a2[3];
      unsigned int v38 = *((unsigned __int16 *)a2 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      double v39 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446978;
        char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
        __int16 v62 = 2114;
        uint64_t v63 = v40;
        __int16 v64 = 1024;
        *(_DWORD *)BOOL v65 = v37;
        *(_WORD *)&v65[4] = 1024;
        *(_DWORD *)&v65[6] = __rev16(v38);
        _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ setting multipath on outer connection to service: %u/alternate_port: %u",  buf,  0x22u);
      }

      nw_parameters_set_multipath_service(*(nw_parameters_t *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), v37);
      nw_endpoint_set_alternate_port(*(void **)(a1 + 40), v38);
      break;
    case 6u:
      unsigned int v41 = *(unsigned __int16 *)(a2 + 1);
      if (v41 != 512)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v52 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446978;
          char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v62 = 2114;
          uint64_t v63 = v52;
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = __rev16(v41);
          *(_WORD *)&v65[4] = 2048;
          *(void *)&v65[6] = 1LL;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Invalid TLV length (%u < %zu)",  buf,  0x26u);
        }

        goto LABEL_78;
      }

      uint64_t v42 = *(void *)(a1 + 32);
      if ((*(_BYTE *)(v42 + 161) & 1) == 0)
      {
        *(_BYTE *)(v42 + 160) |= 0x80u;
        *(_WORD *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = bswap32(*(unsigned __int16 *)(a2 + 3)) >> 16;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v43 = *(void *)(a1 + 32);
          int v44 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
          *(_DWORD *)__int128 buf = 136446722;
          char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v62 = 2114;
          uint64_t v63 = v43;
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = v44;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ requested to create UDP association to inner connection port: %u",  buf,  0x1Cu);
        }

        goto LABEL_78;
      }

      break;
    case 9u:
      unsigned int v17 = bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16;
      if (v17 > 3)
      {
        int v45 = *(_DWORD *)(a2 + 3);
        if (!v45) {
          return;
        }
        if ((v45 & 1) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v54 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v55 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v55;
            _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ requiring interface type wifi on outer connection",  buf,  0x16u);
          }

          int v48 = *(nw_parameters **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
          nw_interface_type_t v49 = nw_interface_type_wifi;
        }

        else if ((v45 & 2) != 0)
        {
          __nwlog_obj();
          uint32_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v57 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v57;
            _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ requiring interface type cellular on outer connection",  buf,  0x16u);
          }

          int v48 = *(nw_parameters **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
          nw_interface_type_t v49 = nw_interface_type_cellular;
        }

        else
        {
          if ((v45 & 4) == 0) {
            return;
          }
          __nwlog_obj();
          uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v47 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446466;
            char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v62 = 2114;
            uint64_t v63 = v47;
            _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ requiring interface type wired on outer connection",  buf,  0x16u);
          }

          int v48 = *(nw_parameters **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
          nw_interface_type_t v49 = nw_interface_type_wired;
        }

        nw_parameters_set_required_interface_type(v48, v49);
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446978;
          char v61 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v62 = 2114;
          uint64_t v63 = v19;
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = v17;
          *(_WORD *)&v65[4] = 2048;
          *(void *)&v65[6] = 4LL;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Invalid TLV length (%u < %zu)",  buf,  0x26u);
        }

void ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke_152( uint64_t a1, char a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*(unsigned __int8 *)(*(void *)(a1 + 32) + 56LL) != 255)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    int v5 = v4;
    if ((a2 & 1) != 0)
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        int v15 = 136446466;
        uint64_t v16 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
        __int16 v17 = 2114;
        uint64_t v18 = v6;
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ successfully registered udp association",  (uint8_t *)&v15,  0x16u);
      }

      nw_connection_t v7 = nw_connection_create(*(nw_endpoint_t *)(a1 + 40), *(nw_parameters_t *)(a1 + 48));
      uint64_t v8 = *(void *)(a1 + 32);
      unsigned int v9 = *(void **)(v8 + 32);
      *(void *)(v8 + 32) = v7;

      int v10 = *(void **)(a1 + 56);
      id v11 = (unsigned __int8 *)*(id *)(a1 + 32);
      id v12 = v10;
      int v13 = v11[56];
      if (v13 != 200 && v13 != 255)
      {
        v11[56] = 101;
        nw_socks5_connection_start_on_queue(v11, v12);
      }
    }

    else
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = *(void *)(a1 + 32);
        int v15 = 136446466;
        uint64_t v16 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
        __int16 v17 = 2114;
        uint64_t v18 = v14;
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ failed to register udp association",  (uint8_t *)&v15,  0x16u);
      }

      nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
    }
  }

void sub_181ECEBCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_socks5_connection_connect_outer_on_queue(void *a1, void *a2, void *a3)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  uint64_t v6 = a2;
  nw_parameters_t secure_tcp = a3;
  if (!secure_tcp)
  {
    nw_parameters_t secure_tcp = nw_parameters_create_secure_tcp(&__block_literal_global_18956, &__block_literal_global_91);
    if (!secure_tcp)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v30 = (id)gLogObj;
      *(_DWORD *)uint64_t v54 = 136446210;
      *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
      uint64_t v31 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      char v47 = 0;
      if (__nwlog_fault(v31, buf, &v47))
      {
        if (buf[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v32 = (os_log_s *)(id)gLogObj;
          os_log_type_t v33 = buf[0];
          if (os_log_type_enabled(v32, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)uint64_t v54 = 136446210;
            *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
            _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s nw_parameters_create_secure_tcp failed", v54, 0xCu);
          }
        }

        else if (v47)
        {
          backtrace_string = __nw_create_backtrace_string();
          if (backtrace_string)
          {
            unsigned int v36 = (char *)backtrace_string;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            nw_multipath_service_t v37 = (os_log_s *)(id)gLogObj;
            os_log_type_t v38 = buf[0];
            if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
            {
              *(_DWORD *)uint64_t v54 = 136446466;
              *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
              *(_WORD *)&v54[12] = 2082;
              *(void *)&v54[14] = v36;
              _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s nw_parameters_create_secure_tcp failed, dumping backtrace:%{public}s",  v54,  0x16u);
            }

            free(v36);
            if (!v31) {
              goto LABEL_28;
            }
            goto LABEL_27;
          }

          __nwlog_obj();
          __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v41 = buf[0];
          if (os_log_type_enabled(v32, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)uint64_t v54 = 136446210;
            *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
            _os_log_impl( &dword_181A5C000,  v32,  v41,  "%{public}s nw_parameters_create_secure_tcp failed, no backtrace",  v54,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v32 = (os_log_s *)(id)gLogObj;
          os_log_type_t v40 = buf[0];
          if (os_log_type_enabled(v32, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)uint64_t v54 = 136446210;
            *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
            _os_log_impl( &dword_181A5C000,  v32,  v40,  "%{public}s nw_parameters_create_secure_tcp failed, backtrace limit exceeded",  v54,  0xCu);
          }
        }
      }

      if (!v31)
      {
LABEL_28:
        uint64_t v34 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 12);
        nw_socks5_connection_cancel_on_queue(v5, v34);
        int v13 = (nw_parameters *)v34;
        goto LABEL_29;
      }

void sub_181ECF408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke_154( uint64_t a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_socks5_connection_decrement_busy_on_queue(*(void **)(a1 + 32), *(void **)(a1 + 40));
  id v4 = *(NWConcrete_nw_socks5_connection **)(a1 + 32);
  if (v4->sc_state != 255)
  {
    if (!v3)
    {
      nw_socks5_connection_inner_connection_read_range_on_queue(v4, 4u, 4u);
      goto LABEL_12;
    }

    int v5 = v3;
    int v6 = v5[3];

    if ((v6 - 6) <= 0x3B && ((1LL << (v6 - 6)) & 0x8C9B80004000001LL) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v8 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v26 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
        __int16 v27 = 2114;
        uint64_t v28 = v9;
        __int16 v29 = 1024;
        int v30 = v6;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ write in auth reply error %{darwin.errno}d",  buf,  0x1Cu);
      }

LABEL_10:
      nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
      goto LABEL_12;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    uint64_t v11 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v26 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
    __int16 v27 = 2114;
    uint64_t v28 = v11;
    __int16 v29 = 1024;
    int v30 = v6;
    unsigned int v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v12, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          uint64_t v15 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v26 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v27 = 2114;
          uint64_t v28 = v15;
          __int16 v29 = 1024;
          int v30 = v6;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s %{public}@ write in auth reply error %{darwin.errno}d",  buf,  0x1Cu);
        }
      }

      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v18)
          {
            uint64_t v19 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v26 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v27 = 2114;
            uint64_t v28 = v19;
            __int16 v29 = 1024;
            int v30 = v6;
            __int16 v31 = 2082;
            __int16 v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v17,  "%{public}s %{public}@ write in auth reply error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }

        if (v18)
        {
          uint64_t v22 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v26 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v27 = 2114;
          uint64_t v28 = v22;
          __int16 v29 = 1024;
          int v30 = v6;
          _os_log_impl( &dword_181A5C000,  v13,  v17,  "%{public}s %{public}@ write in auth reply error %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v13, type))
        {
          uint64_t v21 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v26 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v27 = 2114;
          uint64_t v28 = v21;
          __int16 v29 = 1024;
          int v30 = v6;
          _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s %{public}@ write in auth reply error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_181ECF888(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL59nw_socks5_connection_inner_connection_read_handler_on_queueP31NWConcrete_nw_socks5_connectionPU27objcproto16OS_dispatch_data8NSObjectbim_block_invoke_155( uint64_t a1, void *a2)
{
  v45[2] = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_socks5_connection_decrement_busy_on_queue(*(void **)(a1 + 32), *(void **)(a1 + 40));
  uint64_t v4 = *(void *)(a1 + 32);
  if (v3)
  {
    int v5 = v3;
    int v6 = v5[3];

    int v7 = *(char *)(*(void *)(a1 + 32) + 160LL);
    if (v7 < 0)
    {
      uint64_t v19 = (v6 - 6);
      if (v19 <= 0x3B)
      {
        if (((1LL << (v6 - 6)) & 0x8C9B80004000001LL) != 0)
        {
LABEL_24:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v21 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            uint64_t v22 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446722;
            os_log_type_t v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v42 = 2114;
            uint64_t v43 = v22;
            __int16 v44 = 1024;
            LODWORD(v45[0]) = v6;
            _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ write out error %{darwin.errno}d",  buf,  0x1Cu);
          }

LABEL_27:
          nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), v5);
          goto LABEL_31;
        }

        if (v19 == 49)
        {
LABEL_6:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unsigned int v8 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v9 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446722;
            os_log_type_t v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v42 = 2114;
            uint64_t v43 = v9;
            __int16 v44 = 2112;
            v45[0] = v5;
            _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ ignoring write out error %@",  buf,  0x20u);
          }

          nw_socks5_connection_inner_connection_read_on_queue(*(NWConcrete_nw_socks5_connection **)(a1 + 32));
          goto LABEL_31;
        }
      }
    }

    else
    {
      if ((v7 & 0x20) != 0 && v6 == 55) {
        goto LABEL_6;
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    uint64_t v24 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    os_log_type_t v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
    __int16 v42 = 2114;
    uint64_t v43 = v24;
    __int16 v44 = 1024;
    LODWORD(v45[0]) = v6;
    os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v25, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          uint64_t v28 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          os_log_type_t v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v42 = 2114;
          uint64_t v43 = v28;
          __int16 v44 = 1024;
          LODWORD(v45[0]) = v6;
          _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s %{public}@ write out error %{darwin.errno}d", buf, 0x1Cu);
        }
      }

      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        BOOL v31 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v31)
          {
            uint64_t v32 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446978;
            os_log_type_t v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
            __int16 v42 = 2114;
            uint64_t v43 = v32;
            __int16 v44 = 1024;
            LODWORD(v45[0]) = v6;
            WORD2(v45[0]) = 2082;
            *(void *)((char *)v45 + 6) = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v26,  v30,  "%{public}s %{public}@ write out error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v31)
        {
          uint64_t v35 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          os_log_type_t v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v42 = 2114;
          uint64_t v43 = v35;
          __int16 v44 = 1024;
          LODWORD(v45[0]) = v6;
          _os_log_impl( &dword_181A5C000,  v26,  v30,  "%{public}s %{public}@ write out error %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v26, type))
        {
          uint64_t v34 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          os_log_type_t v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
          __int16 v42 = 2114;
          uint64_t v43 = v34;
          __int16 v44 = 1024;
          LODWORD(v45[0]) = v6;
          _os_log_impl( &dword_181A5C000,  v26,  v33,  "%{public}s %{public}@ write out error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_181ECFF34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_socks5_connection_decrement_busy_on_queue(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v23 = a1;
  id v3 = a2;
  uint64_t v4 = v3;
  if (!v3) {
    goto LABEL_20;
  }
  id v5 = v3;
  int v6 = v5;
  if ((*((_BYTE *)v5 + 136) & 1) != 0)
  {
    int v7 = *((_DWORD *)v5 + 33);
    if (v7)
    {
      *((_DWORD *)v5 + 33) = v7 - 1;
LABEL_12:
      uint64_t v12 = v6;
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_socks5_server_handle_busy_changed_block_invoke;
      os_log_type_t v27 = &unk_189BC93A0;
      uint64_t v28 = v12;
      os_unfair_lock_lock(v12 + 6);
      __nw_socks5_server_handle_busy_changed_block_invoke((uint64_t)buf);
      os_unfair_lock_unlock(v12 + 6);

      goto LABEL_13;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socks5_server_decrement_busy";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v9, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_server_decrement_busy";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s ss_busy_count underflow", buf, 0xCu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socks5_server_decrement_busy";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s ss_busy_count underflow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v9) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }

        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_server_decrement_busy";
          _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s ss_busy_count underflow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_server_decrement_busy";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s ss_busy_count underflow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9) {
      goto LABEL_12;
    }
LABEL_11:
    free(v9);
    goto LABEL_12;
  }

void ___ZL43nw_socks5_connection_connect_outer_on_queueP31NWConcrete_nw_socks5_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke( uint64_t a1, char a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if ((a2 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      int v7 = 136446466;
      id v8 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
      __int16 v9 = 2114;
      uint64_t v10 = v4;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ out connection no longer viable, cancelling",  (uint8_t *)&v7,  0x16u);
    }

    *(_BYTE *)(*(void *)(a1 + 32) + 160LL) |= 1u;
    id v5 = *(void **)(a1 + 32);
    int v6 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 50);
    nw_socks5_connection_cancel_on_queue(v5, v6);
  }

void sub_181ED0420(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_socks5_connection_connect_outer_on_queueP31NWConcrete_nw_socks5_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke_157( uint64_t a1, unsigned int a2, void *a3)
{
  v57[2] = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (a2 != 2)
  {
    int v6 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    if (v6)
    {
      nw_socks5_connection_decrement_busy_on_queue(*(void **)(a1 + 32), v6);
      uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = 0LL;
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v9 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5) {
      uint64_t v10 = "unknown";
    }
    else {
      uint64_t v10 = off_189BB9C00[a2];
    }
    uint64_t v11 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v53 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
    __int16 v54 = 2114;
    uint64_t v55 = v11;
    __int16 v56 = 2082;
    v57[0] = v10;
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ out connection event %{public}s",  buf,  0x20u);
  }

  if (a2 == 4)
  {
    *(_BYTE *)(*(void *)(a1 + 32) + 160LL) |= 1u;
    uint64_t v12 = *(unsigned __int8 **)(a1 + 32);
    if ((~v12[160] & 3) == 0)
    {
      nw_socks5_connection_cancel_on_queue(v12, v5);
      goto LABEL_56;
    }

    if (!v5) {
      goto LABEL_56;
    }
    goto LABEL_16;
  }

  if (!v5)
  {
    if (a2 != 3) {
      goto LABEL_56;
    }
    uint64_t v18 = *(void *)(a1 + 32);
    unsigned int v19 = *(unsigned __int8 *)(v18 + 56);
    if (v19 <= 0x67)
    {
      if (v19 == 7)
      {
        *(_BYTE *)(v18 + 56) = 8;
LABEL_50:
        uint64_t v38 = MEMORY[0x1895F87A8];
        aBlock[0] = MEMORY[0x1895F87A8];
        aBlock[1] = 3221225472LL;
        aBlock[2] = ___ZL43nw_socks5_connection_connect_outer_on_queueP31NWConcrete_nw_socks5_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke_158;
        aBlock[3] = &unk_189BBBDE8;
        os_log_type_t v40 = *(void **)(a1 + 32);
        os_log_type_t v39 = (uint64_t *)(a1 + 32);
        nw_interface_type_t v49 = v40;
        os_log_type_t v41 = _Block_copy(aBlock);
        uint64_t v42 = *v39;
        if (*(_BYTE *)(*v39 + 56) == 105 && (*(_BYTE *)(v42 + 161) & 4) != 0)
        {
          uint64_t v43 = *(nw_connection **)(v42 + 144);
          __int16 v44 = *(dispatch_queue_s **)(v42 + 40);
          access_block[0] = v38;
          access_block[1] = 3221225472LL;
          access_block[2] = ___ZL43nw_socks5_connection_connect_outer_on_queueP31NWConcrete_nw_socks5_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke_159;
          access_block[3] = &unk_189BB82B0;
          id v46 = (id)v42;
          id v47 = v41;
          nw_connection_access_establishment_report(v43, v44, access_block);
        }

        else
        {
          nw_socks5_connection_send_reply_on_queue((void *)v42, 1, v41);
        }

        uint64_t v15 = v49;
        goto LABEL_55;
      }

      if (v19 == 8) {
        goto LABEL_56;
      }
    }

    else
    {
      if (v19 == 200 || v19 == 105) {
        goto LABEL_56;
      }
      if (v19 == 104)
      {
        *(_BYTE *)(v18 + 56) = 105;
        goto LABEL_50;
      }
    }

    __nwlog_obj();
    os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v21 = *(void *)(a1 + 32);
    int v22 = *(unsigned __int8 *)(v21 + 56);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v53 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
    __int16 v54 = 2114;
    uint64_t v55 = v21;
    __int16 v56 = 1024;
    LODWORD(v57[0]) = v22;
    id v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (__nwlog_fault(v23, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          uint64_t v26 = *(void *)(a1 + 32);
          int v27 = *(unsigned __int8 *)(v26 + 56);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v53 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
          __int16 v54 = 2114;
          uint64_t v55 = v26;
          __int16 v56 = 1024;
          LODWORD(v57[0]) = v27;
          _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s %{public}@ out connection ready from unexpected state %u",  buf,  0x1Cu);
        }
      }

      else if (v50)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v30)
          {
            uint64_t v31 = *(void *)(a1 + 32);
            int v32 = *(unsigned __int8 *)(v31 + 56);
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v53 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
            __int16 v54 = 2114;
            uint64_t v55 = v31;
            __int16 v56 = 1024;
            LODWORD(v57[0]) = v32;
            WORD2(v57[0]) = 2082;
            *(void *)((char *)v57 + 6) = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s %{public}@ out connection ready from unexpected state %u, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }

        if (v30)
        {
          uint64_t v36 = *(void *)(a1 + 32);
          int v37 = *(unsigned __int8 *)(v36 + 56);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v53 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
          __int16 v54 = 2114;
          uint64_t v55 = v36;
          __int16 v56 = 1024;
          LODWORD(v57[0]) = v37;
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s %{public}@ out connection ready from unexpected state %u, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v24, type))
        {
          uint64_t v34 = *(void *)(a1 + 32);
          int v35 = *(unsigned __int8 *)(v34 + 56);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v53 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
          __int16 v54 = 2114;
          uint64_t v55 = v34;
          __int16 v56 = 1024;
          LODWORD(v57[0]) = v35;
          _os_log_impl( &dword_181A5C000,  v24,  v33,  "%{public}s %{public}@ out connection ready from unexpected state %u, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_181ED0AD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_socks5_connection_connect_outer_on_queueP31NWConcrete_nw_socks5_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke_158( uint64_t a1, int a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(v2 + 56);
  if (v3 != 255)
  {
    if (!a2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (id)gLogObj;
      if (!os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_ERROR))
      {
LABEL_26:

        nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
        return;
      }

      uint64_t v20 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
      __int16 v47 = 2114;
      uint64_t v48 = v20;
      uint64_t v21 = "%{public}s %{public}@ failed to write reply";
LABEL_25:
      _os_log_impl(&dword_181A5C000, (os_log_t)v22, OS_LOG_TYPE_ERROR, v21, buf, 0x16u);
      goto LABEL_26;
    }

    if (v3 != 105 && v3 != 8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (id)gLogObj;
      if (!os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      uint64_t v24 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
      __int16 v47 = 2114;
      uint64_t v48 = v24;
      uint64_t v21 = "%{public}s %{public}@ wrote reply but ended in bad state";
      goto LABEL_25;
    }

    *(_BYTE *)(v2 + 56) = -56;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
      __int16 v47 = 2114;
      uint64_t v48 = v7;
      _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}@ successfully wrote reply", buf, 0x16u);
    }

    uint64_t v8 = *(void *)(a1 + 32);
    char v9 = *(_BYTE *)(v8 + 160);
    if ((v9 & 0xA0) != 0x20) {
      goto LABEL_53;
    }
    uint64_t v10 = *(nw_connection **)(v8 + 32);
    uint64_t v11 = (nw_protocol_definition *)(id)g_tcp_definition;
    nw_protocol_metadata_t v12 = nw_connection_copy_protocol_metadata(v10, v11);

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v13 = (os_log_s *)(id)gLogObj;
    uint64_t v14 = v13;
    if (!v12)
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446466;
        id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
        __int16 v47 = 2114;
        uint64_t v48 = v25;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ metadata for inner connection is nil -- unable to setting TCP no delay",  buf,  0x16u);
      }

      goto LABEL_48;
    }

    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
      __int16 v47 = 2114;
      uint64_t v48 = v15;
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ setting TCP no delay on inner connection",  buf,  0x16u);
    }

    if (!nw_tcp_set_no_delay(v12, 1))
    {
LABEL_48:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v38 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
      {
        uint64_t v39 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446466;
        id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
        __int16 v47 = 2114;
        uint64_t v48 = v39;
        _os_log_impl(&dword_181A5C000, v38, OS_LOG_TYPE_INFO, "%{public}s %{public}@ adding UDP framer", buf, 0x16u);
      }

      if (nw_shoes_copy_udp_framer_definition::onceToken != -1) {
        dispatch_once(&nw_shoes_copy_udp_framer_definition::onceToken, &__block_literal_global_26826);
      }
      os_log_type_t v40 = (nw_protocol_definition *)(id)nw_shoes_copy_udp_framer_definition::definition;
      os_log_type_t v41 = *(void **)(*(void *)(a1 + 32) + 32LL);
      nw_protocol_options_t options = nw_framer_create_options(v40);
      nw_connection_append_and_start_application_protocol(v41, options);

      uint64_t v8 = *(void *)(a1 + 32);
      char v9 = *(_BYTE *)(v8 + 160);
LABEL_53:
      *(_BYTE *)(v8 + 160) = v9 | 0x10;
      nw_socks5_connection_outer_connection_read_on_queue(*(NWConcrete_nw_socks5_connection **)(a1 + 32));
      nw_socks5_connection_inner_connection_read_on_queue(*(NWConcrete_nw_socks5_connection **)(a1 + 32));
      return;
    }

    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)(id)gLogObj;
    uint64_t v18 = v17;
    if (v16 == 22)
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
        __int16 v47 = 2114;
        uint64_t v48 = v19;
        __int16 v49 = 1024;
        int v50 = 22;
        _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ error setting TCP no delay on inner connection %{darwin.errno}d",  buf,  0x1Cu);
      }

      goto LABEL_48;
    }

    uint64_t v26 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
    __int16 v47 = 2114;
    uint64_t v48 = v26;
    __int16 v49 = 1024;
    int v50 = v16;
    int v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v27, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          uint64_t v30 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
          __int16 v47 = 2114;
          uint64_t v48 = v30;
          __int16 v49 = 1024;
          int v50 = v16;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s %{public}@ error setting TCP no delay on inner connection %{darwin.errno}d",  buf,  0x1Cu);
        }
      }

      else if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        BOOL v33 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v33)
          {
            uint64_t v34 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446978;
            id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
            __int16 v47 = 2114;
            uint64_t v48 = v34;
            __int16 v49 = 1024;
            int v50 = v16;
            __int16 v51 = 2082;
            __int16 v52 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s %{public}@ error setting TCP no delay on inner connection %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_46;
        }

        if (v33)
        {
          uint64_t v37 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
          __int16 v47 = 2114;
          uint64_t v48 = v37;
          __int16 v49 = 1024;
          int v50 = v16;
          _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s %{public}@ error setting TCP no delay on inner connection %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v28, type))
        {
          uint64_t v36 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          id v46 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
          __int16 v47 = 2114;
          uint64_t v48 = v36;
          __int16 v49 = 1024;
          int v50 = v16;
          _os_log_impl( &dword_181A5C000,  v28,  v35,  "%{public}s %{public}@ error setting TCP no delay on inner connection %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_181ED12C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_socks5_connection_connect_outer_on_queueP31NWConcrete_nw_socks5_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke_159( uint64_t a1, void *a2)
{
  id v5 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v4 + 56) != 255)
  {
    objc_storeStrong((id *)(v4 + 176), a2);
    nw_socks5_connection_send_reply_on_queue(*(void **)(a1 + 32), 1, *(void **)(a1 + 40));
  }
}

void sub_181ED1358( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_socks5_connection_send_reply_on_queue(void *a1, char a2, void *a3)
{
  uint64_t v125 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  int v6 = a3;
  int sc_state = v5->sc_state;
  if (sc_state == 255 || (*((_BYTE *)v5 + 160) & 8) != 0) {
    goto LABEL_105;
  }
  if (!v5->sc_in_connection)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v17 = (id)gLogObj;
    *(_DWORD *)uint64_t v119 = 136446466;
    *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
    *(_WORD *)&v119[12] = 2114;
    *(void *)&v119[14] = v5;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v18, buf, &buffer))
    {
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v19 = (os_log_s *)(id)gLogObj;
        os_log_type_t v20 = buf[0];
        if (os_log_type_enabled(v19, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)uint64_t v119 = 136446466;
          *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v5;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s %{public}@ cannot send reply without inner connection",  v119,  0x16u);
        }
      }

      else if ((_BYTE)buffer)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          uint64_t v28 = (uint64_t (*)(uint64_t, uint64_t))backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v29 = (os_log_s *)(id)gLogObj;
          os_log_type_t v30 = buf[0];
          if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)uint64_t v119 = 136446722;
            *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
            *(_WORD *)&v119[12] = 2114;
            *(void *)&v119[14] = v5;
            *(_WORD *)&v119[22] = 2082;
            char v120 = v28;
            _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s %{public}@ cannot send reply without inner connection, dumping backtrace:%{public}s",  v119,  0x20u);
          }

          free(v28);
          if (!v18) {
            goto LABEL_105;
          }
          goto LABEL_104;
        }

        __nwlog_obj();
        uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v62 = buf[0];
        if (os_log_type_enabled(v19, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)uint64_t v119 = 136446466;
          *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v5;
          _os_log_impl( &dword_181A5C000,  v19,  v62,  "%{public}s %{public}@ cannot send reply without inner connection, no backtrace",  v119,  0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v19 = (os_log_s *)(id)gLogObj;
        os_log_type_t v50 = buf[0];
        if (os_log_type_enabled(v19, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)uint64_t v119 = 136446466;
          *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v5;
          _os_log_impl( &dword_181A5C000,  v19,  v50,  "%{public}s %{public}@ cannot send reply without inner connection, backtrace limit exceeded",  v119,  0x16u);
        }
      }
    }

    if (!v18)
    {
LABEL_105:
      v6[2](v6, 0LL);
LABEL_106:

      return;
    }

void sub_181ED2608(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v5 - 208), 8);
  _Unwind_Resume(a1);
}

void nw_socks5_connection_add_prefer_wifi_request(NWConcrete_nw_socks5_connection *a1)
{
  uint64_t v1 = a1;
  if (!v1->sc_prefer_wifi_path_evaluator)
  {
    nw_parameters_t v2 = nw_parameters_create();
    xpc_object_t v3 = xpc_array_create(0LL, 0LL);
    xpc_object_t v4 = xpc_array_create(0LL, 0LL);
    xpc_array_set_string(v3, 0xFFFFFFFFFFFFFFFFLL, "com.apple.networkrelay");
    xpc_array_set_string(v4, 0xFFFFFFFFFFFFFFFFLL, "PreferWiFi");
    nw_parameters_set_required_netagent_classes(v2, v3, v4);
    nw_parameters_t v5 = nw_connection_copy_parameters((nw_connection_t)v1->sc_out_connection);
    effective_bundle_id = (const char *)nw_parameters_get_effective_bundle_id(v5);
    if (effective_bundle_id) {
      nw_parameters_set_account_id(v2, effective_bundle_id);
    }
    evaluator_for_nw_endpoint_t endpoint = nw_path_create_evaluator_for_endpoint(0LL, v2);
    objc_initWeak(&location, v1);
    sc_queue = v1->sc_queue;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = ___ZL44nw_socks5_connection_add_prefer_wifi_requestP31NWConcrete_nw_socks5_connection_block_invoke;
    v9[3] = &unk_189BC8C90;
    objc_copyWeak(&v10, &location);
    nw_path_evaluator_set_update_handler(evaluator_for_endpoint, sc_queue, v9);
    objc_storeStrong((id *)&v1->sc_prefer_wifi_path_evaluator, evaluator_for_endpoint);
    nw_socks5_connection_assert_prefer_wifi(v1);
    objc_destroyWeak(&v10);
    objc_destroyWeak(&location);
  }
}

void sub_181ED282C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke( uint64_t a1, void *a2)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_2;
  v3[3] = &unk_189BBACC8;
  v3[4] = *(void *)(a1 + 32);
  nw_resolution_report_enumerate_endpoints(a2, v3);
  return 0LL;
}

uint64_t ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_3( uint64_t a1, uint64_t a2, void *a3)
{
  xpc_object_t v4 = a3;
  nw_endpoint_t address = nw_endpoint_get_address(v4);
  if (address) {
    *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += address->sa_len + 3;
  }

  return 1LL;
}

void sub_181ED2944(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_166( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  xpc_object_t v4 = a3;
  nw_endpoint_t address = (sockaddr *)nw_endpoint_get_address(v4);
  if (address
    && *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) < *(unsigned __int16 *)(a1 + 56))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v10 = 136446722;
      uint64_t v11 = "nw_socks5_connection_send_reply_on_queue_block_invoke";
      __int16 v12 = 2114;
      uint64_t v13 = v7;
      __int16 v14 = 2082;
      char v15 = "resolved_endpoint";
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ sending reply tlv: %{public}s",  (uint8_t *)&v10,  0x20u);
    }

    uint64_t v8 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += nw_shoes_add_tlv( *(void *)(a1 + 48) + v8,  (unsigned __int16)(*(_WORD *)(a1 + 56) - v8),  8u,  address->sa_len,  address);
  }

  return 1LL;
}

void sub_181ED2AC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_167( uint64_t a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_socks5_connection_decrement_busy_on_queue(*(void **)(a1 + 32), *(void **)(a1 + 40));
  if (!v3)
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
    goto LABEL_8;
  }

  xpc_object_t v4 = v3;
  int v5 = v4[3];

  switch(v5)
  {
    case 6:
    case 32:
    case 49:
    case 50:
    case 51:
    case 53:
    case 54:
    case 57:
    case 60:
    case 61:
    case 65:
    case 89:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v6 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v24 = "nw_socks5_connection_send_reply_on_queue_block_invoke";
        __int16 v25 = 2114;
        uint64_t v26 = v7;
        __int16 v27 = 1024;
        int v28 = v5;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ write in request reply error %{darwin.errno}d",  buf,  0x1Cu);
      }

LABEL_6:
      nw_socks5_connection_cancel_on_queue(*(void *)(a1 + 32), 0LL);
      (*(void (**)(void, void))(*(void *)(a1 + 48) + 16LL))(*(void *)(a1 + 48), 0LL);
LABEL_8:

      return;
    default:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v24 = "nw_socks5_connection_send_reply_on_queue_block_invoke";
      __int16 v25 = 2114;
      uint64_t v26 = v9;
      __int16 v27 = 1024;
      int v28 = v5;
      int v10 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v21 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          uint64_t v13 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v24 = "nw_socks5_connection_send_reply_on_queue_block_invoke";
          __int16 v25 = 2114;
          uint64_t v26 = v13;
          __int16 v27 = 1024;
          int v28 = v5;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %{public}@ write in request reply error %{darwin.errno}d",  buf,  0x1Cu);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            uint64_t v17 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v24 = "nw_socks5_connection_send_reply_on_queue_block_invoke";
            __int16 v25 = 2114;
            uint64_t v26 = v17;
            __int16 v27 = 1024;
            int v28 = v5;
            __int16 v29 = 2082;
            os_log_type_t v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s %{public}@ write in request reply error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v16)
        {
          uint64_t v20 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v24 = "nw_socks5_connection_send_reply_on_queue_block_invoke";
          __int16 v25 = 2114;
          uint64_t v26 = v20;
          __int16 v27 = 1024;
          int v28 = v5;
          _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s %{public}@ write in request reply error %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          uint64_t v19 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v24 = "nw_socks5_connection_send_reply_on_queue_block_invoke";
          __int16 v25 = 2114;
          uint64_t v26 = v19;
          __int16 v27 = 1024;
          int v28 = v5;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s %{public}@ write in request reply error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }

LABEL_25:
      if (v10) {
        free(v10);
      }
      goto LABEL_6;
  }

void sub_181ED2F18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_2( uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  if (!v4)
  {
    BOOL v5 = nw_array_create();
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  }

  nw_array_append(v4, v3);

  return 1LL;
}

void ___ZL44nw_socks5_connection_add_prefer_wifi_requestP31NWConcrete_nw_socks5_connection_block_invoke( uint64_t a1)
{
  id WeakRetained = (NWConcrete_nw_socks5_connection *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && WeakRetained->sc_state != 255) {
    nw_socks5_connection_assert_prefer_wifi(WeakRetained);
  }
}

void sub_181ED2FE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_socks5_connection_assert_prefer_wifi(NWConcrete_nw_socks5_connection *a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  sc_prefer_wifi_path_evaluator = (os_unfair_lock_s *)v1->sc_prefer_wifi_path_evaluator;
  if (sc_prefer_wifi_path_evaluator)
  {
    id v3 = sc_prefer_wifi_path_evaluator + 24;
    uint64_t v4 = sc_prefer_wifi_path_evaluator;
    os_unfair_lock_lock(v3);
    BOOL v5 = (nw_path *)v4[6];
    os_unfair_lock_unlock(v3);

    nw_path_status_t status = nw_path_get_status(v5);
    if (status != nw_path_status_satisfied)
    {
      nw_path_status_t v8 = status;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446722;
        __int16 v25 = "nw_socks5_connection_assert_prefer_wifi";
        __int16 v26 = 2112;
        __int16 v27 = (const char *)v1;
        __int16 v28 = 1024;
        LODWORD(v29) = v8;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ waiting to add prefer wi-fi request (%u)",  buf,  0x1Cu);
      }

      v1->sc_prefer_wifi_previous_path_nw_path_status_t status = v8;
      goto LABEL_41;
    }

    if (v1->sc_prefer_wifi_previous_path_status == 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v25 = "nw_socks5_connection_assert_prefer_wifi";
        __int16 v26 = 2112;
        __int16 v27 = (const char *)v1;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ ignoring path update to add prefer wi-fi request",  buf,  0x16u);
      }

      goto LABEL_41;
    }

    v1->sc_prefer_wifi_previous_path_nw_path_status_t status = 1;
    uuid_clear(uu);
    if (v5 && (int v10 = (void *)*((void *)v5 + 28)) != 0LL)
    {
      id v11 = v10;
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = ___ZL39nw_socks5_connection_assert_prefer_wifiP31NWConcrete_nw_socks5_connection_block_invoke;
      applier[3] = &__block_descriptor_40_e37_B24__0r_8__NSObject_OS_xpc_object__16l;
      void applier[4] = uu;
      xpc_dictionary_apply(v11, applier);
    }

    else
    {
      id v11 = 0LL;
    }

    if (!uuid_is_null(uu))
    {
      uuid_unparse(uu, (char *)buf);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v16 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)os_log_type_t type = 136446722;
        BOOL v33 = "nw_socks5_connection_assert_prefer_wifi";
        __int16 v34 = 2112;
        os_log_type_t v35 = v1;
        __int16 v36 = 2080;
        int v37 = buf;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ adding prefer wi-fi request, asserting agent %s",  (uint8_t *)type,  0x20u);
      }

      if (!nw_path_agent_action((NWConcrete_nw_path *)v5, uu, 131))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_log_type_t type = 136446722;
          BOOL v33 = "nw_socks5_connection_assert_prefer_wifi";
          __int16 v34 = 2112;
          os_log_type_t v35 = v1;
          __int16 v36 = 2080;
          int v37 = buf;
          _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s %@ failed to assert prefer wi-fi agent(%s)",  (uint8_t *)type,  0x20u);
        }
      }

      goto LABEL_40;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v12 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446722;
    __int16 v25 = "nw_socks5_connection_assert_prefer_wifi";
    __int16 v26 = 2080;
    __int16 v27 = "com.apple.networkrelay";
    __int16 v28 = 2080;
    __int16 v29 = "PreferWiFi";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, type, &v22))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v14 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446722;
          __int16 v25 = "nw_socks5_connection_assert_prefer_wifi";
          __int16 v26 = 2080;
          __int16 v27 = "com.apple.networkrelay";
          __int16 v28 = 2080;
          __int16 v29 = "PreferWiFi";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s Unable to determine agent uuid for %s/%s", buf, 0x20u);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type[0];
        BOOL v20 = os_log_type_enabled(v14, type[0]);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)__int128 buf = 136446978;
            __int16 v25 = "nw_socks5_connection_assert_prefer_wifi";
            __int16 v26 = 2080;
            __int16 v27 = "com.apple.networkrelay";
            __int16 v28 = 2080;
            __int16 v29 = "PreferWiFi";
            __int16 v30 = 2082;
            uint64_t v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s Unable to determine agent uuid for %s/%s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          if (!v13) {
            goto LABEL_40;
          }
          goto LABEL_39;
        }

        if (v20)
        {
          *(_DWORD *)__int128 buf = 136446722;
          __int16 v25 = "nw_socks5_connection_assert_prefer_wifi";
          __int16 v26 = 2080;
          __int16 v27 = "com.apple.networkrelay";
          __int16 v28 = 2080;
          __int16 v29 = "PreferWiFi";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s Unable to determine agent uuid for %s/%s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446722;
          __int16 v25 = "nw_socks5_connection_assert_prefer_wifi";
          __int16 v26 = 2080;
          __int16 v27 = "com.apple.networkrelay";
          __int16 v28 = 2080;
          __int16 v29 = "PreferWiFi";
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s Unable to determine agent uuid for %s/%s, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    if (!v13)
    {
LABEL_40:

LABEL_41:
      goto LABEL_42;
    }

void sub_181ED364C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 ___ZL39nw_socks5_connection_assert_prefer_wifiP31NWConcrete_nw_socks5_connection_block_invoke( uint64_t a1, int a2, xpc_object_t xdict)
{
  size_t length = 0LL;
  data = (__n128 *)xpc_dictionary_get_data(xdict, "data", &length);
  if (data
    && length >= 0xD8
    && length == data[13].n128_u32[1] + 216LL
    && !strcmp((const char *)&data[1], "com.apple.networkrelay")
    && !strcmp((const char *)&data[3], "PreferWiFi"))
  {
    __n128 result = *data;
    *(__n128 *)*(void *)(a1 + 32) = *data;
  }

  return result;
}

void nw_socks5_connection_outer_connection_read_on_queue(NWConcrete_nw_socks5_connection *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if (gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      nw_path_status_t v8 = "nw_socks5_connection_outer_connection_read_on_queue";
      __int16 v9 = 2114;
      int v10 = v1;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ reading on outer connection",  buf,  0x16u);
    }
  }

  sc_out_connection = v1->sc_out_connection;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___ZL51nw_socks5_connection_outer_connection_read_on_queueP31NWConcrete_nw_socks5_connection_block_invoke;
  v5[3] = &unk_189BBF198;
  id v3 = v1;
  uint64_t v6 = v3;
  nw_connection_receive_internal(sc_out_connection, 0LL, 1u, 0xFFFFFFFF, v5);
}

void sub_181ED3844( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL51nw_socks5_connection_outer_connection_read_on_queueP31NWConcrete_nw_socks5_connection_block_invoke( uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  uint64_t v77 = *MEMORY[0x1895F89C0];
  __int16 v9 = a2;
  id v10 = a3;
  id v11 = a5;
  id v12 = v11;
  if (v11)
  {
    uint64_t v13 = v11;
    int v14 = v13[3];
  }

  else
  {
    int v14 = 0;
  }

  uint64_t v15 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v15 + 56) != 255 && (*(_BYTE *)(v15 + 160) & 2) == 0)
  {
    if (v9)
    {
      size_t size = dispatch_data_get_size(v9);
      size_t v17 = size;
      if (!v14 && size)
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          os_log_type_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v51 = *(void *)(a1 + 32);
            __int16 v52 = "not";
            os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
            __int16 v67 = 2114;
            *(_DWORD *)__int128 buf = 136446978;
            if (a4) {
              __int16 v52 = "is";
            }
            uint64_t v68 = v51;
            __int16 v69 = 2048;
            uint32_t v70 = (const char *)v17;
            __int16 v71 = 2082;
            int v72 = v52;
            _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ read %zu bytes %{public}s_complete from outer connection",  buf,  0x2Au);
          }

          uint64_t v15 = *(void *)(a1 + 32);
        }

        *(void *)(v15 + 184) += v17;
        os_log_type_t v18 = (nw_content_context *)&__block_literal_global_41831;
        id v19 = &__block_literal_global_41831;
        uint64_t v20 = *(void *)(a1 + 32);
        if (!a4 || (*(_BYTE *)(v20 + 160) & 0x20) != 0)
        {
          char v22 = 0;
        }

        else
        {
          id v21 = &__block_literal_global_3_41839;

          uint64_t v20 = *(void *)(a1 + 32);
          char v22 = 1;
          os_log_type_t v18 = (nw_content_context *)&__block_literal_global_3_41839;
        }

        id WeakRetained = objc_loadWeakRetained((id *)(v20 + 24));
        nw_socks5_connection_increment_busy_on_queue(*(void **)(a1 + 32), WeakRetained);
        os_log_type_t v35 = *(void **)(a1 + 32);
        __int16 v36 = (nw_connection *)v35[4];
        v55[0] = MEMORY[0x1895F87A8];
        v55[1] = 3221225472LL;
        v55[2] = ___ZL51nw_socks5_connection_outer_connection_read_on_queueP31NWConcrete_nw_socks5_connection_block_invoke_162;
        v55[3] = &unk_189BB8260;
        char v56 = v35;
        id v33 = WeakRetained;
        char v59 = v22;
        id v57 = v33;
        size_t v58 = v17;
        nw_connection_send(v36, v9, v18, 1, v55);

        goto LABEL_30;
      }

      if (v14) {
        goto LABEL_16;
      }
    }

    else if (v14)
    {
      size_t v17 = 0LL;
LABEL_16:
      switch(v14)
      {
        case 6:
        case 32:
        case 49:
        case 50:
        case 51:
        case 53:
        case 54:
        case 57:
        case 60:
        case 61:
        case 65:
        case 96:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v23 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            uint64_t v24 = *(void *)(a1 + 32);
            __int16 v25 = "not";
            os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
            *(_DWORD *)__int128 buf = 136447234;
            __int16 v67 = 2114;
            if (a4) {
              __int16 v25 = "is";
            }
            uint64_t v68 = v24;
            __int16 v69 = 2048;
            uint32_t v70 = (const char *)v17;
            __int16 v71 = 2082;
            int v72 = v25;
            __int16 v73 = 1024;
            int v74 = v14;
            _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ out connection read error (data len %zu) %{public}s_complete %{darwin.errno}d",  buf,  0x30u);
          }

          goto LABEL_27;
        default:
          __nwlog_obj();
          int v37 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v38 = *(void *)(a1 + 32);
          uint64_t v39 = "not";
          __int16 v67 = 2114;
          *(_DWORD *)__int128 buf = 136447234;
          os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
          if (a4) {
            uint64_t v39 = "is";
          }
          uint64_t v68 = v38;
          __int16 v69 = 2048;
          uint32_t v70 = (const char *)v17;
          __int16 v71 = 2082;
          __int16 v54 = v39;
          int v72 = v39;
          __int16 v73 = 1024;
          int v74 = v14;
          char v40 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v63 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              uint64_t v43 = *(void *)(a1 + 32);
              *(_DWORD *)__int128 buf = 136447234;
              os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
              __int16 v67 = 2114;
              uint64_t v68 = v43;
              __int16 v69 = 2048;
              uint32_t v70 = (const char *)v17;
              __int16 v71 = 2082;
              int v72 = v54;
              __int16 v73 = 1024;
              int v74 = v14;
              _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s %{public}@ out connection read error (data len %zu) %{public}s_complete %{darwin.errno}d",  buf,  0x30u);
            }
          }

          else if (v63)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            int v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v53 = type;
            BOOL v45 = os_log_type_enabled(v41, type);
            if (backtrace_string)
            {
              if (v45)
              {
                uint64_t v46 = *(void *)(a1 + 32);
                *(_DWORD *)__int128 buf = 136447490;
                os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
                __int16 v67 = 2114;
                uint64_t v68 = v46;
                __int16 v69 = 2048;
                uint32_t v70 = (const char *)v17;
                __int16 v71 = 2082;
                int v72 = v54;
                __int16 v73 = 1024;
                int v74 = v14;
                __int16 v75 = 2082;
                BOOL v76 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v41,  v53,  "%{public}s %{public}@ out connection read error (data len %zu) %{public}s_complete %{darwin.errno}d, d umping backtrace:%{public}s",  buf,  0x3Au);
              }

              free(backtrace_string);
              goto LABEL_50;
            }

            if (v45)
            {
              uint64_t v49 = *(void *)(a1 + 32);
              *(_DWORD *)__int128 buf = 136447234;
              os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
              __int16 v67 = 2114;
              uint64_t v68 = v49;
              __int16 v69 = 2048;
              uint32_t v70 = (const char *)v17;
              __int16 v71 = 2082;
              int v72 = v54;
              __int16 v73 = 1024;
              int v74 = v14;
              _os_log_impl( &dword_181A5C000,  v41,  v53,  "%{public}s %{public}@ out connection read error (data len %zu) %{public}s_complete %{darwin.errno}d, no backtrace",  buf,  0x30u);
            }
          }

          else
          {
            __nwlog_obj();
            int v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v47 = type;
            if (os_log_type_enabled(v41, type))
            {
              uint64_t v48 = *(void *)(a1 + 32);
              *(_DWORD *)__int128 buf = 136447234;
              os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
              __int16 v67 = 2114;
              uint64_t v68 = v48;
              __int16 v69 = 2048;
              uint32_t v70 = (const char *)v17;
              __int16 v71 = 2082;
              int v72 = v54;
              __int16 v73 = 1024;
              int v74 = v14;
              _os_log_impl( &dword_181A5C000,  v41,  v47,  "%{public}s %{public}@ out connection read error (data len %zu) %{public}s_complete %{darwin.errno}d, bac ktrace limit exceeded",  buf,  0x30u);
            }
          }

LABEL_50:
          if (v40) {
            free(v40);
          }
LABEL_27:
          id v29 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 24LL));
          nw_socks5_connection_increment_busy_on_queue(*(void **)(a1 + 32), v29);
          __int16 v30 = *(void **)(a1 + 32);
          uint64_t v31 = (nw_connection *)v30[4];
          completion[0] = MEMORY[0x1895F87A8];
          completion[1] = 3221225472LL;
          completion[2] = ___ZL51nw_socks5_connection_outer_connection_read_on_queueP31NWConcrete_nw_socks5_connection_block_invoke_161;
          completion[3] = &unk_189BB81E8;
          char v61 = v30;
          id v32 = v29;
          id v62 = v32;
          nw_connection_send(v31, 0LL, (nw_content_context_t)&__block_literal_global_3_41839, 1, completion);

          id v33 = v61;
          os_log_type_t v18 = (nw_content_context *)v32;
LABEL_30:

          goto LABEL_31;
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v26 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      __int16 v28 = "not";
      os_log_type_t v66 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
      *(_DWORD *)__int128 buf = 136446722;
      if (a4) {
        __int16 v28 = "is";
      }
      __int16 v67 = 2114;
      uint64_t v68 = v27;
      __int16 v69 = 2082;
      uint32_t v70 = v28;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ out connection read data len 0 %{public}s_complete",  buf,  0x20u);
    }

    goto LABEL_27;
  }

void sub_181ED4074( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL51nw_socks5_connection_outer_connection_read_on_queueP31NWConcrete_nw_socks5_connection_block_invoke_161( uint64_t a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_socks5_connection_decrement_busy_on_queue(*(void **)(a1 + 32), *(void **)(a1 + 40));
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v27 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
      __int16 v28 = 2114;
      uint64_t v29 = v9;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ in connection write close done",  buf,  0x16u);
    }

    goto LABEL_12;
  }

  uint64_t v4 = v3;
  int v5 = v4[3];

  if ((v5 - 6) > 0x3B || ((1LL << (v5 - 6)) & 0x8C9B80004000001LL) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    uint64_t v12 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v27 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
    __int16 v28 = 2114;
    uint64_t v29 = v12;
    __int16 v30 = 1024;
    int v31 = v5;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          uint64_t v16 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v27 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
          __int16 v28 = 2114;
          uint64_t v29 = v16;
          __int16 v30 = 1024;
          int v31 = v5;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s %{public}@ in connection write close error %{darwin.errno}d",  buf,  0x1Cu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v19)
          {
            uint64_t v20 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v27 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
            __int16 v28 = 2114;
            uint64_t v29 = v20;
            __int16 v30 = 1024;
            int v31 = v5;
            __int16 v32 = 2082;
            id v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s %{public}@ in connection write close error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v19)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v27 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
          __int16 v28 = 2114;
          uint64_t v29 = v23;
          __int16 v30 = 1024;
          int v31 = v5;
          _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s %{public}@ in connection write close error %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          uint64_t v22 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v27 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
          __int16 v28 = 2114;
          uint64_t v29 = v22;
          __int16 v30 = 1024;
          int v31 = v5;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s %{public}@ in connection write close error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_181ED457C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL51nw_socks5_connection_outer_connection_read_on_queueP31NWConcrete_nw_socks5_connection_block_invoke_162( uint64_t a1, void *a2)
{
  v43[2] = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_socks5_connection_decrement_busy_on_queue(*(void **)(a1 + 32), *(void **)(a1 + 40));
  uint64_t v4 = *(void *)(a1 + 32);
  if (v3)
  {
    int v5 = v3;
    int v6 = v5[3];

    if (*(char *)(*(void *)(a1 + 32) + 160LL) < 0 && v6 == 55)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v39 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
        __int16 v40 = 2114;
        uint64_t v41 = v8;
        __int16 v42 = 2112;
        v43[0] = v5;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ ignoring write in error %@",  buf,  0x20u);
      }

      nw_socks5_connection_outer_connection_read_on_queue(*(NWConcrete_nw_socks5_connection **)(a1 + 32));
      goto LABEL_26;
    }

    if ((v6 - 6) <= 0x3B && ((1LL << (v6 - 6)) & 0x8C9B80004000001LL) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v19 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v39 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
        __int16 v40 = 2114;
        uint64_t v41 = v20;
        __int16 v42 = 1024;
        LODWORD(v43[0]) = v6;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ write in error %{darwin.errno}d",  buf,  0x1Cu);
      }

LABEL_22:
      nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
      goto LABEL_26;
    }

    __nwlog_obj();
    os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v22 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v39 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
    __int16 v40 = 2114;
    uint64_t v41 = v22;
    __int16 v42 = 1024;
    LODWORD(v43[0]) = v6;
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v23, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          uint64_t v26 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v39 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
          __int16 v40 = 2114;
          uint64_t v41 = v26;
          __int16 v42 = 1024;
          LODWORD(v43[0]) = v6;
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s %{public}@ write in error %{darwin.errno}d", buf, 0x1Cu);
        }
      }

      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        BOOL v29 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v29)
          {
            uint64_t v30 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v39 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
            __int16 v40 = 2114;
            uint64_t v41 = v30;
            __int16 v42 = 1024;
            LODWORD(v43[0]) = v6;
            WORD2(v43[0]) = 2082;
            *(void *)((char *)v43 + 6) = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v28,  "%{public}s %{public}@ write in error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_43;
        }

        if (v29)
        {
          uint64_t v33 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v39 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
          __int16 v40 = 2114;
          uint64_t v41 = v33;
          __int16 v42 = 1024;
          LODWORD(v43[0]) = v6;
          _os_log_impl( &dword_181A5C000,  v24,  v28,  "%{public}s %{public}@ write in error %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v24, type))
        {
          uint64_t v32 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v39 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
          __int16 v40 = 2114;
          uint64_t v41 = v32;
          __int16 v42 = 1024;
          LODWORD(v43[0]) = v6;
          _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s %{public}@ write in error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_181ED4BC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL59nw_socks5_connection_inner_connection_read_message_on_queueP31NWConcrete_nw_socks5_connection_block_invoke( uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v14 = a2;
  id v9 = a3;
  id v10 = a5;
  uint64_t v11 = v10;
  if (v10)
  {
    uint64_t v12 = (unsigned int *)v10;
    uint64_t v13 = v12[3];
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  nw_socks5_connection_inner_connection_read_handler_on_queue(*(void *)(a1 + 32), v14, a4, v13, 1LL);
}

void sub_181ED4C70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_socks5_connection_cancel_on_queueP31NWConcrete_nw_socks5_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke( uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(nw_connection **)(v4 + 144);
  if (v5)
  {
    nw_connection_cancel(v5);
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void **)(v6 + 144);
    *(void *)(v6 + 144) = 0LL;

    uint64_t v4 = *(void *)(a1 + 32);
  }

  if ((*(_BYTE *)(v4 + 160) & 0x90) != 0) {
    a2 = 0;
  }
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZL36nw_socks5_connection_cancel_on_queueP31NWConcrete_nw_socks5_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke_2;
  v8[3] = &unk_189BC93A0;
  id v9 = (id)v4;
  nw_socks5_connection_drain_and_cancel_in_on_queue(v9, a2, v8);
}

void sub_181ED4D30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void ___ZL36nw_socks5_connection_cancel_on_queueP31NWConcrete_nw_socks5_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke_2( uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  nw_parameters_t v2 = (void *)v1[2];
  if (v2)
  {
    v1[2] = 0LL;

    uint64_t v1 = *(void **)(a1 + 32);
  }

  uint64_t v4 = v1;
  uint64_t v5 = v4[6];
  if (v5)
  {
    uint64_t v7 = v4;
    (*(void (**)(void))(v5 + 16))();
    uint64_t v6 = (void *)v7[6];
    v7[6] = 0LL;

    uint64_t v4 = v7;
  }
}

void sub_181ED4DB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_socks5_connection_drain_and_cancel_in_on_queue(void *a1, char a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  uint64_t v6 = a3;
  if (!*((void *)v5 + 4))
  {
LABEL_8:
    v6[2](v6);
    goto LABEL_9;
  }

  if ((a2 & 1) == 0)
  {
    nw_socks5_connection_remove_prefer_wifi_request((NWConcrete_nw_socks5_connection *)v5);
    nw_connection_cancel(*((nw_connection_t *)v5 + 4));
    id v9 = (void *)*((void *)v5 + 4);
    *((void *)v5 + 4) = 0LL;

    id v10 = (void *)*((void *)v5 + 21);
    if (v10)
    {
      uint64_t v11 = v10;
      nw_connection_cancel_inner(v11, 1);

      uint64_t v12 = (void *)*((void *)v5 + 21);
      *((void *)v5 + 21) = 0LL;
    }

    goto LABEL_8;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 136446466;
    size_t v17 = "nw_socks5_connection_drain_and_cancel_in_on_queue";
    __int16 v18 = 2114;
    id v19 = v5;
    _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_INFO, "%{public}s %{public}@ draining inner", buf, 0x16u);
  }

  uint64_t v8 = (void *)*((void *)v5 + 4);
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  v13[2] = ___ZL49nw_socks5_connection_drain_and_cancel_in_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvvE_block_invoke;
  v13[3] = &unk_189BC5F58;
  id v14 = v5;
  int v15 = v6;
  nw_connection_receive_internal(v8, 0LL, 1u, 0xFFFFFFFF, v13);

LABEL_9:
}