void __nw_mem_cache_update_set_timer_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  os_log_s *v4;
  os_log_type_t v5;
  const char *v6;
  BOOL v7;
  char *v8;
  os_log_type_t v9;
  os_log_type_t log;
  os_log_s *loga;
  os_log_type_t logb;
  os_log_s *v13;
  const char *backtrace_string;
  os_log_s *v15;
  char v16;
  os_log_type_t type;
  _BYTE block[24];
  void *v19;
  uint64_t v20;
  uint64_t v21;
  v21 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_cache_lock);
  v0 = nw_mem_cache_head;
  if (nw_mem_cache_head)
  {
    v1 = MEMORY[0x1895F87A8];
    while (1)
    {
      v2 = *(void *)(v0 + 216);
      if (!v2) {
        break;
      }
      *(void *)block = v1;
      *(void *)&block[8] = 0x40000000LL;
      *(void *)&block[16] = ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke;
      v19 = &__block_descriptor_tmp_7_54993;
      v20 = v0;
      if (*(void *)(v2 + 272))
      {
        else {
          dispatch_async(*(dispatch_queue_t *)(v2 + 272), block);
        }
      }

      else
      {
        ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke((uint64_t)block);
      }

LABEL_4:
      v0 = *(void *)(v0 + 80);
      if (!v0) {
        goto LABEL_26;
      }
    }

    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_mem_cache_update";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v3, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v13 = (os_log_s *)__nwlog_obj();
        log = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_mem_cache_update";
        v4 = v13;
        v5 = log;
        v6 = "%{public}s called with null nwm->nwm_region";
        goto LABEL_23;
      }

      if (!v16)
      {
        v15 = (os_log_s *)__nwlog_obj();
        logb = type;
        if (!os_log_type_enabled(v15, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_mem_cache_update";
        v4 = v15;
        v5 = logb;
        v6 = "%{public}s called with null nwm->nwm_region, backtrace limit exceeded";
        goto LABEL_23;
      }

      backtrace_string = __nw_create_backtrace_string();
      loga = (os_log_s *)__nwlog_obj();
      v9 = type;
      v7 = os_log_type_enabled(loga, type);
      v8 = (char *)backtrace_string;
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)block = 136446466;
          *(void *)&block[4] = "nw_mem_cache_update";
          *(_WORD *)&block[12] = 2082;
          *(void *)&block[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  loga,  v9,  "%{public}s called with null nwm->nwm_region, dumping backtrace:%{public}s",  block,  0x16u);
          v8 = (char *)backtrace_string;
        }

        free(v8);
        goto LABEL_24;
      }

      if (v7)
      {
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_mem_cache_update";
        v4 = loga;
        v5 = v9;
        v6 = "%{public}s called with null nwm->nwm_region, no backtrace";
LABEL_23:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, block, 0xCu);
      }
    }

    os_unfair_lock_lock(a1 + 13);
    os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

  v6 = (os_unfair_lock_s *)*((id *)v5 + 8);
  v7 = v6;
  if (v6)
  {
    if (v6 != (os_unfair_lock_s *)&__block_literal_global_5_41854
      && v6 != (os_unfair_lock_s *)&__block_literal_global_4
      && v6 != (os_unfair_lock_s *)&__block_literal_global_3_41839
      && v6 != (os_unfair_lock_s *)&__block_literal_global_41831)
    {
      os_unfair_lock_lock(v6 + 28);
      if (!*(void *)&v7[18]._os_unfair_lock_opaque)
      {
        *(void *)&v7[18]._os_unfair_lock_opaque = mach_absolute_time();
        v8 = *(void **)&v7[24]._os_unfair_lock_opaque;
        *(void *)&v7[24]._os_unfair_lock_opaque = 0LL;
      }

      os_unfair_lock_unlock(v7 + 28);
    }

    goto LABEL_12;
  }

  __nwlog_obj();
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v45 = "nw_content_context_mark_enqueue_time";
  v27 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v27, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_content_context_mark_enqueue_time";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v42)
    {
      v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v34 = type;
      v35 = os_log_type_enabled(v28, type);
      if (v33)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_content_context_mark_enqueue_time";
          v46 = 2082;
          v47 = v33;
          _os_log_impl( &dword_181A5C000,  v28,  v34,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v33);
        goto LABEL_74;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_content_context_mark_enqueue_time";
        _os_log_impl(&dword_181A5C000, v28, v34, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v39 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_content_context_mark_enqueue_time";
        _os_log_impl( &dword_181A5C000,  v28,  v39,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    v2 = *((id *)v4 + 1);

    if (!v2) {
      return 0LL;
    }
  }

  if (v9) {
    v3 = v10;
  }
  else {
    v3 = 0LL;
  }
LABEL_16:

  return v3;
}

      os_unfair_lock_lock((os_unfair_lock_t)(v3 + 52));
      v4 = *(_DWORD *)(v3 + 48);
      goto LABEL_5;
    }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 56))(v11, 1LL, 1LL, v12);
  swift_beginAccess();
  sub_181C1D268((uint64_t)v11, v16, qword_18C58C2B8);
  swift_endAccess();
  *(void *)(v1 + 24) = 0LL;
  swift_release();
  v17 = v1 + OBJC_IVAR____TtC7Network7Browser_endpointSelectionContinuation;
  swift_beginAccess();
  if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(v17, 1LL, v5))
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, v17, v5);
    sub_18264ED9C();
    sub_181C1D2AC();
    v18 = swift_allocError();
    sub_18264E9B8();
    v30 = v18;
    sub_18264ED78();
    (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  }

  v19 = OBJC_IVAR____TtC7Network7Browser_endpointSelectionTask;
  if (*(void *)(v1 + OBJC_IVAR____TtC7Network7Browser_endpointSelectionTask))
  {
    type metadata accessor for NWEndpoint();
    swift_retain();
    __swift_instantiateConcreteTypeFromMangledName(&qword_18C58D6A0);
    sub_18264EE5C();
    swift_release();
  }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v6 + 56))(v4, 1LL, 1LL, v5);
  swift_beginAccess();
  sub_181C1D268((uint64_t)v4, v17, &qword_18C58CDD0);
  swift_endAccess();
  *(void *)(v1 + v19) = 0LL;
  swift_release();
  v20 = *(void *)(v1 + OBJC_IVAR____TtC7Network7Browser_browser);
  if (nw_utilities_minos_atleast())
  {
    v21 = *(os_unfair_lock_s **)(v20 + 24);
    v22 = (uint64_t *)&v21[4];
    v23 = v21 + 20;
    os_unfair_lock_lock(v21 + 20);
    sub_181BD24E8(v22);
    os_unfair_lock_unlock(v23);
  }

  nw_browser_cancel(*(nw_browser_t *)(v20 + 16));
}

      v1 = (void *)*v1;
      if (!v1) {
        return;
      }
    }

    if (nw_protocols_are_equal(*(void **)(a1 + 56), *(void **)(v4 + 16)))
    {
      v5 = *(void *)(v4 + 24);
      if (v5 && (v6 = *(uint64_t (**)(uint64_t, uint64_t, void))(v5 + 224)) != 0LL)
      {
        v7 = (id *)v6(v4, 4LL, 0LL);
        v8 = (uint64_t *)v7;
        if (v7)
        {
          v9 = (os_log_s *)*v7;
          if (v9)
          {
            v10 = v9;
            *(void *)buf = 0LL;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000LL;
            LOBYTE(v42) = 0;
            v32[0] = v3;
            v32[1] = 3221225472LL;
            v32[2] = __nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke_8;
            v32[3] = &unk_189BC7960;
            v33 = *(id *)(a1 + 40);
            v34 = buf;
            nw_array_apply((unsigned __int8 *)v10, (uint64_t)v32);
            nw_array_remove_all_objects(*v8);
            if (*v8) {
              os_release((void *)*v8);
            }
            free(v8);
            if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
            {
              *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v4;

              _Block_object_dispose(buf, 8);
              return;
            }

            if (gLogDatapath)
            {
              __nwlog_obj();
              v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
              {
                v31 = *(void *)(a1 + 32);
                *(_DWORD *)v35 = 136446722;
                v36 = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
                v37 = 2112;
                v38 = v31;
                v39 = 2048;
                v40 = v4;
                _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p did not match",  v35,  0x20u);
              }
            }

            _Block_object_dispose(buf, 8);
          }

          else
          {
            if (!gLogDatapath) {
              goto LABEL_4;
            }
            __nwlog_obj();
            v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
            {
              v19 = *(void *)(a1 + 32);
              v20 = *(void *)(a1 + 56);
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v19;
              *(_WORD *)&buf[22] = 2048;
              v42 = v4;
              v43 = 2080;
              v44 = v20;
              v14 = v10;
              v15 = "%{public}s %@ instance %p of %s not eligible, missing required quic_info";
              goto LABEL_35;
            }
          }
        }

        else
        {
          if (!gLogDatapath) {
            goto LABEL_4;
          }
          __nwlog_obj();
          v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            v17 = *(void *)(a1 + 32);
            v18 = *(void *)(a1 + 56);
            *(_DWORD *)buf = 136446978;
            *(void *)&buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v17;
            *(_WORD *)&buf[22] = 2048;
            v42 = v4;
            v43 = 2080;
            v44 = v18;
            v14 = v10;
            v15 = "%{public}s %@ instance %p of %s not eligible, missing quic_info";
            goto LABEL_35;
          }
        }
      }

      else
      {
        if (!gLogDatapath) {
          goto LABEL_4;
        }
        __nwlog_obj();
        v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v25 = *(void *)(a1 + 32);
          v26 = *(void *)(a1 + 56);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v25;
          *(_WORD *)&buf[22] = 2048;
          v42 = v4;
          v43 = 2080;
          v44 = v26;
          v14 = v10;
          v15 = "%{public}s %@ instance %p of %s not eligible, missing required callbacks";
          goto LABEL_35;
        }
      }
    }

    else
    {
      if (!gLogDatapath) {
        goto LABEL_4;
      }
      __nwlog_obj();
      v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v11 = *(void *)(a1 + 32);
        v12 = *(void *)(v4 + 16);
        v13 = *(void *)(a1 + 56);
        *(_DWORD *)buf = 136447234;
        *(void *)&buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v11;
        *(_WORD *)&buf[22] = 2048;
        v42 = v4;
        v43 = 2080;
        v44 = v12;
        v45 = 2080;
        v46 = v13;
        v14 = v10;
        v15 = "%{public}s %@ instance %p (%s) not eligible for joining by %s, identifier doesn't match";
        v16 = 52;
        goto LABEL_36;
      }
    }

    goto LABEL_17;
  }

    v6 = nw_dictionary_copy(v5);
    v7 = *v4;
    *v4 = (void *)v6;

    goto LABEL_5;
  }

  __nwlog_obj();
  v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v22 = "strict_calloc";
  v23 = 2048;
  v24 = 1LL;
  v25 = 2048;
  v26 = 16LL;
  v14 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    v5 = *a2;
    if (!*a2) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

  v2 = 0LL;
  return v2;
}

    v4 = os_retain(v4);
    goto LABEL_5;
  }

  v12 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v19 = "strict_calloc";
  v20 = 2048;
  v21 = 1LL;
  v22 = 2048;
  v23 = 40LL;
  v13 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    v4 = (void *)*a2;
    if (!*a2) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

  if ((v4 & 4) == 0)
  {
    v6 = 0LL;
    if ((v4 & 8) != 0)
    {
      v7 = *(void *)(a2 + 16);
      if (!*(_BYTE *)(a2 + 24)) {
        v7 = -1LL;
      }
      if (v7 < a4) {
        a4 = v7;
      }
      v20 = a4;
    }

    goto LABEL_37;
  }

  if ((v4 & 0x10000) != 0)
  {
LABEL_32:
    v12 = *(void *)a2;
    if (!*(_BYTE *)(a2 + 8)) {
      v12 = 0LL;
    }
    v11 = v12 >= a4;
    v6 = v12 - a4;
    if (!v11) {
      v6 = 0LL;
    }
    v18 = v6;
    goto LABEL_37;
  }

  v6 = 0LL;
LABEL_37:
  v13 = v6 + a4;
  v17[0] = &v19;
  v17[1] = result;
  v17[2] = &v18;
  v17[3] = a2;
  v17[4] = &v20;
  v17[5] = &v21;
  v11 = *(void *)a2 >= v13;
  v14 = *(void *)a2 - v13;
  if (v14 == 0 || !v11 || *(_BYTE *)(a2 + 8) == 0) {
    v16 = 0LL;
  }
  else {
    v16 = v14;
  }
  if ((v4 & 0x2000) != 0)
  {
  }

  else
  {
    for (; v16; --v16)
      std::ostream::put();
    return nw_printf_write::$_0::operator()((unint64_t)v17);
  }

  return result;
}

  if (*(_BYTE *)(a1 + 56)) {
    os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 16));
  }
  return 1LL;
}

  if (*(_BYTE *)(a1 + 40)) {
    os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 16));
  }
  return 1LL;
}

          *(_DWORD *)(a2 + 136) = 0;
LABEL_5:
          v10 = v7;
          if (v7 >= v8) {
            goto LABEL_219;
          }
          continue;
        }

        if (!*(_DWORD *)(a2 + 152))
        {
          if (guarantee_out_bytes(a1, a2, v21))
          {
            v161 = 3646;
            goto LABEL_348;
          }

          v128 = 7;
LABEL_202:
          *(_DWORD *)(a2 + 136) = v128;
          goto LABEL_5;
        }

        if (!guarantee_out_bytes(a1, a2, v21 + (v21 >> 1)))
        {
          *(_DWORD *)(a2 + 184) = 0;
          v128 = 6;
          goto LABEL_202;
        }

        v161 = 3639;
LABEL_348:
        v10 = v7;
LABEL_349:
        *(_DWORD *)(a1 + 332) = v161;
        *(_DWORD *)(a1 + 328) = 0;
        v162 = *(void *)(a2 + 40);
        *(void *)(a1 + 336) = &v10[*(void *)(a2 + 48)] - &v4[*(void *)(a2 + 56)];
        *(void *)(a1 + 344) = v162;
        v163 = *(FILE **)(a1 + 48);
        if (v163)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v163);
          fprintf( *(FILE **)(a1 + 48),  "header block error on line %d, offset %llu, stream id %llu",  *(_DWORD *)(a1 + 332),  *(void *)(a1 + 336),  *(void *)(a1 + 344));
          fputc(10, *(FILE **)(a1 + 48));
        }

        return 3LL;
      case 6:
        v24 = *(_DWORD *)(a2 + 140);
        else {
          v25 = *(_DWORD *)(a2 + 140);
        }
        if (!v25)
        {
          v161 = 3663;
          goto LABEL_349;
        }

        v26 = *(void *)(a2 + 80);
        if (!v26) {
          goto LABEL_352;
        }
        if (*(_DWORD *)(a2 + 88)) {
          v27 = *(_DWORD *)(v26 + 20) - *(_DWORD *)(v26 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          v27 = *(_DWORD *)(a2 + 92);
        }
        v52 = *(unsigned __int16 *)(v26 + 26);
        if (v52 < v27) {
          goto LABEL_353;
        }
        v53 = lsqpack_huff_decode( v10,  v25,  (char *)(*(void *)v26 + *(int *)(v26 + 16) + v27),  v52 - v27,  v168,  v24 <= (int)v8 - (int)v10);
        v7 = &v10[v54];
        v55 = *(_DWORD *)(a2 + 140);
        *(_DWORD *)(a2 + 140) = v55 - v54;
        if ((_DWORD)v53 == 2)
        {
          if (HIDWORD(v53)) {
            *(_DWORD *)(a2 + 92) += HIDWORD(v53);
          }
          if (header_out_grow_buf(a1, a2))
          {
            v161 = 3688;
            goto LABEL_348;
          }

          goto LABEL_5;
        }

        if ((_DWORD)v53 == 1) {
          goto LABEL_83;
        }
        if ((_DWORD)v53)
        {
          v161 = 3691;
          goto LABEL_348;
        }

        if (header_out_write_value((int *)a1, a2, SHIDWORD(v53), v55 == v54))
        {
          v161 = 3674;
          goto LABEL_348;
        }

        if (!*(_DWORD *)(a2 + 140)) {
          goto LABEL_4;
        }
        goto LABEL_5;
      case 7:
        v28 = v8;
        v29 = v9;
        v30 = v28;
        v31 = (_DWORD)v28 - (_DWORD)v10;
        v32 = *(_DWORD *)(a2 + 140);
        if (v32 >= v31) {
          v33 = v31;
        }
        else {
          v33 = v32;
        }
        if (!(_DWORD)v33)
        {
          v161 = 3697;
          goto LABEL_349;
        }

        v34 = *(void *)(a2 + 80);
        if (!v34) {
          goto LABEL_352;
        }
        if (*(_DWORD *)(a2 + 88)) {
          v35 = *(_DWORD *)(v34 + 20) - *(_DWORD *)(v34 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          v35 = *(_DWORD *)(a2 + 92);
        }
        v56 = *(unsigned __int16 *)(v34 + 26);
        v57 = v56 >= v35;
        v58 = v56 - v35;
        if (!v57) {
          goto LABEL_353;
        }
        if (v58 < v33)
        {
          v161 = 3700;
          goto LABEL_349;
        }

        memcpy((void *)(*(void *)v34 + *(int *)(v34 + 16) + v35), v10, v33);
        if (header_out_write_value((int *)a1, a2, v33, *(_DWORD *)(a2 + 140) == v33))
        {
          v161 = 3704;
          goto LABEL_349;
        }

        v7 = &v10[v33];
        v59 = *(_DWORD *)(a2 + 140) - v33;
        *(_DWORD *)(a2 + 140) = v59;
        if (!v59) {
          *(_DWORD *)(a2 + 136) = 0;
        }
        goto LABEL_92;
      case 8:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_105;
        }
        v36 = 0;
        v16 = *(void *)(a2 + 176);
        v17 = *(_DWORD *)(a2 + 164);
        v7 = v10;
        goto LABEL_203;
      case 9:
        v37 = *(_DWORD *)(a2 + 140);
        else {
          v38 = *(_DWORD *)(a2 + 140);
        }
        if (!v38)
        {
          v161 = 3736;
          goto LABEL_349;
        }

        v39 = *(void *)(a2 + 80);
        if (!v39) {
          goto LABEL_352;
        }
        if (*(_DWORD *)(a2 + 88)) {
          v40 = *(_DWORD *)(v39 + 20) - *(_DWORD *)(v39 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          v40 = *(_DWORD *)(a2 + 92);
        }
        v60 = *(unsigned __int16 *)(v39 + 26);
        if (v60 < v40) {
          goto LABEL_353;
        }
        v53 = lsqpack_huff_decode( v10,  v38,  (char *)(*(void *)v39 + *(int *)(v39 + 16) + v40),  v60 - v40,  v168,  v37 <= (int)v8 - (int)v10);
        v7 = &v10[v61];
        v62 = *(_DWORD *)(a2 + 140);
        *(_DWORD *)(a2 + 140) = v62 - v61;
        if ((_DWORD)v53 == 2)
        {
          if (HIDWORD(v53)) {
            *(_DWORD *)(a2 + 92) += HIDWORD(v53);
          }
          if (header_out_grow_buf(a1, a2))
          {
            v161 = 3761;
            goto LABEL_348;
          }
        }

        else if ((_DWORD)v53 == 1)
        {
LABEL_83:
          if (HIDWORD(v53)) {
            *(_DWORD *)(a2 + 92) += HIDWORD(v53);
          }
        }

        else
        {
          if ((_DWORD)v53)
          {
            v161 = 3764;
            goto LABEL_348;
          }

          if (header_out_write_name((int *)a1, a2, SHIDWORD(v53), v62 == v61))
          {
            v161 = 3747;
            goto LABEL_348;
          }

          if (!*(_DWORD *)(a2 + 140)) {
            goto LABEL_190;
          }
        }

        goto LABEL_5;
      case 0xA:
        v41 = v8;
        v29 = v9;
        v30 = v41;
        v42 = (_DWORD)v41 - (_DWORD)v10;
        v43 = *(_DWORD *)(a2 + 140);
        if (v43 >= v42) {
          v44 = v42;
        }
        else {
          v44 = v43;
        }
        if (!(_DWORD)v44)
        {
          v161 = 3770;
          goto LABEL_349;
        }

        v45 = *(void *)(a2 + 80);
        if (!v45) {
LABEL_352:
        }
          __assert_rtn("get_dst", "lsqpack.c", 3359, "read_ctx->hbrc_out.xhdr");
        if (*(_DWORD *)(a2 + 88)) {
          v46 = *(_DWORD *)(v45 + 20) - *(_DWORD *)(v45 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          v46 = *(_DWORD *)(a2 + 92);
        }
        v63 = *(unsigned __int16 *)(v45 + 26);
        v57 = v63 >= v46;
        v64 = v63 - v46;
        if (!v57) {
LABEL_353:
        }
          __assert_rtn("get_dst", "lsqpack.c", 3366, "read_ctx->hbrc_out.xhdr->val_len >= off");
        if (v64 < v44)
        {
          v161 = 3773;
          goto LABEL_349;
        }

        memcpy((void *)(*(void *)v45 + *(int *)(v45 + 16) + v46), v10, v44);
        if (header_out_write_name((int *)a1, a2, v44, *(_DWORD *)(a2 + 140) == v44))
        {
          v161 = 3777;
          goto LABEL_349;
        }

        v7 = &v10[v44];
        v65 = *(_DWORD *)(a2 + 140) - v44;
        *(_DWORD *)(a2 + 140) = v65;
        if (!v65) {
          *(_DWORD *)(a2 + 136) = 4;
        }
LABEL_92:
        v9 = v29;
        v8 = v30;
        goto LABEL_5;
      case 0xB:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_55;
        }
        v47 = 0;
        v16 = *(void *)(a2 + 176);
        v17 = *(_DWORD *)(a2 + 164);
        v7 = v10;
        goto LABEL_111;
      default:
        __assert_rtn("parse_header_data", "lsqpack.c", 3826, "0");
    }
  }

      v5 = *v4;
      v6 = *(void *)((char *)a3 + v5);
      v8 = *(void *)((char *)a3 + *v7);
      if (v6 >= v8) {
        goto LABEL_85;
      }
    }

    v16 = 0LL;
LABEL_38:
    *v14 = 1;
    goto LABEL_39;
  }

    return (BOOL)v4;
  }

  __break(1u);
  return result;
}

  v6 = 0LL;
LABEL_5:

  return v6;
}

    WeakRetained = 0LL;
  }

  return WeakRetained;
}

    v5 = nw_protocol_options_copy(v5);
    goto LABEL_5;
  }

  __nwlog_obj();
  v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v30 = "strict_calloc";
  v31 = 2048;
  v32 = 1LL;
  v33 = 2048;
  v34 = 48LL;
  v24 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v24);
  if (!result)
  {
    free(v24);
    v5 = *(NWConcrete_nw_protocol_options **)a2;
    if (!*(void *)a2) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_http2_protocol_close";
    v30 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v31 = (os_log_s *)__nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null http2";
      goto LABEL_130;
    }

    if (!v69)
    {
      v31 = (os_log_s *)__nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_130;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v31 = (os_log_s *)__nwlog_obj();
    v32 = type;
    v48 = os_log_type_enabled(v31, type);
    if (!backtrace_string)
    {
      if (!v48) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null http2, no backtrace";
      goto LABEL_130;
    }

    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null http2, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_131;
  }

  if (!a3)
  {
LABEL_48:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_http2_protocol_close";
    v30 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v31 = (os_log_s *)__nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null input_protocol";
      goto LABEL_130;
    }

    if (!v69)
    {
      v31 = (os_log_s *)__nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_130;
    }

    v49 = (char *)__nw_create_backtrace_string();
    v31 = (os_log_s *)__nwlog_obj();
    v32 = type;
    v50 = os_log_type_enabled(v31, type);
    if (v49)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = v49;
        _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v49);
      if (!v30) {
        return;
      }
LABEL_132:
      free(v30);
      return;
    }

    if (v50)
    {
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null input_protocol, no backtrace";
LABEL_130:
      _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
    }

LABEL_24:
    if (v3) {
      free(v3);
    }
    goto LABEL_4;
  }

    if (v8) {
      free(v8);
    }
    LODWORD(v5) = -1;
    *((_DWORD *)v3 + 11) = -1;
    if (!*((_DWORD *)v3 + 8)) {
      goto LABEL_139;
    }
    goto LABEL_27;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v147 = "nw_hash_table_apply";
  v131 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v144 = 0;
  if (__nwlog_fault(v131, &type, &v144))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v132 = (os_log_s *)__nwlog_obj();
      v133 = type;
      if (!os_log_type_enabled(v132, type)) {
        goto LABEL_214;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v134 = "%{public}s called with invalid hash table";
LABEL_213:
      _os_log_impl(&dword_181A5C000, v132, v133, v134, buf, 0xCu);
      goto LABEL_214;
    }

    if (!v144)
    {
      v132 = (os_log_s *)__nwlog_obj();
      v133 = type;
      if (!os_log_type_enabled(v132, type)) {
        goto LABEL_214;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v134 = "%{public}s called with invalid hash table, backtrace limit exceeded";
      goto LABEL_213;
    }

    v139 = (char *)__nw_create_backtrace_string();
    v132 = (os_log_s *)__nwlog_obj();
    v133 = type;
    v140 = os_log_type_enabled(v132, type);
    if (!v139)
    {
      if (!v140) {
        goto LABEL_214;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v134 = "%{public}s called with invalid hash table, no backtrace";
      goto LABEL_213;
    }

    if (v140)
    {
      *(_DWORD *)buf = 136446466;
      v147 = "nw_hash_table_apply";
      v148 = 2082;
      v149 = v139;
      _os_log_impl( &dword_181A5C000,  v132,  v133,  "%{public}s called with invalid hash table, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v139);
  }

  if (v9) {
    free(v9);
  }
LABEL_7:
}

      free(backtrace_string);
    }
  }

    free(backtrace_string);
    goto LABEL_37;
  }

  if (!v3[18])
  {
LABEL_39:
    v6 = 0LL;
    goto LABEL_40;
  }

  v6 = (*((uint64_t (**)(id))v4 + 2))(v4);
LABEL_40:

  return v6;
}

  if (v8) {
    free(v8);
  }
LABEL_7:
}

      free(backtrace_string);
    }
  }

  if (v24) {
    free(v24);
  }
  a1 = 0LL;
LABEL_7:

  return a1;
}

    goto LABEL_25;
  }

  if ((*((_BYTE *)v5 + 268) & 0x20) == 0)
  {
LABEL_7:
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v9 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      if ((*((_BYTE *)v5 + 268) & 1) != 0) {
        v10 = "dry-run ";
      }
      else {
        v10 = "";
      }
      v11 = nw_endpoint_handler_copy_endpoint(v5);
      v12 = nw_endpoint_get_logging_description(v11);
      v13 = *((unsigned int *)v5 + 30);
      v14 = v12;
      else {
        v15 = off_189BBBBF0[v13];
      }
      v74 = v15;
      v16 = v5;
      v17 = (os_unfair_lock_s *)v16;
      v76 = v2;
      v18 = "path";
      switch(*((_DWORD *)v16 + 29))
      {
        case 0:
          break;
        case 1:
          v18 = "resolver";
          break;
        case 2:
          v18 = nw_endpoint_flow_mode_string(v16[31]);
          break;
        case 3:
          v18 = "proxy";
          break;
        case 4:
          v18 = "fallback";
          break;
        case 5:
          v18 = "transform";
          break;
        default:
          v18 = "unknown-mode";
          break;
      }

      v19 = v17 + 28;
      v20 = v17;
      os_unfair_lock_lock(v17 + 28);
      v21 = v20[8];
      os_unfair_lock_unlock(v19);

      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      v81 = 2082;
      v82 = v5 + 21;
      v83 = 2082;
      v84 = v10;
      v85 = 2082;
      v86 = v14;
      v87 = 2082;
      v88 = v74;
      v89 = 2082;
      v90 = v18;
      v91 = 2114;
      v92 = v21;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);

      v2 = v76;
    }

    goto LABEL_24;
  }

    if (v9) {
      free(v9);
    }
    goto LABEL_26;
  }

  v3 = *(void **)(v1[19] + 48LL);
  if (!v3)
  {
LABEL_26:
    is_equal_unsafe = 0LL;
    goto LABEL_27;
  }

  v4 = v3;
  v5 = v4[1];

  v6 = (id)g_ip_definition;
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v6);

  if ((_DWORD)is_equal_unsafe) {
    is_equal_unsafe = nw_ip_options_get_local_address_preference(*(void **)(v2[19] + 48LL));
  }

LABEL_27:
  return is_equal_unsafe;
}

      free(backtrace_string);
    }
  }

    free(backtrace_string);
    goto LABEL_37;
  }

  v5 = (void *)*((void *)v3 + 24);
  if (!v5)
  {
LABEL_39:
    bytes_ptr = 0LL;
    goto LABEL_40;
  }

  *out_signature_length = xpc_data_get_length(v5);
  bytes_ptr = (const uint8_t *)xpc_data_get_bytes_ptr(v4[24]);
LABEL_40:

  return bytes_ptr;
}

    free(backtrace_string);
    goto LABEL_37;
  }

  v6 = (os_unfair_lock_s *)v3[3];
  if (!v6)
  {
LABEL_39:
    v9 = 0LL;
    goto LABEL_40;
  }

  v7 = v6 + 24;
  v8 = v6;
  os_unfair_lock_lock(v7);
  v9 = v8[6];
  os_unfair_lock_unlock(v7);

LABEL_40:
  return v9;
}

    free(backtrace_string);
    goto LABEL_37;
  }

  v6 = v4;
  v7 = *(_WORD *)(v6[13] + 108LL);

  if ((v7 & 4) != 0)
  {
LABEL_39:
    v9 = 0LL;
    goto LABEL_40;
  }

  v8 = v6;
  v9 = v8[20] != 0LL;

LABEL_40:
  return v9;
}

      free(backtrace_string);
    }
  }

  v11 = 1;
LABEL_31:

LABEL_32:
  _Block_object_dispose(buf, 8);
  if (!v11)
  {
LABEL_69:
    v17 = 0LL;
    goto LABEL_70;
  }

  v17 = 1LL;
LABEL_70:

  return v17;
}

      free(backtrace_string);
    }
  }

  if (v11) {
    free(v11);
  }
  v8 = 0LL;
LABEL_7:

  return v8;
}

  BYTE6(a1[3].output_handler) = nw_parameters_get_ip_protocol(v12);
  v13 = a2->handle;
  if (v13 == &nw_protocol_ref_counted_handle)
  {
    v14 = a2[1].callbacks;
    if (v14) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v14->add_input_handler + 1);
    }
  }

  v15 = a2->callbacks;
  if (v15)
  {
    get_local_endpoint = (uint64_t (*)(nw_protocol *))v15->get_local_endpoint;
    if (get_local_endpoint)
    {
      v17 = (nw_endpoint *)get_local_endpoint(a2);
      if (v13 != &nw_protocol_ref_counted_handle) {
        goto LABEL_30;
      }
      goto LABEL_138;
    }
  }

  __nwlog_obj();
  v31 = a2->identifier;
  if (!v31) {
    v31 = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)buf = 136446722;
  v134 = "__nw_protocol_get_local_endpoint";
  v135 = 2082;
  v136 = v31;
  v137 = 2048;
  v138 = a2;
  v32 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v131 = 0;
  if (__nwlog_fault(v32, &type, &v131))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v33 = (os_log_s *)__nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_135;
      }
      v35 = a2->identifier;
      if (!v35) {
        v35 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_local_endpoint";
      v135 = 2082;
      v136 = v35;
      v137 = 2048;
      v138 = a2;
      v36 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback";
LABEL_134:
      _os_log_impl(&dword_181A5C000, v33, v34, v36, buf, 0x20u);
      goto LABEL_135;
    }

    if (!v131)
    {
      v33 = (os_log_s *)__nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_135;
      }
      v55 = a2->identifier;
      if (!v55) {
        v55 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_local_endpoint";
      v135 = 2082;
      v136 = v55;
      v137 = 2048;
      v138 = a2;
      v36 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded";
      goto LABEL_134;
    }

    v44 = (char *)__nw_create_backtrace_string();
    v33 = (os_log_s *)__nwlog_obj();
    v34 = type;
    v45 = os_log_type_enabled(v33, type);
    if (!v44)
    {
      if (!v45) {
        goto LABEL_135;
      }
      v57 = a2->identifier;
      if (!v57) {
        v57 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_local_endpoint";
      v135 = 2082;
      v136 = v57;
      v137 = 2048;
      v138 = a2;
      v36 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace";
      goto LABEL_134;
    }

    if (v45)
    {
      v46 = a2->identifier;
      if (!v46) {
        v46 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446978;
      v134 = "__nw_protocol_get_local_endpoint";
      v135 = 2082;
      v136 = v46;
      v137 = 2048;
      v138 = a2;
      v139 = 2082;
      v140 = v44;
      _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v44);
  }

    free(v9);
    goto LABEL_25;
  }

  v13 = v5[32];
  *a3 = v13;
  memcpy(a2, v5 + 12, v13);
  v14 = 1LL;
LABEL_26:

  return v14;
}

      free(backtrace_string);
    }
  }

    if (v10) {
      free(v10);
    }
LABEL_26:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v31 = "nw_endpoint_handler_copy_resolved_endpoints";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v18, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_copy_resolved_endpoints";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }

      else if (v28)
      {
        v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        v22 = type;
        v23 = os_log_type_enabled(v19, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v31 = "nw_endpoint_handler_copy_resolved_endpoints";
            v32 = 2082;
            v33 = v21;
            _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v21);
          if (!v18) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_copy_resolved_endpoints";
          _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s Endpoint handler is not a resolver, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_copy_resolved_endpoints";
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v18)
    {
LABEL_45:
      v8 = 0LL;
      goto LABEL_46;
    }

  if (v17) {
    free(v17);
  }
  v14 = 0LL;
LABEL_7:

  return v14;
}

  if (v6) {
    free(v6);
  }
LABEL_7:
}

  if (v6) {
    free(v6);
  }
LABEL_7:
}

      free(backtrace_string);
    }
  }

                    v23 = v13[206];
                    if (v23)
                    {
                      v15 = v23 - 1;
                      goto LABEL_26;
                    }

    if (v6) {
      free(v6);
    }
    goto LABEL_26;
  }

  if (nw_data_transfer_report_get_state(v1) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_data_transfer_report_get_path_count";
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

LABEL_26:
    v3 = 0;
    goto LABEL_4;
  }

  v3 = *((_DWORD *)v2 + 11);
LABEL_4:

  return v3;
}

  if (v6) {
    free(v6);
  }
  v3 = 0;
LABEL_7:

  return v3;
}

          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v35 = a1[1].callbacks;
            if (v35)
            {
              v36 = (nw_protocol_callbacks *)((char *)v35 - 1);
              a1[1].callbacks = v36;
              if (!v36)
              {
                v37 = *(void (***)(void))a1[1].flow_id;
                if (v37)
                {
                  *(void *)a1[1].flow_id = 0LL;
                  v37[2](v37);
                  _Block_release(v37);
                }

                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v38 = *(const void **)a1[1].flow_id;
                  if (v38) {
                    _Block_release(v38);
                  }
                }

                free(a1);
              }
            }
          }

          goto LABEL_25;
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      name = output_handler->identifier->name;
      if (!name) {
        name = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_get_input_frames";
      v130 = 2082;
      v131 = (void *)name;
      v132 = 2048;
      v133 = output_handler;
      v52 = (const char *)_os_log_send_and_compose_impl();
      v127 = OS_LOG_TYPE_ERROR;
      v126 = 0;
      v110 = (char *)v52;
      if (__nwlog_fault(v52, &v127, &v126))
      {
        if (v127 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v53 = v127;
          *(void *)type = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, v127)) {
            goto LABEL_133;
          }
          v54 = output_handler->identifier->name;
          if (!v54) {
            v54 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v54;
          v132 = 2048;
          v133 = output_handler;
          v55 = *(os_log_s **)type;
          v56 = v53;
          v57 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_132:
          _os_log_impl(&dword_181A5C000, v55, v56, v57, buf, 0x20u);
          goto LABEL_133;
        }

        if (!v126)
        {
          v77 = (os_log_s *)__nwlog_obj();
          v78 = v127;
          *(void *)typec = v77;
          if (!os_log_type_enabled(v77, v127)) {
            goto LABEL_133;
          }
          v79 = output_handler->identifier->name;
          if (!v79) {
            v79 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v79;
          v132 = 2048;
          v133 = output_handler;
          v55 = *(os_log_s **)typec;
          v56 = v78;
          v57 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
          goto LABEL_132;
        }

        v64 = (char *)__nw_create_backtrace_string();
        log = (os_log_s *)__nwlog_obj();
        typea = v127;
        v65 = os_log_type_enabled(log, v127);
        if (!v64)
        {
          if (!v65) {
            goto LABEL_133;
          }
          v83 = output_handler->identifier->name;
          if (!v83) {
            v83 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v83;
          v132 = 2048;
          v133 = output_handler;
          v55 = log;
          v56 = typea;
          v57 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
          goto LABEL_132;
        }

        if (v65)
        {
          v66 = output_handler->identifier->name;
          if (!v66) {
            v66 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v66;
          v132 = 2048;
          v133 = output_handler;
          v134 = 2082;
          v135 = v64;
          _os_log_impl( &dword_181A5C000,  log,  typea,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v64);
      }

  if (v7) {
    free(v7);
  }
LABEL_7:
}

        v15 = 0;
        v16 = 0LL;
LABEL_25:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          v84 = "nw_protocol_shoes_input_available";
          v85 = 2082;
          v86 = handle + 151;
          v87 = 1024;
          v88 = v15;
          v89 = 2048;
          *(void *)v90 = v16;
          _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Read frame has %u bytes (%p)",  buf,  0x26u);
        }

        v18 = *(void *)(v9 + 32);
        v19 = *(void **)(v9 + 40);
        if (v18)
        {
          *(void *)(v18 + 40) = v19;
          v19 = *(void **)(v9 + 40);
        }

        else
        {
          v80 = *(os_log_type_t **)(v9 + 40);
        }

        *v19 = v18;
        *v11 = 0LL;
        *(void *)(v9 + 40) = 0LL;
        v10 = (void *)*((void *)handle + 16);
        *(void *)(v9 + 40) = v10;
        *v10 = v9;
        *((void *)handle + 16) = v11;
        v9 = v12;
      }

      while (v12);
    }
  }

  else if (gLogDatapath)
  {
    v75 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v84 = "nw_protocol_shoes_input_available";
      v85 = 2082;
      v86 = handle + 151;
      _os_log_impl(&dword_181A5C000, v75, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got 0 input frames", buf, 0x16u);
    }
  }

  v20 = handle + 151;
  while (1)
  {
    if (!*((void *)handle + 15)) {
      return;
    }
    if (handle[150] != 5)
    {
      switch(handle[150])
      {
        case 1:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in initial state";
            goto LABEL_90;
          }

          break;
        case 2:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in waiting for TFO state";
            goto LABEL_90;
          }

          break;
        case 3:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in waiting for UDP associate state";
            goto LABEL_90;
          }

          break;
        case 6:
          (*(void (**)(void, char *))(*(void *)(*((void *)handle + 6) + 24LL) + 64LL))( *((void *)handle + 6),  handle);
          break;
        case 7:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in failed state";
LABEL_90:
            v7 = (os_log_s *)v54;
            goto LABEL_91;
          }

          break;
        default:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v58 = handle[150];
            *(_DWORD *)buf = 136446722;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = handle + 151;
            v87 = 1024;
            v88 = v58;
            v6 = "%{public}s %{public}s Tried to read packets in unknown state %u";
            v7 = (os_log_s *)v57;
            v55 = OS_LOG_TYPE_ERROR;
            v56 = 28;
            goto LABEL_93;
          }

          break;
      }

      return;
    }

    v21 = *((_DWORD *)handle + 34);
    v22 = bswap32(*((unsigned __int16 *)handle + 73)) >> 16;
    if (!(_DWORD)v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_read_reply";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s Received successful empty shoes reply from server",  buf,  0x16u);
      }

      goto LABEL_54;
    }

    if ((_DWORD)v22 == 1)
    {
      v60 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_read_reply";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Received invalid shoes reply length one",  buf,  0x16u);
      }

      nw_protocol_shoes_error((nw_protocol *)handle, (nw_protocol *)handle, 422052353);
      handle[235] |= 0x10u;
      v61 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_internal_disconnect";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl(&dword_181A5C000, v61, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
      }

      handle[150] = 7;
      (*(void (**)(char *, void))(*((void *)handle + 3) + 48LL))(handle, 0LL);
      return;
    }

    v23 = *((_DWORD *)handle + 34);
    if (v23 <= 3)
    {
      if (!nw_shoes_read_into_buffer((uint64_t)handle, (uint64_t)(handle + 146), 4 - v23, v23))
      {
        if (gLogDatapath)
        {
          v59 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_read_reply";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Failed to read shoes reply domain and error code";
            goto LABEL_110;
          }
        }

        return;
      }

      v23 = *((_DWORD *)handle + 34);
    }

    v24 = v22 + 2;
    v25 = v22 + 2 - v23;
    if (v25)
    {
      v26 = nw_calloc_type<unsigned char>((unsigned __int16)(v22 + 2 - v23));
    }

    else
    {
      v26 = 0LL;
      if (v24 > v23)
      {
LABEL_48:
        if (!nw_shoes_read_into_buffer((uint64_t)handle, v26, v25, 0))
        {
          if (gLogDatapath)
          {
            v76 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              v84 = "nw_shoes_read_reply";
              v85 = 2082;
              v86 = v20;
              _os_log_impl( &dword_181A5C000,  v76,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Failed to read shoes rest of reply",  buf,  0x16u);
            }
          }

          if (!v26) {
            return;
          }
LABEL_122:
          free((void *)v26);
          return;
        }
      }
    }

    if (handle[148])
    {
      v62 = handle[149];
      switch(handle[148])
      {
        case 1:
          v62 |= 0x19280100u;
          break;
        case 2:
          break;
        case 3:
          v62 |= 0xFFFEFF00;
          break;
        case 4:
          v62 -= 10055;
          break;
        default:
          v62 = 422052352;
          break;
      }

      v63 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        v64 = handle[148];
        v65 = handle[149];
        *(_DWORD *)buf = 136447490;
        v84 = "nw_shoes_read_reply";
        v85 = 2082;
        v86 = handle + 151;
        v87 = 1024;
        v88 = v62;
        v89 = 1024;
        *(_DWORD *)v90 = v64;
        *(_WORD *)&v90[4] = 1024;
        *(_DWORD *)&v90[6] = v65;
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v22;
        _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Received shoes error %d domain %u code %u inner length %u",  buf,  0x2Eu);
      }

      nw_shoes_read_reply_tlvs((uint64_t)handle, (unsigned __int8 *)v26, v25, 0);
      nw_protocol_shoes_error((nw_protocol *)handle, (nw_protocol *)handle, v62);
      handle[235] |= 0x10u;
      v66 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_internal_disconnect";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl(&dword_181A5C000, v66, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
      }

      handle[150] = 7;
      (*(void (**)(char *, void))(*((void *)handle + 3) + 48LL))(handle, 0LL);
      if (!v26) {
        return;
      }
      goto LABEL_122;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v29 = handle[149];
      *(_DWORD *)buf = 136446978;
      v84 = "nw_shoes_read_reply";
      v85 = 2082;
      v86 = handle + 151;
      v87 = 1024;
      v88 = v22;
      v89 = 1024;
      *(_DWORD *)v90 = v29;
      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s Received successful shoes reply from server with inner length %u code %u",  buf,  0x22u);
    }

    nw_shoes_read_reply_tlvs((uint64_t)handle, (unsigned __int8 *)v26, v25, 1);
    if (v26) {
      free((void *)v26);
    }
LABEL_54:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v84 = "nw_shoes_internal_connect";
      v85 = 2082;
      v86 = handle + 151;
      _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_INFO, "%{public}s %{public}s ", buf, 0x16u);
    }

    handle[150] = 6;
    v31 = *((void *)handle + 6);
    if ((handle[235] & 2) != 0)
    {
      v32 = *((void *)handle + 5);
      if (!v32)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v84 = "nw_protocol_shoes_process_udp_associate_completion";
        v43 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v81 = 0;
        v78 = (char *)v43;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v44 = (os_log_s *)__nwlog_obj();
          v45 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            v84 = "nw_protocol_shoes_process_udp_associate_completion";
            v46 = v44;
            v47 = v45;
            v48 = "%{public}s called with null shoes";
            goto LABEL_77;
          }

          goto LABEL_78;
        }

        if (v81)
        {
          v49 = (char *)__nw_create_backtrace_string();
          v50 = (os_log_s *)__nwlog_obj();
          v77 = type;
          v51 = os_log_type_enabled(v50, type);
          if (v49)
          {
            if (v51)
            {
              *(_DWORD *)buf = 136446466;
              v84 = "nw_protocol_shoes_process_udp_associate_completion";
              v85 = 2082;
              v86 = v49;
              _os_log_impl( &dword_181A5C000,  v50,  v77,  "%{public}s called with null shoes, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v49);
            goto LABEL_78;
          }

          if (!v51)
          {
LABEL_78:
            if (v78) {
              free(v78);
            }
            goto LABEL_32;
          }

          *(_DWORD *)buf = 136446210;
          v84 = "nw_protocol_shoes_process_udp_associate_completion";
          v46 = v50;
          v47 = v77;
          v48 = "%{public}s called with null shoes, no backtrace";
        }

        else
        {
          v52 = (os_log_s *)__nwlog_obj();
          v53 = type;
          if (!os_log_type_enabled(v52, type)) {
            goto LABEL_78;
          }
          *(_DWORD *)buf = 136446210;
          v84 = "nw_protocol_shoes_process_udp_associate_completion";
          v46 = v52;
          v47 = v53;
          v48 = "%{public}s called with null shoes, backtrace limit exceeded";
        }

          v148 = v149;
          v24 = v23;
          if (v23)
          {
LABEL_25:
            v25 = *(void **)(v24 + 448);
            if (v25)
            {
              if (nw_http_metadata_get_type(*(void **)(v24 + 448)) == 3)
              {
                LOBYTE(v26) = 0;
                goto LABEL_47;
              }

              v27 = nw_http_metadata_copy_header_fields(v25);
              if (v27)
              {
                v155 = 0LL;
                v156 = &v155;
                v157 = 0x2000000000LL;
                v158 = 0;
                type.__r_.__value_.__r.__words[0] = v13;
                type.__r_.__value_.__l.__size_ = 0x40000000LL;
                type.__r_.__value_.__l.__cap_ = (std::string::size_type)___ZL29nw_http_sniffing_should_sniffP25nw_protocol_http_sniffingNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP20nw_protocol_metadata_block_invoke;
                v153 = &unk_189BB5A80;
                v154 = &v155;
                v28 = v27;
                v29 = &type;
                _nw_http_fields_access_value_by_name((uint64_t)v28, (unint64_t)"X-Content-Type-Options", v29);

                if (*((_BYTE *)v156 + 24))
                {
                  LOBYTE(v26) = 0;
LABEL_46:
                  _Block_object_dispose(&v155, 8);
                  os_release(v28);
                  goto LABEL_47;
                }

                size = v148.__r_.__value_.__s.__size_;
                if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  size = v148.__r_.__value_.__l.__size_;
                }
                if (!size) {
                  goto LABEL_45;
                }
                mime_type_to_class();
                v26 = std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::find<std::string>((uint64_t)&v148);
                mime_type_to_class();
                if (!v26) {
                  goto LABEL_46;
                }
                if (*((_DWORD *)v26 + 10) != 1)
                {
LABEL_45:
                  LOBYTE(v26) = 1;
                  goto LABEL_46;
                }

                *(void *)buf = 0LL;
                *(void *)&buf[8] = buf;
                *(void *)&buf[16] = 0x4002000000LL;
                v160 = __Block_byref_object_copy__19;
                *(void *)&v161 = __Block_byref_object_dispose__20;
                v162 = 0LL;
                v163 = 0LL;
                *((void *)&v161 + 1) = 0LL;
                v151[0] = v13;
                v151[1] = 0x40000000LL;
                v151[2] = ___ZL29nw_http_sniffing_should_sniffP25nw_protocol_http_sniffingNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP20nw_protocol_metadata_block_invoke_2;
                v151[3] = &unk_189BB5AA8;
                v151[4] = buf;
                nw_http_fields_enumerate_by_name(v28, (unint64_t)"Content-Type", v151);
                v26 = (uint64_t *)(*(void *)&buf[8] + 40LL);
                if (*(char *)(*(void *)&buf[8] + 63LL) < 0)
                {
                  if (!*(void *)(*(void *)&buf[8] + 48LL)) {
                    goto LABEL_107;
                  }
                  v26 = (uint64_t *)*v26;
                }

                else if (!*(_BYTE *)(*(void *)&buf[8] + 63LL))
                {
                  goto LABEL_107;
                }

                if (strcasecmp((const char *)v26, "utf-8"))
                {
                  LOBYTE(v26) = strcasecmp((const char *)v26, "iso-8859-1") == 0;
                  goto LABEL_108;
                }

    operator delete(v21[0]);
    if ((v20 & 0x80000000) == 0)
    {
LABEL_13:
      if ((v18 & 0x80000000) == 0) {
        goto LABEL_14;
      }
      goto LABEL_26;
    }

  if (v15) {
    free(v15);
  }
LABEL_7:
}

  if (v7) {
    free(v7);
  }
LABEL_7:
}

  if (v4) {
    free(v4);
  }
LABEL_7:
}

  if (v8) {
    free(v8);
  }
  v3 = 0;
LABEL_7:

  return v3;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  if (v5) {
    free(v5);
  }
LABEL_7:
}

      free(backtrace_string);
    }
  }

  if (v4) {
    free(v4);
  }
LABEL_7:
}

  if (v4) {
    free(v4);
  }
LABEL_7:
}

  v18 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40), a2);
LABEL_25:
  if (gLogDatapath)
  {
    __nwlog_obj();
    v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      v30 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
      *(_DWORD *)buf = 136446978;
      v39 = "nw_endpoint_enumerate_edges_block_invoke";
      v40 = 2080;
      v41 = (void *)v30;
      v42 = 2112;
      v43 = v6;
      v44 = 1024;
      v45 = v18;
      _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %s continuing after edge %@: %u", buf, 0x26u);
    }
  }

  return v18;
}

      free(backtrace_string);
    }
  }

    if (v6) {
      free(v6);
    }
    goto LABEL_26;
  }

  if (nw_data_transfer_report_get_state(v1) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_data_transfer_report_get_duration_milliseconds";
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

LABEL_26:
    v3 = 0LL;
    goto LABEL_4;
  }

  v3 = *((void *)v2 + 2);
LABEL_4:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_7:
}

  if (v7) {
    free(v7);
  }
LABEL_7:
  v16.receiver = self;
  v16.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_connection_group;
  -[NWConcrete_nw_connection_group dealloc](&v16, sel_dealloc, v14, v15);
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  if (v8) {
    free(v8);
  }
LABEL_7:
}

      free(backtrace_string);
    }
  }

  if (v8) {
    free(v8);
  }
  v5 = 0LL;
LABEL_7:
}

  if (v6) {
    free(v6);
  }
  v3 = 0LL;
LABEL_7:
}

  if (v4) {
    free(v4);
  }
  v2 = 0LL;
LABEL_7:
}

      free(backtrace_string);
    }
  }

    if (v11) {
      free(v11);
    }
    goto LABEL_26;
  }

  if (a3)
  {
    v7 = nw_protocol_implementation_lookup_path(v5, a3, 0LL);
    if (v7)
    {
      wakeup = *(void *)(v7 + 24);
      if (wakeup) {
        goto LABEL_7;
      }
    }

    if (v9) {
      free(v9);
    }
    goto LABEL_26;
  }

  if (a2)
  {
    v5 = nw_protocol_implementation_lookup_path(v3, a2, 0LL);
    if (!v5) {
      goto LABEL_26;
    }
    wakeup = *(id *)(v5 + 24);
    if (!wakeup) {
      goto LABEL_26;
    }
  }

  else
  {
    wakeup = v3->wakeup;
    if (!wakeup)
    {
LABEL_26:
      stats_region = 0LL;
      goto LABEL_27;
    }
  }

  stats_region = nw_path_flow_registration_get_stats_region(wakeup, *(void *)&v4[-1].log_str[9]);
LABEL_27:

  return stats_region;
}

      free(backtrace_string);
    }
  }

  if (v9) {
    free(v9);
  }
  v6 = 0LL;
LABEL_7:

  return v6;
}

  if (v6) {
    free(v6);
  }
}

    free(backtrace_string);
    goto LABEL_34;
  }

  v9 = (os_log_s *)__nwlog_obj();
  v10 = v18;
  if (os_log_type_enabled(v9, v18))
  {
    *(_DWORD *)buf = 136446210;
    v20 = "nw_http_authentication_send_challenge";
    v11 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
  }

  if (v11) {
    free(v11);
  }
  v8 = 0LL;
LABEL_8:

  return v8;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

    free(backtrace_string);
    goto LABEL_34;
  }

  v5 = (os_log_s *)__nwlog_obj();
  v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_trainer_reset";
    v7 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

LABEL_25:
    if (!v15) {
      goto LABEL_36;
    }
LABEL_26:
    free(v15);
    goto LABEL_36;
  }

  if (!v24)
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    v16 = (os_log_s *)(id)glistenerLogObj;
    v22 = type;
    if (os_log_type_enabled(v16, type))
    {

      *(_DWORD *)buf = 136446722;
      v27 = "-[NWConcrete_nw_listener handleInboxCancelComplete:]";
      v28 = 2082;
      v29 = (char *)v14 + 42;
      v30 = 2114;
      v31 = v4;
      _os_log_impl( &dword_181A5C000,  v16,  v22,  "%{public}s [%{public}s] Removing deferral for %{public}@ results in invalid defer count, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_24;
  }

  backtrace_string = __nw_create_backtrace_string();
  if (!backtrace_string)
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    v16 = (os_log_s *)(id)glistenerLogObj;
    v23 = type;
    if (os_log_type_enabled(v16, type))
    {

      *(_DWORD *)buf = 136446722;
      v27 = "-[NWConcrete_nw_listener handleInboxCancelComplete:]";
      v28 = 2082;
      v29 = (char *)v14 + 42;
      v30 = 2114;
      v31 = v4;
      _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s [%{public}s] Removing deferral for %{public}@ results in invalid defer count, no backtrace",  buf,  0x20u);
    }

    goto LABEL_24;
  }

  v19 = (char *)backtrace_string;
  if (__nwlog_listener_log::onceToken != -1) {
    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
  }
  v20 = (os_log_s *)(id)glistenerLogObj;
  v21 = type;
  if (os_log_type_enabled(v20, type))
  {

    *(_DWORD *)buf = 136446978;
    v27 = "-[NWConcrete_nw_listener handleInboxCancelComplete:]";
    v28 = 2082;
    v29 = (char *)v14 + 42;
    v30 = 2114;
    v31 = v4;
    v32 = 2082;
    v33 = v19;
    _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s [%{public}s] Removing deferral for %{public}@ results in invalid defer count, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v19);
  if (v15) {
    goto LABEL_26;
  }
LABEL_36:
}

    free(v18);
    goto LABEL_25;
  }

  if (v9) {
    free(v9);
  }
LABEL_7:
}

  if (v11) {
    free(v11);
  }
LABEL_7:
}

  if (v8) {
    free(v8);
  }
LABEL_7:
}

    if (v12) {
      free(v12);
    }
    goto LABEL_7;
  }

  v5 = (void *)v3[19];
  if (!a2)
  {
    options = (void *)nw_protocol_boringssl_copy_definition();
    nw_protocol_stack_remove_protocol(v5, options);
    goto LABEL_6;
  }

  v6 = (void *)nw_protocol_boringssl_copy_definition();
  v7 = nw_protocol_stack_includes_protocol(v5, v6);

  if ((v7 & 1) == 0)
  {
    v8 = (void *)v4[19];
    v9 = (void *)nw_protocol_boringssl_copy_definition();
    options = nw_protocol_create_options(v9);

    nw_protocol_stack_append_application_protocol(v8, options);
LABEL_6:
  }

  if (v10) {
    free(v10);
  }
  v7 = 0LL;
LABEL_7:

  return v7;
}

      free(backtrace_string);
    }
  }

        v11 = 0LL;
        goto LABEL_25;
      }

      __nwlog_obj();
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
      v31 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (__nwlog_fault(v31, &type, &v51))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
            _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null stack", buf, 0xCu);
          }
        }

        else if (v51)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v40 = type;
          v41 = os_log_type_enabled(v32, type);
          if (backtrace_string)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v32,  v40,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_78;
          }

          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
            _os_log_impl(&dword_181A5C000, v32, v40, "%{public}s called with null stack, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v44 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
            _os_log_impl( &dword_181A5C000,  v32,  v44,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      free(backtrace_string);
    }
  }

  if (v12) {
    free(v12);
  }
  v2 = 0LL;
LABEL_7:

  return v2;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_25;
  }

  if (handle[17] != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (os_log_s *)gLogObj;
      v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
      v6 = "%{public}s Ignoring listen protocol disconnected, not sent by output handler";
      goto LABEL_23;
    }

    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (os_log_s *)gLogObj;
      v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
      v6 = "%{public}s Ignoring listen protocol disconnected, not sent by output handler, backtrace limit exceeded";
      goto LABEL_23;
    }

    v7 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (os_log_s *)gLogObj;
    v5 = type;
    v8 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v7)
    {
      if (!v8) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
      v6 = "%{public}s Ignoring listen protocol disconnected, not sent by output handler, no backtrace";
      goto LABEL_23;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
      v19 = 2082;
      v20 = v7;
      v9 = "%{public}s Ignoring listen protocol disconnected, not sent by output handler, dumping backtrace:%{public}s";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
      goto LABEL_17;
    }

    goto LABEL_17;
  }

  if ((*((_BYTE *)handle + 294) & 4) == 0 && gLogDatapath)
  {
    v14 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
      v19 = 2082;
      v20 = (char *)(handle + 26);
      v21 = 2080;
      v22 = " ";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%slower protocol is disconnected",  buf,  0x20u);
    }
  }

  nw_protocol_http_client_bottom_teardown((uint64_t)handle);
}

        goto LABEL_25;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (os_log_s *)(id)gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (!v17) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        v27 = "nw_endpoint_flow_uses_multipath_block_invoke";
        v14 = "%{public}s Didn't get a CIAUX_MPTCP, no backtrace";
        v18 = v12;
        v19 = v16;
        goto LABEL_23;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v27 = "nw_endpoint_flow_uses_multipath_block_invoke";
        v28 = 2082;
        v29 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s Didn't get a CIAUX_MPTCP, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

        goto LABEL_25;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (os_log_s *)(id)gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (!v17) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        v27 = "nw_endpoint_flow_get_multipath_subflow_count_block_invoke";
        v14 = "%{public}s Didn't get a CIAUX_MPTCP, no backtrace";
        v18 = v12;
        v19 = v16;
        goto LABEL_23;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v27 = "nw_endpoint_flow_get_multipath_subflow_count_block_invoke";
        v28 = 2082;
        v29 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s Didn't get a CIAUX_MPTCP, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }
}
}
}

    free(backtrace_string);
    goto LABEL_34;
  }

  v9 = (os_log_s *)__nwlog_obj();
  v10 = v19;
  if (os_log_type_enabled(v9, v19))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "network_config_policy_observer_create";
    v11 = "%{public}s called with null queue";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

        goto LABEL_25;
      }

      if ((*((_BYTE *)v4 + 268) & 0x20) != 0)
      {
LABEL_25:
        if (v4->state == 1)
        {
          if ((nw_parameters_get_indefinite(v4->parameters) & 1) != 0)
          {
            v4->event = (nw_endpoint_handler_event_s)262145;
            nw_endpoint_handler_report(v4, 0LL, &v4->event.domain, 0LL);
            v22 = (OS_nw_path *)nw_association_copy_current_path(v4->association, v4->parameters);
            os_unfair_lock_lock(&v4->lock);
            current_path = v4->current_path;
            v4->current_path = v22;

            os_unfair_lock_unlock(&v4->lock);
            nw_endpoint_handler_path_change(v4);
            goto LABEL_66;
          }

          if ((*((_BYTE *)v4 + 268) & 0x20) != 0) {
            goto LABEL_66;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v24 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            if ((*((_BYTE *)v4 + 268) & 1) != 0) {
              v31 = "dry-run ";
            }
            else {
              v31 = "";
            }
            v32 = nw_endpoint_handler_copy_endpoint(v4);
            v33 = nw_endpoint_get_logging_description(v32);
            state = v4->state;
            v35 = v33;
            else {
              v36 = off_189BBBBF0[state];
            }
            logb = v36;
            v40 = v4;
            v41 = (os_unfair_lock_s *)v40;
            v42 = "path";
            switch(v40->mode)
            {
              case 0:
                break;
              case 1:
                v42 = "resolver";
                break;
              case 2:
                v42 = nw_endpoint_flow_mode_string(v40->mode_handler);
                break;
              case 3:
                v42 = "proxy";
                break;
              case 4:
                v42 = "fallback";
                break;
              case 5:
                v42 = "transform";
                break;
              default:
                v42 = "unknown-mode";
                break;
            }

            v48 = v2;
            v49 = v41 + 28;
            v50 = v41;
            os_unfair_lock_lock(v41 + 28);
            v51 = v50[8];
            v52 = v49;
            v2 = v48;
            os_unfair_lock_unlock(v52);

            *(_DWORD *)buf = 136447746;
            v87 = "nw_endpoint_handler_restart";
            v88 = 2082;
            id_str = v4->id_str;
            v90 = 2082;
            v91 = v31;
            v92 = 2082;
            v93 = v35;
            v94 = 2082;
            v95 = logb;
            v96 = 2082;
            v97 = v42;
            v98 = 2114;
            v99 = v51;
            _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] skipping restart on non-i ndefinite connection",  buf,  0x48u);
          }
        }

        else
        {
          if ((*((_BYTE *)v4 + 268) & 0x20) != 0) {
            goto LABEL_66;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v24 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            if ((*((_BYTE *)v4 + 268) & 1) != 0) {
              v25 = "dry-run ";
            }
            else {
              v25 = "";
            }
            v26 = nw_endpoint_handler_copy_endpoint(v4);
            v27 = nw_endpoint_get_logging_description(v26);
            loga = v25;
            v28 = v4->state;
            v29 = v27;
            else {
              v30 = off_189BBBBF0[v28];
            }
            v37 = v4;
            v38 = (os_unfair_lock_s *)v37;
            v39 = "path";
            switch(v37->mode)
            {
              case 0:
                break;
              case 1:
                v39 = "resolver";
                break;
              case 2:
                v39 = nw_endpoint_flow_mode_string(v37->mode_handler);
                break;
              case 3:
                v39 = "proxy";
                break;
              case 4:
                v39 = "fallback";
                break;
              case 5:
                v39 = "transform";
                break;
              default:
                v39 = "unknown-mode";
                break;
            }

            v43 = v2;
            v44 = v38 + 28;
            v45 = v38;
            os_unfair_lock_lock(v38 + 28);
            v46 = v45[8];
            v47 = v44;
            v2 = v43;
            os_unfair_lock_unlock(v47);

            *(_DWORD *)buf = 136447746;
            v87 = "nw_endpoint_handler_restart";
            v88 = 2082;
            id_str = v4->id_str;
            v90 = 2082;
            v91 = loga;
            v92 = 2082;
            v93 = v29;
            v94 = 2082;
            v95 = v30;
            v96 = 2082;
            v97 = v39;
            v98 = 2114;
            v99 = v46;
            _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] skipping restart due to wrong state",  buf,  0x48u);
          }
        }

        goto LABEL_66;
      }
    }

    else
    {

      if ((*((_BYTE *)v4 + 268) & 0x20) != 0) {
        goto LABEL_25;
      }
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v8 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      log = v8;
      if ((*((_BYTE *)v4 + 268) & 1) != 0) {
        v9 = "dry-run ";
      }
      else {
        v9 = "";
      }
      v10 = nw_endpoint_handler_copy_endpoint(v4);
      v11 = nw_endpoint_get_logging_description(v10);
      v12 = v4->state;
      v13 = v11;
      else {
        v14 = off_189BBBBF0[v12];
      }
      v15 = v4;
      v16 = (os_unfair_lock_s *)v15;
      v17 = v2;
      v18 = "path";
      switch(v15->mode)
      {
        case 0:
          break;
        case 1:
          v18 = "resolver";
          break;
        case 2:
          v18 = nw_endpoint_flow_mode_string(v15->mode_handler);
          break;
        case 3:
          v18 = "proxy";
          break;
        case 4:
          v18 = "fallback";
          break;
        case 5:
          v18 = "transform";
          break;
        default:
          v18 = "unknown-mode";
          break;
      }

      v19 = v16 + 28;
      v20 = v16;
      os_unfair_lock_lock(v16 + 28);
      v21 = v20[8];
      os_unfair_lock_unlock(v19);

      *(_DWORD *)buf = 136447746;
      v87 = "nw_endpoint_handler_restart";
      v88 = 2082;
      id_str = v4->id_str;
      v90 = 2082;
      v91 = v9;
      v92 = 2082;
      v93 = v13;
      v94 = 2082;
      v95 = v14;
      v96 = 2082;
      v97 = v18;
      v98 = 2114;
      v99 = v21;
      v8 = log;
      _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);

      v2 = v17;
    }

    goto LABEL_24;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v53 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v87 = "nw_endpoint_handler_restart";
  v54 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v84 = 0;
  if (__nwlog_fault(v54, &type, &v84))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v55 = (os_log_s *)(id)gLogObj;
      v56 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_endpoint_handler_restart";
        _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v84)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v55 = (os_log_s *)(id)gLogObj;
      v70 = type;
      v71 = os_log_type_enabled(v55, type);
      if (backtrace_string)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446466;
          v87 = "nw_endpoint_handler_restart";
          v88 = 2082;
          id_str = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v55,  v70,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_95;
      }

      if (v71)
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_endpoint_handler_restart";
        _os_log_impl(&dword_181A5C000, v55, v70, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v55 = (os_log_s *)(id)gLogObj;
      v76 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_endpoint_handler_restart";
        _os_log_impl( &dword_181A5C000,  v55,  v76,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  if (v2) {
    free(v2);
  }
}

    free(backtrace_string);
    goto LABEL_34;
  }

  v5 = (os_log_s *)__nwlog_obj();
  v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ohttp_connect";
    v7 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

    free(v7);
    goto LABEL_25;
  }

  if (*((_DWORD *)v1 + 29) != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_endpoint_handler_used_prefer_fallback";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (os_log_s *)(id)gLogObj;
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_endpoint_handler_used_prefer_fallback";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s Endpoint handler is not in fallback mode", buf, 0xCu);
      }
    }

    else if (v29)
    {
      v10 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (os_log_s *)(id)gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v32 = "nw_endpoint_handler_used_prefer_fallback";
          v33 = 2082;
          v34 = v10;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s Endpoint handler is not in fallback mode, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v10);
        if (!v7) {
          goto LABEL_25;
        }
        goto LABEL_24;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_endpoint_handler_used_prefer_fallback";
        _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s Endpoint handler is not in fallback mode, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (os_log_s *)(id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_endpoint_handler_used_prefer_fallback";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s Endpoint handler is not in fallback mode, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_22;
  }

  v3 = (unsigned __int8 *)v1[31];
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_endpoint_fallback_used_prefer_fallback";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_endpoint_fallback_used_prefer_fallback";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null fallback", buf, 0xCu);
        }
      }

      else if (v29)
      {
        v24 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type;
        v26 = os_log_type_enabled(v19, type);
        if (v24)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_endpoint_fallback_used_prefer_fallback";
            v33 = 2082;
            v34 = v24;
            _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null fallback, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v24);
          goto LABEL_59;
        }

        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_endpoint_fallback_used_prefer_fallback";
          _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null fallback, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_endpoint_fallback_used_prefer_fallback";
          _os_log_impl( &dword_181A5C000,  v19,  v28,  "%{public}s called with null fallback, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(backtrace_string);
    goto LABEL_34;
  }

  v15 = (os_log_s *)__nwlog_obj();
  v16 = v27;
  if (os_log_type_enabled(v15, v27))
  {
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_ethernet_get_output_frames";
    v17 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
  }

    free(v17);
    goto LABEL_25;
  }

  if (a2 && a3) {
    *a2 = 0;
  }
  v7 = v5[2];
  if (v7)
  {
    v8 = nw_connection_copy_host_endpoint(v7);
  }

  else
  {
    v20 = v6[5];
    if (!v20 || (v21 = v20, v22 = [v21 type], v21, v22 != 2))
    {
      v9 = 0LL;
      v10 = 0LL;
LABEL_48:

      goto LABEL_49;
    }

    v8 = v6[5];
  }

  v9 = v8;
  v10 = 0LL;
  if (!a2 || !v8) {
    goto LABEL_48;
  }
  v9 = v8;
  v11 = (const char *)[v9 hostname];

  v12 = strlen(v11);
  if (v12 >= a3) {
    v10 = a3;
  }
  else {
    v10 = v12;
  }
  if (v11)
  {
    if (a3 >= 2) {
      goto LABEL_14;
    }
    goto LABEL_44;
  }

  __nwlog_obj();
  v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v33 = "_strict_strlcpy";
  v28 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    if (a3 >= 2)
    {
LABEL_14:
      v13 = 1LL;
      v14 = a3;
      while (1)
      {
        v15 = *(unsigned __int8 *)v11;
        *a2 = v15;
        if (!v15) {
          goto LABEL_48;
        }
        ++a2;
        ++v11;
        if (--v14 <= 1) {
          goto LABEL_45;
        }
      }
    }

LABEL_25:
      if (!v12) {
        goto LABEL_27;
      }
LABEL_26:
      free(v12);
      goto LABEL_27;
    }

    if (!v28)
    {
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_24;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v22 = type;
    v23 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl(&dword_181A5C000, v13, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_24;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "tcp_connection_read";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  return v6;
}

  return is_expensive;
}

    free(backtrace_string);
    goto LABEL_37;
  }

  if (*(void *)(v3 + 24) == *(void *)(v3 + 16))
  {
LABEL_39:
    v5 = 0LL;
    goto LABEL_40;
  }

  nw_array_get_object_at_index(v3, v2[4]);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = nw_authentication_protection_space_get_type(v4);

LABEL_40:
  return v5;
}

      free(backtrace_string);
    }
  }

  v16 = 0LL;
  if ((*(_WORD *)&self->_has & 0x100) != 0)
  {
LABEL_10:
    v17 = 2654435761LL * self->_longOutstandingQueries;
    if ((*(_WORD *)&self->_has & 0x2000) != 0) {
      goto LABEL_11;
    }
    goto LABEL_26;
  }

  if (gLogDatapath)
  {
    v35 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      v37 = nw_hash_table_count(handle[14], v36);
      *(_DWORD *)buf = 136446722;
      v40 = "nw_protocol_http2_replace_input_handler";
      v41 = 2082;
      v42 = (char *)handle + 205;
      v43 = 1024;
      v44 = v37;
      _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s replaced input handler, have %u input handlers",  buf,  0x1Cu);
    }
  }

  return 1LL;
}

  if (v17) {
    free(v17);
  }
  return 4294966394LL;
}

  if (gLogDatapath)
  {
    v41 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      v42 = *(_DWORD *)(a3 + 32);
      *(_DWORD *)buf = 136446978;
      v52 = "nw_http2_transport_drain_next_frame_for_stream";
      v53 = 2082;
      v54 = (void *)(a1 + 205);
      v55 = 2048;
      *(void *)v56 = a2;
      *(_WORD *)&v56[8] = 1024;
      v57 = v42;
      _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s delivering output available to protocol %p for stream %d",  buf,  0x26u);
    }
  }

  v14 = *(void *)(a2 + 24);
  if (v14)
  {
    v15 = *(void (**)(uint64_t, uint64_t))(v14 + 72);
    if (v15)
    {
      v15(a2, a1);
      return v9;
    }
  }

  __nwlog_obj();
  v31 = *(const char **)(a2 + 16);
  if (!v31) {
    v31 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  v52 = "nw_http2_transport_drain_next_frame_for_stream";
  v53 = 2082;
  v54 = (void *)v31;
  v32 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v49 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v33 = (os_log_s *)__nwlog_obj();
    v34 = type;
    if (!os_log_type_enabled(v33, type)) {
      goto LABEL_102;
    }
    v35 = *(const char **)(a2 + 16);
    if (!v35) {
      v35 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    v52 = "nw_http2_transport_drain_next_frame_for_stream";
    v53 = 2082;
    v54 = (void *)v35;
    v36 = "%{public}s protocol %{public}s has invalid output_available callback";
    goto LABEL_101;
  }

  if (!v49)
  {
    v33 = (os_log_s *)__nwlog_obj();
    v34 = type;
    if (!os_log_type_enabled(v33, type)) {
      goto LABEL_102;
    }
    v46 = *(const char **)(a2 + 16);
    if (!v46) {
      v46 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    v52 = "nw_http2_transport_drain_next_frame_for_stream";
    v53 = 2082;
    v54 = (void *)v46;
    v36 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
    goto LABEL_101;
  }

  v43 = (char *)__nw_create_backtrace_string();
  v33 = (os_log_s *)__nwlog_obj();
  v34 = type;
  v44 = os_log_type_enabled(v33, type);
  if (v43)
  {
    if (v44)
    {
      v45 = *(const char **)(a2 + 16);
      if (!v45) {
        v45 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v52 = "nw_http2_transport_drain_next_frame_for_stream";
      v53 = 2082;
      v54 = (void *)v45;
      v55 = 2082;
      *(void *)v56 = v43;
      _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v43);
    goto LABEL_102;
  }

  if (v44)
  {
    v48 = *(const char **)(a2 + 16);
    if (!v48) {
      v48 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    v52 = "nw_http2_transport_drain_next_frame_for_stream";
    v53 = 2082;
    v54 = (void *)v48;
    v36 = "%{public}s protocol %{public}s has invalid output_available callback, no backtrace";
LABEL_101:
    _os_log_impl(&dword_181A5C000, v33, v34, v36, buf, 0x16u);
  }

  if (v6) {
    free(v6);
  }
LABEL_3:
  v3 = 0LL;
LABEL_7:

  return v3;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

        goto LABEL_25;
      }

      if (!v23)
      {
        __nwlog_obj();
        v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_proxy_config_get_array";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null key_string, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_24;
      }

      v19 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v10, type);
      if (!v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_proxy_config_get_array";
          _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null key_string, no backtrace", buf, 0xCu);
        }

        goto LABEL_24;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_proxy_config_get_array";
        v27 = 2082;
        v28 = v19;
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null key_string, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v19);
    }

    if (v14) {
      free(v14);
    }
    goto LABEL_26;
  }

  v3 = (void *)v1[12];
  if (!v3)
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    }
    v6 = (id)nw_context_copy_implicit_context::implicit_context;
    v7 = nw_context_copy_workloop(v6);
    v8 = nw_agent_create("Network", "Proxy", "Proxy", (void *)v7);
    v9 = *(void **)(v2 + 96);
    *(void *)(v2 + 96) = v8;

    v10 = *(void **)(v2 + 96);
    if (v10)
    {
      nw_agent_set_uuid(v10, (_OWORD *)(v2 + 56));
      nw_agent_set_error_handler(*(void **)(v2 + 96), &__block_literal_global_39516);
      nw_agent_set_assert_handlers(*(void **)(v2 + 96), &__block_literal_global_114, &__block_literal_global_116_39517);
      v11 = *(void **)(v2 + 96);
      v12 = nw_proxy_config_copy_agent_data(v2);
      v5 = 1LL;
      nw_agent_change_state(v11, 1, 0, (void *)v12);

      goto LABEL_27;
    }

  if (v8) {
    free(v8);
  }
LABEL_7:
}

    if (v11) {
      free(v11);
    }
    v9 = 0xFFFFFFFFLL;
    *a2 = -1;
    goto LABEL_27;
  }

  if (!*a1)
  {
    v16 = strdup("");
    if (!v16)
    {
      v33 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v38 = "strict_strdup";
      v34 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v34))
      {
        __break(1u);
        return;
      }

      free(v34);
    }

    *a1 = v16;
  }

    free(backtrace_string);
    goto LABEL_34;
  }

  v4 = (os_log_s *)__nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_replicate_get_remote_endpoint";
    v6 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_34;
  }

  v4 = (os_log_s *)__nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_replicate_get_parameters";
    v6 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    if (v5) {
      free(v5);
    }
    goto LABEL_26;
  }

  v3 = 0LL;
  if (v1 != (nw_content_context_t)&__block_literal_global_5_41854
    && v1 != (nw_content_context_t)&__block_literal_global_4
    && v1 != (nw_content_context_t)&__block_literal_global_3_41839
    && v1 != (nw_content_context_t)&__block_literal_global_41831)
  {
    if ((*((_BYTE *)v1 + 118) & 1) == 0)
    {
      v3 = *((void *)v1 + 8);
      goto LABEL_27;
    }

  if (v6) {
    free(v6);
  }
LABEL_7:
}

    if (v5) {
      free(v5);
    }
    goto LABEL_26;
  }

  v3 = 0LL;
  if (v1 != (nw_content_context_t)&__block_literal_global_5_41854
    && v1 != (nw_content_context_t)&__block_literal_global_4
    && v1 != (nw_content_context_t)&__block_literal_global_3_41839
    && v1 != (nw_content_context_t)&__block_literal_global_41831)
  {
    if ((*((_BYTE *)v1 + 118) & 1) == 0)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v1 + 28);
      v3 = (nw_content_context *)*((id *)v2 + 7);
      os_unfair_lock_unlock((os_unfair_lock_t)v2 + 28);
      goto LABEL_27;
    }

  if (v7) {
    free(v7);
  }
  v3 = 0LL;
LABEL_7:

  return v3;
}

  if (v7) {
    free(v7);
  }
  v3 = 0LL;
LABEL_7:

  return v3;
}

  if (v8) {
    free(v8);
  }
LABEL_7:
}

  v6 = v10;
  if (v12) {
    free(v12);
  }
LABEL_6:

  return v6;
}

  if (v11) {
    free(v11);
  }
}

  LOBYTE(v21) = 0;
LABEL_85:

  return v21;
}
  }

  if (v8) {
    free(v8);
  }
  v5 = 0LL;
LABEL_7:

  return v5;
}
  }

      free(backtrace_string);
    }
  }

    free(backtrace_string);
    goto LABEL_34;
  }

  v5 = (os_log_s *)__nwlog_obj();
  v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    v15 = "nw_frame_get_flow_id";
    v7 = "%{public}s called with null frame";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }
          }
        }
      }
    }
  }

  return 1LL;
}

          if (v23) {
            goto LABEL_47;
          }
          v29 = (os_log_s *)__nwlog_obj(v9, v10);
          os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          v72 = "_strict_strlcpy";
          v30 = (void *)_os_log_send_and_compose_impl();
LABEL_62:
          free(v30);
          goto LABEL_47;
        }

        v34 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v34);
        *(_DWORD *)buf = 136446210;
        v72 = "nw_append_format";
        v30 = (void *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v67 = 0;
        v35 = __nwlog_fault(v30, &type, &v67);
        if ((_DWORD)v35)
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v37 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init(v37);
            v38 = (os_log_s *)gLogObj;
            v39 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_61;
            }
            *(_DWORD *)buf = 136446210;
            v72 = "nw_append_format";
            v40 = "%{public}s reallocf failed";
            goto LABEL_60;
          }

          if (!v67)
          {
            v46 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init(v46);
            v38 = (os_log_s *)gLogObj;
            v39 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_61;
            }
            *(_DWORD *)buf = 136446210;
            v72 = "nw_append_format";
            v40 = "%{public}s reallocf failed, backtrace limit exceeded";
            goto LABEL_60;
          }

          backtrace_string = (char *)__nw_create_backtrace_string(v35, v36);
          v44 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v44);
          v38 = (os_log_s *)gLogObj;
          v39 = type;
          v45 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v45)
            {
              *(_DWORD *)buf = 136446466;
              v72 = "nw_append_format";
              v73 = 2082;
              v74 = (unint64_t)backtrace_string;
              _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s reallocf failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v30) {
              goto LABEL_47;
            }
            goto LABEL_62;
          }

          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            v72 = "nw_append_format";
            v40 = "%{public}s reallocf failed, no backtrace";
LABEL_60:
            _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, 0xCu);
          }
        }

    if (!v12) {
      return 0LL;
    }
    v25 = (char *)v12;
LABEL_26:
    free(v25);
    return 0LL;
  }

  v41 = 0;
  buf[0] = 0LL;
  LODWORD(v56) = 0;
  buf[1] = buf;
  buf[2] = 0x2000000000LL;
  *(void *)type = 0LL;
  v43 = type;
  v44 = 0x2000000000LL;
  v45 = a2;
  *(void *)applier = MEMORY[0x1895F87A8];
  *(void *)&applier[8] = 0x40000000LL;
  *(void *)&applier[16] = ___ZL33nw_dispatch_data_to_iovec_partialP15dispatch_data_smmP5ioveciPb_block_invoke;
  v48 = &unk_189BBF678;
  v49 = type;
  v50 = buf;
  v54 = a5;
  v51 = v10;
  v52 = &v41;
  v53 = a4;
  dispatch_data_apply(a1, applier);
  v17 = *(unsigned int *)(buf[1] + 24LL);
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  if (v41)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v19 = dispatch_data_get_size(a1);
      *(_DWORD *)applier = 136446722;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      *(_WORD *)&applier[12] = 2048;
      *(void *)&applier[14] = v19;
      *(_WORD *)&applier[22] = 1024;
      LODWORD(v48) = a5;
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_INFO,  "%{public}s data (%zu bytes) couldn't get mapped to %d iovecs due to fragmentation",  applier,  0x1Cu);
    }

    return 0LL;
  }

  return v17;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  v15 = 0;
LABEL_25:
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = v15;
  if (!*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL)) {
    goto LABEL_30;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    v20 = a1[5];
    v21 = *(void *)(v20 + 48);
    v22 = *(void *)(v20 + 32);
    *(_DWORD *)buf = 136446722;
    v30 = "nw_http_capsule_framer_read_capsule_block_invoke";
    v31 = 2048;
    v32 = v21;
    v33 = 2048;
    v34 = v22;
    _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s Parsed capsule header for type %llx, length %lld",  buf,  0x20u);
  }

  nw_frame_claim(a2, v19, v11 - v6, 0);
  v23 = (unsigned int *)a1[7];
  v24 = 0LL;
  if (v23) {
    *v23 = v11;
  }
  return v24;
}

  v11 = *(void *)(a1 + 56);
  if (v11)
  {
    if (v5)
    {
      do
      {
        v12 = *(_DWORD *)(v11 + 24);
        if (v12 >= v5 || v12 > *(_DWORD *)(a1 + 4)) {
          break;
        }
        v2 += (*(_DWORD *)(v11 + 48) + *(_DWORD *)(v11 + 52) + 32);
        if (v2 >= a2) {
          return 1LL;
        }
        v11 = *(void *)(v11 + 16);
      }

      while (v11);
    }

    else
    {
      do
      {
        if (*(_DWORD *)(v11 + 24) > *(_DWORD *)(a1 + 4)) {
          break;
        }
        v2 += (*(_DWORD *)(v11 + 48) + *(_DWORD *)(v11 + 52) + 32);
        if (v2 >= a2) {
          return 1LL;
        }
        v11 = *(void *)(v11 + 16);
      }

      while (v11);
    }
  }

  return 0LL;
}

    if (v6) {
      v27 = 1;
    }
    else {
      v27 = v5 == 0LL;
    }
    v28 = !v27;
    if (v4)
    {
      v29 = 31LL;
      if (!v4[31]) {
        v29 = 30LL;
      }
      v31 = (id *)v4[v29];
      if ((v28 & 1) != 0)
      {
        v32 = *(id *)(a1 + 32);
        v34 = objc_getProperty(v4, v33, 440LL, 1);
LABEL_35:
        v35 = v34;
        v54[0] = MEMORY[0x1895F87A8];
        v54[1] = 3221225472LL;
        v55 = __65__NWURLSessionResponseConsumerDownload_deliverCompletionForTask___block_invoke_2;
        v56 = &unk_189BC5EB8;
        v58 = v11;
        v57 = v5;
        v53 = v4;
        v36 = v32;
        v37 = v35;
        v39 = v54;
        if (v31)
        {
          v52 = v5;
          v41 = -[NWURLSessionDelegateWrapper delegateFor_didFinishDownloadingToURL](v31, v38);
          if (v37)
          {
            v42 = -[NWURLSessionDelegateWrapper delegateFor_didFinishCollectingMetrics](v31, v40);
          }

          else
          {
            v42 = 0LL;
          }

          v43 = -[NWURLSessionDelegateWrapper delegateFor_didCompleteWithError](v31, v40);
          v44 = (void *)v43;
          if (v41 || v42 || v43)
          {
            v48 = v31[4];
            v50 = v31[5];
            v66[0] = MEMORY[0x1895F87A8];
            v66[1] = 3221225472LL;
            v66[2] = __102__NWURLSessionDelegateWrapper_downloadTask_didFinishDownloadingToURL_error_metrics_completionHandler___block_invoke;
            v66[3] = &unk_189BC7090;
            v67 = v41;
            v68 = v48;
            v69 = v53;
            v70 = v36;
            v71 = v42;
            v72 = v37;
            v73 = v44;
            v74 = 0LL;
            v75 = v50;
            v76 = v39;
            v45 = v31[6];
            v51 = v50;
            v49 = v48;
            -[NWURLSessionDelegateQueue runDelegateBlock:](v45, v66);
          }

          else
          {
            v55((uint64_t)v39);
          }

          v5 = v52;
        }

        goto LABEL_46;
      }

      v46 = objc_getProperty(v4, v30, 440LL, 1);
    }

    else
    {
      if (v28)
      {
        v32 = *(id *)(a1 + 32);
        v31 = 0LL;
        v34 = 0LL;
        goto LABEL_35;
      }

      v31 = 0LL;
      v46 = 0LL;
    }

    v47 = v46;
    -[NWURLSessionDelegateWrapper task:didCompleteWithError:metrics:]((uint64_t)v31, v4, v6, v47);

LABEL_46:
  }
}

    if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = (os_log_s *)__nwlog_obj();
      v12 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_array_remove_all_objects";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v10) {
          return;
        }
LABEL_36:
        free(v10);
        return;
      }

      if (!v17)
      {
LABEL_35:
        if (!v10) {
          return;
        }
        goto LABEL_36;
      }

      *(_DWORD *)buf = v18;
      v22 = "nw_array_remove_all_objects";
      v13 = "%{public}s called with null array, no backtrace";
    }

    else
    {
      v11 = (os_log_s *)__nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = v18;
      v22 = v1;
      v13 = "%{public}s called with null array, backtrace limit exceeded";
    }

    __break(1u);
    goto LABEL_25;
  }

  if (a1 != a2) {
    std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( a1 + 16,  *(void ***)(a2 + 16),  *(void ***)(a2 + 24),  (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
  }
  do
    v5 = __ldxr(v3);
  while (__stlxr(0, v3));
  if (v5 != 255)
  {
    v11 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v20 = "nw_array_assign";
    v6 = (char *)_os_log_send_and_compose_impl();
    goto LABEL_24;
  }

  if (v7) {
    free(v7);
  }
  v3 = 0LL;
LABEL_7:

  return v3;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  if (v8) {
    free(v8);
  }
  v5 = 255LL;
LABEL_7:

  return v5;
}

  if (v9) {
    free(v9);
  }
  return 1LL;
}

      goto LABEL_25;
    }

    if (!v38)
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
      }
      v12 = (os_log_s *)(id)gbrowserLogObj;
      v29 = type;
      if (os_log_type_enabled(v12, type))
      {
        v30 = *((_DWORD *)self + 48);
        *(_DWORD *)buf = 136446466;
        v41 = "-[NWConcrete_nw_browser dealloc]";
        v42 = 1024;
        v43 = v30;
        _os_log_impl( &dword_181A5C000,  v12,  v29,  "%{public}s [B%u] over-release of nw_browser_t! Object should have deallocated the DNSServiceRef, backtrace limit exceeded",  buf,  0x12u);
      }

      goto LABEL_24;
    }

    v22 = __nw_create_backtrace_string();
    if (!v22)
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
      }
      v12 = (os_log_s *)(id)gbrowserLogObj;
      v33 = type;
      if (os_log_type_enabled(v12, type))
      {
        v34 = *((_DWORD *)self + 48);
        *(_DWORD *)buf = 136446466;
        v41 = "-[NWConcrete_nw_browser dealloc]";
        v42 = 1024;
        v43 = v34;
        _os_log_impl( &dword_181A5C000,  v12,  v33,  "%{public}s [B%u] over-release of nw_browser_t! Object should have deallocated the DNSServiceRef, no backtrace",  buf,  0x12u);
      }

      goto LABEL_24;
    }

    v23 = (char *)v22;
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
    }
    v24 = (os_log_s *)(id)gbrowserLogObj;
    v25 = type;
    if (os_log_type_enabled(v24, type))
    {
      v26 = *((_DWORD *)self + 48);
      *(_DWORD *)buf = 136446722;
      v41 = "-[NWConcrete_nw_browser dealloc]";
      v42 = 1024;
      v43 = v26;
      v44 = 2082;
      v45 = v23;
      _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s [B%u] over-release of nw_browser_t! Object should have deallocated the DNSServiceRef, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

    free(v23);
    if (v11) {
LABEL_26:
    }
      free(v11);
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

    free(backtrace_string);
    goto LABEL_37;
  }

  v5 = v3;
  v6 = [v5 type];

  if (v6 != 6)
  {
LABEL_39:
    v7 = 0LL;
    goto LABEL_40;
  }

  snprintf(a2, 0x3F1uLL, "%016zx", [v5 getHash]);
  v7 = 1LL;
LABEL_40:

  return v7;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      goto LABEL_25;
    }

    if (!(_BYTE)v559)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (os_log_s *)(id)gLogObj;
      v24 = uu[0];
      if (os_log_type_enabled(v18, (os_log_type_t)uu[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_path_parse_necp_parameters";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = a11;
        _os_log_impl( &dword_181A5C000,  v18,  v24,  "%{public}s NECP buffer too short %zu, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_24;
    }

    v21 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (os_log_s *)(id)gLogObj;
    v22 = uu[0];
    v23 = os_log_type_enabled(v18, (os_log_type_t)uu[0]);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_path_parse_necp_parameters";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = a11;
        _os_log_impl(&dword_181A5C000, v18, v22, "%{public}s NECP buffer too short %zu, no backtrace", buf, 0x16u);
      }

      goto LABEL_24;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&buf[4] = "nw_path_parse_necp_parameters";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = a11;
      *(_WORD *)&buf[22] = 2082;
      *(void *)&buf[24] = v21;
      _os_log_impl( &dword_181A5C000,  v18,  v22,  "%{public}s NECP buffer too short %zu, dumping backtrace:%{public}s",  buf,  0x20u);
    }

  if (v11) {
    free(v11);
  }
  v7 = 0LL;
LABEL_8:

  return v7;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  v16 = 0;
LABEL_25:
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = v16;
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    nw_frame_claim(a2, v8, v12 - v6, 0);
    v19 = (unsigned int *)a1[6];
    v20 = 0LL;
    if (v19) {
      *v19 = v12;
    }
    return v20;
  }

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_25;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v10 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v11 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          v19 = "nw_protocol_http3_input_available";
          v20 = 2082;
          v21 = handle + 1289;
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v11;
          _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }

    if (*((nw_protocol **)handle + 131) == a2)
    {
      nw_http3_control_stream_process_input((uint64_t)handle);
      return;
    }

    if (*((nw_protocol **)handle + 133) == a2)
    {
      nw_http3_encoder_stream_process_input((uint64_t)handle);
      return;
    }

    if (*((nw_protocol **)handle + 135) == a2)
    {
      nw_http3_decoder_stream_process_input((uint64_t)handle);
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http3_input_available";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v4, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (os_log_s *)gLogObj;
        v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http3_input_available";
        v7 = "%{public}s input_available for unknown stream";
        goto LABEL_24;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (os_log_s *)gLogObj;
        v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http3_input_available";
        v7 = "%{public}s input_available for unknown stream, backtrace limit exceeded";
        goto LABEL_24;
      }

      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (os_log_s *)gLogObj;
      v6 = type;
      v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v8)
      {
        if (!v9) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http3_input_available";
        v7 = "%{public}s input_available for unknown stream, no backtrace";
        goto LABEL_24;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_protocol_http3_input_available";
        v20 = 2082;
        v21 = v8;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s input_available for unknown stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v8);
    }

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_25;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v10 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v11 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          v19 = "nw_protocol_http3_output_available";
          v20 = 2082;
          v21 = handle + 1289;
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v11;
          _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }

    if (*((nw_protocol **)handle + 4) == a2)
    {
      nw_http3_control_stream_process_output((uint64_t)handle, (uint64_t)a2);
      return;
    }

    if (*((nw_protocol **)handle + 132) == a2)
    {
      nw_http3_encoder_stream_process_output((uint64_t)handle);
      return;
    }

    if (*((nw_protocol **)handle + 134) == a2)
    {
      nw_http3_decoder_stream_process_output((uint64_t)handle);
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http3_output_available";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v4, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (os_log_s *)gLogObj;
        v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http3_output_available";
        v7 = "%{public}s output_available for unknown stream";
        goto LABEL_24;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (os_log_s *)gLogObj;
        v6 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http3_output_available";
        v7 = "%{public}s output_available for unknown stream, backtrace limit exceeded";
        goto LABEL_24;
      }

      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (os_log_s *)gLogObj;
      v6 = type;
      v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v8)
      {
        if (!v9) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http3_output_available";
        v7 = "%{public}s output_available for unknown stream, no backtrace";
        goto LABEL_24;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_protocol_http3_output_available";
        v20 = 2082;
        v21 = v8;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s output_available for unknown stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v8);
    }

    free(backtrace_string);
    goto LABEL_34;
  }

  v8 = (os_log_s *)__nwlog_obj();
  v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    v18 = "nw_socket_updated_path";
    v10 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
  }

    free(backtrace_string);
    if (!v11) {
      return 0LL;
    }
    goto LABEL_42;
  }

  pcap_activate_delayInitStub(v7);
  inited = pcap_ng_dump_open_delayInitStub(v8);
  *((void *)handle + 10) = inited;
  if (inited) {
    return 1LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v35 = "nw_protocol_recorder_add_input_handler";
  v36 = 2082;
  v37 = __str;
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v32 = 0;
  if (__nwlog_fault(v11, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (os_log_s *)gLogObj;
      v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v14 = "%{public}s pcap_create: %{public}s failed";
      goto LABEL_39;
    }

    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (os_log_s *)gLogObj;
      v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v14 = "%{public}s pcap_create: %{public}s failed, backtrace limit exceeded";
      goto LABEL_39;
    }

    v22 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (os_log_s *)gLogObj;
    v13 = type;
    v23 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v22)
    {
      if (!v23) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v14 = "%{public}s pcap_create: %{public}s failed, no backtrace";
      goto LABEL_39;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446722;
      v35 = "nw_protocol_recorder_add_input_handler";
      v36 = 2082;
      v37 = __str;
      v38 = 2082;
      v39 = v22;
      _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s pcap_create: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v22);
  }

    free(backtrace_string);
    goto LABEL_34;
  }

  v14 = (os_log_s *)__nwlog_obj();
  v15 = v26;
  if (os_log_type_enabled(v14, v26))
  {
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_recorder_get_input_frames";
    v16 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
  }

  if (v15) {
    free(v15);
  }
  v11 = 0LL;
LABEL_7:

  return v11;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_26;
  }

  if ((*((_BYTE *)v1 + 475) & 1) == 0)
  {
    v3 = v1[3];
    if (!v3
      || (v4 = v3, v5 = *((_BYTE *)v4 + 231), v4, (v5 & 1) == 0)
      && nw_endpoint_get_type(v2[3]) != nw_endpoint_type_bonjour_service
      && nw_endpoint_get_type(v2[3]) != 6)
    {
LABEL_26:
      v6 = 0LL;
      goto LABEL_27;
    }
  }

  v6 = 1LL;
LABEL_27:

  return v6;
}

    if (!v9)
    {
LABEL_26:
      v6 = 0LL;
      goto LABEL_27;
    }

    if (!v7)
    {
LABEL_26:
      v4 = 0LL;
      goto LABEL_27;
    }

    if (!v9)
    {
LABEL_26:
      v6 = 0LL;
      goto LABEL_27;
    }

    if (!v7)
    {
LABEL_26:
      v4 = 0LL;
      goto LABEL_27;
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_5;
  }

  if (a3) {
    *a3 = *((_DWORD *)v5 + 42);
  }
  v7 = v5 + 8;
  if (!uuid_is_null((const unsigned __int8 *)v5 + 128))
  {
    *a2 = *v7;
    v8 = 1LL;
    goto LABEL_7;
  }

      free(backtrace_string);
    }
  }

    if (v6) {
      free(v6);
    }
    goto LABEL_26;
  }

  if (*((_DWORD *)v1 + 94) != 2 || *((_DWORD *)v1 + 95) != 3)
  {
LABEL_26:
    v4 = 0LL;
    goto LABEL_27;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  v20 = 0;
  v3 = (void *)*((void *)v1 + 28);
  if (v3)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = __nw_path_trigger_inactive_cellular_agent_if_necessary_block_invoke;
    applier[3] = &unk_189BC51C0;
    v15 = v1;
    v16 = buf;
    xpc_dictionary_apply(v3, applier);

    v4 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
  }

  else
  {
    v4 = 0LL;
  }

  _Block_object_dispose(buf, 8);
LABEL_27:

  return v4;
}

    free(backtrace_string);
    goto LABEL_37;
  }

  network_agent_dictionary = v9->network_agent_dictionary;
  if (!network_agent_dictionary)
  {
LABEL_39:
    v12 = 0LL;
    goto LABEL_40;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  v34 = 0;
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = ___ZL27nw_path_get_vpn_config_uuidP18NWConcrete_nw_pathPA16_hPibbb_block_invoke;
  applier[3] = &unk_189BC55D8;
  v28 = a5;
  v29 = 1;
  v30 = a4;
  applier[5] = a2;
  applier[6] = a3;
  applier[4] = buf;
  xpc_dictionary_apply(network_agent_dictionary, applier);
  v12 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
  _Block_object_dispose(buf, 8);
LABEL_40:

  return v12;
}

    free(backtrace_string);
    goto LABEL_37;
  }

  v5 = (void *)*((void *)v3 + 28);
  if (!v5)
  {
LABEL_39:
    v6 = 0LL;
    goto LABEL_40;
  }

  *(void *)type = 0LL;
  v22 = type;
  v23 = 0x2020000000LL;
  v24 = 0;
  *(void *)applier = MEMORY[0x1895F87A8];
  *(void *)&applier[8] = 3221225472LL;
  *(void *)&applier[16] = ___ZL35nw_path_get_private_dns_config_uuidP18NWConcrete_nw_pathPA16_hPi_block_invoke;
  v27 = &unk_189BC5470;
  v29 = a2;
  v30 = 0LL;
  v28 = type;
  xpc_dictionary_apply(v5, applier);
  v6 = *((_BYTE *)v22 + 24) != 0;
  _Block_object_dispose(type, 8);
LABEL_40:

  return v6;
}

  return v6;
}

  if (v9) {
    free(v9);
  }
LABEL_8:

  return singleton;
}

  if (v9) {
    free(v9);
  }
LABEL_8:

  return singleton;
}

  if (v11) {
    free(v11);
  }
LABEL_8:

  return singleton;
}

      if (v10) {
        free(v10);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)gLogObj;
    v12 = type;
    v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_string_create_with_c_string";
        v13 = "%{public}s called with null self, no backtrace";
        goto LABEL_23;
      }

      goto LABEL_24;
    }

    if (!v15)
    {
LABEL_18:
      free(backtrace_string);
      goto LABEL_24;
    }

    *(_DWORD *)buf = 136446466;
    v22 = "nw_string_create_with_c_string";
    v23 = 2082;
    v24 = backtrace_string;
    v16 = "%{public}s called with null self, dumping backtrace:%{public}s";
LABEL_17:
    _os_log_impl(&dword_181A5C000, v11, v12, v16, buf, 0x16u);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

      if (v10) {
        free(v10);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)gLogObj;
    v12 = v21;
    v15 = os_log_type_enabled((os_log_t)gLogObj, v21);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_string_create_with_dispatch_data";
        v13 = "%{public}s called with null self, no backtrace";
        goto LABEL_23;
      }

      goto LABEL_24;
    }

    if (!v15)
    {
LABEL_18:
      free(backtrace_string);
      goto LABEL_24;
    }

    *(_DWORD *)buf = 136446466;
    v23 = "nw_string_create_with_dispatch_data";
    v24 = 2082;
    v25 = backtrace_string;
    v16 = "%{public}s called with null self, dumping backtrace:%{public}s";
LABEL_17:
    _os_log_impl(&dword_181A5C000, v11, v12, v16, buf, 0x16u);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

    if (!v4) {
      return;
    }
    goto LABEL_25;
  }

  if (handle[19] != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (os_log_s *)gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
      v7 = "%{public}s Ignoring listen protocol disconnected, not sent by version specific protocol";
      goto LABEL_23;
    }

    if (!v17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (os_log_s *)gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
      v7 = "%{public}s Ignoring listen protocol disconnected, not sent by version specific protocol, backtrace limit exceeded";
      goto LABEL_23;
    }

    v9 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (os_log_s *)gLogObj;
    v6 = type;
    v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
      v7 = "%{public}s Ignoring listen protocol disconnected, not sent by version specific protocol, no backtrace";
      goto LABEL_23;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
      v21 = 2082;
      v22 = v9;
      v11 = "%{public}s Ignoring listen protocol disconnected, not sent by version specific protocol, dumping backtrace:%{public}s";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v5, v6, v11, buf, 0x16u);
      goto LABEL_17;
    }

    goto LABEL_17;
  }

  if (((_BYTE)handle[34] & 2) == 0 && gLogDatapath)
  {
    v16 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
      v21 = 2082;
      v22 = (char *)handle + 188;
      v23 = 2080;
      v24 = " ";
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%slower protocol is disconnected",  buf,  0x20u);
    }
  }

  *((_BYTE *)handle + 272) |= 8u;
  nw_protocol_http_messaging_teardown((uint64_t)handle, a3);
}

    free(backtrace_string);
    goto LABEL_34;
  }

  v5 = (os_log_s *)__nwlog_obj();
  v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http_messaging_get_remote_endpoint";
    v7 = "%{public}s called with null protocol";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  if (v14) {
    free(v14);
  }
LABEL_3:

  if (!*(_DWORD *)(*(void *)(a1 + 32) + 232LL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      count = nw_dictionary_get_count(*(void *)(*(void *)(a1 + 32) + 736LL));
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_agent_change_state_block_invoke";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = count;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s changed state to inactive, removing %zu clients",  buf,  0x16u);
    }

    v8 = nw_dictionary_create();
    v10 = *(void *)(a1 + 32);
    v9 = a1 + 32;
    v11 = *(void **)(v10 + 736);
    *(void *)(v10 + 736) = v8;

    v12 = *(void **)(*(void *)v9 + 744LL);
    *(void *)(*(void *)v9 + 744LL) = 0LL;
  }

      free(backtrace_string);
    }
  }

    if (v8) {
      free(v8);
    }
    goto LABEL_5;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  v4 = malloc(0x10uLL);
  if (v4)
  {
    v5 = &v22;
LABEL_4:
    v22 = v4;
    *(_OWORD *)*v5 = *a2;
    v6 = (dispatch_queue_s *)v3[27];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_agent_set_uuid_block_invoke;
    block[3] = &unk_189BC9210;
    v18 = v3;
    v19 = buf;
    dispatch_async(v6, block);

    _Block_object_dispose(buf, 8);
LABEL_5:

    return;
  }

  __nwlog_obj();
  v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  v23 = 136446466;
  v24 = "strict_malloc";
  v25 = 2048;
  v26 = 16LL;
  v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    v5 = (void **)(*(void *)&buf[8] + 24LL);
    goto LABEL_4;
  }

  __break(1u);
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  if (v11) {
    free(v11);
  }
}

      v19 = (void *)*((void *)handle + 14);
      if (v19)
      {
        v20 = v19;
        v21 = (v20[231] & 4) == 0;

        if (v21)
        {
          if ((handle[194] & 0x80000000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v22 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v23 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446978;
              v102 = "nw_protocol_http2_connect";
              v103 = 2082;
              v104 = (char *)(handle + 195);
              v105 = 2080;
              v106 = " ";
              v107 = 1024;
              v108 = v23;
              _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered",  buf,  0x26u);
            }
          }
        }

        else
        {
          nw_endpoint_add_edges_for_instance(v20, (unsigned __int8 *)handle, 0);
        }

        goto LABEL_110;
      }

      if (handle[194] < 0) {
        goto LABEL_110;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v34 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)(handle + 195);
      v105 = 2080;
      v106 = " ";
      v107 = 1024;
      v108 = v34;
      v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v99 = 0;
      if (__nwlog_fault(v35, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v36 = (os_log_s *)gconnectionLogObj;
          v37 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_108;
          }
          v38 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)(handle + 195);
          v105 = 2080;
          v106 = " ";
          v107 = 1024;
          v108 = v38;
          v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
          goto LABEL_107;
        }

        if (!v99)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v36 = (os_log_s *)gconnectionLogObj;
          v37 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_108;
          }
          v54 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)(handle + 195);
          v105 = 2080;
          v106 = " ";
          v107 = 1024;
          v108 = v54;
          v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
          goto LABEL_107;
        }

        v47 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v36 = (os_log_s *)gconnectionLogObj;
        v37 = type;
        v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v47)
        {
          if (v48)
          {
            v49 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136447234;
            v102 = "nw_protocol_http2_connect";
            v103 = 2082;
            v104 = (char *)(handle + 195);
            v105 = 2080;
            v106 = " ";
            v107 = 1024;
            v108 = v49;
            v109 = 2082;
            *(void *)v110 = v47;
            _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s",  buf,  0x30u);
          }

          free(v47);
          goto LABEL_108;
        }

        if (v48)
        {
          v56 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)(handle + 195);
          v105 = 2080;
          v106 = " ";
          v107 = 1024;
          v108 = v56;
          v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_107:
          _os_log_impl(&dword_181A5C000, v36, v37, v39, buf, 0x26u);
        }
      }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (!v16) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v7 = "%{public}s xpc_dictionary_create failed, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v7 = "%{public}s xpc_dictionary_create failed, backtrace limit exceeded";
    }

    v17 = (os_log_s *)v14;
    v18 = v15;
    v19 = 12;
    goto LABEL_35;
  }

  v3 = v2;
  xpc_dictionary_set_data(v2, "data", bytes, v28 + 216LL);
  return v3;
}

  if (v2) {
    free(v2);
  }
  return 1LL;
}

    free(v9);
    goto LABEL_25;
  }

  v13 = v5[56];
  *a3 = v13;
  memcpy(a2, v5 + 36, v13);
  v14 = 1LL;
LABEL_26:

  return v14;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_5;
  }

  if (a2) {
    *a2 = (*(_WORD *)((_BYTE *)v3 + 85) & 0x80) != 0;
  }
  if ((*(_WORD *)((_BYTE *)v3 + 85) & 0x80) != 0)
  {
    v5 = *((unsigned int *)v3 + 18);
    goto LABEL_7;
  }

    if (v8) {
      free(v8);
    }
    goto LABEL_5;
  }

  if (a2) {
    *a2 = *((_BYTE *)v3 + 86) & 1;
  }
  if ((*(_WORD *)((_BYTE *)v3 + 85) & 0x100) != 0)
  {
    v5 = v3[19];
    goto LABEL_7;
  }
  }

  if (v8) {
    free(v8);
  }
  return 0LL;
}

LABEL_26:
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_cache_lock);
  nw_mem_cache_stats_dump();
  nw_mem_cache_update_set_timer::cache_update_timer_set = 0;
  if (nw_mem_cache_operations_during_interval == 1)
  {
    nw_mem_cache_operations_during_interval = 0;
    nw_mem_cache_update_set_timer();
  }

    if (v10) {
      free(v10);
    }
    goto LABEL_9;
  }

  v5 = v3[136];
  if ((v5 & 0x40) == 0)
  {
LABEL_5:
    if (a2) {
      v8 = 2;
    }
    else {
      v8 = 0;
    }
    v4[136] = v5 & 0xFD | v8;
LABEL_9:

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "nw_context_set_isolate_protocol_cache";
  v7 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v7))
  {
    free(v7);
    v5 = v4[136];
    goto LABEL_5;
  }

  __break(1u);
}

    if (v8) {
      free(v8);
    }
    goto LABEL_7;
  }

  v5 = (void *)v3[13];
  if (v5)
  {
    free(v5);
    v4[13] = 0LL;
  }

  if (!a2) {
    goto LABEL_7;
  }
  v6 = strdup(a2);
  if (v6)
  {
LABEL_6:
    v4[13] = v6;
LABEL_7:

    return;
  }

  __nwlog_obj();
  v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    goto LABEL_6;
  }

  __break(1u);
}

      free(backtrace_string);
      if (!v7) {
        goto LABEL_42;
      }
      goto LABEL_41;
    }

    accumulated_size = nw_endpoint_get_accumulated_size(v5);
    if (accumulated_size < 0x1389)
    {
      v29[0] = MEMORY[0x1895F87A8];
      v29[1] = 3221225472LL;
      v29[2] = __nw_endpoint_set_public_keys_block_invoke;
      v29[3] = &unk_189BC9238;
      v14 = v3;
      v29[4] = v14;
      v15 = v5;
      v29[5] = v15;
      os_unfair_lock_lock(v3 + 44);
      __nw_endpoint_set_public_keys_block_invoke((uint64_t)v29);
      os_unfair_lock_unlock(v3 + 44);

      goto LABEL_42;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_endpoint_set_public_keys";
      v34 = 2048;
      v35 = accumulated_size;
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_INFO, "%{public}s Accumulated key-size %zu", buf, 0x16u);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v33 = "nw_endpoint_set_public_keys";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v7, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (os_log_s *)(id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s Accumulated key-size too large", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (!v30)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (os_log_s *)(id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl( &dword_181A5C000,  v8,  v22,  "%{public}s Accumulated key-size too large, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_39;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (os_log_s *)(id)gLogObj;
      v19 = type;
      v20 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_181A5C000, v8, v19, "%{public}s Accumulated key-size too large, no backtrace", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v33 = "nw_endpoint_set_public_keys";
        v34 = 2082;
        v35 = (unint64_t)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s Accumulated key-size too large, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_endpoint_set_public_keys";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v7, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_181A5C000, v8, v24, "%{public}s called with null endpoint", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (!v30)
      {
        __nwlog_obj();
        v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl( &dword_181A5C000,  v8,  v28,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_39;
      }

      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      v27 = os_log_type_enabled(v8, type);
      if (!v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_181A5C000, v8, v26, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_39;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        v33 = "nw_endpoint_set_public_keys";
        v34 = 2082;
        v35 = (unint64_t)v25;
        _os_log_impl( &dword_181A5C000,  v8,  v26,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v25);
    }
  }

    if (v8) {
      free(v8);
    }
    v5 = 0LL;
    goto LABEL_9;
  }

  os_unfair_lock_lock(v1 + 28);
  if (v2[29]._os_unfair_lock_opaque != 2)
  {
    os_unfair_lock_unlock(v2 + 28);
LABEL_8:
    v5 = (nw_endpoint_t)*(id *)&v2[6]._os_unfair_lock_opaque;
    goto LABEL_9;
  }

  v3 = (nw_path *)nw_endpoint_flow_copy_connected_path(*(void **)&v2[62]._os_unfair_lock_opaque);
  v4 = v3;
  if (v3) {
    v5 = nw_path_copy_effective_remote_endpoint(v3);
  }
  else {
    v5 = 0LL;
  }

  os_unfair_lock_unlock(v2 + 28);
  if (!v5) {
    goto LABEL_8;
  }
LABEL_9:

  return v5;
}

  if (v6) {
    free(v6);
  }
  v3 = "null";
LABEL_9:

  return v3;
}

      free(backtrace_string);
    }
  }

    free(v24);
    goto LABEL_27;
  }

  __nwlog_obj();
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)v120 = 136446210;
  *(void *)&v120[4] = "nw_context_start_purge_timer";
  v105 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v105, buf, &type))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v107 = buf[0];
      if (os_log_type_enabled(v106, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v120 = 136446210;
        *(void *)&v120[4] = "nw_context_start_purge_timer";
        _os_log_impl( &dword_181A5C000,  v106,  v107,  "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context))",  v120,  0xCu);
      }
    }

    else if (type)
    {
      v111 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v112 = buf[0];
      v113 = os_log_type_enabled(v106, (os_log_type_t)buf[0]);
      if (v111)
      {
        if (v113)
        {
          *(_DWORD *)v120 = 136446466;
          *(void *)&v120[4] = "nw_context_start_purge_timer";
          *(_WORD *)&v120[12] = 2082;
          *(void *)&v120[14] = v111;
          _os_log_impl( &dword_181A5C000,  v106,  v112,  "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), dumpin g backtrace:%{public}s",  v120,  0x16u);
        }

        free(v111);
        goto LABEL_179;
      }

      if (v113)
      {
        *(_DWORD *)v120 = 136446210;
        *(void *)&v120[4] = "nw_context_start_purge_timer";
        _os_log_impl( &dword_181A5C000,  v106,  v112,  "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), no backtrace",  v120,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v117 = buf[0];
      if (os_log_type_enabled(v106, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v120 = 136446210;
        *(void *)&v120[4] = "nw_context_start_purge_timer";
        _os_log_impl( &dword_181A5C000,  v106,  v117,  "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), backtrac e limit exceeded",  v120,  0xCu);
      }
    }
  }

      free(backtrace_string);
    }
  }

  if (v10) {
    free(v10);
  }
  v7 = 0LL;
LABEL_9:

  return v7;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_28;
  }

  if (v4->policy_result.routing_result != 4
    || (hostname = v4->policy_result.routing_result_parameter.tunnel_interface_index, !(_DWORD)hostname)
    || (a2 & 1) == 0)
  {
    hostname = (uint64_t)nw_endpoint_get_hostname(v4->endpoint);
    if (hostname)
    {
      *(_DWORD *)type = 0;
      if (nw_path_get_vpn_config_uuid(v4, (unsigned __int8 (*)[16])buf, (int *)type, 1, 1))
      {
        v6 = v4->direct;
        if (v6)
        {
          v7 = v6;
          hostname = ne_session_service_get_dns_service_id_for_interface();

          goto LABEL_29;
        }
      }

      free(backtrace_string);
    }
  }

    if (v6) {
      free(v6);
    }
    return 0LL;
  }

  v5 = a3;
  if (uuid_is_null(v5 + 32))
  {

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_channel_set_path_flow_registration";
    v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (os_log_s *)gLogObj;
      v8 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      v26 = "nw_channel_set_path_flow_registration";
      v9 = "%{public}s nw_path_flow_registration_get_id failed";
      goto LABEL_25;
    }

    if (!v24)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (os_log_s *)gLogObj;
      v8 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      v26 = "nw_channel_set_path_flow_registration";
      v9 = "%{public}s nw_path_flow_registration_get_id failed, backtrace limit exceeded";
      goto LABEL_25;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (os_log_s *)gLogObj;
    v8 = type[0];
    v18 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      v26 = "nw_channel_set_path_flow_registration";
      v9 = "%{public}s nw_path_flow_registration_get_id failed, no backtrace";
      goto LABEL_25;
    }

    if (!v18)
    {
LABEL_18:
      free(backtrace_string);
      goto LABEL_26;
    }

    *(_DWORD *)buf = 136446466;
    v26 = "nw_channel_set_path_flow_registration";
    v27 = 2082;
    v28[0] = backtrace_string;
    v19 = "%{public}s nw_path_flow_registration_get_id failed, dumping backtrace:%{public}s";
LABEL_17:
    _os_log_impl(&dword_181A5C000, v7, v8, v19, buf, 0x16u);
    goto LABEL_18;
  }

  *(_OWORD *)type = *((_OWORD *)v5 + 2);

  node = nw_hash_table_get_node(*(void *)(a1 + 280), (uint64_t)type, 16LL);
  if (!node)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (os_log_s *)gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446722;
    v26 = "nw_channel_set_path_flow_registration";
    v27 = 1042;
    LODWORD(v28[0]) = 16;
    WORD2(v28[0]) = 2098;
    *(void *)((char *)v28 + 6) = type;
    _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s Node not found for flow id %{public,uuid_t}.16P",  buf,  0x1Cu);
    return 0LL;
  }

  v11 = node;
  v12 = *(void **)(node + 48);
  *(void *)(node + 48) = os_retain(v5);
  nw_path_flow_registration_get_nexus_flow_index(a2, v5, (_DWORD *)(v11 + 112));
  LODWORD(v11) = *(unsigned __int16 *)(a1 + 444);
  v13 = v5;
  v13[148] = v13[148] & 0xFD | (v11 >> 10) & 2;

  advisory_region = nw_channel_get_advisory_region(a1);
  v15 = v13;
  *((void *)v15 + 10) = advisory_region;

  if (v12) {
    os_release(v12);
  }
  return 1LL;
}

    if (v11) {
      free(v11);
    }
    goto LABEL_28;
  }

  v4 = (id)v1[14];
  if (!v4)
  {
LABEL_28:
    v9 = 0LL;
    goto LABEL_29;
  }

  if (v4 != v3)
  {
    if ((*((_BYTE *)v3 + 231) & 2) == 0)
    {
LABEL_5:
      v5 = (id)nw_endpoint_copy_proxy_original_endpoint(v4, v2);
LABEL_9:
      v9 = v5;
LABEL_29:

      return (BOOL)v9;
    }

  v19 = a3 + 222;
  v20 = a3[222];
  if ((v20 & 0x8000) != 0)
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
    }
    *((_BYTE *)a3 + 446) = ((unsigned __int16)*v19 | (*((unsigned __int8 *)a3 + 446) << 16) | 0x10000u) >> 16;
  }

  else
  {
    v21 = (v20 | (*((unsigned __int8 *)a3 + 446) << 16)) & 0xFFFEFFFF;
    *v19 = v20;
    *((_BYTE *)a3 + 446) = BYTE2(v21);
    if (*((void *)a3 + 17))
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
      }
    }
  }

  if ((*v19 & 0x200) != 0)
  {
    if ((*((_BYTE *)a1 + 186) & 3) == 1)
    {
      if (*((void *)a3 + 17))
      {
        if (*((void *)a3 + 27))
        {
          v216 = 0;
          *(_DWORD *)type = 0;
          v22 = *((void *)a3 + 46);
          while (v22)
          {
            v58 = v22;
            v22 = *(void *)(v22 + 40);
            v59 = *(void *)(v58 + 24);
            ce_count = os_channel_flow_adv_get_ce_count();
            if (ce_count)
            {
              if (ce_count == 6)
              {
                if (!gLogDatapath) {
                  continue;
                }
                v111 = (os_log_s *)__nwlog_obj();
                if (!os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG)) {
                  continue;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v221 = 2082;
                *(void *)v222 = v58 + 84;
                v99 = v111;
                v100 = "%{public}s Channel doesn't support flow-advisory %{public}s";
                goto LABEL_251;
              }

              if (ce_count != 22)
              {
                if (ce_count != 2) {
                  continue;
                }
                if (!gLogDatapath) {
                  continue;
                }
                v98 = (os_log_s *)__nwlog_obj();
                if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG)) {
                  continue;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v221 = 2082;
                *(void *)v222 = v58 + 84;
                v99 = v98;
                v100 = "%{public}s Flow advisory is not not valid for flow id %{public}s";
LABEL_251:
                _os_log_impl(&dword_181A5C000, v99, OS_LOG_TYPE_DEBUG, v100, buf, 0x16u);
                continue;
              }

              __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              v83 = v58 + 84;
              *(void *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
              v221 = 2082;
              *(void *)v222 = v83;
              *(_WORD *)&v222[8] = 1024;
              *(_DWORD *)&v222[10] = 22;
              v84 = (const char *)_os_log_send_and_compose_impl();
              LOBYTE(v223) = 16;
              v219 = OS_LOG_TYPE_DEFAULT;
              if (v223 == 17)
              {
                v85 = (os_log_s *)__nwlog_obj();
                v86 = v223;
                loga = v85;
                if (os_log_type_enabled(v85, (os_log_type_t)v223))
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                  v221 = 2082;
                  *(void *)v222 = v83;
                  *(_WORD *)&v222[8] = 1024;
                  *(_DWORD *)&v222[10] = 22;
                  v87 = loga;
                  v88 = v86;
                  v89 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d";
                  goto LABEL_246;
                }

                goto LABEL_247;
              }

              if (v219)
              {
                v104 = (char *)__nw_create_backtrace_string();
                v201 = (os_log_s *)__nwlog_obj();
                v207 = v223;
                v105 = os_log_type_enabled(v201, (os_log_type_t)v223);
                if (v104)
                {
                  if (v105)
                  {
                    *(_DWORD *)buf = 136446978;
                    *(void *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                    v221 = 2082;
                    *(void *)v222 = v83;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = 22;
                    *(_WORD *)&v222[14] = 2082;
                    *(void *)&v222[16] = v104;
                    _os_log_impl( &dword_181A5C000,  v201,  v207,  "%{public}s Ring is not TX %{public}s %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
                  }

                  free(v104);
                  goto LABEL_247;
                }

                if (!v105)
                {
LABEL_247:
                  if (!v84) {
                    continue;
                  }
                  v72 = (char *)v84;
                  goto LABEL_177;
                }

                *(_DWORD *)buf = 136446722;
                *(void *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v221 = 2082;
                *(void *)v222 = v83;
                *(_WORD *)&v222[8] = 1024;
                *(_DWORD *)&v222[10] = 22;
                v87 = v201;
                v88 = v207;
                v89 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d, no backtrace";
              }

              else
              {
                v109 = (os_log_s *)__nwlog_obj();
                v110 = v223;
                logc = v109;
                if (!os_log_type_enabled(v109, (os_log_type_t)v223)) {
                  goto LABEL_247;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v221 = 2082;
                *(void *)v222 = v83;
                *(_WORD *)&v222[8] = 1024;
                *(_DWORD *)&v222[10] = 22;
                v87 = logc;
                v88 = v110;
                v89 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d, backtrace limit exceeded";
              }

    if (v13 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v80 = output_handler[1].callbacks;
      if (v80)
      {
        v81 = (nw_protocol_callbacks *)((char *)v80 - 1);
        output_handler[1].callbacks = v81;
        if (!v81)
        {
          v82 = *(void (***)(void))output_handler[1].flow_id;
          if (v82)
          {
            *(void *)output_handler[1].flow_id = 0LL;
            v82[2](v82);
            _Block_release(v82);
          }

          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            v83 = *(const void **)output_handler[1].flow_id;
            if (v83) {
              _Block_release(v83);
            }
          }

          free(output_handler);
        }
      }
    }

    *((_DWORD *)v193 + 6) = v19;
    if (!v19) {
      goto LABEL_212;
    }
    *(void *)v188 = 0LL;
    v189 = v188;
    v191 = 0;
    v190 = 0x2000000000LL;
    v186[0] = 0LL;
    v186[1] = v186;
    v186[2] = 0x2000000000LL;
    v187 = 0;
    v182[0] = 0LL;
    v182[1] = v182;
    v182[2] = 0x2000000000LL;
    v183 = 0;
    v184 = 0LL;
    v185 = (nw_frame **)&v184;
    v172[0] = MEMORY[0x1895F87A8];
    v172[1] = 0x40000000LL;
    v173 = (uint64_t (*)(void *))___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    v174 = &unk_189BC88B0;
    v175 = v186;
    v176 = v182;
    v179 = v12;
    v180 = v8;
    v181 = &v184;
    v177 = &v192;
    v178 = v188;
    tqh_first = v12->tqh_first;
    do
    {
      if (!tqh_first) {
        break;
      }
      v21 = (nw_frame *)*((void *)tqh_first + 4);
      v22 = v173(v172);
      tqh_first = v21;
    }

    while ((v22 & 1) != 0);
    v171 = 0;
    do
    {
      v25 = nw_protocol_ipv4_process_reassembly((uint64_t)v8, 0, (uint64_t)&v184, 0, &v171);
      *((_DWORD *)v193 + 6) += v25;
      if (!v171) {
        break;
      }
      v170[0] = 0LL;
      v170[1] = v170;
      v166 = 0LL;
      v167 = &v166;
      v168 = 0x2000000000LL;
      v26 = a1->output_handler;
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "__nw_protocol_get_input_frames";
        v55 = (char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        if (v197 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = gLogObj;
          v57 = v197;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_input_frames";
            v58 = (os_log_s *)v56;
            v59 = v57;
            v60 = "%{public}s called with null protocol";
            goto LABEL_126;
          }

          goto LABEL_127;
        }

        if (v196)
        {
          v67 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v68 = (os_log_s *)gLogObj;
          v69 = v197;
          v70 = os_log_type_enabled((os_log_t)gLogObj, v197);
          if (v67)
          {
            if (v70)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v67;
              _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v67);
            goto LABEL_127;
          }

          if (!v70)
          {
LABEL_127:
            if (v55) {
              free(v55);
            }
            v33 = 0;
            goto LABEL_52;
          }

          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = v68;
          v59 = v69;
          v60 = "%{public}s called with null protocol, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v74 = gLogObj;
          v75 = v197;
          if (!os_log_type_enabled((os_log_t)gLogObj, v197)) {
            goto LABEL_127;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = (os_log_s *)v74;
          v59 = v75;
          v60 = "%{public}s called with null protocol, backtrace limit exceeded";
        }

        *v17 = *(void *)(v4 + 384);
        *(void *)(v4 + 384) = v17;
        ++*(_DWORD *)(v4 + 392);
        goto LABEL_12;
      }

      v37 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      *(void *)&buf[4] = "strict_malloc_zone_memalign";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v14;
      v41 = 2048;
      v42 = v16;
      v21 = (void *)_os_log_send_and_compose_impl();
      free(v21);
      v6 = *(_DWORD *)(v4 + 560);
      if (v6 == *v12) {
        goto LABEL_26;
      }
LABEL_12:
      v5 = *(_DWORD *)(v4 + 552);
      if (v5 < v6) {
        goto LABEL_6;
      }
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_mem_buffer_free";
    _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s buffer cache is NULL", buf, 0xCu);
  }

      free(backtrace_string);
      goto LABEL_36;
    }

    v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv4_copy_info";
    v9 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
LABEL_36:
    if (v6) {
      free(v6);
    }
    return 0LL;
  }

  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv4_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = (os_log_s *)__nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv4_copy_info";
      v9 = "%{public}s called with null ipv4";
      goto LABEL_35;
    }

    if (!v17)
    {
      v7 = (os_log_s *)__nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv4_copy_info";
      v9 = "%{public}s called with null ipv4, backtrace limit exceeded";
      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    v16 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_ipv4_copy_info";
        v21 = 2082;
        v22 = (uint64_t)backtrace_string;
        v12 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
        goto LABEL_25;
      }

      goto LABEL_26;
    }

    if (!v16) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv4_copy_info";
    v9 = "%{public}s called with null ipv4, no backtrace";
    goto LABEL_35;
  }

  if (a2 != 5) {
    return 0LL;
  }
  v5 = (char *)calloc(1uLL, 0xB8uLL);
  if (v5) {
    goto LABEL_5;
  }
  v13 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v20 = "strict_calloc";
  v21 = 2048;
  v22 = 1LL;
  v23 = 2048;
  v24 = 184LL;
  v14 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
LABEL_5:
    *(_OWORD *)(v5 + 8) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(v5 + 24) = *(_OWORD *)(a1 + 120);
    *((void *)v5 + 5) = *(void *)(a1 + 96);
    if (a3) {
      *a3 = 184LL;
    }
    return (BOOL)v5;
  }

  __break(1u);
  return result;
}

        goto LABEL_27;
      }

      if ((v11[67] & 0x20) != 0)
      {
LABEL_27:
        if (v11[30] == 5)
        {
          if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v11) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v29 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
            {
              v30 = nw_endpoint_handler_get_id_string(v11);
              v31 = nw_endpoint_handler_dry_run_string(v11);
              v32 = nw_endpoint_handler_copy_endpoint(v11);
              v33 = v6;
              v34 = nw_endpoint_get_logging_description(v32);
              v35 = nw_endpoint_handler_state_string(v11);
              v36 = nw_endpoint_handler_mode_string(v11);
              v37 = nw_endpoint_handler_copy_current_path(v11);
              *(_DWORD *)buf = 136447746;
              v70 = "nw_endpoint_handler_cancel";
              v71 = 2082;
              v72 = (void *)v30;
              v73 = 2082;
              v74 = v31;
              v75 = 2082;
              v76 = v34;
              v77 = 2082;
              v78 = v35;
              v79 = 2082;
              v80 = v36;
              v81 = 2114;
              v82 = v37;
              _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Handler already cancell ed, ignoring cancel",  buf,  0x48u);

              v6 = v33;
            }
          }
        }

        else
        {
          if (a3)
          {
            v11[30] = 4;
            v11[20] = 458753;
            nw_endpoint_handler_report(v11, 0LL, (_WORD *)v11 + 40, 0LL);
          }

          v38 = *((void *)v11 + 17);
          if (v38)
          {
            nw_queue_cancel_source(v38, v15);
            *((void *)v11 + 17) = 0LL;
          }

          v39 = (void *)*((void *)v11 + 9);
          *((void *)v11 + 9) = 0LL;

          v40 = (void *)v6[4];
          v6[4] = 0LL;

          os_unfair_lock_lock((os_unfair_lock_t)v11 + 28);
          v41 = (void *)*((void *)v11 + 8);
          *((void *)v11 + 8) = 0LL;

          os_unfair_lock_unlock((os_unfair_lock_t)v11 + 28);
          v42 = (void *)*((void *)v11 + 7);
          if (v42)
          {
            nw_association_unregister(v42, v11);
            v43 = (void *)*((void *)v11 + 7);
            *((void *)v11 + 7) = 0LL;
          }

          v44 = (void *)*((void *)v11 + 11);
          *((void *)v11 + 11) = 0LL;

          v45 = (void *)*((void *)v11 + 12);
          *((void *)v11 + 12) = 0LL;

          v46 = (void *)*((void *)v11 + 13);
          *((void *)v11 + 13) = 0LL;

          v11[30] = 5;
          v47 = *((id *)v11 + 31);
          [v47 cancelWithHandler:v11 forced:a2];

          if (v11[29] == 2) {
            nw_endpoint_handler_cancel_read_write_requests(v11, 0LL);
          }
        }

        goto LABEL_43;
      }
    }

    else
    {

      if ((v11[67] & 0x20) != 0) {
        goto LABEL_27;
      }
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v16 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      if ((v11[67] & 1) != 0) {
        v17 = "dry-run ";
      }
      else {
        v17 = "";
      }
      v65 = v6;
      v18 = nw_endpoint_handler_copy_endpoint(v11);
      v19 = nw_endpoint_get_logging_description(v18);
      v63 = a3;
      v20 = v11[30];
      v21 = v19;
      else {
        v22 = off_189BBBBF0[v20];
      }
      v23 = v11;
      v24 = (os_unfair_lock_s *)v23;
      v62 = a2;
      v25 = "path";
      switch(v23[29])
      {
        case 0u:
          break;
        case 1u:
          v25 = "resolver";
          break;
        case 2u:
          v25 = nw_endpoint_flow_mode_string(*((void **)v23 + 31));
          break;
        case 3u:
          v25 = "proxy";
          break;
        case 4u:
          v25 = "fallback";
          break;
        case 5u:
          v25 = "transform";
          break;
        default:
          v25 = "unknown-mode";
          break;
      }

      v26 = v24 + 28;
      v27 = v24;
      os_unfair_lock_lock(v24 + 28);
      v28 = v27[8];
      os_unfair_lock_unlock(v26);

      *(_DWORD *)buf = 136447746;
      v70 = "nw_endpoint_handler_cancel";
      v71 = 2082;
      v72 = v11 + 42;
      v73 = 2082;
      v74 = v17;
      v75 = 2082;
      v76 = v21;
      v77 = 2082;
      v78 = v22;
      v79 = 2082;
      v80 = v25;
      v81 = 2114;
      v82 = v28;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);

      v6 = v65;
      a2 = v62;
      a3 = v63;
    }

    goto LABEL_26;
  }

  __nwlog_obj();
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v70 = "nw_endpoint_handler_cancel";
  v49 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v67 = 0;
  if (__nwlog_fault(v49, &type, &v67))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446210;
        v70 = "nw_endpoint_handler_cancel";
        _os_log_impl(&dword_181A5C000, v50, v51, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v67)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v59 = type;
      v60 = os_log_type_enabled(v50, type);
      if (backtrace_string)
      {
        if (v60)
        {
          *(_DWORD *)buf = 136446466;
          v70 = "nw_endpoint_handler_cancel";
          v71 = 2082;
          v72 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v50,  v59,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_65;
      }

      if (v60)
      {
        *(_DWORD *)buf = 136446210;
        v70 = "nw_endpoint_handler_cancel";
        _os_log_impl(&dword_181A5C000, v50, v59, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v61 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446210;
        v70 = "nw_endpoint_handler_cancel";
        _os_log_impl( &dword_181A5C000,  v50,  v61,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_27:
    if (!v20) {
      goto LABEL_29;
    }
LABEL_28:
    free(v20);
    goto LABEL_29;
  }

  if (!v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = (os_log_s *)(id)gLogObj;
    v26 = type;
    if (os_log_type_enabled(v21, type))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_endpoint_handler_get_svcb_report";
      _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_26;
  }

  v23 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v21 = (os_log_s *)(id)gLogObj;
  v24 = type;
  v25 = os_log_type_enabled(v21, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_endpoint_handler_get_svcb_report";
      _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
    }

    goto LABEL_26;
  }

  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    v30 = "nw_endpoint_handler_get_svcb_report";
    v31 = 2082;
    v32 = v23;
    _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v23);
  if (v20) {
    goto LABEL_28;
  }
LABEL_29:
}

  if (v8) {
    free(v8);
  }
  v5 = 0LL;
LABEL_8:

  return v5;
}

    v72 = v112;
    goto LABEL_27;
  }

  v72 = v112;
LABEL_27:
  v73 = (uint64_t)v102;
  swift_release();
  v74 = 1LL << *(_BYTE *)(v72 + 32);
  v75 = -1LL;
  if (v74 < 64) {
    v75 = ~(-1LL << v74);
  }
  v76 = v75 & *(void *)(v72 + 56);
  v119 = (unint64_t)(v74 + 63) >> 6;
  swift_bridgeObjectRetain();
  v118 = v72 + 56;
  if (v76)
  {
    v77 = __clz(__rbit64(v76));
    goto LABEL_41;
  }

  v78 = 1LL;
  if (v119 > 1)
  {
    v79 = *(void *)(v72 + 64);
    if (v79)
    {
LABEL_40:
      v77 = __clz(__rbit64(v79)) + (v78 << 6);
LABEL_41:
      v81 = v105;
      sub_181BC9248( *(void *)(v112 + 48) + *(void *)(v106 + 72) * v77,  v105,  type metadata accessor for NWBrowser.Result.Change);
      sub_181BC928C(v81, v73, type metadata accessor for NWBrowser.Result.Change);
      v82 = (char *)&loc_181BC2520 + *((int *)qword_181BC2AB8 + swift_getEnumCaseMultiPayload());
      __asm { BR              X9 }
    }

    v80 = 2LL;
    if (v119 > 2)
    {
      v79 = *(void *)(v72 + 72);
      if (v79) {
        goto LABEL_39;
      }
      v80 = 3LL;
      if (v119 <= 3) {
        goto LABEL_46;
      }
      v79 = *(void *)(v72 + 80);
      if (v79)
      {
LABEL_39:
        v78 = v80;
        goto LABEL_40;
      }

      v80 = 4LL;
      if (v119 > 4)
      {
        v79 = *(void *)(v72 + 88);
        if (!v79)
        {
          while (1)
          {
            v78 = v80 + 1;
            if (__OFADD__(v80, 1LL)) {
              break;
            }
            if (v78 >= v119) {
              goto LABEL_46;
            }
            v79 = *(void *)(v72 + 56 + 8 * v78);
            ++v80;
            if (v79) {
              goto LABEL_40;
            }
          }

  __break(1u);
  return result;
}

  if (a1->__r_.__value_.__l.__size_)
  {
LABEL_9:
    if ((v5 & 0x80) == 0) {
      goto LABEL_10;
    }
LABEL_30:
    if (a1->__r_.__value_.__l.__size_) {
      goto LABEL_53;
    }
    goto LABEL_31;
  }

    operator delete(v17[0]);
    if ((v16 & 0x80000000) == 0)
    {
LABEL_15:
      if ((v14 & 0x80000000) == 0)
      {
LABEL_16:
        return;
      }

      free(backtrace_string);
      if (!v7) {
        goto LABEL_141;
      }
      goto LABEL_69;
    }

    xpc_dictionary_get_value(v5, (const char *)networkd_privileged_key_result);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v16 = v15;
    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v29 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      v18 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        v30 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_181A5C000, v19, v30, "%{public}s received response without result code", buf, 0xCu);
        }

        goto LABEL_136;
      }

      if (!v94)
      {
        __nwlog_obj();
        v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v65 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl( &dword_181A5C000,  v19,  v65,  "%{public}s received response without result code, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_136;
      }

      v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v45 = type;
      v46 = os_log_type_enabled(v19, type);
      if (!v42)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl( &dword_181A5C000,  v19,  v45,  "%{public}s received response without result code, no backtrace",  buf,  0xCu);
        }

        goto LABEL_136;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v98 = 2082;
        *(void *)v99 = v42;
        _os_log_impl( &dword_181A5C000,  v19,  v45,  "%{public}s received response without result code, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_82;
    }

    if (object_getClass(v15) != (Class)MEMORY[0x1895F9280])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      v18 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s received invalid result type", buf, 0xCu);
        }
}

  if (v14) {
    free(v14);
  }
  v11 = 0;
LABEL_6:

  return v11;
}

    free(backtrace_string);
    goto LABEL_39;
  }

  nw_context_assert_queue(v3[46]);
  v5 = v4[47];
  if (!v5)
  {
    v5 = (id)nw_protocol_copy_shared_connection_state((uint64_t)(v4 + 36), (uint64_t)v4[1], v4[46], 0);
    if (!v5)
    {
LABEL_41:
      v6 = 0LL;
      goto LABEL_6;
    }
  }

  v6 = nw_dictionary_copy_value((uint64_t)v5, a2);

LABEL_6:
  return v6;
}

  if ((v11 & a3) != 1) {
    return !v11;
  }
  if (!*(_BYTE *)(a2 + 24)) {
    return 1LL;
  }
  v20 = *(void **)a2;
  *(void *)a2 = 0LL;

  v21 = *(void **)(a2 + 8);
  *(void *)(a2 + 8) = 0LL;

  v22 = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = 0LL;

  return 0LL;
}

  if (v11) {
    free(v11);
  }
LABEL_9:
}

    free(backtrace_string);
    if (!v22) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }

  v6 = v3[8];
  if (!v6)
  {
LABEL_17:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v56 = "nw_connection_group_copy_remote_endpoint_for_message";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (os_log_s *)(id)gLogObj;
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s Group descriptor is not set", buf, 0xCu);
      }

      goto LABEL_33;
    }

    if (!v53)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (os_log_s *)(id)gLogObj;
      v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s Group descriptor is not set, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (os_log_s *)(id)gLogObj;
    v26 = type;
    v27 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v26, "%{public}s Group descriptor is not set, no backtrace", buf, 0xCu);
      }

      goto LABEL_33;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v56 = "nw_connection_group_copy_remote_endpoint_for_message";
      v57 = 2082;
      v58 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s Group descriptor is not set, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_26;
  }

  v7 = v6;
  v8 = v7[2];

  if (v8 != 1)
  {
    v11 = v3[8];
    if (v11)
    {
      v12 = v11;
      v13 = v12[2];

      if (v13 == 2) {
        goto LABEL_12;
      }
      v14 = v3[8];
      if (v14)
      {
        v15 = v14;
        v16 = v15[2];

        if (v16 == 4)
        {
LABEL_12:
          v10 = nw_connection_group_copy_connection_for_message(v3, v5);
          if (!v10) {
            goto LABEL_7;
          }
          goto LABEL_13;
        }

        if (v3[8])
        {
          __nwlog_obj();
          v18 = (void *)objc_claimAutoreleasedReturnValue();
          v19 = nw_group_descriptor_get_type(v3[8]);
          if (v19 > 4) {
            v20 = "unknown";
          }
          else {
            v20 = off_189BB74C8[v19];
          }
          *(_DWORD *)buf = 136446466;
          v56 = "nw_connection_group_copy_remote_endpoint_for_message";
          v57 = 2080;
          v58 = (void *)v20;
          v22 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v53 = 0;
          if (__nwlog_fault(v22, &type, &v53))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v30 = type;
              if (os_log_type_enabled(v23, type))
              {
                v31 = nw_group_descriptor_get_type(v3[8]);
                if (v31 > 4) {
                  v32 = "unknown";
                }
                else {
                  v32 = off_189BB74C8[v31];
                }
                *(_DWORD *)buf = 136446466;
                v56 = "nw_connection_group_copy_remote_endpoint_for_message";
                v57 = 2080;
                v58 = (void *)v32;
                _os_log_impl(&dword_181A5C000, v23, v30, "%{public}s Unsupported group descriptor type: %s", buf, 0x16u);
              }

      free(backtrace_string);
    }
  }

    if (v10) {
      free(v10);
    }
    goto LABEL_28;
  }

  if (!*((void *)v1 + 4) && v1[2] != 4)
  {
LABEL_28:
    v3 = 0LL;
    goto LABEL_9;
  }

  v3 = -[NWConcrete_nw_group_descriptor initWithType:member:groupID:]( (uint64_t *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_group_descriptor),  v1[2],  0LL,  (_OWORD *)v1 + 1);
  v4 = *((void *)v2 + 4);
  if (v4)
  {
    v5 = nw_array_create();
    if (v5 != v4)
    {
      v6 = v5;
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v5 + 16,  *(void ***)(v4 + 16),  *(void ***)(v4 + 24),  (uint64_t)(*(void *)(v4 + 24) - *(void *)(v4 + 16)) >> 3);
      v4 = v6;
    }

    v7 = (void *)v3[4];
    v3[4] = v4;
  }

  objc_storeStrong((id *)v3 + 5, *((id *)v2 + 5));
  *((_BYTE *)v3 + 48) = v3[6] & 0xFE | v2[12] & 1;
LABEL_9:

  return v3;
}

  if ((v5 & 0x40) == 0) {
    goto LABEL_45;
  }
  BYTE3(v2->flow_in_connected) = v5 & 0xBF;
  v16 = *(void **)&v2[-1].log_str[41];
  if (v16)
  {
    v17 = (void *)v16[5];
    if (v17 == &nw_protocol_ref_counted_handle)
    {
      v19 = v16[11];
      if (v19) {
        v16[11] = v19 + 1;
      }
      v18 = -1;
    }

    else
    {
      v18 = 0;
    }

    *(void *)v74 = v16;
    v75 = v18;
    v20 = *(void **)&v2[-1].log_str[33];
    if (v20 == &nw_protocol_ref_counted_handle)
    {
      v22 = *(void *)&v2[-1].log_str[81];
      if (v22) {
        *(void *)&v2[-1].log_str[81] = v22 + 1;
      }
      v21 = -1;
    }

    else
    {
      v21 = 0;
    }

    p_paths_log_id_num = &v2[-1].paths_log_id_num;
    v73 = v21;
    v23 = v16[3];
    if (v23)
    {
      v24 = *(void (**)(void *, unsigned __int16 *))(v23 + 184);
      if (v24)
      {
        v24(v16, &v2[-1].paths_log_id_num);
LABEL_41:
        if (v20 == &nw_protocol_ref_counted_handle) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
        }
        if (v17 == &nw_protocol_ref_counted_handle) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v74);
        }
        goto LABEL_45;
      }
    }

    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v33 = (const char *)v16[2];
    *(_DWORD *)buf = 136446722;
    v77 = "__nw_protocol_input_finished";
    if (!v33) {
      v33 = "invalid";
    }
    v78 = 2082;
    v79 = (void *)v33;
    v80 = 2048;
    v81 = v16;
    v34 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v70 = 0;
    if (__nwlog_fault(v34, &type, &v70))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          v37 = (const char *)v16[2];
          if (!v37) {
            v37 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v77 = "__nw_protocol_input_finished";
          v78 = 2082;
          v79 = (void *)v37;
          v80 = 2048;
          v81 = v16;
          _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback",  buf,  0x20u);
        }
      }

      else if (v70)
      {
        v50 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v51 = type;
        v52 = os_log_type_enabled(v35, type);
        if (v50)
        {
          if (v52)
          {
            v53 = (const char *)v16[2];
            if (!v53) {
              v53 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            v77 = "__nw_protocol_input_finished";
            v78 = 2082;
            v79 = (void *)v53;
            v80 = 2048;
            v81 = v16;
            v82 = 2082;
            v83 = v50;
            _os_log_impl( &dword_181A5C000,  v35,  v51,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v50);
          goto LABEL_123;
        }

        if (v52)
        {
          v66 = (const char *)v16[2];
          if (!v66) {
            v66 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v77 = "__nw_protocol_input_finished";
          v78 = 2082;
          v79 = (void *)v66;
          v80 = 2048;
          v81 = v16;
          _os_log_impl( &dword_181A5C000,  v35,  v51,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v62 = type;
        if (os_log_type_enabled(v35, type))
        {
          v63 = (const char *)v16[2];
          if (!v63) {
            v63 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v77 = "__nw_protocol_input_finished";
          v78 = 2082;
          v79 = (void *)v63;
          v80 = 2048;
          v81 = v16;
          _os_log_impl( &dword_181A5C000,  v35,  v62,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

  if ((v6 & 0x40) == 0) {
    return 1LL;
  }
  *(_WORD *)(extra + 52) = v6 & 0xFFBF;
  v18 = *(void *)(a1 + 32);
  if (v18) {
    v19 = v18 - 96;
  }
  else {
    v19 = 0LL;
  }
  if (v7)
  {
    v20 = (void *)v7[5];
    if (v20 == &nw_protocol_ref_counted_handle)
    {
      v22 = v7[11];
      if (v22) {
        v7[11] = v22 + 1;
      }
      v21 = -1;
    }

    else
    {
      v21 = 0;
    }

    *(void *)v91 = v7;
    v92 = v21;
    if (v18)
    {
      v23 = *(void **)(v19 + 40);
      if (v23 == &nw_protocol_ref_counted_handle)
      {
        v25 = *(void *)(v19 + 88);
        if (v25) {
          *(void *)(v19 + 88) = v25 + 1;
        }
        v24 = -1;
      }

      else
      {
        v24 = 0;
      }

      *(void *)v88 = v19;
      v89 = v24;
      v26 = v7[3];
      if (v26)
      {
        v27 = *(void (**)(void *))(v26 + 184);
        if (v27)
        {
          v27(v7);
LABEL_45:
          if (v23 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v88);
          }
LABEL_47:
          if (v20 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v91);
          }
          return 1LL;
        }
      }

      __nwlog_obj();
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      v36 = (const char *)v7[2];
      *(_DWORD *)buf = 136446722;
      v94 = "__nw_protocol_input_finished";
      if (!v36) {
        v36 = "invalid";
      }
      v95 = 2082;
      v96 = (void *)v36;
      v97 = 2048;
      v98 = v7;
      v37 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v87 = 0;
      if (__nwlog_fault(v37, &type, &v87))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            v40 = (const char *)v7[2];
            if (!v40) {
              v40 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v94 = "__nw_protocol_input_finished";
            v95 = 2082;
            v96 = (void *)v40;
            v97 = 2048;
            v98 = v7;
            _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback",  buf,  0x20u);
          }
        }

        else if (v87)
        {
          v61 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v62 = type;
          v63 = os_log_type_enabled(v38, type);
          if (v61)
          {
            if (v63)
            {
              v64 = (const char *)v7[2];
              if (!v64) {
                v64 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              v94 = "__nw_protocol_input_finished";
              v95 = 2082;
              v96 = (void *)v64;
              v97 = 2048;
              v98 = v7;
              v99 = 2082;
              v100 = v61;
              _os_log_impl( &dword_181A5C000,  v38,  v62,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v61);
            goto LABEL_150;
          }

          if (v63)
          {
            v84 = (const char *)v7[2];
            if (!v84) {
              v84 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v94 = "__nw_protocol_input_finished";
            v95 = 2082;
            v96 = (void *)v84;
            v97 = 2048;
            v98 = v7;
            _os_log_impl( &dword_181A5C000,  v38,  v62,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v79 = type;
          if (os_log_type_enabled(v38, type))
          {
            v80 = (const char *)v7[2];
            if (!v80) {
              v80 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v94 = "__nw_protocol_input_finished";
            v95 = 2082;
            v96 = (void *)v80;
            v97 = 2048;
            v98 = v7;
            _os_log_impl( &dword_181A5C000,  v38,  v79,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

    stats_area = 0LL;
    goto LABEL_27;
  }

  wakeup = (uint64_t)v5->wakeup;
  if (!wakeup) {
    goto LABEL_26;
  }
LABEL_7:
  stats_area = nw_path_flow_registration_get_stats_area(wakeup, a2);
LABEL_27:

  return stats_area;
}

  v21 = *(void *)(a1 + 40);
  if (v21) {
    v22 = v21 - 96;
  }
  else {
    v22 = 0LL;
  }
  v23 = v6[3];
  if (v23)
  {
    if (v21)
    {
      v24 = *(void (**)(void *))(v23 + 48);
      if (v24)
      {
        v25 = (void *)v6[5];
        if (v25 == &nw_protocol_ref_counted_handle)
        {
          v27 = v6[11];
          if (v27) {
            v6[11] = v27 + 1;
          }
          v26 = -1;
        }

        else
        {
          v26 = 0;
        }

        *(void *)buf = v6;
        buf[8] = v26;
        if (*(_UNKNOWN **)(v22 + 40) == &nw_protocol_ref_counted_handle)
        {
          v30 = *(void *)(v22 + 88);
          v29 = 0;
          if (v30) {
            *(void *)(v22 + 88) = v30 + 1;
          }
          v28 = -1;
        }

        else
        {
          v28 = 0;
          v29 = 1;
        }

        v49 = (void *)v22;
        v50 = v28;
        v24(v6);
        if ((v29 & 1) == 0) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)&v49);
        }
        if (v25 == &nw_protocol_ref_counted_handle) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
        }
      }
    }
  }

  return 1LL;
}
  }

  if (v8) {
    free(v8);
  }
LABEL_9:
}

  if (v8) {
    free(v8);
  }
LABEL_9:
}

              goto LABEL_27;
            }

            nw_protocol_implementation_output_available(a1, a2);
            v18 = BYTE3(v9->flow_in_connected) & 0xF7;
          }

          BYTE3(v9->flow_in_connected) = v18;
          goto LABEL_23;
        }

        __nwlog_obj();
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_link_state";
        v28 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v54 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v34 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_protocol_implementation_link_state";
            _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_111;
        }

        if (!v54)
        {
          __nwlog_obj();
          v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v53 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_protocol_implementation_link_state";
            _os_log_impl( &dword_181A5C000,  v29,  v53,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_111;
        }

        v44 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = type;
        v48 = os_log_type_enabled(v29, type);
        if (!v44)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_protocol_implementation_link_state";
            _os_log_impl( &dword_181A5C000,  v29,  v47,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_111;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_protocol_implementation_link_state";
          v57 = 2082;
          v58 = v44;
          _os_log_impl( &dword_181A5C000,  v29,  v47,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_link_state";
        v28 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v54 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v32 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_protocol_implementation_link_state";
            _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_111;
        }

        if (!v54)
        {
          __nwlog_obj();
          v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v52 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_protocol_implementation_link_state";
            _os_log_impl( &dword_181A5C000,  v29,  v52,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_111;
        }

        v44 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v45 = type;
        v46 = os_log_type_enabled(v29, type);
        if (!v44)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_protocol_implementation_link_state";
            _os_log_impl( &dword_181A5C000,  v29,  v45,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_111;
        }

        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_protocol_implementation_link_state";
          v57 = 2082;
          v58 = v44;
          _os_log_impl( &dword_181A5C000,  v29,  v45,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      free(v44);
      if (!v28) {
        goto LABEL_26;
      }
      goto LABEL_113;
    }

    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_implementation_link_state";
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_link_state";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v54)
    {
      v41 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v42 = type;
      v43 = os_log_type_enabled(v29, type);
      if (v41)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_protocol_implementation_link_state";
          v57 = 2082;
          v58 = v41;
          _os_log_impl( &dword_181A5C000,  v29,  v42,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v41);
LABEL_112:
        if (!v28) {
          goto LABEL_26;
        }
LABEL_113:
        free(v28);
        goto LABEL_26;
      }

      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_link_state";
        _os_log_impl(&dword_181A5C000, v29, v42, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_link_state";
        _os_log_impl( &dword_181A5C000,  v29,  v51,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v14) {
      free(v14);
    }
LABEL_8:
    v7 = 0LL;
  }

    nw_protocol_error(*((void **)handle + 6), (uint64_t)handle);
    nw_protocol_disconnected(*((void **)handle + 6), (uint64_t)handle);
LABEL_17:
    _Block_object_dispose(buf, 8);
    if ((v40 & 1) != 0)
    {
      if (v39) {
        os_release(v39);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_http_authentication_reissue";
  v15 = (char *)_os_log_send_and_compose_impl();
  v41[0] = 16;
  v35 = OS_LOG_TYPE_DEFAULT;
  if (v41[0] == 17)
  {
    v16 = (os_log_s *)__nwlog_obj();
    v17 = v41[0];
    if (!os_log_type_enabled(v16, (os_log_type_t)v41[0])) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http_authentication_reissue";
    v18 = "%{public}s called with null http_authentication";
    goto LABEL_54;
  }

  if (v35 == OS_LOG_TYPE_DEFAULT)
  {
    v16 = (os_log_s *)__nwlog_obj();
    v17 = v41[0];
    if (!os_log_type_enabled(v16, (os_log_type_t)v41[0])) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http_authentication_reissue";
    v18 = "%{public}s called with null http_authentication, backtrace limit exceeded";
    goto LABEL_54;
  }

  v21 = (char *)__nw_create_backtrace_string();
  v16 = (os_log_s *)__nwlog_obj();
  v17 = v41[0];
  v22 = os_log_type_enabled(v16, (os_log_type_t)v41[0]);
  if (!v21)
  {
    if (!v22) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http_authentication_reissue";
    v18 = "%{public}s called with null http_authentication, no backtrace";
    goto LABEL_54;
  }

  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&buf[4] = "nw_http_authentication_reissue";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v21;
    _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v21);
  if (v15) {
    goto LABEL_56;
  }
}

      free(backtrace_string);
      goto LABEL_38;
    }

    v6 = (os_log_s *)__nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136446210;
    v17 = "operator()";
    v8 = "%{public}s called with null protocol";
LABEL_37:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
LABEL_38:
    if (v5) {
      free(v5);
    }
    return 0LL;
  }

  v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "operator()";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = (os_log_s *)__nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "operator()";
      v8 = "%{public}s called with null http_authentication";
      goto LABEL_37;
    }

    if (!v14)
    {
      v6 = (os_log_s *)__nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "operator()";
      v8 = "%{public}s called with null http_authentication, backtrace limit exceeded";
      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = (os_log_s *)__nwlog_obj();
    v7 = type;
    v12 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v17 = "operator()";
        v18 = 2082;
        v19 = backtrace_string;
        v11 = "%{public}s called with null http_authentication, dumping backtrace:%{public}s";
        goto LABEL_25;
      }

      goto LABEL_26;
    }

    if (!v12) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136446210;
    v17 = "operator()";
    v8 = "%{public}s called with null http_authentication, no backtrace";
    goto LABEL_37;
  }

  if ((*(_WORD *)(v3 + 1062) & 0x40) == 0) {
    return 0LL;
  }
  if ((*(_BYTE *)(v3 + 198) & 1) == 0 && gLogDatapath)
  {
    v13 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v17 = "operator()";
      v18 = 2082;
      v19 = (char *)(v3 + 114);
      v20 = 2080;
      v21 = " ";
      _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sretrying pending reissue on a new stream",  buf,  0x20u);
    }
  }

  *(_BYTE *)(v3 + 1060) = 2;
  nw_http_authentication_reissue((nw_protocol *)v3);
  return 1LL;
}

    v3 = 0LL;
LABEL_6:

    return v3;
  }

  if (!a1[3])
  {
    v16 = a1[4];
    if (v16)
    {
      if (a1[6] != a2)
      {
        _os_crash();
        __break(1u);
        goto LABEL_25;
      }

      a1[4] = 0LL;
      v17 = v16;

      v18 = objc_alloc(&OBJC_CLASS___NWURLSessionRequestBodyStream);
      v19 = v3[5];
      v4 = v17;
      v2 = (dispatch_data_s *)v19;
      if (v18)
      {
        cleanup_handler.receiver = v18;
        cleanup_handler.super_class = (Class)&OBJC_CLASS___NWURLSessionRequestBodyStream;
        v3 = objc_msgSendSuper2(&cleanup_handler, sel_init);
        if (!v3)
        {
LABEL_21:

          return v3;
        }

        if (![v4 streamStatus])
        {
          objc_storeStrong(v3 + 2, v16);
          v3[3] = 0LL;
          objc_storeStrong(v3 + 4, v19);
          v20 = objc_alloc_init(&OBJC_CLASS___NWURLSessionReadRequest);
          v21 = v3[5];
          v3[5] = v20;

          goto LABEL_21;
        }

  if (v9) {
    free(v9);
  }
}

  v22 = *((void *)v3 + 2);
  if (v22 && !nw_path_parameters_get_logging_disabled(*(void *)(v22 + 104)))
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    v12 = (os_log_s *)(id)glistenerLogObj;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_INFO)) {
      goto LABEL_33;
    }
    v23 = v3;

    v24 = *((unsigned __int16 *)v3 + 120);
    *(_DWORD *)buf = 136446722;
    v49 = "nw_listener_adjust_awdl_usage_on_queue";
    v50 = 2082;
    v51 = (char *)v23 + 42;
    v52 = 1024;
    LODWORD(v53) = v24;
    v15 = "%{public}s [%{public}s] Decrementing AWDL usage to %d";
    goto LABEL_32;
  }

    return (BOOL)v7;
  }

  v7 = v7;
  v10 = (void *)*((void *)v7 + 10);
  if (v10)
  {
    free(v10);
    *((void *)v7 + 10) = 0LL;
  }

  v11 = strdup(v9);
  if (v11)
  {
LABEL_20:
    *((void *)v7 + 10) = v11;
    *((_BYTE *)v7 + 104) = 0;
    nw_application_id_validate_bundle_id((NWConcrete_nw_application_id *)v7);

    if (gLogDatapath) {
      goto LABEL_32;
    }
    goto LABEL_23;
  }

  __nwlog_obj();
  v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "strict_strdup";
  v23 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v23);
  if (!result)
  {
    free(v23);
    goto LABEL_20;
  }

  __break(1u);
  return result;
}

    if (v10) {
      free(v10);
    }
    goto LABEL_28;
  }

  v3 = v1[19];
  if (!v3 || (v4 = *(void **)(v3 + 24)) == 0LL)
  {
LABEL_28:
    quic_stream_protocol_identifier = 0LL;
    goto LABEL_29;
  }

  v5 = v4;
  v6 = nw_protocol_options_matches_definition(v5, (void *)g_udp_definition);

  if (v6 && nw_udp_options_get_use_quic_stats(*(void **)(v2[19] + 24LL)))
  {
    quic_stream_protocol_identifier = nw_protocol_get_quic_stream_protocol_identifier();
  }

  else
  {
    v8 = nw_protocol_options_copy_definition(*(nw_protocol_options_t *)(v2[19] + 24LL));
    quic_stream_protocol_identifier = nw_protocol_definition_get_identifier(v8);
  }

    v21 = *(void **)(a1 + 304);
    if (v21)
    {
      free(v21);
      *(void *)(a1 + 304) = 0LL;
      *(void *)(a1 + 312) = 0LL;
    }

    v22 = *(void **)(a1 + 360);
    if (v22)
    {
      free(v22);
      *(void *)(a1 + 360) = 0LL;
    }

    v23 = *(void *)(a1 + 392);
    if (v23)
    {
      *(void *)(a1 + 392) = 0LL;
      *(_DWORD *)(v23 + 240) &= ~0x80000000;
    }

    v24 = *(dispatch_object_s **)(a1 + 272);
    if (v24)
    {
      dispatch_release(v24);
      *(void *)(a1 + 272) = 0LL;
    }

    if (v23) {
      nw_mem_region_release(v23);
    }
    malloc_zone_free((malloc_zone_t *)g_slab_zone, (void *)a1);
  }
      }

      v27 = [v25 countByEnumeratingWithState:&v83 objects:v95 count:16];
    }

    while (v27);
  }
}

  if (v8) {
    free(v8);
  }
LABEL_9:
}

  if (v8) {
    free(v8);
  }
LABEL_9:
}

      free(backtrace_string);
    }
  }

      if (v25) {
        free(v25);
      }
      v6 = v8;
    }
  }

LABEL_27:
        v15 = v119;
        goto LABEL_88;
      }

      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v26 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          v28 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          v29 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          v30 = nw_endpoint_get_logging_description(v29);
          v31 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          v32 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          v33 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          *(_DWORD *)bytes = 136447746;
          *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
          *(_WORD *)&bytes[12] = 2082;
          *(void *)&bytes[14] = v27;
          *(_WORD *)&bytes[22] = 2082;
          *(void *)&bytes[24] = v28;
          v133 = 2082;
          v134 = v30;
          v135 = 2082;
          v136 = v31;
          v137 = 2082;
          v138 = v32;
          v139 = 2114;
          v140 = v33;
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] PAC URL missing",  bytes,  0x48u);
        }

        goto LABEL_26;
      }

  if (v9) {
    free(v9);
  }
  v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  v6 = 0LL;
LABEL_9:

  return v6;
}

    v10 = cached_content_for_protocol + 1;
    v22 = cached_content_for_protocol[1] + 1LL;
    v23 = v22 << 31 >> 31;
    cached_content_for_protocol[1] = v22;
    if (v23 != v22 || v23 < 0)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          v28 = *v10;
          *(_DWORD *)buf = 136446978;
          v32 = "nw_endpoint_proxy_record_result";
          v33 = 2082;
          v34 = "result_cache->failure_count";
          v35 = 2048;
          v36 = 1LL;
          v37 = 2048;
          v38 = v28;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
        }

        goto LABEL_40;
      }

  if (v5) {
    free(v5);
  }
}

    free(backtrace_string);
    if (!v4) {
      return 0LL;
    }
    goto LABEL_47;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_masque_listener_accept";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = (os_log_s *)__nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_masque_listener_accept";
      v7 = "%{public}s called with null endpoint";
      goto LABEL_45;
    }

    if (!v14)
    {
      v5 = (os_log_s *)__nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_masque_listener_accept";
      v7 = "%{public}s called with null endpoint, backtrace limit exceeded";
      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = (os_log_s *)__nwlog_obj();
    v6 = type;
    v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v11) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_masque_listener_accept";
      v7 = "%{public}s called with null endpoint, no backtrace";
      goto LABEL_45;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_masque_listener_accept";
      v18 = 2082;
      v19 = backtrace_string;
      v10 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  if (a3) {
    return 1LL;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_masque_listener_accept";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v4, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = (os_log_s *)__nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_masque_listener_accept";
      v7 = "%{public}s called with null parameters";
      goto LABEL_45;
    }

    if (!v14)
    {
      v5 = (os_log_s *)__nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_masque_listener_accept";
      v7 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_45;
    }

    v12 = (char *)__nw_create_backtrace_string();
    v5 = (os_log_s *)__nwlog_obj();
    v6 = type;
    v13 = os_log_type_enabled(v5, type);
    if (!v12)
    {
      if (!v13) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_masque_listener_accept";
      v7 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_45;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_masque_listener_accept";
      v18 = 2082;
      v19 = v12;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v12);
  }

    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        error = (void (*)(void))callbacks->error;
        if (error) {
          error();
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_protocol_masque_error";
  v14 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v15 = (os_log_s *)__nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_58;
    }
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_masque_error";
    v17 = "%{public}s called with null masque";
    goto LABEL_57;
  }

  if (!v23)
  {
    v15 = (os_log_s *)__nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_58;
    }
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_masque_error";
    v17 = "%{public}s called with null masque, backtrace limit exceeded";
    goto LABEL_57;
  }

  v20 = (char *)__nw_create_backtrace_string();
  v15 = (os_log_s *)__nwlog_obj();
  v16 = type;
  v21 = os_log_type_enabled(v15, type);
  if (!v20)
  {
    if (!v21) {
      goto LABEL_58;
    }
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_masque_error";
    v17 = "%{public}s called with null masque, no backtrace";
    goto LABEL_57;
  }

  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_protocol_masque_error";
    v27 = 2082;
    v28 = v20;
    _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v20);
  if (v14) {
LABEL_59:
  }
    free(v14);
}

  if (v9) {
    free(v9);
  }
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_36;
  }

  v9 = (os_log_s *)__nwlog_obj();
  v10 = v21;
  if (os_log_type_enabled(v9, v21))
  {
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_http_security_remove_input_handler";
    v11 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_36;
  }

  v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_http_client_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = (os_log_s *)__nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http_client_copy_info";
        v9 = "%{public}s called with null http_client";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (!v14)
    {
      v7 = (os_log_s *)__nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http_client_copy_info";
        v9 = "%{public}s called with null http_client, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http_client_copy_info";
        v9 = "%{public}s called with null http_client, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_http_client_copy_info";
      v18 = 2082;
      v19 = backtrace_string;
      v12 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  v3 = *(void *)(a1 + 32);
  if (a2 == 255)
  {
    v4 = nw_protocol_copy_info(v3, 255);
    if (!v4) {
      v4 = nw_array_create();
    }
    nw_array_append(v4, *(void **)(v2 + 576));
    return v4;
  }

  return nw_protocol_copy_info(v3, a2);
}

    free(backtrace_string);
    goto LABEL_36;
  }

  v6 = (os_log_s *)__nwlog_obj();
  v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http_client_remove_input_handler";
    v8 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

  if (v10) {
    free(v10);
  }
  __nwlog_obj();
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v36 = "nw_endpoint_handler_copy_parent";
  v18 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v18, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_endpoint_handler_copy_parent";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null handler", buf, 0xCu);
      }

    if (v12) {
      free(v12);
    }
    v6 = 0LL;
    goto LABEL_9;
  }

  v5 = *((unsigned __int8 *)v3 + 268);
  v6 = (v5 >> 3) & 1;
  if ((v5 & 8) != 0 && a2)
  {
    v7 = v3;
    while (1)
    {
      parent_handler = v7->parent_handler;
      if (!parent_handler) {
        break;
      }
      v9 = parent_handler;

      v7 = v9;
      if ((*((_BYTE *)v9 + 268) & 8) == 0)
      {

        v6 = 0LL;
        goto LABEL_9;
      }
    }

    v6 = 1LL;
  }

    free(backtrace_string);
    goto LABEL_36;
  }

  v7 = (os_log_s *)__nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_session_copy_info";
    v9 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
  }

    if (gLogDatapath)
    {
      v40 = v22;
      v41 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
        v52 = 2082;
        v53 = "maximum_bytes";
        v54 = 2048;
        v55 = (const char *)v15;
        v56 = 2048;
        *(void *)v57 = v40;
        _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
      }
    }

    goto LABEL_27;
  }

  __break(1u);
  return result;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_7;
  }

  v5 = (void *)v3[2];
  if (v5)
  {
    free(v5);
    v4[2] = 0LL;
  }

  if (!a2) {
    goto LABEL_7;
  }
  v6 = strdup(a2);
  if (v6)
  {
LABEL_6:
    v4[2] = v6;
LABEL_7:

    return;
  }

  __nwlog_obj();
  v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    goto LABEL_6;
  }

  __break(1u);
}

    free(backtrace_string);
    goto LABEL_39;
  }

  v4 = v2[4] + 1LL;
  if (v4 >= (uint64_t)(*(void *)(v3 + 24) - *(void *)(v3 + 16)) >> 3)
  {
LABEL_41:
    v6 = 0LL;
    goto LABEL_42;
  }

  nw_array_get_object_at_index(v3, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5 != 0LL;
  if (v5) {
    ++v2[4];
  }

LABEL_42:
  return v6;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_7;
  }

  v5 = (void *)v3[2];
  if (v5)
  {
    free(v5);
    v4[2] = 0LL;
  }

  if (!a2) {
    goto LABEL_7;
  }
  v6 = strdup(a2);
  if (v6)
  {
LABEL_6:
    v4[2] = v6;
LABEL_7:

    return;
  }

  __nwlog_obj();
  v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    goto LABEL_6;
  }

  __break(1u);
}

  v18 = 0LL;
  if ((*(_WORD *)&self->_has & 0x4000) != 0)
  {
LABEL_12:
    v19 = 2654435761LL * self->_useP2P;
    if ((*(_WORD *)&self->_has & 0x1000) != 0) {
      goto LABEL_13;
    }
    goto LABEL_28;
  }

  if (v11) {
    free(v11);
  }
  v8 = 0LL;
LABEL_9:

  return v8;
}

    free(backtrace_string);
    goto LABEL_36;
  }

  v6 = (os_log_s *)__nwlog_obj();
  v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http2_transport_remove_listen_handler";
    v8 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

      if (gLogDatapath)
      {
        v49 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          v50 = *(_DWORD *)(a2 + 32);
          *(_DWORD *)buf = 136446978;
          v63 = "nw_http2_transport_remove_from_id_table";
          v64 = 2082;
          v65 = (void *)(a1 + 205);
          v66 = 1024;
          v67 = v50;
          v68 = 2048;
          v69 = a2;
          _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called for stream %d (%p)",  buf,  0x26u);
        }
      }

    free(v9);
    goto LABEL_27;
  }

  xpc_dictionary_get_value(v1, string_ptr);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5;
  if (v5 && object_getClass(v5) == (Class)MEMORY[0x1895F9220]) {
    v7 = v6;
  }
  else {
    v7 = 0LL;
  }

LABEL_28:
  return v7;
}

    v5 = 0LL;
    goto LABEL_27;
  }

  v4 = nw_proxy_config_copy_agent_data((uint64_t)v1);
  v5 = 1LL;
  nw_agent_change_state(v3, 1, 0, (void *)v4);

LABEL_27:
  return v5;
}

    v16 += input_frames;
  }

  while (input_frames);
  if (gLogDatapath)
  {
    v198 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v198, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v198, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v85 = MEMORY[0x1895F87A8];
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_39716;
  *(void *)&buf[24] = &__block_descriptor_tmp_55_39717;
  *(void *)&buf[32] = v260;
  buf[40] = 0;
  a2 = *(nw_protocol **)v260;
  v13 = (unsigned __int16 *)(v12 + 872);
  do
  {
    if (!a2) {
      break;
    }
    v86 = a2->output_handler;
    v87 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    a2 = v86;
  }

  while ((v87 & 1) != 0);
  v88 = (unsigned __int16)*v259;
  v89 = v88 | (*(unsigned __int8 *)(v12 + 874) << 16);
  if ((v88 & 0x6000) == 0x2000 && !*(void *)(v12 + 616))
  {
    *(_BYTE *)(v12 + 874) = BYTE2(v89);
    *v259 = v89 | 0x4000;
    if (*(void *)(v12 + 488))
    {
      if (*(_DWORD *)(v12 + 868) && llhttp_message_needs_eof(v12 + 200))
      {
        if ((v89 & 4) == 0)
        {
          v117 = 5;
          if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
            goto LABEL_134;
          }
          goto LABEL_209;
        }

          v6 = (unsigned __int16)*v4 | (*(unsigned __int8 *)(v2 + 874) << 16) | 8;
          goto LABEL_27;
        }

        if (gLogDatapath) {
          goto LABEL_32;
        }
        goto LABEL_15;
      }

    free(backtrace_string);
    goto LABEL_36;
  }

  v9 = (os_log_s *)__nwlog_obj();
  v10 = v21;
  if (os_log_type_enabled(v9, v21))
  {
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_http_retry_remove_input_handler";
    v11 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
  }

    v3 = 0LL;
  }

    v3 = 0LL;
  }

    v22 = [v6 isRoaming];
    v23 = -[NWNetworkDescription roamingPreference](self, "roamingPreference");
    v24 = 1LL;
    if (v22) {
      v24 = 2LL;
    }
    if (v23 && v24 == v23) {
      goto LABEL_79;
    }
    v25 = -[NWNetworkDescription ssidOptions](self, "ssidOptions");
    if (v25)
    {
      [v6 interface];
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v26 subtype] == 5001)
      {
        v27 = [v6 usesInterfaceType:1];

        if (v27)
        {
          v28 = (void *)[v6 copyDataFromNetworkAgentWithDomain:@"com.apple.networkrelay" type:@"CompanionNetworkDescription"];
          v29 = (void *)[objc_alloc(NSString) initWithData:v28 encoding:4];
          -[NWNetworkDescription ssidOptions](self, "ssidOptions");
          v3 = (Class *)objc_claimAutoreleasedReturnValue();
          v30 = NWUtilsStringMatchesPatternSet(v29, v3);

          if ((v30 & 1) != 0) {
            goto LABEL_58;
          }
        }
      }

      else
      {
      }

      [v6 interface];
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      v34 = [v33 type];

      if (v34 != 1) {
        goto LABEL_79;
      }
      [v6 interface];
      v9 = (id)objc_claimAutoreleasedReturnValue();
      [v9 interfaceName];
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      gotLoadHelper_x24__OBJC_CLASS___CWFInterface(v36);
      if (!objc_opt_class())
      {

LABEL_81:
        LOBYTE(v21) = 0;
        goto LABEL_84;
      }

      v3 = (Class *)objc_alloc_init(v3[9]);
      -[Class activate](v3, "activate");
      v62 = 0u;
      v63 = 0u;
      *(_OWORD *)type = 0u;
      v61 = 0u;
      v37 = -[Class interfaceNames](v3, "interfaceNames");
      v38 = [v37 countByEnumeratingWithState:type objects:buf count:16];
      if (v38)
      {
        v39 = v38;
        v40 = *(void *)v61;
        while (2)
        {
          for (j = 0LL; j != v39; ++j)
          {
            if (*(void *)v61 != v40) {
              objc_enumerationMutation(v37);
            }
            if ([*(id *)(*(void *)&type[8] + 8 * j) isEqual:v35])
            {
              v42 = -[Class networkName](v3, "networkName");
              goto LABEL_56;
            }
          }

          v39 = [v37 countByEnumeratingWithState:type objects:buf count:16];
          if (v39) {
            continue;
          }
          break;
        }
      }

      v42 = 0LL;
LABEL_56:
      -[Class invalidate](v3, "invalidate");

      if (!v42) {
        goto LABEL_79;
      }
      v43 = -[NWNetworkDescription ssidOptions](self, "ssidOptions");
      v44 = NWUtilsStringMatchesPatternSet(v42, v43);

      if (!v44) {
        goto LABEL_79;
      }
    }

  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  return v2 != 0LL;
}

    if (v17) {
      free(v17);
    }
    goto LABEL_4;
  }

  if (uuid_is_null(a1) || (gotLoadHelper_x22__OBJC_CLASS___UMUserPersona(v5), !objc_opt_class()))
  {
    v4[2](v4);
LABEL_4:
    v6 = 0LL;
    goto LABEL_9;
  }

  v7 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:a1];
  [v7 UUIDString];
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  [*(id *)(v2 + 3016) currentPersona];
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = 0LL;
  v10 = (void *)[v9 copyCurrentPersonaContextWithError:&v24];
  v11 = v24;
  [v9 generateAndRestorePersonaContextWithPersonaUniqueString:v8];
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446722;
    v28 = "nw_utilities_execute_block_as_persona";
    v29 = 1040;
    *(_DWORD *)v30 = 16;
    v30[2] = 2096;
    *(void *)&v30[3] = a1;
    _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s Executing block as persona %{uuid_t}.16P",  buf,  0x1Cu);
  }

  v4[2](v4);
  v14 = (id)[v9 restorePersonaWithSavedPersonaContext:v10];

  v6 = 1LL;
LABEL_9:

  return v6;
}

  if (v10) {
    free(v10);
  }
  nw_frame_finalize((uint64_t)a2);
  --*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  return 1LL;
}

  *(void *)(a1 + 24) = v4;
  return v12;
}

  if (v9) {
    free(v9);
  }
  v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v12) {
    free(v12);
  }
LABEL_9:
}

  if (v8) {
    free(v8);
  }
LABEL_3:

  v4 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  v6 = v4;
  if (quic_fillout_definition_callbacks_override)
  {
    quic_fillout_definition_callbacks_override(v4, v5);
  }

  else
  {
    if (!MEMORY[0x189617048])
    {

      goto LABEL_8;
    }

    quic_fillout_definition_callbacks();
  }

  nw_protocol_definition_register((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
LABEL_8:
  nw_protocol_definition_set_options_should_serialize( (void *)nw_protocol_copy_quic_stream_definition::quic_definition,  (uint64_t)nw_quic_stream_should_serialize_options);
}

    if (v7) {
      free(v7);
    }
    v4 = 0LL;
    goto LABEL_4;
  }

  v4 = (id *)calloc(1uLL, 0x28uLL);
  if (v4) {
    goto LABEL_3;
  }
  __nwlog_obj();
  v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v20 = "strict_calloc";
  v21 = 2048;
  v22 = 1LL;
  v23 = 2048;
  v24 = 40LL;
  v11 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
LABEL_3:
    objc_storeStrong(v4, *(id *)a2);
    objc_storeStrong(v4 + 1, *(id *)(a2 + 8));
    objc_storeStrong(v4 + 2, *(id *)(a2 + 16));
    objc_storeStrong(v4 + 3, *(id *)(a2 + 24));
    *((_BYTE *)v4 + 32) = *(_BYTE *)(a2 + 32);
    if (gLogDatapath)
    {
      __nwlog_obj();
      v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v20 = "qpod_options_copy";
        v21 = 2048;
        v22 = a2;
        v23 = 2048;
        v24 = (uint64_t)v4;
        _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s copying options %p -> %p", buf, 0x20u);
      }
    }

    return (BOOL)v9;
  }

  __nwlog_obj();
  v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  v24 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v24);
  if (!result)
  {
    free(v24);
    MEMORY[0] = 0;
    if (v6 + v7 != -1LL) {
      goto LABEL_10;
    }
    goto LABEL_26;
  }

        v21 = 1LL;
LABEL_89:

        goto LABEL_90;
      }

      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        v22 = (id)gbrowserLogObj;
        v23 = *((_DWORD *)v9 + 48);
        *(_DWORD *)buf = 136446978;
        v64 = "nw_browser_add_result_locked";
        v65 = 1024;
        *(_DWORD *)v66 = v23;
        *(_WORD *)&v66[4] = 2112;
        *(void *)&v66[6] = v11;
        v67 = 2080;
        v68 = a2;
        v24 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v61 = 0;
        if (__nwlog_fault(v24, &type, &v61))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            v25 = (os_log_s *)(id)gbrowserLogObj;
            v26 = type;
            if (os_log_type_enabled(v25, type))
            {
              v27 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v27;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s [B%u] tried to insert duplicate interface %@ for %s",  buf,  0x26u);
            }
          }

          else if (v61)
          {
            backtrace_string = __nw_create_backtrace_string();
            if (backtrace_string)
            {
              v35 = (char *)backtrace_string;
              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
              }
              v36 = (os_log_s *)(id)gbrowserLogObj;
              v37 = type;
              if (os_log_type_enabled(v36, type))
              {
                v38 = *((_DWORD *)v9 + 48);
                *(_DWORD *)buf = 136447234;
                v64 = "nw_browser_add_result_locked";
                v65 = 1024;
                *(_DWORD *)v66 = v38;
                *(_WORD *)&v66[4] = 2112;
                *(void *)&v66[6] = v11;
                v67 = 2080;
                v68 = a2;
                v69 = 2082;
                v70 = v35;
                _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s [B%u] tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s",  buf,  0x30u);
              }

              free(v35);
              if (!v24) {
                goto LABEL_88;
              }
              goto LABEL_74;
            }

            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            v25 = (os_log_s *)(id)gbrowserLogObj;
            v46 = type;
            if (os_log_type_enabled(v25, type))
            {
              v47 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v47;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              _os_log_impl( &dword_181A5C000,  v25,  v46,  "%{public}s [B%u] tried to insert duplicate interface %@ for %s, no backtrace",  buf,  0x26u);
            }
          }

          else
          {
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            v25 = (os_log_s *)(id)gbrowserLogObj;
            v44 = type;
            if (os_log_type_enabled(v25, type))
            {
              v45 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v45;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              _os_log_impl( &dword_181A5C000,  v25,  v44,  "%{public}s [B%u] tried to insert duplicate interface %@ for %s, backtrace limit exceeded",  buf,  0x26u);
            }
          }
        }

        if (v24) {
LABEL_74:
        }
          free(v24);
      }

    if (v8) {
      free(v8);
    }
    return 0LL;
  }

  *(_OWORD *)(v3 + 8) = *a2;
  v3[140] |= 6u;
  if (nw_activity_should_log(v3))
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
    }
    v5 = (os_log_s *)(id)gactivityLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)v19 = 16;
      *(_WORD *)&v19[4] = 2098;
      *(void *)&v19[6] = v4 + 8;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEFAULT,  "Create activity <nw_activity [%{public,uuid_t}.16P] (lightweight)>",  buf,  0x12u);
    }
  }

  return v4;
}

    free(v17);
    goto LABEL_27;
  }

  if (a11 <= 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    *(void *)&buf[4] = "nw_path_parse_necp_parameters";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = a11;
    v17 = (char *)_os_log_send_and_compose_impl();

    uu[0] = 16;
    LOBYTE(v559) = 0;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (os_log_s *)(id)gLogObj;
      v19 = uu[0];
      if (os_log_type_enabled(v18, (os_log_type_t)uu[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_path_parse_necp_parameters";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = a11;
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s NECP buffer too short %zu", buf, 0x16u);
      }

  if (v11) {
LABEL_27:
  }
    free(v11);
  return 0LL;
}

        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        goto LABEL_27;
      }

        if (v28) {
          free(v28);
        }
        v6 = v8;
      }

      while (v8);
    }

    free(backtrace_string);
    goto LABEL_36;
  }

  v5 = (os_log_s *)__nwlog_obj();
  v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http3_stream_supports_external_data";
    v7 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

  if (v6) {
    free(v6);
  }
  return v3;
}

  if (v6) {
    free(v6);
  }
  return v3;
}

  if (v6) {
    free(v6);
  }
  return v2;
}

  v19 = 0LL;
LABEL_168:

LABEL_169:
  return v19;
}

  if (v13) {
    free(v13);
  }
  v10 = 0LL;
LABEL_9:

  return v10;
}

      if (v18) {
        free(v18);
      }
      v16 = *(void **)(a1 + 32);
LABEL_29:
      nw_path_set_reason( v16,  10,  "Unknown network agent is prohibited by parameters",  v11,  v12,  v13,  v14,  v15,  (char)v25);
      goto LABEL_30;
    }
  }

  else
  {
    v8 = 0LL;
  }

  v17 = 1LL;
LABEL_31:

  return v17;
}

        goto LABEL_27;
      }

      if (!v25)
      {
        __nwlog_obj();
        v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null advertise_descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_26;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v22 = type;
      v23 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_path_create_evaluator_for_advertise";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null advertise_descriptor, no backtrace",  buf,  0xCu);
        }

        goto LABEL_26;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v28 = "nw_path_create_evaluator_for_advertise";
        v29 = 2082;
        v30 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null advertise_descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    free(backtrace_string);
    goto LABEL_39;
  }

  v5 = v3[9];
  if (!v5
    || *(void *)(v5 + 24) == *(void *)(v5 + 16)
    || (nw_array_get_object_at_index(v5, 0LL), (v6 = (_DWORD *)objc_claimAutoreleasedReturnValue()) == 0LL))
  {
LABEL_41:
    v7 = 0LL;
    goto LABEL_42;
  }

  *a2 = v6[41];

  v7 = 1LL;
LABEL_42:

  return v7;
}

    v27 = *(void *)(a1 + 32);
    if (v27)
    {
      v28 = (id *)*(id *)(v27 + 40);
      v29 = v28;
      if (v28 && ([v28[2] _requiresSecureHTTPSProxyConnection] & 1) != 0) {
        goto LABEL_33;
      }
      v30 = *(void *)(a1 + 32);
      if (!v30)
      {
LABEL_39:
        if (nw_proxy_options_authbroker_is_available::onceToken != -1) {
          dispatch_once(&nw_proxy_options_authbroker_is_available::onceToken, &__block_literal_global_35314);
        }
        v34 = nw_proxy_options_authbroker_is_available::available;

        if ((v34 & 1) != 0) {
          goto LABEL_25;
        }
LABEL_34:
        v32 = *(void *)(a1 + 32);
        v33 = *(void **)(a1 + 40);
        v38[0] = MEMORY[0x1895F87A8];
        v38[1] = 3221225472LL;
        v38[2] = __34__NWURLLoaderHTTP_continueLoading__block_invoke_39;
        v38[3] = &unk_189BC5DE8;
        v38[4] = v32;
        v39 = v37;
        -[NWURLLoaderHTTP handleAuthenticationChallenge:url:cancel:completionHandler:](v32, v5, v33, 0LL, v38);

        goto LABEL_35;
      }
    }

    else
    {
      v29 = 0LL;
      v30 = *(void *)(a1 + 32);
      if (!v30) {
        goto LABEL_39;
      }
    }

    if (*(_BYTE *)(v30 + 18)
      || (v31 = *(void *)(v30 + 40)) != 0
      && ([*(id *)(v31 + 16) _preventsSystemHTTPProxyAuthentication] & 1) != 0)
    {
LABEL_33:

      goto LABEL_34;
    }

    goto LABEL_39;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v26 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    v41 = "-[NWURLLoaderHTTP continueLoading]_block_invoke_2";
    _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to determine authentication type",  buf,  0xCu);
  }

  CFRelease(v12);
  CFRelease(v7);
  (*((void (**)(id, void, uint64_t))v37 + 2))(v37, 0LL, 1LL);

LABEL_35:
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

    goto LABEL_27;
  }

  v4 = (id *)calloc(1uLL, 0x28uLL);
  if (!v4)
  {
    __nwlog_obj();
    v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v25 = "strict_calloc";
    v26 = 2048;
    v27 = 1LL;
    v28 = 2048;
    v29 = 40LL;
    v17 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v17);
    if (result) {
      goto LABEL_30;
    }
    free(v17);
  }

  objc_storeStrong(v4, *(id *)a2);
  v5 = _Block_copy(*(const void **)(a2 + 8));
  v6 = v4[1];
  v4[1] = v5;

  v7 = *(const char **)(a2 + 16);
  if (!v7)
  {
LABEL_6:
    objc_storeStrong(v4 + 3, *(id *)(a2 + 24));
    v9 = (_BYTE)v4[4] & 0xFE | *(_BYTE *)(a2 + 32) & 1;
    *((_BYTE *)v4 + 32) = v9;
    *((_BYTE *)v4 + 32) = v9 & 0xF1 | *(_BYTE *)(a2 + 32) & 0xE;
LABEL_7:

    return (BOOL)v4;
  }

  v8 = strdup(v7);
  if (v8)
  {
LABEL_5:
    v4[2] = v8;
    goto LABEL_6;
  }

  __nwlog_obj();
  v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v25 = "strict_strdup";
  v19 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v19);
  if (!result)
  {
    free(v19);
    goto LABEL_5;
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

    goto LABEL_27;
  }

  if (!v50)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (os_log_s *)(id)gLogObj;
    v25 = type;
    if (os_log_type_enabled(v16, type))
    {
      v26 = v13;
      v27 = objc_msgSend(v26, "type", buf, v48);

      *(_DWORD *)buf = 136446466;
      v53 = "nw_http_metadata_set_endpoint";
      v54 = 1024;
      *(_DWORD *)v55 = v27;
      _os_log_impl( &dword_181A5C000,  v16,  v25,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_26;
  }

  v20 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = (os_log_s *)(id)gLogObj;
  v21 = type;
  v22 = os_log_type_enabled(v16, type);
  if (!v20)
  {
    if (v22)
    {
      v28 = v13;
      v29 = objc_msgSend(v28, "type", buf, v48);

      *(_DWORD *)buf = 136446466;
      v53 = "nw_http_metadata_set_endpoint";
      v54 = 1024;
      *(_DWORD *)v55 = v29;
      _os_log_impl(&dword_181A5C000, v16, v21, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_26;
  }

  if (v22)
  {
    v23 = v13;
    v24 = objc_msgSend(v23, "type", buf, v48);

    *(_DWORD *)buf = 136446722;
    v53 = "nw_http_metadata_set_endpoint";
    v54 = 1024;
    *(_DWORD *)v55 = v24;
    v55[2] = 2082;
    *(void *)&v55[3] = v20;
    _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v20);
  if (v15) {
    goto LABEL_28;
  }
LABEL_29:
}

    free(backtrace_string);
    goto LABEL_39;
  }

  v6 = v3[4];
  if (!v6)
  {
LABEL_41:
    v7 = 0LL;
    goto LABEL_42;
  }

  v7 = v6[2] != 0LL;
LABEL_42:

  return v7;
}

  if (v11) {
    free(v11);
  }
  v8 = 0LL;
LABEL_10:

  return v8;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

    if (v8) {
      free(v8);
    }
    goto LABEL_7;
  }

  nw_context_assert_queue(v3[3]);
  v5 = *((_BYTE *)v4 + 108);
  if ((v5 & 1) != 0)
  {
LABEL_7:

    return;
  }

  if (v4[12])
  {
LABEL_6:
    *((_DWORD *)v4 + 26) = a2;
    *((_BYTE *)v4 + 108) = v5 | 1;
    goto LABEL_7;
  }

  v6 = calloc(1uLL, 0xD60uLL);
  if (v6)
  {
LABEL_5:
    v4[12] = v6;
    v5 = *((_BYTE *)v4 + 108);
    goto LABEL_6;
  }

  __nwlog_obj();
  v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v20 = "strict_calloc";
  v21 = 2048;
  v22 = 1LL;
  v23 = 2048;
  v24 = 3424LL;
  v16 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v16))
  {
    free(v16);
    v6 = 0LL;
    goto LABEL_5;
  }

  __break(1u);
}
  }

  v13 = operator new(0x30uLL);
  *v13 = 0LL;
  v13[1] = v6;
  v13[2] = v6;
  v13[3] = 0LL;
  v13[4] = v5;
  *((_BYTE *)v13 + 40) = -1;
  v14 = (float)(unint64_t)(*(void *)(v3 + 336) + 1LL);
  v15 = *(float *)(v3 + 344);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    v16 = 1LL;
    if (v7 >= 3) {
      v16 = (v7 & (v7 - 1)) != 0;
    }
    v17 = v16 | (2 * v7);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      prime = v18;
    }
    else {
      prime = v17;
    }
    if (prime == 1)
    {
      prime = 2LL;
    }

    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v7 = *(void *)(v3 + 320);
    }

    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_63;
      }
      v32 = vcvtps_u32_f32((float)*(unint64_t *)(v3 + 336) / *(float *)(v3 + 344));
      if (v7 < 3 || (v33 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }

      else
      {
        v34 = 1LL << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          v32 = v34;
        }
      }

      if (prime <= v32) {
        prime = v32;
      }
      if (prime >= v7)
      {
        v7 = *(void *)(v3 + 320);
LABEL_63:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v6 >= v7) {
            v2 = v6 % v7;
          }
          else {
            v2 = v6;
          }
        }

        else
        {
          v2 = (v7 - 1) & v6;
        }

        goto LABEL_76;
      }

      if (!prime)
      {
        v43 = *(void **)(v3 + 312);
        *(void *)(v3 + 312) = 0LL;
        if (v43) {
          operator delete(v43);
        }
        v7 = 0LL;
        *(void *)(v3 + 320) = 0LL;
        goto LABEL_63;
      }
    }

    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    v20 = operator new(8 * prime);
    v21 = *(void **)(v3 + 312);
    *(void *)(v3 + 312) = v20;
    if (v21) {
      operator delete(v21);
    }
    v22 = 0LL;
    *(void *)(v3 + 320) = prime;
    do
      *(void *)(*(void *)(v3 + 312) + 8 * v22++) = 0LL;
    while (prime != v22);
    v23 = *(void **)(v3 + 328);
    if (!v23)
    {
LABEL_62:
      v7 = prime;
      goto LABEL_63;
    }

    v24 = v3 + 328;
    v25 = v23[1];
    v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      v27 = v25 & v26;
      *(void *)(*(void *)(v3 + 312) + 8 * v27) = v24;
      for (i = (void *)*v23; *v23; i = (void *)*v23)
      {
        v29 = i[1] & v26;
        if (v29 == v27)
        {
          v23 = i;
        }

        else
        {
          v30 = *(void *)(v3 + 312);
          if (*(void *)(v30 + 8 * v29))
          {
            *v23 = *i;
            v31 = 8 * v29;
            *i = **(void **)(*(void *)(v3 + 312) + v31);
            **(void **)(*(void *)(v3 + 312) + v31) = i;
          }

          else
          {
            *(void *)(v30 + 8 * v29) = v23;
            v23 = i;
            v27 = v29;
          }
        }
      }

      goto LABEL_62;
    }

    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)(v3 + 312) + 8 * v25) = v24;
    v35 = (void *)*v23;
    if (!*v23) {
      goto LABEL_62;
    }
    while (1)
    {
      v37 = v35[1];
      if (v37 >= prime) {
        v37 %= prime;
      }
      if (v37 != v25)
      {
        v38 = *(void *)(v3 + 312);
        if (!*(void *)(v38 + 8 * v37))
        {
          *(void *)(v38 + 8 * v37) = v23;
          goto LABEL_67;
        }

        *v23 = *v35;
        v36 = 8 * v37;
        *v35 = **(void **)(*(void *)(v3 + 312) + v36);
        **(void **)(*(void *)(v3 + 312) + v36) = v35;
        v35 = v23;
      }

      v37 = v25;
LABEL_67:
      v23 = v35;
      v35 = (void *)*v35;
      v25 = v37;
      if (!v35) {
        goto LABEL_62;
      }
    }
  }

    v13(a3, a1);
    return a1 != 0;
  }

  if ((v7 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v35 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v37 = *(_DWORD *)(a2 + 176);
      v36 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v51 = "nw_http2_stream_connect";
      v52 = 2082;
      v53 = (void *)(a2 + 191);
      v54 = 2080;
      v55 = " ";
      v56 = 1024;
      v57 = v36;
      v58 = 1024;
      v59 = v37;
      v60 = 1024;
      v61 = v37;
      _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> stream %d is already connected",  buf,  0x32u);
    }
  }

  v20 = *(void *)(a3 + 24);
  if (v20)
  {
    v13 = *(void (**)(uint64_t, uint64_t))(v20 + 40);
    if (v13) {
      goto LABEL_26;
    }
  }

  __nwlog_obj();
  v26 = *(const char **)(a3 + 16);
  if (!v26) {
    v26 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  v51 = "nw_http2_stream_connect";
  v52 = 2082;
  v53 = (void *)v26;
  v15 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (__nwlog_fault(v15, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_98;
      }
      v18 = *(const char **)(a3 + 16);
      if (!v18) {
        v18 = "invalid";
      }
      goto LABEL_21;
    }

    if (!v48)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_98;
      }
      v44 = *(const char **)(a3 + 16);
      if (!v44) {
        v44 = "invalid";
      }
      goto LABEL_79;
    }

    v41 = (char *)__nw_create_backtrace_string();
    v16 = (os_log_s *)__nwlog_obj();
    v17 = type;
    v42 = os_log_type_enabled(v16, type);
    if (v41)
    {
      if (v42)
      {
        if (*(void *)(a3 + 16)) {
          v43 = *(const char **)(a3 + 16);
        }
        else {
          v43 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v51 = "nw_http2_stream_connect";
        v52 = 2082;
        v53 = (void *)v43;
        v54 = 2082;
        v55 = v41;
        _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v41);
      if (v15) {
        goto LABEL_99;
      }
      return a1 != 0;
    }

    if (v42)
    {
      v46 = *(const char **)(a3 + 16);
      if (!v46) {
        v46 = "invalid";
      }
      goto LABEL_96;
    }
  }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    if (v13 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v80 = output_handler[1].callbacks;
      if (v80)
      {
        v81 = (nw_protocol_callbacks *)((char *)v80 - 1);
        output_handler[1].callbacks = v81;
        if (!v81)
        {
          v82 = *(void (***)(void))output_handler[1].flow_id;
          if (v82)
          {
            *(void *)output_handler[1].flow_id = 0LL;
            v82[2](v82);
            _Block_release(v82);
          }

          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            v83 = *(const void **)output_handler[1].flow_id;
            if (v83) {
              _Block_release(v83);
            }
          }

          free(output_handler);
        }
      }
    }

    *((_DWORD *)v193 + 6) = v19;
    if (!v19) {
      goto LABEL_212;
    }
    *(void *)v188 = 0LL;
    v189 = v188;
    v191 = 0;
    v190 = 0x2000000000LL;
    v186[0] = 0LL;
    v186[1] = v186;
    v186[2] = 0x2000000000LL;
    v187 = 0;
    v182[0] = 0LL;
    v182[1] = v182;
    v182[2] = 0x2000000000LL;
    v183 = 0;
    v184 = 0LL;
    v185 = (nw_frame **)&v184;
    v172[0] = MEMORY[0x1895F87A8];
    v172[1] = 0x40000000LL;
    v173 = (uint64_t (*)(void *))___ZL33nw_protocol_ipv6_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    v174 = &unk_189BC8A80;
    v175 = v186;
    v176 = v182;
    v179 = v12;
    v180 = v8;
    v181 = &v184;
    v177 = &v192;
    v178 = v188;
    tqh_first = v12->tqh_first;
    do
    {
      if (!tqh_first) {
        break;
      }
      v21 = (nw_frame *)*((void *)tqh_first + 4);
      v22 = v173(v172);
      tqh_first = v21;
    }

    while ((v22 & 1) != 0);
    v171 = 0;
    do
    {
      v25 = nw_protocol_ipv6_process_reassembly((uint64_t)v8, 0, (uint64_t)&v184, 0, &v171);
      *((_DWORD *)v193 + 6) += v25;
      if (!v171) {
        break;
      }
      v170[0] = 0LL;
      v170[1] = v170;
      v166 = 0LL;
      v167 = &v166;
      v168 = 0x2000000000LL;
      v26 = a1->output_handler;
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "__nw_protocol_get_input_frames";
        v55 = (char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        if (v197 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = gLogObj;
          v57 = v197;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_input_frames";
            v58 = (os_log_s *)v56;
            v59 = v57;
            v60 = "%{public}s called with null protocol";
            goto LABEL_126;
          }

          goto LABEL_127;
        }

        if (v196)
        {
          v67 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v68 = (os_log_s *)gLogObj;
          v69 = v197;
          v70 = os_log_type_enabled((os_log_t)gLogObj, v197);
          if (v67)
          {
            if (v70)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v67;
              _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v67);
            goto LABEL_127;
          }

          if (!v70)
          {
LABEL_127:
            if (v55) {
              free(v55);
            }
            v33 = 0;
            goto LABEL_52;
          }

          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = v68;
          v59 = v69;
          v60 = "%{public}s called with null protocol, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v74 = gLogObj;
          v75 = v197;
          if (!os_log_type_enabled((os_log_t)gLogObj, v197)) {
            goto LABEL_127;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = (os_log_s *)v74;
          v59 = v75;
          v60 = "%{public}s called with null protocol, backtrace limit exceeded";
        }

      free(backtrace_string);
      goto LABEL_36;
    }

    v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv6_copy_info";
    v9 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
LABEL_36:
    if (v6) {
      free(v6);
    }
    return 0LL;
  }

  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv6_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = (os_log_s *)__nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv6_copy_info";
      v9 = "%{public}s called with null ipv6";
      goto LABEL_35;
    }

    if (!v17)
    {
      v7 = (os_log_s *)__nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv6_copy_info";
      v9 = "%{public}s called with null ipv6, backtrace limit exceeded";
      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    v16 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_ipv6_copy_info";
        v21 = 2082;
        v22 = (uint64_t)backtrace_string;
        v12 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
        goto LABEL_25;
      }

      goto LABEL_26;
    }

    if (!v16) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv6_copy_info";
    v9 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_35;
  }

  if (a2 != 5) {
    return 0LL;
  }
  v5 = (char *)calloc(1uLL, 0xB8uLL);
  if (v5) {
    goto LABEL_5;
  }
  v13 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v20 = "strict_calloc";
  v21 = 2048;
  v22 = 1LL;
  v23 = 2048;
  v24 = 184LL;
  v14 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
LABEL_5:
    *(_OWORD *)(v5 + 8) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(v5 + 24) = *(_OWORD *)(a1 + 120);
    *((void *)v5 + 5) = *(void *)(a1 + 96);
    if (a3) {
      *a3 = 184LL;
    }
    return (BOOL)v5;
  }

  __break(1u);
  return result;
}
}

void nw_mem_depot_ws_reap(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 368);
  unsigned int v3 = *(_DWORD *)(a1 + 364);
  if (v2 >= v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if ((_DWORD)v4)
  {
    do
    {
      v8 = *(void **)(a1 + 352);
      if (!v8) {
        break;
      }
      *(void *)(a1 + 352) = *v8;
      unsigned int v9 = *(_DWORD *)(a1 + 360) - 1;
      *(_DWORD *)(a1 + 360) = v9;
      if (v9 < *(_DWORD *)(a1 + 364)) {
        *(_DWORD *)(a1 + 364) = v9;
      }
      v10 = *(unsigned int **)(a1 + 336);
      ++*(void *)(a1 + 344);
      uint64_t v11 = *v10;
      if ((int)v11 >= 1)
      {
        v12 = v8 + 1;
        do
        {
          unint64_t v13 = *v12;
          v14 = *(void (**)(unint64_t, void))(a1 + 192);
          if (v14) {
            v14(*v12, *(void *)(a1 + 208));
          }
          nw_mem_slab_free(a1, v13);
          ++v12;
          --v11;
        }

        while (v11);
      }

      --v4;
      malloc_zone_free((malloc_zone_t *)g_slab_zone, v8);
    }

    while (v4);
  }

  unsigned int v5 = *(_DWORD *)(a1 + 400);
  unsigned int v6 = *(_DWORD *)(a1 + 396);
  if (v5 >= v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v5;
  }
  if ((_DWORD)v7)
  {
    do
    {
      v15 = *(void **)(a1 + 384);
      if (!v15) {
        break;
      }
      *(void *)(a1 + 384) = *v15;
      unsigned int v16 = *(_DWORD *)(a1 + 392) - 1;
      *(_DWORD *)(a1 + 392) = v16;
      if (v16 < *(_DWORD *)(a1 + 396)) {
        *(_DWORD *)(a1 + 396) = v16;
      }
      --v7;
      ++*(void *)(a1 + 376);
      malloc_zone_free((malloc_zone_t *)g_slab_zone, v15);
    }

    while (v7);
  }

void nw_mem_cache_magazine_purge(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    v14 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      int v15 = 136446466;
      unsigned int v16 = "nw_mem_cache_magazine_purge";
      __int16 v17 = 2048;
      uint64_t v18 = a1;
      _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p", (uint8_t *)&v15, 0x16u);
    }
  }

  unsigned int v2 = *(unint64_t **)(a1 + 520);
  unsigned int v3 = *(unint64_t **)(a1 + 528);
  uint64_t v4 = *(unsigned int *)(a1 + 552);
  uint64_t v5 = *(unsigned int *)(a1 + 556);
  *(void *)(a1 + 528) = 0LL;
  *(void *)(a1 + 520) = 0LL;
  *(_DWORD *)(a1 + 560) = 0;
  *(void *)(a1 + 552) = -1LL;
  if (v2)
  {
    if ((int)v4 >= 1)
    {
      unsigned int v6 = v2 + 1;
      do
      {
        unint64_t v7 = *v6;
        v8 = *(void (**)(unint64_t, void))(a1 + 192);
        if (v8) {
          v8(*v6, *(void *)(a1 + 208));
        }
        nw_mem_slab_free(a1, v7);
        ++v6;
        --v4;
      }

      while (v4);
    }

    malloc_zone_free((malloc_zone_t *)g_slab_zone, v2);
  }

  if (v3)
  {
    if ((int)v5 >= 1)
    {
      unsigned int v9 = v3 + 1;
      do
      {
        unint64_t v10 = *v9;
        uint64_t v11 = *(void (**)(unint64_t, void))(a1 + 192);
        if (v11) {
          v11(*v9, *(void *)(a1 + 208));
        }
        nw_mem_slab_free(a1, v10);
        ++v9;
        --v5;
      }

      while (v5);
    }

    malloc_zone_free((malloc_zone_t *)g_slab_zone, v3);
  }

  int v12 = *(_DWORD *)(a1 + 360);
  *(_DWORD *)(a1 + 368) = v12;
  *(_DWORD *)(a1 + 364) = v12;
  int v13 = *(_DWORD *)(a1 + 392);
  *(_DWORD *)(a1 + 400) = v13;
  *(_DWORD *)(a1 + 396) = v13;
  nw_mem_depot_ws_reap(a1);
}

void nw_mem_slab_free(uint64_t a1, unint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  ++*(void *)(a1 + 56);
  uint64_t v4 = (void **)(*(void *)(a1 + 288) + 8 * ((a2 >> *(void *)(a1 + 272)) & *(void *)(a1 + 280)));
  uint64_t v5 = v4;
  do
  {
    uint64_t v5 = (void **)*v5;
    if (!v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v31 = 136446722;
      *(void *)&v31[4] = "nw_mem_slab_free";
      *(_WORD *)&v31[12] = 2048;
      *(void *)&v31[14] = a2;
      *(_WORD *)&v31[22] = 2048;
      *(void *)&v31[24] = a1;
      v8 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort((uint64_t)v8))
      {
        free(v8);
        uint64_t v5 = 0LL;
        unint64_t v7 = 0LL;
        goto LABEL_9;
      }

      goto LABEL_42;
    }
  }

  while (v5[1] != (void *)a2);
  for (i = *v4; i != v5; i = (void *)*i)
    uint64_t v4 = (void **)i;
  *uint64_t v4 = *v5;
  unint64_t v7 = (char *)v5[3];
LABEL_9:
  if (a2 - *((void *)v7 + 3) >= *(void *)(*((void *)v7 + 2) + 248LL))
  {
    v25 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v31 = 136446466;
    *(void *)&v31[4] = "nw_mem_slab_free";
    *(_WORD *)&v31[12] = 2082;
    *(void *)&v31[14] = "VERIFY NW_MEM_SLAB_MEMBER(sl, buf) failed";
    v26 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v26))
    {
      free(v26);
      if ((*(_BYTE *)(a1 + 176) & 2) != 0) {
        goto LABEL_36;
      }
      goto LABEL_11;
    }

LABEL_42:
    __break(1u);
    return;
  }

  if ((*(_BYTE *)(a1 + 176) & 2) == 0) {
    goto LABEL_11;
  }
LABEL_36:
  *(void *)v31 = 0LL;
  *(void *)&v31[8] = 0LL;
  gettimeofday((timeval *)v31, 0LL);
  v5[4] = (void *)(1000LL * *(void *)v31 + *(_DWORD *)&v31[8] / 1000);
  *((_DWORD *)v5 + 11) = backtrace((void **)v5 + 6, 16);
LABEL_11:
  unint64_t v10 = (void **)(v7 + 56);
  unsigned int v9 = (void *)*((void *)v7 + 7);
  *uint64_t v5 = v9;
  *((void *)v7 + 7) = v5;
  int v11 = *((_DWORD *)v7 + 16) - 1;
  *((_DWORD *)v7 + 16) = v11;
  if (v11)
  {
    if (!v9)
    {
      uint64_t v12 = *(void *)v7;
      int v13 = (void *)*((void *)v7 + 1);
      if (*(void *)v7)
      {
        *(void *)(v12 + 8) = v13;
        int v13 = (void *)*((void *)v7 + 1);
      }

      else
      {
        *(void *)(a1 + 320) = v13;
      }

      *int v13 = v12;
      uint64_t v17 = *(void *)(a1 + 296);
      *(void *)unint64_t v7 = v17;
      if (v17) {
        uint64_t v18 = (void *)(v17 + 8);
      }
      else {
        uint64_t v18 = (void *)(a1 + 304);
      }
      *uint64_t v18 = v7;
      *(void *)(a1 + 296) = v7;
      *((void *)v7 + 1) = a1 + 296;
    }

    return;
  }

  uint64_t v14 = *((unsigned int *)v7 + 17);
  uint64_t v15 = *(void *)v7;
  unsigned int v16 = (void *)*((void *)v7 + 1);
  if ((_DWORD)v14 != 1)
  {
    if (!v15)
    {
      *(void *)(a1 + 304) = v16;
      goto LABEL_26;
    }

    goto LABEL_19;
  }

  if (v15)
  {
LABEL_19:
    *(void *)(v15 + 8) = v16;
    unsigned int v16 = (void *)*((void *)v7 + 1);
    goto LABEL_26;
  }

  *(void *)(a1 + 320) = v16;
LABEL_26:
  *unsigned int v16 = v15;
  *(void *)(a1 + 8) -= v14;
  ++*(void *)(a1 + 40);
  unint64_t v19 = *((void *)v7 + 3);
  uint64_t v20 = *((void *)v7 + 4);
  if (gLogDatapath)
  {
    v27 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v31 = 136446722;
      *(void *)&v31[4] = "nw_mem_slab_destroy";
      *(_WORD *)&v31[12] = 2048;
      *(void *)&v31[14] = a1;
      *(_WORD *)&v31[22] = 2048;
      *(void *)&v31[24] = v7;
      _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p sl %p", v31, 0x20u);
    }

    if (gLogDatapath)
    {
      v28 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        int v29 = *(_DWORD *)(*((void *)v7 + 5) + 40LL);
        unint64_t v30 = v19 + *(void *)(a1 + 240);
        *(_DWORD *)v31 = 136446978;
        *(void *)&v31[4] = "nw_mem_slab_destroy";
        *(_WORD *)&v31[12] = 1024;
        *(_DWORD *)&v31[14] = v29;
        *(_WORD *)&v31[18] = 2048;
        *(void *)&v31[20] = v19;
        *(_WORD *)&v31[28] = 2048;
        *(void *)&v31[30] = v30;
        _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s   [%u] [%p-%p)", v31, 0x26u);
      }
    }
  }

  v21 = *v10;
  if (*v10)
  {
    do
    {
      v23 = *v10;
      for (j = v7 + 56; v23 != v21; v23 = (void *)*v23)
        j = v23;
      v22 = (void *)*v21;
      void *j = *v21;
      malloc_zone_free((malloc_zone_t *)g_slab_zone, v21);
      v21 = v22;
    }

    while (v22);
  }

  malloc_zone_free((malloc_zone_t *)g_slab_zone, v7);
  nw_mem_region_free(*(void *)(a1 + 216), v19, v20);
}

    if (v14) {
      free(v14);
    }
LABEL_44:
    unsigned int v3 = 0LL;
    goto LABEL_6;
  }

  objc_storeStrong((id *)&v6->definition, a1);
  unint64_t v7 = (uint64_t (*)(void *))v5[11];
  if (v7) {
    v3->handle = (void *)v7(v5);
  }
LABEL_6:

  return v3;
}

    if (v16) {
      free(v16);
    }

    goto LABEL_50;
  }

  v32.receiver = v2;
  v32.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_protocol_options;
  uint64_t v5 = (NWConcrete_nw_protocol_options *)objc_msgSendSuper2(&v32, sel_init);
  unsigned int v2 = v5;
  if (!v5)
  {
    __nwlog_obj();
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if ((__nwlog_fault(v20, &type, &v31) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v31)
      {
        v26 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v27 = type;
        v28 = os_log_type_enabled(v21, type);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
            v36 = 2082;
            v37 = v26;
            _os_log_impl( &dword_181A5C000,  v21,  v27,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v26);
          goto LABEL_48;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_181A5C000, v21, v27, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v30 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_url_scheme";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url_scheme";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_url_scheme";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url_scheme";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url_scheme";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[32];
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = -[nw_endpoint type](v3, "type");

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = -[nw_endpoint type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_address";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = -[nw_endpoint type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = -[nw_endpoint type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_address";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = -[nw_endpoint type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = -[nw_endpoint type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = (const sockaddr *)((char *)v3 + 232);
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = (unsigned __int8 *)v1;
  uint64_t v4 = [v3 type];

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_address_family";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address_family";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_address_family";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address_family";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address_family";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[233];
LABEL_25:

  return v5;
}

    free(v18);
    goto LABEL_43;
  }

  __nwlog_obj();
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v78 = "nw_association_set_cached_content_for_protocol";
  v59 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v75 = OS_LOG_TYPE_DEFAULT;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v63 = type;
    if (os_log_type_enabled(v60, type))
    {
      *(_DWORD *)buf = 136446210;
      v78 = "nw_association_set_cached_content_for_protocol";
      _os_log_impl(&dword_181A5C000, v60, v63, "%{public}s called with null protocol", buf, 0xCu);
    }

    goto LABEL_132;
  }

  if (v75 == OS_LOG_TYPE_DEFAULT)
  {
    __nwlog_obj();
    v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v71 = type;
    if (os_log_type_enabled(v60, type))
    {
      *(_DWORD *)buf = 136446210;
      v78 = "nw_association_set_cached_content_for_protocol";
      _os_log_impl( &dword_181A5C000,  v60,  v71,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_132;
  }

  v67 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v68 = type;
  v69 = os_log_type_enabled(v60, type);
  if (!v67)
  {
    if (v69)
    {
      *(_DWORD *)buf = 136446210;
      v78 = "nw_association_set_cached_content_for_protocol";
      _os_log_impl(&dword_181A5C000, v60, v68, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
    }

    goto LABEL_132;
  }

  if (v69)
  {
    *(_DWORD *)buf = 136446466;
    v78 = "nw_association_set_cached_content_for_protocol";
    v79 = 2082;
    v80 = v67;
    _os_log_impl( &dword_181A5C000,  v60,  v68,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v67);
  if (v59) {
    goto LABEL_134;
  }
LABEL_99:
}

LABEL_43:
      if (v8) {
        free(v8);
      }
      goto LABEL_6;
    }

    if (!v20)
    {
      __nwlog_obj();
      unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null protocol_identifier, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v16 = type;
    uint64_t v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null protocol_identifier, no backtrace",  buf,  0xCu);
      }

      goto LABEL_42;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_path_flow_registration_get_stats_region";
      v24 = 2082;
      v25 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s",  buf,  0x16u);
    }

        while (++v18 != v16)
        {
          uint64_t v17 = *(void *)(a1 + 312);
          if (v17) {
            goto LABEL_26;
          }
        }

        v8 = *(void *)(a1 + 368);
        a5 = v63;
        p_cache = (void **)(&OBJC_CLASS___NWConcrete_nw_activity + 16);
        if (v8)
        {
          uint64_t v5 = a4;
          unsigned int v6 = a2;
          goto LABEL_6;
        }
      }
    }

    ++*(void *)(a1 + 56);
    if ((a5 & 1) != 0) {
      break;
    }
    ++*(_DWORD *)(a1 + 384);
  }

  unsigned int v6 = a2;
  if ((a5 & 2) == 0)
  {
    unsigned int v9 = 0LL;
    v51 = 0LL;
    goto LABEL_71;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v68 = "nw_mem_region_alloc";
  v69 = 2082;
  *(void *)v70 = v64;
  *(_WORD *)&v70[8] = 2048;
  *(void *)&v70[10] = a1;
  v52 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v52);
  if (!result)
  {
    free(v52);
    v8 = 0LL;
    unsigned int v9 = 0LL;
    uint64_t v5 = a4;
    goto LABEL_14;
  }

    free(v10);
    goto LABEL_43;
  }

  uint64_t v5 = nw_endpoint_handler_copy_flow(v3);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 220);
  unsigned int v6 = *((unsigned __int8 *)v5 + 33);
  if (*((_BYTE *)v5 + 32) & 2 | v6 & 1)
  {
    is_viable = (v6 >> 1) & 1;
  }

  else if (*((void *)v5 + 117))
  {
    is_viable = nw_endpoint_handler_is_viable();
  }

  else
  {
    is_viable = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 220);

LABEL_44:
  return is_viable;
}

    goto LABEL_43;
  }

  unsigned int v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v7 = (id)gLogObj;
    else {
      v8 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    v31 = "nw_endpoint_handler_copy_connected_flow_handler";
    uint64_t v32 = 2082;
    v33 = (void *)v8;
    v34 = 2082;
    v35 = "flow";
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v10, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        uint64_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          else {
            int v13 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          uint64_t v32 = 2082;
          v33 = (void *)v13;
          v34 = 2082;
          v35 = "flow";
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v28)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v11, type);
        if (v14)
        {
          if (v16)
          {
            else {
              uint64_t v17 = off_189BBBBC0[mode];
            }
            *(_DWORD *)buf = 136446978;
            v31 = "nw_endpoint_handler_copy_connected_flow_handler";
            uint64_t v32 = 2082;
            v33 = (void *)v17;
            v34 = 2082;
            v35 = "flow";
            v36 = 2082;
            v37 = v14;
            _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v14);
          if (!v10) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }

        if (v16)
        {
          else {
            uint64_t v20 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          uint64_t v32 = 2082;
          v33 = (void *)v20;
          v34 = 2082;
          v35 = "flow";
          _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        uint64_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          else {
            unint64_t v19 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          uint64_t v32 = 2082;
          v33 = (void *)v19;
          v34 = 2082;
          v35 = "flow";
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }

      goto LABEL_42;
    }

    goto LABEL_43;
  }

  if (!v4)
  {
    __nwlog_obj();
    int v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_endpoint_handler_access_proxy_handler";
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null accessor", buf, 0xCu);
      }
    }

    else if (v23)
    {
      uint64_t v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v19 = type;
      uint64_t v20 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_endpoint_handler_access_proxy_handler";
          v27 = 2082;
          v28 = v18;
          _os_log_impl( &dword_181A5C000,  v11,  v19,  "%{public}s called with null accessor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v18);
        if (!v10) {
          goto LABEL_9;
        }
LABEL_44:
        free(v10);
        goto LABEL_9;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_181A5C000, v11, v19, "%{public}s called with null accessor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s called with null accessor, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_42;
  }

  unsigned int v6 = v3;
  while (1)
  {
    unsigned int v6 = v6;
    unint64_t v7 = v6[29];

    if (v7 == 3) {
      break;
    }
    v8 = v6;
    unsigned int v6 = v8[9];

    if (!v6) {
      goto LABEL_8;
    }
  }

  ((void (**)(void, _DWORD *))v5)[2](v5, v6);
LABEL_8:

LABEL_9:
}

    goto LABEL_43;
  }

  if (!v40)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = (os_log_s *)(id)gLogObj;
    int v29 = type;
    if (os_log_type_enabled(v22, type))
    {
      else {
        unint64_t v30 = off_189BBBBC0[v9];
      }
      *(_DWORD *)buf = 136446722;
      v43 = "-[NWConcrete_nw_endpoint_resolver cancelWithHandler:forced:]";
      v44 = 2082;
      v45 = (void *)v30;
      v46 = 2082;
      v47 = "resolver";
      _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_42;
  }

  v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v22 = (os_log_s *)(id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v22, type);
  if (!v25)
  {
    if (v27)
    {
      else {
        v31 = off_189BBBBC0[v9];
      }
      *(_DWORD *)buf = 136446722;
      v43 = "-[NWConcrete_nw_endpoint_resolver cancelWithHandler:forced:]";
      v44 = 2082;
      v45 = (void *)v31;
      v46 = 2082;
      v47 = "resolver";
      _os_log_impl( &dword_181A5C000,  v22,  v26,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_42;
  }

  if (v27)
  {
    else {
      v28 = off_189BBBBC0[v9];
    }
    *(_DWORD *)buf = 136446978;
    v43 = "-[NWConcrete_nw_endpoint_resolver cancelWithHandler:forced:]";
    v44 = 2082;
    v45 = (void *)v28;
    v46 = 2082;
    v47 = "resolver";
    v48 = 2082;
    v49 = v25;
    _os_log_impl( &dword_181A5C000,  v22,  v26,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v25);
  if (v21) {
    goto LABEL_44;
  }
LABEL_45:
}

    goto LABEL_43;
  }

  if (!v4)
  {
    __nwlog_obj();
    int v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_path_flow_registration_access_interface_stats";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null access_block", buf, 0xCu);
      }
    }

    else if (v23)
    {
      unsigned int v16 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = type;
      uint64_t v18 = os_log_type_enabled(v9, type);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_path_flow_registration_access_interface_stats";
          v27 = 2082;
          v28 = (uint64_t)v16;
          _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null access_block, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v16);
        if (!v8) {
          goto LABEL_7;
        }
        goto LABEL_44;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl( &dword_181A5C000,  v9,  v22,  "%{public}s called with null access_block, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_42;
  }

  unsigned int v6 = (void *)v3[9];
  if (v6)
  {
LABEL_6:
    ((void (**)(void, void *))v5)[2](v5, v6);
LABEL_7:

    return;
  }

  unsigned int v6 = calloc(1uLL, 0x68uLL);
  if (v6)
  {
LABEL_5:
    v3[9] = v6;
    goto LABEL_6;
  }

  __nwlog_obj();
  unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v26 = "strict_calloc";
  v27 = 2048;
  v28 = 1LL;
  int v29 = 2048;
  unint64_t v30 = 104LL;
  uint64_t v20 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v20))
  {
    free(v20);
    goto LABEL_5;
  }

  __break(1u);
}

    if (v22) {
      free(v22);
    }
    unsigned int v9 = 0LL;
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_ws_ping_request_create";
  uint64_t v18 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v35.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v18, &v35, &type))
  {
    if (LOBYTE(v35.receiver) == 17)
    {
      __nwlog_obj();
      unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)v35.receiver;
      if (os_log_type_enabled(v19, (os_log_type_t)v35.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_ws_ping_request_create";
        _os_log_impl(&dword_181A5C000, v19, receiver, "%{public}s called with null contents", buf, 0xCu);
      }
    }

    else if (type)
    {
      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = (os_log_type_t)v35.receiver;
      v27 = os_log_type_enabled(v19, (os_log_type_t)v35.receiver);
      if (v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_ws_ping_request_create";
          v38 = 2082;
          v39 = v25;
          _os_log_impl( &dword_181A5C000,  v19,  v26,  "%{public}s called with null contents, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v25);
        goto LABEL_36;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_ws_ping_request_create";
        _os_log_impl(&dword_181A5C000, v19, v26, "%{public}s called with null contents, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = (os_log_type_t)v35.receiver;
      if (os_log_type_enabled(v19, (os_log_type_t)v35.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_ws_ping_request_create";
        _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null contents, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    v95 = OS_LOG_TYPE_DEFAULT;
    v37 = nw_hash_table_add_object(*(void *)(*((void *)v7 + 4) + 24LL), (uint64_t)v16, (char *)&v95);
    if (v95 && v37) {
      goto LABEL_44;
    }
    v42 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v42);
    v43 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v97 = "nw_context_reset_timer_block_with_time";
    v44 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (__nwlog_fault(v44, &type, &v93))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v45 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v45);
        v46 = (os_log_s *)(id)gLogObj;
        v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s Failed to add timer to hash table", buf, 0xCu);
        }
      }

      else if (v93)
      {
        v48 = __nw_create_backtrace_string();
        if (v48)
        {
          v50 = (char *)v48;
          v51 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v51);
          v52 = (os_log_s *)(id)gLogObj;
          v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446466;
            v97 = "nw_context_reset_timer_block_with_time";
            v98 = 2082;
            v99 = (uint64_t)v50;
            _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s Failed to add timer to hash table, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v50);
          if (!v44) {
            goto LABEL_71;
          }
          goto LABEL_70;
        }

        __nwlog_obj(0LL, v49);
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl( &dword_181A5C000,  v46,  v56,  "%{public}s Failed to add timer to hash table, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        v54 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v54);
        v46 = (os_log_s *)(id)gLogObj;
        v55 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl( &dword_181A5C000,  v46,  v55,  "%{public}s Failed to add timer to hash table, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v44)
    {
LABEL_71:
      v57 = *v16;
      v58 = (void *)v16[1];
      if (*v16)
      {
        *(void *)(v57 + 8) = v58;
        v58 = (void *)v16[1];
      }

      else
      {
        *(void *)(*((void *)v7 + 4) + 16LL) = v58;
      }

      *v58 = v57;
      *unsigned int v16 = 0LL;
      v16[1] = 0LL;
      v59 = (void *)v16[4];
      v16[4] = 0LL;

      goto LABEL_75;
    }

    if (v26) {
      free(v26);
    }
LABEL_44:
    unint64_t v7 = 0LL;
    goto LABEL_6;
  }

  p_internalConnection = &v6->_internalConnection;
  objc_storeStrong((id *)&v6->_internalConnection, a3);
  unsigned int v9 = (id *)v5;
  unint64_t v10 = v9[1];

  int v11 = +[NWEndpoint endpointWithInternalEndpoint:](&OBJC_CLASS___NWEndpoint, "endpointWithInternalEndpoint:", v10);
  endpoint = v7->_endpoint;
  v7->_endpoint = (NWEndpoint *)v11;

  int v13 = objc_alloc(&OBJC_CLASS___NWParameters);
  uint64_t v14 = v9;
  uint64_t v15 = v14[2];

  unsigned int v16 = -[NWParameters initWithParameters:](v13, "initWithParameters:", v15);
  parameters = v7->_parameters;
  v7->_parameters = (NWParameters *)v16;

  v7->_state = 1LL;
  -[NWTCPConnection setupEventHandler](v7, "setupEventHandler");
  uint64_t v18 = *p_internalConnection;
  if (NWCopyInternalQueue_init_once != -1) {
    dispatch_once(&NWCopyInternalQueue_init_once, &__block_literal_global_62911);
  }
  unint64_t v19 = (dispatch_queue_s *)(id)NWCopyInternalQueue_nwQueue;
  nw_connection_set_queue(v18, v19);

  nw_connection_start(*p_internalConnection);
LABEL_6:

  return v7;
}

    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_43;
  }

  if (a3)
  {
    if (gLogDatapath)
    {
      int v13 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v14 = "invalid";
        if (a2 && *(void *)(a2 + 16)) {
          uint64_t v14 = *(const char **)(a2 + 16);
        }
        *(_DWORD *)buf = 136446722;
        v22 = "nw_protocol_plugins_handle_reset";
        v23 = 2080;
        v24 = (void *)v14;
        v25 = 2048;
        v26 = a2;
        _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
      }
    }

    unsigned int v6 = *(uint64_t **)(a1 + 8);
    if (v6) {
      nw_protocol_plugin_metadata_reset(v6);
    }
    unint64_t v7 = *(void (***)(uint64_t, uint64_t))(a1 + 16);
    if (v7)
    {
      v8 = *v7;
      if (v8) {
        v8(a2, a3);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_plugins_handle_reset";
  unsigned int v9 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  unint64_t v19 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v10 = (os_log_s *)__nwlog_obj();
    int v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_plugins_handle_reset";
    uint64_t v12 = "%{public}s called with null other_protocol";
    goto LABEL_42;
  }

  if (!v19)
  {
    unint64_t v10 = (os_log_s *)__nwlog_obj();
    int v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_plugins_handle_reset";
    uint64_t v12 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_42;
  }

  uint64_t v17 = (char *)__nw_create_backtrace_string();
  unint64_t v10 = (os_log_s *)__nwlog_obj();
  int v11 = type;
  uint64_t v18 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (!v18) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_plugins_handle_reset";
    uint64_t v12 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_42;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_plugins_handle_reset";
    v23 = 2082;
    v24 = v17;
    _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v17);
  if (v9) {
    goto LABEL_44;
  }
}

          free(v36);
          if (!v32) {
            return;
          }
LABEL_65:
          free(v32);
          return;
        }

        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_63;
        }
      }

      else
      {
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_63;
        }
      }

      goto LABEL_64;
    }

    v33 = (os_log_s *)__nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92)) {
      goto LABEL_64;
    }
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null protocol";
    goto LABEL_63;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        v55 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null context, dumping backtrace:%{public}s";
            goto LABEL_41;
          }

          goto LABEL_42;
        }

        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null context, no backtrace";
          goto LABEL_63;
        }
      }

      else
      {
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null context, backtrace limit exceeded";
          goto LABEL_63;
        }
      }

      goto LABEL_64;
    }

    v33 = (os_log_s *)__nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92)) {
      goto LABEL_64;
    }
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null context";
    goto LABEL_63;
  }

  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        v56 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null _output_frames_handler, dumping backtrace:%{public}s";
            goto LABEL_41;
          }

          goto LABEL_42;
        }

        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _output_frames_handler, no backtrace";
          goto LABEL_63;
        }
      }

      else
      {
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _output_frames_handler, backtrace limit exceeded";
          goto LABEL_63;
        }
      }

      goto LABEL_64;
    }

    v33 = (os_log_s *)__nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92)) {
      goto LABEL_64;
    }
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null _output_frames_handler";
    goto LABEL_63;
  }

  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        v57 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v57)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null _before_connect_handler, dumping backtrace:%{public}s";
            goto LABEL_41;
          }

          goto LABEL_42;
        }

        if (v57)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _before_connect_handler, no backtrace";
          goto LABEL_63;
        }
      }

      else
      {
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _before_connect_handler, backtrace limit exceeded";
          goto LABEL_63;
        }
      }

      goto LABEL_64;
    }

    v33 = (os_log_s *)__nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92)) {
      goto LABEL_64;
    }
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null _before_connect_handler";
    goto LABEL_63;
  }

  if (!a10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (__nwlog_fault(v32, &v92, &v91))
    {
      if (v92 == OS_LOG_TYPE_FAULT)
      {
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null destroy_handler";
          goto LABEL_63;
        }
      }

      else if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        v58 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v58)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null destroy_handler, dumping backtrace:%{public}s";
            goto LABEL_41;
          }

          goto LABEL_42;
        }

        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null destroy_handler, no backtrace";
          goto LABEL_63;
        }
      }

      else
      {
        v33 = (os_log_s *)__nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null destroy_handler, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
    }

  if (v17) {
    free(v17);
  }
  unsigned int v9 = 0LL;
LABEL_9:

  return (nw_protocol_definition_t)v9;
}

  if (v16) {
    free(v16);
  }
}

        free(v13);
        goto LABEL_6;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_ws_request_enumerate_additional_headers";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_ws_request_enumerate_additional_headers";
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      if (!v35)
      {
LABEL_44:
        int v11 = 0LL;
        goto LABEL_49;
      }

  __break(1u);
  return result;
}

    free(v22);
    if (!v12) {
      goto LABEL_12;
    }
    goto LABEL_63;
  }

  if (!strcasecmp(name, "Sec-WebSocket-Accept")
    || !strcasecmp(name, "Sec-WebSocket-Protocol")
    || !strcasecmp(name, "Upgrade")
    || !strcasecmp(name, "Connection"))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v33 = "nw_ws_response_add_additional_header";
      v34 = 2080;
      v35 = name;
      v36 = 2080;
      v37 = value;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot override (%s, %s) header in the server's response",  buf,  0x20u);
    }
  }

  else
  {
    unsigned int v6 = (void *)*((void *)v5 + 3);
    unint64_t v7 = xpc_string_create(name);
    xpc_array_append_value(v6, v7);

    v8 = (void *)*((void *)v5 + 4);
    unsigned int v9 = xpc_string_create(value);
    xpc_array_append_value(v8, v9);
  }

        free(v13);
        goto LABEL_6;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_ws_response_enumerate_additional_headers";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null response, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_ws_response_enumerate_additional_headers";
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null response, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    free(backtrace_string);
    goto LABEL_55;
  }

  __buf = 0LL;
  unint64_t v7 = *((void *)v5 + 37);
  if (!v7 || (node = nw_hash_table_get_node(v7, a2, 8LL)) == 0)
  {
LABEL_57:
    uint64_t v17 = 0LL;
    goto LABEL_58;
  }

  unsigned int v9 = node;
  unint64_t v10 = *(void **)(node + 48);
  int v11 = v10;
  if (v11)
  {
    arc4random_buf(&__buf, 8uLL);
    v35 = 0;
    uint64_t v12 = nw_hash_table_add_object(*((void *)v5 + 37), __buf, &v35);
    if (v35)
    {
      int v13 = v12;
      if (v12)
      {
        *(_OWORD *)(v12 + 32) = 0u;
        *(_OWORD *)(v12 + 48) = 0u;
        *(_OWORD *)(v12 + 144) = 0u;
        *(_OWORD *)(v12 + 160) = 0u;
        *(_OWORD *)(v12 + 112) = 0u;
        *(_OWORD *)(v12 + 128) = 0u;
        *(_OWORD *)(v12 + 80) = 0u;
        *(_OWORD *)(v12 + 96) = 0u;
        *(_OWORD *)(v12 + 64) = 0u;
        objc_storeStrong((id *)(v12 + 48), v10);
        *(_OWORD *)(v13 + 32) = *(_OWORD *)(v9 + 32);
        *(_DWORD *)(v13 + 160) = 1;
        *(_BYTE *)(v13 + 169) &= ~8u;
        objc_storeStrong((id *)(v13 + 152), a3);
        *(void *)(v13 + 136) = 0LL;
        *(void *)(v13 + 144) = v13 + 136;
        (*(void (**)(char *))(*(void *)(*((void *)v5 + 1) + 80LL) + 208LL))(v5);
        if ((v5[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v14 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            uint64_t v15 = *(void *)(v13 + 48);
            unsigned int v16 = *(void *)(v13 + 152);
            *(_DWORD *)buf = 136447490;
            v37 = "nw_protocol_instance_create_extra_path";
            v38 = 2082;
            v39 = v5 + 407;
            v40 = 2080;
            v41 = " ";
            v42 = 2048;
            v43 = __buf;
            v44 = 2112;
            v45 = v15;
            v46 = 2112;
            v47 = v16;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sPath %lx created over %@ (overriden endpoint %@)",  buf,  0x3Eu);
          }
        }

        uint64_t v17 = __buf;
        goto LABEL_22;
      }
    }

    if ((v5[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v19 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v37 = "nw_protocol_instance_create_extra_path";
        v38 = 2082;
        v39 = v5 + 407;
        v40 = 2080;
        v41 = " ";
        v42 = 2048;
        v43 = __buf;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to add additional path %lx to paths table",  buf,  0x2Au);
      }
    }
  }

  else if ((v5[405] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      v37 = "nw_protocol_instance_create_extra_path";
      v38 = 2082;
      v39 = v5 + 407;
      v40 = 2080;
      v41 = " ";
      v42 = 2048;
      v43 = a2;
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sCannot establish extra path on interface used by %lx: interface not found",  buf,  0x2Au);
    }
  }

  uint64_t v17 = 0LL;
LABEL_22:

LABEL_58:
  return v17;
}

    goto LABEL_43;
  }

  if (a2)
  {
    if (*((void *)v3 + 37))
    {
      uint64_t v5 = (void *)*((void *)v3 + 15);
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_protocol_instance_tear_down_path_block_invoke;
      v21[3] = &unk_189BC66E8;
      v22 = v3;
      v23 = a2;
      nw_queue_context_async(v5, v21);
    }

    else if ((v3[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v6 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v27 = "nw_protocol_instance_tear_down_path";
        v28 = 2082;
        int v29 = v4 + 407;
        unint64_t v30 = 2080;
        v31 = " ";
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo path table found", buf, 0x20u);
      }
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  int v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_protocol_instance_tear_down_path";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_instance_tear_down_path";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null path", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (!v24)
  {
    __nwlog_obj();
    unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_instance_tear_down_path";
      _os_log_impl(&dword_181A5C000, v9, v20, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_42;
  }

  unsigned int v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v17 = type;
  uint64_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_instance_tear_down_path";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null path, no backtrace", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_protocol_instance_tear_down_path";
    v28 = 2082;
    int v29 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_44;
  }
LABEL_9:
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = -[nw_endpoint type](v3, "type");

  if (v4 != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = -[nw_endpoint type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_bonjour_service_name";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = -[nw_endpoint type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_name";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = -[nw_endpoint type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_bonjour_service_name";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = -[nw_endpoint type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_name";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = -[nw_endpoint type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_name";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = (const char *)*((void *)v3 + 29);
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = -[nw_endpoint type](v3, "type");

  if (v4 != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = -[nw_endpoint type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_bonjour_service_type";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = -[nw_endpoint type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_type";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = -[nw_endpoint type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_bonjour_service_type";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = -[nw_endpoint type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_type";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = -[nw_endpoint type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_type";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = (const char *)*((void *)v3 + 30);
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = -[nw_endpoint type](v3, "type");

  if (v4 != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = -[nw_endpoint type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_bonjour_service_domain";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = -[nw_endpoint type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_domain";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = -[nw_endpoint type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_bonjour_service_domain";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = -[nw_endpoint type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_domain";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = -[nw_endpoint type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_service_domain";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = (const char *)*((void *)v3 + 31);
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_bonjour_fullname";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_fullname";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_bonjour_fullname";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_fullname";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_bonjour_fullname";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[32];
LABEL_25:

  return v5;
}
}

      if (v18) {
        free(v18);
      }
      return 0LL;
    }

    if (!v28)
    {
      unint64_t v19 = (os_log_s *)__nwlog_obj();
      uint64_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_trainer_top_inject_output";
        v21 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v19 = (os_log_s *)__nwlog_obj();
    uint64_t v20 = type;
    v23 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_trainer_top_inject_output";
        v21 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_protocol_trainer_top_inject_output";
      uint64_t v32 = 2082;
      v33 = backtrace_string;
      v24 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v19, v20, v24, buf, 0x16u);
    }

  if (v22) {
    free(v22);
  }
  return 0LL;
}

        v219[0] = 0;
LABEL_44:
        if ((*((void *)&v11->value + 11) & 4LL) != 0) {
          v27 = ", fast-open";
        }
        else {
          v27 = "";
        }
        default_stack = v11->default_stack;
        int v29 = (void *)nw_protocol_boringssl_copy_definition();
        v197 = v27;
        LODWORD(default_stack) = nw_protocol_stack_includes_protocol(default_stack, v29);

        unint64_t v30 = ", tls";
        if (!(_DWORD)default_stack) {
          unint64_t v30 = "";
        }
        v195 = v30;
        if ((*((void *)&v11->value + 11) & 0x40LL) != 0) {
          v31 = "";
        }
        else {
          v31 = ", definite";
        }
        v194 = v31;
        uint64_t v32 = v11;
        v33 = *((void *)&v11->value + 11);

        v34 = ", server";
        if ((v33 & 0x8000) == 0) {
          v34 = "";
        }
        v193 = v34;
        v35 = v32;
        v36 = *((void *)&v11->value + 11);

        v37 = ", attach protocol listener";
        if ((v36 & 0x400000) == 0) {
          v37 = "";
        }
        v192 = v37;
        v38 = v35;
        v39 = *((void *)&v11->value + 11);

        v40 = ", prohibit joining";
        if ((v39 & 0x800000) == 0) {
          v40 = "";
        }
        v191 = v40;
        v41 = v38;
        v42 = *((void *)&v11->value + 11);

        v43 = ", allow joining fd";
        if ((v42 & 0x1000000) == 0) {
          v43 = "";
        }
        v190 = v43;
        v44 = v41;
        v45 = *((void *)&v11->value + 11);

        v46 = ", allow duplicate updates";
        if ((v45 & 0x4000000) == 0) {
          v46 = "";
        }
        v189 = v46;
        v47 = v44;
        v48 = *((void *)&v11->value + 11);

        v49 = ", don't always open listener socket";
        if ((v48 & 0x8000000) != 0) {
          v49 = "";
        }
        v188 = v49;
        v50 = v47;
        v51 = *((void *)&v11->value + 11);

        v52 = ", never open listener socket";
        if ((v51 & 0x10000000) == 0) {
          v52 = "";
        }
        v187 = v52;
        v53 = v50;
        v54 = *((void *)&v11->value + 11);

        v55 = ", disable listener datapath";
        if ((v54 & 0x20000000) == 0) {
          v55 = "";
        }
        v186 = v55;
        v56 = v53;
        v57 = *((void *)&v11->value + 11);

        v58 = ", requires DNSSEC validation";
        if ((v57 & 0x40000000) == 0) {
          v58 = "";
        }
        v185 = v58;
        v59 = v56;
        v60 = *((void *)&v11->value + 11);

        if ((v60 & 0x100) != 0) {
          v61 = ", reuse local address";
        }
        else {
          v61 = "";
        }
        v62 = v59;
        v63 = *((void *)&v11->value + 11);

        if ((v63 & 0x100000000LL) != 0) {
          v64 = ", prohibit encrypted DNS";
        }
        else {
          v64 = "";
        }
        v65 = v62;
        v66 = *((void *)&v11->value + 11);

        if ((v66 & 0x200000000LL) != 0) {
          v67 = ", block trackers";
        }
        else {
          v67 = "";
        }
        v68 = v65;
        v69 = *((void *)&v11->value + 11);

        if ((v69 & 0x400000000LL) != 0) {
          v70 = ", fail if SVCB received";
        }
        else {
          v70 = "";
        }
        v71 = v68;
        v72 = *((void *)&v11->value + 11);

        v73 = ", include ble";
        if ((v72 & 0x800000000LL) == 0) {
          v73 = "";
        }
        v184 = v73;
        v74 = v71;
        v75 = *((void *)&v11->value + 11);

        v76 = ", screen off";
        if ((v75 & 0x1000000000LL) == 0) {
          v76 = "";
        }
        v183 = v76;
        v77 = v74;
        v78 = *((void *)&v11->value + 11);

        v79 = ", internet fallback";
        if ((v78 & 0x2000000000LL) == 0) {
          v79 = "";
        }
        v182 = v79;
        v80 = v77;
        v81 = *((void *)&v11->value + 11);

        v82 = ", minimize logging";
        if ((v81 & 0x4000000000LL) == 0) {
          v82 = "";
        }
        v181 = v82;
        v83 = v80;
        v84 = *((void *)&v11->value + 11);

        v85 = ", local only";
        if ((v84 & 0x4000) == 0) {
          v85 = "";
        }
        v179 = v85;
        v86 = v83;
        v87 = *((void *)&v11->value + 11);

        if ((v87 & 0x10000000000LL) != 0) {
          v88 = ", stricter path scoping";
        }
        else {
          v88 = "";
        }
        v89 = v86;
        v90 = *((void *)&v11->value + 11);

        v91 = ", allow private access tokens for third party";
        if ((v90 & 0x20000000000LL) == 0) {
          v91 = "";
        }
        v177 = v91;
        v92 = v89;
        v93 = *((void *)&v11->value + 11);

        v94 = ", using ephemeral configuration";
        if ((v93 & 0x40000000000LL) == 0) {
          v94 = "";
        }
        v175 = v94;
        v95 = v92;
        v96 = *((void *)&v11->value + 11);

        if ((v96 & 0x80000000000LL) != 0) {
          v97 = ", prevents system http proxy authentication";
        }
        else {
          v97 = "";
        }
        v98 = *((unsigned __int8 *)&v11->path_parameters->path_value + 30);
        if (v98 > 2)
        {
          v99 = "unknown";
          if (aUnknown[0])
          {
LABEL_104:
            snprintf(v218, 0x26uLL, ", attribution: %s", v99);
            v100 = v11->default_stack;
            if (v100)
            {
LABEL_105:
              v101 = v70;
              transport_protocol = v100->transport_protocol;
              v103 = "generic";
              if (transport_protocol)
              {
                v104 = v88;
                v105 = v95;
                v106 = transport_protocol;
                v173 = v67;
                v107 = v106[1];

                v95 = v105;
                v88 = v104;
                identifier = nw_protocol_definition_get_identifier(v107);
                if (identifier) {
                  v103 = identifier;
                }
                v196 = v103;

                v67 = v173;
              }

              else
              {
                v196 = "generic";
              }

              v70 = v101;
LABEL_114:
              v201 = 0LL;
              if (a2)
              {
                nw_path_parameters_copy_verbose_description(v11->path_parameters, (char *)buf);
                asprintf( &v201,  "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s, %s",  v196,  __str,  (const char *)type,  v219,  v220,  v222,  v221,  v197,  v195,  v194,  v193,  v192,  v191,  v190,  v189,  v188,  v187,  v186,  v218,  v185,  v61,  v64,  v67,  v70,  v184,  v183,  v182,  v181,  v179,  v88,  v177,  v175,  v97,  (const char *)buf);
LABEL_216:
                v117 = v201;
                goto LABEL_217;
              }

              if (v11->path_parameters->process_path_value.pid)
              {
                snprintf(v213, 0x10uLL, ", pid: %d", v11->path_parameters->process_path_value.pid);
                pid = v11->path_parameters->process_path_value.pid;
              }

              else
              {
                pid = 0;
                v213[0] = 0;
              }

              if (pid == getpid()) {
                v213[0] = 0;
              }
              path_parameters = v11->path_parameters;
              v111 = *(const char **)&path_parameters->joinable_path_value.fallback_mode;
              if (!v111) {
                goto LABEL_143;
              }
              v112 = path_parameters->attributed_bundle;
              v113 = v112;
              if (v112 && (v114 = *((_DWORD *)v112 + 31), (v114 - 2) >= 2))
              {
                if (v114 == 1)
                {

                  goto LABEL_141;
                }
              }

              else
              {
                if (nwlog_get_sensitive_redacted::onceToken != -1) {
                  dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
                }
                v115 = nwlog_get_sensitive_redacted::sensitiveRedacted;

                if (!v115)
                {
LABEL_141:
                  if (*v111)
                  {
                    snprintf((char *)buf, 0x91uLL, ", account id: %s", v111);
                    goto LABEL_144;
                  }

    goto LABEL_43;
  }

  if (a2)
  {
    *(_OWORD *)v5->value.parent_id = *(_OWORD *)a2;
    if (a3)
    {
      required_interface = v5->path_parameters->required_interface;
      if (required_interface)
      {
        if (*((void *)required_interface + 16))
        {
          v8 = (void *)*((void *)required_interface + 17);
          if (!v8)
          {
            unsigned int v9 = xpc_array_create(0LL, 0LL);
            unint64_t v10 = v6->path_parameters->required_interface;
            int v11 = (void *)*((void *)v10 + 17);
            *((void *)v10 + 17) = v9;

            v8 = (void *)*((void *)v6->path_parameters->required_interface + 17);
          }

          xpc_array_set_uuid(v8, 0xFFFFFFFFFFFFFFFFLL, a2);
        }
      }
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v29 = "nw_parameters_set_parent_id_inner";
  int v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v17 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      int v29 = "nw_parameters_set_parent_id_inner";
      _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null parent_id", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (!v26)
  {
    __nwlog_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v25 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      int v29 = "nw_parameters_set_parent_id_inner";
      _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s called with null parent_id, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_42;
  }

  v21 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v22 = type;
  v23 = os_log_type_enabled(v14, type);
  if (!v21)
  {
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      int v29 = "nw_parameters_set_parent_id_inner";
      _os_log_impl(&dword_181A5C000, v14, v22, "%{public}s called with null parent_id, no backtrace", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (v23)
  {
    *(_DWORD *)buf = 136446466;
    int v29 = "nw_parameters_set_parent_id_inner";
    unint64_t v30 = 2082;
    v31 = v21;
    _os_log_impl( &dword_181A5C000,  v14,  v22,  "%{public}s called with null parent_id, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v21);
  if (v13) {
    goto LABEL_44;
  }
LABEL_9:
}

    goto LABEL_43;
  }

  if (a2)
  {
    unint64_t v7 = nw_parameters_copy_tls_options(v5);
    v8 = v7;
    if (v7)
    {
      unsigned int v9 = (sec_protocol_options *)v7;
      if ((_DWORD)v3)
      {
        unsigned int v3 = v3;
        do
        {
          unint64_t v10 = *a2++;
          sec_protocol_options_append_tls_ciphersuite(v9, v10);
          --v3;
        }

        while (v3);
      }
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_parameters_set_ssl_cipher_suites";
  uint64_t v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v16 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_parameters_set_ssl_cipher_suites";
      _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null cipher_suites", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (!v25)
  {
    __nwlog_obj();
    int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v24 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_parameters_set_ssl_cipher_suites";
      _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s called with null cipher_suites, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_42;
  }

  uint64_t v20 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v21 = type;
  v22 = os_log_type_enabled(v13, type);
  if (!v20)
  {
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_parameters_set_ssl_cipher_suites";
      _os_log_impl(&dword_181A5C000, v13, v21, "%{public}s called with null cipher_suites, no backtrace", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    v28 = "nw_parameters_set_ssl_cipher_suites";
    int v29 = 2082;
    unint64_t v30 = v20;
    _os_log_impl( &dword_181A5C000,  v13,  v21,  "%{public}s called with null cipher_suites, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v20);
  if (v12) {
    goto LABEL_44;
  }
LABEL_9:
}

      unsigned int v6 = 0LL;
      goto LABEL_43;
    }

    __nwlog_obj();
    int v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_parameters_has_persistent_protocol_in_stack";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v12, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_parameters_has_persistent_protocol_in_stack";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null stack", buf, 0xCu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v19 = type;
        uint64_t v20 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_parameters_has_persistent_protocol_in_stack";
            v28 = 2082;
            int v29 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_parameters_has_persistent_protocol_in_stack";
          _os_log_impl(&dword_181A5C000, v13, v19, "%{public}s called with null stack, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_parameters_has_persistent_protocol_in_stack";
          _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      free(backtrace_string);
    }
  }

                unsigned int v6 = 0LL;
              }
            }
          }
        }
      }
    }
  }

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = (unsigned int *)v1;
  uint64_t v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_device_color";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_color";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_device_color";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_color";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_color";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[70];
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = (unsigned int *)v1;
  uint64_t v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_advertised_route";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_advertised_route";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_advertised_route";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_advertised_route";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_advertised_route";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[71];
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_application_service_alias";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_application_service_alias";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_application_service_alias";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_application_service_alias";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_application_service_alias";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[29];
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_application_service_name";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_application_service_name";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_application_service_name";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_application_service_name";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_application_service_name";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[30];
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_device_name";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_name";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_device_name";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_name";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_name";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[33];
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_device_model";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_model";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_device_model";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_model";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_device_model";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[34];
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_contact_id";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_contact_id";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_contact_id";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_contact_id";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_contact_id";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[36];
LABEL_25:

  return v5;
}

  v28 = +[ManagedNetworkSettings sharedMNS](&OBJC_CLASS___ManagedNetworkSettings, "sharedMNS", v31, v32);
  [v28 reloadMNS];

LABEL_43:
}

        uint64_t v32 = v9;
        v33 = [v32 hostname];

        if (v33) {
          CFStringAppendFormat(Mutable, 0LL, @"%s", v33);
        }
        goto LABEL_44;
      }
    }

    else if (!v8)
    {
      goto LABEL_39;
    }

    if (nw_parameters_get_ip_protocol(v8) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v52 = 136446210;
        v53 = "nw_endpoint_proxy_copy_synthesized_url";
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s Using datagram service lookup for UDP",  v52,  0xCu);
      }

      v28 = "udp";
LABEL_40:
      int v29 = v9;
      unint64_t v30 = [v29 port];

      v31 = getservbyport(v30, v28);
      if (!v31)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v52 = 136446210;
          v53 = "nw_endpoint_proxy_copy_synthesized_url";
          _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s Unknown service and did not find TLS protocol, cannot synthesize URL",  v52,  0xCu);
        }

        CFRelease(Mutable);
        uint64_t v12 = 0LL;
        goto LABEL_60;
      }

      CFStringAppendFormat(Mutable, 0LL, @"%s://", v31->s_name);
      uint64_t v18 = 0;
      if (v10 != 2) {
        goto LABEL_17;
      }
      goto LABEL_42;
    }

      goto LABEL_43;
    }

    if (!v26)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)(id)gLogObj;
      int v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v29 = "nw_hsts_storage_parse_and_set";
        uint64_t v14 = "%{public}s called with null sts_header, backtrace limit exceeded";
        goto LABEL_40;
      }

      goto LABEL_42;
    }

    uint64_t v20 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (os_log_s *)(id)gLogObj;
    uint64_t v18 = type;
    v23 = os_log_type_enabled(v12, type);
    if (v20)
    {
      if (!v23) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446466;
      int v29 = "nw_hsts_storage_parse_and_set";
      unint64_t v30 = 2082;
      v31 = v20;
      v22 = "%{public}s called with null sts_header, dumping backtrace:%{public}s";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v12, v18, v22, buf, 0x16u);
LABEL_32:

      free(v20);
      if (!v11) {
        goto LABEL_5;
      }
      goto LABEL_44;
    }

    if (!v23) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    int v29 = "nw_hsts_storage_parse_and_set";
    uint64_t v14 = "%{public}s called with null sts_header, no backtrace";
    goto LABEL_51;
  }

  v8 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], a4, 0x201u);
  [v7[1] handleSTSHeader:v8 forURL:v6];

LABEL_5:
  return 0LL;
}

  if (v27) {
    free(v27);
  }
LABEL_6:

  unint64_t v19 = v40;
  uint64_t v20 = v16;

  return v20;
}

  if (v27) {
    free(v27);
  }
LABEL_6:

  unint64_t v19 = v40;
  uint64_t v20 = v16;

  return v20;
}

    free(backtrace_string);
    goto LABEL_56;
  }

  uint64_t v12 = (os_log_s *)__nwlog_obj();
  int v13 = type;
  if (os_log_type_enabled(v12, type))
  {
    *(_DWORD *)buf = 136446210;
    v23 = "operator()";
    uint64_t v14 = "%{public}s called with null other_protocol";
    goto LABEL_55;
  }

            if (!v34)
            {
LABEL_44:

LABEL_45:
              v42 = (void *)aBlock;
              goto LABEL_46;
            }

LABEL_16:
    if (!v9)
    {
LABEL_18:
      unsigned int v6 = 0LL;
      goto LABEL_19;
    }

    if (v9) {
      free(v9);
    }
LABEL_44:
    a3 = 0LL;
    goto LABEL_45;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v12 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "tcp_connection_set_tls";
  int v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  int v29 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)(id)gLogObj;
    uint64_t v15 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "tcp_connection_set_tls";
      _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null connection", buf, 0xCu);
    }
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_43;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          unsigned int v9 = handle[11];
          if (v9) {
            unint64_t v10 = *(_DWORD *)(v9 + 460);
          }
          else {
            unint64_t v10 = -1;
          }
          uint64_t v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          unint64_t v19 = "nw_protocol_webtransport_stream_disconnect";
          uint64_t v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }

    if (*((_DWORD *)handle + 46) != 3 || *((_DWORD *)handle + 47) != 3) {
      handle[23] = 0x300000003LL;
    }
    nw_protocol_disconnected(a1->default_input_handler->flow_id, (uint64_t)a1);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v19 = "nw_protocol_webtransport_stream_disconnect";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  unsigned int v16 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    unsigned int v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_webtransport_stream_disconnect";
    unint64_t v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_42;
  }

  if (!v16)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    unsigned int v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_webtransport_stream_disconnect";
    unint64_t v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_42;
  }

  int v13 = (char *)__nw_create_backtrace_string();
  uint64_t v5 = (os_log_s *)__nwlog_obj();
  unsigned int v6 = type;
  uint64_t v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_webtransport_stream_disconnect";
    unint64_t v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_42;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v19 = "nw_protocol_webtransport_stream_disconnect";
    uint64_t v20 = 2082;
    v21 = v13;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v13);
  if (v4) {
    goto LABEL_44;
  }
}

  if (v7) {
    free(v7);
  }
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_54;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
    int v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      uint64_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        unsigned int v16 = "%{public}s called with null webtransport_stream";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      uint64_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        unsigned int v16 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v14 = (os_log_s *)__nwlog_obj();
    uint64_t v15 = type;
    v23 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        unsigned int v16 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
      v36 = 2082;
      v37 = backtrace_string;
      v22 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_41;
    }

    goto LABEL_42;
  }

  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = handle[11];
        if (v18) {
          unint64_t v19 = *(_DWORD *)(v18 + 460);
        }
        else {
          unint64_t v19 = -1;
        }
        v24 = handle[8];
        *(_DWORD *)buf = 136447234;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v36 = 2082;
        v37 = (char *)(handle + 24);
        v38 = 2080;
        v39 = " ";
        v40 = 1024;
        v41 = v19;
        v42 = 2048;
        v43 = v24;
        _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }

  if ((*((_BYTE *)handle + 276) & 8) != 0)
  {
    unint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v5 = handle[8];
    if (v5 >= 0x40)
    {
      if (v5 >> 14)
      {
        if (v5 >> 30)
        {
          if (v5 >> 62)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446466;
            v35 = "_http_vle_encode";
            v36 = 2048;
            v37 = (char *)v5;
            v8 = (void *)_os_log_send_and_compose_impl();
            result = __nwlog_abort((uint64_t)v8);
            if ((_DWORD)result)
            {
              __break(1u);
              return result;
            }

            free(v8);
            uint64_t v5 = 0LL;
            unsigned int v6 = 0;
          }

          else
          {
            uint64_t v5 = bswap64(v5 | 0xC000000000000000LL);
            unsigned int v6 = 8;
          }
        }

        else
        {
          uint64_t v5 = bswap32(v5 | 0x80000000);
          unsigned int v6 = 4;
        }
      }

      else
      {
        uint64_t v5 = bswap32(v5 | 0x4000) >> 16;
        unsigned int v6 = 2;
      }
    }

    else
    {
      unsigned int v6 = 1;
    }

    v25[0] = MEMORY[0x1895F87A8];
    v25[1] = 0x40000000LL;
    v26 = ___ZL60nw_protocol_webtransport_http2_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
    v27 = &__block_descriptor_tmp_34_34184;
    v31 = v6;
    v28 = a1;
    int v29 = v5;
    unint64_t v30 = handle;
    tqh_first = a2->tqh_first;
    unint64_t v7 = 420171067LL;
    do
    {
      if (!tqh_first) {
        break;
      }
      int v11 = (nw_frame *)*((void *)tqh_first + 4);
      uint64_t v12 = ((uint64_t (*)(void *))v26)(v25);
      tqh_first = v11;
    }

    while ((v12 & 1) != 0);
  }

  return nw_http_capsule_framer_finalize_output_frames(handle[11] + 96LL, handle[11], v7, (uint64_t *)a2);
}

  if (v7) {
    free(v7);
  }
}

  if (v20) {
    free(v20);
  }
  uint64_t v5 = 0LL;
LABEL_18:

  return v5;
}

    free(v13);
    goto LABEL_43;
  }

  if ((!self->primary_child || v7[2](v7)) && (!self->fallback_child || v7[2](v7))) {
    goto LABEL_43;
  }
  unint64_t v10 = 0;
LABEL_44:

  return v10;
}

  if (v5) {
LABEL_43:
  }
    free((void *)v5);
  return 1LL;
}

    if (!v13) {
      goto LABEL_58;
    }
    goto LABEL_43;
  }

  if (v3)
  {
    if ((*(_BYTE *)(v3 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v127 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
        {
          v128 = *(void *)(v3 + 488);
          v129 = *(_DWORD *)(*(void *)(v3 + 480) + 372LL);
          v130 = *(_DWORD *)(v3 + 860);
          if (v128) {
            LODWORD(v128) = *(_DWORD *)(v128 + 424);
          }
          *(_DWORD *)buf = 136447746;
          *(void *)&buf[4] = "nw_http1_remove_idle_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v3 + 74;
          *(_WORD *)&buf[22] = 2080;
          v209 = (uint64_t)" ";
          *(_WORD *)v210 = 1024;
          *(_DWORD *)&v210[2] = v129;
          *(_WORD *)&v210[6] = 1024;
          *(_DWORD *)&v210[8] = v130;
          *(_WORD *)&v210[12] = 1024;
          *(_DWORD *)&v210[14] = v128;
          *(_WORD *)&v210[18] = 2048;
          *(void *)&v210[20] = v3;
          _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> called for connection %p",  buf,  0x3Cu);
        }
      }
    }

    if (((*(unsigned __int16 *)(v3 + 872) | (*(unsigned __int8 *)(v3 + 874) << 16)) & 0x80000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_http1_remove_idle_connection";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v3;
      int v13 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(type) = 16;
      LOBYTE(v213) = 0;
      if (type == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = gLogObj;
        uint64_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type)) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_http1_remove_idle_connection";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v3;
        unsigned int v16 = "%{public}s connection %p not in idle list, cannot remove";
LABEL_40:
        v36 = (os_log_s *)v14;
        v37 = v15;
        v38 = 22;
LABEL_41:
        _os_log_impl(&dword_181A5C000, v36, v37, v16, buf, v38);
        goto LABEL_42;
      }

      if (!(_BYTE)v213)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = gLogObj;
        uint64_t v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type)) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_http1_remove_idle_connection";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v3;
        unsigned int v16 = "%{public}s connection %p not in idle list, cannot remove, backtrace limit exceeded";
        goto LABEL_40;
      }

      unint64_t v19 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = gLogObj;
      uint64_t v15 = type;
      uint64_t v20 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type);
      if (!v19)
      {
        uint64_t v12 = &qword_18C45F000;
        if (!v20) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_http1_remove_idle_connection";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v3;
        unsigned int v16 = "%{public}s connection %p not in idle list, cannot remove, no backtrace";
        goto LABEL_40;
      }

      if (!v20) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&buf[4] = "nw_http1_remove_idle_connection";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v3;
      *(_WORD *)&buf[22] = 2082;
      v209 = (uint64_t)v19;
      v21 = "%{public}s connection %p not in idle list, cannot remove, dumping backtrace:%{public}s";
      v22 = (os_log_s *)v14;
      v23 = v15;
      v24 = 32;
      goto LABEL_22;
    }

    uint64_t v17 = *(void *)(v3 + 592);
    uint64_t v18 = *(void **)(v3 + 600);
    if (v17)
    {
      *(void *)(v17 + 600) = v18;
      uint64_t v18 = *(void **)(v3 + 600);
    }

    else
    {
      *(void *)(v11 + 216) = v18;
    }

    v25 = (_WORD *)(v3 + 872);
    *uint64_t v18 = v17;
    *(void *)(v3 + 592) = 0LL;
    *(void *)(v3 + 600) = 0LL;
    v26 = *(_DWORD *)(v11 + 340);
    *(_DWORD *)(v11 + 340) = v26 - 1;
    if (v26)
    {
LABEL_52:
      v41 = (unsigned __int16)*v25;
      v42 = (v41 | (*(unsigned __int8 *)(v3 + 874) << 16)) & 0xFFF7FFFF;
      os_log_s *v25 = v41;
      *(_BYTE *)(v3 + 874) = BYTE2(v42);
      if ((*(_BYTE *)(v3 + 158) & 1) == 0)
      {
        if (*((_BYTE *)v12 + 1537))
        {
          v171 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
          {
            v172 = *(void *)(v3 + 488);
            v173 = *(_DWORD *)(*(void *)(v3 + 480) + 372LL);
            v174 = *(_DWORD *)(v3 + 860);
            if (v172) {
              LODWORD(v172) = *(_DWORD *)(v172 + 424);
            }
            v175 = *(_DWORD *)(v11 + 340);
            *(_DWORD *)buf = 136448002;
            *(void *)&buf[4] = "nw_http1_remove_idle_connection";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v3 + 74;
            *(_WORD *)&buf[22] = 2080;
            v209 = (uint64_t)" ";
            *(_WORD *)v210 = 1024;
            *(_DWORD *)&v210[2] = v173;
            *(_WORD *)&v210[6] = 1024;
            *(_DWORD *)&v210[8] = v174;
            *(_WORD *)&v210[12] = 1024;
            *(_DWORD *)&v210[14] = v172;
            *(_WORD *)&v210[18] = 2048;
            *(void *)&v210[20] = v3;
            v211 = 1024;
            LODWORD(v212) = v175;
            _os_log_impl( &dword_181A5C000,  v171,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed idle connection %p, now have %u idle connections",  buf,  0x42u);
          }
        }
      }

      if (*(void *)(v3 + 784))
      {
        if ((*(_BYTE *)(v3 + 158) & 1) == 0)
        {
          if (*((_BYTE *)v12 + 1537))
          {
            v183 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v183, OS_LOG_TYPE_DEBUG))
            {
              v184 = *(void *)(v3 + 488);
              v185 = *(_DWORD *)(*(void *)(v3 + 480) + 372LL);
              v186 = *(_DWORD *)(v3 + 860);
              if (v184) {
                LODWORD(v184) = *(_DWORD *)(v184 + 424);
              }
              *(_DWORD *)buf = 136447746;
              *(void *)&buf[4] = "nw_http1_remove_idle_connection";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v3 + 74;
              *(_WORD *)&buf[22] = 2080;
              v209 = (uint64_t)" ";
              *(_WORD *)v210 = 1024;
              *(_DWORD *)&v210[2] = v185;
              *(_WORD *)&v210[6] = 1024;
              *(_DWORD *)&v210[8] = v186;
              *(_WORD *)&v210[12] = 1024;
              *(_DWORD *)&v210[14] = v184;
              *(_WORD *)&v210[18] = 2048;
              *(void *)&v210[20] = v3;
              _os_log_impl( &dword_181A5C000,  v183,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> deactivating destroy timer for connection %p",  buf,  0x3Cu);
            }
          }
        }

        nw_queue_cancel_source(*(void *)(v3 + 784), a2);
        *(void *)(v3 + 784) = 0LL;
      }

      goto LABEL_58;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v27 = *(unsigned int *)(v11 + 340);
    *(_DWORD *)buf = 136446978;
    *(void *)&buf[4] = "nw_http1_remove_idle_connection";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "http1->idle_connections_count";
    *(_WORD *)&buf[22] = 2048;
    v209 = 1LL;
    *(_WORD *)v210 = 2048;
    *(void *)&v210[2] = v27;
    v28 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v213) = 0;
    if (__nwlog_fault(v28, &type, &v213))
    {
      if (type == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v29 = (os_log_s *)gLogObj;
        unint64_t v30 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type))
        {
          v31 = *(unsigned int *)(v11 + 340);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_http1_remove_idle_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->idle_connections_count";
          *(_WORD *)&buf[22] = 2048;
          v209 = 1LL;
          *(_WORD *)v210 = 2048;
          *(void *)&v210[2] = v31;
          uint64_t v32 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_48:
          _os_log_impl(&dword_181A5C000, v29, v30, v32, buf, 0x2Au);
        }
      }

      else if ((_BYTE)v213)
      {
        v33 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v29 = (os_log_s *)gLogObj;
        unint64_t v30 = type;
        v34 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type);
        if (v33)
        {
          if (v34)
          {
            v35 = *(unsigned int *)(v11 + 340);
            *(_DWORD *)buf = 136447234;
            *(void *)&buf[4] = "nw_http1_remove_idle_connection";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->idle_connections_count";
            *(_WORD *)&buf[22] = 2048;
            v209 = 1LL;
            *(_WORD *)v210 = 2048;
            *(void *)&v210[2] = v35;
            *(_WORD *)&v210[10] = 2082;
            *(void *)&v210[12] = v33;
            _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v33);
          uint64_t v12 = &qword_18C45F000;
          goto LABEL_49;
        }

        uint64_t v12 = &qword_18C45F000;
        if (v34)
        {
          v40 = *(unsigned int *)(v11 + 340);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_http1_remove_idle_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->idle_connections_count";
          *(_WORD *)&buf[22] = 2048;
          v209 = 1LL;
          *(_WORD *)v210 = 2048;
          *(void *)&v210[2] = v40;
          uint64_t v32 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v29 = (os_log_s *)gLogObj;
        unint64_t v30 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type))
        {
          v39 = *(unsigned int *)(v11 + 340);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_http1_remove_idle_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->idle_connections_count";
          *(_WORD *)&buf[22] = 2048;
          v209 = 1LL;
          *(_WORD *)v210 = 2048;
          *(void *)&v210[2] = v39;
          uint64_t v32 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }

        _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, v22, buf, 0xCu);
        goto LABEL_43;
      }

      -[os_log_s handleRequest:onConnection:]( WeakRetained,  "handleRequest:onConnection:",  v4,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
    }

        goto LABEL_43;
      }

      if (!v27)
      {
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null size, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_42;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v22 = type;
      v23 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_181A5C000, v13, v22, "%{public}s called with null size, no backtrace", buf, 0xCu);
        }

        goto LABEL_42;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_dns_cache_storage_canvas_serialize";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null size, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_30;
    }

    goto LABEL_43;
  }

  uint64_t v5 = v3;
  *((_BYTE *)v5 + 16) = 0;
  unsigned int v6 = nw_dns_cache_storage_canvas_memory_size(v5);
  *a2 = v6;
  if (!v6)
  {
    v8 = 0LL;
    goto LABEL_7;
  }

  unint64_t v7 = v6;
  v8 = malloc(v6);
  if (v8)
  {
LABEL_5:
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    unint64_t v30 = v8;
    unsigned int v9 = (unsigned __int8 *)*((void *)v5 + 1);
    v26[0] = MEMORY[0x1895F87A8];
    v26[1] = 3221225472LL;
    v26[2] = __nw_dns_cache_storage_canvas_serialize_block_invoke;
    v26[3] = &unk_189BC50D0;
    v26[4] = buf;
    nw_array_apply(v9, (uint64_t)v26);
    _Block_object_dispose(buf, 8);
LABEL_7:

LABEL_8:
    return (BOOL)v8;
  }

  __nwlog_obj();
  uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  *(void *)&buf[4] = "strict_malloc";
  *(_WORD *)&buf[12] = 2048;
  *(void *)&buf[14] = v7;
  uint64_t v18 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v18);
  if (!result)
  {
    free(v18);
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v30 = "-[NWConcrete_nw_srv_endpoint initWithName:]";
    int v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v13, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "-[NWConcrete_nw_srv_endpoint initWithName:]";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null _name", buf, 0xCu);
        }
      }

      else if (v26)
      {
        v21 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v22 = type;
        v23 = os_log_type_enabled(v14, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v30 = "-[NWConcrete_nw_srv_endpoint initWithName:]";
            v31 = 2082;
            uint64_t v32 = v21;
            _os_log_impl( &dword_181A5C000,  v14,  v22,  "%{public}s called with null _name, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v21);
          goto LABEL_47;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "-[NWConcrete_nw_srv_endpoint initWithName:]";
          _os_log_impl(&dword_181A5C000, v14, v22, "%{public}s called with null _name, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "-[NWConcrete_nw_srv_endpoint initWithName:]";
          _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s called with null _name, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_srv_name";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_srv_name";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_srv_name";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_srv_name";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_srv_name";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3[29];
LABEL_25:

  return v5;
}
  }

  v184[0] = v15;
  v184[1] = 0x40000000LL;
  v184[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_24;
  v184[3] = &unk_189BBF980;
  v184[4] = &v198;
  v184[5] = &v194;
  nw_http_fields_enumerate_const_field(v30, v184);
  if (a2)
  {
    v36 = (_BYTE *)v199[3];
    if (!v36)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v205 = "_http_safe_append";
      v38 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v178[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v39 = (os_log_s *)__nwlog_obj();
        v40 = type[0];
        if (!os_log_type_enabled(v39, type[0])) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446210;
        v205 = "_http_safe_append";
        v41 = "%{public}s called with null buffer";
        goto LABEL_395;
      }

      if (v178[0] == OS_LOG_TYPE_DEFAULT)
      {
        v39 = (os_log_s *)__nwlog_obj();
        v40 = type[0];
        if (!os_log_type_enabled(v39, type[0])) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446210;
        v205 = "_http_safe_append";
        v41 = "%{public}s called with null buffer, backtrace limit exceeded";
        goto LABEL_395;
      }

      v116 = (char *)__nw_create_backtrace_string();
      v39 = (os_log_s *)__nwlog_obj();
      v40 = type[0];
      v117 = os_log_type_enabled(v39, type[0]);
      if (!v116)
      {
        if (!v117) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446210;
        v205 = "_http_safe_append";
        v41 = "%{public}s called with null buffer, no backtrace";
        goto LABEL_395;
      }

      if (v117)
      {
        *(_DWORD *)buf = 136446466;
        v205 = "_http_safe_append";
        v206 = 2082;
        v207 = v116;
        _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s called with null buffer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v116);
      goto LABEL_396;
    }

    v37 = v195;
    if (!v195[3])
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v205 = "_http_safe_append";
      v38 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v178[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v39 = (os_log_s *)__nwlog_obj();
        v40 = type[0];
        if (!os_log_type_enabled(v39, type[0])) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446210;
        v205 = "_http_safe_append";
        v41 = "%{public}s called with null (*remaining >= length)";
        goto LABEL_395;
      }

      if (v178[0] == OS_LOG_TYPE_DEFAULT)
      {
        v39 = (os_log_s *)__nwlog_obj();
        v40 = type[0];
        if (!os_log_type_enabled(v39, type[0])) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446210;
        v205 = "_http_safe_append";
        v41 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
        goto LABEL_395;
      }

      v118 = (char *)__nw_create_backtrace_string();
      v39 = (os_log_s *)__nwlog_obj();
      v40 = type[0];
      v119 = os_log_type_enabled(v39, type[0]);
      if (v118)
      {
        if (v119)
        {
          *(_DWORD *)buf = 136446466;
          v205 = "_http_safe_append";
          v206 = 2082;
          v207 = v118;
          _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v118);
        if (!v38)
        {
LABEL_398:
          v199[3] = 0LL;
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v205 = "nw_http_fillout_binary_message_inner";
          v159 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v178[0] = OS_LOG_TYPE_DEFAULT;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v160 = (os_log_s *)__nwlog_obj();
            v161 = type[0];
            if (!os_log_type_enabled(v160, type[0])) {
              goto LABEL_525;
            }
            *(_DWORD *)buf = 136446210;
            v205 = "nw_http_fillout_binary_message_inner";
            v162 = "%{public}s called with null cursor";
            goto LABEL_524;
          }

          if (v178[0] == OS_LOG_TYPE_DEFAULT)
          {
            v160 = (os_log_s *)__nwlog_obj();
            v161 = type[0];
            if (!os_log_type_enabled(v160, type[0])) {
              goto LABEL_525;
            }
            *(_DWORD *)buf = 136446210;
            v205 = "nw_http_fillout_binary_message_inner";
            v162 = "%{public}s called with null cursor, backtrace limit exceeded";
            goto LABEL_524;
          }

          v163 = (char *)__nw_create_backtrace_string();
          v160 = (os_log_s *)__nwlog_obj();
          v161 = type[0];
          v164 = os_log_type_enabled(v160, type[0]);
          if (!v163)
          {
            if (!v164) {
              goto LABEL_525;
            }
            *(_DWORD *)buf = 136446210;
            v205 = "nw_http_fillout_binary_message_inner";
            v162 = "%{public}s called with null cursor, no backtrace";
            goto LABEL_524;
          }

          if (!v164) {
            goto LABEL_518;
          }
LABEL_517:
          *(_DWORD *)buf = 136446466;
          v205 = "nw_http_fillout_binary_message_inner";
          v206 = 2082;
          v207 = v163;
          _os_log_impl( &dword_181A5C000,  v160,  v161,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
LABEL_518:
          free(v163);
          if (v159) {
LABEL_526:
          }
            free(v159);
LABEL_527:
          v55 = 0LL;
          if (!v30) {
            goto LABEL_79;
          }
          goto LABEL_78;
        }

  free(v14);
  unsigned int v16 = 1LL;
LABEL_43:

  return v16;
}
}

    if (!v28) {
      goto LABEL_24;
    }
    v25 = (char *)v28;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v7 = (id)gLogObj;
    v8 = v3;
    unsigned int v9 = [v8 type];

    *(_DWORD *)buf = 136446466;
    v41 = "nw_endpoint_get_url_path";
    v42 = 1024;
    *(_DWORD *)v43 = v9;
    LODWORD(v35) = 18;
    unint64_t v10 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v10, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        uint64_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          int v13 = v8;
          uint64_t v14 = objc_msgSend(v13, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v41 = "nw_endpoint_get_url_path";
          v42 = 1024;
          *(_DWORD *)v43 = v14;
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v38)
      {
        uint64_t v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        unsigned int v16 = type;
        uint64_t v17 = os_log_type_enabled(v11, type);
        if (v15)
        {
          if (v17)
          {
            uint64_t v18 = v8;
            unint64_t v19 = objc_msgSend(v18, "type", buf, v35);

            *(_DWORD *)buf = 136446722;
            v41 = "nw_endpoint_get_url_path";
            v42 = 1024;
            *(_DWORD *)v43 = v19;
            v43[2] = 2082;
            *(void *)&v43[3] = v15;
            _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v15);
          if (!v10) {
            goto LABEL_24;
          }
LABEL_22:
          v25 = (char *)v10;
LABEL_23:
          free(v25);
          goto LABEL_24;
        }

        if (v17)
        {
          v23 = v8;
          v24 = objc_msgSend(v23, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v41 = "nw_endpoint_get_url_path";
          v42 = 1024;
          *(_DWORD *)v43 = v24;
          _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        uint64_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          v21 = v8;
          v22 = objc_msgSend(v21, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v41 = "nw_endpoint_get_url_path";
          v42 = 1024;
          *(_DWORD *)v43 = v22;
          _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v10)
    {
LABEL_24:
      unsigned int v6 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = v3;
  v36[0] = MEMORY[0x1895F87A8];
  v36[1] = 3221225472LL;
  v36[2] = __nw_endpoint_get_url_path_block_invoke;
  v36[3] = &unk_189BC93A0;
  v37 = v5;
  nw_endpoint_locked(v5, v36);
  unsigned int v6 = v5[34];

LABEL_25:
  return v6;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = v1;
  uint64_t v4 = -[nw_endpoint type](v3, "type");

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = -[nw_endpoint type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_url";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = -[nw_endpoint type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = -[nw_endpoint type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_url";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = -[nw_endpoint type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = -[nw_endpoint type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = (const char *)*((void *)v3 + 31);
LABEL_25:

  return v5;
}

    if (!v27) {
      goto LABEL_24;
    }
    v24 = (char *)v27;
    goto LABEL_23;
  }

  unsigned int v3 = (CFTypeRef *)v1;
  uint64_t v4 = -[CFTypeRef type](v3, "type");

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (id)gLogObj;
    unint64_t v7 = v3;
    v8 = -[CFTypeRef type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_copy_cfurl";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    unsigned int v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v12 = v7;
          int v13 = -[CFTypeRef type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_copy_cfurl";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v35)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        unsigned int v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            uint64_t v18 = -[CFTypeRef type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_copy_cfurl";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }

        if (v16)
        {
          v22 = v7;
          v23 = -[CFTypeRef type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_copy_cfurl";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          v21 = -[CFTypeRef type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_copy_cfurl";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0LL;
      goto LABEL_25;
    }

    goto LABEL_22;
  }

  uint64_t v5 = CFRetain(v3[29]);
LABEL_25:

  return v5;
}

    if (!v28) {
      goto LABEL_12;
    }
    uint64_t v15 = (char *)v28;
    goto LABEL_11;
  }

  unsigned int v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v7 = (id)gLogObj;
    v8 = v3;
    unsigned int v9 = [v8 type];

    *(_DWORD *)buf = 136446466;
    v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
    v40 = 1024;
    *(_DWORD *)v41 = v9;
    LODWORD(v35) = 18;
    unint64_t v10 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v10, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        uint64_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          int v13 = v8;
          uint64_t v14 = objc_msgSend(v13, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
          v40 = 1024;
          *(_DWORD *)v41 = v14;
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v36)
      {
        uint64_t v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        uint64_t v18 = type;
        unint64_t v19 = os_log_type_enabled(v11, type);
        if (v17)
        {
          if (v19)
          {
            uint64_t v20 = v8;
            v21 = objc_msgSend(v20, "type", buf, v35);

            *(_DWORD *)buf = 136446722;
            v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
            v40 = 1024;
            *(_DWORD *)v41 = v21;
            v41[2] = 2082;
            *(void *)&v41[3] = v17;
            _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v17);
          if (!v10) {
            goto LABEL_12;
          }
LABEL_10:
          uint64_t v15 = (char *)v10;
LABEL_11:
          free(v15);
          goto LABEL_12;
        }

        if (v19)
        {
          v25 = v8;
          v26 = objc_msgSend(v25, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
          v40 = 1024;
          *(_DWORD *)v41 = v26;
          _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v11, type))
        {
          v23 = v8;
          v24 = objc_msgSend(v23, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
          v40 = 1024;
          *(_DWORD *)v41 = v24;
          _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v10)
    {
LABEL_12:
      host_with_numeric_port = 0LL;
      goto LABEL_13;
    }

    goto LABEL_10;
  }

  uint64_t v5 = (const char **)v3;
  host_with_numeric_port = nw_endpoint_create_host_with_numeric_port( v5[33],  bswap32(*((unsigned __int16 *)v5 + 120)) >> 16);
  nw_endpoint_copy_properties(v5, (void *)host_with_numeric_port);

LABEL_13:
  return host_with_numeric_port;
}

    if (v12) {
      free(v12);
    }
    unsigned int v6 = 0LL;
    goto LABEL_7;
  }

  if (a3 <= 0x13)
  {
    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v30 = "nw_quic_stream_deserialize_options";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unsigned int v16 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "nw_quic_stream_deserialize_options";
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null (serialized_length >= sizeof(struct nw_protocol_quic_serialized_options))",  buf,  0xCu);
        }

    if (v13) {
      free(v13);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_interpose_cancel";
  unsigned int v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v9, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null interpose", buf, 0xCu);
      }
    }

    else if (v24)
    {
      unsigned int v16 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = type;
      uint64_t v18 = os_log_type_enabled(v10, type);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_interpose_cancel";
          v28 = 2082;
          int v29 = v16;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null interpose, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v16);
        goto LABEL_37;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_interpose_cancel";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_interpose_cancel";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null interpose, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  __break(1u);
}

  if (v13) {
    free(v13);
  }
  return 22LL;
}

  if (v14) {
    free(v14);
  }
  unint64_t v10 = 0LL;
LABEL_12:

  return v10;
}

      free(v9);
      goto LABEL_43;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v10 = (os_log_s *)(id)gLogObj;
      unint64_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_path_create";
        _os_log_impl(&dword_181A5C000, v10, v19, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }

        free(v10);
        goto LABEL_43;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        unsigned int v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_path_create_evaluator_for_group";
          _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
        }

LABEL_43:
      if (v9) {
        free(v9);
      }
      goto LABEL_7;
    }

    if (!LOBYTE(__s2[0]))
    {
      __nwlog_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v20 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null previous_path, backtrace limit exceeded",  __s1,  0xCu);
      }

      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v17 = type[0];
    uint64_t v18 = os_log_type_enabled(v10, type[0]);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)__s1 = 136446210;
        *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null previous_path, no backtrace", __s1, 0xCu);
      }

      goto LABEL_42;
    }

    if (v18)
    {
      *(_DWORD *)__s1 = 136446466;
      *(void *)&__s1[4] = "nw_path_signature_changed_from_previous";
      *(_WORD *)&__s1[12] = 2082;
      *(void *)&__s1[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null previous_path, dumping backtrace:%{public}s",  __s1,  0x16u);
    }

        goto LABEL_43;
      }

      if (!v27)
      {
        __nwlog_obj();
        unsigned int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null value, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_42;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_181A5C000, v16, v23, "%{public}s called with null value, no backtrace", buf, 0xCu);
        }

        goto LABEL_42;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
        v31 = 2082;
        uint64_t v32 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s called with null value, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_30;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v15, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unsigned int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null code", buf, 0xCu);
        }

        goto LABEL_42;
      }

      if (!v27)
      {
        __nwlog_obj();
        unsigned int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl( &dword_181A5C000,  v16,  v25,  "%{public}s called with null code, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_42;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_181A5C000, v16, v21, "%{public}s called with null code, no backtrace", buf, 0xCu);
        }

        goto LABEL_42;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v30 = "nw_path_flow_registration_get_ctl_command";
        v31 = 2082;
        uint64_t v32 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s called with null code, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    goto LABEL_43;
  }

  *(_DWORD *)type = 0;
  uint64_t v5 = v4->direct;
  if (v5) {
    unsigned int v6 = ne_session_service_matches_address_for_interface();
  }
  else {
    unsigned int v6 = 0LL;
  }

LABEL_46:
  return v6;
}

    if (v6) {
      free(v6);
    }
    return 0LL;
  }

  if (!v31 || v31 < address[0].sa_len)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    v33 = "nw_endpoint_create_with_peer_name";
    v34 = 1024;
    v35 = v31;
    v36 = 1024;
    LODWORD(v37[0]) = address[0].sa_len;
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    int v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v7 = (os_log_s *)(id)gLogObj;
      v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446722;
      v33 = "nw_endpoint_create_with_peer_name";
      v34 = 1024;
      v35 = v31;
      v36 = 1024;
      LODWORD(v37[0]) = address[0].sa_len;
      unsigned int v9 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u";
    }

    else
    {
      if (v29)
      {
        uint64_t v12 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v7 = (os_log_s *)(id)gLogObj;
        int v13 = type;
        uint64_t v14 = os_log_type_enabled(v7, type);
        if (v12)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446978;
            v33 = "nw_endpoint_create_with_peer_name";
            v34 = 1024;
            v35 = v31;
            v36 = 1024;
            LODWORD(v37[0]) = address[0].sa_len;
            WORD2(v37[0]) = 2082;
            *(void *)((char *)v37 + 6) = v12;
            uint64_t v15 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u, dumping backtrace:%{public}s";
            unsigned int v16 = v7;
            uint64_t v17 = v13;
            uint64_t v18 = 34;
LABEL_30:
            _os_log_impl(&dword_181A5C000, v16, v17, v15, buf, v18);
          }

  __break(1u);
  return result;
}

    goto LABEL_43;
  }

  if (v4)
  {
    unsigned int v6 = (id *)v3;
    unint64_t v7 = v6[1];

    if (nw_protocol_copy_http3_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_10_72547);
    }
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v7,  nw_protocol_copy_http3_definition_http3_definition);

    if (is_equal_unsafe)
    {
      v23[0] = MEMORY[0x1895F87A8];
      v23[1] = 3221225472LL;
      v23[2] = __nw_http3_set_application_error_callback_block_invoke;
      v23[3] = &unk_189BC6110;
      v24 = v4;
      nw_protocol_options_access_handle(v6, v23);
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  int v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_http3_set_application_error_callback";
  unint64_t v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_http3_set_application_error_callback";
      _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null callback", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (!v25)
  {
    __nwlog_obj();
    int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_http3_set_application_error_callback";
      _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s called with null callback, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_42;
  }

  uint64_t v18 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  unint64_t v19 = type;
  uint64_t v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_http3_set_application_error_callback";
      _os_log_impl(&dword_181A5C000, v11, v19, "%{public}s called with null callback, no backtrace", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    v28 = "nw_http3_set_application_error_callback";
    int v29 = 2082;
    unint64_t v30 = v18;
    _os_log_impl( &dword_181A5C000,  v11,  v19,  "%{public}s called with null callback, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_44;
  }
LABEL_9:
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

  if (v10) {
    free(v10);
  }
  unint64_t v7 = 0LL;
LABEL_9:

  return v7;
}

  if (v9) {
    free(v9);
  }
  unsigned int v6 = 0LL;
LABEL_9:

  return v6;
}

    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_43;
  }

  if (a2)
  {
    if (*(void *)(a1 + 64))
    {
      uint64_t v4 = a1 + 40;
      std::string::__assign_external( (std::string *)(a1 + 40),  *(const std::string::value_type **)(a1 + 24),  *(void *)(a1 + 32));
      uint64_t v5 = *(void (**)(void))(a1 + 64);
      if (v5)
      {
        *(void *)(a1 + 64) = 0LL;
        v5(*(void *)(a1 + 24));
      }

      if (*(char *)(a1 + 63) < 0)
      {
        uint64_t v4 = *(void *)(a1 + 40);
        unsigned int v6 = *(void *)(a1 + 48);
      }

      else
      {
        unsigned int v6 = *(unsigned __int8 *)(a1 + 63);
      }

      *(void *)(a1 + 24) = v4;
      *(void *)(a1 + 32) = v6;
    }

    unint64_t v7 = a1 + 40;
    std::string::append((std::string *)(a1 + 40), *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
    if (*(char *)(a1 + 63) < 0)
    {
      unint64_t v7 = *(void *)(a1 + 40);
      v8 = *(void *)(a1 + 48);
    }

    else
    {
      v8 = *(unsigned __int8 *)(a1 + 63);
    }

    *(void *)(a1 + 24) = v7;
    *(void *)(a1 + 32) = v8;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_string_append_string";
  unsigned int v9 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  uint64_t v17 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v10 = (os_log_s *)__nwlog_obj();
    int v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_string_append_string";
    uint64_t v12 = "%{public}s called with null string2";
    goto LABEL_42;
  }

  if (!v17)
  {
    unint64_t v10 = (os_log_s *)__nwlog_obj();
    int v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_string_append_string";
    uint64_t v12 = "%{public}s called with null string2, backtrace limit exceeded";
    goto LABEL_42;
  }

  uint64_t v15 = (char *)__nw_create_backtrace_string();
  unint64_t v10 = (os_log_s *)__nwlog_obj();
  int v11 = type;
  unsigned int v16 = os_log_type_enabled(v10, type);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_string_append_string";
    uint64_t v12 = "%{public}s called with null string2, no backtrace";
    goto LABEL_42;
  }

  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v20 = "nw_string_append_string";
    v21 = 2082;
    v22 = v15;
    _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null string2, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v9) {
    goto LABEL_44;
  }
}

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_43;
  }

  if (__s)
  {
    if (*(void *)(a1 + 64))
    {
      uint64_t v4 = a1 + 40;
      std::string::__assign_external( (std::string *)(a1 + 40),  *(const std::string::value_type **)(a1 + 24),  *(void *)(a1 + 32));
      uint64_t v5 = *(void (**)(void))(a1 + 64);
      if (v5)
      {
        *(void *)(a1 + 64) = 0LL;
        v5(*(void *)(a1 + 24));
      }

      if (*(char *)(a1 + 63) < 0)
      {
        uint64_t v4 = *(void *)(a1 + 40);
        unsigned int v6 = *(void *)(a1 + 48);
      }

      else
      {
        unsigned int v6 = *(unsigned __int8 *)(a1 + 63);
      }

      *(void *)(a1 + 24) = v4;
      *(void *)(a1 + 32) = v6;
    }

    unint64_t v7 = a1 + 40;
    v8 = strlen(__s);
    std::string::append((std::string *)(a1 + 40), __s, v8);
    if (*(char *)(a1 + 63) < 0)
    {
      unint64_t v7 = *(void *)(a1 + 40);
      unsigned int v9 = *(void *)(a1 + 48);
    }

    else
    {
      unsigned int v9 = *(unsigned __int8 *)(a1 + 63);
    }

    *(void *)(a1 + 24) = v7;
    *(void *)(a1 + 32) = v9;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_string_append_c_string";
  unint64_t v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  uint64_t v18 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v11 = (os_log_s *)__nwlog_obj();
    uint64_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    v21 = "nw_string_append_c_string";
    int v13 = "%{public}s called with null string2";
    goto LABEL_42;
  }

  if (!v18)
  {
    int v11 = (os_log_s *)__nwlog_obj();
    uint64_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    v21 = "nw_string_append_c_string";
    int v13 = "%{public}s called with null string2, backtrace limit exceeded";
    goto LABEL_42;
  }

  unsigned int v16 = (char *)__nw_create_backtrace_string();
  int v11 = (os_log_s *)__nwlog_obj();
  uint64_t v12 = type;
  uint64_t v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    v21 = "nw_string_append_c_string";
    int v13 = "%{public}s called with null string2, no backtrace";
    goto LABEL_42;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "nw_string_append_c_string";
    v22 = 2082;
    v23 = v16;
    _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null string2, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v10) {
    goto LABEL_44;
  }
}

      free(backtrace_string);
      goto LABEL_56;
    }

    if (!v26) {
      goto LABEL_56;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v30 = "nw_string_get_bytes";
    uint64_t v20 = "%{public}s called with null bytes_copied, no backtrace";
LABEL_55:
    _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
LABEL_56:
    if (v17) {
      free(v17);
    }
    return 0LL;
  }

  *a6 = 0LL;
  uint64_t v12 = *(void *)(a1 + 32);
  int v13 = v12 - a4;
  if (v12 < a4)
  {
    if (gLogDatapath)
    {
      v25 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        unint64_t v30 = "nw_string_get_bytes";
        v31 = 2082;
        uint64_t v32 = "bytes_left";
        v33 = 2048;
        v34 = a4;
        v35 = 2048;
        v36 = v13;
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
      }
    }

    int v13 = 0LL;
  }

  if (a5 >= v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = a5;
  }
  if (v14 >= a3) {
    uint64_t v15 = a3;
  }
  else {
    uint64_t v15 = v14;
  }
  *a6 = v15;
  if (v15)
  {
    memcpy(__dst, (const void *)(*(void *)(a1 + 24) + a4), v15);
    return *a6 != 0;
  }

  return 0LL;
}

    if (!v12) {
      return;
    }
    uint64_t v32 = (char *)v12;
    goto LABEL_44;
  }

  LOBYTE(__srca) = a2;
  uint64_t v17 = a1 + 17;
  uint64_t v18 = *(void *)(a1 + 8);
  unint64_t v19 = (void *)(a1 + 17 + v18);
  uint64_t v20 = v5 - v18;
  if (v5 - v18 >= a2) {
    v21 = a2;
  }
  else {
    v21 = v5 - v18;
  }
  memcpy(v19, __src, v21);
  v22 = *(void *)(a1 + 8) + v21;
  *(void *)(a1 + 8) = v22;
  if (v20 < a2)
  {
    v22 = a2 - v21;
    memcpy((void *)(a1 + 17), &__src[v21], a2 - v21);
    *(void *)(a1 + 8) = a2 - v21;
    *(_BYTE *)(a1 + 16) = 1;
  }

  v23 = *(void *)a1;
  memcpy((void *)(v17 + v22), &__srca, *(void *)a1 != v22);
  v24 = *(void *)(a1 + 8);
  if (v23 != v22) {
    ++v24;
  }
  *(void *)(a1 + 8) = v24;
  if (v23 == v22)
  {
    *(_BYTE *)(a1 + 17) = a2;
    *(void *)(a1 + 8) = 1LL;
    *(_BYTE *)(a1 + 16) = 1;
  }

    if (!v10)
    {
LABEL_44:
      unint64_t v7 = 0LL;
      goto LABEL_45;
    }

    goto LABEL_43;
  }

  unsigned int v3 = (unsigned int *)v1;
  uint64_t v4 = v3[29];

  if ((_DWORD)v4 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = (id)gLogObj;
    else {
      uint64_t v12 = off_189BBBBC0[v4];
    }
    *(_DWORD *)buf = 136446722;
    v34 = "nw_endpoint_handler_copy_channel";
    v35 = 2082;
    v36 = (void *)v12;
    v37 = 2082;
    v38 = "flow";
    int v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v13, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          else {
            unsigned int v16 = off_189BBBBC0[v4];
          }
          *(_DWORD *)buf = 136446722;
          v34 = "nw_endpoint_handler_copy_channel";
          v35 = 2082;
          v36 = (void *)v16;
          v37 = 2082;
          v38 = "flow";
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v31)
      {
        uint64_t v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (os_log_s *)(id)gLogObj;
        uint64_t v18 = type;
        unint64_t v19 = os_log_type_enabled(v14, type);
        if (v17)
        {
          if (v19)
          {
            else {
              uint64_t v20 = off_189BBBBC0[v4];
            }
            *(_DWORD *)buf = 136446978;
            v34 = "nw_endpoint_handler_copy_channel";
            v35 = 2082;
            v36 = (void *)v20;
            v37 = 2082;
            v38 = "flow";
            v39 = 2082;
            v40 = v17;
            _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v17);
          if (!v13) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }

        if (v19)
        {
          else {
            v23 = off_189BBBBC0[v4];
          }
          *(_DWORD *)buf = 136446722;
          v34 = "nw_endpoint_handler_copy_channel";
          v35 = 2082;
          v36 = (void *)v23;
          v37 = 2082;
          v38 = "flow";
          _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (os_log_s *)(id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          else {
            v22 = off_189BBBBC0[v4];
          }
          *(_DWORD *)buf = 136446722;
          v34 = "nw_endpoint_handler_copy_channel";
          v35 = 2082;
          v36 = (void *)v22;
          v37 = 2082;
          v38 = "flow";
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }

      goto LABEL_42;
    }

      goto LABEL_43;
    }

    goto LABEL_43;
  }

  if ((v11 & 0x20) == 0)
  {
    if (v7[79] != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v59 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
    {
      v60 = v10;

      v61 = v60;
      v62 = (*((_BYTE *)v4 + 268) & 1) == 0;

      if (v62) {
        v63 = "";
      }
      else {
        v63 = "dry-run ";
      }
      v64 = nw_endpoint_handler_copy_endpoint(v61);
      v65 = nw_endpoint_get_logging_description(v64);
      v66 = v61;
      v67 = v66;
      v68 = v4->state;
      else {
        v69 = off_189BBBBF0[v68];
      }
      v90 = v69;

      v71 = v67;
      v72 = "path";
      switch(v4->mode)
      {
        case 0:
          break;
        case 1:
          v72 = "resolver";
          break;
        case 2:
          v72 = nw_endpoint_flow_mode_string(v4->mode_handler);
          break;
        case 3:
          v72 = "proxy";
          break;
        case 4:
          v72 = "fallback";
          break;
        case 5:
          v72 = "transform";
          break;
        default:
          v72 = "unknown-mode";
          break;
      }

      v74 = v71;
      os_unfair_lock_lock(lock);
      v75 = v4->current_path;
      os_unfair_lock_unlock(lock);

      *(_DWORD *)buf = 136448002;
      v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
      v96 = 2082;
      v97 = id_str;
      v98 = 2082;
      v99 = v63;
      v100 = 2082;
      v101 = (void *)v65;
      v102 = 2082;
      v103 = v90;
      v104 = 2082;
      v105 = v72;
      v106 = 2114;
      v107 = v75;
      v108 = 2082;
      v109 = v8;
      _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Found listener protocol %{public}s",  buf,  0x52u);
    }
  }

  if (v8) {
    free(v8);
  }
}

    free(backtrace_string);
    goto LABEL_56;
  }

  int v11 = (os_log_s *)__nwlog_obj();
  uint64_t v12 = type;
  if (os_log_type_enabled(v11, type))
  {
    *(_DWORD *)buf = 136446210;
    v28 = "http2_create_input_frame";
    int v13 = "%{public}s called with null frame";
    goto LABEL_55;
  }

      if (v6) {
        goto LABEL_43;
      }
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v90)
      {
        uint64_t v15 = (char *)__nw_create_backtrace_string();
        unint64_t v7 = (os_log_s *)__nwlog_obj();
        v8 = type;
        v79 = os_log_type_enabled(v7, type);
        if (v15)
        {
          if (v79)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v94 = 2082;
            v95 = v15;
            uint64_t v17 = "%{public}s called with null http2, dumping backtrace:%{public}s";
            goto LABEL_19;
          }

          goto LABEL_20;
        }

        if (v79)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          unsigned int v9 = "%{public}s called with null http2, no backtrace";
          goto LABEL_41;
        }
      }

      else
      {
        unint64_t v7 = (os_log_s *)__nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          unsigned int v9 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_41;
        }
      }

      goto LABEL_42;
    }

    unint64_t v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    unsigned int v9 = "%{public}s called with null http2";
    goto LABEL_41;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v93 = "nw_protocol_http2_frame_input_finalizer";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v90 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    unsigned int v9 = "%{public}s called with null input_frame_context";
    goto LABEL_41;
  }

  if (!v90)
  {
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      unsigned int v9 = "%{public}s called with null input_frame_context, backtrace limit exceeded";
      goto LABEL_41;
    }

    goto LABEL_42;
  }

  uint64_t v15 = (char *)__nw_create_backtrace_string();
  unint64_t v7 = (os_log_s *)__nwlog_obj();
  v8 = type;
  v78 = os_log_type_enabled(v7, type);
  if (!v15)
  {
    if (v78)
    {
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      unsigned int v9 = "%{public}s called with null input_frame_context, no backtrace";
      goto LABEL_41;
    }

    goto LABEL_42;
  }

  if (v78)
  {
    *(_DWORD *)buf = 136446466;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v94 = 2082;
    v95 = v15;
    uint64_t v17 = "%{public}s called with null input_frame_context, dumping backtrace:%{public}s";
    goto LABEL_19;
  }

    if (v3) {
      goto LABEL_43;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v111 = "nw_protocol_http2_frame_output_finalizer";
  unsigned int v3 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(type) = 16;
  LOBYTE(v108) = 0;
  if (type == 17)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, (os_log_type_t)type)) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    unsigned int v6 = "%{public}s called with null output_metadata";
    goto LABEL_41;
  }

  if (!(_BYTE)v108)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (os_log_type_enabled(v4, (os_log_type_t)type))
    {
      *(_DWORD *)buf = 136446210;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      unsigned int v6 = "%{public}s called with null output_metadata, backtrace limit exceeded";
      goto LABEL_41;
    }

    goto LABEL_42;
  }

  uint64_t v14 = (char *)__nw_create_backtrace_string();
  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  v96 = os_log_type_enabled(v4, (os_log_type_t)type);
  if (!v14)
  {
    if (v96)
    {
      *(_DWORD *)buf = 136446210;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      unsigned int v6 = "%{public}s called with null output_metadata, no backtrace";
      goto LABEL_41;
    }

    goto LABEL_42;
  }

  if (v96)
  {
    *(_DWORD *)buf = 136446466;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    v112 = 2082;
    *(void *)v113 = v14;
    unsigned int v16 = "%{public}s called with null output_metadata, dumping backtrace:%{public}s";
    goto LABEL_16;
  }

    v43 = &v34[a5];
    if (v10 != __dst) {
      memmove(v43, __dst, v10 - __dst);
    }
    v44 = *(char **)a1;
    *(void *)a1 = v35;
    *(void *)(a1 + 8) = &v43[v10 - __dst];
    *(void *)(a1 + 16) = v33 + v16;
    if (v44) {
      operator delete(v44);
    }
    return;
  }

  uint64_t v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    uint64_t v18 = &__src[a5];
    uint64_t v20 = *(char **)(a1 + 8);
LABEL_17:
    v21 = &__dst[a5];
    v22 = &v20[-a5];
    v23 = v20;
    if (&v20[-a5] < v10)
    {
      v24 = &v10[a5] - v20;
      v25 = v24 >= 0x20 && (unint64_t)a5 > 0x1F;
      v26 = &v20[-a5];
      v23 = v20;
      if (!v25) {
        goto LABEL_50;
      }
      v27 = v24 & 0xFFFFFFFFFFFFFFE0LL;
      v26 = &v22[v24 & 0xFFFFFFFFFFFFFFE0LL];
      v28 = (__int128 *)(v22 + 16);
      int v29 = v20 + 16;
      unint64_t v30 = v24 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v31 = *v28;
        *(v29 - 1) = *(v28 - 1);
        *int v29 = v31;
        v28 += 2;
        v29 += 2;
        v30 -= 32LL;
      }

      while (v30);
      v23 = &v20[v27];
      if (v24 != v27)
      {
LABEL_50:
        do
        {
          uint64_t v32 = *v26++;
          *v23++ = v32;
        }

        while (v26 != v10);
      }
    }

    *(void *)(a1 + 8) = v23;
    if (v20 != v21) {
      memmove(&__dst[a5], __dst, v20 - v21);
    }
    if (v18 != __src) {
      memmove(__dst, __src, v18 - __src);
    }
    return;
  }

  uint64_t v18 = &__src[v17];
  unint64_t v19 = a4 - &__src[v17];
  if (a4 != &__src[v17]) {
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  }
  uint64_t v20 = &v10[v19];
  *(void *)(a1 + 8) = &v10[v19];
  if (v17 >= 1) {
    goto LABEL_17;
  }
}

      goto LABEL_43;
    }

    __nwlog_obj();
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)label = 136446210;
    *(void *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
    v56 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v56, buf, &type) & 1) != 0)
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v58 = buf[0];
        if (os_log_type_enabled(v57, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)label = 136446210;
          *(void *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
          _os_log_impl(&dword_181A5C000, v57, v58, "%{public}s [super init] failed", (uint8_t *)label, 0xCu);
        }
      }

      else
      {
        if (type)
        {
          v63 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v65 = buf[0];
          v66 = os_log_type_enabled(v64, (os_log_type_t)buf[0]);
          if (v63)
          {
            if (v66)
            {
              *(_DWORD *)label = 136446466;
              *(void *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              *(_WORD *)&label[12] = 2082;
              *(void *)&label[14] = v63;
              _os_log_impl( &dword_181A5C000,  v64,  v65,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  (uint8_t *)label,  0x16u);
            }

            free(v63);
          }

          else
          {
            if (v66)
            {
              *(_DWORD *)label = 136446210;
              *(void *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              _os_log_impl( &dword_181A5C000,  v64,  v65,  "%{public}s [super init] failed, no backtrace",  (uint8_t *)label,  0xCu);
            }
          }

          goto LABEL_107;
        }

        __nwlog_obj();
        v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v68 = buf[0];
        if (os_log_type_enabled(v57, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)label = 136446210;
          *(void *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
          _os_log_impl( &dword_181A5C000,  v57,  v68,  "%{public}s [super init] failed, backtrace limit exceeded",  (uint8_t *)label,  0xCu);
        }
      }
    }

    goto LABEL_43;
  }

  if (v8)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    v53 = __Block_byref_object_copy__102_87709;
    v54 = __Block_byref_object_dispose__103_87710;
    v55 = 0LL;
    v48 = 0LL;
    v49 = &v48;
    v50 = 0x2020000000LL;
    v51 = 0LL;
    *(void *)type = 0LL;
    v43 = type;
    v44 = 0x3032000000LL;
    v45 = __Block_byref_object_copy__87670;
    v46 = __Block_byref_object_dispose__87671;
    v47 = 0LL;
    v40[0] = 0LL;
    v40[1] = v40;
    v40[2] = 0x3032000000LL;
    v40[3] = __Block_byref_object_copy__87670;
    v40[4] = __Block_byref_object_dispose__87671;
    v41 = 0LL;
    unint64_t v10 = MEMORY[0x1895F87A8];
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL59nw_masque_server_call_proxy_client_connection_event_handlerP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject41nw_masque_proxy_client_connection_event_tU13block_pointerFvvE_block_invoke;
    aBlock[3] = &unk_189BC94B8;
    v34 = v7;
    v36 = buf;
    v37 = &v48;
    v35 = v8;
    v38 = type;
    v39 = v40;
    int v11 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v7 + 4);
    v11[2](v11);
    os_unfair_lock_unlock(v7 + 4);

    if (v49[3] && *(void *)(*(void *)&buf[8] + 40LL))
    {
      uint64_t v12 = (dispatch_queue_s *)*((void *)v43 + 5);
      block[0] = v10;
      block[1] = 3221225472LL;
      block[2] = ___ZL59nw_masque_server_call_proxy_client_connection_event_handlerP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject41nw_masque_proxy_client_connection_event_tU13block_pointerFvvE_block_invoke_2;
      block[3] = &unk_189BC94E0;
      int v29 = buf;
      unint64_t v30 = &v48;
      uint64_t v32 = a3;
      v28 = v9;
      v31 = v40;
      dispatch_async(v12, block);
    }

    else if (v9)
    {
      v9[2](v9);
    }

    _Block_object_dispose(v40, 8);
    _Block_object_dispose(type, 8);

    _Block_object_dispose(&v48, 8);
    _Block_object_dispose(buf, 8);

    goto LABEL_9;
  }

  __nwlog_obj();
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_masque_server_call_proxy_client_connection_event_handler";
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v40[0]) = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type[0];
    if (os_log_type_enabled(v15, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_masque_server_call_proxy_client_connection_event_handler";
      _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null connection_group", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (!LOBYTE(v40[0]))
  {
    __nwlog_obj();
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v26 = type[0];
    if (os_log_type_enabled(v15, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_masque_server_call_proxy_client_connection_event_handler";
      _os_log_impl( &dword_181A5C000,  v15,  v26,  "%{public}s called with null connection_group, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_42;
  }

  v22 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v23 = type[0];
  v24 = os_log_type_enabled(v15, type[0]);
  if (!v22)
  {
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_masque_server_call_proxy_client_connection_event_handler";
      _os_log_impl(&dword_181A5C000, v15, v23, "%{public}s called with null connection_group, no backtrace", buf, 0xCu);
    }

    goto LABEL_42;
  }

  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&buf[4] = "nw_masque_server_call_proxy_client_connection_event_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v22;
    _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s called with null connection_group, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v22);
  if (v14) {
    goto LABEL_44;
  }
LABEL_9:
}

void nw_mem_region_free(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 360)
     + 16
     * (((a2 >> *(void *)(a1 + 344)) + a2 + (a2 >> (2 * *(void *)(a1 + 344)))) & *(void *)(a1 + 352));
  unint64_t v7 = *(void **)v6;
  do
  {
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      v31 = "nw_mem_region_free";
      __int16 v32 = 2082;
      *(void *)v33 = "VERIFY sg != NULL failed";
      unint64_t v10 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort((uint64_t)v10))
      {
        free(v10);
        nw_segment_freelist_insert((void *)a1, 0LL, 0);
        uint64_t v8 = 0LL;
        goto LABEL_10;
      }

LABEL_35:
      __break(1u);
      return;
    }

    uint64_t v8 = (uint64_t)v7;
    unint64_t v7 = (void *)*v7;
  }

  while (*(void *)(v8 + 24) != a2);
  unsigned int v9 = *(void **)(v8 + 8);
  if (v7)
  {
    v7[1] = v9;
    unsigned int v9 = *(void **)(v8 + 8);
  }

  else
  {
    *(void *)(v6 + 8) = v9;
  }

  *unsigned int v9 = v7;
  nw_segment_freelist_insert((void *)a1, v8, 0);
LABEL_10:
  int64x2_t v11 = *(int64x2_t *)(a1 + 8);
  v12.i64[0] = -1LL;
  v12.i64[1] = -1LL;
  v13.i64[1] = -1LL;
  v13.i64[0] = *(void *)(a1 + 88);
  v13.i64[0] = vsubq_s64(v11, v13).u64[0];
  v13.i64[1] = vaddq_s64(v11, v12).i64[1];
  *(int64x2_t *)(a1 + 8) = v13;
  ++*(void *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_region_lock);
  unint64_t v14 = g_total_memory_usage - *(void *)(a1 + 88);
  g_total_memory_usage = v14;
  if (g_process_transaction)
  {
    if (v14 <= 0x8000)
    {
      os_release((void *)g_process_transaction);
      g_process_transaction = 0LL;
      g_transaction_touched = 0;
      if (gLogDatapath)
      {
        v26 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_mem_region_free";
          _os_log_impl(&dword_181A5C000, v26, OS_LOG_TYPE_DEBUG, "%{public}s os transaction disabled", buf, 0xCu);
        }
      }
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_region_lock);
  if (gLogDatapath)
  {
    v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v31 = "nw_mem_region_free";
      __int16 v32 = 2048;
      *(void *)v33 = a1;
      *(_WORD *)&v33[8] = 2048;
      *(void *)&v33[10] = v8;
      _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s nwr %p sg %p", buf, 0x20u);
    }
  }

  uint64_t v15 = *(void *)(a1 + 392);
  if (v15)
  {
    if ((*(_DWORD *)(v15 + 240) & 0x80000000) != 0)
    {
      if (gLogDatapath)
      {
        v27 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          int v28 = *(_DWORD *)(v8 + 40);
          unint64_t v29 = *(void *)(a1 + 88) + a2;
          *(_DWORD *)buf = 136447234;
          v31 = "nw_mem_region_free";
          __int16 v32 = 1024;
          *(_DWORD *)v33 = v28;
          *(_WORD *)&v33[4] = 2048;
          *(void *)&v33[6] = v8;
          *(_WORD *)&v33[14] = 2048;
          *(void *)&v33[16] = a2;
          __int16 v34 = 2048;
          unint64_t v35 = v29;
          unint64_t v19 = "%{public}s   [%u] sg %p [%p-%p) mirrored";
          uint64_t v20 = v27;
          uint32_t v21 = 48;
LABEL_34:
          _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_DEBUG, v19, buf, v21);
        }
      }
    }

    else if (gLogDatapath)
    {
LABEL_19:
      unsigned int v16 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        int v17 = *(_DWORD *)(v8 + 40);
        unint64_t v18 = *(void *)(a1 + 88) + a2;
        *(_DWORD *)buf = 136446978;
        v31 = "nw_mem_region_free";
        __int16 v32 = 1024;
        *(_DWORD *)v33 = v17;
        *(_WORD *)&v33[4] = 2048;
        *(void *)&v33[6] = a2;
        *(_WORD *)&v33[14] = 2048;
        *(void *)&v33[16] = v18;
        unint64_t v19 = "%{public}s   [%u] [%p-%p)";
        uint64_t v20 = v16;
        uint32_t v21 = 38;
        goto LABEL_34;
      }
    }
  }

  else if (gLogDatapath)
  {
    goto LABEL_19;
  }

  uint64_t v22 = *(void *)(a1 + 392);
  if (v22) {
    nw_mem_region_free(v22, a3, 0LL);
  }
  if (*(_DWORD *)(a1 + 384))
  {
    v24 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v31 = "nw_mem_region_free";
    __int16 v32 = 2082;
    *(void *)v33 = "VERIFY nwr->nwr_seg_waiters == 0 failed";
    v25 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v25))
    {
      free(v25);
      return;
    }

    goto LABEL_35;
  }

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v6(v3, a2);
LABEL_5:
}

    goto LABEL_36;
  }

  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int64x2_t v12 = (os_log_s *)(id)gLogObj;
    unint64_t v19 = type;
    if (os_log_type_enabled(v12, type))
    {
      else {
        uint64_t v20 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_read_close_handler";
      __int16 v32 = 2082;
      v33 = (void *)v20;
      __int16 v34 = 2082;
      unint64_t v35 = "flow";
      _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  uint64_t v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int64x2_t v12 = (os_log_s *)(id)gLogObj;
  unsigned int v16 = type;
  int v17 = os_log_type_enabled(v12, type);
  if (!v15)
  {
    if (v17)
    {
      else {
        uint32_t v21 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_read_close_handler";
      __int16 v32 = 2082;
      v33 = (void *)v21;
      __int16 v34 = 2082;
      unint64_t v35 = "flow";
      _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  if (v17)
  {
    else {
      unint64_t v18 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    v31 = "nw_endpoint_handler_set_read_close_handler";
    __int16 v32 = 2082;
    v33 = (void *)v18;
    __int16 v34 = 2082;
    unint64_t v35 = "flow";
    uint64_t v36 = 2082;
    v37 = v15;
    _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v15);
  if (v11) {
    goto LABEL_37;
  }
LABEL_38:
}

    goto LABEL_36;
  }

  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int64x2_t v12 = (os_log_s *)(id)gLogObj;
    unint64_t v19 = type;
    if (os_log_type_enabled(v12, type))
    {
      else {
        uint64_t v20 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_write_close_handler";
      __int16 v32 = 2082;
      v33 = (void *)v20;
      __int16 v34 = 2082;
      unint64_t v35 = "flow";
      _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  uint64_t v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int64x2_t v12 = (os_log_s *)(id)gLogObj;
  unsigned int v16 = type;
  int v17 = os_log_type_enabled(v12, type);
  if (!v15)
  {
    if (v17)
    {
      else {
        uint32_t v21 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_write_close_handler";
      __int16 v32 = 2082;
      v33 = (void *)v21;
      __int16 v34 = 2082;
      unint64_t v35 = "flow";
      _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  if (v17)
  {
    else {
      unint64_t v18 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    v31 = "nw_endpoint_handler_set_write_close_handler";
    __int16 v32 = 2082;
    v33 = (void *)v18;
    __int16 v34 = 2082;
    unint64_t v35 = "flow";
    uint64_t v36 = 2082;
    v37 = v15;
    _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v15);
  if (v11) {
    goto LABEL_37;
  }
LABEL_38:
}

  if (v9) {
    free(v9);
  }
LABEL_18:
}

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_36;
  }

  if (*(void *)(a1 + 16))
  {
    pointer = (void *)xpc_dictionary_get_pointer();
    if (a3)
    {
      os_retain(a3);
      xpc_dictionary_set_pointer();
    }

    else
    {
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 16), a2, 0LL);
    }

    os_release(pointer);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v18 = "nw_dictionary_set_value";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  uint64_t v15 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_dictionary_set_value";
    unint64_t v10 = "%{public}s called with null dictionary->xpc_object";
    goto LABEL_35;
  }

  if (!v15)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_dictionary_set_value";
    unint64_t v10 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v13 = (char *)__nw_create_backtrace_string();
  uint64_t v8 = (os_log_s *)__nwlog_obj();
  unsigned int v9 = type;
  unint64_t v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_dictionary_set_value";
    unint64_t v10 = "%{public}s called with null dictionary->xpc_object, no backtrace";
    goto LABEL_35;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v18 = "nw_dictionary_set_value";
    unint64_t v19 = 2082;
    uint64_t v20 = v13;
    _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v13);
  if (v7) {
LABEL_37:
  }
    free(v7);
}

    if (v20) {
      free(v20);
    }
    unint64_t v7 = 0;
    goto LABEL_18;
  }

  if ((*((_BYTE *)v1 + 475) & 8) == 0)
  {
    unsigned int v3 = nw_path_copy_connected_interface(v1);
    uint64_t v4 = v3;
    if (v3)
    {
      uint64_t v5 = v3;
      uint64_t v6 = *(_WORD *)(v5 + 85);

      if ((v6 & 1) != 0) {
        goto LABEL_16;
      }
    }

    if (*((_DWORD *)v2 + 94) != 1)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *((_DWORD *)v2 + 95);
      if (v8 == 4 || v8 == 30) {
        goto LABEL_17;
      }
    }

    unsigned int v9 = (void *)*((void *)v2 + 12);
    if (v9)
    {
      unint64_t v10 = v9;
      int64x2_t v11 = *(_WORD *)(v10 + 85);

      if ((v11 & 1) != 0) {
        goto LABEL_16;
      }
    }

    int64x2_t v12 = (void *)*((void *)v2 + 13);
    if (v12)
    {
      int64x2_t v13 = v12;
      unint64_t v14 = *(_WORD *)(v13 + 85);

      if ((v14 & 1) != 0) {
        goto LABEL_16;
      }
    }

    uint64_t v15 = (void *)*((void *)v2 + 14);
    if (v15 && (unsigned int v16 = v15, v17 = *(_WORD *)(v16 + 85), v16, (v17 & 1) != 0)) {
LABEL_16:
    }
      unint64_t v7 = 1;
    else {
      unint64_t v7 = 0;
    }
LABEL_17:

    goto LABEL_18;
  }

  unint64_t v7 = 1;
LABEL_18:

  return v7;
}

    if (v20) {
      free(v20);
    }
    unint64_t v7 = 0;
    goto LABEL_18;
  }

  if ((*((_BYTE *)v1 + 475) & 0x10) == 0)
  {
    unsigned int v3 = nw_path_copy_connected_interface(v1);
    uint64_t v4 = v3;
    if (v3)
    {
      uint64_t v5 = v3;
      uint64_t v6 = *(_WORD *)(v5 + 85);

      if ((v6 & 2) != 0) {
        goto LABEL_16;
      }
    }

    if (*((_DWORD *)v2 + 94) != 1)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *((_DWORD *)v2 + 95);
      if (v8 == 4 || v8 == 30) {
        goto LABEL_17;
      }
    }

    unsigned int v9 = (void *)*((void *)v2 + 12);
    if (v9)
    {
      unint64_t v10 = v9;
      int64x2_t v11 = *(_WORD *)(v10 + 85);

      if ((v11 & 2) != 0) {
        goto LABEL_16;
      }
    }

    int64x2_t v12 = (void *)*((void *)v2 + 13);
    if (v12)
    {
      int64x2_t v13 = v12;
      unint64_t v14 = *(_WORD *)(v13 + 85);

      if ((v14 & 2) != 0) {
        goto LABEL_16;
      }
    }

    uint64_t v15 = (void *)*((void *)v2 + 14);
    if (v15 && (unsigned int v16 = v15, v17 = *(_WORD *)(v16 + 85), v16, (v17 & 2) != 0)) {
LABEL_16:
    }
      unint64_t v7 = 1;
    else {
      unint64_t v7 = 0;
    }
LABEL_17:

    goto LABEL_18;
  }

  unint64_t v7 = 1;
LABEL_18:

  return v7;
}

  if (v22) {
    free(v22);
  }
  unint64_t v10 = 0LL;
LABEL_18:

  return v10;
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v38 = (id)gLogObj;
  if (mode > 5) {
    v39 = "unknown-mode";
  }
  else {
    v39 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_transform_add_children";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = v39;
  *(_WORD *)&buf[22] = 2082;
  v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
  v40 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v67) = 0;
  if (!__nwlog_fault((const char *)v40, type, &v67))
  {
LABEL_54:
    if (!v40) {
      goto LABEL_56;
    }
LABEL_55:
    free(v40);
    goto LABEL_56;
  }

  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v41 = (os_log_s *)(id)gLogObj;
    v42 = type[0];
    if (os_log_type_enabled(v41, type[0]))
    {
      if (mode > 5) {
        v43 = "unknown-mode";
      }
      else {
        v43 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_transform_add_children";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v43;
      *(_WORD *)&buf[22] = 2082;
      v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
      _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

    free(backtrace_string);
    goto LABEL_48;
  }

  if (!(v3[5] | v3[6] | v3[7] | v3[8]))
  {
LABEL_50:
    uint64_t v8 = 0LL;
    goto LABEL_51;
  }

  uint64_t v8 = v3[5] != *a2 || v3[6] != a2[1] || v3[7] != a2[2] || v3[8] != a2[3];
LABEL_51:

  return v8;
}

    if (v23) {
      free(v23);
    }
    mode = 0;
    goto LABEL_38;
  }

  mode = v3->mode;

  if (mode == 2)
  {
    uint64_t v6 = v4;
    unint64_t v7 = v6->parameters;

    uint64_t v8 = nw_parameters_copy_context(v7);
    nw_context_assert_queue(v8);

    unsigned int v9 = nw_endpoint_handler_copy_flow(v6);
    unint64_t v10 = (void *)*((void *)v9 + 51);
    if (v10)
    {
      int64x2_t v11 = v10[3];
      if (v11)
      {
        int64x2_t v12 = *(uint64_t (**)(void))(v11 + 224);
        if (v12)
        {
          int64x2_t v13 = (void *)v10[5];
          if (v13 == &nw_protocol_ref_counted_handle)
          {
            unint64_t v18 = v10[11];
            if (v18) {
              v10[11] = v18 + 1;
            }
            unint64_t v14 = -1;
          }

          else
          {
            unint64_t v14 = 0;
          }

          *(void *)buf = v10;
          buf[8] = v14;
          unint64_t v19 = v12();
          if (v13 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
          }
          os_unfair_lock_lock((os_unfair_lock_t)v9 + 220);
          uint64_t v20 = 1048LL;
          if (a2) {
            uint64_t v20 = 1056LL;
          }
          uint32_t v21 = *(void **)((char *)v9 + v20);
          *(void *)((char *)v9 + v20) = v19;

          os_unfair_lock_unlock((os_unfair_lock_t)v9 + 220);
        }
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        unsigned int v16 = v6;
        id_str = v16->id_str;

        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_update_connected_metadata";
        __int16 v34 = 2082;
        unint64_t v35 = id_str;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s] could not find valid output protocol",  buf,  0x16u);
      }
    }

    goto LABEL_43;
  }

    goto LABEL_36;
  }

  if (!v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v9 = (os_log_s *)(id)gLogObj;
    unsigned int v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      else {
        int v17 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      int v28 = "nw_endpoint_handler_service_writes";
      unint64_t v29 = 2082;
      unint64_t v30 = (void *)v17;
      v31 = 2082;
      __int16 v32 = "flow";
      _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  int64x2_t v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v9 = (os_log_s *)(id)gLogObj;
  int64x2_t v13 = type;
  unint64_t v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      else {
        unint64_t v18 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      int v28 = "nw_endpoint_handler_service_writes";
      unint64_t v29 = 2082;
      unint64_t v30 = (void *)v18;
      v31 = 2082;
      __int16 v32 = "flow";
      _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  if (v14)
  {
    else {
      uint64_t v15 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    int v28 = "nw_endpoint_handler_service_writes";
    unint64_t v29 = 2082;
    unint64_t v30 = (void *)v15;
    v31 = 2082;
    __int16 v32 = "flow";
    v33 = 2082;
    __int16 v34 = v12;
    _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v12);
  if (v8) {
    goto LABEL_37;
  }
LABEL_38:
}

    goto LABEL_36;
  }

  if (!v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v9 = (os_log_s *)(id)gLogObj;
    unsigned int v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      else {
        int v17 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      int v28 = "nw_endpoint_handler_service_reads";
      unint64_t v29 = 2082;
      unint64_t v30 = (void *)v17;
      v31 = 2082;
      __int16 v32 = "flow";
      _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  int64x2_t v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v9 = (os_log_s *)(id)gLogObj;
  int64x2_t v13 = type;
  unint64_t v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      else {
        unint64_t v18 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      int v28 = "nw_endpoint_handler_service_reads";
      unint64_t v29 = 2082;
      unint64_t v30 = (void *)v18;
      v31 = 2082;
      __int16 v32 = "flow";
      _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  if (v14)
  {
    else {
      uint64_t v15 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    int v28 = "nw_endpoint_handler_service_reads";
    unint64_t v29 = 2082;
    unint64_t v30 = (void *)v15;
    v31 = 2082;
    __int16 v32 = "flow";
    v33 = 2082;
    __int16 v34 = v12;
    _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v12);
  if (v8) {
    goto LABEL_37;
  }
LABEL_38:
}

  if (v12) {
    free(v12);
  }
  uint64_t v8 = 0LL;
LABEL_5:

  return v8;
}

  if (v23) {
    free(v23);
  }
  uint64_t v20 = 0LL;
LABEL_18:

  return v20;
}

    LODWORD(v5) = 0;
    goto LABEL_36;
  }

  if (result != 45)
  {
    if (!v5) {
      goto LABEL_32;
    }
    unint64_t v10 = result - 48;
    if (v5 != 1)
    {
      unint64_t v10 = (result >> 8) - 48 + 10 * v10;
      unint64_t v14 = v5 - 2;
      if (v5 != 2)
      {
        uint64_t v15 = (unsigned __int8 *)v20 + 2;
        while (1)
        {
          unsigned int v16 = *v15 - 48;
          if (v16 > 9) {
            goto LABEL_32;
          }
          unint64_t v10 = (10 * v10) + v16;
          if (((v10 >> 8) & 1) != 0) {
            goto LABEL_32;
          }
          LODWORD(v5) = 0;
          ++v15;
          if (!--v14) {
            goto LABEL_36;
          }
        }
      }
    }

    goto LABEL_35;
  }

  if (v5)
  {
    if (v5 != 1)
    {
      if ((BYTE1(result) - 48) <= 9u)
      {
        LOBYTE(v10) = 0;
        if ((-(BYTE1(result) - 48) & 0xFFFFFF00) != 0)
        {
LABEL_33:
          LODWORD(v5) = 1;
          goto LABEL_36;
        }

        if (v5 == 2)
        {
          LODWORD(v5) = 0;
          LOBYTE(v10) = 48 - BYTE1(result);
          goto LABEL_36;
        }

        if ((BYTE2(result) - 48) <= 9u && ((10 * (48 - BYTE1(result))) & 0xF00) == 0)
        {
          unint64_t v10 = (10 * (48 - BYTE1(result))) - (BYTE2(result) - 48);
          if ((v10 & 0xFFFFFF00) == 0)
          {
            int v17 = v5 - 3;
            if (v5 != 3)
            {
              unint64_t v18 = (unsigned __int8 *)v20 + 3;
              while (1)
              {
                unint64_t v19 = *v18 - 48;
                if (v19 > 9) {
                  goto LABEL_32;
                }
                unint64_t v10 = (10 * v10) - v19;
                if ((v10 & 0xFFFFFF00) != 0) {
                  goto LABEL_32;
                }
                LODWORD(v5) = 0;
                ++v18;
                if (!--v17) {
                  goto LABEL_36;
                }
              }
            }

            goto LABEL_35;
          }
        }
      }

    LODWORD(v5) = 0;
    goto LABEL_36;
  }

  if (result != 45)
  {
    if (!v5) {
      goto LABEL_32;
    }
    unint64_t v10 = (result - 48);
    if (v10 > 9) {
      goto LABEL_32;
    }
    if (v5 != 1)
    {
      LOWORD(v10) = 10 * v10 + (BYTE1(result) - 48);
      unint64_t v14 = v5 - 2;
      if (v5 != 2)
      {
        uint64_t v15 = (unsigned __int8 *)v20 + 2;
        while (1)
        {
          unsigned int v16 = *v15 - 48;
          if (v16 > 9) {
            goto LABEL_32;
          }
          unint64_t v10 = (unsigned __int16)(10 * v10) + v16;
          if ((v10 & 0x10000) != 0) {
            goto LABEL_32;
          }
          LODWORD(v5) = 0;
          ++v15;
          if (!--v14) {
            goto LABEL_36;
          }
        }
      }
    }

    goto LABEL_35;
  }

  if (v5)
  {
    if (v5 != 1)
    {
      if ((BYTE1(result) - 48) <= 9u)
      {
        LOWORD(v10) = 0;
        if ((-(BYTE1(result) - 48) & 0xFFFF0000) != 0)
        {
LABEL_33:
          LODWORD(v5) = 1;
          goto LABEL_36;
        }

        if (v5 == 2)
        {
          LODWORD(v5) = 0;
          LOWORD(v10) = -(BYTE1(result) - 48);
          goto LABEL_36;
        }

        if ((BYTE2(result) - 48) <= 9u
          && ((10 * (unsigned __int16)-(BYTE1(result) - 48)) & 0xF0000) == 0)
        {
          unint64_t v10 = (unsigned __int16)(-10 * (BYTE1(result) - 48)) - (BYTE2(result) - 48);
          if ((v10 & 0xFFFF0000) == 0)
          {
            int v17 = v5 - 3;
            if (v5 != 3)
            {
              unint64_t v18 = (unsigned __int8 *)v20 + 3;
              while (1)
              {
                unint64_t v19 = *v18 - 48;
                if (v19 > 9) {
                  goto LABEL_32;
                }
                unint64_t v10 = (unsigned __int16)(10 * v10) - v19;
                if ((v10 & 0xFFFF0000) != 0) {
                  goto LABEL_32;
                }
                LODWORD(v5) = 0;
                ++v18;
                if (!--v17) {
                  goto LABEL_36;
                }
              }
            }

            goto LABEL_35;
          }
        }
      }

  __break(1u);
  result = swift_bridgeObjectRelease();
  __break(1u);
  return result;
}

    *(_OWORD *)v46 = *(_OWORD *)v47;
    goto LABEL_36;
  }

  if (!v49)
  {
    swift_release();
    goto LABEL_35;
  }

  v50 = *(void *)(v47 + 8);
  *v46 = v49;
  v46[1] = v50;
  swift_retain();
  swift_release();
LABEL_36:
  *(void *)(a1 + a3[6]) = *(void *)(a2 + a3[6]);
  v52 = a3[7];
  v53 = *(void **)(a1 + v52);
  v54 = *(void **)(a2 + v52);
  *(void *)(a1 + v52) = v54;
  v55 = v54;

  *(void *)(a1 + a3[8]) = *(void *)(a2 + a3[8]);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + a3[9]) = *(_BYTE *)(a2 + a3[9]);
  *(_BYTE *)(a1 + a3[10]) = *(_BYTE *)(a2 + a3[10]);
  *(void *)(a1 + a3[11]) = *(void *)(a2 + a3[11]);
  swift_retain();
  swift_release();
  return a1;
}

    *(_OWORD *)v26 = *(_OWORD *)v27;
    goto LABEL_36;
  }

  if (v28 < 0xFFFFFFFF)
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    goto LABEL_35;
  }

  os_log_s *v26 = v28;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v26[1] = v27[1];
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
LABEL_36:
  unint64_t v29 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unint64_t v30 = *(unsigned __int8 *)(v29 + 80);
  v31 = (((((v9 & v10 | 7) + v22) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF8LL) + v30 + 16;
  __int16 v32 = ((unint64_t)a1 + v31) & ~v30;
  v33 = ((unint64_t)v4 + v31) & ~v30;
  (*(void (**)(unint64_t, unint64_t))(v29 + 24))(v32, v33);
  __int16 v34 = *(void *)(v29 + 64) + 7LL;
  unint64_t v35 = (void *)((v34 + v32) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v36 = (void *)((v34 + v33) & 0xFFFFFFFFFFFFFFF8LL);
  *unint64_t v35 = *v36;
  v35[1] = v36[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v37 = (void *)(((unint64_t)v35 + 23) & 0xFFFFFFFFFFFFFFF8LL);
  v38 = (void *)(((unint64_t)v36 + 23) & 0xFFFFFFFFFFFFFFF8LL);
  *v37 = *v38;
  v37[1] = v38[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v39 = (void *)(((unint64_t)v37 + 23) & 0xFFFFFFFFFFFFFFF8LL);
  v40 = (void *)(((unint64_t)v38 + 23) & 0xFFFFFFFFFFFFFFF8LL);
  *v39 = *v40;
  v39[1] = v40[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

      uint64_t v15 = sub_18264EB20();
      int v17 = v16;
      goto LABEL_38;
    }
  }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_36;
  }

  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      unsigned int v3 = *(_DWORD *)(a1 + 180);
      if (!v3) {
        unsigned int v3 = 4000;
      }
      uint64_t v4 = a3[1] & 0xFFFFFFF8 | 1;
      *a3 = v3;
      a3[1] = v4;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v16 = "nw_protocol_udp_get_message_properties";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  int64x2_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_udp_get_message_properties";
    uint64_t v8 = "%{public}s called with null udp";
    goto LABEL_35;
  }

  if (!v13)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_udp_get_message_properties";
    uint64_t v8 = "%{public}s called with null udp, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v11 = (char *)__nw_create_backtrace_string();
  uint64_t v6 = (os_log_s *)__nwlog_obj();
  unint64_t v7 = type;
  int64x2_t v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_udp_get_message_properties";
    uint64_t v8 = "%{public}s called with null udp, no backtrace";
    goto LABEL_35;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    unsigned int v16 = "nw_protocol_udp_get_message_properties";
    int v17 = 2082;
    unint64_t v18 = v11;
    _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null udp, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v11);
  if (v5) {
    goto LABEL_37;
  }
}

      goto LABEL_36;
    }

    if (!v38)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = (os_log_s *)(id)gLogObj;
      v23 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_browse_result_remove_interface";
        _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s browse_result was marked immutable, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v17 = (os_log_s *)(id)gLogObj;
    uint64_t v20 = type;
    uint32_t v21 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_browse_result_remove_interface";
        _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s browse_result was marked immutable, no backtrace",  buf,  0xCu);
      }

      goto LABEL_35;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_browse_result_remove_interface";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s browse_result was marked immutable, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_48;
  }

  if ((*((_BYTE *)v3 + 52) & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int64x2_t v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_browse_result_insert_interface";
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, "%{public}s browse_result was marked immutable", buf, 0xCu);
    }

LABEL_14:
    unint64_t v10 = 0LL;
    goto LABEL_15;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v3 + 12);
  uint64_t v6 = (void *)*((void *)v3 + 4);
  if (v6)
  {
    free(v6);
    *((void *)v3 + 4) = 0LL;
  }

  unint64_t v7 = (void *)*((void *)v3 + 5);
  if (v7)
  {
    free(v7);
    *((void *)v3 + 5) = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 12);
  uint64_t v8 = (unsigned __int8 *)*((void *)v3 + 2);
  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 3221225472LL;
  v26[2] = __nw_browse_result_insert_interface_block_invoke;
  v26[3] = &unk_189BC85B0;
  unsigned int v9 = v5;
  v27 = v9;
  unint64_t v10 = nw_array_apply(v8, (uint64_t)v26);
  if (v10) {
    nw_array_append(*((void *)v3 + 2), v9);
  }

LABEL_15:
  return v10;
}

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_36;
  }

  if (!a1->handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_protocol_shoes_connect";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    unint64_t v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_protocol_shoes_connect";
      unsigned int v9 = "%{public}s called with null shoes";
      goto LABEL_35;
    }

    if (!v14)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_protocol_shoes_connect";
      unsigned int v9 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_35;
    }

    int64x2_t v12 = (char *)__nw_create_backtrace_string();
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    int64x2_t v13 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v13) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_protocol_shoes_connect";
      unsigned int v9 = "%{public}s called with null shoes, no backtrace";
      goto LABEL_35;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      int v17 = "nw_protocol_shoes_connect";
      unint64_t v18 = 2082;
      unint64_t v19 = v12;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null shoes, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v12);
LABEL_36:
    if (!v6) {
      return 0LL;
    }
LABEL_37:
    free(v6);
    return 0LL;
  }

  output_handler = a1->output_handler;
  if (!output_handler) {
    return 1LL;
  }
  callbacks = output_handler->callbacks;
  if (callbacks)
  {
    connect = (uint64_t (*)(void))callbacks->connect;
    if (connect) {
      return connect();
    }
  }

  return 0LL;
}

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_36;
  }

  unsigned int v3 = *((void *)this + 5);
  if (v3)
  {
    uint64_t v4 = *(_BYTE *)(v3 + 456);
    if ((v4 & 1) != 0)
    {
      uint64_t v5 = *(void **)(v3 + 448);
      if (v5)
      {
        os_release(v5);
        uint64_t v4 = *(_BYTE *)(v3 + 456);
      }
    }

    *(void *)(v3 + 448) = 0LL;
    *(_BYTE *)(v3 + 456) = v4 | 1;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v17 = "operator()";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  unint64_t v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "operator()";
    unsigned int v9 = "%{public}s called with null http_sniffing";
    goto LABEL_35;
  }

  if (!v14)
  {
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "operator()";
    unsigned int v9 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v12 = (char *)__nw_create_backtrace_string();
  unint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  int64x2_t v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "operator()";
    unsigned int v9 = "%{public}s called with null http_sniffing, no backtrace";
    goto LABEL_35;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    int v17 = "operator()";
    unint64_t v18 = 2082;
    unint64_t v19 = v12;
    _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null http_sniffing, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v12);
  if (v6) {
    goto LABEL_37;
  }
}

    free(v22);
    if (!v12) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v9(v6, v5);
LABEL_5:

  *extra = 0LL;
  return 1LL;
}

    free(v22);
    if (!v12) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v30[0] = MEMORY[0x1895F87A8];
  v30[1] = 3221225472LL;
  v30[2] = __nw_context_set_input_byte_cap_block_invoke;
  v30[3] = &unk_189BC1490;
  v31 = v7;
  __int16 v34 = a2;
  __int16 v32 = v8;
  v33 = v10;
  nw_queue_context_async_if_needed(v31, v30);

LABEL_5:
}

  free(backtrace_string);
  if (v4) {
LABEL_60:
  }
    free(v4);
}

  if (gLogDatapath)
  {
    __nwlog_obj();
    v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
    {
      v41 = "server";
      unint64_t v19 = (*(_WORD *)(a1 + 225) & 4) == 0;
      v52 = "nw_ws_write_header";
      *(_DWORD *)buf = 136446978;
      if (v19) {
        v41 = "client";
      }
      v53 = 2082;
      v54 = (char *)(a1 + 227);
      v55 = 2082;
      *(void *)v56 = v41;
      *(_WORD *)&v56[8] = 1024;
      *(_DWORD *)v57 = *(_DWORD *)v49;
      _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s %{public}s output masking_key = %u",  buf,  0x26u);
    }
  }

  v26 = *(unsigned int *)v49;
LABEL_43:

  return v26;
}
  }

  v27 = v31;
LABEL_37:

  uint32_t v21 = v23;
LABEL_38:

LABEL_39:
LABEL_40:

LABEL_41:
LABEL_42:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v6 = _Block_copy(v4);
  unint64_t v7 = (void *)*((void *)v3 + 50);
  *((void *)v3 + 50) = v6;

LABEL_5:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v6 = _Block_copy(v4);
  unint64_t v7 = (void *)*((void *)v3 + 51);
  *((void *)v3 + 51) = v6;

LABEL_5:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v6 = _Block_copy(v4);
  unint64_t v7 = (void *)*((void *)v3 + 52);
  *((void *)v3 + 52) = v6;

LABEL_5:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v6 = _Block_copy(v4);
  unint64_t v7 = (void *)*((void *)v3 + 53);
  *((void *)v3 + 53) = v6;

LABEL_5:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v6 = _Block_copy(v4);
  unint64_t v7 = (void *)*((void *)v3 + 54);
  *((void *)v3 + 54) = v6;

LABEL_5:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v6 = _Block_copy(v4);
  unint64_t v7 = (void *)*((void *)v3 + 55);
  *((void *)v3 + 55) = v6;

LABEL_5:
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_queue_context_async(v6, v5);
LABEL_5:
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_5:

  return (nw_protocol_options_t)v5;
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 3221225472LL;
  v26[2] = __nw_framer_options_set_object_value_block_invoke;
  v26[3] = &unk_189BC64E8;
  int v28 = key;
  v27 = v6;
  nw_protocol_options_access_handle(v5, v26);

LABEL_5:
}

  if (v9) {
    free(v9);
  }
  unsigned int v3 = 0LL;
LABEL_3:

  if (!nw_protocol_definition_is_framer(v3))
  {
    uint64_t v6 = 0LL;
    goto LABEL_8;
  }

  uint64_t v4 = v3;
  uint64_t v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int64x2_t v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_definition_get_options_allocator";
    int64x2_t v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v14 = (os_log_s *)(id)gLogObj;
        uint64_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_protocol_definition_get_options_allocator";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null definition", buf, 0xCu);
        }
      }

      else if (v24)
      {
        unint64_t v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v14 = (os_log_s *)(id)gLogObj;
        uint64_t v20 = type;
        uint32_t v21 = os_log_type_enabled(v14, type);
        if (v19)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_protocol_definition_get_options_allocator";
            int v28 = 2082;
            unint64_t v29 = v19;
            _os_log_impl( &dword_181A5C000,  v14,  v20,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v19);
          goto LABEL_44;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_protocol_definition_get_options_allocator";
          _os_log_impl(&dword_181A5C000, v14, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v14 = (os_log_s *)(id)gLogObj;
        v23 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_protocol_definition_get_options_allocator";
          _os_log_impl( &dword_181A5C000,  v14,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(backtrace_string);
    if (!v8) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  unint64_t v30 = __Block_byref_object_copy__4444;
  v31 = __Block_byref_object_dispose__4445;
  __int16 v32 = 0LL;
  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 3221225472LL;
  v26[2] = __nw_framer_options_copy_object_value_block_invoke;
  v26[3] = &unk_189BC6510;
  v26[4] = buf;
  v26[5] = key;
  nw_protocol_options_access_handle(v4, v26);
  uint64_t v5 = *(id *)(*(void *)&buf[8] + 40LL);
  _Block_object_dispose(buf, 8);

LABEL_5:
  return v5;
}

    free(v16);
    if (!v6) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3221225472LL;
  v24[2] = __nw_framer_options_set_peer_protocol_definition_block_invoke;
  v24[3] = &unk_189BC6260;
  v25 = v4;
  nw_protocol_options_access_handle(v3, v24);

LABEL_5:
}

    goto LABEL_36;
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL))
  {
LABEL_46:
    uint64_t v5 = 1LL;
    goto LABEL_47;
  }

  uint64_t v5 = 0LL;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
LABEL_47:

  return v5;
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v6 = xpc_data_create(a2, a3);
  unint64_t v7 = (void *)v5[24];
  v5[24] = v6;

LABEL_5:
}

    free(v20);
    if (!v10) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v28[0] = MEMORY[0x1895F87A8];
  v28[1] = 3221225472LL;
  v28[2] = __nw_connection_access_establishment_report_block_invoke;
  v28[3] = &unk_189BC50A8;
  unint64_t v29 = v5;
  unint64_t v30 = v6;
  v31 = v8;
  nw_connection_async_if_needed(v29, v28);

LABEL_5:
}

      goto LABEL_36;
    }

    if (!v17)
    {
      __nwlog_obj();
      unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
        int64x2_t v11 = "%{public}s called with null ending_path_report, backtrace limit exceeded";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v10 = type;
    unint64_t v14 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
        int64x2_t v11 = "%{public}s called with null ending_path_report, no backtrace";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
      uint32_t v21 = 2082;
      uint64_t v22 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null ending_path_report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_36:
    if (!v8) {
      return;
    }
    goto LABEL_37;
  }

  unsigned int v3 = path_report_for_interface_locked;
  nw_data_transfer_update_path_report_end( (nw_data_transfer_path_report *)path_report_for_interface_locked,  *(nw_data_transfer_snapshot **)(a1 + 48));
  uint64_t v4 = *(void **)(a1 + 40);
  if (!v4)
  {
    uint64_t v6 = *(nw_data_transfer_snapshot **)(a1 + 48);
    uint64_t v5 = v3;
    goto LABEL_6;
  }

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 32LL), v4);
  uint64_t v5 = nw_data_transfer_report_get_path_report_for_interface_locked(*(void **)(a1 + 32), *(void **)(a1 + 40), 1);
  if (v5)
  {
    uint64_t v6 = *(nw_data_transfer_snapshot **)(a1 + 48);
LABEL_6:
    nw_data_transfer_update_path_report_begin((nw_data_transfer_path_report *)v5, v6);
    return;
  }

  __nwlog_obj();
  int64x2_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  int v17 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
      int64x2_t v11 = "%{public}s called with null beginning_path_report";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  if (!v17)
  {
    __nwlog_obj();
    unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
      int64x2_t v11 = "%{public}s called with null beginning_path_report, backtrace limit exceeded";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  uint64_t v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  unint64_t v10 = type;
  unsigned int v16 = os_log_type_enabled(v9, type);
  if (!v15)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
      int64x2_t v11 = "%{public}s called with null beginning_path_report, no backtrace";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
    uint32_t v21 = 2082;
    uint64_t v22 = v15;
    _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null beginning_path_report, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v8) {
LABEL_37:
  }
    free(v8);
}

  if (v9) {
    free(v9);
  }
LABEL_18:
}

  if (v19) {
    free(v19);
  }
LABEL_18:
}

          free(v22);
          goto LABEL_36;
        }
      }
    }

    goto LABEL_17;
  }

  unsigned int v9 = (nw_endpoint *)nw_content_context_copy_remote_endpoint(v5);
  if (!v9)
  {
    unint64_t v10 = nw_connection_group_copy_connection_for_message(v3, v5);
    if (!v10)
    {
LABEL_7:
      unsigned int v9 = 0LL;

      goto LABEL_37;
    }

          free(v23);
          goto LABEL_42;
        }

        if (v45)
        {
          v49 = *v5;
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
          *(_WORD *)&applier[12] = 2112;
          *(void *)&applier[14] = v49;
          *(_WORD *)&applier[22] = 1024;
          *(_DWORD *)&applier[24] = v20;
          _os_log_impl( &dword_181A5C000,  v24,  v44,  "%{public}s sendto failed for %@ %{darwin.errno}d, no backtrace",  applier,  0x1Cu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        v47 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          v48 = *v5;
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
          *(_WORD *)&applier[12] = 2112;
          *(void *)&applier[14] = v48;
          *(_WORD *)&applier[22] = 1024;
          *(_DWORD *)&applier[24] = v20;
          _os_log_impl( &dword_181A5C000,  v24,  v47,  "%{public}s sendto failed for %@ %{darwin.errno}d, backtrace limit exceeded",  applier,  0x1Cu);
        }
      }
    }

    if (!v23) {
      goto LABEL_42;
    }
    goto LABEL_35;
  }

  if (v11 != *(void *)(a1 + 80))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 40) + 56LL)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      v27 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        int v28 = *(_DWORD *)(*(void *)(a1 + 40) + 168LL);
        unint64_t v29 = *(void *)(a1 + 80);
        *(_DWORD *)applier = 136446978;
        *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
        *(_WORD *)&applier[12] = 1024;
        *(_DWORD *)&applier[14] = v28;
        *(_WORD *)&applier[18] = 2048;
        *(void *)&applier[20] = v12;
        *(_WORD *)&applier[28] = 2048;
        *(void *)&applier[30] = v29;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] Failed to send entire packet, sent %zu bytes of %zu",  applier,  0x26u);
      }
    }

    goto LABEL_42;
  }

  int64x2_t v13 = 1;
  if (v3) {
LABEL_43:
  }
    free(v3);
LABEL_44:
  unint64_t v30 = nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 40) + 56LL));
  if (v13)
  {
    if (v30) {
      return;
    }
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    v31 = (os_log_s *)(id)gconnection_groupLogObj;
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_60;
    }
    __int16 v32 = *(_DWORD *)(*(void *)(a1 + 40) + 168LL);
    v33 = *(void *)(a1 + 56);
    identifier = nw_content_context_get_identifier(*(nw_content_context_t *)(a1 + 64));
    size = *(dispatch_data_s **)(a1 + 32);
    if (size) {
      size = (dispatch_data_s *)dispatch_data_get_size(size);
    }
    *(_DWORD *)applier = 136447234;
    *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
    *(_WORD *)&applier[12] = 1024;
    *(_DWORD *)&applier[14] = v32;
    *(_WORD *)&applier[18] = 2048;
    *(void *)&applier[20] = v33;
    *(_WORD *)&applier[28] = 2080;
    *(void *)&applier[30] = identifier;
    *(_WORD *)&applier[38] = 2048;
    *(void *)&applier[40] = size;
    uint64_t v36 = "%{public}s [G%u] sent reply to context %p: (context: %s, content: %zu bytes)";
    v37 = v31;
    v38 = OS_LOG_TYPE_DEBUG;
    goto LABEL_59;
  }

  if (v30) {
    return;
  }
  if (__nwlog_connection_group_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
  }
  v31 = (os_log_s *)(id)gconnection_groupLogObj;
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    v39 = *(_DWORD *)(*(void *)(a1 + 40) + 168LL);
    v40 = *(void *)(a1 + 56);
    v41 = nw_content_context_get_identifier(*(nw_content_context_t *)(a1 + 64));
    v42 = *(dispatch_data_s **)(a1 + 32);
    if (v42) {
      v42 = (dispatch_data_s *)dispatch_data_get_size(v42);
    }
    *(_DWORD *)applier = 136447234;
    *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
    *(_WORD *)&applier[12] = 1024;
    *(_DWORD *)&applier[14] = v39;
    *(_WORD *)&applier[18] = 2048;
    *(void *)&applier[20] = v40;
    *(_WORD *)&applier[28] = 2080;
    *(void *)&applier[30] = v41;
    *(_WORD *)&applier[38] = 2048;
    *(void *)&applier[40] = v42;
    uint64_t v36 = "%{public}s [G%u] context %p failed to send reply (context: %s, content: %zu bytes)";
    v37 = v31;
    v38 = OS_LOG_TYPE_ERROR;
LABEL_59:
    _os_log_impl(&dword_181A5C000, v37, v38, v36, applier, 0x30u);
  }

          if (!v22)
          {
LABEL_37:
            unsigned int v9 = 0LL;
            goto LABEL_38;
          }

    free(v17);
    if (!v7) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_queue_context_async(v5, v4);
LABEL_5:
}

    free(v17);
    if (!v7) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_queue_context_async_if_needed(v5, v4);
LABEL_5:
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_protocol_definition_initialize_common_state(v5);
  v6->common_state->var0 = a2;
  v6->common_state->var2 = a3;
LABEL_5:
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_protocol_definition_initialize_common_state(v5);
  v6->common_state->var1 = a2;
  v6->common_state->var2 = a3;
LABEL_5:
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_protocol_definition_initialize_extended_state(v5);
  v6->extended_state->var0 = a2;
  v6->extended_state->var1 = a3;
LABEL_5:
}

    free(v20);
    if (!v10) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  *((_BYTE *)v7 + 185) = *((_BYTE *)v7 + 185) & 0xFE | a2;
  *((void *)v7 + 16) = a3;
  *((void *)v7 + 17) = a4;
LABEL_5:
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  *((void *)v5 + 18) = a2;
  *((void *)v5 + 19) = a3;
LABEL_5:
}

    free(v21);
    if (!v11) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_protocol_definition_initialize_extended_state(v7);
  extended_state = v8->extended_state;
  extended_state->var33 = a2;
  extended_state->var29 = a3;
  v8->extended_state->var30 = a4;
LABEL_5:
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  *((void *)v5 + 21) = a2;
  *((void *)v5 + 22) = a3;
LABEL_5:
}

    free(v20);
    if (!v10) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_protocol_definition_initialize_common_state(v7);
  v8->common_state->var3 = a2;
  v8->common_state->var4 = a3;
  v8->common_state->var5 = a4;
LABEL_5:
}

            unint64_t v29 = (void *)a1[4];
            if (!v29) {
              goto LABEL_186;
            }
            unint64_t v30 = v29[3];
            if (!v30) {
              goto LABEL_186;
            }
            v31 = *(uint64_t (**)(void))(v30 + 224);
            if (!v31) {
              goto LABEL_186;
            }
            __int16 v32 = (void *)v29[5];
            if (v32 == &nw_protocol_ref_counted_handle)
            {
              v45 = v29[11];
              if (v45) {
                v29[11] = v45 + 1;
              }
              v33 = -1;
            }

            else
            {
              v33 = 0;
            }

            *(void *)type = v29;
            v98 = v33;
            if (a2)
            {
              uint64_t v36 = v31();
              if (v32 != &nw_protocol_ref_counted_handle) {
                goto LABEL_187;
              }
LABEL_79:
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              goto LABEL_187;
            }

            v94 = v32;
            __nwlog_obj();
            v84 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
            v85 = (char *)_os_log_send_and_compose_impl();

            v96 = OS_LOG_TYPE_ERROR;
            v95 = 0;
            if (__nwlog_fault(v85, &v96, &v95))
            {
              if (v96 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v87 = v96;
                if (os_log_type_enabled(v86, v96))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
                  _os_log_impl(&dword_181A5C000, v86, v87, "%{public}s called with null type", buf, 0xCu);
                }

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_protocol_definition_initialize_extended_state(v5);
  v6->extended_state->var10 = a2;
  v6->extended_state->var11 = a3;
LABEL_5:
}

        _Block_object_dispose(buf, 8);
        if ((v69 & 1) != 0 && v68) {
          os_release(v68);
        }
        goto LABEL_38;
      }

      __nwlog_obj();
      *(_DWORD *)type = 136446210;
      *(void *)&type[4] = "nw_http_authentication_apply_cache";
      __int16 v34 = (char *)_os_log_send_and_compose_impl();
      v52[0] = OS_LOG_TYPE_ERROR;
      v59 = 0;
      if (__nwlog_fault(v34, v52, &v59))
      {
        if (v52[0] == OS_LOG_TYPE_FAULT)
        {
          unint64_t v35 = (os_log_s *)__nwlog_obj();
          uint64_t v36 = v52[0];
          if (!os_log_type_enabled(v35, v52[0])) {
            goto LABEL_148;
          }
          *(_DWORD *)type = 136446210;
          *(void *)&type[4] = "nw_http_authentication_apply_cache";
          v37 = "%{public}s called with null request";
          goto LABEL_147;
        }

        if (!v59)
        {
          unint64_t v35 = (os_log_s *)__nwlog_obj();
          uint64_t v36 = v52[0];
          if (!os_log_type_enabled(v35, v52[0])) {
            goto LABEL_148;
          }
          *(_DWORD *)type = 136446210;
          *(void *)&type[4] = "nw_http_authentication_apply_cache";
          v37 = "%{public}s called with null request, backtrace limit exceeded";
          goto LABEL_147;
        }

        v50 = (char *)__nw_create_backtrace_string();
        unint64_t v35 = (os_log_s *)__nwlog_obj();
        uint64_t v36 = v52[0];
        v51 = os_log_type_enabled(v35, v52[0]);
        if (v50)
        {
          if (v51)
          {
            *(_DWORD *)type = 136446466;
            *(void *)&type[4] = "nw_http_authentication_apply_cache";
            *(_WORD *)&type[12] = 2082;
            *(void *)&type[14] = v50;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null request, dumping backtrace:%{public}s",  type,  0x16u);
          }

          free(v50);
          goto LABEL_148;
        }

        if (v51)
        {
          *(_DWORD *)type = 136446210;
          *(void *)&type[4] = "nw_http_authentication_apply_cache";
          v37 = "%{public}s called with null request, no backtrace";
LABEL_147:
          _os_log_impl(&dword_181A5C000, v35, v36, v37, type, 0xCu);
        }
      }

  if (v12) {
    free(v12);
  }
  unsigned int v9 = 0LL;
LABEL_18:

  return v9;
}

    free(backtrace_string);
    goto LABEL_49;
  }

  unsigned int v9 = (os_log_s *)__nwlog_obj();
  unint64_t v10 = v22;
  if (os_log_type_enabled(v9, v22))
  {
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http_cookie_remove_input_handler";
    int64x2_t v11 = "%{public}s called with null input_protocol";
    goto LABEL_48;
  }

    if (v8) {
      free(v8);
    }
    mode = 0;
    goto LABEL_38;
  }

  mode = v3->mode;

  if (mode != 2)
  {
LABEL_38:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = (id)gLogObj;
    if (mode > 5) {
      v23 = "unknown-mode";
    }
    else {
      v23 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    v40 = "nw_flow_replay_send_initial_data_to_candidates";
    v41 = 2082;
    v42 = (void *)v23;
    v43 = 2082;
    v44 = "flow";
    int64x2_t v12 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v12, &type, &v37))
    {
LABEL_70:
      if (!v12) {
        goto LABEL_72;
      }
LABEL_71:
      free(v12);
      goto LABEL_72;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int64x2_t v13 = (os_log_s *)(id)gLogObj;
      v24 = type;
      if (os_log_type_enabled(v13, type))
      {
        if (mode > 5) {
          v25 = "unknown-mode";
        }
        else {
          v25 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        v40 = "nw_flow_replay_send_initial_data_to_candidates";
        v41 = 2082;
        v42 = (void *)v25;
        v43 = 2082;
        v44 = "flow";
        _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }

      goto LABEL_69;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int64x2_t v13 = (os_log_s *)(id)gLogObj;
      unint64_t v30 = type;
      if (os_log_type_enabled(v13, type))
      {
        if (mode > 5) {
          v31 = "unknown-mode";
        }
        else {
          v31 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        v40 = "nw_flow_replay_send_initial_data_to_candidates";
        v41 = 2082;
        v42 = (void *)v31;
        v43 = 2082;
        v44 = "flow";
        _os_log_impl( &dword_181A5C000,  v13,  v30,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }

      goto LABEL_69;
    }

    v26 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int64x2_t v13 = (os_log_s *)(id)gLogObj;
    v27 = type;
    int v28 = os_log_type_enabled(v13, type);
    if (!v26)
    {
      if (v28)
      {
        if (mode > 5) {
          __int16 v32 = "unknown-mode";
        }
        else {
          __int16 v32 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        v40 = "nw_flow_replay_send_initial_data_to_candidates";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2082;
        v44 = "flow";
        _os_log_impl( &dword_181A5C000,  v13,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }

      goto LABEL_69;
    }

    if (v28)
    {
      if (mode > 5) {
        unint64_t v29 = "unknown-mode";
      }
      else {
        unint64_t v29 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446978;
      v40 = "nw_flow_replay_send_initial_data_to_candidates";
      v41 = 2082;
      v42 = (void *)v29;
      v43 = 2082;
      v44 = "flow";
      v45 = 2082;
      v46 = v26;
      _os_log_impl( &dword_181A5C000,  v13,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v26);
    if (v12) {
      goto LABEL_71;
    }
    goto LABEL_72;
  }

  if (a2)
  {
    if (a2->fast_open_frames.tqh_first)
    {
      if (a2->fast_open_frame_finalized_count)
      {
        candidate_output_handlers = (char *)a2->candidate_output_handlers;
        if (candidate_output_handlers)
        {
          v34[0] = MEMORY[0x1895F87A8];
          v34[1] = 3221225472LL;
          v34[2] = ___ZL46nw_flow_replay_send_initial_data_to_candidatesP30NWConcrete_nw_endpoint_handlerP16nw_flow_protocol_block_invoke;
          v34[3] = &unk_189BB8550;
          unint64_t v35 = v4;
          uint64_t v36 = a2;
          nw_hash_table_apply(candidate_output_handlers, (uint64_t)v34);
        }
      }
    }

    goto LABEL_72;
  }

  __nwlog_obj();
  int64x2_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v40 = "nw_flow_replay_send_initial_data_to_candidates";
  int64x2_t v12 = (void *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int64x2_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_flow_replay_send_initial_data_to_candidates";
      _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null flow_protocol", buf, 0xCu);
    }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_36;
  }

  unsigned int v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if (object) {
      unsigned int v3 = os_retain(object);
    }
    else {
      unsigned int v3 = 0LL;
    }
    *(void *)(v2 + 160) = v3;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_protocol_trainer_set_local";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  int64x2_t v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_protocol_trainer_set_local";
    unint64_t v7 = "%{public}s called with null trainer";
    goto LABEL_35;
  }

  if (!v12)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_protocol_trainer_set_local";
    unint64_t v7 = "%{public}s called with null trainer, backtrace limit exceeded";
    goto LABEL_35;
  }

  unint64_t v10 = (char *)__nw_create_backtrace_string();
  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  int64x2_t v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_protocol_trainer_set_local";
    unint64_t v7 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_35;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_protocol_trainer_set_local";
    unsigned int v16 = 2082;
    int v17 = v10;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null trainer, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v4) {
    goto LABEL_37;
  }
}

  if (v7) {
    free(v7);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

    unint64_t v18 = -[NWRemotePacketProxy defaultOutputHandler](self, "defaultOutputHandler", *(void *)v20);
    goto LABEL_36;
  }

  if (v24[20] != 6) {
    goto LABEL_33;
  }
  if (v9 <= 0x27) {
    goto LABEL_35;
  }
  if (!v4) {
    goto LABEL_28;
  }
LABEL_16:
  *(_WORD *)&v20[2] = *(_WORD *)(v10 + 22);
  uint64_t v15 = *(_WORD *)(v10 + 20);
LABEL_32:
  uint64_t v22 = v15;
LABEL_33:
  node = nw_hash_table_get_node( (uint64_t)-[NWRemotePacketProxy packetHashTable](self, "packetHashTable", *(_OWORD *)v20, *(void *)&v20[16]),  (uint64_t)v20,  60LL);
  if (!node) {
    goto LABEL_35;
  }
  unint64_t v18 = *(nw_protocol **)(node + 32);
LABEL_36:

  return v18;
}

    free(v21);
    if (!v11) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  unsigned int v9 = (void *)v5[3];
  v29[0] = MEMORY[0x1895F87A8];
  v29[1] = 3221225472LL;
  v29[2] = __nw_listener_register_client_demux_options_if_needed_block_invoke;
  v29[3] = &unk_189BC6E60;
  unint64_t v30 = v5;
  v31 = v8;
  __int16 v32 = v6;
  nw_queue_context_async_if_needed(v9, v29);

LABEL_5:
}

    free(backtrace_string);
    goto LABEL_54;
  }

  if (v1 == &__block_literal_global_18956)
  {
    __nwlog_obj();
    unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_parameters_create_peer_to_peer_migrating_quic";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_create_peer_to_peer_migrating_quic";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_disable))",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    if (!v23)
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint32_t v21 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_create_peer_to_peer_migrating_quic";
        _os_log_impl( &dword_181A5C000,  v7,  v21,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v16 = type;
    int v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_create_peer_to_peer_migrating_quic";
        _os_log_impl( &dword_181A5C000,  v7,  v16,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_disable)), no backtrace",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v26 = "nw_parameters_create_peer_to_peer_migrating_quic";
      v27 = 2082;
      int v28 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v16,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (v1 != &__block_literal_global_91)
  {
    quic = nw_parameters_create_quic(v1);
    nw_parameters_set_migrating_peer_to_peer(quic);
    goto LABEL_5;
  }

  __nwlog_obj();
  int64x2_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_parameters_create_peer_to_peer_migrating_quic";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v6, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int64x2_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_create_peer_to_peer_migrating_quic";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_default_configuration))",  buf,  0xCu);
      }

    free(v17);
    if (!v7) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  *a3 = 0;
LABEL_5:
}

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_path_parse_necp_parameters(v5, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, a2, a3);
LABEL_5:
}

    goto LABEL_36;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "runProbes_block_invoke";
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v3;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEFAULT,  "%{public}s Already running probes, skipping. Finished with transaction %@",  buf,  0x16u);
  }
}

    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_36;
  }

  if (a2)
  {
    uint64_t v4 = *a1;
    if (v4)
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      uint32_t v21 = 0;
      uint64_t v5 = MEMORY[0x1895F87A8];
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 0x40000000LL;
      applier[2] = ___ZL41network_config_remove_observer_from_arrayPPvS__block_invoke;
      applier[3] = &unk_189BB96F0;
      applier[4] = buf;
      applier[5] = a2;
      xpc_array_apply(v4, applier);
      uint64_t v6 = xpc_array_create(0LL, 0LL);
      unint64_t v7 = *a1;
      v16[0] = v5;
      v16[1] = 0x40000000LL;
      v16[2] = ___ZL41network_config_remove_observer_from_arrayPPvS__block_invoke_2;
      v16[3] = &__block_descriptor_tmp_21_23961;
      v16[4] = a2;
      v16[5] = v6;
      xpc_array_apply(v7, v16);
      if (*a1) {
        xpc_release(*a1);
      }
      *a1 = v6;
      _Block_object_dispose(buf, 8);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  unint64_t v19 = OS_LOG_TYPE_ERROR;
  unint64_t v18 = 0;
  if (v19 == OS_LOG_TYPE_FAULT)
  {
    unsigned int v9 = (os_log_s *)__nwlog_obj();
    unint64_t v10 = v19;
    if (!os_log_type_enabled(v9, v19)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
    int64x2_t v11 = "%{public}s called with null observer";
    goto LABEL_35;
  }

  if (!v18)
  {
    unsigned int v9 = (os_log_s *)__nwlog_obj();
    unint64_t v10 = v19;
    if (!os_log_type_enabled(v9, v19)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
    int64x2_t v11 = "%{public}s called with null observer, backtrace limit exceeded";
    goto LABEL_35;
  }

  unint64_t v14 = (char *)__nw_create_backtrace_string();
  unsigned int v9 = (os_log_s *)__nwlog_obj();
  unint64_t v10 = v19;
  uint64_t v15 = os_log_type_enabled(v9, v19);
  if (!v14)
  {
    if (!v15) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
    int64x2_t v11 = "%{public}s called with null observer, no backtrace";
    goto LABEL_35;
  }

  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v14;
    _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null observer, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v14);
  if (v8) {
    goto LABEL_37;
  }
}

  if (v16) {
    free(v16);
  }
LABEL_18:
}

  nw_parameters_set_preferred_netagent_classes((void *)v29, 0LL, 0LL);
  if (v164 == 1 || (*((_BYTE *)v169 + 97) & 0x40) != 0)
  {
    v38 = (id)v29;
    v39 = v38;
    if (v38)
    {
      *(_WORD *)(*((void *)v38 + 13) + 108LL) |= 0x2000u;
LABEL_39:

      goto LABEL_40;
    }

    __nwlog_obj();
    v100 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v178 = "nw_parameters_set_is_system_proxy_connection";
    v101 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(iterate_block[0]) = 16;
    v176 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v101, iterate_block, &v176))
    {
      if (LOBYTE(iterate_block[0]) == 17)
      {
        __nwlog_obj();
        v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v103 = iterate_block[0];
        if (os_log_type_enabled(v102, iterate_block[0]))
        {
          *(_DWORD *)buf = 136446210;
          v178 = "nw_parameters_set_is_system_proxy_connection";
          _os_log_impl(&dword_181A5C000, v102, v103, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else
      {
        v119 = v15;
        if (v176)
        {
          v120 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v122 = iterate_block[0];
          v123 = os_log_type_enabled(v121, iterate_block[0]);
          if (v120)
          {
            if (v123)
            {
              *(_DWORD *)buf = 136446466;
              v178 = "nw_parameters_set_is_system_proxy_connection";
              v179 = 2082;
              v180 = v120;
              _os_log_impl( &dword_181A5C000,  v121,  v122,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            uint64_t v15 = v119;
            free(v120);
            goto LABEL_184;
          }

          if (v123)
          {
            *(_DWORD *)buf = 136446210;
            v178 = "nw_parameters_set_is_system_proxy_connection";
            _os_log_impl( &dword_181A5C000,  v121,  v122,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v136 = iterate_block[0];
          if (os_log_type_enabled(v135, iterate_block[0]))
          {
            *(_DWORD *)buf = 136446210;
            v178 = "nw_parameters_set_is_system_proxy_connection";
            _os_log_impl( &dword_181A5C000,  v135,  v136,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        uint64_t v15 = v119;
      }
    }

  if (v7) {
    free(v7);
  }
  return 0LL;
}

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_36;
  }

  handle = a1->handle;
  if (handle)
  {
    *((_BYTE *)handle + 348) |= 8u;
    nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a2);
    if (a1->output_handler == a2) {
      nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a1);
    }
    uint64_t v5 = (char *)*((void *)handle + 37);
    if (v5)
    {
      v14[0] = MEMORY[0x1895F87A8];
      v14[1] = 0x40000000LL;
      v14[2] = ___ZL27nw_protocol_ohttp_connectedP11nw_protocolS0__block_invoke;
      v14[3] = &__block_descriptor_tmp_42_28636;
      v14[4] = a1;
      nw_hash_table_apply(v5, (uint64_t)v14);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v18 = "nw_protocol_ohttp_connected";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();
  unsigned int v16 = OS_LOG_TYPE_ERROR;
  uint64_t v15 = 0;
  if (v16 == OS_LOG_TYPE_FAULT)
  {
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = v16;
    if (!os_log_type_enabled(v7, v16)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_protocol_ohttp_connected";
    unsigned int v9 = "%{public}s called with null ohttp";
    goto LABEL_35;
  }

  if (!v15)
  {
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = v16;
    if (!os_log_type_enabled(v7, v16)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_protocol_ohttp_connected";
    unsigned int v9 = "%{public}s called with null ohttp, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v12 = (char *)__nw_create_backtrace_string();
  unint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = v16;
  int64x2_t v13 = os_log_type_enabled(v7, v16);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_protocol_ohttp_connected";
    unsigned int v9 = "%{public}s called with null ohttp, no backtrace";
    goto LABEL_35;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v18 = "nw_protocol_ohttp_connected";
    unint64_t v19 = 2082;
    uint64_t v20 = v12;
    _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v12);
  if (v6) {
    goto LABEL_37;
  }
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_36;
  }

  if (a2)
  {
    nw_protocol_ohttp_context_destroy((void *)(a2 + 32));
    if (!nw_hash_table_remove_node(*(void *)(a1 + 296), a2) && (*(_BYTE *)(a1 + 348) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        unsigned int v16 = "nw_protocol_ohttp_context_destroy_node";
        int v17 = 2082;
        unint64_t v18 = (char *)(a1 + 349);
        unint64_t v19 = 2080;
        uint64_t v20 = " ";
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%snw_hash_table_remove_node failed",  buf,  0x20u);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v16 = "nw_protocol_ohttp_context_destroy_node";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  int64x2_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_ohttp_context_destroy_node";
    uint64_t v8 = "%{public}s called with null node";
    goto LABEL_35;
  }

  if (!v13)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_ohttp_context_destroy_node";
    uint64_t v8 = "%{public}s called with null node, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v11 = (char *)__nw_create_backtrace_string();
  uint64_t v6 = (os_log_s *)__nwlog_obj();
  unint64_t v7 = type;
  int64x2_t v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_ohttp_context_destroy_node";
    uint64_t v8 = "%{public}s called with null node, no backtrace";
    goto LABEL_35;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    unsigned int v16 = "nw_protocol_ohttp_context_destroy_node";
    int v17 = 2082;
    unint64_t v18 = v11;
    _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null node, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v11);
  if (v5) {
    goto LABEL_37;
  }
}

    free(v15);
    if (!v5) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v23[0] = MEMORY[0x1895F87A8];
  v23[1] = 3221225472LL;
  v23[2] = ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke;
  v23[3] = &unk_189BBF198;
  v24 = v1;
  nw_connection_receive_internal(v3, 0LL, 1u, 0xFFFFFFFF, v23);

LABEL_5:
}

    free(v17);
    if (!v7) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v25[0] = MEMORY[0x1895F87A8];
  v25[1] = 3221225472LL;
  v25[2] = ___ZL43nw_masque_connection_pair_read_inner_directP36NWConcrete_nw_masque_connection_pairP24NWConcrete_nw_connection_block_invoke;
  v25[3] = &unk_189BBB858;
  v26 = v3;
  v27 = v5;
  nw_connection_read_multiple(v27, 1u, 0xFFFFFFFF, v25);

LABEL_5:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v27[0] = MEMORY[0x1895F87A8];
  v27[1] = 3221225472LL;
  v27[2] = ___ZL41nw_masque_listener_pair_read_inner_directP34NWConcrete_nw_masque_listener_pairP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObject_block_invoke;
  v27[3] = &unk_189BBB808;
  int v28 = v5;
  unint64_t v29 = v7;
  unint64_t v30 = v6;
  nw_connection_read_multiple(v30, 1u, 0xFFFFFFFF, v27);

LABEL_5:
}

    free(v15);
    if (!v5) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v23[0] = MEMORY[0x1895F87A8];
  v23[1] = 3221225472LL;
  v23[2] = ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke;
  v23[3] = &unk_189BBB748;
  v24 = v1;
  nw_connection_read_multiple(v3, 1u, 0xFFFFFFFF, v23);

LABEL_5:
}

    free(v15);
    if (!v5) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v23[0] = MEMORY[0x1895F87A8];
  v23[1] = 3221225472LL;
  v23[2] = ___ZL36nw_masque_connection_pair_read_outerP36NWConcrete_nw_masque_connection_pair_block_invoke;
  v23[3] = &unk_189BBF198;
  v24 = v1;
  nw_connection_receive_internal(v3, 0LL, 1u, 0xFFFFFFFF, v23);

LABEL_5:
}

    free(v15);
    if (!v5) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v23[0] = MEMORY[0x1895F87A8];
  v23[1] = 3221225472LL;
  v23[2] = ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke;
  v23[3] = &unk_189BBF198;
  v24 = v1;
  nw_connection_receive_internal(v3, 0LL, 1u, 0xFFFFFFFF, v23);

LABEL_5:
}

    goto LABEL_36;
  }

  if (!v26)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v10 = (os_log_s *)(id)gLogObj;
    int v17 = type;
    if (os_log_type_enabled(v10, type))
    {
      else {
        unint64_t v18 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      unint64_t v29 = "-[NWConcrete_nw_endpoint_resolver updatePathWithHandler:]";
      unint64_t v30 = 2082;
      v31 = (void *)v18;
      __int16 v32 = 2082;
      v33 = "resolver";
      _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  int64x2_t v13 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v10 = (os_log_s *)(id)gLogObj;
  unint64_t v14 = type;
  uint64_t v15 = os_log_type_enabled(v10, type);
  if (!v13)
  {
    if (v15)
    {
      else {
        unint64_t v19 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      unint64_t v29 = "-[NWConcrete_nw_endpoint_resolver updatePathWithHandler:]";
      unint64_t v30 = 2082;
      v31 = (void *)v19;
      __int16 v32 = 2082;
      v33 = "resolver";
      _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_35;
  }

  if (v15)
  {
    else {
      unsigned int v16 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    unint64_t v29 = "-[NWConcrete_nw_endpoint_resolver updatePathWithHandler:]";
    unint64_t v30 = 2082;
    v31 = (void *)v16;
    __int16 v32 = 2082;
    v33 = "resolver";
    __int16 v34 = 2082;
    unint64_t v35 = v13;
    _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v13);
  if (v9) {
    goto LABEL_37;
  }
LABEL_38:
}

        goto LABEL_36;
      }

      if (!v18)
      {
        __nwlog_obj();
        unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int64x2_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint32_t v21 = "tcp_connection_create_with_sockaddr";
          int64x2_t v12 = "%{public}s called with null queue, backtrace limit exceeded";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int64x2_t v11 = type;
      uint64_t v15 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint32_t v21 = "tcp_connection_create_with_sockaddr";
          int64x2_t v12 = "%{public}s called with null queue, no backtrace";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v15) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      uint32_t v21 = "tcp_connection_create_with_sockaddr";
      uint64_t v22 = 2082;
      v23 = backtrace_string;
      unsigned int v16 = "%{public}s called with null queue, dumping backtrace:%{public}s";
      goto LABEL_24;
    }
  }

        goto LABEL_36;
      }

      if (!v21)
      {
        __nwlog_obj();
        int64x2_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          uint64_t v15 = "%{public}s called with null hostname, backtrace limit exceeded";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int64x2_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v14 = type;
      unint64_t v18 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          uint64_t v15 = "%{public}s called with null hostname, no backtrace";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v18) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      v24 = "tcp_connection_create";
      v25 = 2082;
      v26 = backtrace_string;
      unint64_t v19 = "%{public}s called with null hostname, dumping backtrace:%{public}s";
      goto LABEL_24;
    }
  }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (!v36) {
          goto LABEL_58;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWEndpoint initWithCoder:]";
        unint64_t v29 = "%{public}s NWUtilsCreateXPCDictionaryFromNSDictionary failed, no backtrace";
      }

      v42 = v27;
      v43 = v35;
      goto LABEL_57;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v55 = "-[NWEndpoint initWithCoder:]";
    uint32_t v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v21, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWEndpoint initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed";
LABEL_44:
        v40 = v22;
        v41 = v23;
        goto LABEL_45;
      }

      if (!v51)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWEndpoint initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed, backtrace limit exceeded";
        goto LABEL_44;
      }

      unint64_t v30 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      v31 = type;
      __int16 v32 = os_log_type_enabled(v22, type);
      if (!v30)
      {
        if (!v32)
        {
LABEL_46:

          if (!v21) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }

        *(_DWORD *)buf = 136446210;
        v55 = "-[NWEndpoint initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed, no backtrace";
        v40 = v22;
        v41 = v31;
LABEL_45:
        _os_log_impl(&dword_181A5C000, v40, v41, v24, buf, 0xCu);
        goto LABEL_46;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        v55 = "-[NWEndpoint initWithCoder:]";
        v56 = 2082;
        v57 = v30;
        _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s decodeObjectOfClasses:forKey failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v30);
    }

    if (!v21)
    {
LABEL_21:
      unint64_t v19 = 0LL;
LABEL_40:

      goto LABEL_41;
    }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_36;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0 && gLogDatapath)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v9 = handle[115];
        *(_DWORD *)buf = 136447234;
        int v17 = "nw_protocol_webtransport_session_disconnect";
        unint64_t v18 = 2082;
        unint64_t v19 = (char *)(handle + 116);
        uint64_t v20 = 2080;
        uint32_t v21 = " ";
        uint64_t v22 = 1024;
        v23 = v9;
        v24 = 2048;
        v25 = a2;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called, with other_protocol: %p",  buf,  0x30u);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v17 = "nw_protocol_webtransport_session_disconnect";
  unsigned int v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  unint64_t v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_protocol_webtransport_session_disconnect";
    uint64_t v6 = "%{public}s called with null webtransport_session";
    goto LABEL_35;
  }

  if (!v14)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_protocol_webtransport_session_disconnect";
    uint64_t v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v12 = (char *)__nw_create_backtrace_string();
  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  int64x2_t v13 = os_log_type_enabled(v4, type);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_protocol_webtransport_session_disconnect";
    uint64_t v6 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_35;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    int v17 = "nw_protocol_webtransport_session_disconnect";
    unint64_t v18 = 2082;
    unint64_t v19 = v12;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v12);
  if (v3) {
    goto LABEL_37;
  }
}

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_36;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0 && gLogDatapath)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        unsigned int v16 = "nw_protocol_webtransport_session_input_finished";
        int v17 = 2082;
        unint64_t v18 = (char *)(handle + 116);
        unint64_t v19 = 2080;
        uint64_t v20 = " ";
        uint32_t v21 = 1024;
        uint64_t v22 = v8;
        _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v16 = "nw_protocol_webtransport_session_input_finished";
  unsigned int v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  int64x2_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_webtransport_session_input_finished";
    uint64_t v6 = "%{public}s called with null webtransport_session";
    goto LABEL_35;
  }

  if (!v13)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_webtransport_session_input_finished";
    uint64_t v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v11 = (char *)__nw_create_backtrace_string();
  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  int64x2_t v12 = os_log_type_enabled(v4, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v16 = "nw_protocol_webtransport_session_input_finished";
    uint64_t v6 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_35;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    unsigned int v16 = "nw_protocol_webtransport_session_input_finished";
    int v17 = 2082;
    unint64_t v18 = v11;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v3) {
    goto LABEL_37;
  }
}

      free(v12);
      if (!v6) {
        return;
      }
LABEL_51:
      free(v6);
      return;
    }

    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_webtransport_stream_get_message_properties";
    unsigned int v9 = "%{public}s called with null webtransport_stream";
LABEL_49:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_50;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_webtransport_stream_get_message_properties";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    unsigned int v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v19 = "nw_protocol_webtransport_stream_get_message_properties";
      unsigned int v9 = "%{public}s called with null message_properties";
      goto LABEL_49;
    }

    if (!v16)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v19 = "nw_protocol_webtransport_stream_get_message_properties";
      unsigned int v9 = "%{public}s called with null message_properties, backtrace limit exceeded";
      goto LABEL_49;
    }

    int64x2_t v12 = (char *)__nw_create_backtrace_string();
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    uint64_t v15 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v15) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v19 = "nw_protocol_webtransport_stream_get_message_properties";
      unsigned int v9 = "%{public}s called with null message_properties, no backtrace";
      goto LABEL_49;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v19 = "nw_protocol_webtransport_stream_get_message_properties";
      uint64_t v20 = 2082;
      uint32_t v21 = v12;
      unint64_t v14 = "%{public}s called with null message_properties, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  uint64_t v4 = a3[1] & 0xFFFFFFF8;
  if (*(void *)(v3 + 64) == -2LL) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 4;
  }
  *a3 = -1;
  a3[1] = v4 | v5;
}

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v92 = "nw_webtransport_stream_allocate_new_id";
      type = OS_LOG_TYPE_ERROR;
      v89 = 0;
      v87 = (char *)_os_log_send_and_compose_impl();
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v20 = (os_log_s *)__nwlog_obj();
        uint32_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_162;
        }
        *(_DWORD *)buf = 136446210;
        v92 = "nw_webtransport_stream_allocate_new_id";
        uint64_t v22 = "%{public}s called with null webtransport_session";
      }

      else if (v89)
      {
        v76 = (char *)__nw_create_backtrace_string();
        uint64_t v20 = (os_log_s *)__nwlog_obj();
        uint32_t v21 = type;
        v77 = os_log_type_enabled(v20, type);
        if (v76)
        {
          if (v77)
          {
            *(_DWORD *)buf = 136446466;
            v92 = "nw_webtransport_stream_allocate_new_id";
            v93 = 2082;
            p_identifier = v76;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v76);
          goto LABEL_162;
        }

        if (!v77)
        {
LABEL_162:
          if (v87) {
            free(v87);
          }
LABEL_41:
          v23 = *((void *)handle + 11);
          if (v23)
          {
            if (*((void *)handle + 8) == -2LL)
            {
              if (*(void *)(v23 + 424))
              {
                if ((*(_BYTE *)(v23 + 548) & 2) != 0) {
                  goto LABEL_60;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v24 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_60;
                }
                v25 = *(_DWORD *)(v23 + 460);
                *(_DWORD *)buf = 136446978;
                v92 = "nw_webtransport_session_add_stream";
                v93 = 2082;
                p_identifier = (char *)(v23 + 464);
                v95 = 2080;
                v96 = " ";
                v97 = 1024;
                v98 = v25;
                v26 = "%{public}s %{public}s%s<i%u> WebTransport already has datagram stream registered";
                v27 = (os_log_s *)v24;
                int v28 = OS_LOG_TYPE_ERROR;
                unint64_t v29 = 38;
LABEL_56:
                _os_log_impl(&dword_181A5C000, v27, v28, v26, buf, v29);
LABEL_60:
                __int16 v34 = handle[276];
                if (a1->default_input_handler)
                {
                  if ((handle[276] & 1) == 0)
                  {
                    unint64_t v35 = *((void *)handle + 8);
                    if (v35 == -1)
                    {
                      if ((handle[276] & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v42 = (os_log_s *)gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                        {
                          v43 = *((void *)handle + 11);
                          if (v43) {
                            v44 = *(_DWORD *)(v43 + 460);
                          }
                          else {
                            v44 = -1;
                          }
                          v57 = *((void *)handle + 8);
                          *(_DWORD *)buf = 136447234;
                          v92 = "nw_webtransport_stream_configure_metadata_with_stream_id";
                          v93 = 2082;
                          p_identifier = (char *)(handle + 192);
                          v95 = 2080;
                          v96 = " ";
                          v97 = 1024;
                          v98 = v44;
                          v99 = 2048;
                          v100 = v57;
                          _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set",  buf,  0x30u);
                          if ((handle[276] & 0x10) == 0)
                          {
LABEL_89:
                            if (gLogDatapath)
                            {
                              v73 = (os_log_s *)__nwlog_obj();
                              if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
                              {
                                v74 = *((void *)handle + 11);
                                if (v74) {
                                  v75 = *(_DWORD *)(v74 + 460);
                                }
                                else {
                                  v75 = -1;
                                }
                                v86 = *((void *)handle + 8);
                                *(_DWORD *)buf = 136448002;
                                v92 = "nw_protocol_webtransport_http2_stream_connected";
                                v93 = 2082;
                                p_identifier = (char *)(handle + 192);
                                v95 = 2080;
                                v96 = " ";
                                v97 = 1024;
                                v98 = v75;
                                v99 = 2048;
                                v100 = v86;
                                v101 = 2048;
                                *(void *)v102 = a1;
                                *(_WORD *)&v102[8] = 2048;
                                v103 = v86;
                                v104 = 2048;
                                v105 = a2;
                                _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> webtransport http2 stream %p with id %llu connected with output_handler %p",  buf,  0x4Eu);
                              }
                            }
                          }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_36;
  }

  if (a2)
  {
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(const void **)(a1 + 40) != a2)
    {
      uint64_t v5 = _Block_copy(a2);
      uint64_t v6 = *(const void **)(a1 + 40);
      if (v6) {
        _Block_release(v6);
      }
      *(void *)(a1 + 40) = v5;
    }

    os_unfair_lock_unlock(v4);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v18 = "tcp_listener_set_accept_handler";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  uint64_t v15 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "tcp_listener_set_accept_handler";
    unint64_t v10 = "%{public}s called with null acceptblk";
    goto LABEL_35;
  }

  if (!v15)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "tcp_listener_set_accept_handler";
    unint64_t v10 = "%{public}s called with null acceptblk, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v13 = (char *)__nw_create_backtrace_string();
  uint64_t v8 = (os_log_s *)__nwlog_obj();
  unsigned int v9 = type;
  unint64_t v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "tcp_listener_set_accept_handler";
    unint64_t v10 = "%{public}s called with null acceptblk, no backtrace";
    goto LABEL_35;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v18 = "tcp_listener_set_accept_handler";
    unint64_t v19 = 2082;
    uint64_t v20 = v13;
    _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null acceptblk, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v13);
  if (v7) {
LABEL_37:
  }
    free(v7);
}

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_36;
  }

  if (a2)
  {
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(const void **)(a1 + 48) != a2)
    {
      uint64_t v5 = _Block_copy(a2);
      uint64_t v6 = *(const void **)(a1 + 48);
      if (v6) {
        _Block_release(v6);
      }
      *(void *)(a1 + 48) = v5;
    }

    os_unfair_lock_unlock(v4);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v18 = "tcp_listener_set_error_handler";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  uint64_t v15 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "tcp_listener_set_error_handler";
    unint64_t v10 = "%{public}s called with null handler";
    goto LABEL_35;
  }

  if (!v15)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "tcp_listener_set_error_handler";
    unint64_t v10 = "%{public}s called with null handler, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v13 = (char *)__nw_create_backtrace_string();
  uint64_t v8 = (os_log_s *)__nwlog_obj();
  unsigned int v9 = type;
  unint64_t v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "tcp_listener_set_error_handler";
    unint64_t v10 = "%{public}s called with null handler, no backtrace";
    goto LABEL_35;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v18 = "tcp_listener_set_error_handler";
    unint64_t v19 = 2082;
    uint64_t v20 = v13;
    _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v13);
  if (v7) {
LABEL_37:
  }
    free(v7);
}

      free(backtrace_string);
      goto LABEL_47;
    }

    int64x2_t v13 = (os_log_s *)__nwlog_obj();
    unint64_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
    uint64_t v15 = "%{public}s called with null protocol";
LABEL_46:
    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
LABEL_47:
    if (v12) {
      free(v12);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
    int64x2_t v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int64x2_t v13 = (os_log_s *)__nwlog_obj();
      unint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
      uint64_t v15 = "%{public}s called with null http_connect";
      goto LABEL_46;
    }

    if (!v21)
    {
      int64x2_t v13 = (os_log_s *)__nwlog_obj();
      unint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
      uint64_t v15 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_46;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int64x2_t v13 = (os_log_s *)__nwlog_obj();
    unint64_t v14 = type;
    unint64_t v19 = os_log_type_enabled(v13, type);
    if (backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        unint64_t v18 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (!v19) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
    uint64_t v15 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_46;
  }

  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  if (gLogDatapath)
  {
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_35503;
  v24 = &__block_descriptor_tmp_15_35504;
  v25 = (char *)(handle + 28);
  v26 = 0;
  uint64_t v8 = handle[28];
  do
  {
    if (!v8) {
      break;
    }
    unsigned int v9 = *(void *)(v8 + 32);
    unint64_t v10 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    uint64_t v8 = v9;
  }

  while ((v10 & 1) != 0);
  nw_protocol_remove_input_handler((uint64_t)a1->output_handler, (uint64_t)a1);
  nw_protocol_set_input_handler((uint64_t)a1, 0LL);
  if (a3)
  {
    a1->handle = 0LL;
    nw_http_connect_destroy((uint64_t)handle);
  }

  return 1LL;
}

  if (gLogDatapath)
  {
    v70 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
    {
      v71 = v79[3];
      *(_DWORD *)v82 = 136446978;
      v83 = "http2_transport_create_output_frame";
      v84 = 2082;
      v85 = (uint64_t)handle + 205;
      v86 = 2048;
      v87 = v71;
      v88 = 1024;
      v89 = v9;
      _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s output_frame_create returning frame %p for requested length %u",  v82,  0x26u);
    }
  }

        if (v4) {
          free(v4);
        }
        goto LABEL_37;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v9 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 205;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s added protocol listen handler",  buf,  0x16u);
      }

      *((void *)handle + 13) = a2;
      a2->protocol_handler = a1;
      if ((handle[204] & 0x40) == 0) {
        return 1LL;
      }
      if (gLogDatapath)
      {
        int v28 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 205;
          _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s waiting for listen handler, resuming processing of connected",  buf,  0x16u);
        }

        if (gLogDatapath)
        {
          unint64_t v29 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)type = 136446466;
            uint64_t v36 = "nw_protocol_http2_transport_process_connected";
            v37 = 2082;
            v38 = handle + 205;
            _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called",  (uint8_t *)type,  0x16u);
          }
        }
      }

      if ((handle[204] & 0x10) != 0)
      {
        if (!*((void *)handle + 13))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v19 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)type = 136446466;
            uint64_t v36 = "nw_protocol_http2_transport_process_connected";
            v37 = 2082;
            v38 = handle + 205;
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s no listen handler on server, deferring processing of input and connected state until listen handler is present",  (uint8_t *)type,  0x16u);
          }

          handle[204] |= 0x40u;
          return 1LL;
        }

        if (!gLogDatapath) {
          goto LABEL_24;
        }
        unint64_t v10 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_24;
        }
        *(_DWORD *)type = 136446466;
        uint64_t v36 = "nw_protocol_http2_transport_process_connected";
        v37 = 2082;
        v38 = handle + 205;
        int64x2_t v11 = "%{public}s %{public}s listen handler present, processing input without waiting";
      }

      else
      {
        if (!gLogDatapath || (unint64_t v10 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)))
        {
LABEL_24:
          unint64_t v14 = handle[204];
          handle[204] = v14 & 0xBF;
          if ((v14 & 6) != 0)
          {
            if (gLogDatapath)
            {
              uint64_t v15 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)type = 136446466;
                uint64_t v36 = "nw_protocol_http2_transport_process_connected";
                v37 = 2082;
                v38 = handle + 205;
                _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s tunnel already connected or closed, ignoring connected event",  (uint8_t *)type,  0x16u);
              }
            }
          }

          else
          {
            nw_http2_transport_send_settings((uint64_t)handle);
            handle[204] |= 2u;
            if (gLogDatapath)
            {
              unint64_t v30 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)type = 136446466;
                uint64_t v36 = "nw_protocol_http2_transport_process_connected";
                v37 = 2082;
                v38 = handle + 205;
                _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s http2 tunnel is now connected",  (uint8_t *)type,  0x16u);
              }
            }

            nw_protocol_http2_transport_process_input((uint64_t)handle);
            unsigned int v16 = (char *)*((void *)handle + 14);
            *(void *)buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&buf[16] = ___ZL45nw_protocol_http2_transport_process_connectedP27nw_protocol_http2_transport_block_invoke;
            v33 = (char *)&__block_descriptor_tmp_20_37842;
            __int16 v34 = handle;
            nw_hash_table_apply(v16, (uint64_t)buf);
          }

          return 1LL;
        }

        *(_DWORD *)type = 136446466;
        uint64_t v36 = "nw_protocol_http2_transport_process_connected";
        v37 = 2082;
        v38 = handle + 205;
        int64x2_t v11 = "%{public}s %{public}s not server, processing input without waiting";
      }

      _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, v11, (uint8_t *)type, 0x16u);
      goto LABEL_24;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
        v23 = "%{public}s called with null http2_transport";
        goto LABEL_75;
      }

      goto LABEL_76;
    }

    if (!v31)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
        v23 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_75;
      }

      goto LABEL_76;
    }

    v24 = (char *)__nw_create_backtrace_string();
    uint32_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type[0];
    v27 = os_log_type_enabled(v21, type[0]);
    if (!v24)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
        v23 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_75;
      }

      goto LABEL_76;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v24;
      v26 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
      goto LABEL_60;
    }

    goto LABEL_61;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!v31)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
        v23 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_75;
      }

      goto LABEL_76;
    }

    v24 = (char *)__nw_create_backtrace_string();
    uint32_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type[0];
    v25 = os_log_type_enabled(v21, type[0]);
    if (!v24)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
        v23 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_75;
      }

      goto LABEL_76;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v24;
      v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_60:
      _os_log_impl(&dword_181A5C000, v21, v22, v26, buf, 0x16u);
    }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v9) {
    free(v9);
  }
  return 1LL;
}

    free(v12);
    if (!v6) {
      goto LABEL_83;
    }
LABEL_82:
    free(v6);
    goto LABEL_83;
  }

  uint64_t v5 = *((void *)handle + 1);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_http1_get_http1_protocol";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_81;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_http1_get_http1_protocol";
      unsigned int v9 = "%{public}s called with null handle->http1_stream";
      goto LABEL_80;
    }

    if (!v42)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_81;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_http1_get_http1_protocol";
      unsigned int v9 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_80;
    }

    int64x2_t v12 = (char *)__nw_create_backtrace_string();
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    unint64_t v19 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v19) {
        goto LABEL_81;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_http1_get_http1_protocol";
      unsigned int v9 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_80;
    }

    if (!v19) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446466;
    v45 = "nw_http1_get_http1_protocol";
    v46 = 2082;
    v47 = v12;
    unint64_t v14 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v7, v8, v14, buf, 0x16u);
    goto LABEL_35;
  }

  unsigned int v3 = (void *)(v5 + 248);
LABEL_10:
  if (*v3)
  {
    if (v2 == 2) {
      goto LABEL_14;
    }
    if (v2 != 3) {
      return;
    }
    if (*((void *)handle + 2))
    {
LABEL_14:
      if (v2 != 2) {
        return;
      }
      goto LABEL_107;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_http1_get_stream_for_protocol";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v15, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v16 = (os_log_s *)__nwlog_obj();
        int v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        v45 = "nw_http1_get_stream_for_protocol";
        unint64_t v18 = "%{public}s called with null handle->http1_connection";
LABEL_102:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
        goto LABEL_103;
      }

      if (!v42)
      {
        unsigned int v16 = (os_log_s *)__nwlog_obj();
        int v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        v45 = "nw_http1_get_stream_for_protocol";
        unint64_t v18 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_102;
      }

      uint32_t v21 = (char *)__nw_create_backtrace_string();
      unsigned int v16 = (os_log_s *)__nwlog_obj();
      int v17 = type;
      uint64_t v22 = os_log_type_enabled(v16, type);
      if (!v21)
      {
        if (!v22) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        v45 = "nw_http1_get_stream_for_protocol";
        unint64_t v18 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_102;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        v45 = "nw_http1_get_stream_for_protocol";
        v46 = 2082;
        v47 = v21;
        _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v21);
    }

    free(v12);
    if (!v6) {
      goto LABEL_83;
    }
LABEL_82:
    free(v6);
    goto LABEL_83;
  }

  uint64_t v5 = *((void *)handle + 1);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_http1_get_http1_protocol";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_81;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_http1_get_http1_protocol";
      unsigned int v9 = "%{public}s called with null handle->http1_stream";
      goto LABEL_80;
    }

    if (!v42)
    {
      unint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_81;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_http1_get_http1_protocol";
      unsigned int v9 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_80;
    }

    int64x2_t v12 = (char *)__nw_create_backtrace_string();
    unint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    unint64_t v19 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v19) {
        goto LABEL_81;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_http1_get_http1_protocol";
      unsigned int v9 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_80;
    }

    if (!v19) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446466;
    v45 = "nw_http1_get_http1_protocol";
    v46 = 2082;
    v47 = v12;
    unint64_t v14 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v7, v8, v14, buf, 0x16u);
    goto LABEL_35;
  }

  unsigned int v3 = (void *)(v5 + 248);
LABEL_10:
  if (*v3)
  {
    if (v2 == 2) {
      goto LABEL_14;
    }
    if (v2 != 3) {
      return;
    }
    if (*((void *)handle + 2))
    {
LABEL_14:
      if (v2 != 2) {
        return;
      }
      goto LABEL_107;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_http1_get_stream_for_protocol";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v15, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v16 = (os_log_s *)__nwlog_obj();
        int v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        v45 = "nw_http1_get_stream_for_protocol";
        unint64_t v18 = "%{public}s called with null handle->http1_connection";
LABEL_102:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
        goto LABEL_103;
      }

      if (!v42)
      {
        unsigned int v16 = (os_log_s *)__nwlog_obj();
        int v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        v45 = "nw_http1_get_stream_for_protocol";
        unint64_t v18 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_102;
      }

      uint32_t v21 = (char *)__nw_create_backtrace_string();
      unsigned int v16 = (os_log_s *)__nwlog_obj();
      int v17 = type;
      uint64_t v22 = os_log_type_enabled(v16, type);
      if (!v21)
      {
        if (!v22) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        v45 = "nw_http1_get_stream_for_protocol";
        unint64_t v18 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_102;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        v45 = "nw_http1_get_stream_for_protocol";
        v46 = 2082;
        v47 = v21;
        _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v21);
    }

    if (v19) {
      free(v19);
    }
    int v28 = *(void *)(a2 + 32);
    unint64_t v29 = *(void **)(a2 + 40);
    if (v28)
    {
      *(void *)(v28 + 40) = v29;
      unint64_t v29 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(*(void *)(a1 + 48) + 8LL) = v29;
    }

    *unint64_t v29 = v28;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    nw_frame_finalize(a2);
    return a2 != 0;
  }

  __break(1u);
  return result;
}

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (os_log_s *)gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_4;
        }
        v26 = *(void *)(a1 + 32);
        unint64_t v29 = 136446466;
        unint64_t v30 = "nw_replicate_metadata_add_endpoint_on_queue_block_invoke";
        v31 = 2112;
        __int16 v32 = v26;
        v25 = "%{public}s Will not add endpoint %@ for replication, already covered";
        goto LABEL_37;
      }
    }
  }

    if (v12) {
      free(v12);
    }
    goto LABEL_18;
  }

  if (v3 != (nw_content_context_t)&__block_literal_global_5_41854
    && v3 != (nw_content_context_t)&__block_literal_global_4
    && v3 != (nw_content_context_t)&__block_literal_global_3_41839
    && v3 != (nw_content_context_t)&__block_literal_global_41831
    && v4 != (nw_content_context *)&__block_literal_global_5_41854
    && v4 != (nw_content_context *)&__block_literal_global_4
    && v4 != (nw_content_context *)&__block_literal_global_3_41839
    && v4 != (nw_content_context *)&__block_literal_global_41831)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 28);
    uint64_t v6 = v5;
    if (v6)
    {
      unint64_t v7 = v6;
      uint64_t v8 = v6;
      while (v8 != (id *)v3)
      {
        unsigned int v9 = (id *)v8[7];

        uint64_t v8 = v9;
        if (!v9) {
          goto LABEL_14;
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v22 = "nw_content_context_set_antecedent";
        v23 = 2114;
        v24 = (char *)v7;
        v25 = 2114;
        v26 = v3;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot create antecedent loops (%{public}@ introduces loop to %{public}@)",  buf,  0x20u);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 28);
    }

    else
    {
LABEL_14:
      objc_storeStrong((id *)v3 + 7, antecendent_context);
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 28);
    }
  }

      if (v9) {
        free(v9);
      }
LABEL_37:
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      return v4 == 0LL;
    }
  }

  int64x2_t v13 = calloc(1uLL, 0x78uLL);
  if (v13)
  {
LABEL_22:
    unint64_t v14 = *(_OWORD *)a1;
    uint64_t v15 = *((_OWORD *)a1 + 1);
    v13[8] = a1[4];
    *((_OWORD *)v13 + 2) = v14;
    *((_OWORD *)v13 + 3) = v15;
    v13[11] = a2;
    unsigned int v16 = g_registration_list;
    *int64x2_t v13 = g_registration_list;
    if (v16) {
      *(void *)(v16 + 8) = v13;
    }
    g_registration_list = (uint64_t)v13;
    v13[1] = &g_registration_list;
    goto LABEL_37;
  }

  uint64_t v20 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v25 = "strict_calloc";
  v26 = 2048;
  v27 = 1LL;
  int v28 = 2048;
  unint64_t v29 = 120LL;
  uint32_t v21 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
    goto LABEL_22;
  }

  __break(1u);
  return result;
}

    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  unsigned int v2 = (void *)NEHelperCacheCopySigningIdentifierMapping();
  if (gLogDatapath)
  {
    __nwlog_obj();
    int64x2_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_utilities_copy_bundle_id_for_uuid";
      v23 = 2112;
      *(void *)v24 = v2;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s NEHelperCacheCopySigningIdentifierMapping returned %@",  buf,  0x16u);
    }
  }

  if (!v2) {
    goto LABEL_5;
  }
  if (object_getClass(v2) != (Class)MEMORY[0x1895F92E8]) {
    goto LABEL_5;
  }
  string_ptr = xpc_string_get_string_ptr(v2);
  if (!string_ptr) {
    goto LABEL_5;
  }
  if (gLogDatapath)
  {
    int v17 = string_ptr;
    __nwlog_obj();
    unint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      uint64_t v22 = "nw_utilities_copy_bundle_id_for_uuid";
      v23 = 1040;
      *(_DWORD *)v24 = 16;
      *(_WORD *)&v24[4] = 2096;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = v17;
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s Looked up UUID (%{uuid_t}.16P) -> Bundle ID (%s)",  buf,  0x26u);
    }

    string_ptr = v17;
  }

  unsigned int v3 = strdup(string_ptr);
  if (v3) {
    goto LABEL_6;
  }
  __nwlog_obj();
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "strict_strdup";
  unint64_t v7 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
LABEL_5:
    unsigned int v3 = 0LL;
LABEL_6:

    return (BOOL)v3;
  }

  __break(1u);
  return result;
}

        goto LABEL_36;
      }

      if (!v18)
      {
        __nwlog_obj();
        unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int64x2_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint32_t v21 = "nw_storage_provider_for_type";
          int64x2_t v12 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int64x2_t v11 = type;
      uint64_t v15 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint32_t v21 = "nw_storage_provider_for_type";
          int64x2_t v12 = "%{public}s called with null storage, no backtrace";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v15) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      uint32_t v21 = "nw_storage_provider_for_type";
      uint64_t v22 = 2082;
      v23 = backtrace_string;
      unsigned int v16 = "%{public}s called with null storage, dumping backtrace:%{public}s";
      goto LABEL_24;
    }
  }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (!v36) {
          goto LABEL_58;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWParameters initWithCoder:]";
        unint64_t v29 = "%{public}s NWUtilsCreateXPCDictionaryFromNSDictionary failed, no backtrace";
      }

      v42 = v27;
      v43 = v35;
      goto LABEL_57;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v55 = "-[NWParameters initWithCoder:]";
    uint32_t v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v21, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWParameters initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed";
LABEL_44:
        v40 = v22;
        v41 = v23;
        goto LABEL_45;
      }

      if (!v51)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWParameters initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed, backtrace limit exceeded";
        goto LABEL_44;
      }

      unint64_t v30 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      v31 = type;
      __int16 v32 = os_log_type_enabled(v22, type);
      if (!v30)
      {
        if (!v32)
        {
LABEL_46:

          if (!v21) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }

        *(_DWORD *)buf = 136446210;
        v55 = "-[NWParameters initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed, no backtrace";
        v40 = v22;
        v41 = v31;
LABEL_45:
        _os_log_impl(&dword_181A5C000, v40, v41, v24, buf, 0xCu);
        goto LABEL_46;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        v55 = "-[NWParameters initWithCoder:]";
        v56 = 2082;
        v57 = v30;
        _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s decodeObjectOfClasses:forKey failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v30);
    }

    if (!v21)
    {
LABEL_21:
      unint64_t v19 = 0LL;
LABEL_40:

      goto LABEL_41;
    }
  }

    unint64_t v29 = v14 - v28;
    if (v27 > v14 - v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v30 = (os_log_s *)gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      goto LABEL_404;
    }

    __int16 v32 = (char *)v13 + v28;
    v33 = v29 >= v27;
    __int16 v34 = v29 - v27;
    if (!v33)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446978;
      v204 = "nw_http_copy_metadata_from_binary_message";
      v205 = 2082;
      v206 = "remaining";
      v207 = 2048;
      v208 = v27;
      v209 = 2048;
      v210 = v34;
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v201 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v36 = (os_log_s *)__nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_216;
        }
        *(_DWORD *)buf = 136446978;
        v204 = "nw_http_copy_metadata_from_binary_message";
        v205 = 2082;
        v206 = "remaining";
        v207 = 2048;
        v208 = v27;
        v209 = 2048;
        v210 = v34;
        v38 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
      }

      else if (v201)
      {
        v72 = (char *)__nw_create_backtrace_string();
        uint64_t v36 = (os_log_s *)__nwlog_obj();
        v37 = type;
        v73 = os_log_type_enabled(v36, type);
        if (v72)
        {
          if (v73)
          {
            *(_DWORD *)buf = 136447234;
            v204 = "nw_http_copy_metadata_from_binary_message";
            v205 = 2082;
            v206 = "remaining";
            v207 = 2048;
            v208 = v27;
            v209 = 2048;
            v210 = v34;
            v211 = 2082;
            v212 = v72;
            _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v72);
          goto LABEL_216;
        }

        if (!v73)
        {
LABEL_216:
          if (v35) {
            free(v35);
          }
          goto LABEL_218;
        }

        *(_DWORD *)buf = 136446978;
        v204 = "nw_http_copy_metadata_from_binary_message";
        v205 = 2082;
        v206 = "remaining";
        v207 = 2048;
        v208 = v27;
        v209 = 2048;
        v210 = v34;
        v38 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
      }

      else
      {
        uint64_t v36 = (os_log_s *)__nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_216;
        }
        *(_DWORD *)buf = 136446978;
        v204 = "nw_http_copy_metadata_from_binary_message";
        v205 = 2082;
        v206 = "remaining";
        v207 = 2048;
        v208 = v27;
        v209 = 2048;
        v210 = v34;
        v38 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v36, v37, v38, buf, 0x2Au);
      goto LABEL_216;
    }

    if (!v34) {
      goto LABEL_218;
    }
    v58 = &v32[v27];
    v27 = v32[v27];
    if (v27 <= 0x3F)
    {
      v59 = 1LL;
      goto LABEL_116;
    }

    if (v27 >> 6 == 2)
    {
      if (v34 < 4) {
        goto LABEL_218;
      }
      v27 = bswap32(*(_DWORD *)v58 & 0xFFFFFF7F);
      v59 = 4LL;
    }

    else
    {
      if (v27 >> 6 == 1)
      {
        if (v34 >= 2)
        {
          v27 = bswap32(*(_WORD *)v58 & 0xFFBF) >> 16;
          v59 = 2LL;
          goto LABEL_116;
        }

  __break(1u);
  return result;
}

    unsigned int v16 = 0LL;
    *(_DWORD *)(a2 + 432) = 0;
    *(_OWORD *)(a2 + 400) = 0u;
    *(_OWORD *)(a2 + 416) = 0u;
    *(_OWORD *)(a2 + 368) = 0u;
    *(_OWORD *)(a2 + 384) = 0u;
    *(_OWORD *)(a2 + 336) = 0u;
    *(_OWORD *)(a2 + 352) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    goto LABEL_43;
  }

  uint64_t v15 = 436LL;
  while (*(_BYTE *)a2)
  {
    ++a2;
    if (!--v15) {
      goto LABEL_42;
    }
  }

  if (v15 < 2)
  {
LABEL_41:
    *(_BYTE *)a2 = 0;
  }

  else
  {
    int v17 = 0LL;
    while (1)
    {
      unint64_t v18 = v14[v17];
      *(_BYTE *)(a2 + v17) = v18;
      if (!v18) {
        break;
      }
      --v15;
      ++v17;
      if (v15 <= 1)
      {
        a2 += v17;
        goto LABEL_41;
      }
    }
  }

    free(backtrace_string);
    goto LABEL_54;
  }

  activeOutgoingRequests = (uint64_t)v3->activeOutgoingRequests;
  if (!activeOutgoingRequests)
  {
    __nwlog_obj();
    int64x2_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
    unint64_t v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    unint64_t v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int64x2_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null serviceConnector->activeOutgoingRequests",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    if (!v30)
    {
      __nwlog_obj();
      int64x2_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int64x2_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v20 = type;
    uint32_t v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (v4)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    v33 = __Block_byref_object_copy__49049;
    __int16 v34 = __Block_byref_object_dispose__49050;
    unint64_t v35 = 0LL;
    v27[0] = MEMORY[0x1895F87A8];
    v27[1] = 3221225472LL;
    v27[2] = ___ZL55nw_service_connector_copy_active_request_for_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connection_block_invoke;
    v27[3] = &unk_189BC7820;
    int v28 = v4;
    unint64_t v29 = buf;
    nw_dictionary_apply(activeOutgoingRequests, (uint64_t)v27);
    unint64_t v7 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
  unint64_t v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  unint64_t v30 = 0;
  if (__nwlog_fault(v10, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int64x2_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unsigned int v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null connection", buf, 0xCu);
      }

  if (v10) {
LABEL_36:
  }
    free(v10);
LABEL_46:
}

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v27[0] = MEMORY[0x1895F87A8];
  v27[1] = 3221225472LL;
  v27[2] = __nw_ws_options_set_client_request_handler_block_invoke;
  v27[3] = &unk_189BC6710;
  int v28 = v6;
  unint64_t v29 = v7;
  nw_protocol_options_access_handle(v5, v27);

LABEL_5:
}

    free(v23);
    if (!v13) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v8 = v6;
  nw_framer_message_set_value(v5, "client_queue", v8, &__block_literal_global_50665);
  unsigned int v9 = nw_dictionary_create();
  unint64_t v10 = _Block_copy(v7);
  nw_dictionary_set_value((uint64_t)v9, "handler", v10);

  int64x2_t v11 = v9;
  dispose_value[0] = MEMORY[0x1895F87A8];
  dispose_value[1] = 3221225472LL;
  dispose_value[2] = __nw_ws_metadata_set_pong_handler_block_invoke_2;
  dispose_value[3] = &unk_189BC09B8;
  __int16 v32 = v8;
  nw_framer_message_set_value(v5, "pong_handler", v11, dispose_value);

LABEL_5:
}

      unint64_t v29 = *(uint32x4_t *)v9->i8;
      unint64_t v30 = *(uint32x4_t *)v9[2].i8;
      v9 += 4;
      v8 += vaddvq_s64( vaddq_s64( (int64x2_t)vaddl_u32(*(uint32x2_t *)v29.i8, *(uint32x2_t *)v30.i8),  (int64x2_t)vaddl_high_u32(v29, v30)));
      if ((v6 & 0x10) == 0)
      {
LABEL_13:
        if ((v6 & 8) == 0) {
          goto LABEL_14;
        }
        goto LABEL_37;
      }

    free(v21);
    if (!v11) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  uint64_t v8 = v6;
  unsigned int v9 = -[nw_endpoint hostname](v8, "hostname");

  nw_resolver_config_add_name_server(v3, v9);
LABEL_5:
}

  if (v20) {
    free(v20);
  }
LABEL_18:
}

    free(v16);
    if (!v6) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  *((void *)v3 + 3) = a2;
LABEL_5:
}

  if (v7) {
    free(v7);
  }
  unsigned int v3 = 0LL;
LABEL_5:

  return v3;
}

        free(backtrace_string);
      }
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_activity_get_activation_time";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v6, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_get_activation_time";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
        }
      }

      else if (v24)
      {
        int64x2_t v13 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v14 = type;
        uint64_t v15 = os_log_type_enabled(v7, type);
        if (v13)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            int v28 = 2082;
            unint64_t v29 = v13;
            _os_log_impl( &dword_181A5C000,  v7,  v14,  "%{public}s called with null activity, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v13);
          goto LABEL_54;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_get_activation_time";
          _os_log_impl(&dword_181A5C000, v7, v14, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint32_t v21 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_get_activation_time";
          _os_log_impl( &dword_181A5C000,  v7,  v21,  "%{public}s called with null activity, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      goto LABEL_53;
    }
  }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (!v36) {
          goto LABEL_58;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWInterface initWithCoder:]";
        unint64_t v29 = "%{public}s NWUtilsCreateXPCDictionaryFromNSDictionary failed, no backtrace";
      }

      v42 = v27;
      v43 = v35;
      goto LABEL_57;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v55 = "-[NWInterface initWithCoder:]";
    uint32_t v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v21, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWInterface initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed";
LABEL_44:
        v40 = v22;
        v41 = v23;
        goto LABEL_45;
      }

      if (!v51)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWInterface initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed, backtrace limit exceeded";
        goto LABEL_44;
      }

      unint64_t v30 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      v31 = type;
      __int16 v32 = os_log_type_enabled(v22, type);
      if (!v30)
      {
        if (!v32)
        {
LABEL_46:

          if (!v21) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }

        *(_DWORD *)buf = 136446210;
        v55 = "-[NWInterface initWithCoder:]";
        v24 = "%{public}s decodeObjectOfClasses:forKey failed, no backtrace";
        v40 = v22;
        v41 = v31;
LABEL_45:
        _os_log_impl(&dword_181A5C000, v40, v41, v24, buf, 0xCu);
        goto LABEL_46;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        v55 = "-[NWInterface initWithCoder:]";
        v56 = 2082;
        v57 = v30;
        _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s decodeObjectOfClasses:forKey failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v30);
    }

    if (!v21)
    {
LABEL_21:
      unint64_t v19 = 0LL;
LABEL_40:

      goto LABEL_41;
    }

    input_finished(v12, a1);
    return;
  }

  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      v64 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        v65 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
        v66 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        v95 = "nw_protocol_http3_stream_input_finished";
        v96 = 2082;
        v97 = handle + 636;
        v98 = 2080;
        v99 = " ";
        v100 = 1024;
        v101 = v65;
        v102 = 2048;
        v103 = v66;
        _os_log_impl(&dword_181A5C000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }

  int64x2_t v12 = a1->default_input_handler;
  if (v12)
  {
    v25 = v12->callbacks;
    if (v25)
    {
      input_finished = (void (*)(nw_protocol *, nw_protocol *))v25->input_finished;
      if (input_finished) {
        goto LABEL_35;
      }
    }
  }

  __nwlog_obj();
  uint64_t v36 = a1->default_input_handler;
  v37 = "invalid";
  if (v36)
  {
    v38 = v36->identifier;
    if (v38) {
      v37 = (const char *)v38;
    }
  }

  *(_DWORD *)buf = 136446466;
  v95 = "nw_protocol_http3_stream_input_finished";
  v96 = 2082;
  v97 = (char *)v37;
  unint64_t v18 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v92 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v19 = (os_log_s *)__nwlog_obj();
    uint64_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_165;
    }
    v39 = a1->default_input_handler;
    uint64_t v22 = "invalid";
    if (v39)
    {
      v40 = v39->identifier;
      if (v40) {
        uint64_t v22 = (const char *)v40;
      }
    }

    goto LABEL_29;
  }

  if (!v92)
  {
    unint64_t v19 = (os_log_s *)__nwlog_obj();
    uint64_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_165;
    }
    v75 = a1->default_input_handler;
    v76 = "invalid";
    if (v75)
    {
      v77 = v75->identifier;
      if (v77) {
        v76 = (const char *)v77;
      }
    }

    goto LABEL_123;
  }

  v50 = (char *)__nw_create_backtrace_string();
  unint64_t v19 = (os_log_s *)__nwlog_obj();
  uint64_t v20 = type;
  v51 = os_log_type_enabled(v19, type);
  if (!v50)
  {
    if (!v51) {
      goto LABEL_165;
    }
    v84 = a1->default_input_handler;
    v85 = "invalid";
    if (v84)
    {
      v86 = v84->identifier;
      if (v86) {
        v85 = (const char *)v86;
      }
    }

    goto LABEL_163;
  }

  if (v51)
  {
    v52 = a1->default_input_handler;
    v53 = "invalid";
    if (v52)
    {
      v54 = v52->identifier;
      if (v54) {
        v53 = (const char *)v54;
      }
    }

    *(_DWORD *)buf = 136446722;
    v95 = "nw_protocol_http3_stream_input_finished";
    v96 = 2082;
    v97 = (char *)v53;
    v98 = 2082;
    v99 = v50;
    _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v50);
LABEL_165:
  if (v18)
  {
LABEL_166:
    v87 = (char *)v18;
    goto LABEL_167;
  }

    free(backtrace_string);
    goto LABEL_49;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  unint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    uint32_t v21 = "nw_protocol_http3_stream_add_listen_handler";
    uint64_t v8 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_48;
  }

    free(backtrace_string);
    goto LABEL_49;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  unint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    uint32_t v21 = "nw_protocol_http3_stream_remove_listen_handler";
    uint64_t v8 = "%{public}s called with null http3_stream->http3_connection";
    goto LABEL_48;
  }

      free(v14);
      if (!v8) {
        return 0LL;
      }
      goto LABEL_53;
    }

    unsigned int v9 = (os_log_s *)__nwlog_obj();
    unint64_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_http_early_data_get_output_frames";
    int64x2_t v11 = "%{public}s called with null http_early_data";
LABEL_51:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_52;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_http_early_data_get_output_frames";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v9 = (os_log_s *)__nwlog_obj();
      unint64_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_http_early_data_get_output_frames";
      int64x2_t v11 = "%{public}s called with null return_array";
      goto LABEL_51;
    }

    if (!v19)
    {
      unsigned int v9 = (os_log_s *)__nwlog_obj();
      unint64_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_http_early_data_get_output_frames";
      int64x2_t v11 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_51;
    }

    unint64_t v14 = (char *)__nw_create_backtrace_string();
    unsigned int v9 = (os_log_s *)__nwlog_obj();
    unint64_t v10 = type;
    int v17 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v17) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_protocol_http_early_data_get_output_frames";
      int64x2_t v11 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_51;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_protocol_http_early_data_get_output_frames";
      v23 = 2082;
      v24 = v14;
      unsigned int v16 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  if ((handle[256] & 4) == 0) {
    return nw_protocol_get_output_frames((uint64_t)a1->output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
  }
  if ((handle[198] & 1) == 0 && gLogDatapath)
  {
    unint64_t v18 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v22 = "nw_protocol_http_early_data_get_output_frames";
      v23 = 2082;
      v24 = handle + 114;
      v25 = 2080;
      v26 = " ";
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%snot vending output frames, still replaying early data",  buf,  0x20u);
    }
  }

  return 0LL;
}

      free(v10);
      if (!v4) {
        return;
      }
LABEL_51:
      free(v4);
      return;
    }

    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_protocol_http_early_data_error";
    unint64_t v7 = "%{public}s called with null http_early_data";
LABEL_49:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_50;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_protocol_http_early_data_error";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    unint64_t v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      uint64_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_protocol_http_early_data_error";
      unint64_t v7 = "%{public}s called with null other_protocol";
      goto LABEL_49;
    }

    if (!v14)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      uint64_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_protocol_http_early_data_error";
      unint64_t v7 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_49;
    }

    unint64_t v10 = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    int64x2_t v13 = os_log_type_enabled(v5, type);
    if (!v10)
    {
      if (!v13) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_protocol_http_early_data_error";
      unint64_t v7 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_49;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      int v17 = "nw_protocol_http_early_data_error";
      unint64_t v18 = 2082;
      unint64_t v19 = v10;
      int64x2_t v12 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  if (a3 == 35 && (handle[256] & 2) != 0)
  {
    handle[256] |= 0x10u;
    *((void *)handle + 31) = a2;
  }

  else
  {
    nw_protocol_error(*((void **)handle + 6), (uint64_t)a2);
  }

  if (v8) {
    free(v8);
  }
LABEL_5:
}

      free(backtrace_string);
      goto LABEL_54;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v10 = (os_log_s *)gLogObj;
    int64x2_t v11 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_54;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "nw_socket_replace_input_handler";
    int64x2_t v12 = "%{public}s called with null old_input_handler";
LABEL_53:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_54;
  }

  if (!a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "nw_socket_replace_input_handler";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v10 = (os_log_s *)gLogObj;
      int64x2_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "nw_socket_replace_input_handler";
      int64x2_t v12 = "%{public}s called with null new_input_handler";
      goto LABEL_53;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v10 = (os_log_s *)gLogObj;
      int64x2_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "nw_socket_replace_input_handler";
      int64x2_t v12 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v10 = (os_log_s *)gLogObj;
    int64x2_t v11 = type;
    uint64_t v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v20) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "nw_socket_replace_input_handler";
      int64x2_t v12 = "%{public}s called with null new_input_handler, no backtrace";
      goto LABEL_53;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v34 = "nw_socket_replace_input_handler";
      unint64_t v35 = 2082;
      uint64_t v36 = backtrace_string;
      uint64_t v15 = "%{public}s called with null new_input_handler, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  if ((nw_protocol *)a1[2].identifier == a2)
  {
    a1[2].identifier = a3;
    if (!*(void *)&a3->level)
    {
      *(void *)&a3->level = a1;
      callbacks = a1[1].callbacks;
      if (callbacks) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
    }

    int v17 = *(nw_protocol_callbacks **)&a3->name[24];
    if (v17
      && (supports_external_data = (uint64_t (*)(nw_protocol_identifier *))v17->supports_external_data) != 0LL)
    {
      if (*(_UNKNOWN **)a3[1].name == &nw_protocol_ref_counted_handle)
      {
        uint32_t v21 = *(nw_protocol_callbacks **)&a3[2].name[8];
        if (v21) {
          *(void *)&a3[2].name[8] = (char *)&v21->add_input_handler + 1;
        }
        unint64_t v19 = supports_external_data(a3);
        if (*(_UNKNOWN **)a3[1].name == &nw_protocol_ref_counted_handle)
        {
          v25 = *(nw_protocol_callbacks **)&a3[2].name[8];
          if (v25)
          {
            v26 = (nw_protocol_callbacks *)((char *)v25 - 1);
            *(void *)&a3[2].name[8] = v26;
            if (!v26)
            {
              v27 = *(void (***)(void))&a3[1].name[24];
              if (v27)
              {
                *(void *)&a3[1].name[24] = 0LL;
                v27[2](v27);
                _Block_release(v27);
              }

              if ((a3[1].level & 1) != 0)
              {
                int v28 = *(const void **)&a3[1].name[24];
                if (v28) {
                  _Block_release(v28);
                }
              }

              free(a3);
            }
          }
        }
      }

      else
      {
        unint64_t v19 = supports_external_data(a3);
      }

      uint64_t v22 = &a1[6].flow_id[13];
      if (((((*(_WORD *)&a1[6].flow_id[13] & 0x1000) == 0) ^ v19) & 1) != 0) {
        return 1LL;
      }
      nw_socket_release_frame_array((nw_frame_array_s *)&a1[4].handle);
      v23 = *(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16);
      if (v19) {
        v24 = 4096;
      }
      else {
        v24 = 0;
      }
    }

    else
    {
      uint64_t v22 = &a1[6].flow_id[13];
      if ((*(_WORD *)&a1[6].flow_id[13] & 0x1000) == 0) {
        return 1LL;
      }
      nw_socket_release_frame_array((nw_frame_array_s *)&a1[4].handle);
      v24 = 0;
      v23 = *(unsigned __int16 *)v22 | (a1[6].flow_id[15] << 16);
    }

    v22[2] = BYTE2(v23);
    *(_WORD *)uint64_t v22 = v23 & 0xEFFF | v24;
    return 1LL;
  }

  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) != 0) {
    return 0LL;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  uint64_t v6 = (os_log_s *)gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    identifier = a1[2].identifier;
    *(_DWORD *)buf = 136446978;
    __int16 v34 = "nw_socket_replace_input_handler";
    unint64_t v35 = 2082;
    uint64_t v36 = (char *)&a1[6].identifier + 4;
    v37 = 2048;
    v38 = identifier;
    v39 = 2048;
    v40 = a2;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Old input handler does not match (%p != %p)",  buf,  0x2Au);
    return 0LL;
  }

  return result;
}

  if (v6) {
    free(v6);
  }
}

  if (v5) {
    free(v5);
  }
}

    if (!v24) {
      return 0LL;
    }
    unint64_t v35 = v24;
LABEL_37:
    free(v35);
    return 0LL;
  }

  if (!v18)
  {
    v62 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v82 = "strict_calloc";
    v63 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v63);
    if (result) {
      goto LABEL_208;
    }
    free(v63);
    v27 = v77;
    unint64_t v18 = 0LL;
    v25 = a10;
  }

  unint64_t v30 = calloc(1uLL, v18);
  if (!v30)
  {
    v64 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v82 = "strict_calloc";
    v83 = 2048;
    v84 = 1LL;
    v85 = 2048;
    v86 = v18;
    v65 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v65);
    if (result) {
      goto LABEL_208;
    }
    free(v65);
    v27 = v77;
    unint64_t v18 = __size;
    v25 = a10;
  }

  v31 = v78 - v74;
  memcpy(v30, &v26[v27 + v78 - v74], v18);
  if (v78 == v74)
  {
    v66 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v82 = "strict_calloc";
    v67 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v67);
    if (result) {
      goto LABEL_208;
    }
    free(v67);
    v25 = a10;
  }

  __int16 v32 = calloc(1uLL, v31);
  if (!v32)
  {
    v68 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v82 = "strict_calloc";
    v83 = 2048;
    v84 = 1LL;
    v85 = 2048;
    v86 = v78 - v74;
    v69 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v69);
    if (result) {
      goto LABEL_208;
    }
    free(v69);
    v25 = a10;
  }

  v33 = cchpke_responder_decrypt();
  if (v30) {
    free(v30);
  }
  if (v33)
  {
    __int16 v34 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v82 = "nw_http_decrypt_oblivious_request";
      v83 = 1024;
      LODWORD(v84) = v33;
      _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", buf, 0x12u);
    }

    if (v32) {
      free(v32);
    }
    goto LABEL_35;
  }

  *a6 = v24;
  *a7 = 96LL;
  v37 = v77;
  if (!v77)
  {
    v70 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v82 = "strict_calloc";
    v71 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v71);
    if (result) {
      goto LABEL_208;
    }
    free(v71);
    v37 = 0LL;
    v25 = a10;
  }

  v38 = calloc(1uLL, v37);
  v39 = a9;
  if (v38)
  {
LABEL_42:
    *a8 = v38;
    memcpy(v38, v26, v37);
    *v39 = v37;
    void *v25 = v31;
    return (BOOL)v32;
  }

  v72 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v82 = "strict_calloc";
  v83 = 2048;
  v84 = 1LL;
  v85 = 2048;
  v86 = v37;
  v73 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v73);
  if (!result)
  {
    free(v73);
    v37 = v77;
    v39 = a9;
    v25 = a10;
    goto LABEL_42;
  }

    free(v18);
    if (!v8) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  nw_protocol_options_add_proxy_next_hop(v6, v5);
LABEL_5:
}

      free(v16);
      goto LABEL_36;
    }
  }

  if (v19) {
    free(v19);
  }
LABEL_18:
}

    if (v14) {
      free(v14);
    }
    uint64_t v6 = 0LL;
    goto LABEL_9;
  }

  is_viable = nw_path_is_viable(v3);
  if (v4 && v4[94] == 1 && (v3[66] != 4 || !v3[67]))
  {
    if (is_viable && v3[94] != 2)
    {
      uint64_t v8 = nw_path_copy_connected_interface(v3);
      unsigned int v9 = v8;
      uint64_t v6 = 0LL;
      if (v3[66] != 6 && v8)
      {
        unint64_t v10 = v8;
        int64x2_t v11 = *((_DWORD *)v10 + 24);

        if (v11 == 4)
        {
          uint64_t v6 = 0LL;

          goto LABEL_9;
        }

        int64x2_t v12 = *((_DWORD *)v10 + 2);
        uint64_t v6 = v12 != nw_path_get_interface_index(v4);
      }

      goto LABEL_9;
    }

    uint64_t v6 = 1LL;
  }

  else
  {
    uint64_t v6 = v3[94] == 3 && !is_viable;
  }

    if (!v12)
    {
LABEL_37:
      v33 = 0LL;
      unsigned int v9 = v10;
      goto LABEL_38;
    }

    if (v12) {
      free(v12);
    }
    goto LABEL_13;
  }

  if (uuid_is_null(v1 + 84))
  {
LABEL_13:
    uint64_t v8 = 0LL;
    goto LABEL_14;
  }

  unsigned int v3 = v2;
  uint64_t v4 = (void *)*((void *)v3 + 3);
  if (!v4
    || (*(void *)length = 0LL, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) == 0LL)
    || *(void *)length < 0xD8uLL
    || (uint64_t v6 = data, *(void *)length != data[53] + 216LL)
    || ((data[52] & 0xE080) != 0 ? (unint64_t v7 = (data[52] & 0x13) == 1) : (unint64_t v7 = 1), v7))
  {

    goto LABEL_13;
  }

  if (v6[53] < 0xCCu) {
    goto LABEL_13;
  }
  unint64_t v10 = v6[54];
  if (v10 >= 5) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = v10;
  }
LABEL_14:

  return v8;
}

    free(backtrace_string);
    goto LABEL_49;
  }

  unsigned int v9 = (os_log_s *)__nwlog_obj();
  unint64_t v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_http_alt_svc_remove_input_handler";
    int64x2_t v11 = "%{public}s called with null input_protocol";
    goto LABEL_48;
  }

      free(v11);
      if (!v5) {
        return 0LL;
      }
      goto LABEL_53;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_http_alt_svc_copy_info";
    uint64_t v8 = "%{public}s called with null http_alt_svc";
LABEL_51:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_52;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_http_alt_svc_copy_info";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    unsigned int v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      unint64_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v19 = "nw_protocol_http_alt_svc_copy_info";
      uint64_t v8 = "%{public}s called with null type";
      goto LABEL_51;
    }

    if (!v16)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      unint64_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v19 = "nw_protocol_http_alt_svc_copy_info";
      uint64_t v8 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_51;
    }

    int64x2_t v11 = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = type;
    unint64_t v14 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v14) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v19 = "nw_protocol_http_alt_svc_copy_info";
      uint64_t v8 = "%{public}s called with null type, no backtrace";
      goto LABEL_51;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v19 = "nw_protocol_http_alt_svc_copy_info";
      uint64_t v20 = 2082;
      uint32_t v21 = v11;
      int64x2_t v13 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  unsigned int v3 = *(void *)(a1 + 32);
  if (v3) {
    return nw_protocol_common_copy_info(v3, a2);
  }
  if ((*(_BYTE *)(v2 + 198) & 1) == 0 && gLogDatapath)
  {
    uint64_t v15 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      unint64_t v19 = "nw_protocol_http_alt_svc_copy_info";
      uint64_t v20 = 2082;
      uint32_t v21 = (char *)(v2 + 114);
      uint64_t v22 = 2080;
      v23 = " ";
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scopy_info requires an output handler",  buf,  0x20u);
    }
  }

  return 0LL;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}
}

  __break(1u);
  return result;
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_36;
  }

  if (data)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 0x40000000LL;
    applier[2] = __nw_string_append_dispatch_data_block_invoke;
    applier[3] = &__block_descriptor_tmp_4_76110;
    applier[4] = a1;
    dispatch_data_apply(data, applier);
    if (*(char *)(a1 + 63) < 0)
    {
      unsigned int v3 = *(void *)(a1 + 40);
      uint64_t v4 = *(void *)(a1 + 48);
    }

    else
    {
      unsigned int v3 = a1 + 40;
      uint64_t v4 = *(unsigned __int8 *)(a1 + 63);
    }

    *(void *)(a1 + 24) = v3;
    *(void *)(a1 + 32) = v4;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v17 = "nw_string_append_dispatch_data";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  uint64_t v15 = OS_LOG_TYPE_ERROR;
  unint64_t v14 = 0;
  if (v15 == OS_LOG_TYPE_FAULT)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = v15;
    if (!os_log_type_enabled(v6, v15)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_string_append_dispatch_data";
    uint64_t v8 = "%{public}s called with null data";
    goto LABEL_35;
  }

  if (!v14)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    unint64_t v7 = v15;
    if (!os_log_type_enabled(v6, v15)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_string_append_dispatch_data";
    uint64_t v8 = "%{public}s called with null data, backtrace limit exceeded";
    goto LABEL_35;
  }

  int64x2_t v11 = (char *)__nw_create_backtrace_string();
  uint64_t v6 = (os_log_s *)__nwlog_obj();
  unint64_t v7 = v15;
  int64x2_t v12 = os_log_type_enabled(v6, v15);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    int v17 = "nw_string_append_dispatch_data";
    uint64_t v8 = "%{public}s called with null data, no backtrace";
    goto LABEL_35;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    int v17 = "nw_string_append_dispatch_data";
    unint64_t v18 = 2082;
    unint64_t v19 = v11;
    _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v11);
  if (v5) {
    goto LABEL_37;
  }
}

      free(v18);
      if (!v12) {
        return 0LL;
      }
      goto LABEL_51;
    }

    int64x2_t v13 = (os_log_s *)__nwlog_obj();
    unint64_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446210;
    v25 = "nw_http_messaging_add_to_version_specific_protocol";
    uint64_t v15 = "%{public}s called with null parameters";
LABEL_49:
    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_50;
  }

  uint64_t v5 = nw_parameters_copy_protocol_options_legacy(parameters, (nw_protocol *)a1);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_http_messaging_add_to_version_specific_protocol";
    int64x2_t v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    uint64_t v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int64x2_t v13 = (os_log_s *)__nwlog_obj();
      unint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      v25 = "nw_http_messaging_add_to_version_specific_protocol";
      uint64_t v15 = "%{public}s called with null options";
      goto LABEL_49;
    }

    if (!v22)
    {
      int64x2_t v13 = (os_log_s *)__nwlog_obj();
      unint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      v25 = "nw_http_messaging_add_to_version_specific_protocol";
      uint64_t v15 = "%{public}s called with null options, backtrace limit exceeded";
      goto LABEL_49;
    }

    unint64_t v18 = (char *)__nw_create_backtrace_string();
    int64x2_t v13 = (os_log_s *)__nwlog_obj();
    unint64_t v14 = type;
    uint32_t v21 = os_log_type_enabled(v13, type);
    if (!v18)
    {
      if (!v21) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      v25 = "nw_http_messaging_add_to_version_specific_protocol";
      uint64_t v15 = "%{public}s called with null options, no backtrace";
      goto LABEL_49;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_http_messaging_add_to_version_specific_protocol";
      v26 = 2082;
      v27 = v18;
      uint64_t v20 = "%{public}s called with null options, dumping backtrace:%{public}s";
      goto LABEL_34;
    }

    goto LABEL_35;
  }

  uint64_t v6 = v5;
  if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72514);
  }
  unint64_t v7 = (id)nw_protocol_copy_http_messaging_definition_definition;
  uint64_t v8 = *(void *)(a1 + 152);
  unsigned int v9 = v6;
  *((void *)v9 + 2) = v8;

  if (v7) {
    os_release(v7);
  }
  nw_protocol_set_output_handler(a2, 0LL);
  unint64_t v10 = nw_protocol_add_input_handler(*(void *)(a1 + 152), a2);
  os_release(v9);
  return v10;
}

  if (v9) {
LABEL_36:
  }
    free(v9);
LABEL_37:
}

    free(v23);
    if (!v13) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  *(void *)type = 0LL;
  v37 = type;
  v39 = 0;
  v38 = 0x2020000000LL;
  __int16 v32 = 0LL;
  v33 = &v32;
  unint64_t v35 = 0;
  __int16 v34 = 0x2020000000LL;
  unint64_t v7 = MEMORY[0x1895F87A8];
  v31[0] = MEMORY[0x1895F87A8];
  v31[1] = 3221225472LL;
  v31[2] = __nw_establishment_report_get_accurate_ecn_state_block_invoke;
  v31[3] = &unk_189BC7108;
  v31[4] = type;
  v31[5] = &v32;
  uint64_t v8 = v5;
  unsigned int v9 = v31;
  unint64_t v10 = (unsigned __int8 *)v8[8];
  *(void *)buf = v7;
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = __nw_establishment_report_enumerate_protocol_l4s_state_block_invoke;
  v41 = &unk_189BC8628;
  int64x2_t v11 = v9;
  v42 = v11;
  nw_array_apply(v10, (uint64_t)buf);

  *a2 = *((_DWORD *)v37 + 6);
  *a3 = *((_DWORD *)v33 + 6);
  _Block_object_dispose(&v32, 8);
  _Block_object_dispose(type, 8);
LABEL_5:
}

  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __nw_connection_shares_protocol_stack_block_invoke_5;
  block[3] = &unk_189BC71E8;
  uint64_t v20 = *(dispatch_queue_s **)(a1 + 48);
  v66 = *(id *)(a1 + 56);
  v67 = (char)v13;
  dispatch_async(v20, block);
}

    free(v23);
    if (!v13) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v31[0] = MEMORY[0x1895F87A8];
  v31[1] = 3221225472LL;
  v31[2] = __nw_agent_set_assert_handlers_block_invoke;
  v31[3] = &unk_189BC7610;
  unsigned int v9 = (os_unfair_lock_s *)v5;
  v31[4] = v9;
  unint64_t v10 = v6;
  v31[5] = v10;
  int64x2_t v11 = v8;
  v31[6] = v11;
  os_unfair_lock_lock(v9 + 2);
  __nw_agent_set_assert_handlers_block_invoke((uint64_t)v31);
  os_unfair_lock_unlock(v9 + 2);

LABEL_5:
}

    free(v25);
    if (!v15) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  int64x2_t v13 = (dispatch_queue_s *)v9[27];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __nw_agent_add_resolve_handlers_block_invoke;
  block[3] = &unk_189BC7698;
  __int16 v34 = v9;
  v37 = a2;
  v38 = a3;
  unint64_t v35 = v10;
  uint64_t v36 = v12;
  dispatch_async(v13, block);

LABEL_5:
}

    free(v23);
    if (!v13) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v31[0] = MEMORY[0x1895F87A8];
  v31[1] = 3221225472LL;
  v31[2] = __nw_agent_set_browse_handlers_block_invoke;
  v31[3] = &unk_189BC7610;
  unsigned int v9 = (os_unfair_lock_s *)v5;
  v31[4] = v9;
  unint64_t v10 = v6;
  v31[5] = v10;
  int64x2_t v11 = v8;
  v31[6] = v11;
  os_unfair_lock_lock(v9 + 2);
  __nw_agent_set_browse_handlers_block_invoke((uint64_t)v31);
  os_unfair_lock_unlock(v9 + 2);

LABEL_5:
}

    free(v29);
    if (!v19) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v37[0] = MEMORY[0x1895F87A8];
  v37[1] = 3221225472LL;
  v37[2] = __nw_agent_set_flow_handlers_block_invoke;
  v37[3] = &unk_189BC76C0;
  uint64_t v15 = (os_unfair_lock_s *)v11;
  v37[4] = v15;
  v38 = a2;
  v39 = a3;
  v40 = a4;
  unsigned int v16 = v12;
  v37[5] = v16;
  int v17 = v14;
  v37[6] = v17;
  os_unfair_lock_lock(v15 + 2);
  __nw_agent_set_flow_handlers_block_invoke((uint64_t)v37);
  os_unfair_lock_unlock(v15 + 2);

LABEL_5:
}

    free(v23);
    if (!v13) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }

  v31[0] = MEMORY[0x1895F87A8];
  v31[1] = 3221225472LL;
  v31[2] = __nw_agent_set_group_handlers_block_invoke;
  v31[3] = &unk_189BC7610;
  unsigned int v9 = (os_unfair_lock_s *)v5;
  v31[4] = v9;
  unint64_t v10 = v6;
  v31[5] = v10;
  int64x2_t v11 = v8;
  v31[6] = v11;
  os_unfair_lock_lock(v9 + 2);
  __nw_agent_set_group_handlers_block_invoke((uint64_t)v31);
  os_unfair_lock_unlock(v9 + 2);

LABEL_5:
}

    if (!v7) {
      return;
    }
    __int16 v32 = (char *)v7;
LABEL_44:
    free(v32);
    return;
  }

  if (a2 >= 0x100)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __srca = 136446722;
    uint64_t v36 = "nw_log_ring_append";
    v37 = 2048;
    v38 = a2;
    v39 = 2048;
    v40 = 255LL;
    int64x2_t v12 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v12, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int64x2_t v13 = (os_log_s *)gLogObj;
        unint64_t v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          __srca = 136446722;
          uint64_t v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = 255LL;
          uint64_t v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu";
LABEL_41:
          _os_log_impl(&dword_181A5C000, v13, v14, v15, (uint8_t *)&__srca, 0x20u);
        }
      }

      else if (v33)
      {
        int v28 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int64x2_t v13 = (os_log_s *)gLogObj;
        unint64_t v14 = type;
        unint64_t v29 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v28)
        {
          if (v29)
          {
            __srca = 136446978;
            uint64_t v36 = "nw_log_ring_append";
            v37 = 2048;
            v38 = a2;
            v39 = 2048;
            v40 = 255LL;
            v41 = 2082;
            v42 = v28;
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, dumping backtrace:%{public}s",  (uint8_t *)&__srca,  0x2Au);
          }

          free(v28);
          goto LABEL_42;
        }

        if (v29)
        {
          __srca = 136446722;
          uint64_t v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = 255LL;
          uint64_t v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, no backtrace";
          goto LABEL_41;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int64x2_t v13 = (os_log_s *)gLogObj;
        unint64_t v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          __srca = 136446722;
          uint64_t v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = 255LL;
          uint64_t v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
    }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0
        || !*((_BYTE *)v8 + 1537))
      {
        goto LABEL_37;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v254 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_37;
      }
      v256 = *(_DWORD *)(a3 + 176);
      v255 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_http2_submit_message";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(void *)&v370 = " ";
      WORD4(v370) = 1024;
      *(_DWORD *)((char *)&v370 + 10) = v255;
      HIWORD(v370) = 1024;
      LODWORD(v371[0]) = v256;
      v136 = "%{public}s %{public}s%s<i%u:s%d> skipping empty frame body";
      v137 = (os_log_s *)v254;
      v138 = OS_LOG_TYPE_DEBUG;
      v139 = 44;
      goto LABEL_643;
    }

    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
    v243 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v374[0]) = 0;
    if (__nwlog_fault(v243, type, v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v244 = (os_log_s *)__nwlog_obj();
        v245 = type[0];
        if (!os_log_type_enabled(v244, type[0])) {
          goto LABEL_443;
        }
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        v246 = "%{public}s called with null frame";
LABEL_442:
        _os_log_impl(&dword_181A5C000, v244, v245, v246, (uint8_t *)buf, 0xCu);
        goto LABEL_443;
      }

      if (!LOBYTE(v374[0]))
      {
        v244 = (os_log_s *)__nwlog_obj();
        v245 = type[0];
        if (!os_log_type_enabled(v244, type[0])) {
          goto LABEL_443;
        }
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        v246 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_442;
      }

      v267 = (char *)__nw_create_backtrace_string();
      v244 = (os_log_s *)__nwlog_obj();
      v245 = type[0];
      v268 = os_log_type_enabled(v244, type[0]);
      if (!v267)
      {
        if (!v268) {
          goto LABEL_443;
        }
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        v246 = "%{public}s called with null frame, no backtrace";
        goto LABEL_442;
      }

      if (v268)
      {
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v267;
        _os_log_impl( &dword_181A5C000,  v244,  v245,  "%{public}s called with null frame, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
      }

      free(v267);
    }

    _os_log_impl(&dword_181A5C000, v15, v16, v21, buf, 0x36u);
    goto LABEL_36;
  }

  return result;
}

void nw_segment_freelist_insert(void *a1, uint64_t a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a2 + 48) == 3)
  {
    if (a3) {
      goto LABEL_5;
    }
  }

  else
  {
    unsigned int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    int v16 = 136446466;
    int v17 = "nw_segment_freelist_insert";
    __int16 v18 = 2082;
    unint64_t v19 = "VERIFY sg->sg_state == NW_SEG_STATE_MAPPED failed";
    unint64_t v10 = (void *)_os_log_send_and_compose_impl();
    free(v10);
    if (a3) {
      goto LABEL_5;
    }
  }

  uint64_t v6 = (void (*)(uint64_t, void))a1[36];
  if (v6) {
    v6(a2, a1[33]);
  }
LABEL_5:
  int state = 2;
  if (!mach_vm_purgable_control(*MEMORY[0x1895FBBE0], *(void *)(a2 + 24), 0, &state)) {
    goto LABEL_6;
  }
  int64x2_t v11 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  int v16 = 136446466;
  int v17 = "nw_segment_freelist_insert";
  __int16 v18 = 2082;
  unint64_t v19 = "VERIFY result == 0 failed";
  int64x2_t v12 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v12))
  {
LABEL_15:
    __break(1u);
    return;
  }

  free(v12);
LABEL_6:
  *(void *)(a2 + 44) = 0x200000002LL;
  *(void *)a2 = 0LL;
  unint64_t v7 = (void *)a1[47];
  *(void *)(a2 + 8) = v7;
  *unint64_t v7 = a2;
  a1[47] = a2;
  unint64_t v8 = a1[40] + 1LL;
  a1[40] = v8;
  if (v8 > a1[12])
  {
    int64x2_t v13 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    int v16 = 136446466;
    int v17 = "nw_segment_freelist_insert";
    __int16 v18 = 2082;
    unint64_t v19 = "VERIFY nwr->nwr_seg_free_cnt <= nwr->nwr_seg_max_cnt failed";
    unint64_t v14 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v14))
    {
      free(v14);
      return;
    }

    goto LABEL_15;
  }

void nw_mem_cache_stats_dump(void)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (nw_mem_dump_slab_stats)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_cache_lock);
    v0 = (void *)nw_mem_cache_head;
    if (nw_mem_cache_head)
    {
      do
      {
        v1 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
        {
          uint64_t v2 = v0[4];
          uint64_t v3 = v0[5];
          uint64_t v4 = v0[67];
          uint64_t v5 = v0[68];
          *(_DWORD *)buf = 136447490;
          unint64_t v7 = "nw_mem_cache_stats_dump";
          __int16 v8 = 2082;
          unsigned int v9 = v0 + 12;
          __int16 v10 = 2048;
          uint64_t v11 = v2;
          __int16 v12 = 2048;
          uint64_t v13 = v3;
          __int16 v14 = 2048;
          uint64_t v15 = v4;
          __int16 v16 = 2048;
          uint64_t v17 = v5;
          _os_log_impl( &dword_181A5C000,  v1,  OS_LOG_TYPE_INFO,  "%{public}s \n \n %{public}s: \n \tNumber of Slabs created %llu\n \tNumber of Slabs destroyed %llu\n \tNumber of Cache Allocs %llu\n \tNumber of Cache Frees %llu",  buf,  0x3Eu);
        }

        v0 = (void *)v0[10];
      }

      while (v0);
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_cache_lock);
    nw_mem_region_stats_dump();
  }

void nw_mem_cache_update_set_timer()
{
  if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_cache_lock);
    if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
    {
      uint64_t source = nw_mem_cache_update_source;
      if (nw_mem_cache_update_source
        || (id v1 = nw_context_copy_implicit_context(),
            uint64_t source = nw_queue_context_create_source(v1, 2, 3, 0, &__block_literal_global_54985, 0LL),
            (nw_mem_cache_update_uint64_t source = source) != 0))
      {
        dispatch_time_t v2 = dispatch_time(0x8000000000000000LL, 11000000000LL);
        nw_queue_set_timer_values(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        nw_queue_activate_source(nw_mem_cache_update_source, v3);
        nw_mem_cache_update_set_timer::cache_update_timer_set = 1;
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_cache_lock);
  }

void nw_queue_set_timer_values(uint64_t a1, dispatch_time_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (*(void *)a1)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)a1, a2, a3, a4);
    }

    else
    {
      *(void *)(a1 + 32) = a2;
      *(void *)(a1 + 40) = a3;
      if (*(_BYTE *)(a1 + 48))
      {
        if (*(_BYTE *)(a1 + 49)) {
          nw_queue_source_run_timer(a1, a2);
        }
      }
    }

    return;
  }

  __nwlog_obj(0LL, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_queue_set_timer_values";
  uint64_t v5 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  uint64_t v6 = __nwlog_fault(v5, &type, &v14);
  if ((_DWORD)v6)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v6, v7);
      __int16 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_queue_set_timer_values";
        __int16 v10 = "%{public}s called with null source";
LABEL_20:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      }
    }

    else
    {
      if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj(backtrace_string, v12);
        __int16 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v17 = "nw_queue_set_timer_values";
            __int16 v18 = 2082;
            unint64_t v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null source, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }

        if (!v13) {
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_queue_set_timer_values";
        __int16 v10 = "%{public}s called with null source, no backtrace";
        goto LABEL_20;
      }

      __nwlog_obj(v6, v7);
      __int16 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_queue_set_timer_values";
        __int16 v10 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_20;
      }
    }

LABEL_21:
  }

  if (v5) {
    free(v5);
  }
LABEL_4:
}

  if (v7) {
    free(v7);
  }
  return 0LL;
}

  if (v7) {
    free(v7);
  }
  return "???";
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
LABEL_4:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_23;
  }

  uint64_t v3 = *(xpc_object_t **)(*((void *)v1 + 13) + 176LL);
  if (!v3 || !*v3)
  {
LABEL_23:
    uint64_t v4 = 0LL;
    goto LABEL_24;
  }

  uint64_t v4 = xpc_array_get_count(*v3) != 0;
LABEL_24:

  return v4;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }

  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3 || (uint64_t v4 = *(void **)(v3 + 24)) == 0LL)
  {
LABEL_23:
    uint64_t v5 = 0LL;
    goto LABEL_24;
  }

  uint64_t v5 = xpc_array_get_count(v4) != 0;
LABEL_24:

  return v5;
}

          nw_parameters_clear_protocol_stack(v6, 2);
          goto LABEL_22;
        }

  if (v5) {
    free(v5);
  }
LABEL_4:
}

    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }

  uint64_t v3 = *(void ***)(*((void *)v1 + 13) + 176LL);
  if (!v3 || (uint64_t v4 = *v3) == 0LL)
  {
LABEL_23:
    uint64_t v5 = 0LL;
    goto LABEL_24;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  unint64_t v19 = 0;
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = __nw_parameters_get_prohibit_cellular_block_invoke;
  applier[3] = &unk_189BBC908;
  applier[4] = buf;
  xpc_array_apply(v4, applier);
  uint64_t v5 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
  _Block_object_dispose(buf, 8);
LABEL_24:

  return v5;
}

  if (v6) {
    free(v6);
  }
LABEL_4:
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

    if (v5) {
      free(v5);
    }
    goto LABEL_23;
  }

  if (!nw_path_network_is_satisfied_update_reason(v1, 0LL))
  {
LABEL_23:
    effective_traffic_class = 0LL;
    goto LABEL_24;
  }

  effective_traffic_class = v2->effective_traffic_class;
  if (!(_DWORD)effective_traffic_class) {
    effective_traffic_class = nw_parameters_get_traffic_class(v2->parameters);
  }
LABEL_24:

  return effective_traffic_class;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }

  if (!nw_path_network_is_satisfied_update_reason(v1, 0LL) || (direct = v2->direct) == 0LL)
  {
LABEL_23:
    uint64_t v5 = 0LL;
    goto LABEL_24;
  }

  uint64_t v4 = direct;
  uint64_t v5 = *((unsigned int *)v4 + 20);

LABEL_24:
  return v5;
}

  if (v4) {
    free(v4);
  }
}

  if (v4) {
    free(v4);
  }
}

  if (v4) {
LABEL_22:
  }
    free(v4);
  return 0LL;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }

  if (!nw_path_network_is_satisfied_update_reason(v1, 0LL) || (direct = v2->direct) == 0LL)
  {
LABEL_23:
    uint64_t v5 = 0LL;
    goto LABEL_24;
  }

  uint64_t v4 = direct;
  uint64_t v5 = *((unsigned int *)v4 + 16);

LABEL_24:
  return v5;
}

        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          __int16 v18 = *(void *)(a2 + 88);
          if (v18)
          {
            unint64_t v19 = v18 - 1;
            *(void *)(a2 + 88) = v19;
            if (!v19)
            {
              uint64_t v20 = *(void (***)(void))(a2 + 64);
              if (v20)
              {
                *(void *)(a2 + 64) = 0LL;
                v20[2](v20);
                _Block_release(v20);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                uint32_t v21 = *(const void **)(a2 + 64);
                if (v21) {
                  _Block_release(v21);
                }
              }

              free((void *)a2);
            }
          }
        }

        goto LABEL_22;
      }
    }

    __nwlog_obj();
    __int16 v32 = *(const char **)(a2 + 16);
    *(_DWORD *)buf = 136446722;
    v49 = "__nw_protocol_get_output_local_endpoint";
    if (!v32) {
      __int16 v32 = "invalid";
    }
    v50 = 2082;
    v51 = (void *)v32;
    v52 = 2048;
    v53 = (const char *)a2;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    v45 = (char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v45, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = (os_log_s *)__nwlog_obj();
        __int16 v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_138;
        }
        unint64_t v35 = *(const char **)(a2 + 16);
        if (!v35) {
          unint64_t v35 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v35;
        v52 = 2048;
        v53 = (const char *)a2;
        uint64_t v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback";
LABEL_137:
        _os_log_impl(&dword_181A5C000, v33, v34, v36, buf, 0x20u);
        goto LABEL_138;
      }

      if (!v46)
      {
        v33 = (os_log_s *)__nwlog_obj();
        __int16 v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_138;
        }
        v43 = *(const char **)(a2 + 16);
        if (!v43) {
          v43 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v43;
        v52 = 2048;
        v53 = (const char *)a2;
        uint64_t v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, backtrace limit exceeded";
        goto LABEL_137;
      }

      v40 = (char *)__nw_create_backtrace_string();
      v33 = (os_log_s *)__nwlog_obj();
      __int16 v34 = type;
      v41 = os_log_type_enabled(v33, type);
      if (!v40)
      {
        __int16 v8 = a1 + 96;
        if (!v41) {
          goto LABEL_138;
        }
        v44 = *(const char **)(a2 + 16);
        if (!v44) {
          v44 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v44;
        v52 = 2048;
        v53 = (const char *)a2;
        uint64_t v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, no backtrace";
        goto LABEL_137;
      }

      if (v41)
      {
        v42 = *(const char **)(a2 + 16);
        if (!v42) {
          v42 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v42;
        v52 = 2048;
        v53 = (const char *)a2;
        v54 = 2082;
        v55 = v40;
        _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v40);
      __int16 v8 = a1 + 96;
    }

    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }

  if (!nw_path_network_is_satisfied_update_reason(v1, 0LL) || (direct = v2->direct) == 0LL)
  {
LABEL_23:
    uint64_t v5 = 0LL;
    goto LABEL_24;
  }

  uint64_t v4 = direct;
  uint64_t v5 = *((unsigned int *)v4 + 17);

LABEL_24:
  return v5;
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
LABEL_4:

  return v4;
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
LABEL_4:

  return v4;
}

  if (v4) {
    free(v4);
  }
  return 0;
}

  if (v6) {
    free(v6);
  }
}

    if (v5) {
      free(v5);
    }
    goto LABEL_23;
  }

  if (!nw_path_network_is_satisfied_update_reason(v1, 0LL) && !nw_path_endpoint_is_always_satisfied(p_isa[3]))
  {
LABEL_23:
    uint64_t v3 = 0LL;
    goto LABEL_24;
  }

  uint64_t v3 = p_isa[12];
LABEL_24:

  return v3;
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v10) {
    free(v10);
  }

LABEL_4:
}

  if (v10) {
    free(v10);
  }

LABEL_4:
}

  v45 = *(void **)(a2 + 312);
  *(void *)(a2 + 312) = 0LL;

  v46 = *(void **)(a2 + 320);
  *(void *)(a2 + 320) = 0LL;

  v47 = *(void *)(a2 + 72);
  if (v47)
  {
    v48 = *(void *)(v47 + 24);
    if (v48)
    {
      v49 = *(uint64_t (**)(void, uint64_t))(v48 + 240);
      if (v49)
      {
        if ((v49(*(void *)(a2 + 72), a2 + 64) & 1) == 0
          && (nw_endpoint_handler_get_logging_disabled(*(void **)(a2 + 160)) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v50 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            id_string = nw_endpoint_handler_get_id_string(*(void **)(a2 + 160));
            v52 = nw_endpoint_handler_dry_run_string(*(void **)(a2 + 160));
            v75 = v26;
            v53 = nw_endpoint_handler_copy_endpoint(*(void **)(a2 + 160));
            logging_description = nw_endpoint_get_logging_description(v53);
            v55 = nw_endpoint_handler_state_string(*(void **)(a2 + 160));
            v56 = nw_endpoint_handler_mode_string(*(void **)(a2 + 160));
            v57 = nw_endpoint_handler_copy_current_path(*(void **)(a2 + 160));
            v58 = *(void *)(v47 + 16);
            *(_DWORD *)buf = 136448002;
            v82 = "nw_endpoint_flow_cleanup_protocol";
            v83 = 2082;
            v84 = id_string;
            v85 = 2082;
            v86 = v52;
            v87 = 2082;
            v88 = logging_description;
            v89 = 2082;
            v90 = v55;
            v91 = 2082;
            v92 = v56;
            v93 = 2114;
            v94 = v57;
            v95 = 2082;
            v96 = v58;
            _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to remove listen h andler %{public}s",  buf,  0x52u);

            v26 = v75;
          }
        }
      }
    }
  }

  if (a3)
  {
    v59 = *(void *)(a2 + 32);
    if (v59)
    {
      v60 = *(void *)(v59 + 24);
      if (v60)
      {
        v61 = *(uint64_t (**)(void))(v60 + 8);
        if (v61)
        {
          if ((v61() & 1) == 0 && (nw_endpoint_handler_get_logging_disabled(*(void **)(a2 + 160)) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v62 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            {
              v63 = nw_endpoint_handler_get_id_string(*(void **)(a2 + 160));
              v64 = nw_endpoint_handler_dry_run_string(*(void **)(a2 + 160));
              v65 = nw_endpoint_handler_copy_endpoint(*(void **)(a2 + 160));
              v66 = v26;
              v67 = nw_endpoint_get_logging_description(v65);
              v68 = nw_endpoint_handler_state_string(*(void **)(a2 + 160));
              v69 = nw_endpoint_handler_mode_string(*(void **)(a2 + 160));
              v70 = nw_endpoint_handler_copy_current_path(*(void **)(a2 + 160));
              v71 = *(void *)(a2 + 16);
              *(_DWORD *)buf = 136448002;
              v82 = "nw_endpoint_flow_cleanup_protocol";
              v83 = 2082;
              v84 = v63;
              v85 = 2082;
              v86 = v64;
              v87 = 2082;
              v88 = v67;
              v89 = 2082;
              v90 = v68;
              v91 = 2082;
              v92 = v69;
              v93 = 2114;
              v94 = v70;
              v95 = 2082;
              v96 = v71;
              _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to remove protocol %{public}s",  buf,  0x52u);

              v26 = v66;
            }
          }
        }
      }
    }

    v72 = *(void **)(a2 + 160);
    *(void *)(a2 + 160) = 0LL;
  }
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
LABEL_4:

  return v4;
}

  result = swift_release_n();
  id v1 = v23;
LABEL_23:
  os_log_s *v1 = v9;
  return result;
}

  swift_release();
  id v1 = v23;
  uint64_t v20 = 1LL << *(_BYTE *)(v30 + 32);
  if (v20 > 63) {
    bzero(v27, ((unint64_t)(v20 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    os_log_s *v27 = -1LL << v20;
  }
  *(void *)(v30 + 16) = 0LL;
LABEL_26:
  result = swift_release();
  os_log_s *v1 = v9;
  return result;
}

  uint64_t v36 = *v43;
  *(void *)(*v43 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  result = sub_181BC928C( a1,  *(void *)(v36 + 48) + *(void *)(v47 + 72) * a2,  type metadata accessor for NWBrowser.Result);
  v38 = *(void *)(v36 + 16);
  v39 = __OFADD__(v38, 1LL);
  v40 = v38 + 1;
  if (v39)
  {
    __break(1u);
LABEL_24:
    sub_181BD6288(0LL);
    sub_181BD6288(0LL);
    sub_181BC920C((uint64_t)v44, type metadata accessor for NWBrowser.Result);
    sub_181BC920C((uint64_t)v13, type metadata accessor for NWBrowser.Result);
    sub_181BC920C((uint64_t)v21, type metadata accessor for NWBrowser.Result);
LABEL_25:
    result = sub_18264F5B8();
    __break(1u);
  }

  else
  {
    *(void *)(v36 + 16) = v40;
  }

  return result;
}

          if (v10 >> 14 != v21 >> 14) {
            continue;
          }
          swift_bridgeObjectRelease();
          a3 = v25;
          uint64_t v6 = v24;
          break;
      }

      break;
    }
  }

  swift_bridgeObjectRelease();
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = a2;
  *(void *)(a3 + 16) = v6;
  *(void *)(a3 + 24) = a2;
  return swift_bridgeObjectRetain();
}

  *(void *)(v0 + 264) = v27;
  *(void *)(v0 + 272) = v56;
  *(void *)(v0 + 248) = v25;
  *(void *)(v0 + 256) = v26;
  v57 = *(void *)(v0 + 232);
  v59 = *(int **)(v0 + 184);
  v58 = *(void *)(v0 + 192);
  v60 = *(void *)(v0 + 176);
  v61 = sub_18264E688();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v61 - 8) + 16LL))(v58, v60, v61);
  *(_OWORD *)(v58 + v59[5]) = xmmword_18265D190;
  v62 = v58 + v59[6];
  *(void *)v62 = v25;
  *(void *)(v62 + 8) = v26;
  *(void *)(v62 + 16) = v27;
  *(void *)(v62 + 24) = v56;
  *(_BYTE *)(v62 + 32) = 0;
  v63 = v58 + v59[7];
  *(void *)v63 = v70;
  *(_BYTE *)(v63 + 8) = v69 & 1;
  __swift_project_boxed_opaque_existential_2( (void *)(v60 + *(int *)(v57 + 20)),  *(void *)(v60 + *(int *)(v57 + 20) + 24));
  sub_181C36CD8(v25, v26, v27, v56, 0);
  v64 = (void *)swift_task_alloc();
  *(void *)(v0 + 280) = v64;
  *v64 = v0;
  v64[1] = sub_181C3698C;
  return sub_181C49B30(*(void *)(v0 + 192));
}

    uint64_t v20 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    uint32_t v21 = *v20;
    uint64_t v22 = (-1LL << v3) - 1;
  }

  else
  {
    uint64_t v20 = (uint64_t *)(v4 + 8 * (result >> 6));
    uint64_t v22 = *v20;
    uint32_t v21 = (-1LL << result) - 1;
  }

  *uint64_t v20 = v22 & v21;
  v23 = *(void *)(a2 + 16);
  v24 = __OFSUB__(v23, 1LL);
  v25 = v23 - 1;
  if (v24)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v25;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

    if (v4 <= v8 >> 16) {
      goto LABEL_28;
    }
    __int16 v8 = sub_18264EB98();
LABEL_8:
  }

  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

      if (!v11) {
        goto LABEL_3;
      }
      swift_bridgeObjectRetain();
      if (sub_18264EB50() == 3)
      {
        uint32_t v21 = sub_181C6F6F8(v17, v16);
        swift_bridgeObjectRelease();
        if ((v21 & 1) != 0)
        {
          __swift_destroy_boxed_opaque_existential_2((uint64_t)v39);
          *(void *)v24 = v12;
          *(void *)(v24 + 8) = v11;
          *(void *)(v24 + 16) = v14;
          *(void *)(v24 + 24) = v13;
          *(_BYTE *)(v24 + 32) = v15;
          *(void *)(v24 + 40) = v17;
          *(void *)(v24 + 48) = v16;
          uint64_t v22 = v41;
          return __swift_destroy_boxed_opaque_existential_2(v22);
        }
      }

      else
      {
        swift_bridgeObjectRelease();
      }

      sub_181BCD38C((uint64_t)v39, (uint64_t)&v32);
      sub_18264F168();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRetain();
      sub_18264EB74();
      sub_181BCECE0(v12, v11);
      swift_bridgeObjectRelease();
      sub_18264EB74();
      sub_18264F204();
      swift_allocError();
      sub_18264F1E0();
      swift_bridgeObjectRelease();
    }

    __swift_destroy_boxed_opaque_existential_2((uint64_t)&v32);
    swift_willThrow();
LABEL_28:
    __swift_destroy_boxed_opaque_existential_2((uint64_t)v39);
    uint64_t v3 = (void *)v41;
  }

  uint64_t v22 = (uint64_t)v3;
  return __swift_destroy_boxed_opaque_existential_2(v22);
}

          sub_181C86A84(v12, v13);
          unint64_t v19 = sub_18264EB20();
          uint32_t v21 = v20;
          goto LABEL_23;
        }
      }

    uint64_t v15 = (v24 - 1) & v24;
    uint32_t v21 = __clz(__rbit64(v24)) + (v18 << 6);
LABEL_22:
    v26 = *(void *)(v6 + 72);
    v27 = *(void *)(v9 + 48) + v26 * v21;
    if ((v39 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v6 + 32))(v8, v27, v5);
      sub_181C275FC((_OWORD *)(*(void *)(v9 + 56) + 32 * v21), v40);
    }

    else
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v6 + 16))(v8, v27, v5);
      sub_181BF9894(*(void *)(v9 + 56) + 32 * v21, (uint64_t)v40);
    }

    result = sub_18264E9DC();
    int v28 = -1LL << *(_BYTE *)(v11 + 32);
    unint64_t v29 = result & ~v28;
    unint64_t v30 = v29 >> 6;
    if (((-1LL << v29) & ~*(void *)(v16 + 8 * (v29 >> 6))) != 0)
    {
      unint64_t v19 = __clz(__rbit64((-1LL << v29) & ~*(void *)(v16 + 8 * (v29 >> 6)))) | v29 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      v31 = 0;
      __int16 v32 = (unint64_t)(63 - v28) >> 6;
      do
      {
        if (++v30 == v32 && (v31 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }

        v33 = v30 == v32;
        if (v30 == v32) {
          unint64_t v30 = 0LL;
        }
        v31 |= v33;
        __int16 v34 = *(void *)(v16 + 8 * v30);
      }

      while (v34 == -1);
      unint64_t v19 = __clz(__rbit64(~v34)) + (v30 << 6);
    }

    *(void *)(v16 + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v19;
    (*(void (**)(unint64_t, char *, uint64_t))(v6 + 32))(*(void *)(v11 + 48) + v26 * v19, v8, v5);
    result = (uint64_t)sub_181C275FC(v40, (_OWORD *)(*(void *)(v11 + 56) + 32 * v19));
    ++*(void *)(v11 + 16);
  }

  swift_release();
  uint64_t v3 = v36;
  v23 = v38;
  if ((v39 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  unint64_t v35 = 1LL << *(_BYTE *)(v9 + 32);
  if (v35 >= 64) {
    bzero(v23, ((unint64_t)(v35 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    os_log_s *v23 = -1LL << v35;
  }
  *(void *)(v9 + 16) = 0LL;
LABEL_41:
  result = swift_release();
  *uint64_t v3 = v11;
  return result;
}

        __int16 v16 = (v24 - 1) & v24;
        uint64_t v22 = __clz(__rbit64(v24)) + (v19 << 6);
      }

      v26 = *(void *)(v41 + 72);
      v27 = *(void *)(v10 + 48) + v26 * v22;
      if ((v43 & 1) != 0)
      {
        sub_181BC928C(v27, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for NWActorID);
        int v28 = *(void *)(*(void *)(v10 + 56) + 8 * v22);
      }

      else
      {
        sub_181BC9248(v27, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for NWActorID);
        int v28 = *(void *)(*(void *)(v10 + 56) + 8 * v22);
        swift_retain();
      }

      sub_18264F648();
      sub_18264EB44();
      sub_18264E688();
      sub_181C93408((unint64_t *)&qword_18C58E6E0, MEMORY[0x189606F48]);
      sub_18264E9E8();
      result = sub_18264F684();
      unint64_t v29 = -1LL << *(_BYTE *)(v12 + 32);
      unint64_t v30 = result & ~v29;
      v31 = v30 >> 6;
      if (((-1LL << v30) & ~*(void *)(v17 + 8 * (v30 >> 6))) != 0)
      {
        uint64_t v20 = __clz(__rbit64((-1LL << v30) & ~*(void *)(v17 + 8 * (v30 >> 6)))) | v30 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        __int16 v32 = 0;
        v33 = (unint64_t)(63 - v29) >> 6;
        do
        {
          if (++v31 == v33 && (v32 & 1) != 0)
          {
            __break(1u);
            goto LABEL_40;
          }

          __int16 v34 = v31 == v33;
          if (v31 == v33) {
            v31 = 0LL;
          }
          v32 |= v34;
          unint64_t v35 = *(void *)(v17 + 8 * v31);
        }

        while (v35 == -1);
        uint64_t v20 = __clz(__rbit64(~v35)) + (v31 << 6);
      }

      *(void *)(v17 + ((v20 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v20;
      result = sub_181BC928C( (uint64_t)v9,  *(void *)(v12 + 48) + v26 * v20,  (uint64_t (*)(void))type metadata accessor for NWActorID);
      *(void *)(*(void *)(v12 + 56) + 8 * v20) = v28;
      ++*(void *)(v12 + 16);
    }
  }

  result = swift_release();
  *uint64_t v5 = v12;
  return result;
}

    char v14 = (v23 - 1) & v23;
    uint64_t v20 = __clz(__rbit64(v23)) + (v17 << 6);
LABEL_22:
    v25 = *(void *)(v38 + 72);
    v26 = *(void *)(v8 + 48) + v25 * v20;
    if ((v40 & 1) != 0)
    {
      sub_181BC928C(v26, (uint64_t)v7, (uint64_t (*)(void))type metadata accessor for NWActorID);
      v41 = *(_OWORD *)(*(void *)(v8 + 56) + 16 * v20);
    }

    else
    {
      sub_181BC9248(v26, (uint64_t)v7, (uint64_t (*)(void))type metadata accessor for NWActorID);
      v41 = *(_OWORD *)(*(void *)(v8 + 56) + 16 * v20);
      swift_retain();
    }

    sub_18264F648();
    sub_18264EB44();
    sub_18264E688();
    sub_181C93408((unint64_t *)&qword_18C58E6E0, MEMORY[0x189606F48]);
    sub_18264E9E8();
    result = sub_18264F684();
    v27 = -1LL << *(_BYTE *)(v10 + 32);
    int v28 = result & ~v27;
    unint64_t v29 = v28 >> 6;
    if (((-1LL << v28) & ~*(void *)(v15 + 8 * (v28 >> 6))) != 0)
    {
      __int16 v18 = __clz(__rbit64((-1LL << v28) & ~*(void *)(v15 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      unint64_t v30 = 0;
      v31 = (unint64_t)(63 - v27) >> 6;
      do
      {
        if (++v29 == v31 && (v30 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }

        __int16 v32 = v29 == v31;
        if (v29 == v31) {
          unint64_t v29 = 0LL;
        }
        v30 |= v32;
        v33 = *(void *)(v15 + 8 * v29);
      }

      while (v33 == -1);
      __int16 v18 = __clz(__rbit64(~v33)) + (v29 << 6);
    }

    *(void *)(v15 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v18;
    result = sub_181BC928C( (uint64_t)v7,  *(void *)(v10 + 48) + v25 * v18,  (uint64_t (*)(void))type metadata accessor for NWActorID);
    *(_OWORD *)(*(void *)(v10 + 56) + 16 * v18) = v41;
    ++*(void *)(v10 + 16);
  }

  swift_release();
  uint64_t v3 = v35;
  uint64_t v22 = v37;
  if ((v40 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  __int16 v34 = 1LL << *(_BYTE *)(v8 + 32);
  if (v34 >= 64) {
    bzero(v22, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    void *v22 = -1LL << v34;
  }
  *(void *)(v8 + 16) = 0LL;
LABEL_41:
  result = swift_release();
  *uint64_t v3 = v10;
  return result;
}

    uint64_t v17 = (v26 - 1) & v26;
    v23 = __clz(__rbit64(v26)) + (v20 << 6);
LABEL_22:
    int v28 = *(void *)(v45 + 72);
    unint64_t v29 = *(void *)(v11 + 48) + v28 * v23;
    if ((v47 & 1) != 0)
    {
      sub_181BC928C(v29, (uint64_t)v10, (uint64_t (*)(void))type metadata accessor for NWActorID);
      unint64_t v30 = *(void *)(v44 + 72);
      sub_181BC928C( *(void *)(v11 + 56) + v30 * v23,  (uint64_t)v7,  type metadata accessor for NWActorDiscoveryMechanism);
    }

    else
    {
      sub_181BC9248(v29, (uint64_t)v10, (uint64_t (*)(void))type metadata accessor for NWActorID);
      unint64_t v30 = *(void *)(v44 + 72);
      sub_181BC9248( *(void *)(v11 + 56) + v30 * v23,  (uint64_t)v7,  type metadata accessor for NWActorDiscoveryMechanism);
    }

    sub_18264F648();
    sub_18264EB44();
    sub_18264E688();
    sub_181C93408((unint64_t *)&qword_18C58E6E0, MEMORY[0x189606F48]);
    sub_18264E9E8();
    result = sub_18264F684();
    v31 = -1LL << *(_BYTE *)(v13 + 32);
    __int16 v32 = result & ~v31;
    v33 = v32 >> 6;
    if (((-1LL << v32) & ~*(void *)(v18 + 8 * (v32 >> 6))) != 0)
    {
      uint32_t v21 = __clz(__rbit64((-1LL << v32) & ~*(void *)(v18 + 8 * (v32 >> 6)))) | v32 & 0x7FFFFFFFFFFFFFC0LL;
      uint64_t v7 = v43;
    }

    else
    {
      __int16 v34 = 0;
      unint64_t v35 = (unint64_t)(63 - v31) >> 6;
      uint64_t v7 = v43;
      do
      {
        if (++v33 == v35 && (v34 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }

        uint64_t v36 = v33 == v35;
        if (v33 == v35) {
          v33 = 0LL;
        }
        v34 |= v36;
        v37 = *(void *)(v18 + 8 * v33);
      }

      while (v37 == -1);
      uint32_t v21 = __clz(__rbit64(~v37)) + (v33 << 6);
    }

    *(void *)(v18 + ((v21 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v21;
    sub_181BC928C( (uint64_t)v10,  *(void *)(v13 + 48) + v28 * v21,  (uint64_t (*)(void))type metadata accessor for NWActorID);
    result = sub_181BC928C( (uint64_t)v7,  *(void *)(v13 + 56) + v30 * v21,  type metadata accessor for NWActorDiscoveryMechanism);
    ++*(void *)(v13 + 16);
  }

  swift_release();
  uint64_t v3 = v40;
  v25 = v42;
  if ((v47 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  v38 = 1LL << *(_BYTE *)(v11 + 32);
  if (v38 >= 64) {
    bzero(v25, ((unint64_t)(v38 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    void *v25 = -1LL << v38;
  }
  *(void *)(v11 + 16) = 0LL;
LABEL_41:
  result = swift_release();
  *uint64_t v3 = v13;
  return result;
}

    char v14 = (v24 - 1) & v24;
    uint32_t v21 = __clz(__rbit64(v24)) + (v17 << 6);
LABEL_22:
    v26 = (uint64_t *)(*(void *)(v8 + 48) + 16 * v21);
    int v28 = *v26;
    v27 = v26[1];
    unint64_t v29 = *(void *)(v42 + 72);
    unint64_t v30 = *(void *)(v8 + 56) + v29 * v21;
    if ((v43 & 1) != 0)
    {
      sub_181BC928C( v30,  (uint64_t)v7,  (uint64_t (*)(void))type metadata accessor for NWActorSystem.ServerRole);
    }

    else
    {
      sub_181BC9248( v30,  (uint64_t)v7,  (uint64_t (*)(void))type metadata accessor for NWActorSystem.ServerRole);
      swift_bridgeObjectRetain();
    }

    sub_18264F648();
    sub_18264EB44();
    result = sub_18264F684();
    v31 = -1LL << *(_BYTE *)(v10 + 32);
    __int16 v32 = result & ~v31;
    v33 = v32 >> 6;
    if (((-1LL << v32) & ~*(void *)(v15 + 8 * (v32 >> 6))) != 0)
    {
      __int16 v18 = __clz(__rbit64((-1LL << v32) & ~*(void *)(v15 + 8 * (v32 >> 6)))) | v32 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      __int16 v34 = 0;
      unint64_t v35 = (unint64_t)(63 - v31) >> 6;
      do
      {
        if (++v33 == v35 && (v34 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }

        uint64_t v36 = v33 == v35;
        if (v33 == v35) {
          v33 = 0LL;
        }
        v34 |= v36;
        v37 = *(void *)(v15 + 8 * v33);
      }

      while (v37 == -1);
      __int16 v18 = __clz(__rbit64(~v37)) + (v33 << 6);
    }

    *(void *)(v15 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v18;
    unint64_t v19 = (void *)(*(void *)(v10 + 48) + 16 * v18);
    *unint64_t v19 = v28;
    v19[1] = v27;
    result = sub_181BC928C( (uint64_t)v7,  *(void *)(v10 + 56) + v29 * v18,  (uint64_t (*)(void))type metadata accessor for NWActorSystem.ServerRole);
    ++*(void *)(v10 + 16);
  }

  swift_release();
  uint64_t v3 = v39;
  v23 = v41;
  if ((v43 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  v38 = 1LL << *(_BYTE *)(v8 + 32);
  if (v38 >= 64) {
    bzero(v23, ((unint64_t)(v38 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    os_log_s *v23 = -1LL << v38;
  }
  *(void *)(v8 + 16) = 0LL;
LABEL_41:
  result = swift_release();
  *uint64_t v3 = v10;
  return result;
}

        __int16 v10 = (v19 - 1) & v19;
        uint64_t v17 = __clz(__rbit64(v19)) + (v13 << 6);
      }

      uint32_t v21 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v17);
      v23 = *v21;
      uint64_t v22 = v21[1];
      v24 = (_OWORD *)(*(void *)(v5 + 56) + 32 * v17);
      if ((a2 & 1) != 0)
      {
        sub_181C275FC(v24, v35);
      }

      else
      {
        sub_181BF9894((uint64_t)v24, (uint64_t)v35);
        swift_bridgeObjectRetain();
      }

      sub_18264F648();
      sub_18264EB44();
      result = sub_18264F684();
      v25 = -1LL << *(_BYTE *)(v7 + 32);
      v26 = result & ~v25;
      v27 = v26 >> 6;
      if (((-1LL << v26) & ~*(void *)(v11 + 8 * (v26 >> 6))) != 0)
      {
        char v14 = __clz(__rbit64((-1LL << v26) & ~*(void *)(v11 + 8 * (v26 >> 6)))) | v26 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        int v28 = 0;
        unint64_t v29 = (unint64_t)(63 - v25) >> 6;
        do
        {
          if (++v27 == v29 && (v28 & 1) != 0)
          {
            __break(1u);
            goto LABEL_40;
          }

          unint64_t v30 = v27 == v29;
          if (v27 == v29) {
            v27 = 0LL;
          }
          v28 |= v30;
          v31 = *(void *)(v11 + 8 * v27);
        }

        while (v31 == -1);
        char v14 = __clz(__rbit64(~v31)) + (v27 << 6);
      }

      *(void *)(v11 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v14;
      uint64_t v15 = (void *)(*(void *)(v7 + 48) + 16 * v14);
      void *v15 = v23;
      v15[1] = v22;
      result = (uint64_t)sub_181C275FC(v35, (_OWORD *)(*(void *)(v7 + 56) + 32 * v14));
      ++*(void *)(v7 + 16);
    }
  }

  result = swift_release();
  *uint64_t v3 = v7;
  return result;
}

    __int16 v16 = (v25 - 1) & v25;
    uint64_t v22 = __clz(__rbit64(v25)) + (v19 << 6);
LABEL_22:
    v27 = *(void *)(v6 + 72);
    int v28 = *(void *)(v11 + 48) + v27 * v22;
    if ((v43 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v6 + 32))(v8, v28, v5);
      unint64_t v29 = *(void *)(*(void *)(v11 + 56) + 8 * v22);
    }

    else
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v6 + 16))(v8, v28, v5);
      unint64_t v29 = *(void *)(*(void *)(v11 + 56) + 8 * v22);
      swift_retain();
    }

    sub_181C93408((unint64_t *)&qword_18C58E6E0, MEMORY[0x189606F48]);
    result = sub_18264E9DC();
    unint64_t v30 = -1LL << *(_BYTE *)(v12 + 32);
    v31 = result & ~v30;
    __int16 v32 = v31 >> 6;
    if (((-1LL << v31) & ~*(void *)(v17 + 8 * (v31 >> 6))) != 0)
    {
      uint64_t v20 = __clz(__rbit64((-1LL << v31) & ~*(void *)(v17 + 8 * (v31 >> 6)))) | v31 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      v33 = 0;
      __int16 v34 = (unint64_t)(63 - v30) >> 6;
      do
      {
        if (++v32 == v34 && (v33 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }

        unint64_t v35 = v32 == v34;
        if (v32 == v34) {
          __int16 v32 = 0LL;
        }
        v33 |= v35;
        uint64_t v36 = *(void *)(v17 + 8 * v32);
      }

      while (v36 == -1);
      uint64_t v20 = __clz(__rbit64(~v36)) + (v32 << 6);
    }

    *(void *)(v17 + ((v20 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v20;
    result = (*(uint64_t (**)(unint64_t, char *, uint64_t))(v6 + 32))( *(void *)(v12 + 48) + v27 * v20,  v8,  v5);
    *(void *)(*(void *)(v12 + 56) + 8 * v20) = v29;
    ++*(void *)(v12 + 16);
  }

  swift_release();
  uint64_t v3 = v39;
  v24 = v41;
  if ((v43 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  v37 = 1LL << *(_BYTE *)(v11 + 32);
  if (v37 >= 64) {
    bzero(v24, ((unint64_t)(v37 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    os_log_s *v24 = -1LL << v37;
  }
  *(void *)(v11 + 16) = 0LL;
LABEL_41:
  result = swift_release();
  *uint64_t v3 = v12;
  return result;
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v27 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    if (v26) {
      int v28 = "fallback: Wi-Fi shown ";
    }
    else {
      int v28 = "primary: ";
    }
    unint64_t v29 = -[NWSystemPathMonitor isWiFiPrimary](v2, "isWiFiPrimary");
    unint64_t v30 = -[NWSystemPathMonitor isEthernetPrimary](v2, "isEthernetPrimary");
    v31 = -[NWSystemPathMonitor isVPNActive](v2, "isVPNActive");
    *(_DWORD *)buf = 136448258;
    v37 = "-[NWSystemPathMonitor updateFlags]";
    v38 = 2082;
    v39 = v28;
    v40 = 1024;
    v41 = v29;
    v42 = 1024;
    v43 = v16;
    v44 = 2082;
    v45 = v25;
    v46 = 1024;
    v47 = v30;
    v48 = 1024;
    v49 = v21;
    v50 = 1024;
    v51 = v31;
    v52 = 1024;
    v53 = v5 & 1;
    _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEFAULT,  "%{public}s Wi-Fi %{public}s%{BOOL}d->%{BOOL}d%{public}s, Ethernet primary: %{BOOL}d->%{BOOL}d, VPN active: %{BOOL}d->%{BOOL}d",  buf,  0x44u);
  }

  if ((_DWORD)v16 != -[NWSystemPathMonitor isWiFiPrimary](v2, "isWiFiPrimary")) {
    -[NWSystemPathMonitor setWifiPrimary:](v2, "setWifiPrimary:", v16);
  }
  if ((_DWORD)v21 != -[NWSystemPathMonitor isEthernetPrimary](v2, "isEthernetPrimary")) {
    -[NWSystemPathMonitor setEthernetPrimary:](v2, "setEthernetPrimary:", v21);
  }
  if ((v5 & 1) != -[NWSystemPathMonitor isVPNActive](v2, "isVPNActive")) {
    -[NWSystemPathMonitor setVpnActive:](v2, "setVpnActive:");
  }
  objc_sync_exit(v2);
}

          _Block_object_dispose(buf, 8);
          if (SHIBYTE(v163) < 0) {
            operator delete(*((void **)&v161 + 1));
          }
          os_release(v15);
          v23 = a1[6];
          if ((char)v149.__r_.__value_.__s.__size_ < 0)
          {
            std::string::__init_copy_ctor_external( &v148,  v149.__r_.__value_.__l.__data_,  v149.__r_.__value_.__l.__size_);
            v24 = a1[6];
            if (v23) {
              goto LABEL_25;
            }
            goto LABEL_32;
          }

  if (a1->__r_.__value_.__l.__size_)
  {
LABEL_7:
    if ((v5 & 0x80) == 0) {
      goto LABEL_8;
    }
    goto LABEL_26;
  }

    operator delete(v27[0]);
    if ((v26 & 0x80000000) == 0)
    {
LABEL_10:
      if ((v24 & 0x80000000) == 0) {
        goto LABEL_11;
      }
      goto LABEL_23;
    }

  if (v12) {
    free(v12);
  }
LABEL_4:
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
LABEL_4:

  return v4;
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
LABEL_4:

  return v4;
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
LABEL_4:

  return v4;
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
LABEL_4:

  return v4;
}
}

        ++v21;
      }

      while (v19 != v21);
      v40 = [v18 countByEnumeratingWithState:v73 objects:buf count:16];
      unint64_t v19 = v40;
      if (!v40)
      {
LABEL_53:

        v41 = object;
        goto LABEL_54;
      }
    }
  }

  v41 = object;
  if (object && *((void *)object + 2) != *((void *)object + 3))
  {
    v42 = [MEMORY[0x189603FC8] dictionary];
    uint64_t v15 = 0LL;
    char v14 = v9[4];
    v9[4] = (id)v42;
    goto LABEL_12;
  }

  unint64_t v29 = v20;
  unint64_t v30 = *(id *)(*((void *)v29 + 13) + 136LL);

  if (!v30)
  {
    __nwlog_obj();
    v60 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v61 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (__nwlog_fault(v61, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)buf = 136446210;
          v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl(&dword_181A5C000, v62, v63, "%{public}s called with null context", buf, 0xCu);
        }
      }

      else if (v98)
      {
        v81 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v82 = type;
        v83 = os_log_type_enabled(v62, type);
        if (v81)
        {
          if (v83)
          {
            *(_DWORD *)buf = 136446466;
            v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
            v102 = 2082;
            v103 = v81;
            _os_log_impl( &dword_181A5C000,  v62,  v82,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v81);
          goto LABEL_170;
        }

        if (v83)
        {
          *(_DWORD *)buf = 136446210;
          v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl(&dword_181A5C000, v62, v82, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v89 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)buf = 136446210;
          v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl( &dword_181A5C000,  v62,  v89,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v4) {
    free(v4);
  }
LABEL_4:
}

  if (v4) {
    free(v4);
  }
LABEL_4:
}

  if (v5) {
    free(v5);
  }
LABEL_4:
}

      if (v15[256])
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v34 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
        v76 = 2082;
        *(void *)v77 = v15 + 256;
        *(_WORD *)&v77[8] = 1024;
        *(_DWORD *)&v77[10] = a2;
        *(_WORD *)&v77[14] = 1024;
        *(_DWORD *)&v77[16] = a3;
        *(_WORD *)&v77[20] = 1024;
        *(_DWORD *)&v77[22] = a4;
        *(_WORD *)&v77[26] = 2082;
        *(void *)&v77[28] = v16;
        *(_WORD *)&v77[36] = 1024;
        v78 = a10;
        unint64_t v35 = "%{public}s [C%{public}s] flags=0x%x ifindex=%u errorCode=%d hostname=%{public}s ttl=%d";
        uint64_t v36 = v34;
        v37 = 56;
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v34 = (os_log_s *)(id)gLogObj;
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
LABEL_29:

          goto LABEL_30;
        }

        v38 = *((_DWORD *)v15 + 85);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
        v76 = 1024;
        *(_DWORD *)v77 = v38;
        *(_WORD *)&v77[4] = 1024;
        *(_DWORD *)&v77[6] = a2;
        *(_WORD *)&v77[10] = 1024;
        *(_DWORD *)&v77[12] = a3;
        *(_WORD *)&v77[16] = 1024;
        *(_DWORD *)&v77[18] = a4;
        *(_WORD *)&v77[22] = 2082;
        *(void *)&v77[24] = v16;
        *(_WORD *)&v77[32] = 1024;
        *(_DWORD *)&v77[34] = a10;
        unint64_t v35 = "%{public}s [R%u] flags=0x%x ifindex=%u errorCode=%d hostname=%{public}s ttl=%d";
        uint64_t v36 = v34;
        v37 = 52;
      }

      _os_log_impl(&dword_181A5C000, v36, OS_LOG_TYPE_DEBUG, v35, buf, v37);
      goto LABEL_29;
    }

    if (v8) {
      free(v8);
    }
    return 1LL;
  }

  WeakRetained = objc_loadWeakRetained((id *)(a2 + 48));
  if (!WeakRetained) {
    return 1LL;
  }
  uint64_t v4 = WeakRetained;
  is_active = nw_endpoint_is_active(WeakRetained, 0LL);

  result = 1LL;
  if (is_active)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

      goto LABEL_22;
    }

    if (!v29)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      char v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_endpoint_add_edge";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s endpoints cannot add edges to themselves, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_21;
    }

    uint64_t v11 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    uint64_t v12 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (!v11)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_endpoint_add_edge";
        _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s endpoints cannot add edges to themselves, no backtrace",  buf,  0xCu);
      }

      goto LABEL_21;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v32 = "nw_endpoint_add_edge";
      v33 = 2082;
      __int16 v34 = v11;
      _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s endpoints cannot add edges to themselves, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v5) {
    free(v5);
  }
LABEL_23:
  uint64_t v3 = 0LL;
LABEL_24:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_23;
  }

  uint64_t v3 = *((void *)v1 + 5);
  if (!v3 || *(void *)(v3 + 24) == *(void *)(v3 + 16))
  {
LABEL_23:
    uint64_t v4 = 0LL;
    goto LABEL_24;
  }

  nw_array_get_object_at_index(v3, 0LL);
  uint64_t v4 = (nw_endpoint *)objc_claimAutoreleasedReturnValue();
LABEL_24:

  return v4;
}

  if (v7) {
    goto LABEL_22;
  }
LABEL_23:
  objc_storeStrong((id *)(*(void *)(a1[7] + 8LL) + 40LL), *(id *)(a1[4] + 24LL));
}

  if (v6) {
    free(v6);
  }
LABEL_4:
}

      unint64_t v30 = (void *)v91[5];
      v31 = v21[4];
      *(void *)buf = v20;
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL42nw_connection_group_handle_incoming_packetP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectS3_PU26objcproto15OS_nw_interfaceS1_PU27objcproto16OS_nw_fd_wrapperS1_PU27objcproto16OS_dispatch_dataS1__block_invoke_2;
      *(void *)&buf[24] = &unk_189BBE1E0;
      *(void *)&buf[32] = v21;
      v105 = v23;
      *(void *)v106 = data;
      *(void *)&v106[8] = &v96;
      __int16 v32 = v23;
      v33 = v30;
      __int16 v34 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v31, 0, buf);
      dispatch_async(v33, v34);

LABEL_27:
      goto LABEL_28;
    }

    __nwlog_obj();
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_content_context_set_multicast_info";
    v80 = (const char *)_os_log_send_and_compose_impl();

    v103 = OS_LOG_TYPE_ERROR;
    v102 = 0;
    v67 = (char *)v80;
    if (!__nwlog_fault(v80, &v103, &v102))
    {
LABEL_146:
      if (v67) {
        free(v67);
      }
      goto LABEL_21;
    }

    if (v103 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v69 = v103;
      if (os_log_type_enabled(v68, v103))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_multicast_info";
        _os_log_impl(&dword_181A5C000, v68, v69, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v102)
    {
      v70 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t type = v103;
      v71 = os_log_type_enabled(v68, v103);
      if (v70)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_content_context_set_multicast_info";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v70;
          _os_log_impl( &dword_181A5C000,  v68,  type,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v70);
        goto LABEL_145;
      }

      if (v71)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_multicast_info";
        _os_log_impl(&dword_181A5C000, v68, type, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v78 = v103;
      if (os_log_type_enabled(v68, v103))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_multicast_info";
        _os_log_impl( &dword_181A5C000,  v68,  v78,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_145:
    v67 = (char *)v80;
    goto LABEL_146;
  }

  if (!nw_parameters_get_logging_disabled(*((void *)v16 + 7)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    __int16 v32 = (nw_content_context *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      unint64_t v35 = v21[42];
      size = dispatch_data_get_size(data);
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v35;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2112;
      *(void *)&buf[30] = v85;
      *(_WORD *)&buf[38] = 2112;
      v105 = v84;
      *(_WORD *)v106 = 2048;
      *(void *)&v106[2] = size;
      _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] no receive handler or client queue, ignoring incoming packet <%@->%@@%@, %zu bytes>",  buf,  0x3Au);
    }

    goto LABEL_27;
  }

    goto LABEL_22;
  }

  uint64_t v3 = *((_DWORD *)v1 + 2);
  if (v3 != 3)
  {
    if (v3) {
      goto LABEL_24;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_group_descriptor_supports_known_membership";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v20 = 0;
    if (__nwlog_fault(v5, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        uint64_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_group_descriptor_supports_known_membership";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s Invalid group descriptor type", buf, 0xCu);
        }
      }

      else if (v20)
      {
        os_log_type_t v9 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        __int16 v10 = type;
        uint64_t v11 = os_log_type_enabled(v6, type);
        if (v9)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v23 = "nw_group_descriptor_supports_known_membership";
            v24 = 2082;
            v25 = v9;
            _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s Invalid group descriptor type, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v9);
          if (!v5) {
            goto LABEL_24;
          }
          goto LABEL_23;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_group_descriptor_supports_known_membership";
          _os_log_impl(&dword_181A5C000, v6, v10, "%{public}s Invalid group descriptor type, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        uint64_t v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_group_descriptor_supports_known_membership";
          _os_log_impl( &dword_181A5C000,  v6,  v12,  "%{public}s Invalid group descriptor type, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      goto LABEL_21;
    }

    if (!v4) {
      goto LABEL_23;
    }
LABEL_22:
    free(v4);
    goto LABEL_23;
  }

  if (v1 != (nw_privacy_context *)&__block_literal_global_11084)
  {
    nw_context_set_privacy_level_internal(v1, 4, 0);
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_privacy_context_disable_logging";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v17 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    uint64_t v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_privacy_context_disable_logging";
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Logging cannot be disabled for the default privacy context",  buf,  0xCu);
    }

  if (v4) {
    free(v4);
  }
LABEL_4:
}

          nw::release_if_needed<nw_protocol *>((uint64_t *)v57);
          goto LABEL_22;
        }
      }

      __nwlog_obj();
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      __int16 v34 = (const char *)*((void *)v16 + 2);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
      if (!v34) {
        __int16 v34 = "invalid";
      }
      v63 = 2082;
      v64 = (char *)v34;
      v65 = 2048;
      v66 = v16;
      v55 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v56 = 0;
      unint64_t v35 = (char *)v55;
      if (!__nwlog_fault(v55, &type, &v56))
      {
LABEL_74:
        if (v35) {
          free(v35);
        }
        v27 = 0;
        if (v22 != &nw_protocol_ref_counted_handle) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          v38 = (const char *)*((void *)v16 + 2);
          if (!v38) {
            v38 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
          v63 = 2082;
          v64 = (char *)v38;
          v65 = 2048;
          v66 = v16;
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback",  buf,  0x20u);
        }
      }

      else
      {
        if (v56)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v53 = type;
          v45 = os_log_type_enabled(v44, type);
          if (backtrace_string)
          {
            if (v45)
            {
              v46 = (const char *)*((void *)v16 + 2);
              if (!v46) {
                v46 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
              v63 = 2082;
              v64 = (char *)v46;
              v65 = 2048;
              v66 = v16;
              v67 = 2082;
              v68 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v44,  v53,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
          }

          else
          {
            if (v45)
            {
              v51 = (const char *)*((void *)v16 + 2);
              if (!v51) {
                v51 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
              v63 = 2082;
              v64 = (char *)v51;
              v65 = 2048;
              v66 = v16;
              _os_log_impl( &dword_181A5C000,  v44,  v53,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback, no backtrace",  buf,  0x20u);
            }
          }

          goto LABEL_73;
        }

        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v49 = type;
        if (os_log_type_enabled(v36, type))
        {
          v50 = (const char *)*((void *)v16 + 2);
          if (!v50) {
            v50 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
          v63 = 2082;
          v64 = (char *)v50;
          v65 = 2048;
          v66 = v16;
          _os_log_impl( &dword_181A5C000,  v36,  v49,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback, backtrace limit exceeded",  buf,  0x20u);
        }
      }

LABEL_73:
      unint64_t v35 = (char *)v55;
      goto LABEL_74;
    }

    __nwlog_obj();
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
    v40 = (char *)_os_log_send_and_compose_impl();

    v57[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v40, v57, &type))
    {
      if (v57[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v42 = v57[0];
        if (os_log_type_enabled(v41, v57[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
          _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null input_protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        v47 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v54 = v57[0];
        v48 = os_log_type_enabled(v41, v57[0]);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
            v63 = 2082;
            v64 = v47;
            _os_log_impl( &dword_181A5C000,  v41,  v54,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v47);
          goto LABEL_84;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
          _os_log_impl( &dword_181A5C000,  v41,  v54,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v52 = v57[0];
        if (os_log_type_enabled(v41, v57[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
          _os_log_impl( &dword_181A5C000,  v41,  v52,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }
  }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (!v8) {
      goto LABEL_23;
    }
LABEL_22:
    free(v8);
    goto LABEL_23;
  }

  if (v5[2] == 2)
  {
    v5[16] = a2;
    v5[17] = a3;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v24 = "nw_advertise_descriptor_set_invitation";
  __int16 v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint32_t v21 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    __int16 v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_advertise_descriptor_set_invitation";
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s Advertise descriptor not of type application service",  buf,  0xCu);
    }

  if (v10) {
    free(v10);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v18) {
    free(v18);
  }
  BOOL v13 = 0LL;
LABEL_4:

  return v13;
}

  if (v6) {
    free(v6);
  }
}

  if (v5) {
    free(v5);
  }
LABEL_4:
}

    if (v8) {
      free(v8);
    }
    goto LABEL_23;
  }

  uint64_t v3 = v1[1];

  if (v3)
  {
    uint64_t v4 = v3;

    uint64_t v5 = v4[10] == 5;
    goto LABEL_4;
  }

  if (v6) {
    free(v6);
  }
LABEL_4:
}

    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }

  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3 || (uint64_t v4 = *(void **)(v3 + 16)) == 0LL)
  {
LABEL_23:
    uint64_t v5 = 0LL;
    goto LABEL_24;
  }

  uint64_t v5 = xpc_array_get_count(v4) != 0;
LABEL_24:

  return v5;
}

  if (v6) {
    free(v6);
  }
LABEL_4:
}
  }

      goto LABEL_22;
    }

    if (!v20)
    {
      __nwlog_obj();
      __int16 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v19 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_set_metadata";
        _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_21;
    }

    __int16 v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v17 = type;
    __int16 v18 = os_log_type_enabled(v8, type);
    if (!v16)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_set_metadata";
        _os_log_impl(&dword_181A5C000, v8, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_21;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_parameters_set_metadata";
      v24 = 2082;
      v25 = v16;
      _os_log_impl( &dword_181A5C000,  v8,  v17,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v16);
  }

LABEL_22:
    if (!v13) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }

  if (!v44)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v14 = (os_log_s *)(id)gLogObj;
    v23 = type;
    if (os_log_type_enabled(v14, type))
    {
      v24 = v11;
      v25 = objc_msgSend(v24, "type", buf, v43);

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_set_service_identifier";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v25;
      _os_log_impl( &dword_181A5C000,  v14,  v23,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_21;
  }

  __int16 v18 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v14 = (os_log_s *)(id)gLogObj;
  unint64_t v19 = type;
  uint64_t v20 = os_log_type_enabled(v14, type);
  if (!v18)
  {
    if (v20)
    {
      v26 = v11;
      v27 = objc_msgSend(v26, "type", buf, v43);

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_set_service_identifier";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v27;
      _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_21;
  }

  if (v20)
  {
    uint32_t v21 = v11;
    uint64_t v22 = objc_msgSend(v21, "type", buf, v43);

    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_service_identifier";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v22;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v18;
    _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v18);
  if (v13)
  {
LABEL_23:
    int v28 = (char *)v13;
LABEL_24:
    free(v28);
  }
}

    free(v21);
    goto LABEL_22;
  }

  __nwlog_obj();
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v58 = "nwphRunProbe";
  v38 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v55 = 0;
  if (__nwlog_fault(v38, &type, &v55))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nwphRunProbe";
        v41 = "%{public}s called with null completion";
LABEL_91:
        _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0xCu);
      }
    }

    else
    {
      if (v55)
      {
        v48 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v40 = type;
        v49 = os_log_type_enabled(v39, type);
        if (v48)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446466;
            v58 = "nwphRunProbe";
            v59 = 2082;
            v60 = v48;
            _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s called with null completion, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v48);
          goto LABEL_93;
        }

        if (!v49) {
          goto LABEL_92;
        }
        *(_DWORD *)buf = 136446210;
        v58 = "nwphRunProbe";
        v41 = "%{public}s called with null completion, no backtrace";
        goto LABEL_91;
      }

      __nwlog_obj();
      v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nwphRunProbe";
        v41 = "%{public}s called with null completion, backtrace limit exceeded";
        goto LABEL_91;
      }
    }

    if (!v7)
    {
LABEL_23:
      uint64_t v5 = 0LL;
      goto LABEL_24;
    }

        goto LABEL_22;
      }

      if (!v22)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint32_t v21 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_endpoint_get_custom_data_length";
          _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v19 = type;
      uint64_t v20 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_endpoint_get_custom_data_length";
          _os_log_impl(&dword_181A5C000, v9, v19, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_21;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_endpoint_get_custom_data_length";
        v26 = 2082;
        v27 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v7)
    {
LABEL_23:
      uint64_t v5 = 0LL;
      goto LABEL_24;
    }
  }

  if (v4) {
    free(v4);
  }
  return 0LL;
}
  }

    if (!v8)
    {
LABEL_23:
      uint64_t v6 = 0LL;
      goto LABEL_24;
    }

  __int16 v16 = (dispatch_source_s *)v12[10];
  if (v16)
  {
    dispatch_source_cancel(v16);
    uint64_t v17 = (void *)v12[10];
    v12[10] = 0LL;
  }

    free(v8);
    goto LABEL_22;
  }

  uint64_t v3 = (void *)*((void *)v1 + 2);
  if (v3)
  {
    uint64_t v4 = nw_connection_copy_proxy_settings(v3);
    uint64_t v5 = v4;
    else {
      uint64_t v6 = 0LL;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "tcp_connection_copy_proxy";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    uint64_t v6 = 0LL;
  }

    free(v8);
    goto LABEL_22;
  }

  if (*(void *)&v3[4]._os_unfair_lock_opaque)
  {
    os_unfair_lock_lock(v3 + 30);
    os_unfair_lock_opaque = v4[29]._os_unfair_lock_opaque;
    if ((_DWORD)os_unfair_lock_opaque == -1)
    {
      if (SBYTE2(v4[39]._os_unfair_lock_opaque) < 0)
      {
        connected_socket = nw_connection_get_connected_socket(*(void **)&v4[4]._os_unfair_lock_opaque);
        if (connected_socket >= -1)
        {
          os_unfair_lock_opaque = dup(connected_socket);
          v4[29]._os_unfair_lock_opaque = os_unfair_lock_opaque;
          goto LABEL_31;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "tcp_connection_get_socket";
          _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot get socket on a connection for which client socket access is disallowed.",  buf,  0xCu);
        }
      }

      os_unfair_lock_opaque = 0xFFFFFFFFLL;
    }
}

    uint64_t v17 = tcp_connection_create_with_connected_fd_inner(v8, 1);
    if (!v17)
    {
      close(v8);
      tcp_listener_call_error_handler_locked((void *)v2, 12);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v28 = (os_log_s *)v4[131];
      id v1 = v44;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        __buf = 136446210;
        *(void *)v55 = "tcp_listener_accept_locked";
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s tcp_connection_create_inbound() returned non-zero",  (uint8_t *)&__buf,  0xCu);
      }

      goto LABEL_53;
    }

    __int16 v18 = v17;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    if (os_log_type_enabled((os_log_t)v4[131], OS_LOG_TYPE_DEBUG) || gLogFDOverride != -1)
    {
      unint64_t v19 = nw_endpoint_create_address(&address);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = (os_log_s *)v4[131];
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        uint32_t v21 = tcp_connection_id(v18);
        uint64_t v22 = nw_endpoint_get_logging_description(v19);
        __buf = 136446978;
        *(void *)v55 = "tcp_listener_accept_locked";
        *(_WORD *)&v55[8] = 2048;
        *(void *)&v55[10] = v21;
        uint64_t v4 = &qword_18C45F000;
        *(_WORD *)&v55[18] = 1024;
        *(_DWORD *)&v55[20] = v8;
        *(_WORD *)&v55[24] = 2082;
        *(void *)&v55[26] = v22;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s client connection %llu fd=%d from %{public}s",  (uint8_t *)&__buf,  0x26u);
      }

      if (v19) {
        os_release(v19);
      }
    }

    uint64_t v5 = *(void *)(v2 + 40);
    if (v5)
    {
      uint64_t v6 = *(dispatch_queue_s **)(v2 + 32);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = __tcp_listener_accept_locked_block_invoke;
      block[3] = &unk_189BBC8E0;
      block[5] = v18;
      block[6] = v2;
      block[4] = v5;
      dispatch_async(v6, block);
    }

    else
    {
      os_release(v18);
    }
  }

  v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  id v1 = v44;
  if (v23 != 35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      __buf = 136446466;
      *(void *)v55 = "tcp_listener_accept_locked";
      *(_WORD *)&v55[8] = 1024;
      *(_DWORD *)&v55[10] = v23;
      _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s accept failed %{darwin.errno}d",  (uint8_t *)&__buf,  0x12u);
    }

    tcp_listener_call_error_handler_locked((void *)v2, v23);
  }

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

      input_finished();
      return;
    }

    handle[184] = handle[184] & 0xFFC7 | 0x20;
    unint64_t v19 = a1->default_input_handler;
    if (v19)
    {
      uint64_t v20 = v19->callbacks;
      if (v20)
      {
        input_finished = (void (*)(void))v20->disconnected;
        if (input_finished) {
          goto LABEL_21;
        }
      }
    }

    __nwlog_obj();
    uint32_t v21 = a1->default_input_handler;
    uint64_t v22 = "invalid";
    if (v21)
    {
      v23 = v21->identifier;
      if (v23) {
        uint64_t v22 = (const char *)v23;
      }
    }

    *(_DWORD *)buf = 136446466;
    v82 = "nw_protocol_http_connect_input_finished";
    v83 = 2082;
    v84 = (void *)v22;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    v24 = (const char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v24, &type, &v79))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = (os_log_s *)__nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type)) {
          goto LABEL_152;
        }
        v27 = a1->default_input_handler;
        int v28 = "invalid";
        if (v27)
        {
          unint64_t v29 = v27->identifier;
          if (v29) {
            int v28 = (const char *)v29;
          }
        }

        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v28;
        unint64_t v30 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_151:
        _os_log_impl(&dword_181A5C000, v25, v26, v30, buf, 0x16u);
        goto LABEL_152;
      }

      if (!v79)
      {
        v25 = (os_log_s *)__nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type)) {
          goto LABEL_152;
        }
        v73 = a1->default_input_handler;
        v74 = "invalid";
        if (v73)
        {
          v75 = v73->identifier;
          if (v75) {
            v74 = (const char *)v75;
          }
        }

        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v74;
        unint64_t v30 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_151;
      }

      v60 = (char *)__nw_create_backtrace_string();
      v25 = (os_log_s *)__nwlog_obj();
      v26 = type;
      v61 = os_log_type_enabled(v25, type);
      if (!v60)
      {
        if (!v61) {
          goto LABEL_152;
        }
        v76 = a1->default_input_handler;
        v77 = "invalid";
        if (v76)
        {
          v78 = v76->identifier;
          if (v78) {
            v77 = (const char *)v78;
          }
        }

        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v77;
        unint64_t v30 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
        goto LABEL_151;
      }

      if (v61)
      {
        v62 = a1->default_input_handler;
        v63 = "invalid";
        if (v62)
        {
          v64 = v62->identifier;
          if (v64) {
            v63 = (const char *)v64;
          }
        }

        *(_DWORD *)buf = 136446722;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v63;
        v85 = 2082;
        v86 = v60;
        _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v60);
    }

  BOOL v13 = 0LL;
  if ((*(_WORD *)&self->_has & 0x400) != 0)
  {
LABEL_7:
    char v14 = 2654435761LL * self->_prohibitExpensive;
    if ((has & 0x40) != 0) {
      goto LABEL_8;
    }
    goto LABEL_23;
  }

LABEL_22:
    if (v5) {
      free(v5);
    }
    goto LABEL_24;
  }

  *(void *)cStr = 0LL;
  if ((*((_BYTE *)self + 136) & 1) != 0) {
    dispatch_time_t v2 = "SHOES";
  }
  else {
    dispatch_time_t v2 = "SOCKS";
  }
  asprintf((char **)cStr, "[SP%llu %s]", self->ss_id, v2);
  if (!*(void *)cStr)
  {
LABEL_24:
    uint64_t v3 = 0LL;
    return (NSString *)v3;
  }

  uint64_t v3 = (__CFString *)CFStringCreateWithCStringNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  *(const char **)cStr,  0x8000100u,  (CFAllocatorRef)*MEMORY[0x189604DB8]);
  return (NSString *)v3;
}

  if (v5) {
    free(v5);
  }
LABEL_5:
}

  if (v11) {
    free(v11);
  }
  return 4294966394LL;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

    if (!v7)
    {
LABEL_23:
      string = 0LL;
      goto LABEL_24;
    }

    if (gLogDatapath)
    {
      v46 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v257;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v9 + 616;
        _os_log_impl(&dword_181A5C000, v46, OS_LOG_TYPE_DEBUG, "%{public}s moved %u frames from %p to %p", buf, 0x26u);
      }
    }

  BOOL v13 = *(unsigned int *)(v1 + 840);
  if ((*(_BYTE *)(*(void *)(v1 + 480) + 376LL) & 1) != 0
    && (_DWORD)v13 == 4
    && !strncasecmp(*(const char **)(v1 + 800), "Host", v13))
  {
    char v14 = ":authority";
    uint64_t v15 = v3;
    __int16 v16 = -1LL;
  }

  else
  {
    char v14 = *(const char **)(v1 + 800);
    uint64_t v15 = v3;
    __int16 v16 = v13;
  }

  if (!nw_http_parsed_fields_add(v15, (unint64_t)v14, v16, v4, v9, 0))
  {
    if (*(_DWORD *)(v1 + 840))
    {
      if (*(_DWORD *)(v1 + 844))
      {
        if ((*(_BYTE *)(v1 + 158) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            __int16 v18 = *(void *)(v1 + 488);
            unint64_t v19 = *(_DWORD *)(*(void *)(v1 + 480) + 372LL);
            uint64_t v20 = *(_DWORD *)(v1 + 860);
            if (v18) {
              LODWORD(v18) = *(_DWORD *)(v18 + 424);
            }
            uint32_t v21 = *(_DWORD *)(v1 + 840);
            uint64_t v22 = *(void *)(v1 + 800);
            v23 = *(_DWORD *)(v1 + 844);
            v24 = *(void *)(v1 + 808);
            *(_DWORD *)buf = 136448515;
            v41 = "nw_http1_on_header_value_complete";
            v42 = 2082;
            v43 = (char *)(v1 + 74);
            v44 = 2080;
            v45 = " ";
            v46 = 1024;
            v47 = v19;
            v48 = 1024;
            v49 = v20;
            v50 = 1024;
            v51 = v18;
            v52 = 1040;
            v53 = v21;
            v54 = 2085;
            v55 = v22;
            v56 = 1040;
            v57 = v23;
            v58 = 2085;
            v59 = v24;
            _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> discarded invalid header %{sensitive}.*s with value %{sensitive}.*s",  buf,  0x52u);
          }
        }
      }
    }
  }

  v25 = *(void **)(v1 + 800);
  if (v25)
  {
    free(v25);
    *(void *)(v1 + 800) = 0LL;
  }

  *(_DWORD *)(v1 + 840) = 0;
  v26 = *(void **)(v1 + 808);
  if (v26)
  {
    free(v26);
    *(void *)(v1 + 808) = 0LL;
  }

  result = 0LL;
  *(_DWORD *)(v1 + 844) = 0;
  return result;
}

  if (v16) {
    free(v16);
  }
LABEL_5:

  return v2;
}

    uint64_t v15 = 0LL;
    goto LABEL_11;
  }

  BOOL v13 = *(void *)(a1 + 40);
  if (!v13) {
    goto LABEL_21;
  }
LABEL_8:
  char v14 = 248LL;
  if (!*(void *)(v13 + 248)) {
    char v14 = 240LL;
  }
  uint64_t v15 = (void **)*(id *)(v13 + v14);
LABEL_11:
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3221225472LL;
  v24[2] = __82__NWURLSessionStreamTask_readDataOfMinLength_maxLength_timeout_completionHandler___block_invoke_7;
  v24[3] = &unk_189BC55B0;
  v27 = *(id *)(a1 + 48);
  __int16 v16 = v7;
  int v28 = a3;
  uint64_t v17 = *(void *)(a1 + 40);
  v25 = v16;
  v26 = v17;
  if (v15) {
    -[NWURLSessionDelegateQueue runDelegateBlock:](v15[6], v24);
  }
  __int16 v18 = &v27;

  unint64_t v19 = *(void *)(a1 + 40);
  if (!a3) {
    goto LABEL_16;
  }
  if (!v19) {
    goto LABEL_23;
  }
  if (!*(_BYTE *)(v19 + 468))
  {
    *(_BYTE *)(v19 + 468) = 1;
    unint64_t v19 = *(void *)(a1 + 40);
LABEL_23:
    v23 = -[NWURLSessionTask delegateWrapper]((void *)v19);
    -[NWURLSessionDelegateWrapper readClosedForStreamTask:]((uint64_t)v23, *(void **)(a1 + 40));

    unint64_t v19 = *(void *)(a1 + 40);
  }

        unint64_t v29 = *(double *)(v24 + 328);
        if (v29 > 0.0)
        {
          unint64_t v30 = *(void *)(v24 + 336);
          if (v30)
          {
            v31 = dispatch_time(0x8000000000000000LL, (uint64_t)(v29 * 1000000000.0));
            if (*(void *)v30)
            {
              dispatch_source_set_timer(*(dispatch_source_t *)v30, v31, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
            }

            else
            {
              *(void *)(v30 + 32) = v31;
              *(void *)(v30 + 40) = -1LL;
              if (*(_BYTE *)(v30 + 48) && *(_BYTE *)(v30 + 49)) {
                nw_queue_source_run_timer(v30, v31);
              }
            }
          }

          else
          {
            *(void *)(v24 + 336) = -[NWURLSessionTask createTimerWithTimeout:](v24, v29);
          }
        }

        __int16 v32 = *(void **)(a1 + 32);
        if (v32)
        {
          v33 = (void *)v32[34];
          if (v33)
          {
            __int16 v34 = v33;
            [v32 error];
            unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
            v44[0] = MEMORY[0x1895F87A8];
            v44[1] = 3221225472LL;
            v44[2] = __36__NWURLSessionTask_readResponseBody__block_invoke_3;
            v44[3] = &unk_189BBEF38;
            uint64_t v36 = *(void **)(a1 + 40);
            v44[4] = *(void *)(a1 + 32);
            v46 = v23;
            v47 = a3;
            v37 = &v45;
            v45 = v36;
            -[NWURLSessionMultipartParser task:handleMultipartData:complete:error:completionHandler:]( (uint64_t)v34,  v32,  v7,  v23,  v35,  v44);
LABEL_31:

            __int16 v8 = v25;
            goto LABEL_32;
          }

          v38 = (void *)v32[53];
LABEL_30:
          __int16 v34 = v38;
          [v32 error];
          unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
          v40[0] = MEMORY[0x1895F87A8];
          v40[1] = 3221225472LL;
          v40[2] = __36__NWURLSessionTask_readResponseBody__block_invoke_6;
          v40[3] = &unk_189BBEF38;
          v39 = *(void **)(a1 + 40);
          v40[4] = *(void *)(a1 + 32);
          v42 = v23;
          v43 = a3;
          v37 = &v41;
          v41 = v39;
          [v34 task:v32 deliverData:v7 complete:v23 error:v35 completionHandler:v40];
          goto LABEL_31;
        }

    goto LABEL_22;
  }

  if (v7) {
    free(v7);
  }
}

  if (v7) {
    free(v7);
  }
}

  if (v8) {
    free(v8);
  }
}

  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v14;
  if (*(void *)(*(void *)(*v7 + 8LL) + 24LL)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  unint64_t v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }

    v33 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    uint32_t v21 = __src;
    __int16 v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      v52 = 2082;
      v53 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v33);
  }

  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v14;
  if (*(void *)(*(void *)(*v7 + 8LL) + 24LL)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  unint64_t v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }

    v33 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    uint32_t v21 = __src;
    __int16 v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      v52 = 2082;
      v53 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v33);
  }

  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v14;
  if (*(void *)(*(void *)(*v7 + 8LL) + 24LL)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  unint64_t v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }

    v33 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    uint32_t v21 = __src;
    __int16 v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      v52 = 2082;
      v53 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v33);
  }

  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v14;
  if (*(void *)(*(void *)(*v7 + 8LL) + 24LL)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  unint64_t v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }

    v33 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    uint32_t v21 = __src;
    __int16 v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      v52 = 2082;
      v53 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v33);
  }

    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 56), 22);
    return 0LL;
  }

  if (*((_WORD *)a2 + 1) != 25378)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v13 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      unint64_t v19 = *(void *)(a1 + 48);
      uint64_t v20 = "";
      uint32_t v21 = (const char *)(v19 + 4);
      __int16 v16 = v19 == 0;
      uint64_t v22 = *((unsigned __int16 *)a2 + 1);
      if (!v16) {
        uint64_t v20 = v21;
      }
      int v28 = 136446722;
      unint64_t v29 = "nw_tcpconverter_parse_response_block_invoke";
      unint64_t v30 = 2080;
      v31 = v20;
      __int16 v32 = 1024;
      LODWORD(v33) = bswap32(v22) >> 16;
      __int16 v18 = "%{public}s %s Invalid magic number received: %u";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_INFO, v18, (uint8_t *)&v28, 0x1Cu);
      goto LABEL_21;
    }

    goto LABEL_21;
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 4LL * a2[1];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v5 = *(void *)(v4 + 24);
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = v5 > v6;
  __int16 v8 = v5 - v6;
  if (v7)
  {
    *(void *)(v4 + 24) = v8;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
    return *(void *)(a1 + 64);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v25 = *(void *)(a1 + 48);
      if (v25) {
        v26 = (const char *)(v25 + 4);
      }
      else {
        v26 = "";
      }
      v27 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      int v28 = 136446722;
      unint64_t v29 = "nw_tcpconverter_parse_response_block_invoke";
      unint64_t v30 = 2080;
      v31 = v26;
      __int16 v32 = 2048;
      v33 = v27;
      _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_INFO,  "%{public}s %s Received too small total_length in the fixed header: %ld",  (uint8_t *)&v28,  0x20u);
    }

    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 56), 22);
    return 4LL;
  }

  if (v8) {
    free(v8);
  }
LABEL_4:

  return v3;
}

  if (v8) {
    free(v8);
  }
LABEL_4:

  return v3;
}

        uint64_t v7 = v10 + 1;
        uint64_t v22 = *v10;
        v23 = ~(-1 << v9);
        uint32_t v21 = v22 & v23;
        if ((v22 & v23) < v23) {
          goto LABEL_194;
        }
        char v14 = 0;
        uint64_t v20 = 1;
        do
        {
          if (v7 >= v8)
          {
            if ((v20 & 1) != 0) {
              v140 = 0;
            }
            else {
              v140 = *(_DWORD *)(a2 + 168);
            }
            v150 = v140 + (_DWORD)v7 - (_DWORD)v10;
            if (v150 >= 0xB)
            {
              v161 = 3658;
              goto LABEL_349;
            }

            *(void *)(a2 + 176) = v21;
LABEL_327:
            *(_DWORD *)(a2 + 164) = v14;
            *(_DWORD *)(a2 + 168) = v150;
            *(_DWORD *)(a2 + 160) = 1;
            return 2LL;
          }

    v47 = v12;
    v33 = v16[4];
    __int16 v34 = v16[5];
    unint64_t v35 = v22;
    uint64_t v36 = v34;
    v64[0] = v35;
    v64[1] = 3221225472LL;
    v64[2] = __117__NWURLSessionDelegateWrapper_dataTask_didReceiveData_complete_error_metrics_cachedResponse_cache_completionHandler___block_invoke;
    v64[3] = &unk_189BC7068;
    v48 = v23;
    v37 = v27;
    v38 = v25;
    v65 = v25;
    v66 = v33;
    v67 = v55;
    v68 = v54;
    v69 = v36;
    v79 = v56;
    v39 = v37;
    v80 = v58;
    v70 = v39;
    v71 = v16;
    v72 = v53;
    v73 = v51;
    v74 = v30;
    v75 = v31;
    v76 = v48;
    v77 = v32;
    v78 = v52;
    v40 = v16[6];
    v59 = v36;
    v41 = v33;
    v42 = v40;
    v25 = v38;
    v27 = v37;
    v23 = v48;
    -[NWURLSessionDelegateQueue runDelegateBlock:](v42, v64);

    uint64_t v12 = v47;
    goto LABEL_22;
  }

  if (v58)
  {
    -[NWURLSessionTask finishProgressReporting]((uint64_t)v11);
    v44 = -[NWURLSessionTask delegateWrapper](v11);
    if (v11) {
      Property = objc_getProperty(v11, v43, 440LL, 1);
    }
    else {
      Property = 0LL;
    }
    v46 = Property;
    -[NWURLSessionDelegateWrapper task:didCompleteWithError:metrics:]((uint64_t)v44, v11, v57, v46);
  }

  (*((void (**)(id, void))v13 + 2))(v13, 0LL);
LABEL_24:
}

  if (v7) {
    free(v7);
  }
LABEL_4:
}

  if (v7) {
    free(v7);
  }
LABEL_4:
}

  if (v7) {
    free(v7);
  }
LABEL_4:
}

    __break(1u);
    return;
  }

  if (v6) {
    free(v6);
  }
LABEL_4:
}

      CFDataGetBytePtr(*(CFDataRef *)(a2 + 112));
      CFDataGetLength(*(CFDataRef *)(a2 + 112));
      if (*(void *)(a1 + 48)) {
        uint64_t v15 = NEHelperCopyXPCEndpointForIdentityProxyExtended();
      }
      else {
        uint64_t v15 = NEHelperCopyXPCEndpointForIdentityProxy();
      }
      __int16 v16 = (void *)v15;
      if (v15)
      {
        uint64_t v17 = objc_alloc_init(MEMORY[0x189607B58]);
        [v17 _setEndpoint:v16];
        v30[0] = 0LL;
        __int16 v18 = (__SecIdentity *)[MEMORY[0x18960AFC0] createIdentityFromEndpoint:v17 error:v30];
        unint64_t v19 = (__SecIdentity *)v30[0];
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)(id)gLogObj;
        uint32_t v21 = v20;
        if (v19)
        {
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
            uint64_t v36 = 2112;
            v37 = v19;
            _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to fetch identity from NEHelper: %@",  buf,  0x16u);
          }

          *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
        }

        else
        {
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
            uint64_t v36 = 2112;
            v37 = v18;
            _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s Fetched identity %@ from NEHelper",  buf,  0x16u);
          }
        }

        if (v18)
        {
          if (Mutable) {
            v24 = sec_identity_create_with_certificates(v18, Mutable);
          }
          else {
            v24 = sec_identity_create(v18);
          }
          v25 = v24;
          if ((*(_WORD *)(a2 + 215) & 0x2000) != 0)
          {
            *(void *)buf = 0LL;
            if (!SecIdentityCopyCertificate(v18, (SecCertificateRef *)buf))
            {
              v26 = SecCertificateCopyKey(*(SecCertificateRef *)buf);
              if (v26)
              {
                v27 = (const void *)SecKeyCopySubjectPublicKeyInfo();
                if (v27)
                {
                  int v28 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
                  CFArrayAppendValue(v28, v27);
                  sec_protocol_options_set_client_raw_public_key_certificates();
                  if (v28) {
                    CFRelease(v28);
                  }
                  CFRelease(v27);
                  Mutable = 0LL;
                }

                CFRelease(v26);
              }

              if (*(void *)buf) {
                CFRelease(*(CFTypeRef *)buf);
              }
            }
          }

          sec_protocol_options_set_local_identity(*(sec_protocol_options_t *)(a2 + 96), v25);

          CFRelease(v18);
        }

        if (Mutable) {
          CFRelease(Mutable);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          v23 = *(__SecIdentity **)(a2 + 112);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
          uint64_t v36 = 2112;
          v37 = v23;
          _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to copy xpc endpoint for client identity %@",  buf,  0x16u);
        }

        if (Mutable) {
          CFRelease(Mutable);
        }
        *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
      }
    }

    _Block_object_dispose(&v31, 8);
  }

  return 1LL;
}

      v25 = (unint64_t)v7->u64 + v6;
      v26 = v11 + 1;
      do
      {
        int v28 = *v10++;
        v27 = v28;
        *v26++ = v27;
      }

      while ((unint64_t)v10 < v25);
      goto LABEL_25;
    }

    goto LABEL_33;
  }

    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_activity_retrieve_metrics_block_invoke_2;
    block[3] = &unk_189BC16F8;
    __int16 v16 = (dispatch_queue_s *)v6;
    v54 = v16;
    v57 = v10;
    v56 = v8;
    v55 = v5;
    uint64_t v17 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v10, 0, block);
    dispatch_async(v16, v17);

    goto LABEL_22;
  }

  __nwlog_obj();
  __int16 v32 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446466;
  v65 = "nw_activity_retrieve_metrics";
  v66 = 2082;
  v67 = "Cannot retrieve metrics before activation";
  v33 = (char *)_os_log_send_and_compose_impl();

  v63 = OS_LOG_TYPE_ERROR;
  v62 = 0;
  if (__nwlog_fault(v33, &v63, &v62))
  {
    if (v63 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v35 = v63;
      if (os_log_type_enabled(v34, v63))
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }

    else if (v62)
    {
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v39 = v63;
      v40 = os_log_type_enabled(v34, v63);
      if (v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446722;
          v65 = "nw_activity_retrieve_metrics";
          v66 = 2082;
          v67 = "Cannot retrieve metrics before activation";
          v68 = 2082;
          v69 = v38;
          _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v38);
        goto LABEL_98;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace",  buf,  0x16u);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = v63;
      if (os_log_type_enabled(v34, v63))
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl( &dword_181A5C000,  v34,  v47,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded",  buf,  0x16u);
      }
    }
  }

    free(v10);
    goto LABEL_22;
  }

  uint64_t v5 = v4->_name;
  uint64_t v6 = -[NSString UTF8String](v5, "UTF8String");
  if ((*(_BYTE *)&v4->_has & 0x20) != 0)
  {
    uint64_t v7 = v4->_type;
    if ((*(_BYTE *)&v4->_has & 0x10) != 0) {
      goto LABEL_4;
    }
LABEL_10:
    subos_log_type_t type = 0;
    goto LABEL_11;
  }

  uint64_t v7 = 0;
  if ((*(_BYTE *)&v4->_has & 0x10) == 0) {
    goto LABEL_10;
  }
LABEL_4:
  subos_log_type_t type = v4->_subtype;
LABEL_11:
  char v14 = nw_interface_create_static( v6,  v4->_index,  v7,  subtype,  v4->_generation,  v4->_delegateIndex,  v4->_expensive,  0,  v4->_mtu,  0,  0);
  if (v14) {
    uint64_t v15 = -[NWInterface initWithInterface:](objc_alloc(&OBJC_CLASS___NWInterface), "initWithInterface:", v14);
  }
  else {
    uint64_t v15 = 0LL;
  }

LABEL_23:
  return v15;
}

  if (v6) {
    free(v6);
  }
LABEL_4:
}

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  v3[2] = a2;
  *((_BYTE *)v3 + 24) &= ~2u;
  arc4random_buf(v3 + 4, 8uLL);
  return v4;
}

          free(v13);
          if (!v9) {
            return 0LL;
          }
          goto LABEL_185;
        }

        if (v143)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socket_connect";
          uint64_t v12 = "%{public}s called with null socket_handler, no backtrace";
          goto LABEL_183;
        }
      }

      else
      {
        __int16 v10 = (os_log_s *)__nwlog_obj();
        sae_srcif = type.sae_srcif;
        if (os_log_type_enabled(v10, type.sae_srcif))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socket_connect";
          uint64_t v12 = "%{public}s called with null socket_handler, backtrace limit exceeded";
          goto LABEL_183;
        }
      }
    }

    goto LABEL_184;
  }

  if ((*(_DWORD *)&a1[4].flow_id[12] & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socket_connect";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type.sae_srcif) = 16;
    LOBYTE(v160) = 0;
    if (LOBYTE(type.sae_srcif) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v10 = (os_log_s *)gLogObj;
      sae_srcif = type.sae_srcif;
      if (!os_log_type_enabled((os_log_t)gLogObj, type.sae_srcif)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socket_connect";
      uint64_t v12 = "%{public}s called with null socket_handler->fd";
    }

    else if ((_BYTE)v160)
    {
      BOOL v13 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v10 = (os_log_s *)gLogObj;
      sae_srcif = type.sae_srcif;
      char v14 = os_log_type_enabled((os_log_t)gLogObj, type.sae_srcif);
      if (v13)
      {
        if (!v14) {
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v13;
        uint64_t v15 = "%{public}s called with null socket_handler->fd, dumping backtrace:%{public}s";
        goto LABEL_20;
      }

      if (!v14) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socket_connect";
      uint64_t v12 = "%{public}s called with null socket_handler->fd, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v10 = (os_log_s *)gLogObj;
      sae_srcif = type.sae_srcif;
      if (!os_log_type_enabled((os_log_t)gLogObj, type.sae_srcif)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socket_connect";
      uint64_t v12 = "%{public}s called with null socket_handler->fd, backtrace limit exceeded";
    }

    if (v4) {
      free(v4);
    }
    return *(unsigned int *)v20;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_protocol_socket_get_receive_buffer_size";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();
  v20[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v19) = 0;
  if (__nwlog_fault(v11, v20, &v19))
  {
    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        char v14 = "%{public}s called with null handle";
LABEL_37:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      }
    }

    else if ((_BYTE)v19)
    {
      uint64_t v15 = (char *)__nw_create_backtrace_string();
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = v20[0];
      __int16 v16 = os_log_type_enabled(v12, v20[0]);
      if (v15)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_protocol_socket_get_receive_buffer_size";
          v23 = 2082;
          *(void *)v24 = v15;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        goto LABEL_38;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        char v14 = "%{public}s called with null handle, no backtrace";
        goto LABEL_37;
      }
    }

    else
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_socket_get_receive_buffer_size";
        char v14 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
  }

    if (v4) {
      free(v4);
    }
    return *(unsigned int *)v20;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_protocol_socket_get_send_buffer_size";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();
  v20[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v19) = 0;
  if (__nwlog_fault(v11, v20, &v19))
  {
    if (v20[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_socket_get_send_buffer_size";
        char v14 = "%{public}s called with null handle";
LABEL_37:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      }
    }

    else if ((_BYTE)v19)
    {
      uint64_t v15 = (char *)__nw_create_backtrace_string();
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = v20[0];
      __int16 v16 = os_log_type_enabled(v12, v20[0]);
      if (v15)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_protocol_socket_get_send_buffer_size";
          v23 = 2082;
          *(void *)v24 = v15;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        goto LABEL_38;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_socket_get_send_buffer_size";
        char v14 = "%{public}s called with null handle, no backtrace";
        goto LABEL_37;
      }
    }

    else
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = v20[0];
      if (os_log_type_enabled(v12, v20[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_socket_get_send_buffer_size";
        char v14 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
  }

    if (v11) {
      free(v11);
    }
    goto LABEL_23;
  }

  uint64_t v7 = v5[9];
  if (!v7 || *(void *)(v7 + 24) == *(void *)(v7 + 16))
  {
LABEL_23:
    nexus_instance = 0LL;
    goto LABEL_24;
  }

  nw_array_get_object_at_index(v7, 0LL);
  __int16 v8 = (void *)objc_claimAutoreleasedReturnValue();
  nexus_instance = nw_path_flow_get_nexus_instance(v8, a2, a3);

LABEL_24:
  return nexus_instance;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_23;
  }

  uint64_t v5 = v3[9];
  if (!v5 || *(void *)(v5 + 24) == *(void *)(v5 + 16))
  {
LABEL_23:
    nexus_key = 0LL;
    goto LABEL_24;
  }

  nw_array_get_object_at_index(v5, 0LL);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  nexus_key = nw_path_flow_get_nexus_key(v6, a2);

LABEL_24:
  return nexus_key;
}

    unint64_t v35 = *(void **)(a1 + 32);
    if (v35) {
      unint64_t v35 = (void *)v35[6];
    }
    uint64_t v36 = v35;
    v37 = (void *)[v19 copy];
    v46[0] = MEMORY[0x1895F87A8];
    v46[1] = 3221225472LL;
    v46[2] = __34__NWURLLoaderHTTP_continueLoading__block_invoke_13;
    v46[3] = &unk_189BC5D48;
    v46[4] = *(void *)(a1 + 32);
    v47 = v13;
    [v36 loaderWillPerformHTTPRedirection:v15 newRequest:v37 completionHandler:v46];

LABEL_24:
    goto LABEL_25;
  }

  (*((void (**)(id, void, void, void))v13 + 2))(v13, 0LL, 0LL, 0LL);
LABEL_25:
}

    goto LABEL_22;
  }

  uint64_t v4 = calloc(1uLL, 8uLL);
  if (v4)
  {
LABEL_3:
    *uint64_t v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "strict_calloc";
  unint64_t v19 = 2048;
  uint64_t v20 = 1LL;
  uint32_t v21 = 2048;
  uint64_t v22 = 8LL;
  uint64_t v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = calloc(1uLL, 0x50uLL);
  if (v4)
  {
LABEL_3:
    *((_DWORD *)v4 + 16) = *(_DWORD *)(a2 + 64);
    *((_DWORD *)v4 + 18) = *(_DWORD *)(a2 + 72);
    *((_OWORD *)v4 + 1) = *(_OWORD *)(a2 + 16);
    *((void *)v4 + 4) = *(void *)(a2 + 32);
    uint64_t v5 = *((_BYTE *)v4 + 77) & 0xFE | *(_BYTE *)(a2 + 77) & 1;
    *((_BYTE *)v4 + 77) = v5;
    *((_BYTE *)v4 + 77) = v5 & 0xFD | *(_BYTE *)(a2 + 77) & 2;
    *((_BYTE *)v4 + 76) = *(_BYTE *)(a2 + 76);
    uint64_t v6 = _Block_copy(*(const void **)(a2 + 48));
    uint64_t v7 = (void *)*((void *)v4 + 6);
    *((void *)v4 + 6) = v6;

    objc_storeStrong((id *)v4 + 7, *(id *)(a2 + 56));
    __int16 v8 = _Block_copy(*(const void **)(a2 + 40));
    os_log_type_t v9 = (void *)*((void *)v4 + 5);
    *((void *)v4 + 5) = v8;

    *((_DWORD *)v4 + 17) = *(_DWORD *)(a2 + 68);
    *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v23 = "strict_calloc";
  v24 = 2048;
  v25 = 1LL;
  v26 = 2048;
  v27 = 80LL;
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

    goto LABEL_22;
  }

  uint64_t v4 = (char *)calloc(1uLL, 0x20uLL);
  if (v4)
  {
LABEL_3:
    *(_OWORD *)(v4 + 8) = *(_OWORD *)(a2 + 8);
    v4[24] = v4[24] & 0xFE | *(_BYTE *)(a2 + 24) & 1;
    uint64_t v5 = _Block_copy(*(const void **)a2);
    uint64_t v6 = *(void **)v4;
    *(void *)uint64_t v4 = v5;

LABEL_4:
    return (BOOL)v4;
  }

  __nwlog_obj();
  BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v20 = "strict_calloc";
  uint32_t v21 = 2048;
  uint64_t v22 = 1LL;
  v23 = 2048;
  v24 = 32LL;
  char v14 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v12) {
    free(v12);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

  if (v10) {
    free(v10);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
LABEL_5:
}

    goto LABEL_22;
  }

  uint64_t v4 = (id *)calloc(1uLL, 0x10uLL);
  if (v4)
  {
LABEL_3:
    objc_storeStrong(v4, *(id *)a2);
    *((_BYTE *)v4 + 8) = (_BYTE)v4[1] & 0xFE | *(_BYTE *)(a2 + 8) & 1;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "strict_calloc";
  unint64_t v19 = 2048;
  uint64_t v20 = 1LL;
  uint32_t v21 = 2048;
  uint64_t v22 = 16LL;
  uint64_t v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

    goto LABEL_22;
  }

  uint64_t v4 = (id *)calloc(1uLL, 0x30uLL);
  if (v4)
  {
LABEL_3:
    objc_storeStrong(v4 + 5, *(id *)(a2 + 40));
    uint64_t v5 = _Block_copy(*(const void **)a2);
    uint64_t v6 = *v4;
    *uint64_t v4 = v5;

    objc_storeStrong(v4 + 1, *(id *)(a2 + 8));
    objc_storeStrong(v4 + 2, *(id *)(a2 + 16));
    objc_storeStrong(v4 + 3, *(id *)(a2 + 24));
    objc_storeStrong(v4 + 4, *(id *)(a2 + 32));
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v20 = "strict_calloc";
  uint32_t v21 = 2048;
  uint64_t v22 = 1LL;
  v23 = 2048;
  v24 = 48LL;
  char v14 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = calloc(1uLL, 4uLL);
  if (v4)
  {
LABEL_3:
    *uint64_t v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "strict_calloc";
  unint64_t v19 = 2048;
  uint64_t v20 = 1LL;
  uint32_t v21 = 2048;
  uint64_t v22 = 4LL;
  uint64_t v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = calloc(1uLL, 0x18uLL);
  if (v4)
  {
LABEL_3:
    *((_DWORD *)v4 + 4) = *(_DWORD *)(a2 + 16);
    uint64_t v5 = _Block_copy(*(const void **)a2);
    uint64_t v6 = *(void **)v4;
    *(void *)uint64_t v4 = v5;

    objc_storeStrong((id *)v4 + 1, *(id *)(a2 + 8));
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v20 = "strict_calloc";
  uint32_t v21 = 2048;
  uint64_t v22 = 1LL;
  v23 = 2048;
  v24 = 24LL;
  char v14 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = calloc(1uLL, 4uLL);
  if (v4)
  {
LABEL_3:
    *uint64_t v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "strict_calloc";
  unint64_t v19 = 2048;
  uint64_t v20 = 1LL;
  uint32_t v21 = 2048;
  uint64_t v22 = 4LL;
  uint64_t v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = (id *)calloc(1uLL, 0x28uLL);
  if (v4)
  {
LABEL_3:
    objc_storeStrong(v4, *(id *)a2);
    uint64_t v5 = _Block_copy(*(const void **)(a2 + 16));
    uint64_t v6 = v4[2];
    v4[2] = v5;

    objc_storeStrong(v4 + 3, *(id *)(a2 + 24));
    uint64_t v7 = (_BYTE)v4[4] & 0xFE | *(_BYTE *)(a2 + 32) & 1;
    *((_BYTE *)v4 + 32) = v7;
    *((_BYTE *)v4 + 32) = v7 & 0xFD | *(_BYTE *)(a2 + 32) & 2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint32_t v21 = "strict_calloc";
  uint64_t v22 = 2048;
  v23 = 1LL;
  v24 = 2048;
  v25 = 40LL;
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v15);
  if (!result)
  {
    free(v15);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = calloc(1uLL, 4uLL);
  if (v4)
  {
LABEL_3:
    *uint64_t v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "strict_calloc";
  unint64_t v19 = 2048;
  uint64_t v20 = 1LL;
  uint32_t v21 = 2048;
  uint64_t v22 = 4LL;
  uint64_t v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = calloc(1uLL, 4uLL);
  if (v4)
  {
LABEL_3:
    *uint64_t v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v18 = "strict_calloc";
  unint64_t v19 = 2048;
  uint64_t v20 = 1LL;
  uint32_t v21 = 2048;
  uint64_t v22 = 4LL;
  uint64_t v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}
  }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v10) {
    free(v10);
  }
  return url != 0LL;
}

  if (v7) {
    free(v7);
  }
  return 0LL;
}

    goto LABEL_22;
  }

  uint64_t v4 = (void **)calloc(1uLL, 0x10uLL);
  if (v4)
  {
LABEL_3:
    uint64_t v5 = _Block_copy(*a2);
    uint64_t v6 = *v4;
    *uint64_t v4 = v5;

    uint64_t v7 = _Block_copy(a2[1]);
    __int16 v8 = v4[1];
    v4[1] = v7;

LABEL_4:
    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v22 = "strict_calloc";
  v23 = 2048;
  v24 = 1LL;
  v25 = 2048;
  v26 = 16LL;
  __int16 v16 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v16);
  if (!result)
  {
    free(v16);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if ((char *)v4 - (char *)v5 == (char *)v9 - v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_http_messaging_remove_listen_handler";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (os_log_s *)gLogObj;
      uint64_t v15 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_http_messaging_remove_listen_handler";
        __int16 v16 = "%{public}s ignoring request to remove protocol listen handler, does not match our handler";
LABEL_39:
        _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        goto LABEL_40;
      }

      goto LABEL_40;
    }

    if (!v24)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (os_log_s *)gLogObj;
      uint64_t v15 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_http_messaging_remove_listen_handler";
        __int16 v16 = "%{public}s ignoring request to remove protocol listen handler, does not match our handler, backtrace limit exceeded";
        goto LABEL_39;
      }

    if (!v7) {
      return;
    }
    BOOL v13 = (char *)v7;
    goto LABEL_23;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v28 = "nw_parallel_array_get_at_index";
  char v14 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v15 = (os_log_s *)__nwlog_obj();
    __int16 v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_78;
    }
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_parallel_array_get_at_index";
    uint64_t v17 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size())";
    goto LABEL_77;
  }

  if (!v25)
  {
    uint64_t v15 = (os_log_s *)__nwlog_obj();
    __int16 v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_78;
    }
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_parallel_array_get_at_index";
    uint64_t v17 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size()), backtrace limit exceeded";
    goto LABEL_77;
  }

  uint64_t v20 = (char *)__nw_create_backtrace_string();
  uint64_t v15 = (os_log_s *)__nwlog_obj();
  __int16 v16 = type;
  v24 = os_log_type_enabled(v15, type);
  if (!v20)
  {
    if (!v24) {
      goto LABEL_78;
    }
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_parallel_array_get_at_index";
    uint64_t v17 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size()), no backtrace";
    goto LABEL_77;
  }

  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    int v28 = "nw_parallel_array_get_at_index";
    unint64_t v29 = 2082;
    unint64_t v30 = v20;
    uint64_t v22 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size()), dumping backtrace:%{public}s";
    goto LABEL_58;
  }

  if (v4) {
LABEL_13:
  }
    free(v4);
LABEL_14:
  uint64_t v11 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v11)
  {
    free(v11);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  }

          free(v14);
          if (!v8) {
            return;
          }
LABEL_32:
          free(v8);
          return;
        }

        if (!v40) {
          goto LABEL_31;
        }
        v43 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)buf = 136446978;
        v47 = "http2_input_frame_metadata_reset";
        v48 = 2082;
        v49 = (void *)v34;
        v50 = 2080;
        v51 = v39;
        v52 = 1024;
        v53 = v43;
        BOOL v13 = "%{public}s %{public}s%s<i%u> frame has no metadata, no backtrace";
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v36 = gconnectionLogObj;
        v37 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_31;
        }
        v42 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)buf = 136446978;
        v47 = "http2_input_frame_metadata_reset";
        v48 = 2082;
        v49 = (void *)v34;
        v50 = 2080;
        v51 = v31;
        v52 = 1024;
        v53 = v42;
        BOOL v13 = "%{public}s %{public}s%s<i%u> frame has no metadata, backtrace limit exceeded";
      }
    }

    v26 = (os_log_s *)v36;
    v27 = v37;
    int v28 = 38;
    goto LABEL_30;
  }

  if ((*(__int16 *)(a2 + 388) & 0x80000000) == 0)
  {
    v31 = " ";
    goto LABEL_47;
  }

    __int16 v16 = *(char **)(v6 + 152);
    v30[0] = MEMORY[0x1895F87A8];
    v30[1] = 0x40000000LL;
    v30[2] = ___ZL24nw_protocol_http2_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke;
    v30[3] = &__block_descriptor_tmp_87_82621;
    v30[4] = v6;
    v30[5] = a2;
    v31 = a3;
    v30[6] = a4;
    v30[7] = a5;
    nw_hash_table_apply(v16, (uint64_t)v30);
    return;
  }

  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 + 24);
    if (v12)
    {
      BOOL v13 = *(void (**)(void))(v12 + 160);
      if (v13) {
        v13();
      }
    }
  }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (!v6) {
      goto LABEL_23;
    }
LABEL_22:
    free(v6);
    goto LABEL_23;
  }

  if (*((_DWORD *)v3 + 2) == 2)
  {
    *((_DWORD *)v3 + 22) = a2;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_browse_descriptor_set_device_types";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v19 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    __int16 v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_browse_descriptor_set_device_types";
      _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
    }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (!v6) {
      goto LABEL_23;
    }
LABEL_22:
    free(v6);
    goto LABEL_23;
  }

  if (*((_DWORD *)v3 + 2) == 2)
  {
    *((_DWORD *)v3 + 23) = a2;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_browse_descriptor_set_browse_scope";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v19 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    __int16 v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_browse_descriptor_set_browse_scope";
      _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
    }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

    if (v6) {
      free(v6);
    }
    goto LABEL_23;
  }

  if (*((_DWORD *)v1 + 2) != 1 || (uint64_t v3 = v1[2]) == 0LL)
  {
LABEL_23:
    uint64_t v4 = 0LL;
    goto LABEL_24;
  }

  uint64_t v4 = strcmp(v3, "_services._dns-sd._udp") == 0;
LABEL_24:

  return v4;
}

    if (!v6) {
      goto LABEL_23;
    }
LABEL_22:
    free(v6);
    goto LABEL_23;
  }

  if (*((_DWORD *)v3 + 2) == 2)
  {
    *((_DWORD *)v3 + 24) = a2;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_browse_descriptor_set_invitation_scope";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v19 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    __int16 v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_browse_descriptor_set_invitation_scope";
      _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
    }

    if (!v5)
    {
LABEL_23:
      uint64_t v3 = 0LL;
      goto LABEL_24;
    }

        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          __int16 v18 = *(void *)(a2 + 88);
          if (v18)
          {
            unint64_t v19 = v18 - 1;
            *(void *)(a2 + 88) = v19;
            if (!v19)
            {
              uint64_t v20 = *(void (***)(void))(a2 + 64);
              if (v20)
              {
                *(void *)(a2 + 64) = 0LL;
                v20[2](v20);
                _Block_release(v20);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                uint32_t v21 = *(const void **)(a2 + 64);
                if (v21) {
                  _Block_release(v21);
                }
              }

              free((void *)a2);
            }
          }
        }

        goto LABEL_22;
      }
    }

    __nwlog_obj();
    __int16 v32 = *(const char **)(a2 + 16);
    *(_DWORD *)buf = 136446722;
    v49 = "__nw_protocol_get_output_local_endpoint";
    if (!v32) {
      __int16 v32 = "invalid";
    }
    v50 = 2082;
    v51 = (void *)v32;
    v52 = 2048;
    v53 = (const char *)a2;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    v45 = (char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v45, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = (os_log_s *)__nwlog_obj();
        __int16 v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_138;
        }
        unint64_t v35 = *(const char **)(a2 + 16);
        if (!v35) {
          unint64_t v35 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v35;
        v52 = 2048;
        v53 = (const char *)a2;
        uint64_t v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback";
LABEL_137:
        _os_log_impl(&dword_181A5C000, v33, v34, v36, buf, 0x20u);
        goto LABEL_138;
      }

      if (!v46)
      {
        v33 = (os_log_s *)__nwlog_obj();
        __int16 v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_138;
        }
        v43 = *(const char **)(a2 + 16);
        if (!v43) {
          v43 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v43;
        v52 = 2048;
        v53 = (const char *)a2;
        uint64_t v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, backtrace limit exceeded";
        goto LABEL_137;
      }

      v40 = (char *)__nw_create_backtrace_string();
      v33 = (os_log_s *)__nwlog_obj();
      __int16 v34 = type;
      v41 = os_log_type_enabled(v33, type);
      if (!v40)
      {
        __int16 v8 = a1 + 96;
        if (!v41) {
          goto LABEL_138;
        }
        v44 = *(const char **)(a2 + 16);
        if (!v44) {
          v44 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v44;
        v52 = 2048;
        v53 = (const char *)a2;
        uint64_t v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, no backtrace";
        goto LABEL_137;
      }

      if (v41)
      {
        v42 = *(const char **)(a2 + 16);
        if (!v42) {
          v42 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v42;
        v52 = 2048;
        v53 = (const char *)a2;
        v54 = 2082;
        v55 = v40;
        _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v40);
      __int16 v8 = a1 + 96;
    }

LABEL_22:
  if (v5) {
    free(v5);
  }
}

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  os_log_type_t v9 = (id *)calloc(1uLL, 0x20uLL);
  if (v9)
  {
LABEL_23:
    objc_storeStrong(v9 + 2, *(id *)(a1 + 40));
    objc_storeStrong(v9 + 3, *(id *)(a1 + 48));
    *os_log_type_t v9 = 0LL;
    __int16 v10 = *(id ***)(*(void *)(a1 + 32) + 168LL);
    v9[1] = v10;
    const char *v10 = v9;
    uint64_t v11 = *(void *)(a1 + 32);
LABEL_25:
    *(void *)(v11 + 168) = v9;
    return;
  }

  __nwlog_obj();
  BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  char v14 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v14))
  {
    free(v14);
    goto LABEL_23;
  }

  __break(1u);
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_5:

  return v3;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 1LL;
LABEL_5:

  return v5;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = "";
LABEL_5:

  return v3;
}

  if (v7) {
    free(v7);
  }
  uint64_t v4 = "null";
LABEL_5:

  return v4;
}

  if (v5) {
    free(v5);
  }
  dispatch_time_t v2 = 0LL;
LABEL_5:

  return v2;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_5:

  return v3;
}

  if (v5) {
    free(v5);
  }
  dispatch_time_t v2 = 0LL;
LABEL_5:

  return v2;
}

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}
}

    __break(1u);
    return;
  }

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

  if (v8) {
    free(v8);
  }
  uint64_t v4 = 0LL;
LABEL_5:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_3;
  }

  if (!uuid_is_null((const unsigned __int8 *)(v1[13] + 24LL)))
  {
    uint64_t v3 = uuid_compare((const unsigned __int8 *)(v2[13] + 24LL), (const unsigned __int8 *)(v2[13] + 8LL)) != 0;
    goto LABEL_5;
  }

    if (v8) {
      free(v8);
    }
    goto LABEL_24;
  }

  if (v1[94] != 2)
  {
LABEL_24:
    uint64_t v6 = 0LL;
    goto LABEL_25;
  }

  uint64_t v3 = v1[95];
  uint64_t v4 = v3 > 0x1F;
  uint64_t v5 = (0xBC000168 >> v3) & 1;
  if (v4) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = v5;
  }
LABEL_25:

  return v6;
}

  if (v5) {
    free(v5);
  }
  dispatch_time_t v2 = 0;
LABEL_5:

  return v2;
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v19 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  unint64_t v30 = "nw_endpoint_handler_get_svcb_report";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v21 = (os_log_s *)(id)gLogObj;
    uint64_t v22 = type;
    if (os_log_type_enabled(v21, type))
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v30 = "nw_endpoint_handler_get_svcb_report";
      _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
    }

  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0LL;
LABEL_5:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_3;
  }

  if (!*((void *)v1 + 9))
  {
    uint64_t v3 = *((void *)v1 + 10) == 0LL;
    goto LABEL_5;
  }

    goto LABEL_23;
  }

  if (!v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v13 = (os_log_s *)(id)gLogObj;
    unint64_t v30 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v35 = "-[NWConcrete_nw_endpoint_flow dealloc]";
      _os_log_impl( &dword_181A5C000,  v13,  v30,  "%{public}s write requests not drained, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_22;
  }

  v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v13 = (os_log_s *)(id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v13, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v35 = "-[NWConcrete_nw_endpoint_flow dealloc]";
      _os_log_impl(&dword_181A5C000, v13, v26, "%{public}s write requests not drained, no backtrace", buf, 0xCu);
    }

    goto LABEL_22;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v35 = "-[NWConcrete_nw_endpoint_flow dealloc]";
    uint64_t v36 = 2082;
    v37 = v25;
    _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s write requests not drained, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v25);
  if (v12) {
LABEL_24:
  }
    free(v12);
LABEL_25:
  tcp_info = self->tcp_info;
  if (tcp_info)
  {
    free(tcp_info);
    self->tcp_info = 0LL;
  }

  tcp_connection_info = self->tcp_connection_info;
  if (tcp_connection_info)
  {
    free(tcp_connection_info);
    self->tcp_connection_info = 0LL;
  }

  data_transfer_snapshot = self->data_transfer_snapshot;
  if (data_transfer_snapshot)
  {
    free(data_transfer_snapshot);
    self->data_transfer_snapshot = 0LL;
  }

  context = self->shared_protocol.context;
  self->shared_protocol.context = 0LL;

  v31.receiver = self;
  v31.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_endpoint_flow;
  -[NWConcrete_nw_endpoint_flow dealloc](&v31, sel_dealloc);
}

  sub_181C54438(0x2E312F5054544820LL, 0xEB000000000A0D31LL);
  if (v3)
  {
    sub_181C54438(0x203A74736F48LL, 0xE600000000000000LL);
    if ((sub_181BCE7EC(v7, v10) & 1) != 0)
    {
      v70 = v7;
      v71 = v10;
      swift_bridgeObjectRetain();
      sub_181BE7A14((uint64_t *)&v70);
      swift_bridgeObjectRelease();
    }

    else
    {
      sub_181C94A88(v7, v10);
    }

    sub_181C54438(2573LL, 0xE200000000000000LL);
  }

  swift_retain();
  v63 = (uint64_t *)(v55 + 16);
  swift_beginAccess();
  char v14 = *(void *)(v55 + 16);
  uint64_t v15 = *(void *)(v14 + 16);
  if (v15)
  {
    v54 = 0;
    __int16 v16 = 0LL;
    while (v16 < v15)
    {
      uint64_t v17 = (void *)(v14 + (v16 << 6));
      __int16 v18 = v17[4];
      unint64_t v19 = v17[5];
      ++v16;
      uint64_t v20 = v17[6] == 0x65696B6F6F63LL && v17[7] == 0xE600000000000000LL;
      v66 = v16;
      if (v20 || (v22 = v17[9], uint32_t v21 = v17[10], (sub_18264F4EC() & 1) != 0))
      {
        if (!v54)
        {
          swift_bridgeObjectRetain();
          sub_181C54438(v18, v19);
          sub_181C54438(8250LL, 0xE200000000000000LL);
          __int16 v32 = sub_181C1DA34();
          if (*(void *)(v32 + 16) && (v33 = sub_181C8C01C(0x65696B6F6F63LL, 0xE600000000000000LL), (v34 & 1) != 0)) {
            unint64_t v35 = *(_WORD *)(*(void *)(v32 + 56) + 4 * v33);
          }
          else {
            unint64_t v35 = -1;
          }
          swift_bridgeObjectRelease();
          swift_beginAccess();
          uint64_t v36 = swift_bridgeObjectRetain();
          v37 = sub_181C23934(v36, v35);
          swift_bridgeObjectRelease();
          v38 = *(void *)(v37 + 16);
          v60 = v38;
          v54 = v38 != 0;
          if (!v38)
          {
LABEL_102:
            swift_release();
            sub_181C54438(2573LL, 0xE200000000000000LL);
            __int16 v16 = v66;
            goto LABEL_103;
          }

          v39 = 0;
          v40 = 0LL;
          v56 = v37;
          v58 = v37 + 32;
LABEL_73:
          if (v40 >= *(void *)(v37 + 16)) {
            goto LABEL_110;
          }
          v67 = v6;
          v41 = v58 + 56 * v40;
          v43 = *(void *)(v41 + 40);
          v42 = *(void *)(v41 + 48);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if ((v39 & 1) != 0) {
            sub_181C54438(8251LL, 0xE200000000000000LL);
          }
          v64 = v40 + 1;
          if ((v42 & 0x2000000000000000LL) != 0) {
            v44 = HIBYTE(v42) & 0xF;
          }
          else {
            v44 = v43 & 0xFFFFFFFFFFFFLL;
          }
          v45 = (v43 >> 59) & 1;
          if ((v42 & 0x1000000000000000LL) == 0) {
            LOBYTE(v45) = 1;
          }
          v46 = 4LL << v45;
          v47 = 15LL;
          while (1)
          {
            while (1)
            {
              if (4 * v44 == v47 >> 14)
              {
                v68 = v43;
                v69 = v42;
                swift_bridgeObjectRetain();
                uint64_t v6 = v67;
                sub_181BE7A14((uint64_t *)&v68);
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
LABEL_72:
                swift_bridgeObjectRelease();
                v37 = v56;
                ++v40;
                v39 = 1;
                if (v64 == v60) {
                  goto LABEL_102;
                }
                goto LABEL_73;
              }

              v48 = v47 & 0xC;
              v49 = v47;
              if (v48 == v46) {
                v49 = sub_181C23710(v47, v43, v42);
              }
              v50 = v49 >> 16;
              if (v49 >> 16 >= v44)
              {
LABEL_107:
                __break(1u);
LABEL_108:
                __break(1u);
                goto LABEL_109;
              }

              if ((v42 & 0x1000000000000000LL) == 0) {
                break;
              }
              v52 = sub_18264EBC8();
              if (v48 == v46) {
                goto LABEL_92;
              }
LABEL_95:
              if ((v42 & 0x1000000000000000LL) == 0) {
                goto LABEL_82;
              }
LABEL_96:
              if (v44 <= v47 >> 16) {
                goto LABEL_108;
              }
              v47 = sub_18264EB98();
              if (v52 < 0)
              {
LABEL_71:
                uint64_t v6 = v67;
                sub_181C94A88(v43, v42);
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                goto LABEL_72;
              }
            }

            if ((v42 & 0x2000000000000000LL) != 0)
            {
              v68 = v43;
              v69 = v42 & 0xFFFFFFFFFFFFFFLL;
              v52 = *((_BYTE *)&v68 + v50);
              if (v48 == v46) {
                goto LABEL_92;
              }
              goto LABEL_95;
            }

            v51 = (v42 & 0xFFFFFFFFFFFFFFFLL) + 32;
            if ((v43 & 0x1000000000000000LL) == 0) {
              v51 = sub_18264F228();
            }
            v52 = *(_BYTE *)(v51 + v50);
            if (v48 != v46) {
              goto LABEL_95;
            }
LABEL_92:
            v47 = sub_181C23710(v47, v43, v42);
            if ((v42 & 0x1000000000000000LL) != 0) {
              goto LABEL_96;
            }
LABEL_82:
            v47 = (v47 & 0xFFFFFFFFFFFF0000LL) + 65540;
            if (v52 < 0) {
              goto LABEL_71;
            }
          }
        }

        v54 = 1;
LABEL_103:
        swift_beginAccess();
        char v14 = *v63;
        uint64_t v15 = *(void *)(*v63 + 16);
        if (v16 == v15) {
          goto LABEL_104;
        }
      }

      else
      {
        swift_bridgeObjectRetain_n();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        sub_181C54438(v18, v19);
        sub_181C54438(8250LL, 0xE200000000000000LL);
        if ((v21 & 0x2000000000000000LL) != 0) {
          v23 = HIBYTE(v21) & 0xF;
        }
        else {
          v23 = v22 & 0xFFFFFFFFFFFFLL;
        }
        v24 = (v22 >> 59) & 1;
        if ((v21 & 0x1000000000000000LL) == 0) {
          LOBYTE(v24) = 1;
        }
        v25 = 4LL << v24;
        v26 = 15LL;
        while (4 * v23 != v26 >> 14)
        {
          v27 = v26 & 0xC;
          int v28 = v26;
          if (v27 == v25) {
            int v28 = sub_181C23710(v26, v22, v21);
          }
          unint64_t v29 = v28 >> 16;
          if (v28 >> 16 >= v23)
          {
            __break(1u);
LABEL_106:
            __break(1u);
            goto LABEL_107;
          }

          if ((v21 & 0x1000000000000000LL) != 0)
          {
            v31 = sub_18264EBC8();
            if (v27 == v25) {
              goto LABEL_53;
            }
LABEL_56:
            if ((v21 & 0x1000000000000000LL) == 0) {
              goto LABEL_43;
            }
LABEL_57:
            if (v23 <= v26 >> 16) {
              goto LABEL_106;
            }
            v26 = sub_18264EB98();
            if (v31 < 0)
            {
LABEL_29:
              sub_181C94A88(v22, v21);
              swift_bridgeObjectRelease();
              swift_bridgeObjectRelease();
              goto LABEL_30;
            }
          }

          else
          {
            if ((v21 & 0x2000000000000000LL) != 0)
            {
              v68 = v22;
              v69 = v21 & 0xFFFFFFFFFFFFFFLL;
              v31 = *((_BYTE *)&v68 + v29);
              if (v27 == v25) {
                goto LABEL_53;
              }
              goto LABEL_56;
            }

            unint64_t v30 = (v21 & 0xFFFFFFFFFFFFFFFLL) + 32;
            if ((v22 & 0x1000000000000000LL) == 0) {
              unint64_t v30 = sub_18264F228();
            }
            v31 = *(_BYTE *)(v30 + v29);
            if (v27 != v25) {
              goto LABEL_56;
            }
LABEL_53:
            v26 = sub_181C23710(v26, v22, v21);
            if ((v21 & 0x1000000000000000LL) != 0) {
              goto LABEL_57;
            }
LABEL_43:
            v26 = (v26 & 0xFFFFFFFFFFFF0000LL) + 65540;
            if (v31 < 0) {
              goto LABEL_29;
            }
          }
        }

        v68 = v22;
        v69 = v21;
        swift_bridgeObjectRetain();
        sub_181BE7A14((uint64_t *)&v68);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
LABEL_30:
        swift_bridgeObjectRelease();
        sub_181C54438(2573LL, 0xE200000000000000LL);
        swift_beginAccess();
        char v14 = *v63;
        uint64_t v15 = *(void *)(*v63 + 16);
        __int16 v16 = v66;
        if (v66 == v15) {
          goto LABEL_104;
        }
      }
    }

      unint64_t v19 = v14;
LABEL_23:
      *((void *)v3 + 2) = v19;
    }
  }

  uint64_t v6 = (int64_t)a2;
  uint64_t v7 = result;
  isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
  if (!(_DWORD)isUniquelyReferenced_nonNull_native || (os_log_type_t v9 = *((void *)v3 + 3) >> 1, v9 < v5))
  {
    if (v4 <= v5) {
      __int16 v10 = v5;
    }
    else {
      __int16 v10 = v4;
    }
    uint64_t v3 = sub_181BC4A78(isUniquelyReferenced_nonNull_native, v10, 1, v3);
    os_log_type_t v9 = *((void *)v3 + 3) >> 1;
  }

  uint64_t v11 = *((void *)v3 + 2);
  uint64_t v12 = v9 - v11;
  result = sub_181C62ACC(&v3[v11 + 32], v9 - v11, v7, v6);
  if (v13 < v6) {
    goto LABEL_15;
  }
  if (v13 >= 1)
  {
    uint64_t v15 = *((void *)v3 + 2);
    __int16 v16 = __OFADD__(v15, v13);
    uint64_t v17 = v15 + v13;
    if (v16)
    {
      __break(1u);
      goto LABEL_22;
    }

    *((void *)v3 + 2) = v17;
  }

  if (v13 == v12) {
    goto LABEL_16;
  }
LABEL_13:
  *dispatch_time_t v2 = v3;
  return result;
}

      v47 = (char *)a4;
      v48 = a5;
      v49 = sub_181C94200;
      v50 = 0LL;
      sub_181C86A84(v12, v13);
      __swift_instantiateConcreteTypeFromMangledName(&qword_18C58D498);
      sub_181C02894((unint64_t *)&unk_18C58D4A0, &qword_18C58D498, MEMORY[0x189619618]);
      sub_18264EB14();
      unint64_t v19 = 0LL;
      uint32_t v21 = 0xE000000000000000LL;
LABEL_23:
      uint64_t v22 = sub_181C02668(v19, v21);
      v24 = v23;
      swift_bridgeObjectRelease();
      if ((a6 & 1) != 0)
      {
        sub_181C7DE74(v12, v13);
LABEL_25:
        v46 = v22;
        v25 = (void *)(a1 + 16);
        swift_beginAccess();
        v26 = *(void **)(a1 + 16);
        isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
        *(void *)(a1 + 16) = v26;
        int v28 = v24;
        if ((isUniquelyReferenced_nonNull_native & 1) == 0)
        {
          v26 = sub_181BC58B4(0LL, v26[2] + 1LL, 1, v26);
          void *v25 = v26;
        }

        unint64_t v30 = v26[2];
        unint64_t v29 = v26[3];
        if (v30 >= v29 >> 1)
        {
          v26 = sub_181BC58B4((void *)(v29 > 1), v30 + 1, 1, v26);
          void *v25 = v26;
        }

        v26[2] = v30 + 1;
        v31 = &v26[7 * v30];
        v31[4] = v12;
        v31[5] = v13;
        v31[6] = v14;
        v31[7] = v15;
        *((_BYTE *)v31 + 64) = 0;
        v31[9] = v46;
        v31[10] = v28;
        goto LABEL_42;
      }

      if (v14 == 0x69726F687475613ALL && v15 == 0xEA00000000007974LL)
      {
        sub_181C7DE74(v12, v13);
      }

      else
      {
        v45 = sub_18264F4EC();
        sub_181C7DE74(v12, v13);
        if ((v45 & 1) == 0) {
          goto LABEL_25;
        }
      }

      swift_beginAccess();
      v47 = (char *)v12;
      v48 = v13;
      v49 = (unsigned __int8 *(*)@<X0>(unsigned __int8 *@<X0>, _DWORD *@<X8>))v14;
      v50 = v15;
      v51 = 0;
      v52 = v22;
      v53 = v24;
      sub_181BF7584(0LL, 0LL, (uint64_t)&v47);
LABEL_42:
      swift_endAccess();
      swift_release();
      return 1LL;
    }

    goto LABEL_34;
  }

  __int16 v10 = sub_18264EB20();
  uint64_t v12 = v10;
  BOOL v13 = v11;
  if ((a6 & 1) != 0)
  {
    HTTPField.Name.init(parsed:)(v10, v11, (uint64_t)&v47);
    goto LABEL_5;
  }

  __int16 v16 = HIBYTE(v11) & 0xF;
  if ((v11 & 0x2000000000000000LL) == 0) {
    __int16 v16 = v10 & 0xFFFFFFFFFFFFLL;
  }
  if (v16 && (sub_181C2B750(v10, v11) & 1) != 0)
  {
    char v14 = sub_18264EAB4();
    uint64_t v15 = v17;
    swift_retain();
    if (a5 >= 1) {
      goto LABEL_14;
    }
    goto LABEL_7;
  }

  swift_bridgeObjectRelease();
  swift_retain();
LABEL_34:
  sub_181C2ECE0();
  __int16 v32 = (void *)swift_allocError();
  *v33 = 0;
  swift_willThrow();
  __int16 v34 = v32;
  if (qword_18C58B248 != -1) {
    swift_once();
  }
  unint64_t v35 = sub_18264E934();
  __swift_project_value_buffer(v35, (uint64_t)qword_18C5A4A30);
  uint64_t v36 = v32;
  v37 = v32;
  v38 = (os_log_s *)sub_18264E91C();
  v39 = sub_18264F000();
  if (os_log_type_enabled(v38, v39))
  {
    v40 = (uint8_t *)swift_slowAlloc();
    v41 = (void *)swift_slowAlloc();
    *(_DWORD *)v40 = 138543362;
    v42 = v32;
    v43 = _swift_stdlib_bridgeErrorToNSError();
    v47 = (char *)v43;
    sub_18264F0CC();
    *v41 = v43;

    _os_log_impl(&dword_181A5C000, v38, v39, "Failed to parse HTTP field: %{public}@", v40, 0xCu);
    __swift_instantiateConcreteTypeFromMangledName(&qword_18C58D610);
    swift_arrayDestroy();
    MEMORY[0x186E12168](v41, -1LL, -1LL);
    MEMORY[0x186E12168](v40, -1LL, -1LL);
    swift_release();
  }

  else
  {
    swift_release();
  }

  return 0LL;
}

    __int16 v16 = (v22 - 1) & v22;
    __int16 v18 = __clz(__rbit64(v22)) + (v13 << 6);
LABEL_9:
    unint64_t v19 = *(void *)(v28 + 72) * v18;
    sub_181BC9248( *(void *)(v8 + 48) + v19,  (uint64_t)v7,  (uint64_t (*)(void))type metadata accessor for NWActorID);
    uint64_t v20 = *(void *)(v29 + 72) * v18;
    sub_181BC9248(*(void *)(v8 + 56) + v20, (uint64_t)v4, type metadata accessor for NWActorDiscoveryMechanism);
    sub_181BC928C( (uint64_t)v7,  *(void *)(v10 + 48) + v19,  (uint64_t (*)(void))type metadata accessor for NWActorID);
    result = (void *)sub_181BC928C( (uint64_t)v4,  *(void *)(v10 + 56) + v20,  type metadata accessor for NWActorDiscoveryMechanism);
  }

  v23 = v21 + 2;
  if (v23 >= v27)
  {
LABEL_23:
    result = (void *)swift_release();
    id v1 = v25;
    goto LABEL_25;
  }

  uint64_t v22 = *(void *)(v26 + 8 * v23);
  if (v22)
  {
    BOOL v13 = v23;
    goto LABEL_22;
  }

  while (1)
  {
    BOOL v13 = v23 + 1;
    if (__OFADD__(v23, 1LL)) {
      break;
    }
    if (v13 >= v27) {
      goto LABEL_23;
    }
    uint64_t v22 = *(void *)(v26 + 8 * v13);
    ++v23;
    if (v22) {
      goto LABEL_22;
    }
  }

    BOOL v13 = (v20 - 1) & v20;
    uint64_t v15 = __clz(__rbit64(v20)) + (v10 << 6);
LABEL_9:
    __int16 v16 = 8 * v15;
    uint64_t v17 = *(void *)(*(void *)(v5 + 48) + 8 * v15);
    __int16 v18 = *(void *)(v2 + 72) * v15;
    (*(void (**)(char *, unint64_t, uint64_t))(v2 + 16))(v4, *(void *)(v5 + 56) + v18, v1);
    *(void *)(*(void *)(v7 + 48) + v16) = v17;
    result = (void *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v2 + 32))( *(void *)(v7 + 56) + v18,  v4,  v1);
  }

  uint32_t v21 = v19 + 2;
  if (v21 >= v25) {
    goto LABEL_23;
  }
  uint64_t v20 = *(void *)(v24 + 8 * v21);
  if (v20)
  {
    __int16 v10 = v21;
    goto LABEL_22;
  }

  while (1)
  {
    __int16 v10 = v21 + 1;
    if (__OFADD__(v21, 1LL)) {
      break;
    }
    if (v10 >= v25) {
      goto LABEL_23;
    }
    uint64_t v20 = *(void *)(v24 + 8 * v10);
    ++v21;
    if (v20) {
      goto LABEL_22;
    }
  }

    BOOL v13 = (v28 - 1) & v28;
    v44 = v29;
    uint32_t v21 = __clz(__rbit64(v28)) + (v29 << 6);
LABEL_9:
    v23 = *(void *)(v14 + 72) * v21;
    (*(void (**)(char *, unint64_t, uint64_t))(v14 + 16))(v17, *(void *)(v22 + 48) + v23, v16);
    v24 = *(void *)(v15 + 72) * v21;
    v25 = *(void *)(v22 + 56) + v24;
    v26 = v40;
    (*(void (**)(char *, unint64_t, uint64_t))(v15 + 16))(v40, v25, v18);
    (*(void (**)(unint64_t, char *, uint64_t))(v14 + 32))(*(void *)(v19 + 48) + v23, v17, v16);
    result = (char *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v15 + 32))( *(void *)(v19 + 56) + v24,  v26,  v18);
    __int16 v10 = v44;
  }

  unint64_t v30 = v27 + 2;
  if (v30 >= v35)
  {
LABEL_23:
    result = (char *)swift_release();
    v31 = v33;
    __int16 v32 = v43;
    goto LABEL_25;
  }

  int v28 = *(void *)(v34 + 8 * v30);
  if (v28)
  {
    unint64_t v29 = v30;
    goto LABEL_22;
  }

  while (1)
  {
    unint64_t v29 = v30 + 1;
    if (__OFADD__(v30, 1LL)) {
      break;
    }
    if (v29 >= v35) {
      goto LABEL_23;
    }
    int v28 = *(void *)(v34 + 8 * v29);
    ++v30;
    if (v28) {
      goto LABEL_22;
    }
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_protocol_shoes_waiting_for_output";
    uint64_t v7 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_shoes_get_remote_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "operator()";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_http_sniffing_remove_input_handler";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

  {
    sImageTypeRules(void)::rules = 0LL;
    unk_18C5A2BF0 = "GIF87a";
    qword_18C5A2BF8 = 6LL;
    unk_18C5A2C00 = kNWMIMETypeImageGIF;
    qword_18C5A2C08 = 0LL;
    unk_18C5A2C10 = "GIF89a";
    qword_18C5A2C18 = 6LL;
    unk_18C5A2C20 = kNWMIMETypeImageGIF;
    qword_18C5A2C28 = 0LL;
    unk_18C5A2C30 = "\x89PNG\r\n\x1A\n";
    qword_18C5A2C38 = 8LL;
    unk_18C5A2C40 = kNWMIMETypeImagePNG;
    qword_18C5A2C48 = 0LL;
    unk_18C5A2C50 = "\xFF\xD8\xFF";
    qword_18C5A2C58 = 3LL;
    unk_18C5A2C60 = kNWMIMETypeImageJPEG;
    qword_18C5A2C68 = 0LL;
    unk_18C5A2C70 = "BM";
    qword_18C5A2C78 = 2LL;
    unk_18C5A2C80 = kNWMIMETypeImageBMP;
    qword_18C5A2C88 = 0LL;
    unk_18C5A2C90 = &unk_18266712F;
    qword_18C5A2C98 = 4LL;
    unk_18C5A2CA0 = kNWMIMETypeImageICO;
    qword_18C5A2CA8 = 0LL;
    unk_18C5A2CB0 = 0LL;
    qword_18C5A2CB8 = 0LL;
    unk_18C5A2CC0 = "";
  }

  nw_http_sniffing_get_mime_type_for_rule_array( &v29,  *(void *)(a2 + 520),  *(void *)(a2 + 528),  &sImageTypeRules(void)::rules,  1);
  *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&v29.__r_.__value_.__l.__data_;
  uint64_t v12 = v29.__r_.__value_.__l.__cap_;
  a1->__r_.__value_.__l.__cap_ = v29.__r_.__value_.__l.__cap_;
  uint64_t v5 = HIBYTE(v12);
  if ((v5 & 0x80) == 0)
  {
LABEL_8:
    if ((_BYTE)v5) {
      goto LABEL_9;
    }
    goto LABEL_27;
  }

    operator delete(v25[0]);
    if ((v24 & 0x80000000) == 0)
    {
LABEL_11:
      if ((v22 & 0x80000000) == 0) {
        goto LABEL_12;
      }
      goto LABEL_24;
    }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_http_redirect_remove_input_handler";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

  if (v7) {
    free(v7);
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

          __int16 v10 = 0;
          goto LABEL_23;
        }

        if (gLogDatapath)
        {
          v38 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_retry_disconnected";
            _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s sending disconnected because disconnect was received",  buf,  0xCu);
          }
        }
      }

    if (v10) {
      free(v10);
    }
    goto LABEL_4;
  }

  if (v11) {
    free(v11);
  }
  uint64_t v7 = 0LL;
LABEL_3:

  is_equal = nw_dispatch_data_is_equal(v7, *(dispatch_data_s **)(a1 + 32));
  if (is_equal) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
  }
  return !is_equal;
}

                uint64_t v3 = 4;
              }

LABEL_24:
              continue;
            }
          }
        }

        if (gLogDatapath)
        {
          __nwlog_obj();
          uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            v46 = *(void *)(a1 + 32);
            v47 = *(void *)(a1 + 72);
            *(_DWORD *)buf = 136446978;
            v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
            v61 = 2112;
            v62 = v46;
            v63 = 2048;
            v64 = v4;
            v65 = 2080;
            v66 = v47;
            uint64_t v17 = v7;
            __int16 v18 = "%{public}s %@ instance %p of %s not eligible, missing required callbacks";
            goto LABEL_69;
          }

LABEL_23:
    if (v3) {
      free(v3);
    }
    return 0LL;
  }

  return a1->sa_family != 30 || a1->sa_len < 0x18u || (a1->sa_data[6] & 0xFE) != 0xFC;
}

    if (!v8) {
      goto LABEL_24;
    }
LABEL_23:
    free(v8);
    goto LABEL_24;
  }

  nw_endpoint_edge_get_endpoint(v4);
  uint64_t v6 = (id)objc_claimAutoreleasedReturnValue();

  if (v6 == v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v32 = "nw_endpoint_add_edge";
    __int16 v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      __int16 v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_endpoint_add_edge";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s endpoints cannot add edges to themselves", buf, 0xCu);
      }

  if (v11) {
    free(v11);
  }
LABEL_5:
}

  if (v10) {
    free(v10);
  }
  uint64_t v5 = 0LL;
LABEL_5:

  return v5;
}

    goto LABEL_42;
  }

  if (gLogDatapath) {
    __int16 v10 = logging_disabled;
  }
  else {
    __int16 v10 = 1;
  }
  if ((v10 & 1) == 0)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    v54 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
    {
      v55 = *(void *)(a1 + 48);
      v56 = *(_DWORD *)(*(void *)(a1 + 40) + 168LL);
      v57 = *(void *)(a1 + 80);
      v58 = *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL);
      *(_DWORD *)applier = 136447490;
      *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
      *(_WORD *)&applier[12] = 1024;
      *(_DWORD *)&applier[14] = v56;
      *(_WORD *)&applier[18] = 1024;
      *(_DWORD *)&applier[20] = v58;
      *(_WORD *)&applier[24] = 2048;
      *(void *)&applier[26] = v3;
      *(_WORD *)&applier[34] = 2048;
      *(void *)&applier[36] = v57;
      *(_WORD *)&applier[44] = 2112;
      *(void *)&applier[46] = v55;
      _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] calling sendto(%d, %p, %zu, 0, %@)",  applier,  0x36u);
    }
  }

  uint64_t v11 = sendto( *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL),  v3,  *(void *)(a1 + 80),  0,  address,  address->sa_len);
  uint64_t v12 = v11;
  if (v11 < 0)
  {
    uint64_t v20 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v21 = (id)gLogObj;
    uint64_t v22 = *v5;
    *(_DWORD *)applier = 136446722;
    *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
    *(_WORD *)&applier[12] = 2112;
    *(void *)&applier[14] = v22;
    *(_WORD *)&applier[22] = 1024;
    *(_DWORD *)&applier[24] = v20;
    v23 = (void *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v59[0]) = 0;
    if (__nwlog_fault((const char *)v23, type, v59))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        v25 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          v26 = *v5;
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
          *(_WORD *)&applier[12] = 2112;
          *(void *)&applier[14] = v26;
          *(_WORD *)&applier[22] = 1024;
          *(_DWORD *)&applier[24] = v20;
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s sendto failed for %@ %{darwin.errno}d", applier, 0x1Cu);
        }
      }

      else if (LOBYTE(v59[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        v44 = type[0];
        v45 = os_log_type_enabled(v24, type[0]);
        if (backtrace_string)
        {
          if (v45)
          {
            v46 = *v5;
            *(_DWORD *)applier = 136446978;
            *(void *)&applier[4] = "nw_connection_group_send_message_on_socket_block_invoke";
            *(_WORD *)&applier[12] = 2112;
            *(void *)&applier[14] = v46;
            *(_WORD *)&applier[22] = 1024;
            *(_DWORD *)&applier[24] = v20;
            *(_WORD *)&applier[28] = 2082;
            *(void *)&applier[30] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v44,  "%{public}s sendto failed for %@ %{darwin.errno}d, dumping backtrace:%{public}s",  applier,  0x26u);
          }

          free(backtrace_string);
          if (!v23)
          {
LABEL_42:
            BOOL v13 = 0;
            if (!v3) {
              goto LABEL_44;
            }
            goto LABEL_43;
          }

    if (v5) {
LABEL_23:
    }
      free(v5);
LABEL_24:
    __int16 v8 = 0LL;
    goto LABEL_25;
  }

  __int16 v8 = 1LL;
LABEL_25:

  return v8;
}

  if (v5) {
    free(v5);
  }
LABEL_5:
}
  }

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 1LL;
LABEL_5:

  return v3;
}

  if (v10) {
    free(v10);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_http_authentication_remove_input_handler";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

  if (v17) {
    free(v17);
  }
  char v14 = 0LL;
LABEL_6:

  return v14;
}

    free(v5);
    goto LABEL_23;
  }

  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_advertise_descriptor_get_invitation_scope";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_advertise_descriptor_get_invitation_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Advertise descriptor not of type application service",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_advertise_descriptor_get_invitation_scope";
          v23 = 2082;
          v24 = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Advertise descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_advertise_descriptor_get_invitation_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Advertise descriptor not of type application service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_advertise_descriptor_get_invitation_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Advertise descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = v1[16];
LABEL_24:

  return v3;
}

    free(v5);
    goto LABEL_23;
  }

  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_advertise_descriptor_get_invitation_route";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_advertise_descriptor_get_invitation_route";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Advertise descriptor not of type application service",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_advertise_descriptor_get_invitation_route";
          v23 = 2082;
          v24 = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Advertise descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_advertise_descriptor_get_invitation_route";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Advertise descriptor not of type application service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_advertise_descriptor_get_invitation_route";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Advertise descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = v1[17];
LABEL_24:

  return v3;
}

            os_release(v15);
            goto LABEL_23;
          }

          __nwlog_obj();
          v74 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)os_log_type_t type = 136446210;
          *(void *)&type[4] = "nw_http_cookie_options_get_allow_only_partitioned_cookies";
          v71 = (char *)_os_log_send_and_compose_impl();

          v107[0] = 16;
          LOBYTE(v111[0]) = 0;
          if (__nwlog_fault(v71, v107, v111))
          {
            if (v107[0] == 17)
            {
              __nwlog_obj();
              v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v75 = v107[0];
              if (os_log_type_enabled(v72, (os_log_type_t)v107[0]))
              {
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http_cookie_options_get_allow_only_partitioned_cookies";
                _os_log_impl(&dword_181A5C000, v72, v75, "%{public}s protocol options are not http_cookie", type, 0xCu);
              }

      __int16 v16 = 0LL;
      goto LABEL_23;
    }

    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
    v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (__nwlog_fault(v25, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v44)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v33 = type;
        __int16 v34 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v26,  v33,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_63;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v26, v33, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v36 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
          _os_log_impl( &dword_181A5C000,  v26,  v36,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v6) {
      free(v6);
    }
    mode = 0;
    goto LABEL_25;
  }

  mode = v1->mode;

  if (mode == 2)
  {
    uint64_t v4 = nw_endpoint_handler_copy_flow(v2);
    if ((*((_BYTE *)v4 + 32) & 8) != 0)
    {
      *((void *)v4 + 19) = nw_flow_input_available;
      *((void *)v4 + 20) = nw_flow_output_available;
      *((void *)v4 + 17) = nw_flow_disconnected;
      *((void *)v4 + 31) = nw_flow_notify;
      *((void *)v4 + 33) = nw_flow_supports_external_data;
      *((void *)v4 + 34) = nw_flow_input_finished;
    }

    goto LABEL_46;
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_top_expect_connected";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_top_expect_disconnected";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_bottom_expect_disconnect";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_bottom_expect_reset";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_expect_frames_consumed";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_get_path";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_get_parameters";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_get_local";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_trainer_get_remote";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  if (v10) {
    free(v10);
  }
LABEL_5:
}

      unint64_t v19 = *(void **)(a1 + 32);
      uint64_t v20 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 22);
      nw_listener_set_state_on_queue(v19, 3, v20);

      goto LABEL_196;
    }

    if (!*(void *)(v15 + 32)) {
      goto LABEL_48;
    }
    goto LABEL_47;
  }

  uint64_t v15 = *(void *)(a1 + 32);
  if (*(void *)(v15 + 32))
  {
LABEL_47:
    if (!*((_BYTE *)v122 + 24))
    {
      v63 = *(void *)(v15 + 16);
      if (v63 && !nw_path_parameters_get_logging_disabled(*(void *)(v63 + 104)))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
        }
        v64 = (os_log_s *)(id)glistenerLogObj;
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          v65 = nw_listener_get_id_string(*(void **)(a1 + 32));
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v65;
          _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] Started without setting new packet handler",  buf,  0x16u);
        }
      }

      goto LABEL_22;
    }

    goto LABEL_48;
  }

  if (!*((_BYTE *)v126 + 24))
  {
    v26 = *(void *)(v15 + 16);
    if (v26 && !nw_path_parameters_get_logging_disabled(*(void *)(v26 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      v27 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        int v28 = nw_listener_get_id_string(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_listener_start_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v28;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] Started without setting either new connection handler or new connection group handler",  buf,  0x16u);
      }
    }

    unint64_t v29 = *(void **)(a1 + 32);
    posix_error = nw_error_create_posix_error(22);
    nw_listener_set_state_on_queue(v29, 3, posix_error);

    goto LABEL_196;
  }

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v4) {
    free(v4);
  }
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:
}

    goto LABEL_23;
  }

  if (!v20)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v8 = (os_log_s *)(id)gLogObj;
    BOOL v13 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_parameters_set_initial_data_payload";
      _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s initial_data_payload is empty, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_22;
  }

  __int16 v10 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v8 = (os_log_s *)(id)gLogObj;
  uint64_t v11 = type;
  uint64_t v12 = os_log_type_enabled(v8, type);
  if (!v10)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_parameters_set_initial_data_payload";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s initial_data_payload is empty, no backtrace", buf, 0xCu);
    }

    goto LABEL_22;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_parameters_set_initial_data_payload";
    v24 = 2082;
    v25 = v10;
    _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s initial_data_payload is empty, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v7) {
    goto LABEL_24;
  }
LABEL_5:
}

  if (v7) {
LABEL_23:
  }
    free(v7);
LABEL_24:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

  if (v3) {
    free(v3);
  }
}

  if (v10) {
    free(v10);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
LABEL_5:

  return v5 != 0LL;
}

    free(v7);
    goto LABEL_23;
  }

  uint64_t v3 = (id *)v1;
  uint64_t v4 = [v3 type];

  if (v4 <= 0x3E7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_endpoint_copy_custom_data";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_endpoint_copy_custom_data";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s non-custom endpoint", buf, 0xCu);
      }
    }

    else if (v21)
    {
      __int16 v10 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v8 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      uint64_t v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_endpoint_copy_custom_data";
          v25 = 2082;
          v26 = v10;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s non-custom endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v10);
        if (!v7) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_endpoint_copy_custom_data";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s non-custom endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v8 = (os_log_s *)(id)gLogObj;
      BOOL v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_endpoint_copy_custom_data";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s non-custom endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v5 = v3[29];
LABEL_24:

  return v5;
}

    if (!v8) {
      goto LABEL_24;
    }
LABEL_23:
    free(v8);
    goto LABEL_24;
  }

  uint64_t v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 <= 0x3E7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_endpoint_get_custom_data_length";
    __int16 v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      __int16 v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_get_custom_data_length";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s non-custom endpoint", buf, 0xCu);
      }
    }

    else if (v22)
    {
      uint64_t v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      uint64_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (v11)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_endpoint_get_custom_data_length";
          v26 = 2082;
          v27 = v11;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s non-custom endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v11);
        if (!v8) {
          goto LABEL_24;
        }
        goto LABEL_23;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_get_custom_data_length";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s non-custom endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      char v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_get_custom_data_length";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s non-custom endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_21;
  }

  uint64_t v5 = (dispatch_data_s *)v3[29];
  if (!v5)
  {
LABEL_24:
    size = 0LL;
    goto LABEL_25;
  }

  size = dispatch_data_get_size(v5);
LABEL_25:

  return size;
}

    free(v7);
    goto LABEL_23;
  }

  uint64_t v3 = (const void **)v1;
  uint64_t v4 = [v3 type];

  if (v4 <= 0x3E7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_endpoint_copy_custom_resolver_block";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_endpoint_copy_custom_resolver_block";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s non-custom endpoint", buf, 0xCu);
      }
    }

    else if (v21)
    {
      __int16 v10 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v8 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      uint64_t v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_endpoint_copy_custom_resolver_block";
          v25 = 2082;
          v26 = v10;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s non-custom endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v10);
        if (!v7) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_endpoint_copy_custom_resolver_block";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s non-custom endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v8 = (os_log_s *)(id)gLogObj;
      BOOL v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_endpoint_copy_custom_resolver_block";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s non-custom endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v5 = _Block_copy(v3[30]);
LABEL_24:

  return v5;
}

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_demux_supports_external_data";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  uint64_t v15 = (void *)extra[2];
  if (v15)
  {
    do
    {
      uint64_t v17 = (void *)*v15;
      __int16 v16 = (void *)v15[1];
      if (*v15)
      {
        v17[1] = v16;
        __int16 v16 = (void *)v15[1];
      }

      else
      {
        extra[3] = v16;
      }

      *__int16 v16 = v17;
      void *v15 = 0LL;
      v15[1] = 0LL;
      if (v15 != extra + 4) {
        free(v15);
      }
      uint64_t v15 = v17;
    }

    while (v17);
  }

  __int16 v18 = nw_hash_table_remove_node(*(void *)(a1 + 80), a2);
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v19 = (const char *)(a1 + 90);
    *(_DWORD *)buf = 136446466;
    v38 = "nw_protocol_demux_destroy_entry";
    v39 = 2080;
    v40 = (const char *)(a1 + 90);
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v21 = (os_log_s *)gLogObj;
      uint64_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      v38 = "nw_protocol_demux_destroy_entry";
      v39 = 2080;
      v40 = v19;
      v23 = "%{public}s %s nw_hash_table_remove_node failed";
    }

    else if (v35)
    {
      v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v21 = (os_log_s *)gLogObj;
      uint64_t v22 = type;
      v25 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v24)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446722;
          v38 = "nw_protocol_demux_destroy_entry";
          v39 = 2080;
          v40 = v19;
          v41 = 2082;
          v42 = v24;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s %s nw_hash_table_remove_node failed, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v24);
        goto LABEL_45;
      }

      if (!v25)
      {
LABEL_45:
        if (v20) {
          free(v20);
        }
        return v18;
      }

      *(_DWORD *)buf = 136446466;
      v38 = "nw_protocol_demux_destroy_entry";
      v39 = 2080;
      v40 = v19;
      v23 = "%{public}s %s nw_hash_table_remove_node failed, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v21 = (os_log_s *)gLogObj;
      uint64_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      v38 = "nw_protocol_demux_destroy_entry";
      v39 = 2080;
      v40 = v19;
      v23 = "%{public}s %s nw_hash_table_remove_node failed, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0x16u);
    goto LABEL_45;
  }

  return v18;
}

  if (v12) {
    free(v12);
  }
LABEL_5:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v13) {
    free(v13);
  }
LABEL_6:

  return v5;
}

  if (v6) {
    free(v6);
  }
  return a2 != 0;
}

    if (v9) {
      free(v9);
    }
    *(_DWORD *)(a1 + 24) = 0;
LABEL_25:
    buffer = (void *)nw_frame_get_buffer((uint64_t)a2, 0LL);
    if (buffer) {
      free(buffer);
    }
    nw_frame_reset((uint64_t)a2, 0LL, 0, 0LL, 0LL);
    os_release(a2);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v29 = "frame_cache_remove_from_cache";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v20, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v29 = "frame_cache_remove_from_cache";
      v23 = "%{public}s called with null frame_cache";
      goto LABEL_42;
    }

    if (!v26)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v29 = "frame_cache_remove_from_cache";
      v23 = "%{public}s called with null frame_cache, backtrace limit exceeded";
      goto LABEL_42;
    }

    v24 = (char *)__nw_create_backtrace_string();
    uint32_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    v25 = os_log_type_enabled(v21, type);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v29 = "frame_cache_remove_from_cache";
        unint64_t v30 = 2082;
        v31 = v24;
        _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s called with null frame_cache, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v24);
      goto LABEL_43;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v29 = "frame_cache_remove_from_cache";
      v23 = "%{public}s called with null frame_cache, no backtrace";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
    }
  }

  if (v5) {
    free(v5);
  }
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_masque_listener_compare_metadata";
    uint64_t v7 = "%{public}s called with null handle1";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_masque_supports_external_data";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_protocol_masque_waiting_for_output";
    uint64_t v7 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_masque_compare_metadata";
    uint64_t v7 = "%{public}s called with null handle1";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

    nw_protocol_ohttp_destroy(handle);
    return 1LL;
  }

  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    a2->output_handler_context = 0LL;
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
    nw_protocol_ohttp_context_destroy_node((uint64_t)handle, (uint64_t)output_handler_context);
    if (!a3) {
      return 1LL;
    }
    if (a1->default_input_handler) {
      return 1LL;
    }
    __int16 v8 = handle[37];
    if (v8)
    {
      if (*(_DWORD *)(v8 + 40)) {
        return 1LL;
      }
    }

    goto LABEL_22;
  }

  return 0LL;
}

    free(v8);
    goto LABEL_23;
  }

  uint64_t v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if (mode != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
    __int16 v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      __int16 v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
      }
    }

    else if (v22)
    {
      uint64_t v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      uint64_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (v11)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          v26 = 2082;
          v27 = v11;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v11);
        if (!v8) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s Endpoint handler is not a resolver, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      char v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v5 = (id *)nw_endpoint_handler_copy_resolver(v3);
  uint64_t v6 = v5[13];

LABEL_24:
  return v6;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_5:

  return v5;
}

        goto LABEL_23;
      }

      if (!v29)
      {
        __nwlog_obj();
        __int16 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v32 = "nw_endpoint_handler_used_prefer_fallback";
          _os_log_impl( &dword_181A5C000,  v8,  v27,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      v23 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v32 = "nw_endpoint_handler_used_prefer_fallback";
          _os_log_impl(&dword_181A5C000, v8, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_22;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v32 = "nw_endpoint_handler_used_prefer_fallback";
        v33 = 2082;
        __int16 v34 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v22,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    free(v13);
    goto LABEL_23;
  }

  v43.receiver = self;
  v43.super_class = (Class)&OBJC_CLASS___NWEndpoint;
  uint64_t v5 = -[NWEndpoint init](&v43, sel_init);
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = (void *)objc_opt_class();
    __int16 v8 = [v7 supportsResolverCallback];
    os_log_type_t v9 = [v7 endpointType];
    __int16 v10 = (void *)[v4 _createDispatchData];
    if (v8)
    {
      v42[0] = MEMORY[0x1895F87A8];
      v42[1] = 3221225472LL;
      v42[2] = __34__NWEndpoint_initWithEncodedData___block_invoke;
      v42[3] = &__block_descriptor_40_e100_v32__0__NSObject_OS_nw_endpoint__8__NSObject_OS_dispatch_queue__16___v____NSObject_OS_nw_array__B_24lu32l8;
      v42[4] = v7;
      uint64_t v11 = v42;
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    custom = nw_endpoint_create_custom(v9, v10, v11);

    if (custom)
    {
      -[NWEndpoint setInternalEndpoint:](v6, "setInternalEndpoint:", custom);
      __int16 v18 = v6;
LABEL_45:

      goto LABEL_46;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v47 = "-[NWEndpoint initWithEncodedData:]";
    uint64_t v20 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault((const char *)v20, &type, &v44))
    {
LABEL_42:
      if (v20) {
        free(v20);
      }
      __int16 v18 = 0LL;
      goto LABEL_45;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v21 = (os_log_s *)(id)gLogObj;
      uint64_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "-[NWEndpoint initWithEncodedData:]";
        v23 = "%{public}s nw_endpoint_create_custom failed";
LABEL_39:
        __int16 v32 = v21;
        v33 = v22;
LABEL_40:
        _os_log_impl(&dword_181A5C000, v32, v33, v23, buf, 0xCu);
      }
    }

    else
    {
      if (v44)
      {
        v27 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint32_t v21 = (os_log_s *)(id)gLogObj;
        int v28 = type;
        unint64_t v29 = os_log_type_enabled(v21, type);
        if (v27)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v47 = "-[NWEndpoint initWithEncodedData:]";
            v48 = 2082;
            v49 = v27;
            _os_log_impl( &dword_181A5C000,  v21,  v28,  "%{public}s nw_endpoint_create_custom failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v27);
          goto LABEL_42;
        }

        if (!v29) {
          goto LABEL_41;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "-[NWEndpoint initWithEncodedData:]";
        v23 = "%{public}s nw_endpoint_create_custom failed, no backtrace";
        __int16 v32 = v21;
        v33 = v28;
        goto LABEL_40;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v21 = (os_log_s *)(id)gLogObj;
      uint64_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "-[NWEndpoint initWithEncodedData:]";
        v23 = "%{public}s nw_endpoint_create_custom failed, backtrace limit exceeded";
        goto LABEL_39;
      }
    }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "operator()";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_http_encoding_remove_input_handler";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_webtransport_session_get_parameters";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_webtransport_stream_get_parameters";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  char v14 = 0LL;
  if ((has & 0x40) != 0)
  {
LABEL_8:
    uint64_t v15 = 2654435761LL * self->_fastOpen;
    if ((*(_WORD *)&self->_has & 0x800) != 0) {
      goto LABEL_9;
    }
    goto LABEL_24;
  }

  v23.receiver = self;
  v23.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_socks5_server;
  -[NWConcrete_nw_socks5_server dealloc](&v23, sel_dealloc, v21, v22);
}
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http2_transport_get_parameters";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  if (v9) {
    free(v9);
  }
LABEL_5:
}

LABEL_32:
  return a3;
}

    free(v7);
    goto LABEL_23;
  }

  string = xpc_dictionary_get_string(v1, string_ptr);
LABEL_24:

  return string;
}

  if (v12) {
    free(v12);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_5:

  return v5;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_24;
  }

  if (!v1[3])
  {
LABEL_24:
    uint64_t v6 = 0LL;
    goto LABEL_25;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  uint64_t v20 = 0;
  if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72514);
  }
  uint64_t v3 = (id)nw_protocol_copy_http_messaging_definition_definition;
  identifier = nw_protocol_definition_get_identifier(v3);
  uint64_t v5 = (void *)v2[3];
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = __nw_proxy_config_stack_requires_http_protocols_block_invoke;
  applier[3] = &unk_189BC5538;
  applier[4] = buf;
  applier[5] = identifier;
  xpc_array_apply(v5, applier);
  uint64_t v6 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

  _Block_object_dispose(buf, 8);
LABEL_25:

  return v6;
}

  uint64_t v20 = v11 + v13 + 5;
LABEL_38:
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v20;
  if (*(id *)(a1 + 40) != v5) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = nw_proxy_config_serialize_one_stack( v5,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL)
  }
                                                                              + 24LL),
                                                                    *(void *)(a1 + 64));
  unint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) != 0LL;
LABEL_41:

  return v19;
}

    v13 += input_frames;
  }

  while (input_frames);
  if (gLogDatapath)
  {
    v197 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v197, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v197, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v71 = MEMORY[0x1895F87A8];
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_39716;
  *(void *)&buf[24] = &__block_descriptor_tmp_55_39717;
  *(void *)&buf[32] = v257;
  buf[40] = 0;
  v72 = *(_DWORD **)v257;
  __int16 v10 = (unsigned __int16 *)(v9 + 872);
  do
  {
    if (!v72) {
      break;
    }
    v73 = (_DWORD *)*((void *)v72 + 4);
    v74 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v72 = v73;
  }

  while ((v74 & 1) != 0);
  v75 = (unsigned __int16)*v256;
  v76 = v75 | (*(unsigned __int8 *)(v9 + 874) << 16);
  if ((v75 & 0x6000) == 0x2000 && !*(void *)(v9 + 616))
  {
    *(_BYTE *)(v9 + 874) = BYTE2(v76);
    *v256 = v76 | 0x4000;
    if (*(void *)(v9 + 488))
    {
      if (*(_DWORD *)(v9 + 868) && llhttp_message_needs_eof(v9 + 200))
      {
        if ((v76 & 4) == 0)
        {
          v106 = 5;
          if ((*(_BYTE *)(v9 + 158) & 1) != 0) {
            goto LABEL_117;
          }
          goto LABEL_191;
        }

    free(backtrace_string);
    goto LABEL_32;
  }

  __int16 v8 = (os_log_s *)__nwlog_obj();
  os_log_type_t v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "nw_http1_on_header_field";
    __int16 v10 = "%{public}s called with null parser";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_http1_on_header_field_complete";
    uint64_t v6 = "%{public}s called with null parser";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  if (v8) {
    free(v8);
  }
  return 0xFFFFFFFFLL;
}

  if (v14) {
    free(v14);
  }
  return 0LL;
}

  unint64_t v19 = *(void **)(v8 + 200);
  if (v19)
  {
    uint64_t v20 = nw_endpoint_is_equal(v19, *(void **)(a1 + 32), 0LL);
    if (v20) {
      __int16 v16 = 3;
    }
    is_equal |= v20;
  }

  uint32_t v21 = *(void **)(v8 + 208);
  if (v21)
  {
    uint64_t v22 = nw_endpoint_is_equal(v21, *(void **)(a1 + 32), 0LL);
    if (v22) {
      __int16 v16 = 4;
    }
    is_equal |= v22;
  }

  v23 = *(void **)(v8 + 216);
  if (v23)
  {
    v24 = nw_endpoint_is_equal(v23, *(void **)(a1 + 32), 0LL);
    if (v24) {
      __int16 v16 = 5;
    }
    is_equal |= v24;
  }

  v25 = *(void **)(v8 + 224);
  if (v25)
  {
    v26 = nw_endpoint_is_equal(v25, *(void **)(a1 + 32), 0LL);
    if (v26) {
      __int16 v16 = 6;
    }
    is_equal |= v26;
  }

  v27 = *(void **)(v8 + 232);
  if (v27)
  {
    int v28 = nw_endpoint_is_equal(v27, *(void **)(a1 + 32), 0LL);
    if (v28) {
      __int16 v16 = 7;
    }
    if (((v28 | is_equal) & 1) != 0) {
      goto LABEL_42;
    }
  }

  else if ((is_equal & 1) != 0)
  {
LABEL_42:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v29 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v30 = *(void *)(a1 + 32);
      v42 = 136446466;
      v43 = "nw_replicate_metadata_remove_endpoint_on_queue_block_invoke";
      v44 = 2112;
      v45 = v30;
      _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEFAULT,  "%{public}s Removing endpoint %@ for replication",  (uint8_t *)&v42,  0x16u);
    }

    v31 = v16;
    __int16 v32 = v8 + 8LL * v16;
    unint64_t v35 = *(void *)(v32 + 112);
    __int16 v34 = (void *)(v32 + 112);
    v33 = v35;
    if (v35)
    {
      (*(void (**)(void))(*(void *)(v33 + 24) + 8LL))();
      *__int16 v34 = 0LL;
    }

    uint64_t v36 = v8 + 8 * v31;
    v39 = *(void **)(v36 + 176);
    v38 = (void *)(v36 + 176);
    v37 = v39;
    if (v39)
    {
      os_release(v37);
      *v38 = 0LL;
    }

    goto LABEL_4;
  }

  if ((v10 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v40 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v41 = *(void *)(a1 + 32);
      v42 = 136446466;
      v43 = "nw_replicate_metadata_remove_endpoint_on_queue_block_invoke";
      v44 = 2112;
      v45 = v41;
      _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_ERROR,  "%{public}s Will not remove endpoint %@ for replication, not found",  (uint8_t *)&v42,  0x16u);
    }
  }

    free(backtrace_string);
    goto LABEL_33;
  }

  if (!port)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_endpoint_create_host";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_endpoint_create_host";
        __int16 v8 = "%{public}s called with null port_string";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v14)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_endpoint_create_host";
        __int16 v8 = "%{public}s called with null port_string, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v7 = type;
    BOOL v13 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_endpoint_create_host";
        __int16 v8 = "%{public}s called with null port_string, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_endpoint_create_host";
      __int16 v18 = 2082;
      unint64_t v19 = backtrace_string;
      uint64_t v12 = "%{public}s called with null port_string, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  *(_WORD *)buf = 0;
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "operator()";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_33;
  }

  if ((unint64_t)[v4 length] > 0x1000)
  {
    __nwlog_obj();
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint32_t v21 = "-[NWNetworkAgentRegistration addToken:]";
    __int16 v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v21 = "-[NWNetworkAgentRegistration addToken:]";
        uint64_t v11 = "%{public}s called with null (token.length <= NETAGENT_MAX_DATA_SIZE)";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v18)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v21 = "-[NWNetworkAgentRegistration addToken:]";
        uint64_t v11 = "%{public}s called with null (token.length <= NETAGENT_MAX_DATA_SIZE), backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v10 = type;
    __int16 v16 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v21 = "-[NWNetworkAgentRegistration addToken:]";
        uint64_t v11 = "%{public}s called with null (token.length <= NETAGENT_MAX_DATA_SIZE), no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      uint32_t v21 = "-[NWNetworkAgentRegistration addToken:]";
      uint64_t v22 = 2082;
      v23 = backtrace_string;
      uint64_t v15 = "%{public}s called with null (token.length <= NETAGENT_MAX_DATA_SIZE), dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  if (!-[NWNetworkAgentRegistration isRegisteredInternal](self, "isRegisteredInternal"))
  {
LABEL_35:
    uint64_t v6 = 0;
    goto LABEL_36;
  }

  uint64_t v6 = nw_network_agent_ctl_setsockopt_inner( -[NWNetworkAgentRegistration registrationSocket](self, "registrationSocket"),  21,  (const unsigned __int8 *)[v5 bytes],  objc_msgSend(v5, "length"),  0,  0) == 0;
LABEL_36:

  return v6;
}
  }
  }

  delegateWrapper = v26->_delegateWrapper;
  v26->_delegateWrapper = v24;

  v41 = [MEMORY[0x1896078B8] weakObjectsHashTable];
  weakUnresumedTasks = v26->_weakUnresumedTasks;
  v26->_weakUnresumedTasks = (NSHashTable *)v41;

  v43 = (NSMutableSet *)objc_alloc_init(MEMORY[0x189603FE0]);
  runningTasks = v26->_runningTasks;
  v26->_runningTasks = v43;

  v45 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
  trustExceptions = v26->_trustExceptions;
  v26->_trustExceptions = v45;

  __int16 v8 = v51;
  __int16 v10 = v52;
  os_log_type_t v9 = v53;
  if ([v51 _disableAPWakeOnIdleConnections])
  {
    v60.receiver = 0LL;
    LODWORD(v59.receiver) = 0;
    v47 = IORegisterForSystemPower( v26,  (IONotificationPortRef *)&v60,  (IOServiceInterestCallback)_systemPowerNotificationsCallback,  (io_object_t *)&v59);
    v26->_rootPort = v47;
    if (v47)
    {
      receiver = (IONotificationPort *)v60.receiver;
      v26->_notifyPortRef = (IONotificationPort *)v60.receiver;
      v26->_notifierObject = v59.receiver;
      IONotificationPortSetDispatchQueue(receiver, (dispatch_queue_t)v12->_queue);
    }

    else
    {
      if (__nwlog_url_log::onceToken != -1) {
        dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
      }
      v49 = (os_log_s *)(id)gurlLogObj;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_181A5C000, v49, OS_LOG_TYPE_ERROR, "Failed to register power notifications", buf, 2u);
      }
    }

    objc_storeStrong(&v26->_retainedSelf, v12);
  }

    goto LABEL_23;
  }

  if (!v51)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v8 = (os_log_s *)(id)gLogObj;
    BOOL v13 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v55 = "nw_utilities_public_key_info_for_sec_identity";
      _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s SecIdentityCopyPrivateKey failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_22;
  }

  __int16 v10 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v8 = (os_log_s *)(id)gLogObj;
  uint64_t v11 = type;
  uint64_t v12 = os_log_type_enabled(v8, type);
  if (!v10)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      v55 = "nw_utilities_public_key_info_for_sec_identity";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s SecIdentityCopyPrivateKey failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_22;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v55 = "nw_utilities_public_key_info_for_sec_identity";
    v56 = 2082;
    v57 = v10;
    _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s SecIdentityCopyPrivateKey failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v7) {
LABEL_24:
  }
    free(v7);
LABEL_25:
  if (!privateKeyRef)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_utilities_public_key_info_for_sec_identity";
    unint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null privateKey", buf, 0xCu);
      }

      goto LABEL_111;
    }

    if (!v51)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl( &dword_181A5C000,  v25,  v48,  "%{public}s called with null privateKey, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_111;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v39 = type;
    v40 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_181A5C000, v25, v39, "%{public}s called with null privateKey, no backtrace", buf, 0xCu);
      }

      goto LABEL_111;
    }

    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      v55 = "nw_utilities_public_key_info_for_sec_identity";
      v56 = 2082;
      v57 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v25,  v39,  "%{public}s called with null privateKey, dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_23:
    if (v5) {
      free(v5);
    }
    return 0LL;
  }

  dispatch_time_t v2 = *((_DWORD *)a1 + 5);
  if (v2 < 1) {
    return 0LL;
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
      __int16 v18 = 1024;
      LODWORD(v19) = v2;
      _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_DEBUG, "%{public}s Looked up Audit Token -> PID (%d)", buf, 0x12u);
    }
  }

  return nw_utilities_copy_bundle_id_for_pid(v2);
}

  enumerator[0] = MEMORY[0x1895F87A8];
  enumerator[1] = 3221225472LL;
  enumerator[2] = ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke;
  enumerator[3] = &unk_189BBEC68;
  enumerator[4] = &v56;
  if (nw_ws_response_enumerate_additional_headers((nw_ws_response_t)v16, enumerator))
  {
LABEL_30:
    async_block[0] = MEMORY[0x1895F87A8];
    async_block[1] = 3221225472LL;
    async_block[2] = ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke_68;
    async_block[3] = &unk_189BBEC90;
    v52 = a1;
    v49 = v7;
    v51 = &v56;
    v50 = v5;
    nw_framer_async(v50, async_block);

    goto LABEL_87;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v19 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v61 = "nw_ws_write_server_response";
    v62 = 2082;
    v63 = (char *)(a1 + 227);
    _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s failed to set all additional headers",  buf,  0x16u);
  }

  uint64_t v20 = (const void *)v57[3];
  if (v20)
  {
    CFRelease(v20);
    v57[3] = 0LL;
  }

  nw_framer_mark_failed_with_error(v5, 14);
LABEL_87:
  _Block_object_dispose(&v56, 8);
}
  }

  if (v5) {
    free(v5);
  }
  dispatch_time_t v2 = 0;
LABEL_5:

  return v2;
}

    if (v8)
    {
      uint64_t v15 = objc_alloc(&OBJC_CLASS___NWURLError);
      __int16 v16 = v8[33];
      uint64_t v17 = v8;
      if (v15)
      {
        __int16 v18 = *MEMORY[0x189607740];
        v21.receiver = v15;
        v21.super_class = (Class)&OBJC_CLASS___NWURLError;
        unint64_t v19 = (NWURLError *)objc_msgSendSuper2(&v21, sel_initWithDomain_code_userInfo_, v18, -999, 0);
        uint64_t v15 = v19;
        if (v19) {
          -[NWURLError fillErrorForLoader:andTask:](v19, "fillErrorForLoader:andTask:", v16, v17);
        }
      }
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    [v8 completeTaskWithError:v15];

    goto LABEL_28;
  }

  if (*(void *)(v5 + 288) != 2LL)
  {
    uint64_t v6 = *(double *)(v5 + 328);
    if (v6 > 0.0)
    {
      uint64_t v7 = *(void *)(v5 + 336);
      if (v7)
      {
        uint64_t v4 = (const char *)dispatch_time(0x8000000000000000LL, (uint64_t)(v6 * 1000000000.0));
        if (*(void *)v7)
        {
          dispatch_source_set_timer(*(dispatch_source_t *)v7, (dispatch_time_t)v4, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
LABEL_7:
          uint64_t v3 = newValue;
          goto LABEL_8;
        }

        *(void *)(v7 + 32) = v4;
        *(void *)(v7 + 40) = -1LL;
        uint64_t v3 = newValue;
        if (*(_BYTE *)(v7 + 48) && *(_BYTE *)(v7 + 49))
        {
          nw_queue_source_run_timer(v7, (uint64_t)v4);
          goto LABEL_7;
        }
      }
    }

  return v9;
}

    if (!v3) {
      return;
    }
    goto LABEL_23;
  }

  if (a3 != (void *)16435934)
  {
    if (a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      __int16 v18 = "__nw_frame_empty_finalizer";
      uint64_t v3 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint64_t v15 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v4 = (os_log_s *)gLogObj;
        uint64_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "__nw_frame_empty_finalizer";
        uint64_t v6 = "%{public}s trying to finalize non-split frame";
        goto LABEL_21;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v4 = (os_log_s *)gLogObj;
        uint64_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "__nw_frame_empty_finalizer";
        uint64_t v6 = "%{public}s trying to finalize non-split frame, backtrace limit exceeded";
        goto LABEL_21;
      }

      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      uint64_t v5 = type;
      os_log_type_t v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v8)
      {
        if (!v9) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "__nw_frame_empty_finalizer";
        uint64_t v6 = "%{public}s trying to finalize non-split frame, no backtrace";
        goto LABEL_21;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v18 = "__nw_frame_empty_finalizer";
        unint64_t v19 = 2082;
        uint64_t v20 = (nw_frame *)v8;
        __int16 v10 = "%{public}s trying to finalize non-split frame, dumping backtrace:%{public}s";
LABEL_14:
        _os_log_impl(&dword_181A5C000, v4, v5, v10, buf, 0x16u);
        goto LABEL_15;
      }

      goto LABEL_15;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "__nw_frame_empty_finalizer";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v15 = 0;
    if (__nwlog_fault(v3, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v18 = "__nw_frame_empty_finalizer";
          uint64_t v6 = "%{public}s called with null context";
          goto LABEL_21;
        }
      }

      else if (v15)
      {
        __int16 v8 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        char v14 = os_log_type_enabled(v4, type);
        if (v8)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v18 = "__nw_frame_empty_finalizer";
            unint64_t v19 = 2082;
            uint64_t v20 = (nw_frame *)v8;
            __int16 v10 = "%{public}s called with null context, dumping backtrace:%{public}s";
            goto LABEL_14;
          }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "__nw_frame_get_tso_segment_size";
    uint64_t v6 = "%{public}s called with null frame";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    goto LABEL_23;
  }

  if (!v37)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    __int16 v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      uint64_t v17 = v5->endpoint;
      *(_DWORD *)buf = 136446722;
      v40 = "nw_service_connector_remove_active_outgoing_request";
      v41 = 2114;
      v42 = v17;
      v43 = 2082;
      service = v5->service;
      _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_22;
  }

  uint64_t v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v9 = (os_log_s *)(id)gLogObj;
  BOOL v13 = type;
  char v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      __int16 v18 = v5->endpoint;
      *(_DWORD *)buf = 136446722;
      v40 = "nw_service_connector_remove_active_outgoing_request";
      v41 = 2114;
      v42 = v18;
      v43 = 2082;
      service = v5->service;
      _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_22;
  }

  if (v14)
  {
    uint64_t v15 = v5->endpoint;
    *(_DWORD *)buf = 136446978;
    v40 = "nw_service_connector_remove_active_outgoing_request";
    v41 = 2114;
    v42 = v15;
    v43 = 2082;
    service = v5->service;
    v45 = 2082;
    v46 = v12;
    _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v12);
  if (v8) {
    goto LABEL_24;
  }
LABEL_25:
}

    goto LABEL_23;
  }

  if (!v37)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    __int16 v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      uint64_t v17 = p_isa[1];
      *(_DWORD *)buf = 136446722;
      v40 = "nw_service_connector_remove_active_connection";
      v41 = 2114;
      v42 = v17;
      v43 = 2082;
      v44 = p_isa + 2;
      _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_22;
  }

  uint64_t v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v9 = (os_log_s *)(id)gLogObj;
  BOOL v13 = type;
  char v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      __int16 v18 = p_isa[1];
      *(_DWORD *)buf = 136446722;
      v40 = "nw_service_connector_remove_active_connection";
      v41 = 2114;
      v42 = v18;
      v43 = 2082;
      v44 = p_isa + 2;
      _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_22;
  }

  if (v14)
  {
    uint64_t v15 = p_isa[1];
    *(_DWORD *)buf = 136446978;
    v40 = "nw_service_connector_remove_active_connection";
    v41 = 2114;
    v42 = v15;
    v43 = 2082;
    v44 = p_isa + 2;
    v45 = 2082;
    v46 = v12;
    _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v12);
  if (v8) {
    goto LABEL_24;
  }
LABEL_25:
}

  if (v9) {
    free(v9);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

  if (v9) {
    free(v9);
  }
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

  if (v7) {
    free(v7);
  }
LABEL_5:

  return (nw_protocol_metadata_t)singleton;
}

  if (v5) {
    free(v5);
  }
  dispatch_time_t v2 = 0LL;
LABEL_5:

  return v2;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = nw_ip_ecn_flag_non_ect;
LABEL_5:

  return v5;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = nw_service_class_best_effort;
LABEL_5:

  return v5;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_5:

  return v5;
}

  if (v7) {
    free(v7);
  }
LABEL_5:

  return v3;
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v9) {
    free(v9);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

  unint64_t v19 = *(const __CFData **)(a2 + 128);
  if (v19)
  {
LABEL_23:
    uint64_t v20 = CFDataGetLength(v19) + 2;
    goto LABEL_26;
  }

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

  if (v7) {
    free(v7);
  }
  dispatch_time_t v2 = 0LL;
  uint64_t v4 = 0LL;
LABEL_5:

  return v4;
}

  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0LL;
LABEL_5:
}

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

          uint64_t v5 = 1;
          goto LABEL_26;
        }
      }

  if (v4) {
    free(v4);
  }
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

        input_finished(v4, a1);
        return;
      }

      uint64_t v17 = a1->callbacks;
      if (v17)
      {
        input_finished = (void (*)(nw_protocol *, nw_protocol *))v17->disconnect;
        if (input_finished)
        {
          uint64_t v4 = a1;
          goto LABEL_22;
        }
      }

      __nwlog_obj();
      identifier = a1->identifier;
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446466;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v56 = 2082;
      v57 = identifier;
      v26 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v52 = 0;
      if (__nwlog_fault(v26, &type, &v52))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v27 = (os_log_s *)__nwlog_obj();
          int v28 = type;
          if (!os_log_type_enabled(v27, type)) {
            goto LABEL_101;
          }
          unint64_t v29 = a1->identifier;
          if (!v29) {
            unint64_t v29 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v29;
          unint64_t v30 = "%{public}s protocol %{public}s has invalid disconnect callback";
LABEL_100:
          _os_log_impl(&dword_181A5C000, v27, v28, v30, buf, 0x16u);
          goto LABEL_101;
        }

        if (!v52)
        {
          v27 = (os_log_s *)__nwlog_obj();
          int v28 = type;
          v45 = os_log_type_enabled(v27, type);
          v46 = (nw_protocol_identifier *)"invalid";
          if (!v45) {
            goto LABEL_101;
          }
          if (a1->identifier) {
            v46 = a1->identifier;
          }
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v46;
          unint64_t v30 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
          goto LABEL_100;
        }

        uint64_t v36 = (char *)__nw_create_backtrace_string();
        v27 = (os_log_s *)__nwlog_obj();
        int v28 = type;
        v37 = os_log_type_enabled(v27, type);
        if (!v36)
        {
          v51 = (nw_protocol_identifier *)"invalid";
          if (!v37) {
            goto LABEL_101;
          }
          if (a1->identifier) {
            v51 = a1->identifier;
          }
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v51;
          unint64_t v30 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
          goto LABEL_100;
        }

        if (v37)
        {
          v38 = (nw_protocol_identifier *)"invalid";
          if (a1->identifier) {
            v38 = a1->identifier;
          }
          *(_DWORD *)buf = 136446722;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v38;
          v58 = 2082;
          v59 = v36;
          _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v36);
      }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http3_uni_stream_supports_external_data";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

      if (v9) {
        free(v9);
      }
LABEL_24:
      if (v7) {
        os_release(v7);
      }
      if (!*((void *)handle + 138))
      {
        if (!a2)
        {
          v216 = (void **)(handle + 1112);
          goto LABEL_38;
        }

        callbacks = a2->callbacks;
        if (callbacks)
        {
          get_local_endpoint = (uint64_t (*)(nw_protocol *))callbacks->get_local_endpoint;
          if (get_local_endpoint)
          {
            v27 = (void *)get_local_endpoint(a2);
            if (v27) {
              *((void *)handle + 138) = os_retain(v27);
            }
          }
        }
      }

      v216 = (void **)(handle + 1112);
      if (a2)
      {
        if (!*((void *)handle + 139))
        {
          int v28 = a2->callbacks;
          if (v28)
          {
            get_path = (uint64_t (*)(nw_protocol *))v28->get_path;
            if (get_path)
            {
              unint64_t v30 = (void *)get_path(a2);
              if (v30) {
                *((void *)handle + 139) = os_retain(v30);
              }
            }
          }
        }
      }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http3_get_local_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http3_get_remote_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http3_get_path";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  if (v6) {
    free(v6);
  }
LABEL_5:

  return v1 != 0LL;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 22LL;
LABEL_5:

  return v5;
}

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = v16;
  if (os_log_type_enabled(v6, v16))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "nw_protocol_http_early_data_remove_input_handler";
    __int16 v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v3 = (os_log_s *)__nwlog_obj();
  uint64_t v4 = type;
  if (os_log_type_enabled(v3, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_socket_get_output_local";
    uint64_t v5 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v3 = (os_log_s *)__nwlog_obj();
  uint64_t v4 = type;
  if (os_log_type_enabled(v3, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_socket_get_output_interface";
    uint64_t v5 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_socket_waiting_for_output";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  if (v6) {
    free(v6);
  }
LABEL_5:
}

    if (v9) {
      free(v9);
    }
    goto LABEL_3;
  }

  uint64_t v5 = v3 + 2;
  if (!uuid_is_null((const unsigned __int8 *)v3 + 32))
  {
    *a2 = *v5;
    uint64_t v6 = 1LL;
    goto LABEL_5;
  }

    free(backtrace_string);
    if (!v14) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  objc_storeStrong((id *)v5 + 1, a1);
  *((_BYTE *)v6 + 107) |= 2u;
  uint64_t v7 = (id *)v4;
  __int16 v8 = v7[19];

  if (v8)
  {
    os_log_type_t v9 = (id *)v8;
    __int16 v10 = v9[3];

    if (v10 && nw_protocol_options_is_custom_ip(v10)) {
      *((_BYTE *)v6 + 106) = nw_custom_ip_options_get_protocol(v10);
    }
  }

  if ((nw_path_evaluator_evaluate(v6, a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v30 = "nw_path_create_evaluator_for_listener";
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    uint64_t v6 = 0LL;
  }

  uint64_t v12 = v6;

LABEL_33:
  return v12;
}

  if (v11) {
    free(v11);
  }
  __int16 v8 = 0LL;
LABEL_5:

  return v8;
}

  if (v5) {
    free(v5);
  }
LABEL_5:
}

  if (v8) {
    free(v8);
  }
  uint64_t v4 = 0LL;
LABEL_5:

  return v4;
}

  if (v9) {
    free(v9);
  }
  uint64_t v6 = nw_path_unsatisfied_reason_not_available;
LABEL_5:

  return v6;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_3;
  }

  if ((v3[148] & 4) != 0)
  {
    uint64_t v5 = uuid_compare(v3 + 48, a2) == 0;
    goto LABEL_5;
  }

    free(v12);
    goto LABEL_23;
  }

    if (v9) {
      free(v9);
    }
    goto LABEL_3;
  }

  uint64_t v5 = v3 + 152;
  if (!uuid_is_null((const unsigned __int8 *)v3 + 152))
  {
    *a2 = *v5;
    uint64_t v6 = 1LL;
    goto LABEL_5;
  }

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_3;
  }

  uint64_t v5 = v3 + 9;
  if (!uuid_is_null((const unsigned __int8 *)v3 + 144))
  {
    *a2 = *v5;
    uint64_t v6 = 1LL;
    goto LABEL_5;
  }

    if (v9) {
      free(v9);
    }
    goto LABEL_3;
  }

  uint64_t v5 = v3 + 84;
  if (!uuid_is_null((const unsigned __int8 *)v3 + 84))
  {
    *a2 = *v5;
    uint64_t v6 = 1LL;
    goto LABEL_5;
  }

  if (v8) {
    free(v8);
  }
  is_equal_unsafe = 0LL;
LABEL_5:

  return is_equal_unsafe;
}

  if (v12) {
    free(v12);
  }
  os_log_type_t v9 = 0LL;
LABEL_5:

  return v9;
}

  [MEMORY[0x189607968] numberWithUnsignedInt:self->_delegateIndex];
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setObject:v15 forKey:@"delegateIndex"];

  __int16 v10 = (char)self->_has;
  if ((v10 & 8) != 0) {
    goto LABEL_23;
  }
LABEL_17:
  if ((v10 & 0x40) != 0)
  {
LABEL_18:
    [MEMORY[0x189607968] numberWithBool:self->_expensive];
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v11 forKey:@"expensive"];
  }

  return v3;
}

  if (v6) {
    free(v6);
  }
  idle_timeout = 0LL;
LABEL_5:

  return idle_timeout;
}

  if (v6) {
    free(v6);
  }
  connection_pool_width = 0LL;
LABEL_5:

  return connection_pool_width;
}

  if (v6) {
    free(v6);
  }
  capsule_handling_disabled = 0LL;
LABEL_5:

  return capsule_handling_disabled;
}

  if (v6) {
    free(v6);
  }
  idle_timeout = 0LL;
LABEL_5:

  return idle_timeout;
}

  if (v6) {
    free(v6);
  }
  stream_receive_window_size = 0LL;
LABEL_5:

  return stream_receive_window_size;
}

  if (v6) {
    free(v6);
  }
  connection_receive_window_size = 0LL;
LABEL_5:

  return connection_receive_window_size;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

  if (v6) {
    free(v6);
  }
  local_max_webtransport_sessions = 0LL;
LABEL_5:

  return local_max_webtransport_sessions;
}

  if (v6) {
    free(v6);
  }
  idle_timeout = 0LL;
LABEL_5:

  return idle_timeout;
}

  if (v6) {
    free(v6);
  }
  keepalive_mode = 0LL;
LABEL_5:

  return keepalive_mode;
}

  if (v6) {
    free(v6);
  }
  _0rtt_enabled = 0LL;
LABEL_5:

  return _0rtt_enabled;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

  if (v6) {
    free(v6);
  }
  sessions_to_request = 0LL;
LABEL_5:

  return sessions_to_request;
}

  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0LL;
LABEL_5:

  return v3;
}

  if (v6) {
    free(v6);
  }
  stream_mode = 0LL;
LABEL_5:

  return stream_mode;
}

  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0LL;
LABEL_5:

  return v4;
}

  if (v7) {
    free(v7);
  }
}

  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0LL;
LABEL_5:

  return v4;
}

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  uint64_t v11 = out_token;
  if (out_token == -1) {
    return 0LL;
  }
  if (tcp_fallback_watcher_fallback_inuse(out_token)) {
    dispatch_async(queue, a3);
  }
  return v11;
}

      if (v10) {
        free(v10);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)gLogObj;
    uint64_t v12 = type;
    uint64_t v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_string_create_with_c_string_no_copy";
        BOOL v13 = "%{public}s called with null self, no backtrace";
        goto LABEL_21;
      }

      goto LABEL_22;
    }

    if (!v15)
    {
LABEL_16:
      free(backtrace_string);
      goto LABEL_22;
    }

    *(_DWORD *)buf = 136446466;
    v23 = "nw_string_create_with_c_string_no_copy";
    v24 = 2082;
    v25 = backtrace_string;
    __int16 v16 = "%{public}s called with null self, dumping backtrace:%{public}s";
LABEL_15:
    _os_log_impl(&dword_181A5C000, v11, v12, v16, buf, 0x16u);
    goto LABEL_16;
  }

  __break(1u);
  return result;
}

      free(backtrace_string);
      goto LABEL_32;
    }

    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_string_is_equal_to_string";
    uint64_t v7 = "%{public}s called with null string1";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
LABEL_32:
    if (v4) {
      free(v4);
    }
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_string_is_equal_to_string";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      uint64_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_string_is_equal_to_string";
      uint64_t v7 = "%{public}s called with null string2";
      goto LABEL_31;
    }

    if (!v12)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      uint64_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_string_is_equal_to_string";
      uint64_t v7 = "%{public}s called with null string2, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    uint64_t v11 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v15 = "nw_string_is_equal_to_string";
        __int16 v16 = 2082;
        uint64_t v17 = backtrace_string;
        __int16 v10 = "%{public}s called with null string2, dumping backtrace:%{public}s";
        goto LABEL_21;
      }

      goto LABEL_22;
    }

    if (!v11) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_string_is_equal_to_string";
    uint64_t v7 = "%{public}s called with null string2, no backtrace";
    goto LABEL_31;
  }

  dispatch_time_t v2 = *(void *)(a1 + 32);
  if (v2 == *(void *)(a2 + 32)) {
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2) == 0;
  }
  return 0LL;
}

      free(backtrace_string);
      goto LABEL_32;
    }

    uint64_t v7 = (os_log_s *)__nwlog_obj();
    __int16 v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_string_is_equal_to_c_string";
    os_log_type_t v9 = "%{public}s called with null string1";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
LABEL_32:
    if (v6) {
      free(v6);
    }
    return 0LL;
  }

  if (!__s)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_string_is_equal_to_c_string";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      __int16 v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_string_is_equal_to_c_string";
      os_log_type_t v9 = "%{public}s called with null string2";
      goto LABEL_31;
    }

    if (!v14)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      __int16 v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_string_is_equal_to_c_string";
      os_log_type_t v9 = "%{public}s called with null string2, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    __int16 v8 = type;
    BOOL v13 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v17 = "nw_string_is_equal_to_c_string";
        __int16 v18 = 2082;
        unint64_t v19 = backtrace_string;
        uint64_t v12 = "%{public}s called with null string2, dumping backtrace:%{public}s";
        goto LABEL_21;
      }

      goto LABEL_22;
    }

    if (!v13) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_string_is_equal_to_c_string";
    os_log_type_t v9 = "%{public}s called with null string2, no backtrace";
    goto LABEL_31;
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 == strlen(__s)) {
    return memcmp(*(const void **)(a1 + 24), __s, v4) == 0;
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_parallel_array_contains";
    uint64_t v7 = "%{public}s called with null parray";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

  return v6;
}

    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v5 = (char *)v7;
    goto LABEL_4;
  }

  *(void *)buf = 0LL;
  endpoint_array_result = nw_path_create_endpoint_array_result(buf, v3, 202);
  nw_agent_assign( *(NWConcrete_nw_agent **)(a1 + 32),  (unsigned __int8 *)endpoint_array_result,  *(size_t *)buf,  (unsigned __int8 *)(*(void *)(a1 + 40) + 8LL),  0);
  if (endpoint_array_result)
  {
    uint64_t v5 = (char *)endpoint_array_result;
LABEL_4:
    free(v5);
  }

    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v5 = (char *)v7;
    goto LABEL_4;
  }

  *(void *)buf = 0LL;
  endpoint_array_result = nw_path_create_endpoint_array_result(buf, v3, 203);
  nw_agent_assign( *(NWConcrete_nw_agent **)(a1 + 32),  (unsigned __int8 *)endpoint_array_result,  *(size_t *)buf,  (unsigned __int8 *)(*(void *)(a1 + 40) + 8LL),  0);
  if (endpoint_array_result)
  {
    uint64_t v5 = (char *)endpoint_array_result;
LABEL_4:
    free(v5);
  }

  v24 = *(dispatch_data_s **)(v2 + 224);
  if (v24)
  {
    v44 = 0LL;
    v45 = &v44;
    v46 = 0x2000000000LL;
    v47 = 0LL;
    v43[0] = 0LL;
    v43[1] = v43;
    v43[2] = 0x2000000000LL;
    v43[3] = (char *)v48 + v7;
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 0x40000000LL;
    applier[2] = __nw_dispatch_data_copyout_block_invoke;
    applier[3] = &unk_189BBF598;
    applier[5] = v43;
    applier[6] = 4096 - v7;
    applier[4] = &v44;
    dispatch_data_apply(v24, applier);
    v25 = v45[3];
    _Block_object_dispose(v43, 8);
    _Block_object_dispose(&v44, 8);
    v7 += v25;
    dispatch_time_t v2 = *(void *)(v1 + 32);
    uint64_t v3 = *(_BYTE *)(v2 + 856);
  }

  v26 = (unsigned __int8 *)(v2 + 720);
  v27 = (_BYTE *)(v2 + 20);
  int v28 = (_BYTE *)(v2 + 52);
  unint64_t v29 = v2 + 84;
  v31 = *(_DWORD *)(v2 + 232);
  unint64_t v30 = *(_DWORD *)(v2 + 236);
  __int16 v32 = (v30 >> 1) & 1;
  v33 = v31 == 1;
  __int16 v34 = v31 == 3;
  unint64_t v35 = (v30 >> 2) & 1;
  uint64_t v36 = (v31 & 0xFFFFFFFE) == 2;
  v37 = (const unsigned __int8 *)v48;
  if (!v7) {
    v37 = 0LL;
  }
  v41 = (v30 & 8) != 0;
  v38 = v30 & 1;
  if ((v3 & 1) != 0) {
    v39 = 3;
  }
  else {
    v39 = 1;
  }
  result = nw_network_agent_ctl_setsockopt( *(_DWORD *)(v1 + 48),  v39,  v26,  v27,  v28,  v29,  v33,  v34,  v36,  v38,  v32,  v35,  (v3 & 8) != 0,  (v3 & 2) != 0,  (v3 & 0x10) != 0,  (v3 & 0x20) != 0,  (v3 & 0x40) != 0,  (v3 & 4) != 0,  v41,  v37,  v7);
  *(_DWORD *)(*(void *)(*(void *)(v1 + 40) + 8LL) + 24LL) = result;
  if (!*(_DWORD *)(*(void *)(*(void *)(v1 + 40) + 8LL) + 24LL)) {
    *(_BYTE *)(*(void *)(v1 + 32) + 856LL) |= 1u;
  }
  if (*(_DWORD *)(*(void *)(v1 + 32) + 716LL))
  {
    LODWORD(applier[0]) = *(_DWORD *)(*(void *)(v1 + 32) + 716LL);
    result = nw_network_agent_ctl_setsockopt_inner( *(_DWORD *)(v1 + 48),  24,  (const unsigned __int8 *)applier,  4u,  0LL,  0);
    *(_DWORD *)(*(void *)(*(void *)(v1 + 40) + 8LL) + 24LL) = result;
  }

  return result;
}

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http2_get_parameters";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v15 = nghttp2_strerror();
  *(_DWORD *)buf = 136446466;
  unint64_t v35 = "nw_http2_send_settings";
  uint64_t v36 = 2082;
  v37 = v15;
  __int16 v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v32 = 0;
  if (__nwlog_fault(v16, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      __int16 v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      unint64_t v19 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      unint64_t v35 = "nw_http2_send_settings";
      uint64_t v36 = 2082;
      v37 = v19;
      uint64_t v20 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed";
      goto LABEL_37;
    }

    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      __int16 v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      v24 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      unint64_t v35 = "nw_http2_send_settings";
      uint64_t v36 = 2082;
      v37 = v24;
      uint64_t v20 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, backtrace limit exceeded";
      goto LABEL_37;
    }

    uint32_t v21 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)gLogObj;
    __int16 v18 = type;
    uint64_t v22 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v21)
    {
      if (v22)
      {
        v23 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        unint64_t v35 = "nw_http2_send_settings";
        uint64_t v36 = 2082;
        v37 = v23;
        v38 = 2082;
        v39 = v21;
        _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v21);
      goto LABEL_38;
    }

    if (v22)
    {
      v25 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      unint64_t v35 = "nw_http2_send_settings";
      uint64_t v36 = 2082;
      v37 = v25;
      uint64_t v20 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, no backtrace";
LABEL_37:
      _os_log_impl(&dword_181A5C000, v17, v18, v20, buf, 0x16u);
    }
  }

    free(backtrace_string);
    goto LABEL_32;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  __int16 v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
    os_log_type_t v9 = "%{public}s called with null mode";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
  }

    free(v5);
    goto LABEL_23;
  }

  if (*((_DWORD *)v1 + 2) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_browse_descriptor_get_application_service_name";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_application_service_name";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Browse descriptor not of type application service",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_browse_descriptor_get_application_service_name";
          v23 = 2082;
          v24 = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_application_service_name";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_application_service_name";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = (const char *)*((void *)v1 + 9);
LABEL_24:

  return v3;
}

    free(v5);
    goto LABEL_23;
  }

  if (*((_DWORD *)v1 + 2) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_browse_descriptor_get_bundle_id";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_bundle_id";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Browse descriptor not of type application service",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_browse_descriptor_get_bundle_id";
          v23 = 2082;
          v24 = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_bundle_id";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_bundle_id";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = *((void *)v1 + 10);
LABEL_24:

  return v3;
}

    free(v5);
    goto LABEL_23;
  }

  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_browse_descriptor_get_device_types";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_device_types";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Browse descriptor not of type application service",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_browse_descriptor_get_device_types";
          v23 = 2082;
          v24 = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_device_types";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_device_types";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = v1[22];
LABEL_24:

  return v3;
}

    free(v5);
    goto LABEL_23;
  }

  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_browse_descriptor_get_browse_scope";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_browse_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Browse descriptor not of type application service",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_browse_descriptor_get_browse_scope";
          v23 = 2082;
          v24 = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_browse_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_browse_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = v1[23];
LABEL_24:

  return v3;
}

    free(v5);
    goto LABEL_23;
  }

  if (*((_DWORD *)v1 + 2) <= 0x3E7u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_browse_descriptor_copy_custom_data";
    v23 = 1024;
    *(_DWORD *)v24 = 1000;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "nw_browse_descriptor_copy_custom_data";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s Custom browse type values must start at %d", buf, 0x12u);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v22 = "nw_browse_descriptor_copy_custom_data";
          v23 = 1024;
          *(_DWORD *)v24 = 1000;
          v24[2] = 2082;
          *(void *)&v24[3] = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Custom browse type values must start at %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "nw_browse_descriptor_copy_custom_data";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Custom browse type values must start at %d, no backtrace",  buf,  0x12u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "nw_browse_descriptor_copy_custom_data";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Custom browse type values must start at %d, backtrace limit exceeded",  buf,  0x12u);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = v1[7];
LABEL_24:

  return v3;
}

    free(v5);
    goto LABEL_23;
  }

  if (*((_DWORD *)v1 + 2) <= 0x3E7u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_browse_descriptor_copy_custom_browse_block";
    v23 = 1024;
    *(_DWORD *)v24 = 1000;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "nw_browse_descriptor_copy_custom_browse_block";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s Custom browse type values must start at %d", buf, 0x12u);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v22 = "nw_browse_descriptor_copy_custom_browse_block";
          v23 = 1024;
          *(_DWORD *)v24 = 1000;
          v24[2] = 2082;
          *(void *)&v24[3] = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Custom browse type values must start at %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "nw_browse_descriptor_copy_custom_browse_block";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Custom browse type values must start at %d, no backtrace",  buf,  0x12u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "nw_browse_descriptor_copy_custom_browse_block";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Custom browse type values must start at %d, backtrace limit exceeded",  buf,  0x12u);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = _Block_copy(v1[8]);
LABEL_24:

  return v3;
}

    free(v5);
    goto LABEL_23;
  }

  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_browse_descriptor_get_invitation_scope";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_invitation_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Browse descriptor not of type application service",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      __int16 v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      __int16 v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_browse_descriptor_get_invitation_scope";
          v23 = 2082;
          v24 = v8;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v8);
        if (!v5) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_invitation_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_browse_descriptor_get_invitation_scope";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = v1[24];
LABEL_24:

  return v3;
}

LABEL_23:
    if (v6) {
      free(v6);
    }
    return 0LL;
  }

  dispatch_time_t v2 = if_nametoindex(a1);
  if (v2) {
    return nw_interface_create_with_index_and_name(v2, (unsigned __int8 *)a1);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_interface_create_with_name";
    __int16 v16 = 2082;
    uint64_t v17 = a1;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to find interface index for %{public}s",  buf,  0x16u);
  }

  return 0LL;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_3;
  }

  if ((*(_WORD *)((_BYTE *)v1 + 85) & 0x80) != 0)
  {
    uint64_t v4 = *((_DWORD *)v1 + 18);
    *(_DWORD *)address = 528;
    *(_DWORD *)&address[4] = v4;
    *(void *)&address[8] = 0LL;
    uint64_t v3 = nw_endpoint_create_address((const sockaddr *)address);
    goto LABEL_5;
  }

    if (v7) {
      free(v7);
    }
    goto LABEL_3;
  }

  if ((*(_WORD *)((_BYTE *)v1 + 85) & 0x100) != 0)
  {
    uint64_t v4 = *((_DWORD *)v1 + 19);
    *(_DWORD *)address = 528;
    *(_DWORD *)&address[4] = v4;
    *(void *)&address[8] = 0LL;
    uint64_t v3 = nw_endpoint_create_address((const sockaddr *)address);
    goto LABEL_5;
  }

void nw_queue_activate_source(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj(0LL, a2);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_queue_activate_source";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    uint64_t v7 = __nwlog_fault(v6, &type, &v16);
    if (!(_DWORD)v7) {
      goto LABEL_28;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v7, v8);
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v19 = "nw_queue_activate_source";
        uint64_t v11 = "%{public}s called with null source";
LABEL_26:
        _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      }
    }

    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj(backtrace_string, v13);
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v14 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v19 = "nw_queue_activate_source";
            __int16 v20 = 2082;
            uint32_t v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null source, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (!v14) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v19 = "nw_queue_activate_source";
        uint64_t v11 = "%{public}s called with null source, no backtrace";
        goto LABEL_26;
      }

      __nwlog_obj(v7, v8);
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v19 = "nw_queue_activate_source";
        uint64_t v11 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_26;
      }
    }

LABEL_27:
LABEL_28:
    if (v6) {
      free(v6);
    }
    return;
  }

  uint64_t v3 = *(dispatch_object_s **)a1;
  if (v3)
  {
    dispatch_activate(v3);
    return;
  }

  if (*(_BYTE *)(a1 + 48))
  {
    if (!*(_BYTE *)(a1 + 49))
    {
      nw_queue_source_run_timer(a1, a2);
LABEL_10:
      *(_BYTE *)(a1 + 49) = 1;
    }
  }

  else
  {
    uint64_t v4 = *(void **)(a1 + 16);
    if (v4)
    {
      if (!*(_BYTE *)(a1 + 49))
      {
        nw_context_queue_source_block(*(void **)(a1 + 8), v4);
        goto LABEL_10;
      }
    }

    else if (gLogDatapath)
    {
      __nwlog_obj(0LL, 0LL);
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v19 = "nw_queue_activate_source";
        _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not activating source", buf, 0xCu);
      }
    }
  }

      free(backtrace_string);
    }

    goto LABEL_28;
  }

  uint64_t v4 = MaximumSizeForEncoding + 1;
  uint64_t v5 = nw_calloc_type<unsigned char>(MaximumSizeForEncoding + 1);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  __int16 v32 = "nw_utilities_create_c_string_from_cfstring";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v29 = 0;
  if (__nwlog_fault(v7, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_utilities_create_c_string_from_cfstring";
        os_log_type_t v10 = "%{public}s CFStringGetCString failed";
LABEL_34:
        v23 = v8;
        v24 = v9;
LABEL_35:
        _os_log_impl(&dword_181A5C000, v23, v24, v10, buf, 0xCu);
        goto LABEL_36;
      }

      goto LABEL_36;
    }

    if (!v29)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_utilities_create_c_string_from_cfstring";
        os_log_type_t v10 = "%{public}s CFStringGetCString failed, backtrace limit exceeded";
        goto LABEL_34;
      }

  if (v10) {
    free(v10);
  }
  uint64_t v6 = 0LL;
LABEL_10:

  return v6;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_8;
  }

  if (nw_parameters_get_multipath(v1[2])
    && !*((_DWORD *)v2 + 88)
    && *((_DWORD *)v2 + 66) != 4
    && (nw_path_uses_interface_subtype(v2, 5001) & 1) == 0
    && (nw_parameters_multipath_fallback_allowed(v2[2])
     || !nw_parameters_get_required_interface_index(v2[2])))
  {
    uint64_t v3 = 1LL;
    goto LABEL_9;
  }

    if (v12) {
      free(v12);
    }
LABEL_6:
    os_log_type_t v9 = 0LL;
    goto LABEL_10;
  }

  if (nw_path_uses_nexus_internal(v5, 0))
  {
    nexus_agent = nw_path_get_nexus_agent(v6, 0);
    uint64_t v8 = (_OWORD *)nexus_agent;
    if (a3) {
      *a3 = (*(_DWORD *)(nexus_agent + 208) & 2) == 0;
    }
    if (!uuid_is_null((const unsigned __int8 *)nexus_agent))
    {
      *a2 = *v8;
      os_log_type_t v9 = 1LL;
      goto LABEL_10;
    }

    goto LABEL_6;
  }

  os_log_type_t v9 = 0LL;
  if (a3) {
    *a3 = 0;
  }
LABEL_10:

  return v9;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_9;
  }

  if (!nw_path_network_is_satisfied_update_reason(v1, 0LL)) {
    goto LABEL_9;
  }
  effective_mtu = v2->effective_mtu;
  if (!(_DWORD)effective_mtu)
  {
    direct = v2->direct;
    if (direct)
    {
      uint64_t v5 = direct;
      effective_mtu = *((unsigned int *)v5 + 15);

      goto LABEL_10;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v19 = "nw_path_get_mtu";
      _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_ERROR, "%{public}s Unable to determine MTU for path", buf, 0xCu);
    }

LABEL_9:
    effective_mtu = 0LL;
  }

            v73[0] = MEMORY[0x1895F87A8];
            v73[1] = 0x40000000LL;
            v74 = ___ZL34nw_protocol_ipv4_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v75 = &__block_descriptor_tmp_28_86144;
            v76 = a1;
            tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              v23 = (nw_frame *)*((void *)tqh_first + 4);
              v24 = ((uint64_t (*)(void *))v74)(v73);
              tqh_first = v23;
            }

            while ((v24 & 1) != 0);
            return v21;
          }

      goto LABEL_28;
    }

    if (!v36)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (os_log_s *)(id)gLogObj;
      unint64_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        v42 = 1024;
        *(_DWORD *)v43 = v10;
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s necp update cache failed for ecn %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
      }

      goto LABEL_27;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = (os_log_s *)(id)gLogObj;
    uint64_t v17 = type;
    __int16 v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        v42 = 1024;
        *(_DWORD *)v43 = v10;
        _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s necp update cache failed for ecn %{darwin.errno}d, no backtrace",  buf,  0x12u);
      }

      goto LABEL_27;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446722;
      v41 = "nw_path_flow_registration_set_ecn_cache";
      v42 = 1024;
      *(_DWORD *)v43 = v10;
      v43[2] = 2082;
      *(void *)&v43[3] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s necp update cache failed for ecn %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

LABEL_20:
    free(backtrace_string);
    if (!v13) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v41 = "nw_path_flow_registration_set_ecn_cache";
    v42 = 1024;
    *(_DWORD *)v43 = 2;
    _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s necp update cache failed for ecn %{darwin.errno}d",  buf,  0x12u);
  }

LABEL_30:
}

LABEL_28:
    if (v6) {
      free(v6);
    }
    return;
  }

  uint64_t v3 = *(dispatch_object_s **)a1;
  if (v3)
  {
    dispatch_resume(v3);
    return;
  }

  if (*(_BYTE *)(a1 + 48))
  {
    if (!*(_BYTE *)(a1 + 49))
    {
      nw_queue_source_run_timer(a1, a2);
LABEL_10:
      *(_BYTE *)(a1 + 49) = 1;
    }
  }

  else
  {
    uint64_t v4 = *(void **)(a1 + 16);
    if (v4)
    {
      if (!*(_BYTE *)(a1 + 49))
      {
        nw_context_queue_source_block(*(void **)(a1 + 8), v4);
        goto LABEL_10;
      }
    }

    else if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_queue_resume_source";
        _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not resuming source", buf, 0xCu);
      }
    }
  }

        goto LABEL_28;
      }

      free(backtrace_string);
    }
  }

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
LABEL_10:

  return v3;
}

  if (v11) {
    free(v11);
  }
LABEL_10:
}

  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0LL;
LABEL_10:

  return v3;
}

                    v24 = 1;
LABEL_32:

                    *(_BYTE *)(*(void *)&v63[8] + 24LL) = v24;
                    goto LABEL_33;
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v25 = (os_log_s *)(id)gLogObj;
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
                    _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s copy_info() returned NULL",  buf,  0xCu);
                  }
                }
              }
            }

    __int16 v20 = (v26 - 1) & v26;
    v23 = __clz(__rbit64(v26)) + (v17 << 6);
LABEL_12:
    v24 = *(void *)(v7 + 72) * v23;
    sub_181BC9248(*(void *)(v10 + 48) + v24, (uint64_t)v9, a1);
    result = (void *)sub_181BC928C((uint64_t)v9, *(void *)(v12 + 48) + v24, a1);
  }

  v27 = v25 + 3;
  if (v27 >= v21)
  {
LABEL_28:
    result = (void *)swift_release();
    uint64_t v5 = v29;
    goto LABEL_30;
  }

  v26 = *(void *)(v14 + 8 * v27);
  if (v26)
  {
    uint64_t v17 = v27;
    goto LABEL_27;
  }

  while (1)
  {
    uint64_t v17 = v27 + 1;
    if (__OFADD__(v27, 1LL)) {
      break;
    }
    if (v17 >= v21) {
      goto LABEL_28;
    }
    v26 = *(void *)(v14 + 8 * v17);
    ++v27;
    if (v26) {
      goto LABEL_27;
    }
  }

      unint64_t v30 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C45E5A0);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v30 - 8) + 56LL))(v9, 1LL, 1LL, v30);
      unint64_t v19 = 0LL;
    }

    int v28 = *(void *)(v33 + 8 * v29);
    if (v28)
    {
LABEL_16:
      v27 = v29;
LABEL_13:
      unint64_t v19 = (v28 - 1) & v28;
      v23 = __clz(__rbit64(v28)) + (v27 << 6);
      uint32_t v21 = v27;
      continue;
    }

    break;
  }

  while (1)
  {
    v27 = v29 + 1;
    if (__OFADD__(v29, 1LL)) {
      break;
    }
    if (v27 >= v34)
    {
      uint32_t v21 = v32;
      goto LABEL_27;
    }

    int v28 = *(void *)(v33 + 8 * v27);
    ++v29;
    if (v28) {
      goto LABEL_13;
    }
  }

  __break(1u);
  return result;
}

    swift_release();
    swift_bridgeObjectRelease();
    sub_181C2760C();
    return swift_release();
  }

  sub_181C8EC9C(v19, a4 & 1);
  uint32_t v21 = sub_181C8C01C(v13, v12);
  if ((v20 & 1) == (v22 & 1))
  {
    char v16 = v21;
    if ((v20 & 1) == 0) {
      goto LABEL_14;
    }
LABEL_12:
    sub_181BF9894((uint64_t)v47, (uint64_t)v46);
    __swift_destroy_boxed_opaque_existential_2((uint64_t)v47);
    swift_bridgeObjectRelease();
    v23 = (_OWORD *)(*(void *)(*(void *)a5 + 56LL) + 32 * v16);
    __swift_destroy_boxed_opaque_existential_2((uint64_t)v23);
    sub_181C275FC(v46, v23);
    goto LABEL_16;
  }

    if (v23 <= v12 >> 16) {
      goto LABEL_35;
    }
    uint64_t v12 = sub_18264EB98();
LABEL_29:
    *(_BYTE *)(a2 + v11) = v19;
    if (v26 == v11)
    {
      uint64_t v11 = a3;
      goto LABEL_33;
    }

    ++v11;
    if (v10 == v12 >> 14) {
      goto LABEL_33;
    }
  }

  __break(1u);
LABEL_35:
  __break(1u);
LABEL_36:
  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

    free(backtrace_string);
    goto LABEL_37;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
    os_log_type_t v9 = "%{public}s called with null metadata";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
  }

  nw_http_sniffing_get_mime_type_for_complex_nonscriptable_type_rules((uint64_t)&v29, a2);
  *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&v29.__r_.__value_.__l.__data_;
  uint64_t v13 = v29.__r_.__value_.__l.__cap_;
  a1->__r_.__value_.__l.__cap_ = v29.__r_.__value_.__l.__cap_;
  uint64_t v5 = HIBYTE(v13);
  if ((v5 & 0x80) != 0) {
    goto LABEL_30;
  }
LABEL_10:
  if ((_BYTE)v5) {
    goto LABEL_53;
  }
LABEL_31:
  BOOL v14 = *(void *)(a2 + 520);
  uint64_t v15 = *(void *)(a2 + 528);
  if (v14 == v15) {
    goto LABEL_52;
  }
  char v16 = v15 - v14;
  if (v16 >= 0x200) {
    char v16 = 512LL;
  }
  if (!v16) {
    goto LABEL_52;
  }
  uint64_t v17 = v16 + v14 - 1;
  __int16 v18 = v14 + 1;
  do
  {
    unint64_t v19 = *(unsigned __int8 *)(v18 - 1);
    uint32_t v21 = v19 >= 9 && v19 != 11 && v19 - 14 >= 0xD;
    uint64_t v22 = v19 & 0xFC;
    v23 = !v21 || v22 == 28;
    v24 = v23;
    if (v23) {
      break;
    }
  }

  while (v18++ <= v17);
  if ((v24 & 1) == 0)
  {
LABEL_52:
    std::string::__assign_external(a1, (const std::string::value_type *)kNWMIMETypeTextPlain);
    LOBYTE(v5) = a1->__r_.__value_.__s.__size_;
  }

    operator delete(v15[0]);
    if ((v14 & 0x80000000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_28;
  }

  if (v19) {
    free(v19);
  }
LABEL_10:
}

  if (v6) {
    free(v6);
  }
}

            nw_parameters_set_url_endpoint(a5, v20);
            goto LABEL_28;
          }
        }

        __nwlog_obj();
        v59 = *(const char **)(v26 + 16);
        *(_DWORD *)buf = 136446722;
        v94 = "__nw_protocol_get_parameters";
        if (!v59) {
          v59 = "invalid";
        }
        v95 = 2082;
        v96 = (void *)v59;
        v97 = 2048;
        v98 = v26;
        v92 = OS_LOG_TYPE_ERROR;
        v91 = 0;
        v83 = (char *)_os_log_send_and_compose_impl();
        if (__nwlog_fault(v83, &v92, &v91))
        {
          if (v92 == OS_LOG_TYPE_FAULT)
          {
            v60 = (os_log_s *)__nwlog_obj();
            v61 = v92;
            v62 = v60;
            if (os_log_type_enabled(v60, v92))
            {
              v63 = *(const char **)(v26 + 16);
              if (!v63) {
                v63 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = (void *)v63;
              v97 = 2048;
              v98 = v26;
              v64 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_176:
              v76 = v62;
              v77 = v61;
LABEL_177:
              _os_log_impl(&dword_181A5C000, v76, v77, v64, buf, 0x20u);
            }
          }

          else if (v91)
          {
            v69 = (char *)__nw_create_backtrace_string();
            log = (os_log_s *)__nwlog_obj();
            os_log_type_t type = v92;
            v70 = os_log_type_enabled(log, v92);
            if (v69)
            {
              if (v70)
              {
                v71 = *(const char **)(v26 + 16);
                if (!v71) {
                  v71 = "invalid";
                }
                *(_DWORD *)buf = 136446978;
                v94 = "__nw_protocol_get_parameters";
                v95 = 2082;
                v96 = (void *)v71;
                v97 = 2048;
                v98 = v26;
                v99 = 2082;
                v100 = v69;
                _os_log_impl( &dword_181A5C000,  log,  type,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(v69);
              goto LABEL_178;
            }

            if (v70)
            {
              v78 = *(const char **)(v26 + 16);
              if (!v78) {
                v78 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = (void *)v78;
              v97 = 2048;
              v98 = v26;
              v64 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
              v76 = log;
              v77 = type;
              goto LABEL_177;
            }
          }

          else
          {
            v62 = (os_log_s *)__nwlog_obj();
            v61 = v92;
            if (os_log_type_enabled(v62, v92))
            {
              v75 = *(const char **)(v26 + 16);
              if (!v75) {
                v75 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = (void *)v75;
              v97 = 2048;
              v98 = v26;
              v64 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
              goto LABEL_176;
            }
          }
        }

    if (v16) {
      free(v16);
    }
    goto LABEL_8;
  }

  *(_DWORD *)os_log_type_t type = nw_ws_write_header(a1, v11, a3, a4, a6, 0, 1);
  if (!a5 || !a6) {
    goto LABEL_8;
  }
  uint64_t v12 = malloc(a6);
  if (v12)
  {
LABEL_5:
    uint64_t v13 = 0LL;
    do
    {
      v12[v13] = *(_BYTE *)((unint64_t)type | v13 & 3) ^ *(_BYTE *)(a5 + v13);
      ++v13;
    }

    while (a6 != v13);
    BOOL v14 = dispatch_data_create(v12, a6, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A88]);
    nw_framer_write_output_data((nw_framer_t)v11, v14);

LABEL_8:
    return;
  }

  __nwlog_obj();
  unint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  int v28 = "strict_malloc";
  unint64_t v29 = 2048;
  unint64_t v30 = a6;
  __int16 v20 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v20))
  {
    free(v20);
    goto LABEL_5;
  }

  __break(1u);
}

  return v5;
}

  if (v10) {
    free(v10);
  }
LABEL_10:
}

  if (v12) {
    free(v12);
  }
LABEL_5:

  _Block_object_dispose(&v30, 8);
}

    free(backtrace_string);
    if (!v22) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }

  uint64_t v6 = v3[8];
  if (!v6)
  {
LABEL_18:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v21 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v56 = "nw_connection_group_copy_local_endpoint_for_message";
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (os_log_s *)(id)gLogObj;
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s Group descriptor is not set", buf, 0xCu);
      }

      goto LABEL_34;
    }

    if (!v53)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (os_log_s *)(id)gLogObj;
      int v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s Group descriptor is not set, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (os_log_s *)(id)gLogObj;
    v26 = type;
    v27 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v26, "%{public}s Group descriptor is not set, no backtrace", buf, 0xCu);
      }

      goto LABEL_34;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v56 = "nw_connection_group_copy_local_endpoint_for_message";
      v57 = 2082;
      v58 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s Group descriptor is not set, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_27;
  }

  uint64_t v7 = v6;
  uint64_t v8 = v7[2];

  if (v8 != 1)
  {
    uint64_t v12 = v3[8];
    if (v12)
    {
      uint64_t v13 = v12;
      BOOL v14 = v13[2];

      if (v14 == 2) {
        goto LABEL_12;
      }
      uint64_t v15 = v3[8];
      if (v15)
      {
        char v16 = v15;
        uint64_t v17 = v16[2];

        if (v17 == 4)
        {
LABEL_12:
          os_log_type_t v10 = nw_connection_group_copy_connection_for_message(v3, v5);
          uint64_t v11 = v10;
          if (v10)
          {
LABEL_13:
            os_log_type_t v9 = (nw_endpoint *)nw_connection_copy_connected_local_endpoint(v10);

            goto LABEL_38;
          }

    free(backtrace_string);
    goto LABEL_40;
  }

  uint64_t v5 = v3[37];
  if (!v5 || (node = nw_hash_table_get_node(v5, a2, 8LL)) == 0)
  {
LABEL_42:
    uint64_t v8 = 0LL;
    goto LABEL_43;
  }

  uint64_t v7 = 152LL;
  if (!*(void *)(node + 152)) {
    uint64_t v7 = 120LL;
  }
  uint64_t v8 = *(id *)(node + v7);
LABEL_43:

  return v8;
}

  if (v13) {
    free(v13);
  }
  return 0LL;
}

  if (v10) {
    free(v10);
  }
LABEL_10:
}

  if (v13) {
    free(v13);
  }
  os_log_type_t v10 = 0LL;
LABEL_10:

  return v10;
}

  if (v4) {
LABEL_28:
  }
    free(v4);
  return 0LL;
}

  if (v4) {
LABEL_28:
  }
    free(v4);
  return 0LL;
}

  if (v8) {
LABEL_28:
  }
    free(v8);
  return 0LL;
}

  if (v4) {
LABEL_28:
  }
    free(v4);
  return 0LL;
}

  if (v4) {
LABEL_28:
  }
    free(v4);
  return 0LL;
}

  (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1LL, a3);
LABEL_28:
  _Block_object_dispose(buf, 8);
  if ((v106 & 1) != 0)
  {
    if (object) {
      os_release(object);
    }
  }

  if (v5) {
    free(v5);
  }
}

      free(v31);
      goto LABEL_28;
    }
  }

  uint64_t v8 = v5[160];
  os_log_type_t v9 = secure_tcp;
  os_log_type_t v10 = *((void *)v9 + 13);
  uint64_t v11 = *(unsigned __int16 *)(v10 + 108);
  v10 += 108LL;
  uint64_t v12 = v11 & 0xFFFFFFFD | (*(unsigned __int8 *)(v10 + 2) << 16);
  *(_WORD *)os_log_type_t v10 = v11 & 0xFFFD | (v8 >> 1) & 2;
  *(_BYTE *)(v10 + 2) = BYTE2(v12);

  uint64_t v13 = v9;
  *((void *)v13 + 12) = *((void *)v13 + 12) & 0xFFFFFFFFFFFFFF3FLL | 0x80;

  BOOL v14 = nw_connection_create(v6, v13);
  uint64_t v15 = (void *)*((void *)v5 + 18);
  *((void *)v5 + 18) = v14;

  if (!*((void *)v5 + 18))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = (id)gLogObj;
    *(_DWORD *)v54 = 136446210;
    *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
    v23 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v47 = 0;
    if (__nwlog_fault(v23, buf, &v47))
    {
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        v25 = buf[0];
        if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v54 = 136446210;
          *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s nw_connection_create failed", v54, 0xCu);
        }
      }

      else if (v47)
      {
        v27 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        int v28 = buf[0];
        unint64_t v29 = os_log_type_enabled(v24, (os_log_type_t)buf[0]);
        if (v27)
        {
          if (v29)
          {
            *(_DWORD *)v54 = 136446466;
            *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
            *(_WORD *)&v54[12] = 2082;
            *(void *)&v54[14] = v27;
            _os_log_impl( &dword_181A5C000,  v24,  v28,  "%{public}s nw_connection_create failed, dumping backtrace:%{public}s",  v54,  0x16u);
          }

          free(v27);
          if (!v23) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        if (v29)
        {
          *(_DWORD *)v54 = 136446210;
          *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
          _os_log_impl(&dword_181A5C000, v24, v28, "%{public}s nw_connection_create failed, no backtrace", v54, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        v39 = buf[0];
        if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v54 = 136446210;
          *(void *)&v54[4] = "nw_socks5_connection_connect_outer_on_queue";
          _os_log_impl( &dword_181A5C000,  v24,  v39,  "%{public}s nw_connection_create failed, backtrace limit exceeded",  v54,  0xCu);
        }
      }
    }

    if (!v23)
    {
LABEL_14:
      v26 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 12);
      nw_socks5_connection_cancel_on_queue(v5, v26);

      goto LABEL_29;
    }

    free(backtrace_string);
    goto LABEL_37;
  }

  uint64_t v8 = (os_log_s *)__nwlog_obj();
  os_log_type_t v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "nw_protocol_trainer_add_input_handler";
    os_log_type_t v10 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }

    if (v8) {
      free(v8);
    }
    goto LABEL_8;
  }

  uint64_t v5 = (void *)v3[14];
  if (v5)
  {
    free(v5);
    v4[14] = 0LL;
  }

  if (!a2 || strlen(a2) - 1 > 0x3FE) {
    goto LABEL_8;
  }
  uint64_t v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    v4[14] = v6;
LABEL_8:

    return;
  }

  __nwlog_obj();
  BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "strict_strdup";
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }

  __break(1u);
}

    if (v8) {
      free(v8);
    }
    goto LABEL_8;
  }

  uint64_t v5 = *(void **)(v3[13] + 112LL);
  if (v5)
  {
    free(v5);
    *(void *)(v4[13] + 112LL) = 0LL;
  }

  if (!a2 || strlen(a2) - 1 > 0x3FE) {
    goto LABEL_8;
  }
  uint64_t v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    *(void *)(v4[13] + 112LL) = v6;
LABEL_8:

    return;
  }

  __nwlog_obj();
  BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "strict_strdup";
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }

  __break(1u);
}

    if (v8) {
      free(v8);
    }
    goto LABEL_8;
  }

  uint64_t v5 = *(void **)(v3[13] + 120LL);
  if (v5)
  {
    free(v5);
    *(void *)(v4[13] + 120LL) = 0LL;
  }

  if (!a2 || strlen(a2) - 1 > 0x3FE) {
    goto LABEL_8;
  }
  uint64_t v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    *(void *)(v4[13] + 120LL) = v6;
LABEL_8:

    return;
  }

  __nwlog_obj();
  BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "strict_strdup";
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }

  __break(1u);
}

  if (v17) {
    free(v17);
  }
LABEL_10:
}

    if (v8) {
      free(v8);
    }
    goto LABEL_8;
  }

  uint64_t v5 = (void *)v3[15];
  if (v5)
  {
    free(v5);
    v4[15] = 0LL;
  }

  if (!a2 || strlen(a2) - 1 > 0x3FE) {
    goto LABEL_8;
  }
  uint64_t v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    v4[15] = v6;
LABEL_8:

    return;
  }

  __nwlog_obj();
  BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "strict_strdup";
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }

  __break(1u);
}

  if (v9) {
    free(v9);
  }
LABEL_8:
}

  if (v6) {
    free(v6);
  }
  has_protocol_in_stack = 0LL;
LABEL_10:

  return has_protocol_in_stack;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_8;
  }

  uint64_t v5 = *(void **)(v3[13] + 128LL);
  if (v5)
  {
    free(v5);
    *(void *)(v4[13] + 128LL) = 0LL;
  }

  if (!a2 || strlen(a2) - 1 > 0x3FE) {
    goto LABEL_8;
  }
  uint64_t v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    *(void *)(v4[13] + 128LL) = v6;
LABEL_8:

    return;
  }

  __nwlog_obj();
  BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "strict_strdup";
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }

  __break(1u);
}

  if (v7) {
    free(v7);
  }
LABEL_10:
}

  if (v10) {
    free(v10);
  }
LABEL_10:
}

    free(v21);
    goto LABEL_28;
  }

  __nwlog_obj();
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v62 = "nw_endpoint_create_custom";
  v43 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v58.receiver) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v43, &v58, &type))
  {
    if (LOBYTE(v58.receiver) == 17)
    {
      __nwlog_obj();
      v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v45 = (os_log_type_t)v58.receiver;
      if (os_log_type_enabled(v44, (os_log_type_t)v58.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_endpoint_create_custom";
        _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s called with null custom_data", buf, 0xCu);
      }
    }

    else if (type)
    {
      v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = (os_log_type_t)v58.receiver;
      v48 = os_log_type_enabled(v44, (os_log_type_t)v58.receiver);
      if (v46)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          v62 = "nw_endpoint_create_custom";
          v63 = 2082;
          *(void *)v64 = v46;
          _os_log_impl( &dword_181A5C000,  v44,  v47,  "%{public}s called with null custom_data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v46);
        goto LABEL_95;
      }

      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_endpoint_create_custom";
        _os_log_impl(&dword_181A5C000, v44, v47, "%{public}s called with null custom_data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v53 = (os_log_type_t)v58.receiver;
      if (os_log_type_enabled(v44, (os_log_type_t)v58.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_endpoint_create_custom";
        _os_log_impl( &dword_181A5C000,  v44,  v53,  "%{public}s called with null custom_data, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        nw_masque_mark_failed_with_error(a1, 94);
        goto LABEL_266;
      }

      if (capsule_type != 16770305)
      {
        if (capsule_type == 16770307)
        {
          if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
            goto LABEL_266;
          }
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint64_t v7 = gprivacy_proxyLogObj;
          if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_266;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 531;
          *(_WORD *)&buf[22] = 2080;
          v102 = " ";
          uint64_t v8 = "%{public}s %{public}s%sReceived ACK_LISTENER_DEMUX capsule, ignoring";
LABEL_14:
          os_log_type_t v9 = (os_log_s *)v7;
          os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
          goto LABEL_61;
        }

  if (v10) {
    free(v10);
  }
  return 0LL;
}

  uint64_t v12 = _Block_copy(*(const void **)(v13 + 64));
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 120LL));
  if (!v15)
  {
LABEL_35:
    if (!v14) {
      goto LABEL_42;
    }
    goto LABEL_36;
  }

  __int16 v20 = (unsigned __int8 *)*(id *)(a1 + 32);
  uint32_t v21 = v12;
  uint64_t v12 = v21;
  uint64_t v22 = v29;
  if (v21 && v20[156] != 255) {
    (*((void (**)(id, void, void *))v21 + 2))(v21, v30, v29);
  }
  if (v22) {
    free(v22);
  }

  if (v14)
  {
LABEL_36:
    v23 = (unsigned __int8 *)*(id *)(a1 + 32);
    v24 = v12;
    uint64_t v12 = v24;
    v25 = v27;
    if (v24 && v23[156] != 255) {
      (*((void (**)(id, void, void *))v24 + 2))(v24, v28, v27);
    }
    if (v25) {
      free(v25);
    }
  }
}
}

    free(backtrace_string);
    goto LABEL_39;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_protocol_webtransport_http3_stream_connect";
    uint64_t v8 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_39;
  }

  uint64_t v8 = (os_log_s *)__nwlog_obj();
  os_log_type_t v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
    os_log_type_t v10 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_39;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_protocol_webtransport_http2_stream_connect";
    uint64_t v8 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_52;
  }

  if (setsockopt(a3, 0xFFFF, 4130, &v55, 4u))
  {
    uint64_t v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v6;
    uint64_t v7 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        os_log_type_t v10 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d";
LABEL_50:
        v33 = (os_log_s *)v8;
        __int16 v34 = v9;
        unint64_t v35 = 18;
LABEL_51:
        _os_log_impl(&dword_181A5C000, v33, v34, v10, buf, v35);
        goto LABEL_52;
      }

      goto LABEL_52;
    }

    if (!v53)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        os_log_type_t v10 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_50;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = gLogObj;
    os_log_type_t v9 = type;
    __int16 v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        os_log_type_t v10 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d, no backtrace";
        goto LABEL_50;
      }

      goto LABEL_52;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = backtrace_string;
      unint64_t v19 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_25:
      uint32_t v21 = (os_log_s *)v8;
      uint64_t v22 = v9;
      v23 = 28;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v21, v22, v19, buf, v23);
      goto LABEL_27;
    }

    goto LABEL_27;
  }

  if (xpc_dictionary_get_BOOL(*(xpc_object_t *)(a2 + 16), "tfo") && setsockopt(a3, 6, 261, &v55, 4u))
  {
    uint64_t v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v12;
    uint64_t v13 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (os_log_s *)gLogObj;
      uint64_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      char v16 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d";
      goto LABEL_87;
    }

    if (!v53)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      uint64_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      char v16 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_87;
    }

    v38 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = (os_log_s *)gLogObj;
    uint64_t v15 = type;
    v39 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v38)
    {
      if (!v39) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      char v16 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d, no backtrace";
      goto LABEL_87;
    }

    if (v39)
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      *(_WORD *)&buf[24] = 2082;
      *(void *)&buf[26] = v38;
      v40 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_72:
      _os_log_impl(&dword_181A5C000, v14, v15, v40, buf, 0x22u);
      goto LABEL_73;
    }

    goto LABEL_73;
  }

  if (a1 == 30
    && xpc_dictionary_get_BOOL(*(xpc_object_t *)(a2 + 16), "coproc")
    && setsockopt(a3, 0xFFFF, 4376, &v55, 4u))
  {
    v24 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v24;
    uint64_t v13 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      uint64_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      char v16 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d";
      goto LABEL_87;
    }

    if (!v53)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      uint64_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      char v16 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_87;
    }

    v38 = (char *)__nw_create_backtrace_string();
    BOOL v14 = (os_log_s *)__nwlog_obj();
    uint64_t v15 = type;
    v43 = os_log_type_enabled(v14, type);
    if (!v38)
    {
      if (!v43) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      char v16 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, no backtrace";
LABEL_87:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0x18u);
LABEL_88:
      if (!v13) {
        return 0LL;
      }
      goto LABEL_89;
    }

    if (v43)
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      *(_WORD *)&buf[24] = 2082;
      *(void *)&buf[26] = v38;
      v40 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_72;
    }

    free(backtrace_string);
    goto LABEL_124;
  }

  v51 = 1;
  if (setsockopt(v11, 0xFFFF, 4, &v51, 4u))
  {
    uint64_t v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v13;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v13;
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    type.sa_len = 16;
    v50 = OS_LOG_TYPE_DEFAULT;
    if (type.sa_len == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len)) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      uint64_t v17 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d";
LABEL_122:
      v44 = v15;
      v45 = sa_len;
      v46 = 18;
LABEL_123:
      _os_log_impl(&dword_181A5C000, v44, v45, v17, buf, v46);
      goto LABEL_124;
    }

    if (v50 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len)) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      uint64_t v17 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_122;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = (os_log_s *)gLogObj;
    sa_len = type.sa_len;
    uint32_t v21 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len);
    if (!backtrace_string)
    {
      if (!v21) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      uint64_t v17 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d, no backtrace";
      goto LABEL_122;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446722;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      v57 = 2082;
      *(void *)v58 = backtrace_string;
      uint64_t v22 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_25:
      v24 = v15;
      v25 = sa_len;
      v26 = 28;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v24, v25, v22, buf, v26);
      goto LABEL_27;
    }

    goto LABEL_27;
  }

  if (a5 && setsockopt(v12, 0xFFFF, 4356, &v51, 4u))
  {
    unint64_t v19 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v19;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v19;
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    type.sa_len = 16;
    v50 = OS_LOG_TYPE_DEFAULT;
    if (type.sa_len == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len)) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      uint64_t v17 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d";
      goto LABEL_122;
    }

    if (v50 == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      sa_len = type.sa_len;
      if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len)) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      uint64_t v17 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_122;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = (os_log_s *)gLogObj;
    sa_len = type.sa_len;
    unint64_t v30 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len);
    if (!backtrace_string)
    {
      if (!v30) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      uint64_t v17 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace";
      goto LABEL_122;
    }

    if (v30)
    {
      *(_DWORD *)buf = 136446722;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      v57 = 2082;
      *(void *)v58 = backtrace_string;
      uint64_t v22 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

    goto LABEL_27;
  }

  if (a2 == 30)
  {
    if (setsockopt(v12, 41, 27, &v51, 4u))
    {
      v27 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      *a6 = v27;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v27;
      BOOL v14 = (char *)_os_log_send_and_compose_impl();
      type.sa_len = 16;
      v50 = OS_LOG_TYPE_DEFAULT;
      if (type.sa_len == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = (os_log_s *)gLogObj;
        sa_len = type.sa_len;
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        uint64_t v17 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d";
        goto LABEL_122;
      }

      if (v50 == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        uint64_t v17 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_122;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      sa_len = type.sa_len;
      __int16 v32 = os_log_type_enabled(v15, (os_log_type_t)type.sa_len);
      if (!backtrace_string)
      {
        if (!v32) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        uint64_t v17 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d, no backtrace";
        goto LABEL_122;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        v57 = 2082;
        *(void *)v58 = backtrace_string;
        uint64_t v22 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_25;
      }

      goto LABEL_27;
    }

    if (v52 && setsockopt(v12, 41, 125, &v52, 4u))
    {
      v31 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      *a6 = v31;
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v31;
      BOOL v14 = (char *)_os_log_send_and_compose_impl();
      type.sa_len = 16;
      v50 = OS_LOG_TYPE_DEFAULT;
      if (type.sa_len == 17)
      {
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        uint64_t v17 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d";
        goto LABEL_122;
      }

      if (v50 == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        uint64_t v17 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_122;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      sa_len = type.sa_len;
      v42 = os_log_type_enabled(v15, (os_log_type_t)type.sa_len);
      if (!backtrace_string)
      {
        if (!v42) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        uint64_t v17 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d, no backtrace";
        goto LABEL_122;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        v57 = 2082;
        *(void *)v58 = backtrace_string;
        uint64_t v22 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_25;
      }

      goto LABEL_27;
    }

    memset(&type.sa_data[2], 0, 24);
  }

  else
  {
    if (v52 && setsockopt(v12, 0, 25, &v52, 4u))
    {
      int v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      *a6 = v28;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v28;
      BOOL v14 = (char *)_os_log_send_and_compose_impl();
      type.sa_len = 16;
      v50 = OS_LOG_TYPE_DEFAULT;
      if (type.sa_len == 17)
      {
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        uint64_t v17 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d";
        goto LABEL_122;
      }

      if (v50 == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        uint64_t v17 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_122;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      sa_len = type.sa_len;
      v37 = os_log_type_enabled(v15, (os_log_type_t)type.sa_len);
      if (!backtrace_string)
      {
        if (!v37) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        uint64_t v17 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d, no backtrace";
        goto LABEL_122;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        v57 = 2082;
        *(void *)v58 = backtrace_string;
        uint64_t v22 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_25;
      }

      goto LABEL_27;
    }

    memset(&type, 0, 28);
    if (a2 == 2)
    {
      *(_WORD *)&type.sa_len = 528;
      unint64_t v29 = 16;
      goto LABEL_66;
    }
  }

  *(_WORD *)&type.sa_len = 7708;
  unint64_t v29 = 28;
LABEL_66:
  *(_WORD *)type.sa_data = a3;
  if (bind(v12, &type, v29))
  {
    v33 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v33;
    if (v33 <= 0x31 && ((1LL << v33) & 0x2000000002002LL) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v35 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s bind(fd %d) failed %{darwin.errno}d",  buf,  0x18u);
      }

      goto LABEL_126;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v12;
    v57 = 1024;
    v58[0] = v33;
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    v50 = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if ((__nwlog_fault(v14, &v50, &v48) & 1) != 0)
    {
      if (v50 == OS_LOG_TYPE_FAULT)
      {
        v38 = (os_log_s *)__nwlog_obj();
        v39 = v50;
        if (!os_log_type_enabled(v38, v50)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        uint64_t v17 = "%{public}s bind(fd %d) failed %{darwin.errno}d";
        goto LABEL_133;
      }

      if (!v48)
      {
        v38 = (os_log_s *)__nwlog_obj();
        v39 = v50;
        if (!os_log_type_enabled(v38, v50)) {
          goto LABEL_124;
        }
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        uint64_t v17 = "%{public}s bind(fd %d) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_133;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = (os_log_s *)__nwlog_obj();
      v39 = v50;
      v43 = os_log_type_enabled(v38, v50);
      if (backtrace_string)
      {
        if (!v43) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446978;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        LOWORD(v58[1]) = 2082;
        *(void *)((char *)&v58[1] + 2) = backtrace_string;
        uint64_t v22 = "%{public}s bind(fd %d) failed %{darwin.errno}d, dumping backtrace:%{public}s";
        v24 = v38;
        v25 = v39;
        v26 = 34;
        goto LABEL_26;
      }

      if (v43)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        uint64_t v17 = "%{public}s bind(fd %d) failed %{darwin.errno}d, no backtrace";
LABEL_133:
        v44 = v38;
        v45 = v39;
        v46 = 24;
        goto LABEL_123;
      }
    }

    if (v12) {
      free(v12);
    }
    goto LABEL_8;
  }

  uint64_t v5 = v3;
  uint64_t v6 = v5;
  uint64_t v7 = (void *)*((void *)v5 + 3);
  if (v7)
  {
    uint64_t v8 = strlen(*((const char **)v5 + 3));
    bzero(v7, v8);
    os_log_type_t v9 = (void *)v6[3];
    if (v9)
    {
      free(v9);
      v6[3] = 0LL;
    }
  }

  if (!a2) {
    goto LABEL_8;
  }
  os_log_type_t v10 = strdup(a2);
  if (v10)
  {
LABEL_7:
    v6[3] = v10;
LABEL_8:

    return;
  }

  __nwlog_obj();
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v24 = "strict_strdup";
  char v16 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v16))
  {
    free(v16);
    goto LABEL_7;
  }

  __break(1u);
}

    if (v11) {
      free(v11);
    }
    uint64_t v4 = 0LL;
    goto LABEL_6;
  }

  uint64_t v4 = (void **)calloc(1uLL, 0x10uLL);
  if (!v4)
  {
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v25 = "strict_calloc";
    v26 = 2048;
    v27 = 1LL;
    int v28 = 2048;
    unint64_t v29 = 16LL;
    uint64_t v15 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v15);
    if (result) {
      goto LABEL_30;
    }
    free(v15);
  }

  uint64_t v5 = _Block_copy(*(const void **)a2);
  uint64_t v6 = *v4;
  *uint64_t v4 = v5;

  uint64_t v7 = *(const char **)(a2 + 8);
  if (!v7)
  {
LABEL_6:

    return (BOOL)v4;
  }

  uint64_t v8 = strdup(v7);
  if (v8)
  {
LABEL_5:
    v4[1] = v8;
    goto LABEL_6;
  }

  __nwlog_obj();
  char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v25 = "strict_strdup";
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_5;
  }

  if (v9) {
LABEL_28:
  }
    free(v9);
  return 0LL;
}

      free(backtrace_string);
      goto LABEL_37;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_http_connect_get_local_endpoint";
    uint64_t v8 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
LABEL_37:
    if (v5) {
      free(v5);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_http_connect_get_local_endpoint";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      uint64_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_http_connect_get_local_endpoint";
      uint64_t v8 = "%{public}s called with null http_connect";
      goto LABEL_36;
    }

    if (!v13)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      uint64_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_http_connect_get_local_endpoint";
      uint64_t v8 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = type;
    uint64_t v12 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        char v16 = "nw_protocol_http_connect_get_local_endpoint";
        uint64_t v17 = 2082;
        __int16 v18 = backtrace_string;
        uint64_t v11 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_26;
      }

      goto LABEL_27;
    }

    if (!v12) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_http_connect_get_local_endpoint";
    uint64_t v8 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_36;
  }

  if (handle[13]) {
    return (nw_protocol *)handle[15];
  }
  result = a1->default_input_handler;
  if (result)
  {
    callbacks = result->callbacks;
    if (callbacks)
    {
      get_local_endpoint = (uint64_t (*)(void))callbacks->get_local_endpoint;
    }

    return 0LL;
  }

  return result;
}

  localEndpoint = self->_localEndpoint;
  if (localEndpoint)
  {
    -[NWPBEndpoint dictionaryRepresentation](localEndpoint, "dictionaryRepresentation");
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    [v4 setObject:v13 forKey:@"localEndpoint"];
  }

  requiredInterface = self->_requiredInterface;
  if (requiredInterface)
  {
    -[NWPBInterface dictionaryRepresentation](requiredInterface, "dictionaryRepresentation");
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    [v4 setObject:v15 forKey:@"requiredInterface"];
  }

  p_prohibitedInterfaceTypes = &self->_prohibitedInterfaceTypes;
  if (self->_prohibitedInterfaceTypes.count)
  {
    objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:");
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    if (self->_prohibitedInterfaceTypes.count)
    {
      __int16 v18 = 0LL;
      do
      {
        __int16 v20 = p_prohibitedInterfaceTypes->list[v18];
        if (v20 < 5)
        {
          unint64_t v19 = off_189BBCB38[v20];
        }

        else
        {
          objc_msgSend( NSString,  "stringWithFormat:",  @"(unknown: %i)",  p_prohibitedInterfaceTypes->list[v18]);
          unint64_t v19 = (__CFString *)objc_claimAutoreleasedReturnValue();
        }

        [v17 addObject:v19];

        ++v18;
      }

      while (v18 < self->_prohibitedInterfaceTypes.count);
    }

    [v4 setObject:v17 forKey:@"prohibitedInterfaceTypes"];
  }

  p_prohibitedInterfaceSubTypes = &self->_prohibitedInterfaceSubTypes;
  if (self->_prohibitedInterfaceSubTypes.count)
  {
    objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:");
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    if (self->_prohibitedInterfaceSubTypes.count)
    {
      v23 = 0LL;
      do
      {
        v25 = p_prohibitedInterfaceSubTypes->list[v23];
        if (v25 < 3)
        {
          v24 = off_189BBCB60[v25];
        }

        else
        {
          objc_msgSend( NSString,  "stringWithFormat:",  @"(unknown: %i)",  p_prohibitedInterfaceSubTypes->list[v23]);
          v24 = (__CFString *)objc_claimAutoreleasedReturnValue();
        }

        [v22 addObject:v24];

        ++v23;
      }

      while (v23 < self->_prohibitedInterfaceSubTypes.count);
    }

    [v4 setObject:v22 forKey:@"prohibitedInterfaceSubTypes"];
  }

  if (-[NSMutableArray count](self->_prohibitedInterfaces, "count"))
  {
    v26 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  -[NSMutableArray count](self->_prohibitedInterfaces, "count"));
    v85 = 0u;
    v86 = 0u;
    v87 = 0u;
    v88 = 0u;
    v27 = self->_prohibitedInterfaces;
    int v28 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v85,  v92,  16LL);
    if (v28)
    {
      unint64_t v29 = v28;
      unint64_t v30 = *(void *)v86;
      do
      {
        for (i = 0LL; i != v29; ++i)
        {
          if (*(void *)v86 != v30) {
            objc_enumerationMutation(v27);
          }
          [*(id *)(*((void *)&v85 + 1) + 8 * i) dictionaryRepresentation];
          __int16 v32 = (void *)objc_claimAutoreleasedReturnValue();
          [v26 addObject:v32];
        }

        unint64_t v29 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v85,  v92,  16LL);
      }

      while (v29);
    }

    [v4 setObject:v26 forKey:@"prohibitedInterfaces"];
  }

  if (-[NSMutableArray count](self->_prohibitedAgents, "count"))
  {
    v33 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  -[NSMutableArray count](self->_prohibitedAgents, "count"));
    v81 = 0u;
    v82 = 0u;
    v83 = 0u;
    v84 = 0u;
    __int16 v34 = self->_prohibitedAgents;
    unint64_t v35 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v81,  v91,  16LL);
    if (v35)
    {
      uint64_t v36 = v35;
      v37 = *(void *)v82;
      do
      {
        for (j = 0LL; j != v36; ++j)
        {
          if (*(void *)v82 != v37) {
            objc_enumerationMutation(v34);
          }
          [*(id *)(*((void *)&v81 + 1) + 8 * j) dictionaryRepresentation];
          v39 = (void *)objc_claimAutoreleasedReturnValue();
          [v33 addObject:v39];
        }

        uint64_t v36 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v81,  v91,  16LL);
      }

      while (v36);
    }

    [v4 setObject:v33 forKey:@"prohibitedAgents"];
  }

  if (-[NSMutableArray count](self->_requiredAgents, "count"))
  {
    v40 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  -[NSMutableArray count](self->_requiredAgents, "count"));
    v77 = 0u;
    v78 = 0u;
    v79 = 0u;
    v80 = 0u;
    v41 = self->_requiredAgents;
    v42 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v41,  "countByEnumeratingWithState:objects:count:",  &v77,  v90,  16LL);
    if (v42)
    {
      v43 = v42;
      v44 = *(void *)v78;
      do
      {
        for (k = 0LL; k != v43; ++k)
        {
          if (*(void *)v78 != v44) {
            objc_enumerationMutation(v41);
          }
          [*(id *)(*((void *)&v77 + 1) + 8 * k) dictionaryRepresentation];
          v46 = (void *)objc_claimAutoreleasedReturnValue();
          [v40 addObject:v46];
        }

        v43 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v41,  "countByEnumeratingWithState:objects:count:",  &v77,  v90,  16LL);
      }

      while (v43);
    }

    [v4 setObject:v40 forKey:@"requiredAgents"];
  }

  if (-[NSMutableArray count](self->_preferredAgents, "count"))
  {
    v47 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  -[NSMutableArray count](self->_preferredAgents, "count"));
    v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    v76 = 0u;
    v48 = self->_preferredAgents;
    v49 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v73,  v89,  16LL);
    if (v49)
    {
      v50 = v49;
      v51 = *(void *)v74;
      do
      {
        for (m = 0LL; m != v50; ++m)
        {
          if (*(void *)v74 != v51) {
            objc_enumerationMutation(v48);
          }
          [*(id *)(*((void *)&v73 + 1) + 8 * m) dictionaryRepresentation];
          v53 = (void *)objc_claimAutoreleasedReturnValue();
          [v47 addObject:v53];
        }

        v50 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v73,  v89,  16LL);
      }

      while (v50);
    }

    [v4 setObject:v47 forKey:@"preferredAgents"];
  }

  metadata = self->_metadata;
  if (metadata) {
    [v4 setObject:metadata forKey:@"metadata"];
  }
  v55 = v4;

  return v55;
}

  unint64_t v19 = 0LL;
  if ((*(_WORD *)&self->_has & 0x1000) != 0)
  {
LABEL_13:
    __int16 v20 = 2654435761LL * self->_reuseLocalAddress;
    if ((*(_WORD *)&self->_has & 0x200) != 0) {
      goto LABEL_14;
    }
    goto LABEL_29;
  }

      unint64_t v19 = *(void *)(a1 + 120);
      if (v19)
      {
        node = nw_hash_table_get_node(v19, a2 + 32, 4LL);
        if (node)
        {
          if (nw_hash_table_remove_node(*(void *)(a1 + 120), node))
          {
            if (!gLogDatapath)
            {
LABEL_58:
              *uint64_t v4 = -1;
              return;
            }

            uint32_t v21 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
LABEL_57:
              if (gLogDatapath)
              {
                v51 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                {
                  v52 = *v4;
                  *(_DWORD *)buf = 136446722;
                  v63 = "nw_http2_transport_stream_close";
                  v64 = 2082;
                  v65 = (void *)(a1 + 205);
                  v66 = 1024;
                  v67 = v52;
                  _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s removed stream %d from id based table",  buf,  0x1Cu);
                }
              }

              goto LABEL_58;
            }

            uint64_t v22 = *v4;
            *(_DWORD *)buf = 136446722;
            v63 = "nw_http2_transport_remove_from_id_table";
            v64 = 2082;
            v65 = (void *)(a1 + 205);
            v66 = 1024;
            v67 = v22;
            v23 = "%{public}s %{public}s removed stream %d from id based table";
LABEL_56:
            _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, v23, buf, 0x1Cu);
            goto LABEL_57;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = *v4;
          *(_DWORD *)buf = 136446722;
          v63 = "nw_http2_transport_remove_from_id_table";
          v64 = 2082;
          v65 = (void *)(a1 + 205);
          v66 = 1024;
          v67 = v31;
          __int16 v32 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v60 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v33 = (os_log_s *)gLogObj;
            __int16 v34 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_52;
            }
            unint64_t v35 = *v4;
            *(_DWORD *)buf = 136446722;
            v63 = "nw_http2_transport_remove_from_id_table";
            v64 = 2082;
            v65 = (void *)(a1 + 205);
            v66 = 1024;
            v67 = v35;
            uint64_t v36 = "%{public}s %{public}s failed to remove id node for stream %d from table";
          }

          else if (v60)
          {
            v37 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v33 = (os_log_s *)gLogObj;
            __int16 v34 = type;
            v38 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v37)
            {
              if (v38)
              {
                v39 = *v4;
                *(_DWORD *)buf = 136446978;
                v63 = "nw_http2_transport_remove_from_id_table";
                v64 = 2082;
                v65 = (void *)(a1 + 205);
                v66 = 1024;
                v67 = v39;
                v68 = 2082;
                v69 = (uint64_t)v37;
                _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s %{public}s failed to remove id node for stream %d from table, dumping backtrace:%{public}s",  buf,  0x26u);
              }

              free(v37);
              goto LABEL_52;
            }

            if (!v38)
            {
LABEL_52:
              if (v32) {
                free(v32);
              }
              goto LABEL_54;
            }

            v41 = *v4;
            *(_DWORD *)buf = 136446722;
            v63 = "nw_http2_transport_remove_from_id_table";
            v64 = 2082;
            v65 = (void *)(a1 + 205);
            v66 = 1024;
            v67 = v41;
            uint64_t v36 = "%{public}s %{public}s failed to remove id node for stream %d from table, no backtrace";
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v33 = (os_log_s *)gLogObj;
            __int16 v34 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_52;
            }
            v40 = *v4;
            *(_DWORD *)buf = 136446722;
            v63 = "nw_http2_transport_remove_from_id_table";
            v64 = 2082;
            v65 = (void *)(a1 + 205);
            v66 = 1024;
            v67 = v40;
            uint64_t v36 = "%{public}s %{public}s failed to remove id node for stream %d from table, backtrace limit exceeded";
          }

          _os_log_impl(&dword_181A5C000, v33, v34, v36, buf, 0x1Cu);
          goto LABEL_52;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v29 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          unint64_t v30 = *v4;
          *(_DWORD *)buf = 136446722;
          v63 = "nw_http2_transport_remove_from_id_table";
          v64 = 2082;
          v65 = (void *)(a1 + 205);
          v66 = 1024;
          v67 = v30;
          v26 = "%{public}s %{public}s stream %d is not present in id based table, will not remove";
          v27 = (os_log_s *)v29;
          int v28 = OS_LOG_TYPE_INFO;
          goto LABEL_37;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v25 = *v4;
          *(_DWORD *)buf = 136446722;
          v63 = "nw_http2_transport_remove_from_id_table";
          v64 = 2082;
          v65 = (void *)(a1 + 205);
          v66 = 1024;
          v67 = v25;
          v26 = "%{public}s %{public}s id based table is NULL, cannot remove stream %d";
          v27 = (os_log_s *)v24;
          int v28 = OS_LOG_TYPE_ERROR;
LABEL_37:
          _os_log_impl(&dword_181A5C000, v27, v28, v26, buf, 0x1Cu);
        }
      }

      nw_http2_transport_connection_close(*(void *)(a1 + 40));
LABEL_28:
      v8 += v9;
      if (gLogDatapath)
      {
        v23 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          v24 = *(void *)(a1 + 40);
          v25 = (const char *)(v24 + 205);
          uint64_t v5 = v24 == 0;
          v26 = "";
          if (!v5) {
            v26 = v25;
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v36 = "nw_protocol_http2_transport_process_input_block_invoke";
          v37 = 2082;
          v38 = v26;
          v39 = 1024;
          v40 = v8;
          _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s nghttp2_session_mem_recv consumed %u bytes",  buf,  0x1Cu);
        }
      }

      uint64_t v4 = v34;
      if (v8 >= v34) {
        goto LABEL_41;
      }
    }

    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    __int16 v20 = *(void *)(a1 + 40);
    if (v20) {
      uint32_t v21 = (const char *)(v20 + 205);
    }
    else {
      uint32_t v21 = "";
    }
    uint64_t v22 = nghttp2_strerror();
    *(_DWORD *)buf = 136446978;
    uint64_t v36 = "nw_protocol_http2_transport_process_input_block_invoke";
    v37 = 2082;
    v38 = v21;
    v39 = 1024;
    v40 = -902;
    v41 = 2082;
    v42 = v22;
    char v16 = (os_log_s *)v11;
    uint64_t v17 = OS_LOG_TYPE_DEFAULT;
    __int16 v18 = "%{public}s %{public}s Could not process incoming data: %d (%{public}s), closing";
    goto LABEL_26;
  }

  uint64_t v8 = 0;
LABEL_41:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v8;
  return v33;
}

      goto LABEL_28;
    }

      goto LABEL_28;
    }

    if (!v44)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446722;
        v47 = "nw_necp_append_tlv";
        v48 = 1024;
        *(_DWORD *)v49 = 8;
        *(_WORD *)&v49[4] = 1024;
        *(_DWORD *)&v49[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v43,  "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded",  buf,  0x18u);
      }

      goto LABEL_27;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v41 = type;
    v42 = os_log_type_enabled(v11, type);
    if (!v33)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446722;
        v47 = "nw_necp_append_tlv";
        v48 = 1024;
        *(_DWORD *)v49 = 8;
        *(_WORD *)&v49[4] = 1024;
        *(_DWORD *)&v49[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v41,  "%{public}s type=%u length=%u but value is NULL, no backtrace",  buf,  0x18u);
      }

      goto LABEL_27;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446978;
      v47 = "nw_necp_append_tlv";
      v48 = 1024;
      *(_DWORD *)v49 = 8;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v8;
      *(_WORD *)v50 = 2082;
      *(void *)&v50[2] = v33;
      _os_log_impl( &dword_181A5C000,  v11,  v41,  "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s",  buf,  0x22u);
    }

      goto LABEL_28;
    }

    if (!v44)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446722;
        v47 = "nw_necp_append_tlv";
        v48 = 1024;
        *(_DWORD *)v49 = 9;
        *(_WORD *)&v49[4] = 1024;
        *(_DWORD *)&v49[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v43,  "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded",  buf,  0x18u);
      }

      goto LABEL_27;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v41 = type;
    v42 = os_log_type_enabled(v11, type);
    if (!v33)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446722;
        v47 = "nw_necp_append_tlv";
        v48 = 1024;
        *(_DWORD *)v49 = 9;
        *(_WORD *)&v49[4] = 1024;
        *(_DWORD *)&v49[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v41,  "%{public}s type=%u length=%u but value is NULL, no backtrace",  buf,  0x18u);
      }

      goto LABEL_27;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446978;
      v47 = "nw_necp_append_tlv";
      v48 = 1024;
      *(_DWORD *)v49 = 9;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v8;
      *(_WORD *)v50 = 2082;
      *(void *)&v50[2] = v33;
      _os_log_impl( &dword_181A5C000,  v11,  v41,  "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s",  buf,  0x22u);
    }

  uint64_t v11 = *(_BYTE *)(*(void *)(v2 + 248) + 376LL);
  uint64_t v12 = v3;
  if ((v11 & 1) == 0)
  {
    uint64_t v13 = (void *)_nw_http_parsed_fields_copy_response();

    if (v13)
    {
      if (*(void *)(v2 + 416))
      {
        BOOL v14 = v13;
        _nw_http_response_set_reason_phrase();

        uint64_t v15 = *(void **)(v2 + 416);
        if (v15)
        {
          free(v15);
          *(void *)(v2 + 416) = 0LL;
        }
      }

      metadata_for_response = nw_http_create_metadata_for_response(v13);
      uint64_t v17 = *(_BYTE *)(v2 + 376);
      if ((v17 & 1) != 0)
      {
        __int16 v18 = *(void **)(v2 + 368);
        if (v18)
        {
          os_release(v18);
          uint64_t v17 = *(_BYTE *)(v2 + 376);
        }
      }

      *(void *)(v2 + 368) = metadata_for_response;
      *(_BYTE *)(v2 + 376) = v17 | 1;
      unint64_t v19 = v13;
      status_code = _nw_http_response_get_status_code();

      os_release(v19);
      nw_http_metadata_set_version(*(void **)(v2 + 368), 3);
      goto LABEL_43;
    }

    if ((*(_BYTE *)(v1 + 158) & 1) != 0) {
      return 0xFFFFFFFFLL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v30 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    v31 = *(void *)(v1 + 488);
    __int16 v32 = *(_DWORD *)(*(void *)(v1 + 480) + 372LL);
    v33 = *(_DWORD *)(v1 + 860);
    if (v31) {
      LODWORD(v31) = *(_DWORD *)(v31 + 424);
    }
    *(_DWORD *)buf = 136447490;
    v55 = "nw_http1_on_headers_complete";
    v56 = 2082;
    v57 = (char *)(v1 + 74);
    v58 = 2080;
    v59 = " ";
    v60 = 1024;
    v61 = v32;
    v62 = 1024;
    v63 = v33;
    v64 = 1024;
    v65 = v31;
    __int16 v34 = "%{public}s %{public}s%s<i%u:c%u:s%u> invalid response received";
LABEL_61:
    _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_ERROR, v34, buf, 0x32u);
    return 0xFFFFFFFFLL;
  }

  uint32_t v21 = (void *)_nw_http_parsed_fields_copy_request();

  if (!v21)
  {
    if ((*(_BYTE *)(v1 + 158) & 1) != 0) {
      return 0xFFFFFFFFLL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v30 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    unint64_t v35 = *(void *)(v1 + 488);
    uint64_t v36 = *(_DWORD *)(*(void *)(v1 + 480) + 372LL);
    v37 = *(_DWORD *)(v1 + 860);
    if (v35) {
      LODWORD(v35) = *(_DWORD *)(v35 + 424);
    }
    *(_DWORD *)buf = 136447490;
    v55 = "nw_http1_on_headers_complete";
    v56 = 2082;
    v57 = (char *)(v1 + 74);
    v58 = 2080;
    v59 = " ";
    v60 = 1024;
    v61 = v36;
    v62 = 1024;
    v63 = v37;
    v64 = 1024;
    v65 = v35;
    __int16 v34 = "%{public}s %{public}s%s<i%u:c%u:s%u> invalid request received";
    goto LABEL_61;
  }

  metadata_for_request = nw_http_create_metadata_for_request(v21);
  v23 = *(_BYTE *)(v2 + 376);
  if ((v23 & 1) != 0)
  {
    v24 = *(void **)(v2 + 368);
    if (v24)
    {
      os_release(v24);
      v23 = *(_BYTE *)(v2 + 376);
    }
  }

  *(void *)(v2 + 368) = metadata_for_request;
  *(_BYTE *)(v2 + 376) = v23 | 1;
  os_release(v21);
  nw_http_metadata_set_version(*(void **)(v2 + 368), 3);
LABEL_43:
  *(_WORD *)(v2 + 428) |= 1u;
LABEL_44:
  nw_http_transaction_metadata_set_inbound_message(*(void **)(v2 + 352), *(void **)(v2 + 368));
  if ((*(_BYTE *)(*(void *)(v2 + 248) + 376LL) & 1) != 0) {
    return 21LL;
  }
  v25 = *(void **)(v2 + 384);
  if (!v25) {
    return 21LL;
  }
  v26 = nw_http_metadata_copy_request(v25);
  v27 = 21LL;
  if (v26)
  {
    int v28 = v26;
    has_method = _nw_http_request_has_method((uint64_t)v28);

    os_release(v28);
    if (has_method) {
      return 1LL;
    }
    else {
      return 21LL;
    }
  }

  return v27;
}

  return v3;
}

  return v3;
}

LABEL_28:
      if (!v12)
      {
LABEL_30:
        uint64_t v8 = 0LL;
        goto LABEL_6;
      }

  void *v12 = 0;
LABEL_28:
  BOOL v14 = nw_endpoint_copy_port_string(v3);
  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      __int16 v20 = 136446466;
      uint32_t v21 = "nwsc_get_endpoint_identifier";
      uint64_t v22 = 2112;
      v23 = v3;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s Could not get port string from endpoint %@",  (uint8_t *)&v20,  0x16u);
    }

      if (v11 - v10 < 12 || v14 < 0x10) {
        break;
      }
      uint64_t v8 = v14;
      do
      {
        unint64_t v19 = &hdecs[4 * (unsigned __int16)(v6 >> (v8 - 16))];
        __int16 v20 = *v19;
        uint32_t v21 = *(_WORD *)(v19 + 1);
        LOBYTE(v19) = v19[3];
        *(_WORD *)os_log_type_t v10 = v21;
        v10[2] = (char)v19;
        v10 += v20 & 3;
        v8 -= v20 >> 2;
        if (v20) {
          uint64_t v22 = v8 > 0xF;
        }
        else {
          uint64_t v22 = 0;
        }
      }

      while (v22);
      a1 = v13;
      if (v8 >= 0x10) {
        goto LABEL_60;
      }
    }

    uint64_t v8 = v14;
    a1 = v13;
  }

  while (v14 < 0x10);
  while (1)
  {
    v23 = &hdecs[4 * (unsigned __int16)(v6 >> (v14 - 16))];
    v24 = *v23;
    v25 = v24 & 3;
    v26 = &v10[v24 & 3];
    if ((v24 & 3) == 0 || v26 > v11) {
      break;
    }
    int v28 = v23[1];
    unint64_t v29 = v23[2];
    if (v25 == 2)
    {
      const char *v10 = v28;
      v10[1] = v29;
      v10 += 2;
    }

    else if (v25 == 3)
    {
      unint64_t v30 = v23[3];
      const char *v10 = v28;
      v10[1] = v29;
      v10[2] = v30;
      v10 += 3;
    }

    else
    {
      *v10++ = v28;
    }

    v14 -= v24 >> 2;
    if (v14 <= 0xF)
    {
      uint64_t v8 = v14;
      a1 = v13;
      goto LABEL_4;
    }
  }

  uint64_t v8 = v14;
  if (v26 <= v11)
  {
LABEL_60:
    uint64_t v36 = v8 & 7;
    if ((v8 & 7) != 0 && v10 > a3)
    {
      v37 = v10 - 1;
      do
      {
        uint64_t v22 = v37 > a3;
        v38 = *v37--;
        v8 += encode_table[2 * v38 + 1];
        uint64_t v36 = v8 & 7;
      }

      while (v22 && (v8 & 7) != 0);
      os_log_type_t v10 = v37 + 1;
    }

    if (v36) {
      __assert_rtn("huff_decode_fast", "lsqpack.c", 5398, "(avail_bits & 7) == 0");
    }
    v39 = (_DWORD)v11 - (_DWORD)v10;
    v40 = lsqpack_huff_decode_full( &v13[-(v8 >> 3)],  v9 - ((_DWORD)v13 - (v8 >> 3)),  v10,  ((_DWORD)v11 - (_DWORD)v10),  (uint64_t)a5,  1);
    v41 = v7 - v39;
    if ((v40 & 0xFFFFFFFD) != 0) {
      v41 = 0;
    }
    __int16 v34 = (v41 + HIDWORD(v40));
    unint64_t v35 = v40;
  }

  else
  {
LABEL_51:
    __int16 v32 = v8 & 7;
    if ((v8 & 7) != 0 && v10 > a3)
    {
      --v10;
      do
      {
        uint64_t v22 = v10 > a3;
        v33 = *v10--;
        v8 += encode_table[2 * v33 + 1];
        __int16 v32 = v8 & 7;
      }

      while (v22 && (v8 & 7) != 0);
      LODWORD(v10) = (_DWORD)v10 + 1;
    }

    if (v32) {
      __assert_rtn("huff_decode_fast", "lsqpack.c", 5386, "(avail_bits & 7) == 0");
    }
    __int16 v34 = ((_DWORD)v10 - (_DWORD)v11 + v7);
    unint64_t v35 = 2LL;
  }

  return v35 | (v34 << 32);
}

    return 0LL;
  }

  os_log_type_t v9 = *((void *)v4 + 31);
  if (!v9)
  {
    __nwlog_obj();
    v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v52 = "strict_strndup";
    v41 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v41);
    if (result) {
      goto LABEL_85;
    }
    free(v41);
  }

  os_log_type_t v10 = strndup((const char *)(v9 + v8.location), v8.length);
  if (!v10)
  {
    __nwlog_obj();
    v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v52 = "strict_strndup";
    v43 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v43);
    if (result) {
      goto LABEL_85;
    }
    free(v43);
    *((void *)v4 + 32) = 0LL;

    return 0LL;
  }

  *((void *)v4 + 32) = v10;
  uint64_t v11 = CFURLGetByteRangeForComponent((CFURLRef)*((void *)v4 + 29), kCFURLComponentHost, 0LL);
  if (v11.location == -1) {
    length = 0LL;
  }
  else {
    length = v11.length;
  }
  if (v11.location == -1) {
    location = 0LL;
  }
  else {
    location = v11.location;
  }
  BOOL v14 = *((void *)v4 + 31);
  uint64_t v15 = (const char *)(v14 + location);
  if (length <= 1)
  {
    if (!v14)
    {
      __nwlog_obj();
      __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v52 = "strict_strndup";
      uint32_t v21 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v21);
      if (result) {
        goto LABEL_85;
      }
      free(v21);
    }
  }

  else
  {
    if (*v15 == 91)
    {
      char v16 = *(unsigned __int8 *)(length + location + v14 - 1);
      if (v16 == 93) {
        length -= 2LL;
      }
      else {
        length = v11.length;
      }
      if (v16 == 93) {
        ++location;
      }
    }

    else
    {
      length = v11.length;
    }

    uint64_t v15 = (const char *)(v14 + location);
  }

  v23 = strndup(v15, length);
  if (v23)
  {
    *((void *)v4 + 33) = v23;
    *((_BYTE *)v4 + 297) &= ~1u;
    v24 = CFURLGetPortNumber(*((CFURLRef *)v4 + 29));
    if (v24 == -1)
    {
      v25 = (const char *)*((void *)v4 + 32);
      if (v25)
      {
        else {
          *((_WORD *)v4 + 120) = 0;
        }
      }
    }

    else
    {
      *((_WORD *)v4 + 120) = bswap32(v24) >> 16;
    }

    return (BOOL)v4;
  }

  __nwlog_obj();
  v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v52 = "strict_strndup";
  v45 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v45);
  if (!result)
  {
    free(v45);
    *((void *)v4 + 33) = 0LL;

    return 0LL;
  }

  if (v11) {
    CFRelease(v11);
  }
}

        free(v8);
        goto LABEL_28;
      }

      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
        _os_log_impl( &dword_181A5C000,  v25,  v33,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v36 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
        _os_log_impl( &dword_181A5C000,  v25,  v36,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), backtrace limit exceeded",  buf,  0xCu);
      }
    }

  if (v10) {
    free(v10);
  }
LABEL_10:
}

        if ((_UNKNOWN *)a1[5] == &nw_protocol_ref_counted_handle)
        {
          v45 = a1[11];
          if (v45)
          {
            v46 = v45 - 1;
            a1[11] = v46;
            if (!v46)
            {
              v47 = (void (**)(void))a1[8];
              if (v47)
              {
                a1[8] = 0LL;
                v47[2](v47);
                _Block_release(v47);
              }

              if ((a1[9] & 1) != 0)
              {
                v48 = (const void *)a1[8];
                if (v48) {
                  _Block_release(v48);
                }
              }

              free(a1);
            }
          }
        }

        goto LABEL_28;
      }
    }

    __nwlog_obj();
    v57 = *(const char **)(v18 + 16);
    *(_DWORD *)buf = 136446722;
    v71 = "__nw_protocol_remove_input_handler";
    if (!v57) {
      v57 = "invalid";
    }
    v72 = 2082;
    v73 = (void *)v57;
    v74 = 2048;
    v75 = (void *)v18;
    v58 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (__nwlog_fault(v58, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v59 = (os_log_s *)__nwlog_obj();
        v60 = type;
        if (!os_log_type_enabled(v59, type)) {
          goto LABEL_137;
        }
        v61 = *(const char **)(v18 + 16);
        if (!v61) {
          v61 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v71 = "__nw_protocol_remove_input_handler";
        v72 = 2082;
        v73 = (void *)v61;
        v74 = 2048;
        v75 = (void *)v18;
        v62 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback";
LABEL_136:
        _os_log_impl(&dword_181A5C000, v59, v60, v62, buf, 0x20u);
        goto LABEL_137;
      }

      if (!v68)
      {
        v59 = (os_log_s *)__nwlog_obj();
        v60 = type;
        if (!os_log_type_enabled(v59, type)) {
          goto LABEL_137;
        }
        v66 = *(const char **)(v18 + 16);
        if (!v66) {
          v66 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v71 = "__nw_protocol_remove_input_handler";
        v72 = 2082;
        v73 = (void *)v66;
        v74 = 2048;
        v75 = (void *)v18;
        v62 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_136;
      }

      v63 = (char *)__nw_create_backtrace_string();
      v59 = (os_log_s *)__nwlog_obj();
      v60 = type;
      v64 = os_log_type_enabled(v59, type);
      if (!v63)
      {
        if (!v64) {
          goto LABEL_137;
        }
        v67 = *(const char **)(v18 + 16);
        if (!v67) {
          v67 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v71 = "__nw_protocol_remove_input_handler";
        v72 = 2082;
        v73 = (void *)v67;
        v74 = 2048;
        v75 = (void *)v18;
        v62 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace";
        goto LABEL_136;
      }

      if (v64)
      {
        v65 = *(const char **)(v18 + 16);
        if (!v65) {
          v65 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        v71 = "__nw_protocol_remove_input_handler";
        v72 = 2082;
        v73 = (void *)v65;
        v74 = 2048;
        v75 = (void *)v18;
        v76 = 2082;
        v77 = v63;
        _os_log_impl( &dword_181A5C000,  v59,  v60,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v63);
    }

  uint64_t v15 = (void *)*((void *)self + 22);
  if (v15)
  {
    free(v15);
    *((void *)self + 22) = 0LL;
  }

  char v16 = (void *)*((void *)self + 23);
  if (v16)
  {
    free(v16);
    *((void *)self + 23) = 0LL;
  }

  v37.receiver = self;
  v37.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_browser;
  -[NWConcrete_nw_browser dealloc](&v37, sel_dealloc, v35, v36);
}

  if (v13) {
    free(v13);
  }
  os_log_type_t v10 = 0LL;
LABEL_10:

  return v10;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }

  if ((v1[35] & 8) != 0)
  {
    uint64_t v4 = v1[31];
    goto LABEL_10;
  }

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  uint64_t v3 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    uint64_t v17 = v2;
    _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}@ not complete, returning 0 for underlying error domain",  buf,  0xCu);
  }

LABEL_8:
  uint64_t v4 = 0LL;
LABEL_10:

  return v4;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }

  if ((v1[35] & 8) != 0)
  {
    uint64_t v4 = v1[32];
    goto LABEL_10;
  }

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  uint64_t v3 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    uint64_t v17 = v2;
    _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}@ not complete, returning 0 for underlying error code",  buf,  0xCu);
  }

LABEL_8:
  uint64_t v4 = 0LL;
LABEL_10:

  return v4;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }

  if ((v1[35] & 8) != 0)
  {
    uint64_t v4 = v1[34];
    goto LABEL_10;
  }

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  uint64_t v3 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    uint64_t v17 = v2;
    _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}@ not complete, returning nw_activity_completion_reason_invalid",  buf,  0xCu);
  }

LABEL_8:
  uint64_t v4 = 0LL;
LABEL_10:

  return v4;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_8;
  }

  if ((v1[140] & 8) != 0)
  {
    uint64_t v4 = *((void *)v1 + 9);
    goto LABEL_10;
  }

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  uint64_t v3 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    uint64_t v17 = v2;
    _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}@ not complete, returning NULL for underlying error domain string",  buf,  0xCu);
  }

LABEL_8:
  uint64_t v4 = 0LL;
LABEL_10:

  return v4;
}

      free(v11);
      goto LABEL_28;
    }

    *(_BYTE *)uint64_t v7 = -34;
    *(_DWORD *)(v7 + 1) = length;
    if (!length) {
      goto LABEL_13;
    }
    if (bytes_ptr)
    {
      memcpy((void *)(v7 + 5), bytes_ptr, length);
LABEL_13:
      BOOL v14 = v7 + v9;
      goto LABEL_29;
    }

    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v55 = "nw_necp_append_tlv";
    v56 = 1024;
    *(_DWORD *)v57 = 222;
    *(_WORD *)&v57[4] = 1024;
    *(_DWORD *)&v57[6] = length;
    v42 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_necp_append_tlv";
        v56 = 1024;
        *(_DWORD *)v57 = 222;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = length;
        _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
      }
    }

    else if (v52)
    {
      v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v49 = type;
      v50 = os_log_type_enabled(v43, type);
      if (v48)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446978;
          v55 = "nw_necp_append_tlv";
          v56 = 1024;
          *(_DWORD *)v57 = 222;
          *(_WORD *)&v57[4] = 1024;
          *(_DWORD *)&v57[6] = length;
          *(_WORD *)v58 = 2082;
          *(void *)&v58[2] = v48;
          _os_log_impl( &dword_181A5C000,  v43,  v49,  "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v48);
        goto LABEL_101;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_necp_append_tlv";
        v56 = 1024;
        *(_DWORD *)v57 = 222;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = length;
        _os_log_impl( &dword_181A5C000,  v43,  v49,  "%{public}s type=%u length=%u but value is NULL, no backtrace",  buf,  0x18u);
      }
    }

    else
    {
      __nwlog_obj();
      v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_necp_append_tlv";
        v56 = 1024;
        *(_DWORD *)v57 = 222;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = length;
        _os_log_impl( &dword_181A5C000,  v43,  v51,  "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded",  buf,  0x18u);
      }
    }

LABEL_101:
    if (v42) {
      free(v42);
    }
    BOOL v14 = 0LL;
    goto LABEL_29;
  }

  __nwlog_obj();
  int v28 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136447234;
  v55 = "nw_necp_append_tlv";
  v56 = 2048;
  *(void *)v57 = v7;
  *(_WORD *)&v57[8] = 2048;
  *(void *)v58 = v8;
  *(_WORD *)&v58[8] = 1024;
  *(_DWORD *)v59 = 222;
  *(_WORD *)&v59[4] = 1024;
  *(_DWORD *)&v59[6] = length;
  unint64_t v29 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v52 = 0;
  if (__nwlog_fault(v29, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136447234;
        v55 = "nw_necp_append_tlv";
        v56 = 2048;
        *(void *)v57 = v7;
        *(_WORD *)&v57[8] = 2048;
        *(void *)v58 = v8;
        *(_WORD *)&v58[8] = 1024;
        *(_DWORD *)v59 = 222;
        *(_WORD *)&v59[4] = 1024;
        *(_DWORD *)&v59[6] = length;
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  buf,  0x2Cu);
      }
    }

    else if (v52)
    {
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v30, type);
      if (v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136447490;
          v55 = "nw_necp_append_tlv";
          v56 = 2048;
          *(void *)v57 = v7;
          *(_WORD *)&v57[8] = 2048;
          *(void *)v58 = v8;
          *(_WORD *)&v58[8] = 1024;
          *(_DWORD *)v59 = 222;
          *(_WORD *)&v59[4] = 1024;
          *(_DWORD *)&v59[6] = length;
          *(_WORD *)v60 = 2082;
          *(void *)&v60[2] = v38;
          _os_log_impl( &dword_181A5C000,  v30,  v39,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
        }

        free(v38);
        goto LABEL_92;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136447234;
        v55 = "nw_necp_append_tlv";
        v56 = 2048;
        *(void *)v57 = v7;
        *(_WORD *)&v57[8] = 2048;
        *(void *)v58 = v8;
        *(_WORD *)&v58[8] = 1024;
        *(_DWORD *)v59 = 222;
        *(_WORD *)&v59[4] = 1024;
        *(_DWORD *)&v59[6] = length;
        _os_log_impl( &dword_181A5C000,  v30,  v39,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  buf,  0x2Cu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136447234;
        v55 = "nw_necp_append_tlv";
        v56 = 2048;
        *(void *)v57 = v7;
        *(_WORD *)&v57[8] = 2048;
        *(void *)v58 = v8;
        *(_WORD *)&v58[8] = 1024;
        *(_DWORD *)v59 = 222;
        *(_WORD *)&v59[4] = 1024;
        *(_DWORD *)&v59[6] = length;
        _os_log_impl( &dword_181A5C000,  v30,  v47,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  buf,  0x2Cu);
      }
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

  *(_DWORD *)(v5 + 452) += v6;
LABEL_28:
  v23 = *(void *)(a2 + 32);
  v24 = *(void **)(a2 + 40);
  if (v23)
  {
    *(void *)(v23 + 40) = v24;
    v24 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL) = v24;
  }

  os_log_s *v24 = v23;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  v25 = 1LL;
  nw_frame_finalize(a2);
  return v25;
}

    if (!v3) {
      return;
    }
    goto LABEL_28;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v33 = "nw_http3_decoder_stream_finalize_output_frames";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v30 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_27;
    }
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http3_decoder_stream_finalize_output_frames";
    uint64_t v6 = "%{public}s called with null http3";
    goto LABEL_25;
  }

  if (!v30)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_27;
    }
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http3_decoder_stream_finalize_output_frames";
    uint64_t v6 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_25;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  uint32_t v21 = os_log_type_enabled(v4, type);
  if (!backtrace_string)
  {
    if (!v21) {
      goto LABEL_27;
    }
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http3_decoder_stream_finalize_output_frames";
    uint64_t v6 = "%{public}s called with null http3, no backtrace";
LABEL_25:
    uint64_t v17 = v4;
    __int16 v18 = v5;
    unint64_t v19 = 12;
LABEL_26:
    _os_log_impl(&dword_181A5C000, v17, v18, v6, buf, v19);
    goto LABEL_27;
  }

  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v33 = "nw_http3_decoder_stream_finalize_output_frames";
    __int16 v34 = 2082;
    unint64_t v35 = backtrace_string;
    uint64_t v11 = "%{public}s called with null http3, dumping backtrace:%{public}s";
    goto LABEL_13;
  }

    free(backtrace_string);
    goto LABEL_37;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_http3_get_parameters";
    uint64_t v7 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_37;
  }

  os_log_type_t v9 = (os_log_s *)__nwlog_obj();
  os_log_type_t v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    unint64_t v19 = "nw_protocol_http3_stream_register_notification";
    uint64_t v11 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_37;
  }

  uint64_t v12 = (os_log_s *)__nwlog_obj();
  uint64_t v13 = type;
  if (os_log_type_enabled(v12, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_http3_stream_unregister_notification";
    BOOL v14 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
  }

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  dispatch_time_t v2 = cchpke_params_sizeof_aead_key();
  uint64_t v3 = cchpke_params_sizeof_aead_nonce();
  if (v2 <= v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if (!v4)
  {
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "strict_calloc";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v12);
    if (result) {
      goto LABEL_30;
    }
    free(v12);
  }

  uint64_t v5 = calloc(1uLL, v4);
  if (v5)
  {
LABEL_7:
    arc4random_buf(v5, v4);
    *a1 = v4;
    return (BOOL)v5;
  }

  uint64_t v13 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v20 = "strict_calloc";
  uint32_t v21 = 2048;
  uint64_t v22 = 1LL;
  v23 = 2048;
  v24 = v4;
  BOOL v14 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_7;
  }

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_10:

  return v7;
}

    if (!v9)
    {
LABEL_29:
      uint64_t v6 = 0LL;
      goto LABEL_30;
    }

  return v6;
}

  return v4;
}

  return v6;
}

  return v4;
}

      free(backtrace_string);
    }
  }

      goto LABEL_28;
    }

    if (!v36)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (os_log_s *)(id)gLogObj;
      unint64_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_path_flow_registration_set_tfo_cache";
        v42 = 1024;
        *(_DWORD *)v43 = v10;
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s necp update cache failed for tfo %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
      }

      goto LABEL_27;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = (os_log_s *)(id)gLogObj;
    uint64_t v17 = type;
    __int16 v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_path_flow_registration_set_tfo_cache";
        v42 = 1024;
        *(_DWORD *)v43 = v10;
        _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s necp update cache failed for tfo %{darwin.errno}d, no backtrace",  buf,  0x12u);
      }

      goto LABEL_27;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446722;
      v41 = "nw_path_flow_registration_set_tfo_cache";
      v42 = 1024;
      *(_DWORD *)v43 = v10;
      v43[2] = 2082;
      *(void *)&v43[3] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s necp update cache failed for tfo %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

LABEL_20:
    free(backtrace_string);
    if (!v13) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }

  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v41 = "nw_path_flow_registration_set_tfo_cache";
    v42 = 1024;
    *(_DWORD *)v43 = 2;
    _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s necp update cache failed for tfo %{darwin.errno}d",  buf,  0x12u);
  }

LABEL_30:
}

  if (v9) {
    free(v9);
  }
  uint64_t v4 = 0LL;
LABEL_10:

  return v4;
}

  if (v10) {
    free(v10);
  }
  uint64_t v4 = 0LL;
LABEL_10:

  return v4;
}

    goto LABEL_28;
  }

  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v57 = "nw_path_report_error_to_agent";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v54 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }

    else if (v54)
    {
      __int16 v18 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      unint64_t v19 = type[0];
      __int16 v20 = os_log_type_enabled(v8, type[0]);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v57 = "nw_path_report_error_to_agent";
          v58 = 2082;
          *(void *)v59 = v18;
          _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null agent_uuid, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v18);
        if (!v7) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_181A5C000, v8, v19, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      uint32_t v21 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v57 = "nw_path_report_error_to_agent";
        _os_log_impl( &dword_181A5C000,  v8,  v21,  "%{public}s called with null agent_uuid, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_27;
  }

  os_log_type_t v10 = nw_parameters_copy_context(v5[2]);
  uint64_t v11 = nw_path_shared_necp_fd(v10);

  if (v11 < 0) {
    goto LABEL_30;
  }
  *(_OWORD *)os_log_type_t type = *(_OWORD *)a2;
  uint64_t v12 = (char *)calloc(1uLL, 0x19uLL);
  uint64_t v13 = v12;
  if (v12)
  {
    void *v12 = -121;
    *(_DWORD *)(v12 + 1) = 20;
    *(_OWORD *)(v12 + 5) = *(_OWORD *)type;
    *(_DWORD *)(v12 + 21) = a3;
    BOOL v14 = necp_client_action();
    uint64_t v15 = v14 == 0;
    if (!v14)
    {
LABEL_49:
      free(v13);
      goto LABEL_50;
    }

    char v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v16 == 45 || v16 == 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v57 = "nw_path_report_error_to_agent";
        v58 = 1024;
        *(_DWORD *)v59 = v16;
        _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d",  buf,  0x12u);
      }

      goto LABEL_49;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v57 = "nw_path_report_error_to_agent";
    v58 = 1024;
    *(_DWORD *)v59 = v16;
    v23 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v54 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v23, type, &v54))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v57 = "nw_path_report_error_to_agent";
          v58 = 1024;
          *(_DWORD *)v59 = v16;
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
        }
      }

      else if (v54)
      {
        v26 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v27 = type[0];
        int v28 = os_log_type_enabled(v24, type[0]);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446722;
            v57 = "nw_path_report_error_to_agent";
            v58 = 1024;
            *(_DWORD *)v59 = v16;
            *(_WORD *)&v59[4] = 2082;
            *(void *)&v59[6] = v26;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v26);
          goto LABEL_47;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v57 = "nw_path_report_error_to_agent";
          v58 = 1024;
          *(_DWORD *)v59 = v16;
          _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v29 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v57 = "nw_path_report_error_to_agent";
          v58 = 1024;
          *(_DWORD *)v59 = v16;
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    goto LABEL_28;
  }

  __nwlog_obj();
  v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v66 = "strict_malloc";
  v67 = 2048;
  v68 = v3;
  int v28 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    v48 = 0LL;
    v49 = &v48;
    v50 = 0x2020000000LL;
    v51 = 0LL;
    __nwlog_obj();
    unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_necp_append_tlv";
    unint64_t v30 = (char *)_os_log_send_and_compose_impl();

    v64 = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (__nwlog_fault(v30, &v64, &v63))
    {
      if (v64 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v32 = v64;
        if (os_log_type_enabled(v31, v64))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }

      else if (v63)
      {
        v38 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v39 = v64;
        v40 = os_log_type_enabled(v31, v64);
        if (v38)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446466;
            v66 = "nw_necp_append_tlv";
            v67 = 2082;
            v68 = (size_t)v38;
            _os_log_impl( &dword_181A5C000,  v31,  v39,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v38);
          goto LABEL_85;
        }

        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v31, v39, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v45 = v64;
        if (os_log_type_enabled(v31, v64))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_necp_append_tlv";
          _os_log_impl( &dword_181A5C000,  v31,  v45,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v7) {
    free(v7);
  }
  return 0LL;
}
  }

      if (v10) {
        free(v10);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)gLogObj;
    uint64_t v12 = type;
    uint64_t v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_string_create_with_string";
        uint64_t v13 = "%{public}s called with null self, no backtrace";
        goto LABEL_26;
      }

      goto LABEL_27;
    }

    if (!v15)
    {
LABEL_19:
      free(backtrace_string);
      goto LABEL_27;
    }

    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_string_create_with_string";
    v23 = 2082;
    v24 = backtrace_string;
    char v16 = "%{public}s called with null self, dumping backtrace:%{public}s";
LABEL_18:
    _os_log_impl(&dword_181A5C000, v11, v12, v16, buf, 0x16u);
    goto LABEL_19;
  }

  __break(1u);
  return result;
}

      if (v10) {
        free(v10);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)gLogObj;
    uint64_t v12 = type;
    uint64_t v15 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_string_copy";
        uint64_t v13 = "%{public}s called with null self, no backtrace";
        goto LABEL_26;
      }

      goto LABEL_27;
    }

    if (!v15)
    {
LABEL_19:
      free(backtrace_string);
      goto LABEL_27;
    }

    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_string_copy";
    v23 = 2082;
    v24 = backtrace_string;
    char v16 = "%{public}s called with null self, dumping backtrace:%{public}s";
LABEL_18:
    _os_log_impl(&dword_181A5C000, v11, v12, v16, buf, 0x16u);
    goto LABEL_19;
  }

  __break(1u);
  return result;
}

    if (v9) {
      free(v9);
    }
    uint64_t v6 = 0LL;
    goto LABEL_5;
  }

  [v1 redactedDescription];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = [v3 length];
  uint64_t v5 = v4 + 1;
  if (v4 == -1)
  {
    __nwlog_obj();
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v27 = "nw_application_id_copy_redacted_description";
    uint64_t v13 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v13);
    if (result) {
      goto LABEL_30;
    }
    free(v13);
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v27 = "strict_calloc";
    LODWORD(v23) = 12;
    uint64_t v22 = buf;
    uint64_t v15 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v15);
    if (result) {
      goto LABEL_30;
    }
    free(v15);
  }

  uint64_t v6 = calloc(1uLL, v5);
  if (v6)
  {
LABEL_4:
    objc_msgSend(v3, "getCString:maxLength:encoding:", v6, v5, 4, v22, v23);

LABEL_5:
    return (BOOL)v6;
  }

  __nwlog_obj();
  char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v27 = "strict_calloc";
  int v28 = 2048;
  unint64_t v29 = 1LL;
  unint64_t v30 = 2048;
  v31 = v5;
  LODWORD(v23) = 32;
  uint64_t v22 = buf;
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_4;
  }

LABEL_28:
    if (v20) {
      free(v20);
    }
    goto LABEL_30;
  }

  uint64_t v11 = v10;
  for (i = 0LL; i != v9; ++i)
  {
    [v6 objectAtIndexedSubscript:i];
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v15 = v14;
    if (v14) {
      BOOL v14 = (void *)[v14 _createDispatchData];
    }
    uint64_t v13 = (void *)v11[i];
    v11[i] = v14;
  }

  -[NWConnection internalConnection](self, "internalConnection");
  char v16 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v17 = v16;
  if (v7 == &__block_literal_global_14103)
  {
    __int16 v18 = nw_connection_write_multiple(v16, (uint64_t)v11, v9, &__block_literal_global_41);
  }

  else
  {
    v32[0] = MEMORY[0x1895F87A8];
    v32[1] = 3221225472LL;
    v32[2] = __57__NWDatagramConnection_writeDatagrams_completionHandler___block_invoke;
    v32[3] = &unk_189BC6E10;
    v33 = v7;
    __int16 v18 = nw_connection_write_multiple(v17, (uint64_t)v11, v9, v32);
  }

  v24 = 0LL;
  if (v9 <= 1) {
    os_log_type_t v9 = 1LL;
  }
  do
  {
    v25 = (void *)v11[v24];
    v11[v24] = 0LL;

    ++v24;
  }

  while (v9 != v24);
  free(v11);
LABEL_31:

  return v18;
}

      free(backtrace_string);
    }
  }

  if (v8) {
    free(v8);
  }
}

  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0LL;
LABEL_9:

  return v4;
}

  if (v5) {
    free(v5);
  }
  return 0xFFFFFFFFLL;
}

  if (v5) {
    free(v5);
  }
  return 0xFFFFFFFFLL;
}

    free(backtrace_string);
    goto LABEL_37;
  }

  os_log_type_t v10 = (os_log_s *)__nwlog_obj();
  uint64_t v11 = type;
  if (os_log_type_enabled(v10, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_protocol_test_remove_input_handler";
    uint64_t v12 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
  }

      free(backtrace_string);
      if (!v9) {
        goto LABEL_54;
      }
      goto LABEL_53;
    }

    if (dispatch_data_get_size(v6) >= 0x401)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v44 = "nw_browse_descriptor_create_custom";
      v45 = 1024;
      *(_DWORD *)v46 = 1024;
      os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v41 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1024;
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
        }

        goto LABEL_51;
      }

      if (!v41)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        unint64_t v29 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1024;
          _os_log_impl( &dword_181A5C000,  v10,  v29,  "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded",  buf,  0x12u);
        }

        goto LABEL_51;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v22 = type;
      v23 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1024;
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s Custom data size must be no larger than %d, no backtrace",  buf,  0x12u);
        }

        goto LABEL_51;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446722;
        v44 = "nw_browse_descriptor_create_custom";
        v45 = 1024;
        *(_DWORD *)v46 = 1024;
        v46[2] = 2082;
        *(void *)&v46[3] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      goto LABEL_27;
    }

    BOOL v14 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_browse_descriptor);
    uint64_t v15 = v14;
    if (v14)
    {
      *((_DWORD *)v14 + 2) = a1;
      objc_storeStrong((id *)v14 + 7, a2);
      if (v7)
      {
        char v16 = _Block_copy(v7);
        uint64_t v17 = (void *)*((void *)v15 + 8);
        *((void *)v15 + 8) = v16;
      }

      __int16 v18 = v15;
      goto LABEL_63;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v44 = "nw_browse_descriptor_create_custom";
    v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (__nwlog_fault(v25, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = (os_log_s *)(id)gLogObj;
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "nw_browse_descriptor_create_custom";
          _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s [nw_browse_descriptor init] failed", buf, 0xCu);
        }
      }

      else if (v41)
      {
        unint64_t v30 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type;
        __int16 v32 = os_log_type_enabled(v26, type);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v44 = "nw_browse_descriptor_create_custom";
            v45 = 2082;
            *(void *)v46 = v30;
            _os_log_impl( &dword_181A5C000,  v26,  v31,  "%{public}s [nw_browse_descriptor init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v30);
          if (!v25) {
            goto LABEL_63;
          }
          goto LABEL_62;
        }

        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v44 = "nw_browse_descriptor_create_custom";
          _os_log_impl( &dword_181A5C000,  v26,  v31,  "%{public}s [nw_browse_descriptor init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "nw_browse_descriptor_create_custom";
          _os_log_impl( &dword_181A5C000,  v26,  v33,  "%{public}s [nw_browse_descriptor init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v25)
    {
LABEL_63:

      goto LABEL_64;
    }

        goto LABEL_28;
      }

      if (!v45)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v20 = (os_log_s *)(id)gconnectionLogObj;
        v39 = type;
        if (os_log_type_enabled(v20, type))
        {
          v40 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
          *(_DWORD *)buf = 136446466;
          v48 = "nw_association_schedule_deactivation_block_invoke";
          v49 = 2082;
          v50 = v40;
          _os_log_impl( &dword_181A5C000,  v20,  v39,  "%{public}s <nw_association %{public}s> dormant, but connected flow handles is non-empty, backtrace limit exceeded",  buf,  0x16u);
        }

        goto LABEL_27;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v20 = (os_log_s *)(id)gconnectionLogObj;
      __int16 v32 = type;
      v33 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          v43 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
          *(_DWORD *)buf = 136446466;
          v48 = "nw_association_schedule_deactivation_block_invoke";
          v49 = 2082;
          v50 = v43;
          _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s <nw_association %{public}s> dormant, but connected flow handles is non-empty, no backtrace",  buf,  0x16u);
        }

        goto LABEL_27;
      }

      if (v33)
      {
        __int16 v34 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
        *(_DWORD *)buf = 136446722;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v34;
        v51 = 2082;
        v52 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s <nw_association %{public}s> dormant, but connected flow handles is non-empty, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      if (v19) {
LABEL_29:
      }
        free(v19);
    }

    else
    {
      _nw_hash_table_release(v16, v15);
      *(void *)(*(void *)(a1 + 40) + 48LL) = 0LL;
    }
  }

            v73[0] = MEMORY[0x1895F87A8];
            v73[1] = 0x40000000LL;
            v74 = (uint64_t (*)(void *))___ZL34nw_protocol_ipv6_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v75 = &__block_descriptor_tmp_45_85710;
            p_output_handler = &a1[1].output_handler;
            v77 = a1;
            tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              v23 = (nw_frame *)*((void *)tqh_first + 4);
              v24 = v74(v73);
              tqh_first = v23;
            }

            while ((v24 & 1) != 0);
            return v21;
          }

            if ((a3[17] & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v24 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_protocol_ipv4_frame_output_finalizer";
                v116 = 2082;
                v117 = (char *)a3 + 137;
                v118 = 2080;
                v119 = " ";
                v120 = 2048;
                v121 = (char *)a3;
                v122 = 1024;
                v123 = v111;
                _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p Not enough bytes to fragment %u",  buf,  0x30u);
              }
            }

            v103[0] = MEMORY[0x1895F87A8];
            v103[1] = 0x40000000LL;
            v104 = ___ZL39nw_protocol_ipv4_frame_output_finalizerP8nw_framebPv_block_invoke;
            v105 = &__block_descriptor_tmp_29_86146;
            v106 = v107;
            v25 = v107[0];
            do
            {
              if (!v25) {
                break;
              }
              v26 = *(void *)(v25 + 32);
              v27 = ((uint64_t (*)(void *))v104)(v103);
              v25 = v26;
            }

            while ((v27 & 1) != 0);
            goto LABEL_48;
          }

    if (v3) {
      free(v3);
    }
    return 0LL;
  }

  if (*(void *)(a1 + 136))
  {
    if (((*(unsigned __int16 *)(a1 + 444) | (*(unsigned __int8 *)(a1 + 446) << 16)) & 0x80000) == 0)
    {
      result = os_channel_is_defunct();
      if (!(_DWORD)result) {
        return result;
      }
      nw_channel_handle_defunct(a1);
    }
  }

  else
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
    }
    if (_nw_signposts_enabled)
    {
    }
  }

  return 1LL;
}

void __nw_mem_region_init_block_invoke()
{
  uint64_t v0 = nw_mem_region_head;
  if (nw_mem_region_head)
  {
    uint64_t v1 = MEMORY[0x1895F87A8];
    do
    {
      while (1)
      {
        block[0] = v1;
        block[1] = 0x40000000LL;
        block[2] = ___ZL20nw_mem_region_updateP13nw_mem_region_block_invoke;
        block[3] = &__block_descriptor_tmp_27_22957;
        block[4] = v0;
        if (*(void *)(v0 + 272))
        {
        }

        ___ZL20nw_mem_region_updateP13nw_mem_region_block_invoke((uint64_t)block);
        uint64_t v0 = *(void *)(v0 + 144);
        if (!v0) {
          goto LABEL_7;
        }
      }

      dispatch_async(*(dispatch_queue_t *)(v0 + 272), block);
      uint64_t v0 = *(void *)(v0 + 144);
    }

    while (v0);
  }

LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_region_lock);
  uint64_t v2 = nw_mem_region_update_source;
  if (nw_mem_region_update_source)
  {
    dispatch_time_t v3 = dispatch_time(0x8000000000000000LL, 13000000000LL);
    if (*(void *)v2)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }

    else
    {
      *(void *)(v2 + 32) = v3;
      *(void *)(v2 + 40) = -1LL;
      if (*(_BYTE *)(v2 + 48))
      {
        if (*(_BYTE *)(v2 + 49)) {
          nw_queue_source_run_timer(v2, v3);
        }
      }
    }

    nw_queue_activate_source(nw_mem_region_update_source, v3);
  }

LABEL_8:
    if (!v6) {
      goto LABEL_10;
    }
LABEL_9:
    free(v6);
    goto LABEL_10;
  }

  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    uint64_t v13 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_path_copy_without_parameters";
      _os_log_impl(&dword_181A5C000, v7, v13, "%{public}s [path copy] failed, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (os_log_s *)(id)gLogObj;
  uint64_t v11 = type;
  uint64_t v12 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_path_copy_without_parameters";
      _os_log_impl(&dword_181A5C000, v7, v11, "%{public}s [path copy] failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_7;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_path_copy_without_parameters";
    __int16 v18 = 2082;
    unint64_t v19 = backtrace_string;
    _os_log_impl(&dword_181A5C000, v7, v11, "%{public}s [path copy] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v6) {
    goto LABEL_9;
  }
LABEL_10:

  return v1;
}

    uint64_t v6 = 1LL;
    goto LABEL_10;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_is_viable";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v18 = 0;
  if (__nwlog_fault(v10, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_viable";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v14 = type;
      uint64_t v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_is_viable";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_viable";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_viable";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      a2 = 0LL;
      goto LABEL_8;
    }

    os_log_type_t v10 = bswap32(*(_DWORD *)&address->sa_data[2]);
    if (HIWORD(v10) == 43518) {
      goto LABEL_7;
    }
    a2 = 0LL;
    if (v10 >> 8 != 14680064
      && *(_DWORD *)&address->sa_data[2]
      && *(_DWORD *)&address->sa_data[2] != 127)
    {
      goto LABEL_15;
    }
  }

LABEL_8:
    if (!v4) {
      goto LABEL_10;
    }
LABEL_9:
    free(v4);
    goto LABEL_10;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    uint64_t v11 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_path_flow_create";
      _os_log_impl( &dword_181A5C000,  v5,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  os_log_type_t v9 = type;
  os_log_type_t v10 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_path_flow_create";
      _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow) alloc] init] failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_path_flow_create";
    char v16 = 2082;
    uint64_t v17 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:

  return v1;
}

  os_log_type_t v9 = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  uint64_t v2 = v1;
  dispatch_time_t v3 = v2[10];
  if (v3) {
    uint64_t v4 = *(unsigned int *)(v3 + 260);
  }
  else {
    uint64_t v4 = 0LL;
  }
  uint64_t v5 = (objc_class *)objc_opt_class();
  Instance = (id *)class_createInstance(v5, v4);
  uint64_t v7 = -[NWConcrete_nw_protocol_metadata initWithDefinition:identifier:](Instance, v2, &v9);

  return v7;
}

LABEL_8:
    if (!v6) {
      goto LABEL_10;
    }
LABEL_9:
    free(v6);
    goto LABEL_10;
  }

  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    uint64_t v13 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_link_info_create";
      _os_log_impl( &dword_181A5C000,  v7,  v13,  "%{public}s [nw_link_info init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (os_log_s *)(id)gLogObj;
  uint64_t v11 = type;
  uint64_t v12 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_link_info_create";
      _os_log_impl(&dword_181A5C000, v7, v11, "%{public}s [nw_link_info init] failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_7;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_link_info_create";
    __int16 v18 = 2082;
    unint64_t v19 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v7,  v11,  "%{public}s [nw_link_info init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v6) {
    goto LABEL_9;
  }
LABEL_10:

  return v3;
}

  sub_181BCDDE0(v11, v12, a2, a3, a4, a5);
  return sub_181BCEE10(a2);
}

      os_log_type_t v10 = v101;
      os_log_type_t v9 = v102;
    }

    else if (v103 | v24)
    {
      v102 = v9;
      swift_bridgeObjectRetain_n();
      v58 = v24;
      sub_181BDA12C(v103, v24, 2);
      v59 = swift_isUniquelyReferenced_nonNull_native();
      v104 = (void *)*a2;
      v60 = v104;
      *a2 = 0x8000000000000000LL;
      v61 = v21;
      v63 = sub_181C8C01C(v21, v22);
      v64 = v60[2];
      v65 = (v62 & 1) == 0;
      v66 = v64 + v65;
      if (__OFADD__(v64, v65)) {
        goto LABEL_75;
      }
      v67 = v62;
      if (v60[3] >= v66)
      {
        if ((v59 & 1) != 0)
        {
          v70 = v104;
          if ((v62 & 1) != 0) {
            goto LABEL_59;
          }
        }

        else
        {
          sub_181C926B8();
          v70 = v104;
          if ((v67 & 1) != 0) {
            goto LABEL_59;
          }
        }
      }

      else
      {
        sub_181C8F71C(v66, v59);
        v68 = sub_181C8C01C(v61, v22);
        if ((v67 & 1) != (v69 & 1)) {
          goto LABEL_80;
        }
        v63 = v68;
        v70 = v104;
        if ((v67 & 1) != 0)
        {
LABEL_59:
          v84 = (void *)(v70[7] + 16 * v63);
          swift_bridgeObjectRelease();
          *v84 = 0LL;
          v84[1] = 0xE000000000000000LL;
          goto LABEL_70;
        }
      }

      v70[(v63 >> 6) + 8] |= 1LL << v63;
      v91 = (uint64_t *)(v70[6] + 16 * v63);
      *v91 = v61;
      v91[1] = v22;
      v92 = (void *)(v70[7] + 16 * v63);
      *v92 = 0LL;
      v92[1] = 0xE000000000000000LL;
      v93 = v70[2];
      v74 = __OFADD__(v93, 1LL);
      v94 = v93 + 1;
      if (v74) {
        goto LABEL_78;
      }
      v70[2] = v94;
      swift_bridgeObjectRetain();
LABEL_70:
      a2 = v99;
      *v99 = (uint64_t)v70;
      swift_bridgeObjectRelease_n();
      swift_bridgeObjectRelease();
      sub_181BDA14C(v103, v58, 2);
      os_log_type_t v9 = v102;
    }

    else
    {
      sub_181BDA14C(v103, v24, 2);
    }
  }

  unint64_t v19 = v17 + 4;
  if (v19 >= v98) {
    return swift_release();
  }
  __int16 v18 = *(void *)(v97 + 8 * v19);
  if (v18)
  {
    os_log_type_t v10 = v19;
    goto LABEL_25;
  }

  while (1)
  {
    os_log_type_t v10 = v19 + 1;
    if (__OFADD__(v19, 1LL)) {
      break;
    }
    if (v10 >= v98) {
      return swift_release();
    }
    __int16 v18 = *(void *)(v97 + 8 * v10);
    ++v19;
    if (v18) {
      goto LABEL_25;
    }
  }

    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }

  if (v5 < 0xFFFFFFFF)
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    goto LABEL_7;
  }

  *a1 = v5;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  return a1;
}

    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    *(void *)uint64_t v7 = a1;
LABEL_8:
    swift_storeEnumTagMultiPayload();
LABEL_9:
    sub_181BE4800((uint64_t)v7, a2);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v5 + 56))(a2, 0LL, 1LL, v4);
  }

  __int16 v18 = nw_endpoint_get_port(a1);
  address = nw_endpoint_get_address(a1);
  sa_family = address->sa_family;
  if (sa_family == 1)
  {
    v33 = nw_endpoint_copy_address_string(a1);
    *(void *)uint64_t v7 = sub_18264EB80();
    *((void *)v7 + 1) = v34;
    swift_storeEnumTagMultiPayload();
    MEMORY[0x186E12168](v33, -1LL, -1LL);
    swift_unknownObjectRelease();
    swift_unknownObjectRelease_n();
    goto LABEL_9;
  }

  if (sa_family != 30)
  {
    if (sa_family == 2 && address->sa_len == 16)
    {
      uint32_t v21 = *(unsigned int *)&address->sa_data[2];
      swift_unknownObjectRelease_n();
      *(void *)uint64_t v7 = v21;
      *((void *)v7 + 1) = v11;
      *((void *)v7 + 2) = 0LL;
      uint64_t v22 = 1;
LABEL_35:
      v7[24] = v22;
      *((_WORD *)v7 + 13) = v18;
      goto LABEL_8;
    }

    goto LABEL_30;
  }

  if (address->sa_len == 28)
  {
    uint64_t v36 = *(void *)&address->sa_data[6];
    unint64_t v35 = *(void *)&address[1].sa_len;
    if (v11 == 1)
    {
      v37 = *(_DWORD *)&address[1].sa_data[6];
      if (v37)
      {
        os_log_type_t v10 = (uint64_t)nw_interface_create_with_index(v37);
        swift_unknownObjectRelease_n();
        if (!v10) {
          os_log_type_t v10 = 1LL;
        }
        goto LABEL_34;
      }

      os_log_type_t v10 = 1LL;
    }

    swift_unknownObjectRelease_n();
LABEL_34:
    *(void *)uint64_t v7 = v36;
    *((void *)v7 + 1) = v35;
    *((void *)v7 + 2) = v10;
    uint64_t v22 = 2;
    goto LABEL_35;
  }

  uint64_t v13 = (unsigned __int16)sub_181C1B9EC(v9, v10, a5);
  swift_bridgeObjectRelease();
  return v13 & 0x1FF;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

    *((_OWORD *)a1 + 3) = *((_OWORD *)a2 + 3);
    return a1;
  }

  if (!v4)
  {
    sub_181BD73AC((uint64_t)(a1 + 6));
    goto LABEL_7;
  }

  a1[6] = v4;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[7] = a2[7];
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  return a1;
}

  uint64_t v13 = a4(v9, v10, a3);
  swift_bridgeObjectRelease();
  return v13;
}

  uint64_t v13 = a4(v9, v10, a3);
  swift_bridgeObjectRelease();
  return v13 & 0x1FF;
}

  uint64_t v13 = a4(v9, v10, a3);
  swift_bridgeObjectRelease();
  return v13 & 0x1FFFF;
}

  uint64_t v13 = a4(v9, v10, a3);
  swift_bridgeObjectRelease();
  return v13 | ((HIDWORD(v13) & 1) << 32);
}

  nw_framer_write_output_data(a1, (dispatch_data_t)v22);
  swift_unknownObjectRelease();

  sub_181BCD4F0(a2, v28);
}

  sub_181C3900C(v13, v14, a2, a3, a4, a5, a6);
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

  __break(1u);
  return result;
}

    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }

  if (v4 < 0xFFFFFFFF)
  {
    swift_release();
    goto LABEL_7;
  }

  uint64_t v5 = a2[1];
  *a1 = v4;
  a1[1] = v5;
  swift_retain();
  swift_release();
  return a1;
}

    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }

  if (v4 < 0xFFFFFFFF)
  {
    swift_release();
    goto LABEL_7;
  }

  uint64_t v5 = a2[1];
  *a1 = v4;
  a1[1] = v5;
  swift_release();
  return a1;
}

    uint64_t v11 = v9[v14] | v13;
LABEL_8:
    v9[v14] = v11;
    if (a5 == ++v10)
    {
      uint64_t v15 = dispatch_data_create(v9, a5 >> 1, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A88]);
      char v16 = *(void ***)(a1 + 32);
      uint64_t v17 = *v16;
      *char v16 = v15;

      return 1LL;
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v18 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    unint64_t v19 = *(unsigned __int8 *)(a4 + v10);
    *(_DWORD *)buf = 136446466;
    v23 = "nw_txt_record_get_key_data_value_block_invoke";
    v24 = 1024;
    LODWORD(v25) = v19;
    _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_ERROR, "%{public}s Not hex character: %c", buf, 0x12u);
  }

  if (v9) {
    free(v9);
  }
  return 0LL;
}

    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL) = v4;
    goto LABEL_8;
  }

  dispatch_time_t v3 = a2[4];
  uint64_t v4 = (void *)a2[5];
  uint64_t v2 = a2 + 4;
  if (!v3) {
    goto LABEL_7;
  }
  *(void *)(v3 + 40) = v4;
  *(void *)a2[5] = v3;
LABEL_9:
  *uint64_t v2 = 0LL;
  v2[1] = 0LL;
  uint64_t v5 = *(void *)(a1 + 40);
  if (*(_BYTE *)(a1 + 48))
  {
    a2[4] = 0LL;
    uint64_t v6 = a2 + 4;
  }

  else
  {
    a2[2] = 0LL;
    uint64_t v6 = a2 + 2;
  }

  uint64_t v7 = *(void **)(v5 + 8);
  v6[1] = v7;
  *uint64_t v7 = a2;
  *(void *)(v5 + 8) = v6;
  return 1LL;
}

  return v8;
}

LABEL_8:
      _Block_object_dispose(&v62, 8);
      goto LABEL_9;
    }

    uint64_t v15 = (os_log_s *)*(id *)&v9[22]._os_unfair_lock_opaque;
    if (!v15)
    {
      if (!nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        unint64_t v19 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          if (a2 > 4) {
            __int16 v20 = "<unknown>";
          }
          else {
            __int16 v20 = off_189BB8B98[a2];
          }
          v27 = v9[42]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v27;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v20;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] no listener present, ignoring listener state %s",  buf,  0x1Cu);
        }
      }

      uint64_t v13 = 0LL;
      goto LABEL_7;
    }

    uint64_t v13 = v15;
    if (a2)
    {
      logging_disabled = nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque);
      if (v7)
      {
        if (logging_disabled) {
          goto LABEL_50;
        }
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        uint64_t v17 = (os_log_s *)(id)gconnection_groupLogObj;
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_49;
        }
        if (a2 > 4) {
          __int16 v18 = "<unknown>";
        }
        else {
          __int16 v18 = off_189BB8B98[a2];
        }
        v23 = v9[42]._os_unfair_lock_opaque;
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v23;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v13;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v18;
        *(_WORD *)&buf[38] = 2112;
        v67 = v7;
        v24 = "%{public}s [G%u] listener %@ changed to state %s (error %@)";
        v25 = v17;
        v26 = 48;
      }

      else
      {
        if (logging_disabled) {
          goto LABEL_50;
        }
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        uint64_t v17 = (os_log_s *)(id)gconnection_groupLogObj;
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
LABEL_49:

LABEL_50:
          switch(a2)
          {
            case 1u:
              *(void *)buf = v8;
              *(void *)&buf[8] = 3221225472LL;
              *(void *)&buf[16] = ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_170;
              *(void *)&buf[24] = &unk_189BC9238;
              *(void *)&buf[32] = v9;
              v67 = v7;
              unint64_t v29 = (void (**)(void))_Block_copy(buf);
              os_unfair_lock_lock(v6 + 43);
              v29[2](v29);
              os_unfair_lock_unlock(v6 + 43);

              break;
            case 2u:
              if (!nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque))
              {
                if (__nwlog_connection_group_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
                }
                unint64_t v30 = (os_log_s *)(id)gconnection_groupLogObj;
                if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                {
                  v31 = v9[42]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v31;
                  _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEFAULT,  "%{public}s [G%u] listener ready",  buf,  0x12u);
                }
              }

              *(void *)buf = v8;
              *(void *)&buf[8] = 3221225472LL;
              *(void *)&buf[16] = ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_171;
              *(void *)&buf[24] = &unk_189BC9238;
              *(void *)&buf[32] = v9;
              v67 = v7;
              __int16 v32 = (void (**)(void))_Block_copy(buf);
              os_unfair_lock_lock(v6 + 43);
              v32[2](v32);
              os_unfair_lock_unlock(v6 + 43);

              break;
            case 3u:
              if (!nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque))
              {
                if (__nwlog_connection_group_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
                }
                v33 = (os_log_s *)(id)gconnection_groupLogObj;
                if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                {
                  __int16 v34 = v9[42]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v34;
                  _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] listener failed with error ",  buf,  0x12u);
                }
              }

              if (v7)
              {
                *(void *)buf = v8;
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_172;
                *(void *)&buf[24] = &unk_189BC9238;
                *(void *)&buf[32] = v9;
                v67 = v7;
                unint64_t v35 = _Block_copy(buf);
                *(void *)os_log_type_t type = v35;
                nw_synchronize<void({block_pointer} {__strong})(void)>(v6 + 43, (uint64_t)type);
              }

              else
              {
                posix_error = nw_error_create_posix_error(50);
                *(void *)buf = v8;
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_2;
                *(void *)&buf[24] = &unk_189BC9238;
                *(void *)&buf[32] = v9;
                v67 = posix_error;
                v40 = posix_error;
                v41 = _Block_copy(buf);
                *(void *)os_log_type_t type = v41;
                nw_synchronize<void({block_pointer} {__strong})(void)>(v6 + 43, (uint64_t)type);
              }

              break;
            case 4u:
              if (!nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque))
              {
                if (__nwlog_connection_group_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
                }
                uint64_t v36 = (os_log_s *)(id)gconnection_groupLogObj;
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
                {
                  v37 = v9[42]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v37;
                  _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Listener cancelled",  buf,  0x12u);
                }
              }

              *(void *)buf = v8;
              *(void *)&buf[8] = 3221225472LL;
              *(void *)&buf[16] = ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_173;
              *(void *)&buf[24] = &unk_189BC93A0;
              *(void *)&buf[32] = v9;
              v38 = (void (**)(void))_Block_copy(buf);
              os_unfair_lock_lock(v6 + 43);
              v38[2](v38);
              os_unfair_lock_unlock(v6 + 43);

              break;
            default:
              goto LABEL_7;
          }

          goto LABEL_7;
        }

        if (a2 > 4) {
          uint64_t v22 = "<unknown>";
        }
        else {
          uint64_t v22 = off_189BB8B98[a2];
        }
        int v28 = v9[42]._os_unfair_lock_opaque;
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v28;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v13;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v22;
        v24 = "%{public}s [G%u] listener %@ changed to state %s";
        v25 = v17;
        v26 = 38;
      }

      _os_log_impl(&dword_181A5C000, v25, OS_LOG_TYPE_DEBUG, v24, buf, v26);
      goto LABEL_49;
    }

    __nwlog_obj();
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
    v53 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (__nwlog_fault(v53, type, &v61))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v55 = type[0];
        if (os_log_type_enabled(v54, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
          _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null listener_state", buf, 0xCu);
        }
      }

      else if (v61)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v57 = type[0];
        v58 = os_log_type_enabled(v54, type[0]);
        if (backtrace_string)
        {
          if (v58)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v54,  v57,  "%{public}s called with null listener_state, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_114;
        }

        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
          _os_log_impl( &dword_181A5C000,  v54,  v57,  "%{public}s called with null listener_state, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v59 = type[0];
        if (os_log_type_enabled(v54, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
          _os_log_impl( &dword_181A5C000,  v54,  v59,  "%{public}s called with null listener_state, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    BOOL v14 = [*(id *)(a1 + 32) mID];
    [*(id *)(a1 + 40) UUIDString];
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    char v16 = *(void *)(a1 + 48);
    uint64_t v17 = *(void *)(a1 + 56);
    unint64_t v19 = 136447746;
    __int16 v20 = "-[NWMonitor evaluateStartingAtIndex:probeUUID:probeWasSuccessful:]_block_invoke";
    uint32_t v21 = 1024;
    uint64_t v22 = v14;
    v23 = 2114;
    v24 = v15;
    v25 = 2114;
    v26 = v16;
    v27 = 2048;
    int v28 = v17;
    unint64_t v29 = 2048;
    unint64_t v30 = v7;
    v31 = 2114;
    __int16 v32 = v8;
    _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s %u received response for probe %{public}@ to %{public}@ for description%lu: data = %p, response = %{public}@",  (uint8_t *)&v19,  0x44u);
  }

  if (v7)
  {
    objc_opt_class();
    __int16 v18 = (objc_opt_isKindOfClass() & 1) == 0 || (unint64_t)([v8 statusCode] - 200) < 0x64;
  }

  else
  {
    __int16 v18 = 0LL;
  }

  [*(id *)(a1 + 32) evaluateStartingAtIndex:*(void *)(a1 + 56) probeUUID:*(void *)(a1 + 40) probeWasSuccessful:v18];
}

  return v8;
}

LABEL_8:
    if (!v4) {
      goto LABEL_10;
    }
LABEL_9:
    free(v4);
    goto LABEL_10;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    uint64_t v11 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_protocol_data_array_create";
      _os_log_impl( &dword_181A5C000,  v5,  v11,  "%{public}s [nw_protocol_data_array init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  os_log_type_t v9 = type;
  os_log_type_t v10 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_protocol_data_array_create";
      _os_log_impl(&dword_181A5C000, v5, v9, "%{public}s [nw_protocol_data_array init] failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_7;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_protocol_data_array_create";
    char v16 = 2082;
    uint64_t v17 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [nw_protocol_data_array init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:

  return v1;
}

    uint64_t v8 = 1LL;
  }
}

    uint64_t v8 = 0LL;
    os_log_type_t v9 = 0;
    os_log_type_t v10 = 1;
    do
    {
      uint64_t v11 = v7[v8];
      if ((v11 - 65) <= 0x19)
      {
        v11 += 32;
        v7[v8] = v11;
        os_log_type_t v9 = 1;
      }

      v10 &= (v11 - 32) < 0x60;
      ++v8;
    }

    while (v6 != v8);
    if ((v10 & 1) != 0)
    {
      if ((v9 & 1) != 0)
      {
        uint64_t v12 = (void *)NSString;
        uint64_t v13 = v7;
        BOOL v14 = v6;
        goto LABEL_19;
      }
    }

    else
    {
      if (createIDNAEncodedDomain__onceToken != -1) {
        dispatch_once(&createIDNAEncodedDomain__onceToken, &__block_literal_global_15792);
      }
      pErrorCode = U_ZERO_ERROR;
      pInfo = (UIDNAInfo)xmmword_18272D840;
      uint64_t v15 = uidna_nameToASCII((const UIDNA *)createIDNAEncodedDomain__idna, v7, v6, dest, 256, &pInfo, &pErrorCode);
      if (pErrorCode <= U_ZERO_ERROR && pInfo.errors < 0x40)
      {
        BOOL v14 = v15;
        uint64_t v13 = dest;
        uint64_t v12 = (void *)NSString;
LABEL_19:
        objc_msgSend(v12, "stringWithCharacters:length:", v13, v14, v26, v27);
        char v16 = (void *)objc_claimAutoreleasedReturnValue();
        free(v7);

        if (!v16) {
          goto LABEL_33;
        }
LABEL_23:
        if ([v16 getCString:dest maxLength:256 encoding:1])
        {
          uint64_t v17 = strlen((const char *)dest);
          if (v17 && *((_BYTE *)dest + v17 - 1) == 46) {
            *((_BYTE *)dest + v17 - 1) = 0;
          }
          TopLevelDomain = _CFHostGetTopLevelDomain();
          dispatch_time_t v3 = 0LL;
          if (TopLevelDomain && TopLevelDomain > (unint64_t)dest + 1)
          {
            unint64_t v19 = (UChar *)(TopLevelDomain - 2);
            do
            {
              __int16 v20 = v19;
              if (v19 < dest) {
                break;
              }
              unint64_t v19 = (UChar *)((char *)v19 - 1);
            }

            while (*(_BYTE *)v20 != 46);
            [NSString stringWithCString:(char *)v20 + 1 encoding:1];
            dispatch_time_t v3 = (void *)objc_claimAutoreleasedReturnValue();
          }

          goto LABEL_34;
        }
}

  uint64_t v13 = -[NSData copyWithZone:](self->_agentData, "copyWithZone:", a3);
  BOOL v14 = *(void **)(v5 + 16);
  *(void *)(v5 + 16) = v13;

  return (id)v5;
}

      if (gLogDatapath)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v8 = *((void *)v64 + 3);
          buf = 136446722;
          v68 = "nw_frame_cache_create_frame";
          v69 = 2048;
          v70 = v8;
          v71 = 1024;
          LODWORD(v72) = v2;
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s returning frame %p for requested length %u",  (uint8_t *)&buf,  0x1Cu);
        }
      }

      goto LABEL_52;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    buf = 136446210;
    v68 = "nw_frame_cache_create_frame";
    int v28 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v28, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v29 = (os_log_s *)gLogObj;
        unint64_t v30 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          buf = 136446210;
          v68 = "nw_frame_cache_create_frame";
          v31 = "%{public}s nw_frame_create new frame failed";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v29, v30, v31, (uint8_t *)&buf, 0xCu);
        }
      }

      else if (v50)
      {
        unint64_t v35 = (char *)__nw_create_backtrace_string();
        unint64_t v29 = (os_log_s *)__nwlog_obj();
        unint64_t v30 = type;
        uint64_t v36 = os_log_type_enabled(v29, type);
        if (v35)
        {
          if (v36)
          {
            buf = 136446466;
            v68 = "nw_frame_cache_create_frame";
            v69 = 2082;
            v70 = (uint64_t)v35;
            _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s nw_frame_create new frame failed, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x16u);
          }

          free(v35);
          goto LABEL_60;
        }

        if (v36)
        {
          buf = 136446210;
          v68 = "nw_frame_cache_create_frame";
          v31 = "%{public}s nw_frame_create new frame failed, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        unint64_t v29 = (os_log_s *)__nwlog_obj();
        unint64_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          buf = 136446210;
          v68 = "nw_frame_cache_create_frame";
          v31 = "%{public}s nw_frame_create new frame failed, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }
  }

  return nw_endpoint_handler_reset_mode(*(void *)(a1 + 32), 1LL);
}

    goto LABEL_8;
  }

  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v9 = type;
    if (os_log_type_enabled(v4, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "tcp_connection_set_source_application_by_bundle";
      _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v4 = (os_log_s *)(id)gLogObj;
  uint64_t v7 = type;
  uint64_t v8 = os_log_type_enabled(v4, type);
  if (!backtrace_string)
  {
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "tcp_connection_set_source_application_by_bundle";
      _os_log_impl(&dword_181A5C000, v4, v7, "%{public}s called with null connection, no backtrace", buf, 0xCu);
    }

    goto LABEL_7;
  }

  if (v8)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v13 = "tcp_connection_set_source_application_by_bundle";
    BOOL v14 = 2082;
    uint64_t v15 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v3) {
LABEL_9:
  }
    free(v3);
}

        CFRelease(v4);
        *(void *)(a1 + 208) = 0LL;
        goto LABEL_8;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446722;
      v40 = "nw_http_connect_send_auth_request";
      v41 = 2082;
      v42 = (char *)(a1 + 284);
      v43 = 2080;
      v44 = " ";
      char v16 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v33 = 0;
      if (__nwlog_fault(v16, &type, &v33))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v17 = (os_log_s *)__nwlog_obj();
          __int16 v18 = type;
          if (!os_log_type_enabled(v17, type)) {
            goto LABEL_49;
          }
          *(_DWORD *)buf = 136446722;
          v40 = "nw_http_connect_send_auth_request";
          v41 = 2082;
          v42 = (char *)(a1 + 284);
          v43 = 2080;
          v44 = " ";
          unint64_t v19 = "%{public}s %{public}s%sCFStringCreateWithCString failed";
          goto LABEL_48;
        }

        if (!v33)
        {
          uint64_t v17 = (os_log_s *)__nwlog_obj();
          __int16 v18 = type;
          if (!os_log_type_enabled(v17, type)) {
            goto LABEL_49;
          }
          *(_DWORD *)buf = 136446722;
          v40 = "nw_http_connect_send_auth_request";
          v41 = 2082;
          v42 = (char *)(a1 + 284);
          v43 = 2080;
          v44 = " ";
          unint64_t v19 = "%{public}s %{public}s%sCFStringCreateWithCString failed, backtrace limit exceeded";
          goto LABEL_48;
        }

        __int16 v20 = (char *)__nw_create_backtrace_string();
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        __int16 v18 = type;
        uint32_t v21 = os_log_type_enabled(v17, type);
        if (v20)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446978;
            v40 = "nw_http_connect_send_auth_request";
            v41 = 2082;
            v42 = (char *)(a1 + 284);
            v43 = 2080;
            v44 = " ";
            v45 = 2082;
            v46 = v20;
            _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s %{public}s%sCFStringCreateWithCString failed, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v20);
          goto LABEL_49;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_http_connect_send_auth_request";
          v41 = 2082;
          v42 = (char *)(a1 + 284);
          v43 = 2080;
          v44 = " ";
          unint64_t v19 = "%{public}s %{public}s%sCFStringCreateWithCString failed, no backtrace";
LABEL_48:
          _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0x20u);
        }
      }

LABEL_8:
    if (!v4) {
      goto LABEL_10;
    }
LABEL_9:
    free(v4);
    goto LABEL_10;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    uint64_t v11 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_proxy_config_create_direct";
      _os_log_impl( &dword_181A5C000,  v5,  v11,  "%{public}s [nw_proxy_config init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  os_log_type_t v9 = type;
  os_log_type_t v10 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_proxy_config_create_direct";
      _os_log_impl(&dword_181A5C000, v5, v9, "%{public}s [nw_proxy_config init] failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_7;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_proxy_config_create_direct";
    char v16 = 2082;
    uint64_t v17 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [nw_proxy_config init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:

  return v1;
}

    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL) = v4;
    goto LABEL_8;
  }

  dispatch_time_t v3 = a2[4];
  uint64_t v4 = (void *)a2[5];
  uint64_t v2 = a2 + 4;
  if (!v3) {
    goto LABEL_7;
  }
  *(void *)(v3 + 40) = v4;
  *(void *)a2[5] = v3;
LABEL_9:
  *uint64_t v2 = 0LL;
  v2[1] = 0LL;
  uint64_t v5 = *(void *)(a1 + 40);
  if (*(_BYTE *)(a1 + 48))
  {
    a2[4] = 0LL;
    uint64_t v6 = a2 + 4;
  }

  else
  {
    a2[2] = 0LL;
    uint64_t v6 = a2 + 2;
  }

  uint64_t v7 = *(void **)(v5 + 8);
  v6[1] = v7;
  *uint64_t v7 = a2;
  *(void *)(v5 + 8) = v6;
  return 1LL;
}

    uint64_t v4 = MEMORY[0x1895F87A8];
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_39716;
    v137 = (uint64_t)&__block_descriptor_tmp_55_39717;
    *(void *)v138 = v2 + 616;
    v138[8] = 0;
    uint64_t v5 = *(void *)(v2 + 616);
    do
    {
      if (!v5) {
        break;
      }
      uint64_t v6 = *(void *)(v5 + 32);
      uint64_t v7 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      uint64_t v5 = v6;
    }

    while ((v7 & 1) != 0);
    if ((*(_BYTE *)(v2 + 158) & 1) == 0)
    {
      if (!gLogDatapath) {
        goto LABEL_12;
      }
      v85 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
      {
        v86 = *(void *)(v2 + 488);
        v87 = *(_DWORD *)(*(void *)(v2 + 480) + 372LL);
        v88 = *(_DWORD *)(v2 + 860);
        if (v86) {
          LODWORD(v86) = *(_DWORD *)(v86 + 424);
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_http1_tear_down_connection";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v2 + 74;
        *(_WORD *)&buf[22] = 2080;
        v137 = (uint64_t)" ";
        *(_WORD *)v138 = 1024;
        *(_DWORD *)&v138[2] = v87;
        *(_WORD *)&v138[6] = 1024;
        *(_DWORD *)&v138[8] = v88;
        *(_WORD *)&v138[12] = 1024;
        *(_DWORD *)&v138[14] = v86;
        _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> finalizing processed_input_frames",  buf,  0x32u);
      }
    }

    if (gLogDatapath)
    {
      v89 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(type) = 136446210;
        *(void *)((char *)&type + 4) = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v89, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&type, 0xCu);
      }
    }

  uint64_t v12 = (id)v19[5];
  _Block_object_dispose(&v18, 8);

  return v12;
}

  uint64_t v12 = (id)v19[5];
  _Block_object_dispose(&v18, 8);

  return v12;
}

  uint64_t v12 = (id)v19[5];
  _Block_object_dispose(&v18, 8);

  return v12;
}

  uint64_t v12 = (id)v19[5];
  _Block_object_dispose(&v18, 8);

  return v12;
}

  uint64_t v15 = (id)v27[5];
  _Block_object_dispose(&v26, 8);

  return v15;
}

  uint64_t v15 = (id)v27[5];
  _Block_object_dispose(&v26, 8);

  return v15;
}

  __int16 v18 = (id)v27[5];
  _Block_object_dispose(&v26, 8);

  return v18;
}

  __int16 v18 = (id)v27[5];
  _Block_object_dispose(&v26, 8);

  return v18;
}

  __int16 v18 = (id)v27[5];
  _Block_object_dispose(&v26, 8);

  return v18;
}

  __int16 v18 = (id)v27[5];
  _Block_object_dispose(&v26, 8);

  return v18;
}

  __int16 v18 = (id)v27[5];
  _Block_object_dispose(&v26, 8);

  return v18;
}

          uint64_t v7 = v6 >> 1;
          uint64_t v8 = *((_BYTE *)v5 + (v6 >> 1)) | v10;
LABEL_8:
          *((_BYTE *)v5 + v7) = v8;
          if (v4 == ++v6) {
            goto LABEL_33;
          }
        }

        os_log_type_t v10 = v9 - 87;
LABEL_12:
        if ((v6 & 1) == 0) {
          goto LABEL_13;
        }
        goto LABEL_7;
      }

    if (v5 == 2)
    {
      *(void *)&buf = 0LL;
      *((void *)&buf + 1) = &buf;
      char v16 = 0x2000000000LL;
      uint64_t v17 = 0LL;
      *(void *)temp_buffer = 0LL;
      uint64_t v12 = temp_buffer;
      uint64_t v13 = 0x2000000000LL;
      BOOL v14 = 0;
      v10[0] = MEMORY[0x1895F87A8];
      v10[1] = 0x40000000LL;
      v10[2] = __nw_protocol_socksv4_copy_definition_block_invoke_7;
      v10[3] = &unk_189BBE5F0;
      v10[4] = &buf;
      v10[5] = temp_buffer;
      nw_framer_parse_input(framer, 1uLL, 0xFFFFFFFFuLL, 0LL, v10);
      uint64_t v8 = nw_framer_message_create(*(nw_framer_t *)(a1 + 40));
      nw_framer_deliver_input_no_copy(framer, *(void *)(*((void *)&buf + 1) + 24LL), v8, v12[24]);
      if (v8) {
        os_release(v8);
      }
      _Block_object_dispose(temp_buffer, 8);
      _Block_object_dispose(&buf, 8);
    }

    return 0LL;
  }

  *(void *)temp_buffer = 0LL;
  *(void *)&buf = MEMORY[0x1895F87A8];
  *((void *)&buf + 1) = 0x40000000LL;
  char v16 = (uint64_t)___ZL24nw_socksv4_parse_connectP9nw_framerP10nw_socksv4_block_invoke;
  uint64_t v17 = &__block_descriptor_tmp_24_44279;
  __int16 v18 = framer;
  unint64_t v19 = v4;
  uint64_t v7 = 8LL;
  if (nw_framer_parse_input(framer, 8uLL, 8uLL, temp_buffer, &buf))
  {
    uint64_t v5 = *(_DWORD *)(*(void *)(a1 + 32) + 8LL);
    goto LABEL_7;
  }

  return v7;
}

  if (v4)
  {
    os_log_type_t v9 = a1[4];
    if (v9)
    {
      os_log_type_t v10 = *(void *)(v9 + 416);
      uint64_t v11 = v4;
      if (v10)
      {
        objc_storeStrong((id *)(v10 + 32), a2);
        *(void *)(v10 + 48) = 0LL;
      }
    }

    else
    {
      uint64_t v17 = v4;
    }

    uint64_t v12 = (void *)a1[4];
    uint64_t v13 = a1[5];
    if (v12) {
      uint64_t v12 = (void *)v12[52];
    }
    BOOL v14 = (void *)a1[6];
    uint64_t v15 = v12;
    -[NWURLSessionRequestBodyInfo bodyProviderFromOffset:](v15, v14);
    char v16 = (void *)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void *))(v13 + 16))(v13, v16);
  }

  else
  {
    (*(void (**)(void))(a1[5] + 16LL))();
  }
}

  uint64_t v15 = (void *)[v11 mutableCopy];
LABEL_25:
  v24 = -[NWURLSessionTask initWithRequest:identifier:session:](a1, v15, a4, v10);
  v26 = v24;
  if (v24)
  {
    objc_setProperty_nonatomic_copy(v24, v25, v11, 48LL);
    v27 = v9[5];
    [v26 setEarliestBeginDate:v27];

    [v26 setCountOfBytesClientExpectsToSend:v9[6]];
    [v26 setCountOfBytesClientExpectsToReceive:v9[7]];
    int v28 = v9[8];
    [v26 setTaskDescription:v28];

    LODWORD(v29) = *((_DWORD *)v9 + 3);
    [v26 setPriority:v29];
    [v26 setPrefersIncrementalDelivery:*((unsigned __int8 *)v9 + 8)];
    objc_msgSend(v26, "set_keepDownloadTaskFile:", *((unsigned __int8 *)v9 + 9));
  }

  a1 = v26;
  unint64_t v30 = a1;
LABEL_28:

LABEL_29:
  return v30;
}

  dispatch_group_enter(*(dispatch_group_t *)(a1 + 32));
  os_log_type_t v9 = *(void *)(a1 + 40);
  if (v9) {
    os_log_type_t v10 = *(void **)(v9 + 32);
  }
  else {
    os_log_type_t v10 = 0LL;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  v13[2] = __89__NWURLSessionMultipartParser_task_handleMultipartData_complete_error_completionHandler___block_invoke_50;
  v13[3] = &unk_189BBF430;
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v15 = *(void *)(a1 + 56);
  BOOL v14 = *(id *)(a1 + 32);
  [v10 task:v11 deliverData:v7 complete:a3 error:v8 completionHandler:v13];

LABEL_10:
}

  uint64_t v7 = calloc((2 * a2), 0x10uLL);
  if (!v7)
  {
    __nwlog_obj();
    v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v76 = 136446722;
    *(void *)&v76[4] = "strict_calloc";
    *(_WORD *)&v76[12] = 2048;
    *(void *)&v76[14] = v5;
    v77 = 2048;
    v78 = 16LL;
    v49 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v49);
    if (!(_DWORD)result)
    {
      free(v49);
      goto LABEL_8;
    }

  uint64_t v1 = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  BYTE9(v1) &= ~1u;
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
  }
  return nw_protocol_metadata_create((void *)nw_protocol_copy_quic_connection_definition::quic_definition, &v1);
}

LABEL_8:
    if (!v4) {
      goto LABEL_10;
    }
LABEL_9:
    free(v4);
    goto LABEL_10;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    uint64_t v11 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_path_flow_registration_create_internal";
      _os_log_impl( &dword_181A5C000,  v5,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow_registration) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  os_log_type_t v9 = type;
  os_log_type_t v10 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_path_flow_registration_create_internal";
      _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow_registration) alloc] init] failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_path_flow_registration_create_internal";
    char v16 = 2082;
    uint64_t v17 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow_registration) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:

  return v1;
}

  a2 = 0LL;
LABEL_124:

  return a2;
}

  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  uint64_t v12 = nw_hash_table_add_object(v11, (uint64_t)v6, (char *)&type);
  os_unfair_lock_unlock(v10);
  if (type == OS_LOG_TYPE_DEFAULT || !v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v18 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      unint64_t v35 = "nw_path_flow_registration_create";
      uint64_t v36 = 1042;
      *(_DWORD *)v37 = 16;
      v37[2] = 2098;
      *(void *)&v37[3] = v6->registration_id;
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to add flow registration for %{public,uuid_t}.16P",  buf,  0x1Cu);
    }

    goto LABEL_52;
  }

  uint64_t v13 = v6;
LABEL_53:

  return v13;
}
}

LABEL_8:
    if (!v4) {
      goto LABEL_10;
    }
LABEL_9:
    free(v4);
    goto LABEL_10;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    uint64_t v11 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_path_override_info_create";
      _os_log_impl( &dword_181A5C000,  v5,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_override_info) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  os_log_type_t v9 = type;
  os_log_type_t v10 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_path_override_info_create";
      _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_override_info) alloc] init] failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_7;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_path_override_info_create";
    char v16 = 2082;
    uint64_t v17 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_override_info) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:

  return v1;
}

    *a3 = v6;
    return nw_endpoint_create_address_with_port((unsigned __int8 *)__dst, a2);
  }

  if ((nw_utilities_cidr_string_to_subnet_and_mask(a1, (uint64_t)__dst, (uint64_t)type, &v26) & 1) != 0)
  {
    uint64_t v6 = v26;
    goto LABEL_7;
  }

  return 0LL;
}

  uint64_t v7 = nw_hash_table_add_object(internal, a2, (char *)&v47);
  uint64_t v8 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
  if (v47 == OS_LOG_TYPE_DEFAULT)
  {
    if ((v8 & 0x80000) != 0) {
      return 0LL;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v11 = *(_DWORD *)(a2 + 176);
    os_log_type_t v10 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)buf = 136447490;
    v49 = "nw_http2_add_to_id_table";
    v50 = 2082;
    v51 = (char *)(a2 + 191);
    v52 = 2080;
    v53 = " ";
    v54 = 1024;
    v55 = v10;
    v56 = 1024;
    v57 = v11;
    v58 = 1024;
    *(_DWORD *)v59 = v11;
    uint64_t v12 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v13 = (os_log_s *)gconnectionLogObj;
      BOOL v14 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        char v16 = *(_DWORD *)(a2 + 176);
        uint64_t v15 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v15;
        v56 = 1024;
        v57 = v16;
        v58 = 1024;
        *(_DWORD *)v59 = v16;
        uint64_t v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d";
LABEL_46:
        _os_log_impl(&dword_181A5C000, v13, v14, v17, buf, 0x32u);
      }
    }

    else if (v45)
    {
      __int16 v18 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v13 = (os_log_s *)gconnectionLogObj;
      BOOL v14 = type;
      unint64_t v19 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_47;
        }
        __int16 v32 = *(_DWORD *)(a2 + 176);
        v31 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v31;
        v56 = 1024;
        v57 = v32;
        v58 = 1024;
        *(_DWORD *)v59 = v32;
        uint64_t v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, no backtrace";
        goto LABEL_46;
      }

      if (v19)
      {
        uint32_t v21 = *(_DWORD *)(a2 + 176);
        __int16 v20 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447746;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v20;
        v56 = 1024;
        v57 = v21;
        v58 = 1024;
        *(_DWORD *)v59 = v21;
        *(_WORD *)&v59[4] = 2082;
        *(void *)&v59[6] = v18;
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, dumping backtrace:%{public}s",  buf,  0x3Cu);
      }

      free(v18);
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v13 = (os_log_s *)gconnectionLogObj;
      BOOL v14 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        unint64_t v30 = *(_DWORD *)(a2 + 176);
        unint64_t v29 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v29;
        v56 = 1024;
        v57 = v30;
        v58 = 1024;
        *(_DWORD *)v59 = v30;
        uint64_t v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, backtrace limit exceeded";
        goto LABEL_46;
      }
    }

  *(void *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 16) = v5 | 1;
  return 1LL;
}

  return v5;
}

BOOL nw_context_get_globals_for_channel(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  id v2 = &__block_literal_global_29_86675;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_context_get_globals_for_channel";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null context", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v22 = "nw_context_get_globals_for_channel";
            __int16 v23 = 2082;
            uint64_t v24 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_context_get_globals_for_channel";
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_25:
    if (v10) {
      free(v10);
    }
    uint64_t v5 = 0LL;
    goto LABEL_6;
  }

  BOOL v3 = nw_context_copy_globals_context(v1);

  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(v3 + 32) + 40LL));
  uint64_t v4 = *(void *)(v3 + 32);
  uint64_t v5 = *(void *)(v4 + 60);
  if (v5)
  {
LABEL_5:
    os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 40));

LABEL_6:
    return v5;
  }

  uint64_t v6 = calloc(1uLL, 0x18uLL);
  if (v6)
  {
LABEL_4:
    *(void *)(*(void *)(v3 + 32) + 60LL) = v6;
    uint64_t v7 = *(void **)(*(void *)(v3 + 32) + 60LL);
    *uint64_t v7 = nw_dictionary_create();
    v7[1] = nw_array_create();
    v7[2] = 0LL;
    uint64_t v4 = *(void *)(v3 + 32);
    uint64_t v5 = *(void *)(v4 + 60);
    goto LABEL_5;
  }

  __nwlog_obj();
  char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v22 = "strict_calloc";
  __int16 v23 = 2048;
  uint64_t v24 = 1LL;
  __int16 v25 = 2048;
  uint64_t v26 = 24LL;
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

              nw_array_append(v14, v9);
              goto LABEL_26;
            }

            __int16 v25 = 1LL;
LABEL_24:
            uint64_t v26 = nw_array_create();
            uint64_t v27 = (void *)v11[v25];
            v11[v25] = v26;

            os_log_type_t v14 = v11[v25];
            goto LABEL_25;
          default:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v12 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v61 = "nw_parameters_add_protocol_stack_member";
              v62 = 1024;
              LODWORD(v63) = a2;
              _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s Unsupported protocol level %u",  buf,  0x12u);
            }

            goto LABEL_9;
        }
      }

      __nwlog_obj();
      unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v61 = "nw_parameters_add_protocol_stack_member";
      uint64_t v36 = (char *)_os_log_send_and_compose_impl();

      v59 = OS_LOG_TYPE_ERROR;
      v58 = 0;
      if (__nwlog_fault(v36, &v59, &v58))
      {
        if (v59 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v38 = v59;
          if (os_log_type_enabled(v37, v59))
          {
            *(_DWORD *)buf = 136446210;
            v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null stack", buf, 0xCu);
          }
        }

        else if (v58)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v45 = v59;
          v46 = os_log_type_enabled(v37, v59);
          if (backtrace_string)
          {
            if (v46)
            {
              *(_DWORD *)buf = 136446466;
              v61 = "nw_parameters_add_protocol_stack_member";
              v62 = 2082;
              v63 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v37,  v45,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_80;
          }

          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_181A5C000, v37, v45, "%{public}s called with null stack, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v49 = v59;
          if (os_log_type_enabled(v37, v59))
          {
            *(_DWORD *)buf = 136446210;
            v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl( &dword_181A5C000,  v37,  v49,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

  return 1LL;
}

  if (*((_DWORD *)v5 + 29) == 2 && nw_endpoint_flow_should_not_use_path(v5[31]))
  {
    *((_DWORD *)v5 + 30) = 1;
    uint64_t v22 = mach_continuous_time();
    if (v22 <= 1) {
      __int16 v23 = 1LL;
    }
    else {
      __int16 v23 = v22;
    }
    v5[16] = (void *)v23;
    uint64_t v24 = v5[31];
    [v24 startWithHandler:v5];

    goto LABEL_64;
  }

  *((_DWORD *)v5 + 20) = 65537;
  nw_endpoint_handler_report(v5, 0LL, (_WORD *)v5 + 40, 0LL);
  if (*((_DWORD *)v5 + 30))
  {
    __int16 v25 = v5;
    uint64_t v26 = v25;
    uint64_t v27 = v2[4];
    if (v27)
    {
      int v28 = v27;
      unint64_t v29 = (v28[12] & 0x4000000000LL) == 0;

      if (!v29)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unint64_t v30 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v31 = v2;
          __int16 v32 = nw_endpoint_handler_get_id_string(v26);
          v33 = nw_endpoint_handler_dry_run_string(v26);
          __int16 v34 = nw_endpoint_handler_copy_endpoint(v26);
          unint64_t v35 = nw_endpoint_get_logging_description(v34);
          uint64_t v36 = nw_endpoint_handler_state_string(v26);
          v37 = nw_endpoint_handler_mode_string(v26);
          v38 = nw_endpoint_handler_copy_current_path(v26);
          *(_DWORD *)buf = 136447746;
          v80 = "nw_endpoint_handler_start";
          v81 = 2082;
          v82 = v32;
          v83 = 2082;
          v84 = v33;
          v85 = 2082;
          v86 = v35;
          v87 = 2082;
          v88 = v36;
          v89 = 2082;
          v90 = v37;
          v91 = 2114;
          v92 = v38;
          _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] state changed during initia l report, not starting",  buf,  0x48u);

          id v2 = v31;
        }

    if (v12) {
      free(v12);
    }
    uint64_t v6 = 0LL;
    goto LABEL_6;
  }

  uint64_t v4 = nw_context_copy_globals_context(v1);

  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(v4 + 32) + 44LL));
  uint64_t v5 = *(void *)(v4 + 32);
  uint64_t v6 = *(void *)(v5 + 68);
  if (v6)
  {
LABEL_5:
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 44));

LABEL_6:
    return v6;
  }

  uint64_t v8 = calloc(1uLL, 0x98uLL);
  if (v8)
  {
LABEL_4:
    *(void *)(*(void *)(v4 + 32) + 68LL) = v8;
    os_log_type_t v9 = *(void *)(*(void *)(v4 + 32) + 68LL);
    *(_OWORD *)(v9 + 112) = 0u;
    *(_OWORD *)(v9 + 128) = 0u;
    *(void *)(v9 + 144) = 0LL;
    *(_OWORD *)(v9 + 80) = 0u;
    *(_OWORD *)(v9 + 96) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 16) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)os_log_type_t v9 = 0u;
    *(void *)(v9 + 132) = -1LL;
    uint64_t v5 = *(void *)(v4 + 32);
    uint64_t v6 = *(void *)(v5 + 68);
    goto LABEL_5;
  }

  __nwlog_obj(0LL, v7);
  uint32_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v27 = "strict_calloc";
  int v28 = 2048;
  unint64_t v29 = 1LL;
  unint64_t v30 = 2048;
  v31 = 152LL;
  uint64_t v22 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v22);
  if (!result)
  {
    free(v22);
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

LABEL_26:
    if (!v13) {
      goto LABEL_28;
    }
LABEL_27:
    free(v13);
    goto LABEL_28;
  }

  if (!v35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v14 = (os_log_s *)(id)gLogObj;
    char v19 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_resolver_config_create_with_dictionary";
      _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s [nw_resolver_config init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_25;
  }

  char v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v14 = (os_log_s *)(id)gLogObj;
  uint64_t v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v14, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_resolver_config_create_with_dictionary";
      _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s [nw_resolver_config init] failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_25;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v40 = "nw_resolver_config_create_with_dictionary";
    v41 = 2082;
    v42 = v16;
    _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s [nw_resolver_config init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v13) {
    goto LABEL_27;
  }
LABEL_28:

  return v3;
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_8:

  return v7;
}

  if (v11) {
    free(v11);
  }
LABEL_8:
}

    uint64_t v5 = 0LL;
    goto LABEL_6;
  }

          if (v11) {
            free(v11);
          }
          *(_WORD *)(a1 + 196) = 0;
        }
      }
    }
  }

    if (v10) {
      free(v10);
    }
LABEL_27:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unint64_t v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v19 = (os_log_s *)(id)gLogObj;
        __int16 v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }

      else if (v26)
      {
        uint32_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v19 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type;
        __int16 v23 = os_log_type_enabled(v19, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
            unint64_t v30 = 2082;
            v31 = v21;
            _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v21);
          if (!v18) {
            goto LABEL_46;
          }
          goto LABEL_45;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
          _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s Endpoint handler is not a resolver, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v19 = (os_log_s *)(id)gLogObj;
        uint64_t v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v18)
    {
LABEL_46:
      uint64_t v8 = 0LL;
      goto LABEL_47;
    }

  if (v10) {
    free(v10);
  }
LABEL_8:
}

  if (v8) {
    free(v8);
  }
  is_multipath = 0LL;
LABEL_8:

  return is_multipath;
}

    if (v8) {
      free(v8);
    }
    BOOL v3 = 0LL;
    goto LABEL_6;
  }

  BOOL v3 = *((id *)v1 + 1);
  uint64_t v4 = (void *)v2[1];
  v2[1] = 0LL;

  if (!v3)
  {
LABEL_5:
    v2[2] = 0LL;
LABEL_6:

    return (BOOL)v3;
  }

  uint64_t v5 = v2[2];
  if (v5)
  {
LABEL_4:
    v3[2] = v5;
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "nw_write_request_list_remove_head";
  os_log_type_t v12 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v5 = v2[2];
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

    if (v8) {
      free(v8);
    }
    BOOL v3 = 0LL;
    goto LABEL_6;
  }

  BOOL v3 = *((id *)v1 + 1);
  uint64_t v4 = (void *)v2[1];
  v2[1] = 0LL;

  if (!v3)
  {
LABEL_5:
    v2[2] = 0LL;
LABEL_6:

    return (BOOL)v3;
  }

  uint64_t v5 = v2[2];
  if (v5)
  {
LABEL_4:
    v3[2] = v5;
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "nw_read_request_list_remove_head";
  os_log_type_t v12 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v5 = v2[2];
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

  if (v3) {
    free(v3);
  }
LABEL_8:
}

  if (v7) {
    free(v7);
  }
LABEL_5:
}

    os_log_type_t v9 = (v18 - 1) & v18;
    char v16 = __clz(__rbit64(v18)) + (v10 << 6);
LABEL_26:
    __int16 v20 = (uint64_t *)(*(void *)(v100 + 48) + 16 * v16);
    uint32_t v21 = *v20;
    uint64_t v22 = v20[1];
    __int16 v23 = *(void *)(v100 + 56) + 24 * v16;
    uint64_t v24 = *(void *)(v23 + 8);
    v103 = *(void *)v23;
    __int16 v25 = *(unsigned __int8 *)(v23 + 16);
    if (!v25)
    {
      v101 = v10;
      v102 = v9;
      swift_bridgeObjectRetain_n();
      v42 = v103;
      sub_181BDA12C(v103, v24, 0);
      v43 = v22;
      v44 = v42;
      v45 = v24;
      sub_181BDA12C(v42, v24, 0);
      isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      v104 = (void *)*a2;
      v47 = v104;
      *a2 = 0x8000000000000000LL;
      v48 = v21;
      v50 = sub_181C8C01C(v21, v43);
      v51 = v47[2];
      v52 = (v49 & 1) == 0;
      v53 = v51 + v52;
      if (__OFADD__(v51, v52)) {
        goto LABEL_73;
      }
      v54 = v49;
      if (v47[3] < v53)
      {
        sub_181C8F71C(v53, isUniquelyReferenced_nonNull_native);
        v55 = sub_181C8C01C(v48, v43);
        if ((v54 & 1) != (v56 & 1)) {
          goto LABEL_80;
        }
        v50 = v55;
        v57 = v104;
        if ((v54 & 1) == 0) {
          goto LABEL_47;
        }
LABEL_4:
        uint64_t v11 = (uint64_t *)(v57[7] + 16 * v50);
        swift_bridgeObjectRelease();
        *uint64_t v11 = v44;
        v11[1] = v45;
LABEL_5:
        a2 = v99;
        *v99 = (uint64_t)v57;
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease();
        os_log_type_t v12 = v44;
        uint64_t v13 = v45;
        os_log_type_t v14 = 0;
LABEL_6:
        sub_181BDA14C(v12, v13, v14);
        goto LABEL_7;
      }

      if ((isUniquelyReferenced_nonNull_native & 1) != 0)
      {
        v57 = v104;
        if ((v49 & 1) != 0) {
          goto LABEL_4;
        }
      }

      else
      {
        sub_181C926B8();
        v57 = v104;
        if ((v54 & 1) != 0) {
          goto LABEL_4;
        }
      }

    if (!(_DWORD)v7)
    {
      uint64_t v11 = sub_18264E958();
    }

    return 0LL;
  }

  if (v5 == 1)
  {
    if (((v4 >> 38) & 3) != 1) {
      return 0LL;
    }
    uint64_t v6 = HIDWORD(v3) & 0x3F;
    uint64_t v7 = HIDWORD(v4) & 0x3F;
    if ((_DWORD)v6)
    {
      if ((_DWORD)v6 == 1) {
        return (_DWORD)v7 == 1 && (_DWORD)v3 == *a2;
      }
      return (_DWORD)v7 == 2 && (_DWORD)v3 == *a2;
    }

    goto LABEL_25;
  }

  os_log_type_t v10 = 0x8000000000LL;
  if (v3 == 0x8000000000LL || (os_log_type_t v10 = 0x8000000001LL, v3 == 0x8000000001LL))
  {
    if ((v4 & 0xFFFFFFFFFFLL) == v10) {
      return 1LL;
    }
  }

  else if ((v4 & 0xFFFFFFFFFFLL) == 0x8000000002LL)
  {
    return 1LL;
  }

  return 0LL;
}

          if (4 * v2 == v8 >> 14) {
            return 1LL;
          }
          break;
      }
    }
  }

  return 1LL;
}

      uint64_t v5 = 0LL;
      memset(v27, 0, sizeof(v27));
      uint64_t v26 = 0u;
    }

    os_log_type_t v14 = *(void *)(v21 + 8 * v15);
    if (v14)
    {
LABEL_14:
      uint64_t v13 = v15;
LABEL_11:
      uint64_t v5 = (v14 - 1) & v14;
      os_log_type_t v9 = __clz(__rbit64(v14)) + (v13 << 6);
      uint64_t v7 = v13;
      continue;
    }

    break;
  }

  while (1)
  {
    uint64_t v13 = v15 + 1;
    if (__OFADD__(v15, 1LL)) {
      break;
    }
    if (v13 >= v22)
    {
      uint64_t v7 = v22 - 1;
      goto LABEL_25;
    }

    os_log_type_t v14 = *(void *)(v21 + 8 * v13);
    ++v15;
    if (v14) {
      goto LABEL_11;
    }
  }

    os_log_type_t v12 = (v23 - 1) & v23;
    BOOL v15 = __clz(__rbit64(v23)) + (v9 << 6);
LABEL_12:
    char v16 = 16 * v15;
    uint64_t v17 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v15);
    char v19 = *v17;
    os_log_type_t v18 = v17[1];
    __int16 v20 = 4 * v15;
    LODWORD(v17) = *(_DWORD *)(*(void *)(v2 + 56) + v20);
    uint32_t v21 = (void *)(*(void *)(v4 + 48) + v16);
    char *v21 = v19;
    v21[1] = v18;
    *(_DWORD *)(*(void *)(v4 + 56) + v20) = (_DWORD)v17;
    BOOL result = (void *)swift_bridgeObjectRetain();
  }

  uint64_t v24 = v22 + 2;
  if (v24 >= v13) {
    goto LABEL_26;
  }
  __int16 v23 = *(void *)(v6 + 8 * v24);
  if (v23)
  {
    os_log_type_t v9 = v24;
    goto LABEL_25;
  }

  while (1)
  {
    os_log_type_t v9 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    __int16 v23 = *(void *)(v6 + 8 * v9);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }

    os_log_type_t v12 = (v28 - 1) & v28;
    BOOL v15 = __clz(__rbit64(v28)) + (v9 << 6);
LABEL_12:
    char v16 = 16 * v15;
    uint64_t v17 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v15);
    char v19 = *v17;
    os_log_type_t v18 = v17[1];
    __int16 v20 = 24 * v15;
    uint32_t v21 = *(void *)(v2 + 56) + v20;
    uint64_t v22 = *(void *)v21;
    __int16 v23 = *(void *)(v21 + 8);
    uint64_t v24 = (void *)(*(void *)(v4 + 48) + v16);
    __int16 v25 = *(_BYTE *)(v21 + 16);
    os_log_s *v24 = v19;
    v24[1] = v18;
    uint64_t v26 = *(void *)(v4 + 56) + v20;
    *(void *)uint64_t v26 = v22;
    *(void *)(v26 + 8) = v23;
    *(_BYTE *)(v26 + 16) = v25;
    swift_bridgeObjectRetain();
    BOOL result = (void *)sub_181BDA12C(v22, v23, v25);
  }

  unint64_t v29 = v27 + 2;
  if (v29 >= v13) {
    goto LABEL_26;
  }
  int v28 = *(void *)(v6 + 8 * v29);
  if (v28)
  {
    os_log_type_t v9 = v29;
    goto LABEL_25;
  }

  while (1)
  {
    os_log_type_t v9 = v29 + 1;
    if (__OFADD__(v29, 1LL)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    int v28 = *(void *)(v6 + 8 * v9);
    ++v29;
    if (v28) {
      goto LABEL_25;
    }
  }

    BOOL v15 = (v22 - 1) & v22;
    os_log_type_t v18 = __clz(__rbit64(v22)) + (v12 << 6);
LABEL_12:
    char v19 = *(void *)(v3 + 72) * v18;
    (*(void (**)(char *, unint64_t, uint64_t))(v3 + 16))(v5, *(void *)(v6 + 48) + v19, v2);
    __int16 v20 = 32 * v18;
    sub_181BF9894(*(void *)(v6 + 56) + v20, (uint64_t)v26);
    (*(void (**)(unint64_t, char *, uint64_t))(v3 + 32))(*(void *)(v8 + 48) + v19, v5, v2);
    BOOL result = sub_181C275FC(v26, (_OWORD *)(*(void *)(v8 + 56) + v20));
  }

  __int16 v23 = v21 + 2;
  if (v23 >= v16)
  {
LABEL_26:
    BOOL result = (void *)swift_release();
    uint64_t v1 = v24;
    goto LABEL_28;
  }

  uint64_t v22 = *(void *)(v25 + 8 * v23);
  if (v22)
  {
    os_log_type_t v12 = v23;
    goto LABEL_25;
  }

  while (1)
  {
    os_log_type_t v12 = v23 + 1;
    if (__OFADD__(v23, 1LL)) {
      break;
    }
    if (v12 >= v16) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void *)(v25 + 8 * v12);
    ++v23;
    if (v22) {
      goto LABEL_25;
    }
  }

    char v16 = (v24 - 1) & v24;
    char v19 = __clz(__rbit64(v24)) + (v13 << 6);
LABEL_12:
    __int16 v20 = *(void *)(v29 + 72) * v19;
    sub_181BC9248( *(void *)(v7 + 48) + v20,  (uint64_t)v6,  (uint64_t (*)(void))type metadata accessor for NWActorID);
    uint32_t v21 = 8 * v19;
    uint64_t v22 = *(void *)(*(void *)(v7 + 56) + 8 * v19);
    sub_181BC928C( (uint64_t)v6,  *(void *)(v9 + 48) + v20,  (uint64_t (*)(void))type metadata accessor for NWActorID);
    *(void *)(*(void *)(v9 + 56) + v21) = v22;
    BOOL result = (void *)swift_retain();
  }

  __int16 v25 = v23 + 2;
  if (v25 >= v17)
  {
LABEL_26:
    BOOL result = (void *)swift_release();
    BOOL v3 = v27;
    goto LABEL_28;
  }

  uint64_t v24 = *(void *)(v28 + 8 * v25);
  if (v24)
  {
    uint64_t v13 = v25;
    goto LABEL_25;
  }

  while (1)
  {
    uint64_t v13 = v25 + 1;
    if (__OFADD__(v25, 1LL)) {
      break;
    }
    if (v13 >= v17) {
      goto LABEL_26;
    }
    uint64_t v24 = *(void *)(v28 + 8 * v13);
    ++v25;
    if (v24) {
      goto LABEL_25;
    }
  }

    BOOL v15 = (v23 - 1) & v23;
    os_log_type_t v18 = __clz(__rbit64(v23)) + (v12 << 6);
LABEL_12:
    char v19 = *(void *)(v26 + 72) * v18;
    sub_181BC9248( *(void *)(v5 + 48) + v19,  (uint64_t)v4,  (uint64_t (*)(void))type metadata accessor for NWActorID);
    __int16 v20 = 16 * v18;
    uint32_t v21 = *(void *)(v7 + 48) + v19;
    uint64_t v27 = *(_OWORD *)(*(void *)(v5 + 56) + v20);
    sub_181BC928C((uint64_t)v4, v21, (uint64_t (*)(void))type metadata accessor for NWActorID);
    *(_OWORD *)(*(void *)(v7 + 56) + v20) = v27;
    BOOL result = (void *)swift_retain();
  }

  uint64_t v24 = v22 + 2;
  if (v24 >= v16)
  {
LABEL_26:
    BOOL result = (void *)swift_release();
    uint64_t v1 = v25;
    goto LABEL_28;
  }

  __int16 v23 = *(void *)(v9 + 8 * v24);
  if (v23)
  {
    os_log_type_t v12 = v24;
    goto LABEL_25;
  }

  while (1)
  {
    os_log_type_t v12 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v12 >= v16) {
      goto LABEL_26;
    }
    __int16 v23 = *(void *)(v9 + 8 * v12);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }

    os_log_type_t v14 = (v24 - 1) & v24;
    char v16 = __clz(__rbit64(v24)) + (v11 << 6);
LABEL_12:
    uint64_t v17 = 16 * v16;
    os_log_type_t v18 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v16);
    char v19 = *v18;
    __int16 v20 = v18[1];
    uint32_t v21 = *(void *)(v29 + 72) * v16;
    sub_181BC9248( *(void *)(v5 + 56) + v21,  (uint64_t)v4,  (uint64_t (*)(void))type metadata accessor for NWActorSystem.ServerRole);
    uint64_t v22 = (void *)(*(void *)(v7 + 48) + v17);
    const char *v22 = v19;
    v22[1] = v20;
    sub_181BC928C( (uint64_t)v4,  *(void *)(v7 + 56) + v21,  (uint64_t (*)(void))type metadata accessor for NWActorSystem.ServerRole);
    BOOL result = (void *)swift_bridgeObjectRetain();
  }

  __int16 v25 = v23 + 2;
  if (v25 >= v28)
  {
LABEL_26:
    BOOL result = (void *)swift_release();
    uint64_t v1 = v26;
    goto LABEL_28;
  }

  uint64_t v24 = *(void *)(v27 + 8 * v25);
  if (v24)
  {
    uint64_t v11 = v25;
    goto LABEL_25;
  }

  while (1)
  {
    uint64_t v11 = v25 + 1;
    if (__OFADD__(v25, 1LL)) {
      break;
    }
    if (v11 >= v28) {
      goto LABEL_26;
    }
    uint64_t v24 = *(void *)(v27 + 8 * v11);
    ++v25;
    if (v24) {
      goto LABEL_25;
    }
  }

  __break(1u);
  return result;
}

    os_log_type_t v12 = (v23 - 1) & v23;
    BOOL v15 = __clz(__rbit64(v23)) + (v9 << 6);
LABEL_12:
    char v16 = 16 * v15;
    uint64_t v17 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v15);
    char v19 = *v17;
    os_log_type_t v18 = v17[1];
    __int16 v20 = 32 * v15;
    sub_181BF9894(*(void *)(v2 + 56) + 32 * v15, (uint64_t)v26);
    uint32_t v21 = (void *)(*(void *)(v4 + 48) + v16);
    char *v21 = v19;
    v21[1] = v18;
    sub_181C275FC(v26, (_OWORD *)(*(void *)(v4 + 56) + v20));
    BOOL result = (void *)swift_bridgeObjectRetain();
  }

  uint64_t v24 = v22 + 2;
  if (v24 >= v13)
  {
LABEL_26:
    BOOL result = (void *)swift_release();
    uint64_t v1 = v25;
    goto LABEL_28;
  }

  __int16 v23 = *(void *)(v6 + 8 * v24);
  if (v23)
  {
    os_log_type_t v9 = v24;
    goto LABEL_25;
  }

  while (1)
  {
    os_log_type_t v9 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    __int16 v23 = *(void *)(v6 + 8 * v9);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }

    os_log_type_t v14 = (v21 - 1) & v21;
    char v16 = __clz(__rbit64(v21)) + (v11 << 6);
LABEL_12:
    uint64_t v17 = *(void *)(v2 + 72) * v16;
    (*(void (**)(char *, unint64_t, uint64_t))(v2 + 16))(v4, *(void *)(v5 + 48) + v17, v1);
    os_log_type_t v18 = 8 * v16;
    char v19 = *(void *)(*(void *)(v5 + 56) + 8 * v16);
    (*(void (**)(unint64_t, char *, uint64_t))(v2 + 32))(*(void *)(v7 + 48) + v17, v4, v1);
    *(void *)(*(void *)(v7 + 56) + v18) = v19;
    BOOL result = (void *)swift_retain();
  }

  uint64_t v22 = v20 + 2;
  if (v22 >= v26) {
    goto LABEL_26;
  }
  uint32_t v21 = *(void *)(v25 + 8 * v22);
  if (v21)
  {
    uint64_t v11 = v22;
    goto LABEL_25;
  }

  while (1)
  {
    uint64_t v11 = v22 + 1;
    if (__OFADD__(v22, 1LL)) {
      break;
    }
    if (v11 >= v26) {
      goto LABEL_26;
    }
    uint32_t v21 = *(void *)(v25 + 8 * v11);
    ++v22;
    if (v21) {
      goto LABEL_25;
    }
  }

    os_log_type_t v12 = (v26 - 1) & v26;
    BOOL v15 = __clz(__rbit64(v26)) + (v9 << 6);
LABEL_12:
    char v16 = 16 * v15;
    uint64_t v17 = (uint64_t *)(*(void *)(v2 + 48) + v16);
    char v19 = *v17;
    os_log_type_t v18 = v17[1];
    __int16 v20 = (uint64_t *)(*(void *)(v2 + 56) + v16);
    uint32_t v21 = *v20;
    uint64_t v22 = v20[1];
    __int16 v23 = (void *)(*(void *)(v4 + 48) + v16);
    os_log_s *v23 = v19;
    v23[1] = v18;
    uint64_t v24 = (void *)(*(void *)(v4 + 56) + v16);
    os_log_s *v24 = v21;
    v24[1] = v22;
    swift_bridgeObjectRetain();
    BOOL result = (void *)swift_bridgeObjectRetain();
  }

  uint64_t v27 = v25 + 2;
  if (v27 >= v13) {
    goto LABEL_26;
  }
  uint64_t v26 = *(void *)(v6 + 8 * v27);
  if (v26)
  {
    os_log_type_t v9 = v27;
    goto LABEL_25;
  }

  while (1)
  {
    os_log_type_t v9 = v27 + 1;
    if (__OFADD__(v27, 1LL)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    uint64_t v26 = *(void *)(v6 + 8 * v9);
    ++v27;
    if (v26) {
      goto LABEL_25;
    }
  }

  if (!v71)
  {
    if (!v68)
    {
LABEL_40:
      if (v57)
      {
        if (v54)
        {
          if (v51 == v48 && v53 == v49)
          {
          }

          else
          {
            __int16 v25 = sub_18264F4EC();
            BOOL result = 0LL;
          }

          if (v46 == v45 && v52 == v44) {
            goto LABEL_59;
          }
          uint64_t v26 = sub_18264F4EC();
          BOOL result = 0LL;
          if ((v26 & 1) != 0) {
            goto LABEL_59;
          }
          return result;
        }

        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }

      else if (!v54)
      {
LABEL_59:
        if (v40)
        {
          uint64_t v27 = v39;
          if (v39) {
            return (v38 == v35 && v41 == v36 || (sub_18264F4EC() & 1) != 0)
          }
                && v37 == v34
                && (v32 == v30 && v33 == v31 || (sub_18264F4EC() & 1) != 0);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
        }

        else
        {
          uint64_t v27 = v39;
          if (!v39) {
            return 1LL;
          }
        }

        sub_181BCECA4(v28, v27);
        sub_181BCECE0(v29, v40);
        BOOL v15 = v28;
        char v16 = v27;
        goto LABEL_51;
      }

      char v19 = v42;
      __int16 v20 = v54;
      sub_181BCECA4(v42, v54);
      uint32_t v21 = v43;
      uint64_t v22 = v57;
      goto LABEL_50;
    }

    free(backtrace_string);
    if (!v16) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v3 + 12);
  uint64_t v6 = (void *)*((void *)v3 + 4);
  if (v6)
  {
    free(v6);
    *((void *)v3 + 4) = 0LL;
  }

  uint64_t v7 = (void *)*((void *)v3 + 5);
  if (v7)
  {
    free(v7);
    *((void *)v3 + 5) = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 12);
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  v41 = __Block_byref_object_copy_;
  v42 = __Block_byref_object_dispose_;
  v43 = 0LL;
  uint64_t v8 = (unsigned __int8 *)*((void *)v3 + 2);
  v35[0] = MEMORY[0x1895F87A8];
  v35[1] = 3221225472LL;
  v35[2] = __nw_browse_result_remove_interface_block_invoke;
  v35[3] = &unk_189BC7960;
  uint64_t v36 = v5;
  v37 = buf;
  nw_array_apply(v8, (uint64_t)v35);
  os_log_type_t v9 = *(void **)(*(void *)&buf[8] + 40LL);
  os_log_type_t v10 = v9 != 0LL;
  if (v9)
  {
    uint64_t v11 = *((void *)v3 + 2);
    if (!v11 || *(void *)(v11 + 16) == *(void *)(v11 + 24))
    {
      os_log_type_t v12 = nw_array_create();
    }

    else
    {
      os_log_type_t v12 = nw_array_create();
      std::vector<nw_object_wrapper_t>::reserve( v12 + 16,  ((uint64_t)(*(void *)(v11 + 24) - *(void *)(v11 + 16)) >> 3) - 1);
      os_log_type_t v14 = *(void ***)(v11 + 16);
      uint64_t v13 = *(void ***)(v11 + 24);
      while (v14 != v13)
      {
        if (*v14 != v9) {
          nw_array_append(v12, *v14);
        }
        ++v14;
      }
    }

    uint64_t v22 = (void *)*((void *)v3 + 2);
    *((void *)v3 + 2) = v12;
  }

  _Block_object_dispose(buf, 8);
LABEL_39:

  return v10;
}

    operator delete(v19[0]);
    if ((v18 & 0x80000000) == 0)
    {
LABEL_14:
      if ((v16 & 0x80000000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_27;
    }

      abort();
    }

    uint64_t v6 = HIBYTE(cap);
    uint64_t v7 = (void *)this->__r_.__value_.__r.__words[0];
  }

  else
  {
    uint64_t v7 = this;
    if (__n > 0x16)
    {
      if (__n - 0x7FFFFFFFFFFFFFF7LL >= 0x800000000000001FLL)
      {
        uint64_t v8 = 22LL;
        os_log_type_t v9 = this;
        goto LABEL_8;
      }

      goto LABEL_25;
    }
  }

  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = this->__r_.__value_.__s.__size_;
  }

  if ((v6 & 0x80) != 0) {
    goto LABEL_23;
  }
  this->__r_.__value_.__s.__size_ = __n & 0x7F;
LABEL_24:
  *((_BYTE *)v7 + __n) = 0;
  return this;
}

      free(backtrace_string);
      if (!v5) {
        goto LABEL_136;
      }
      goto LABEL_75;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
    }

      free(backtrace_string);
      if (!v5) {
        goto LABEL_136;
      }
      goto LABEL_75;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_run_probes_block_invoke";
      _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
    }

      free(backtrace_string);
      if (!v6) {
        goto LABEL_138;
      }
      goto LABEL_74;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
    }

      free(backtrace_string);
      if (!v6) {
        goto LABEL_138;
      }
      goto LABEL_74;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
    }

      free(backtrace_string);
      if (!v6) {
        goto LABEL_138;
      }
      goto LABEL_74;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
    }

      free(backtrace_string);
      if (!v6) {
        goto LABEL_136;
      }
      goto LABEL_74;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
    }

      free(backtrace_string);
      if (!v6) {
        goto LABEL_136;
      }
      goto LABEL_74;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
    }

  if (v15) {
    free(v15);
  }
  *(_DWORD *)(a1 + 688) = 0;
LABEL_28:
  _Block_object_dispose(v41, 8);
  if ((v43 & 1) != 0 && v42) {
    os_release(v42);
  }
  _Block_object_dispose(buf, 8);
  if ((v58 & 1) != 0)
  {
    if (v57) {
      os_release(v57);
    }
  }

          free(v23);
          goto LABEL_26;
        }

        *(_DWORD *)buf = 136446210;
        v56 = "-[NWTCPConnection initWithUpgradeForConnection:]";
        uint64_t v26 = "%{public}s nw_connection_create failed, no backtrace";
        unint64_t v30 = v24;
        v31 = v28;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v30, v31, v26, buf, 0xCu);
        goto LABEL_24;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        v56 = "-[NWTCPConnection initWithUpgradeForConnection:]";
        v57 = 2082;
        v58 = v27;
        _os_log_impl( &dword_181A5C000,  v24,  v28,  "%{public}s nw_connection_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v27);
    }

    if (!v23) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }

  __nwlog_obj();
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v56 = "-[NWTCPConnection initWithUpgradeForConnection:]";
  __int16 v34 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v53 = 0;
  if (__nwlog_fault(v34, &type, &v53))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "-[NWTCPConnection initWithUpgradeForConnection:]";
        v37 = "%{public}s called with null connection.parameters";
        goto LABEL_78;
      }

  if (v9) {
    free(v9);
  }
LABEL_8:
}

  __int16 v25 = *(void *)(a1 + 32);
  if (!v25 || !*(void *)(v25 + 152))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v26 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_34;
    }
    v33 = *(void *)(a1 + 32);
    v57 = 136446466;
    v58 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
    v59 = 2114;
    v60 = v33;
    unint64_t v30 = "%{public}s [%{public}@] Ethernet Channel handle update: updated flow";
LABEL_32:
    v31 = v26;
    __int16 v32 = 22;
    goto LABEL_33;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v26 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v27 = *(void *)(a1 + 32);
    int v28 = *(void *)(v27 + 24);
    unint64_t v29 = (unsigned __int8 *)(v27 + 115);
    LODWORD(v27) = *(_DWORD *)(v27 + 168);
    v57 = 136447234;
    v58 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
    v59 = 2080;
    v60 = v28;
    v61 = 1042;
    v62 = 16;
    v63 = 2098;
    v64 = v29;
    v65 = 1024;
    v66 = v27;
    unint64_t v30 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: updated flow";
LABEL_29:
    v31 = v26;
    __int16 v32 = 44;
LABEL_33:
    _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEBUG, v30, (uint8_t *)&v57, v32);
  }

      goto LABEL_26;
    }

    __nwlog_obj();
    __int16 v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_candidate_manager_stop_awdl_resolver";
    v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v33, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_candidate_manager_stop_awdl_resolver";
          _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s called with null manager", buf, 0xCu);
        }
      }

      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        v38 = os_log_type_enabled(v34, type);
        if (backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_candidate_manager_stop_awdl_resolver";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v34,  v37,  "%{public}s called with null manager, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_54;
        }

        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_candidate_manager_stop_awdl_resolver";
          _os_log_impl(&dword_181A5C000, v34, v37, "%{public}s called with null manager, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v39 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_candidate_manager_stop_awdl_resolver";
          _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s called with null manager, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v7) {
    free(v7);
  }
LABEL_8:
}
    }
  }

  __int16 v23 = *(_WORD *)(a1 + 225);
  if (a3 == 8)
  {
    v23 |= 0x20u;
    *(_WORD *)(a1 + 225) = v23;
  }

  if ((v23 & 4) != 0)
  {
    if (a3 == 8 && a4 != 1005)
    {
      if (a5 >= 0x7C)
      {
        __nwlog_obj();
        v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "nw_ws_write_header";
          _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s ws.output: attempted to send close frame of >125 bytes",  buf,  0xCu);
        }

    goto LABEL_26;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v16 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
    *(_DWORD *)buf = 136446466;
    __int16 v34 = "nw_protocol_copy_ws_definition_block_invoke";
    unint64_t v35 = 2082;
    uint64_t v36 = v17;
    _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_ERROR, "%{public}s %{public}s CFHTTPMessageAppendBytes", buf, 0x16u);
  }

  nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 12);
  return 1LL;
}
  }

    if (v15) {
      free(v15);
    }
    goto LABEL_6;
  }

  nw_context_assert_queue(*((void **)v9 + 46));
  if ((*((_BYTE *)v9 + 607) & 4) != 0)
  {
    os_log_type_t v12 = nw_framer_parse_array( v9,  (void *)v9 + 71,  0,  0,  minimum_incomplete_length,  maximum_length,  (uint64_t)temp_buffer,  v10);
    goto LABEL_8;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v11 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_framer_parse_output";
    _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot parse output when not in output handler",  buf,  0xCu);
  }

LABEL_6:
  os_log_type_t v12 = 0;
LABEL_8:

  return v12;
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_7:

  return v7;
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_7:

  return v7;
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_7:

  return v7;
}

    if (v10) {
      free(v10);
    }
    uint64_t v4 = 0LL;
    goto LABEL_5;
  }

  uint64_t v4 = (void **)calloc(1uLL, 0x10uLL);
  if (v4)
  {
    uint64_t v5 = *a2;
    if (!*a2)
    {
LABEL_5:

      return (BOOL)v4;
    }

    uint64_t v7 = 0LL;
    goto LABEL_29;
  }

  uint64_t v7 = (void *)v6;
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v8 = *(_BYTE **)(a1 + 32);
  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint32_t v21 = 136446722;
      uint64_t v22 = "nw_resolver_set_update_handler_block_invoke";
      __int16 v23 = 2082;
      *(void *)uint64_t v24 = nw_endpoint_get_logging_description(v5);
      *(_WORD *)&v24[8] = 2114;
      *(void *)&v24[10] = v7;
      uint64_t v11 = "%{public}s found cached alternative %{public}s for %{public}@";
      os_log_type_t v12 = v9;
      uint64_t v13 = 32;
LABEL_28:
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_INFO, v11, (uint8_t *)&v21, v13);
    }

    if (v7) {
      free(v7);
    }
    goto LABEL_6;
  }

  if (!a2 || v3[11]) {
    goto LABEL_6;
  }
  uint64_t v5 = strdup(a2);
  if (v5)
  {
LABEL_5:
    v4[11] = v5;
LABEL_6:

    return;
  }

  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  char v19 = "strict_strdup";
  uint64_t v11 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v11))
  {
    free(v11);
    goto LABEL_5;
  }

  __break(1u);
}

    if (v7) {
      free(v7);
    }
    goto LABEL_6;
  }

  if (!a2 || v3[12]) {
    goto LABEL_6;
  }
  uint64_t v5 = strdup(a2);
  if (v5)
  {
LABEL_5:
    v4[12] = v5;
LABEL_6:

    return;
  }

  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  char v19 = "strict_strdup";
  uint64_t v11 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v11))
  {
    free(v11);
    goto LABEL_5;
  }

  __break(1u);
}

          free(backtrace_string);
          if (!v13) {
            goto LABEL_102;
          }
          goto LABEL_101;
        }
      }

      char v16 = nw_array_create();
      uint64_t v17 = (void *)*((void *)a1 + 13);
      *((void *)a1 + 13) = v16;

      os_log_type_t v18 = (void *)*((void *)a1 + 17);
      *((void *)a1 + 17) = 0LL;

      char v19 = (void *)*((void *)a1 + 18);
      *((void *)a1 + 18) = 0LL;

      *((_DWORD *)a1 + 46) = -1;
      *((void *)a1 + 22) = 0x40000000000LL;
      a1[190] &= 0x25u;
      *((_DWORD *)a1 + 10) = 0;
      __int16 v20 = (void *)*((void *)a1 + 6);
      *((void *)a1 + 6) = 0LL;

      if (v8)
      {
        uint32_t v21 = (id *)v8;
        uint64_t v22 = v21[2];

        __int16 v23 = v22;
        uint64_t v24 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v23,  0,  0);

        __int16 v25 = (void *)*((void *)a1 + 7);
        *((void *)a1 + 7) = v24;

        a1[190] |= 4u;
      }

      else if (v9)
      {
        uint64_t v26 = v9;
        uint64_t v27 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v26,  0,  0);

        __int16 v23 = (id)*((void *)a1 + 7);
        *((void *)a1 + 7) = v27;
      }

      else
      {
        v31 = nw_parameters_create();
        __int16 v23 = (id)*((void *)a1 + 7);
        *((void *)a1 + 7) = v31;
      }

      nw_parameters_set_reuse_local_address(*((nw_parameters_t *)a1 + 7), 1);
      __int16 v32 = nw_group_descriptor_copy(v7);
      v33 = (void *)*((void *)a1 + 8);
      *((void *)a1 + 8) = v32;

      __int16 v34 = (void *)*((void *)a1 + 8);
      if (v34)
      {
        unint64_t v35 = v34;
        uint64_t v36 = v35[2];

        if (v36 == 1 && nw_parameters_get_data_mode(*((void **)a1 + 7)) == 2)
        {
          if (nw_parameters_get_logging_disabled(*((void *)a1 + 7))) {
            goto LABEL_102;
          }
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          v37 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          {
            v38 = *((_DWORD *)a1 + 42);
            *(_DWORD *)buf = 136446466;
            v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
            v165 = 1024;
            *(_DWORD *)v166 = v38;
            _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] cannot create multicast connection group with stream mode parameters",  buf,  0x12u);
          }

    free(backtrace_string);
    if (!v25) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }

  os_log_type_t v9 = v5[8];
  if (!v9) {
    goto LABEL_16;
  }
  os_log_type_t v10 = v9;
  uint64_t v11 = v10[2];

  if (v11 == 1) {
    goto LABEL_35;
  }
  os_log_type_t v12 = v5[8];
  if (!v12) {
    goto LABEL_16;
  }
  uint64_t v13 = v12;
  os_log_type_t v14 = v13[2];

  if (v14 == 2) {
    goto LABEL_10;
  }
  BOOL v15 = v5[8];
  if (!v15)
  {
LABEL_16:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v24 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v64 = "nw_connection_group_copy_protocol_metadata_for_message";
    __int16 v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (os_log_s *)(id)gLogObj;
      uint64_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s Group descriptor is not set", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (!v61)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (os_log_s *)(id)gLogObj;
      v31 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl( &dword_181A5C000,  v26,  v31,  "%{public}s Group descriptor is not set, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v26 = (os_log_s *)(id)gLogObj;
    unint64_t v29 = type;
    unint64_t v30 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v29, "%{public}s Group descriptor is not set, no backtrace", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      v64 = "nw_connection_group_copy_protocol_metadata_for_message";
      v65 = 2082;
      v66 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v26,  v29,  "%{public}s Group descriptor is not set, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  char v16 = v15;
  uint64_t v17 = v16[2];

  if (v17 != 4)
  {
    if (v5[8])
    {
      __nwlog_obj();
      uint32_t v21 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = nw_group_descriptor_get_type(v5[8]);
      if (v22 > 4) {
        __int16 v23 = "unknown";
      }
      else {
        __int16 v23 = off_189BB74C8[v22];
      }
      *(_DWORD *)buf = 136446466;
      v64 = "nw_connection_group_copy_protocol_metadata_for_message";
      v65 = 2080;
      v66 = (void *)v23;
      __int16 v25 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (__nwlog_fault(v25, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v33 = type;
          if (os_log_type_enabled(v26, type))
          {
            __int16 v34 = nw_group_descriptor_get_type(v5[8]);
            if (v34 > 4) {
              unint64_t v35 = "unknown";
            }
            else {
              unint64_t v35 = off_189BB74C8[v34];
            }
            *(_DWORD *)buf = 136446466;
            v64 = "nw_connection_group_copy_protocol_metadata_for_message";
            v65 = 2080;
            v66 = (void *)v35;
            _os_log_impl(&dword_181A5C000, v26, v33, "%{public}s Unsupported group descriptor type: %s", buf, 0x16u);
          }

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v5 = v3[37];
  if (!v5 || (node = nw_hash_table_get_node(v5, a2, 8LL)) == 0)
  {
LABEL_40:
    uint64_t v7 = 0LL;
    goto LABEL_41;
  }

  uint64_t v7 = *(id *)(node + 48);
LABEL_41:

  return v7;
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v5 = v3[37];
  if (!v5 || (node = nw_hash_table_get_node(v5, a2, 8LL)) == 0)
  {
LABEL_40:
    uint64_t v7 = 0;
    goto LABEL_41;
  }

  uint64_t v7 = *(_BYTE *)(node + 168);
LABEL_41:

  return v7;
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v5 = v3[37];
  if (!v5 || (node = nw_hash_table_get_node(v5, a2, 8LL)) == 0)
  {
LABEL_40:
    uint64_t v7 = 0LL;
    goto LABEL_41;
  }

  uint64_t v7 = *(id *)(node + 96);
LABEL_41:

  return v7;
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v5 = v3[37];
  if (!v5 || (node = nw_hash_table_get_node(v5, a2, 8LL)) == 0)
  {
LABEL_40:
    uint64_t v7 = 0LL;
    goto LABEL_41;
  }

  uint64_t v7 = *(id *)(node + 104);
LABEL_41:

  return v7;
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v5 = v3[37];
  if (!v5 || (node = nw_hash_table_get_node(v5, a2, 8LL)) == 0)
  {
LABEL_40:
    uint64_t v7 = 0LL;
    goto LABEL_41;
  }

  uint64_t v7 = *(id *)(node + 112);
LABEL_41:

  return v7;
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v5 = v3[37];
  if (!v5 || (node = nw_hash_table_get_node(v5, a2, 8LL)) == 0)
  {
LABEL_40:
    uint64_t v7 = 0xFFFFFFFFLL;
    goto LABEL_41;
  }

  uint64_t v7 = *(unsigned int *)(node + 164);
LABEL_41:

  return v7;
}

      return;
    }
  }

  else
  {
  }

  uint64_t v7 = v4;
  *(void *)os_log_type_t type = 0LL;
  v31 = type;
  __int16 v32 = 0x2020000000LL;
  v33 = 0;
  flow_registration = (char *)v7->flow_registration;
  if (flow_registration)
  {
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL43nw_protocol_implementation_has_active_pathsP31NWConcrete_nw_protocol_instance_block_invoke;
    unint64_t v35 = (const char *)&unk_189BB76C0;
    uint64_t v36 = type;
    nw_hash_table_apply(flow_registration, (uint64_t)buf);
    os_log_type_t v9 = *((_BYTE *)v31 + 24) == 0;
    _Block_object_dispose(type, 8);

    if (!v9) {
      goto LABEL_8;
    }
  }

  else
  {
    _Block_object_dispose(type, 8);
  }

  uint64_t v11 = *(char **)v7->_anon_0;
  if (v11 == (char *)v7)
  {
LABEL_17:
    if ((SBYTE5(v7->flow_in_connected) & 0x80000000) == 0 && gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)&v7->flow_in_connected + 7;
        *(_WORD *)&buf[22] = 2080;
        unint64_t v35 = " ";
        _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDestroying protocol", buf, 0x20u);
      }
    }

    maximum_content_size = v7->maximum_content_size;
    if (maximum_content_size)
    {
      parent_definition = v7->parent_definition;
      var1 = (void (*)(NWConcrete_nw_protocol_definition *, unint64_t))parent_definition->extended_state->var1;
      if (var1)
      {
        var1(parent_definition, maximum_content_size);
        v7->maximum_content_size = 0LL;
      }
    }

    parameters = v7->parameters;
    if (parameters)
    {
      nw_association_unregister(parameters, v7);
      os_log_type_t v18 = v7->parameters;
      v7->parameters = 0LL;
    }

    wakeup = v7->wakeup;
    v7->wakeup = 0LL;

    *(void *)v7->_anon_0 = 0LL;
    BYTE4(v7->flow_in_connected) &= ~8u;
    nw_protocol_destroy((uint64_t)v7, 0LL);
    goto LABEL_25;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v12 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
  *(_WORD *)&buf[12] = 2048;
  *(void *)&buf[14] = v11;
  *(_WORD *)&buf[22] = 2048;
  unint64_t v35 = (const char *)v7;
  uint64_t v13 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v13))
  {
    free(v13);
    goto LABEL_17;
  }

  __break(1u);
}

  if (v6) {
    free(v6);
  }
LABEL_8:
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v4 = *(void *)(v3 + 72);
  if (!v4 || (uint64_t v5 = *(uint64_t (**)(id))(v4 + 48)) == 0LL)
  {
LABEL_40:
    uint64_t v6 = 0LL;
    goto LABEL_41;
  }

  uint64_t v6 = v5(v1);
LABEL_41:

  return v6;
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v4 = *(void *)(v3 + 72);
  if (!v4 || (uint64_t v5 = *(uint64_t (**)(id))(v4 + 24)) == 0LL)
  {
LABEL_40:
    uint64_t v6 = 0LL;
    goto LABEL_41;
  }

  uint64_t v6 = v5(v1);
LABEL_41:

  return v6;
}

    free(backtrace_string);
    goto LABEL_38;
  }

  uint64_t v4 = *(void *)(v3 + 72);
  if (!v4 || (uint64_t v5 = *(uint64_t (**)(void))(v4 + 32)) == 0LL)
  {
LABEL_40:
    uint64_t v6 = 0LL;
    goto LABEL_41;
  }

  uint64_t v6 = v5();
LABEL_41:

  return v6;
}

  if (v11) {
    free(v11);
  }
  uint64_t v8 = 0LL;
LABEL_8:

  return v8;
}

        _os_crash();
        __break(1u);
        goto LABEL_26;
      }
    }

    else
    {
      _os_crash();
      __break(1u);
    }

    BOOL v3 = 0LL;
    goto LABEL_21;
  }

  uint64_t v8 = objc_alloc(&OBJC_CLASS___NWURLSessionRequestBodyFile);
  os_log_type_t v9 = v3[5];
  os_log_type_t v10 = v3[3];
  uint64_t v11 = (dispatch_queue_s *)v9;
  if (v8)
  {
    v27.receiver = v8;
    v27.super_class = (Class)&OBJC_CLASS___NWURLSessionRequestBodyFile;
    BOOL v3 = objc_msgSendSuper2(&v27, sel_init);
    if (v3)
    {
      os_log_type_t v12 = open((const char *)[v10 fileSystemRepresentation], 0);
      if (v12 < 0)
      {
        *((_DWORD *)v3 + 2) = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }

      else
      {
        uint64_t v13 = v12;
        if (v4)
        {
          lseek(v12, (off_t)v4, 0);
          v3[4] = v4;
        }

        cleanup_handler.receiver = (id)MEMORY[0x1895F87A8];
        cleanup_handler.super_class = (Class)3221225472LL;
        uint64_t v24 = __60__NWURLSessionRequestBodyFile_initWithFileURL_offset_queue___block_invoke;
        __int16 v25 = &__block_descriptor_36_e8_v12__0i8l;
        uint64_t v26 = v13;
        os_log_type_t v14 = dispatch_io_create(0LL, v13, v11, &cleanup_handler);
        BOOL v15 = v3[2];
        v3[2] = v14;

        dispatch_io_set_low_water((dispatch_io_t)v3[2], 0xFFFFFFFFFFFFFFFFLL);
        objc_storeStrong(v3 + 3, v9);
      }
    }
  }

  else
  {
    BOOL v3 = 0LL;
  }

  return v3;
}
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (id)gLogObj;
  if (mode > 5) {
    os_log_type_t v14 = "unknown-mode";
  }
  else {
    os_log_type_t v14 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  unint64_t v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
  unint64_t v30 = 2082;
  v31 = (void *)v14;
  __int16 v32 = 2082;
  v33 = "flow";
  BOOL v15 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v26 = 0;
  if (!__nwlog_fault((const char *)v15, &type, &v26))
  {
LABEL_44:
    if (!v15) {
      goto LABEL_46;
    }
LABEL_45:
    free(v15);
    goto LABEL_46;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v16 = (os_log_s *)(id)gLogObj;
    uint64_t v17 = type;
    if (os_log_type_enabled(v16, type))
    {
      if (mode > 5) {
        os_log_type_t v18 = "unknown-mode";
      }
      else {
        os_log_type_t v18 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      unint64_t v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
      unint64_t v30 = 2082;
      v31 = (void *)v18;
      __int16 v32 = 2082;
      v33 = "flow";
      _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

    free(backtrace_string);
    goto LABEL_35;
  }

  uint64_t v8 = (os_log_s *)__nwlog_obj();
  os_log_type_t v9 = v21;
  if (os_log_type_enabled(v8, v21))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_trainer_bottom_finalize_output_frames";
    os_log_type_t v10 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
  }

    free(backtrace_string);
    goto LABEL_35;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "nw_protocol_trainer_connect";
    uint64_t v7 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
  }

  if (v12) {
    free(v12);
  }
LABEL_8:
}

  if (v11) {
    free(v11);
  }
LABEL_8:
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_8:

  return v7;
}

  return v12;
}

    if (v10) {
      free(v10);
    }
    uint64_t v4 = v25;
    if (!v25) {
      return 0LL;
    }
    __int16 v20 = (void *)*((void *)v25 + 1);
    if (v20)
    {
      free(v20);
      v4[1] = 0LL;
    }

    uint32_t v21 = (void *)v4[2];
    if (v21)
    {
      free(v21);
      v4[2] = 0LL;
    }

    uint64_t v8 = (void *)v4[4];
    if (!v8)
    {
      BOOL v3 = 0LL;
      goto LABEL_34;
    }

    goto LABEL_33;
  }

  return 0LL;
}

    if (v10) {
      free(v10);
    }
    uint64_t v4 = v25;
    if (!v25) {
      return 0LL;
    }
    __int16 v20 = (void *)*((void *)v25 + 1);
    if (v20)
    {
      free(v20);
      v4[1] = 0LL;
    }

    uint32_t v21 = (void *)v4[2];
    if (v21)
    {
      free(v21);
      v4[2] = 0LL;
    }

    uint64_t v8 = (void *)v4[4];
    if (!v8)
    {
      BOOL v3 = 0LL;
      goto LABEL_34;
    }

    goto LABEL_33;
  }

  return 0LL;
}
}

            goto LABEL_26;
          }

          __int16 v32 = [v31 longLongValue];
          v33 = 0x7FFFFFFF;
          if (v32 <= 0x7FFFFFFF)
          {
            else {
              v33 = 0x80000000;
            }
          }

          LODWORD(v91) = v33;

          v50 = (const char *)[v30 UTF8String];
          LODWORD(v87) = 0;
          type[0] = 4LL;
          if (!sysctlbyname(v50, &v87, type, 0LL, 0LL) && type[0] == 4)
          {
            if ((_DWORD)v91 == (_DWORD)v87) {
              goto LABEL_26;
            }
LABEL_83:
            if (!sysctlbyname(v50, 0LL, 0LL, &v91, 4uLL))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v41 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                v105 = 136446978;
                v106 = "-[ManagedNetworkSettings reloadMNS]";
                v107 = 2114;
                v108[0] = v30;
                LOWORD(v108[1]) = 1024;
                *(_DWORD *)((char *)&v108[1] + 2) = v87;
                HIWORD(v108[1]) = 1024;
                LODWORD(v108[2]) = v91;
                v42 = v41;
                v43 = OS_LOG_TYPE_DEFAULT;
                v44 = "%{public}s MNS successfully set sysctl %{public}@ from %d to %d";
                v45 = 34;
LABEL_24:
                _os_log_impl(&dword_181A5C000, v42, v43, v44, (uint8_t *)&v105, v45);
              }

              goto LABEL_25;
            }

            v63 = **(_DWORD **)(StatusReg + 8);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v64 = (os_log_s *)(id)gLogObj;
            v65 = v64;
            if (v63 == 45)
            {
              if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
              {
                v105 = 136446978;
                v106 = "-[ManagedNetworkSettings reloadMNS]";
                v107 = 1024;
                LODWORD(v108[0]) = v91;
                WORD2(v108[0]) = 2114;
                *(void *)((char *)v108 + 6) = v30;
                HIWORD(v108[1]) = 1024;
                LODWORD(v108[2]) = 45;
                _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_ERROR,  "%{public}s MNS error writing %d to sysctl %{public}@ %{darwin.errno}d",  (uint8_t *)&v105,  0x22u);
              }

              goto LABEL_26;
            }

            v105 = 136446978;
            v106 = "-[ManagedNetworkSettings reloadMNS]";
            v107 = 1024;
            LODWORD(v108[0]) = v91;
            WORD2(v108[0]) = 2114;
            *(void *)((char *)v108 + 6) = v30;
            HIWORD(v108[1]) = 1024;
            v79 = v63;
            LODWORD(v108[2]) = v63;
            v66 = (char *)_os_log_send_and_compose_impl();

            LOBYTE(buf) = 16;
            v82 = 0;
            if (__nwlog_fault(v66, &buf, &v82))
            {
              if (buf != 17)
              {
                if (v82)
                {
                  v72 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v67 = (os_log_s *)(id)gLogObj;
                  v76 = buf;
                  v73 = os_log_type_enabled(v67, (os_log_type_t)buf);
                  if (v72)
                  {
                    if (v73)
                    {
                      v105 = 136447234;
                      v106 = "-[ManagedNetworkSettings reloadMNS]";
                      v107 = 1024;
                      LODWORD(v108[0]) = v91;
                      WORD2(v108[0]) = 2114;
                      *(void *)((char *)v108 + 6) = v30;
                      HIWORD(v108[1]) = 1024;
                      LODWORD(v108[2]) = v79;
                      WORD2(v108[2]) = 2082;
                      *(void *)((char *)&v108[2] + 6) = v72;
                      _os_log_impl( &dword_181A5C000,  v67,  v76,  "%{public}s MNS error writing %d to sysctl %{public}@ %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)&v105,  0x2Cu);
                    }

                    free(v72);
                    goto LABEL_105;
                  }

                  if (!v73) {
                    goto LABEL_104;
                  }
                  v105 = 136446978;
                  v106 = "-[ManagedNetworkSettings reloadMNS]";
                  v107 = 1024;
                  LODWORD(v108[0]) = v91;
                  WORD2(v108[0]) = 2114;
                  *(void *)((char *)v108 + 6) = v30;
                  HIWORD(v108[1]) = 1024;
                  LODWORD(v108[2]) = v79;
                  v69 = v67;
                  v70 = v76;
                  v71 = "%{public}s MNS error writing %d to sysctl %{public}@ %{darwin.errno}d, no backtrace";
                }

                else
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v67 = (os_log_s *)(id)gLogObj;
                  v74 = buf;
                  if (!os_log_type_enabled(v67, (os_log_type_t)buf)) {
                    goto LABEL_104;
                  }
                  v105 = 136446978;
                  v106 = "-[ManagedNetworkSettings reloadMNS]";
                  v107 = 1024;
                  LODWORD(v108[0]) = v91;
                  WORD2(v108[0]) = 2114;
                  *(void *)((char *)v108 + 6) = v30;
                  HIWORD(v108[1]) = 1024;
                  LODWORD(v108[2]) = v79;
                  v69 = v67;
                  v70 = v74;
                  v71 = "%{public}s MNS error writing %d to sysctl %{public}@ %{darwin.errno}d, backtrace limit exceeded";
                }

  if (v7) {
    free(v7);
  }
}

    if (v13) {
      free(v13);
    }
    goto LABEL_27;
  }

  BOOL v3 = v1;
  uint64_t v4 = v3[94];

  if (v4 != 2)
  {
LABEL_27:
    uint64_t v7 = 1LL;
    goto LABEL_28;
  }

  uint64_t v5 = v3;
  uint64_t v6 = v5[95];

  uint64_t v7 = 1LL;
  if (v6 == 2)
  {
    *(void *)uint64_t v27 = 0LL;
    *(void *)&v27[8] = v27;
    *(void *)&v27[16] = 0x2020000000LL;
    int v28 = 1;
    uint64_t v8 = (unsigned __int8 *)nw_path_copy_proxy_configs(v5);
    os_log_type_t v9 = v8;
    if (v8)
    {
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_endpoint_proxy_unsatisfied_handler_should_use_proxy_block_invoke;
      v21[3] = &unk_189BC50D0;
      v21[4] = v27;
      nw_array_apply(v8, (uint64_t)v21);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = *(unsigned __int8 *)(*(void *)&v27[8] + 24LL);
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
      __int16 v25 = 1024;
      uint64_t v26 = v11;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s unsatisfied path allowed to use proxy: %d",  buf,  0x12u);
    }

    uint64_t v7 = *(_BYTE *)(*(void *)&v27[8] + 24LL) != 0;
    _Block_object_dispose(v27, 8);
  }

    free(backtrace_string);
    goto LABEL_35;
  }

  uint64_t v8 = (os_log_s *)__nwlog_obj();
  os_log_type_t v9 = v21;
  if (os_log_type_enabled(v8, v21))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_ohttp_finalize_output_frames";
    os_log_type_t v10 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
  }

      goto LABEL_26;
    }

    if (!v33)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v36 = "nw_endpoint_handler_get_mode";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_25;
    }

    uint64_t v13 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v11, type);
    if (!v13)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v36 = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_25;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_endpoint_handler_get_mode";
      v37 = 2082;
      v38 = v13;
      _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v13);
  }

      os_unfair_lock_unlock(v7 + 220);
LABEL_26:

      *(_BYTE *)(*(void *)&v39[8] + 24LL) = v9;
      goto LABEL_27;
    }

    __nwlog_obj();
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
    __int16 v25 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v25, type, &v38))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v27 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v32 = type[0];
        v33 = os_log_type_enabled(v26, type[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
            v42 = 2082;
            v43 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v26,  v32,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_64;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_181A5C000, v26, v32, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v35 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl( &dword_181A5C000,  v26,  v35,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(backtrace_string);
    goto LABEL_38;
  }

  nw_endpoint_handler_initialize_association(v3);
  uint64_t v5 = (void *)*((void *)v4 + 7);
  if (!v5 || (uint64_t v6 = nw_association_copy_current_path(v5, *((void **)v4 + 4)), (v7 = v6) == 0LL))
  {
LABEL_40:
    uint64_t v8 = 0LL;
    goto LABEL_41;
  }

  uint64_t v8 = nw_path_fillout_route_stats(v6, a2, 0LL);

LABEL_41:
  return v8;
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_8:

  return v7;
}

                goto LABEL_38;
              }

              if (!v72)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                __int16 v34 = (os_log_s *)(id)gLogObj;
                v40 = type;
                if (os_log_type_enabled(v34, type))
                {
                  *(_DWORD *)buf = 136446210;
                  v75 = "nw_pac_resolver_create_with_script";
                  _os_log_impl( &dword_181A5C000,  v34,  v40,  "%{public}s nw_pac_resolver_obj_alloc failed, backtrace limit exceeded",  buf,  0xCu);
                }

                goto LABEL_25;
              }

              backtrace_string = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v37 = (os_log_s *)(id)gLogObj;
              v38 = type;
              v39 = os_log_type_enabled(v37, type);
              if (backtrace_string)
              {
                if (v39)
                {
                  *(_DWORD *)buf = 136446466;
                  v75 = "nw_pac_resolver_create_with_script";
                  v76 = 2082;
                  v77 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s nw_pac_resolver_obj_alloc failed, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(backtrace_string);
                if (!v33) {
                  goto LABEL_40;
                }
                goto LABEL_39;
              }

              if (v39)
              {
                *(_DWORD *)buf = 136446210;
                v75 = "nw_pac_resolver_create_with_script";
                _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s nw_pac_resolver_obj_alloc failed, no backtrace",  buf,  0xCu);
              }
            }

    free(v9);
    goto LABEL_26;
  }

  BOOL v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_connection_multipath_get_subflow_count";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_26;
  }

  uint64_t v4 = v3;
  *(void *)os_log_type_t type = 0LL;
  __int16 v20 = type;
  uint64_t v22 = 0;
  uint32_t v21 = 0x2020000000LL;
  uint64_t v5 = v4 + 34;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = __nw_connection_multipath_get_subflow_count_block_invoke;
  uint64_t v24 = &unk_189BC9210;
  uint64_t v6 = v4;
  __int16 v25 = v6;
  uint64_t v26 = type;
  os_unfair_lock_lock(v5);
  __nw_connection_multipath_get_subflow_count_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v5);
  uint64_t v7 = *((unsigned int *)v20 + 6);

  _Block_object_dispose(type, 8);
LABEL_27:

  return v7;
}

    free(v9);
    goto LABEL_26;
  }

  BOOL v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_connection_get_unsent_length";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_26;
  }

  uint64_t v4 = v3;
  *(void *)os_log_type_t type = 0LL;
  __int16 v20 = type;
  uint64_t v22 = 0;
  uint32_t v21 = 0x2020000000LL;
  uint64_t v5 = v4 + 34;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = __nw_connection_get_unsent_byte_count_block_invoke;
  uint64_t v24 = &unk_189BC9210;
  uint64_t v6 = v4;
  __int16 v25 = v6;
  uint64_t v26 = type;
  os_unfair_lock_lock(v5);
  __nw_connection_get_unsent_byte_count_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v5);
  uint64_t v7 = *((unsigned int *)v20 + 6);

  _Block_object_dispose(type, 8);
LABEL_27:

  return v7;
}

    free(v7);
    goto LABEL_26;
  }

  BOOL v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      char v19 = "tcp_connection_copy_description";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_26;
  }

  uint64_t v4 = v3;
  uint64_t v5 = nw_connection_copy_description_level(v4, 1);

LABEL_27:
  return v5;
}

  if (v7) {
    free(v7);
  }
  return 1LL;
}

  uint64_t v17 = 0LL;
  if ((*(_WORD *)&self->_has & 0x2000) != 0)
  {
LABEL_11:
    os_log_type_t v18 = 2654435761LL * self->_useAWDL;
    if ((*(_WORD *)&self->_has & 0x4000) != 0) {
      goto LABEL_12;
    }
    goto LABEL_27;
  }

    free(backtrace_string);
    goto LABEL_35;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_http2_transport_get_remote_endpoint";
    os_log_type_t v9 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
  }

        nw_http2_transport_session_send(a1);
        goto LABEL_26;
      }

      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_25;
      }
      os_log_type_t v18 = *v4;
      *(_DWORD *)buf = 136446722;
      v63 = "nw_http2_transport_stream_send_rst_stream";
      v64 = 2082;
      v65 = (void *)(a1 + 205);
      v66 = 1024;
      v67 = v18;
      os_log_type_t v12 = "%{public}s %{public}s Submitted RST_STREAM on stream %d";
      uint64_t v13 = (os_log_s *)v9;
      os_log_type_t v14 = OS_LOG_TYPE_INFO;
    }

    BOOL v15 = 28;
    goto LABEL_24;
  }

  *(_BYTE *)(a2 + 36) = v5 & 0xFE;
  *(_DWORD *)(a2 + 32) = -1;
  if (gLogDatapath)
  {
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v63 = "nw_http2_transport_stream_close";
      v64 = 2082;
      v65 = (void *)(a1 + 205);
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s stream id is -1, skipping rst_stream and removal from id based table",  buf,  0x16u);
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v19 = nghttp2_strerror();
  *(_DWORD *)buf = 136446466;
  uint64_t v36 = "nw_http2_transport_send_settings";
  v37 = 2082;
  v38 = v19;
  __int16 v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v20, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v21 = (os_log_s *)gLogObj;
      uint64_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      __int16 v23 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_http2_transport_send_settings";
      v37 = 2082;
      v38 = v23;
      uint64_t v24 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed";
      goto LABEL_40;
    }

    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v21 = (os_log_s *)gLogObj;
      uint64_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      int v28 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_http2_transport_send_settings";
      v37 = 2082;
      v38 = v28;
      uint64_t v24 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, backtrace limit exceeded";
      goto LABEL_40;
    }

    __int16 v25 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v21 = (os_log_s *)gLogObj;
    uint64_t v22 = type;
    uint64_t v26 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v25)
    {
      if (v26)
      {
        uint64_t v27 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        uint64_t v36 = "nw_http2_transport_send_settings";
        v37 = 2082;
        v38 = v27;
        v39 = 2082;
        v40 = v25;
        _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v25);
      goto LABEL_41;
    }

    if (v26)
    {
      unint64_t v29 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_http2_transport_send_settings";
      v37 = 2082;
      v38 = v29;
      uint64_t v24 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, no backtrace";
LABEL_40:
      _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x16u);
    }
  }

      _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0x16u);
      goto LABEL_26;
    }

      free(v14);
      goto LABEL_26;
    }

    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_proxy_config_create_with_stack";
    __int16 v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v35 = 0;
    if (__nwlog_fault(v23, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v27 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_proxy_config_create_with_stack";
          _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null stack", buf, 0xCu);
        }

    if (!v9)
    {
LABEL_27:
      uint64_t v7 = 0LL;
      goto LABEL_28;
    }

    if (gLogDatapath)
    {
      v49 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v19;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v260;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v12 + 616;
        _os_log_impl(&dword_181A5C000, v49, OS_LOG_TYPE_DEBUG, "%{public}s moved %u frames from %p to %p", buf, 0x26u);
      }
    }

      *(void *)(v11 + 80) = 0LL;
      *(void *)(v11 + 88) = 0LL;
      nw_frame_cache_return_frame(v344, v11);
      uint64_t v11 = *v10;
LABEL_26:
      if (!v11) {
        goto LABEL_373;
      }
      continue;
    }

    break;
  }

  v117 = v345;
  if ((*(_BYTE *)(v9 + 158) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v234 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v235 = *(void *)(v9 + 488);
      v236 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
      v237 = *(_DWORD *)(v9 + 860);
      if (v235) {
        LODWORD(v235) = *(_DWORD *)(v235 + 424);
      }
      *(_DWORD *)buf = 136448002;
      v364 = "nw_http1_connection_drain_outbound_frames";
      v365 = 2082;
      *(void *)v366 = v347;
      *(_WORD *)&v366[8] = 2080;
      *(void *)&v366[10] = " ";
      v367 = 1024;
      *(_DWORD *)v368 = v236;
      *(_WORD *)&v368[4] = 1024;
      *(_DWORD *)&v368[6] = v237;
      LOWORD(v369) = 1024;
      *(_DWORD *)((char *)&v369 + 2) = v235;
      HIWORD(v369) = 1024;
      *(_DWORD *)v370 = __len[0];
      *(_WORD *)&v370[4] = 1024;
      *(_DWORD *)&v370[6] = v18;
      _os_log_impl( &dword_181A5C000,  v234,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%s<i%u:c%u:s%u> could not send pending output frame of length %u sent %u",  buf,  0x3Eu);
    }
  }

  if (v12) {
    char v19 = v14 == 0;
  }
  else {
    char v19 = 1;
  }
  if (!v19) {
    return nw_protocol_updated_path(v14, v12, (uint64_t)a3);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  BOOL v3 = 0.5;
LABEL_8:

  return v3;
}

  if (v6) {
    free(v6);
  }
  BOOL v3 = 0LL;
LABEL_8:

  return v3;
}

        os_log_type_t v18 = [v13 writeToFile:v10 atomically:1];
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v19 = (os_log_s *)(id)gLogObj;
        __int16 v20 = v19;
        if ((v18 & 1) != 0)
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            v40 = "handleSetNetworkdSetting";
            v41 = 2114;
            *(void *)v42 = v9;
            _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully changed value of setting %{public}@",  buf,  0x16u);
          }

          goto LABEL_32;
        }

        *(_DWORD *)buf = 136446466;
        v40 = "handleSetNetworkdSetting";
        v41 = 2114;
        *(void *)v42 = v10;
        __int16 v23 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v37 = 0;
        if (!__nwlog_fault((const char *)v23, &type, &v37))
        {
LABEL_65:
          if (v23) {
            free(v23);
          }

          uint64_t v11 = 5LL;
          goto LABEL_33;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v24 = (os_log_s *)(id)gLogObj;
          __int16 v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446466;
            v40 = "handleSetNetworkdSetting";
            v41 = 2114;
            *(void *)v42 = v10;
            uint64_t v26 = "%{public}s settings writeToFile:%{public}@ failed";
LABEL_63:
            _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0x16u);
          }
        }

        else
        {
          if (v37)
          {
            uint64_t v27 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            __int16 v25 = type;
            int v28 = os_log_type_enabled(v24, type);
            if (v27)
            {
              if (v28)
              {
                *(_DWORD *)buf = 136446722;
                v40 = "handleSetNetworkdSetting";
                v41 = 2114;
                *(void *)v42 = v10;
                *(_WORD *)&v42[8] = 2082;
                *(void *)&v42[10] = v27;
                _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s settings writeToFile:%{public}@ failed, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v27);
              goto LABEL_65;
            }

            if (!v28) {
              goto LABEL_64;
            }
            *(_DWORD *)buf = 136446466;
            v40 = "handleSetNetworkdSetting";
            v41 = 2114;
            *(void *)v42 = v10;
            uint64_t v26 = "%{public}s settings writeToFile:%{public}@ failed, no backtrace";
            goto LABEL_63;
          }

          __nwlog_obj();
          uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446466;
            v40 = "handleSetNetworkdSetting";
            v41 = 2114;
            *(void *)v42 = v10;
            uint64_t v26 = "%{public}s settings writeToFile:%{public}@ failed, backtrace limit exceeded";
            goto LABEL_63;
          }
        }

  if (v3) {
    free(v3);
  }
}

  if (v9) {
    free(v9);
  }
  size = 0LL;
LABEL_7:

  return size;
}

      free(backtrace_string);
      goto LABEL_35;
    }

    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    uint64_t v11 = type[0];
    if (!os_log_type_enabled(v10, type[0])) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    os_log_type_t v12 = "%{public}s called with null from_array";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
LABEL_35:
    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      uint64_t v11 = type[0];
      if (!os_log_type_enabled(v10, type[0])) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
      os_log_type_t v12 = "%{public}s called with null to_array";
      goto LABEL_34;
    }

    if (!v31)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      uint64_t v11 = type[0];
      if (!os_log_type_enabled(v10, type[0])) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
      os_log_type_t v12 = "%{public}s called with null to_array, backtrace limit exceeded";
      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    uint64_t v11 = type[0];
    char v16 = os_log_type_enabled(v10, type[0]);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        BOOL v15 = "%{public}s called with null to_array, dumping backtrace:%{public}s";
        goto LABEL_24;
      }

      goto LABEL_25;
    }

    if (!v16) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    os_log_type_t v12 = "%{public}s called with null to_array, no backtrace";
    goto LABEL_34;
  }

  uint64_t v5 = *a1;
  if (!*a1) {
    return 0LL;
  }
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  v33 = 0;
  *(void *)&buf[16] = 0x2000000000LL;
  *(void *)os_log_type_t type = 0LL;
  int v28 = type;
  unint64_t v30 = 0;
  unint64_t v29 = 0x2000000000LL;
  v18[0] = MEMORY[0x1895F87A8];
  v18[1] = 0x40000000LL;
  char v19 = __nw_frame_array_fill_from_pending_array_block_invoke;
  __int16 v20 = &unk_189BBF250;
  uint32_t v21 = buf;
  uint64_t v22 = type;
  __int16 v25 = a4;
  uint64_t v26 = a3;
  __int16 v23 = a1;
  uint64_t v24 = a2;
  do
  {
    if (!v5) {
      break;
    }
    uint64_t v6 = *(void *)(v5 + 32);
    uint64_t v7 = ((uint64_t (*)(void *))v19)(v18);
    uint64_t v5 = v6;
  }

  while ((v7 & 1) != 0);
  uint64_t v8 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v8;
}

  if (v2) {
    operator delete(v2);
  }
  return v15;
}

    if (!v17)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = v16;
      __int16 v20 = v2;
      os_log_type_t v9 = "%{public}s called with null to, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    uint64_t v13 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (!v13) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446466;
      __int16 v20 = "nw_array_assign";
      uint32_t v21 = 2082;
      uint64_t v22 = backtrace_string;
      os_log_type_t v14 = "%{public}s called with null to, dumping backtrace:%{public}s";
      goto LABEL_33;
    }

    if (v13)
    {
      *(_DWORD *)buf = v16;
      __int16 v20 = "nw_array_assign";
      os_log_type_t v9 = "%{public}s called with null to, no backtrace";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      goto LABEL_45;
    }

    goto LABEL_45;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_array_assign";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v20 = "nw_array_assign";
      os_log_type_t v9 = "%{public}s called with null from";
      goto LABEL_44;
    }

    if (!v17)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v20 = "nw_array_assign";
      os_log_type_t v9 = "%{public}s called with null from, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    uint64_t v8 = type;
    BOOL v15 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (!v15) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446466;
      __int16 v20 = "nw_array_assign";
      uint32_t v21 = 2082;
      uint64_t v22 = backtrace_string;
      os_log_type_t v14 = "%{public}s called with null from, dumping backtrace:%{public}s";
LABEL_33:
      _os_log_impl(&dword_181A5C000, v7, v8, v14, buf, 0x16u);
LABEL_34:
      free(backtrace_string);
      if (!v6) {
        return;
      }
LABEL_46:
      free(v6);
      return;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v20 = "nw_array_assign";
      os_log_type_t v9 = "%{public}s called with null from, no backtrace";
      goto LABEL_44;
    }

  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0LL;
LABEL_8:

  return v6;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_27;
  }

  proxy_agent = (const char *)nw_resolver_config_get_proxy_agent(v1);
  if (!proxy_agent)
  {
LABEL_27:
    uint64_t v5 = 0LL;
    goto LABEL_28;
  }

  *(void *)uu = 0LL;
  *(void *)&uu[8] = 0LL;
  uuid_parse(proxy_agent, uu);
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  }
  uint64_t v4 = (id)nw_context_copy_implicit_context::implicit_context;
  *(void *)os_log_type_t type = v4;
  os_log_type_t v18 = -1;
  uint64_t v5 = nw_path_copy_proxy_config_for_agent_uuid(uu, 0xFFFFFFFF, v4);
  if (v4) {

  }
  if (v5)
  {
    uint64_t v6 = v2[23];
    uint64_t v7 = v5;
    v7[41] = v6;
  }

    __break(1u);
    return;
  }

  if (v7) {
    free(v7);
  }
LABEL_3:

  nw_protocol_definition_set_cache_entry_deallocator( (void *)nw_protocol_copy_quic_connection_definition::quic_definition,  nw_quic_deallocate_cache_entry);
  nw_protocol_definition_set_should_flush_cache_entry( (void *)nw_protocol_copy_quic_connection_definition::quic_definition,  nw_quic_should_flush_cache_entry);
  uint64_t v4 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (quic_fillout_definition_callbacks_override)
  {
    os_log_type_t v14 = v4;
    quic_fillout_definition_callbacks_override(v4, v5);
LABEL_7:

    nw_protocol_definition_register((void *)nw_protocol_copy_quic_connection_definition::quic_definition);
    return;
  }

  if (MEMORY[0x189617048])
  {
    os_log_type_t v14 = v4;
    quic_fillout_definition_callbacks();
    goto LABEL_7;
  }
}

  __int16 v20 = 0LL;
LABEL_26:
  uint32_t v21 = v7 + v14 + v20;
  uint64_t v22 = v21 + 20;
  **(void **)(a1 + 40) = v21 + 20;
  if (v21 == -20)
  {
    __nwlog_obj();
    v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    v64 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v64);
    if (result) {
      goto LABEL_49;
    }
    free(v64);
  }

  __int16 v23 = calloc(1uLL, v22);
  if (!v23)
  {
    __nwlog_obj();
    v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    v66 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v66);
    if (!result)
    {
      free(v66);
      goto LABEL_28;
    }
        }

          unint64_t v29 = v6 + 1;
          goto LABEL_26;
        }

        os_log_type_t v12 = v9 & 0xFFFFFFFFFFFFFFE0LL;
        uint64_t v13 = (int8x16_t *)(v5 + 17);
        os_log_type_t v14 = v7 + 1;
        v15.i64[0] = 0x8181818181818181LL;
        v15.i64[1] = 0x8181818181818181LL;
        v16.i64[0] = 0xA1A1A1A1A1A1A1A1LL;
        v16.i64[1] = 0xA1A1A1A1A1A1A1A1LL;
        v17.i64[0] = 0x2E2E2E2E2E2E2E2ELL;
        v17.i64[1] = 0x2E2E2E2E2E2E2E2ELL;
        os_log_type_t v18 = v9 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          char v19 = vbslq_s8((int8x16_t)vcgtq_u8(v16, (uint8x16_t)vaddq_s8(*v14, v15)), v17, *v14);
          v13[-1] = vbslq_s8((int8x16_t)vcgtq_u8(v16, (uint8x16_t)vaddq_s8(v14[-1], v15)), v17, v14[-1]);
          *uint64_t v13 = v19;
          v13 += 2;
          v14 += 2;
          v18 -= 32LL;
        }

        while (v18);
        if (v9 == v12) {
          goto LABEL_25;
        }
        if ((v9 & 0x18) != 0) {
          goto LABEL_16;
        }
        uint64_t v11 = &v5[v12];
        os_log_type_t v10 = &v7->u8[v12];
      }

          uint64_t v11 = *v3;
          uint64_t v17 = (unint64_t)&v3[v11 + 1];
          uint64_t v6 = 1;
        }

        while ((const uint8_t *)v17 != v16);
      }
    }

    else
    {
LABEL_7:
      uint64_t v6 = 0;
    }

    *((_BYTE *)v4 + 36) = *((_BYTE *)v4 + 36) & 0xFE | v6;
    *((void *)v4 + 2) = txt_len;
    *((void *)v4 + 3) = txt_len;
    os_log_type_t v12 = v4;
    goto LABEL_42;
  }

  __nwlog_obj();
  v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v48 = "strict_malloc";
  v49 = 2048;
  v50 = txt_len;
  __int16 v34 = (void *)_os_log_send_and_compose_impl();

  BOOL result = (nw_txt_record_t)__nwlog_abort((uint64_t)v34);
  if (!(_DWORD)result)
  {
    free(v34);
    goto LABEL_6;
  }

  __break(1u);
  return result;
}

    if (!v17)
    {
LABEL_27:
      __int16 v25 = 0LL;
      goto LABEL_1184;
    }

        goto LABEL_26;
      }

      if (!v78)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v65 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1907;
          _os_log_impl( &dword_181A5C000,  v12,  v65,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
        }

        goto LABEL_25;
      }

      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = type;
      v52 = os_log_type_enabled(v12, type);
      if (!v39)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1907;
          _os_log_impl( &dword_181A5C000,  v12,  v51,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
        }

        goto LABEL_25;
      }

      if (v52)
      {
        *(_DWORD *)buf = 136447490;
        v81 = "nw_path_copy_browse_descriptor_from_tlv";
        v82 = 1024;
        v83 = 202;
        v84 = 1024;
        v85 = a1;
        v86 = 2080;
        v87 = "nw_path_copy_browse_descriptor_from_tlv";
        v88 = 1024;
        v89 = 1907;
        v90 = 2082;
        v91 = v39;
        _os_log_impl( &dword_181A5C000,  v12,  v51,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
      }

  if (v7) {
    free(v7);
  }
}

  if (v7) {
    free(v7);
  }
}

        if ((*(unsigned int (**)(uint64_t))(v5 + 440))(v5 + 256))
        {
LABEL_37:
          nw_http3_fail_all_streams(*(void *)(a1 + 40), 514LL);
          return 0LL;
        }

        os_log_type_t v9 = 0;
        *(_DWORD *)(v5 + 416) = 0;
        uint64_t v4 = v17;
      }

      if (!v9)
      {
        os_log_type_t v10 = (char)*v4;
        if (v10 < 0)
        {
          os_log_type_t v12 = 7;
          uint64_t v13 = enc_proc_header_ack;
        }

        else
        {
          uint64_t v11 = v10 & 0xC0;
          if (v11)
          {
            if (v11 != 64) {
              __assert_rtn("lsqpack_enc_decoder_in", "lsqpack.c", 2459, "(buf[0] & 0xC0) == 0x40");
            }
            os_log_type_t v12 = 6;
            uint64_t v13 = enc_proc_stream_cancel;
          }

          else
          {
            os_log_type_t v12 = 6;
            uint64_t v13 = enc_proc_ici;
          }
        }

        *(void *)(v5 + 440) = v13;
        uint64_t v17 = v4 + 1;
        os_log_type_t v18 = *v4;
        char v19 = (-1 << v12) & 0x40 ^ 0x7Fu;
        BOOL v15 = v19 & v18;
        if ((v19 & v18) >= v19)
        {
          char v16 = 0;
          os_log_type_t v14 = 1;
          goto LABEL_17;
        }

        goto LABEL_25;
      }
    }

    while (v4 < (unsigned __int8 *)v8);
  }

    if (!v4) {
      return;
    }
    goto LABEL_26;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v19 = "nw_protocol_http3_input_available";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_25;
    }
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_input_available";
    uint64_t v7 = "%{public}s called with null http3";
    goto LABEL_24;
  }

  if (!v16)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_25;
    }
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_input_available";
    uint64_t v7 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_24;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  BOOL v15 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (!v15) {
      goto LABEL_25;
    }
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_input_available";
    uint64_t v7 = "%{public}s called with null http3, no backtrace";
    goto LABEL_24;
  }

  if (!v15) {
    goto LABEL_47;
  }
  *(_DWORD *)buf = 136446466;
  char v19 = "nw_protocol_http3_input_available";
  __int16 v20 = 2082;
  uint32_t v21 = backtrace_string;
  os_log_type_t v14 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_46:
  _os_log_impl(&dword_181A5C000, v5, v6, v14, buf, 0x16u);
LABEL_47:
  free(backtrace_string);
  if (v4) {
LABEL_26:
  }
    free(v4);
}

    if (!v4) {
      return;
    }
    goto LABEL_26;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v19 = "nw_protocol_http3_output_available";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_25;
    }
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_output_available";
    uint64_t v7 = "%{public}s called with null http3";
    goto LABEL_24;
  }

  if (!v16)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_25;
    }
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_output_available";
    uint64_t v7 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_24;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  uint64_t v5 = (os_log_s *)__nwlog_obj();
  uint64_t v6 = type;
  BOOL v15 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (!v15) {
      goto LABEL_25;
    }
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_http3_output_available";
    uint64_t v7 = "%{public}s called with null http3, no backtrace";
    goto LABEL_24;
  }

  if (!v15) {
    goto LABEL_47;
  }
  *(_DWORD *)buf = 136446466;
  char v19 = "nw_protocol_http3_output_available";
  __int16 v20 = 2082;
  uint32_t v21 = backtrace_string;
  os_log_type_t v14 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_46:
  _os_log_impl(&dword_181A5C000, v5, v6, v14, buf, 0x16u);
LABEL_47:
  free(backtrace_string);
  if (v4) {
LABEL_26:
  }
    free(v4);
}

  if (v16) {
    free(v16);
  }
  return 1LL;
}

  if (v16) {
    free(v16);
  }
  return 1LL;
}

  if (v7) {
    free(v7);
  }
LABEL_8:
}

  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0LL;
LABEL_8:

  return v4;
}

    free(v9);
    goto LABEL_26;
  }

  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_evaluator);
  uint64_t v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_path_create_evaluator_for_custom_ether";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed",  buf,  0xCu);
      }
    }

    else if (v23)
    {
      os_log_type_t v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v13 = type;
      os_log_type_t v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_path_create_evaluator_for_custom_ether";
          uint64_t v27 = 2082;
          int v28 = v12;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v12);
        if (!v9) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_path_create_evaluator_for_custom_ether";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong((id *)v5 + 1, a1);
  *((_WORD *)v6 + 52) = a2;
  if ((nw_path_evaluator_evaluate(v6, 0LL) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_path_create_evaluator_for_custom_ether";
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }

    free(v7);
    goto LABEL_26;
  }

  BOOL v3 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_evaluator);
  uint64_t v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed",  buf,  0xCu);
      }
    }

    else if (v21)
    {
      os_log_type_t v10 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      os_log_type_t v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          __int16 v25 = 2082;
          uint64_t v26 = v10;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v10);
        if (!v7) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      uint64_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong((id *)v3 + 1, a1);
  *((_BYTE *)v4 + 107) |= 0xAu;
  if ((nw_path_evaluator_evaluate(v4, 0LL) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
      _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }

    free(v9);
    goto LABEL_26;
  }

  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_evaluator);
  uint64_t v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_path_create_evaluator_for_custom_ip";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed",  buf,  0xCu);
      }
    }

    else if (v23)
    {
      os_log_type_t v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v13 = type;
      os_log_type_t v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_path_create_evaluator_for_custom_ip";
          uint64_t v27 = 2082;
          int v28 = v12;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v12);
        if (!v9) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_path_create_evaluator_for_custom_ip";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong((id *)v5 + 1, a1);
  *((_BYTE *)v6 + 106) = a2;
  if ((nw_path_evaluator_evaluate(v6, 0LL) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_path_create_evaluator_for_custom_ip";
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }

    free(v7);
    goto LABEL_26;
  }

  BOOL v3 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_evaluator);
  uint64_t v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_path_create_evaluator_for_interpose";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed",  buf,  0xCu);
      }
    }

    else if (v21)
    {
      os_log_type_t v10 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type;
      os_log_type_t v12 = os_log_type_enabled(v8, type);
      if (v10)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v24 = "nw_path_create_evaluator_for_interpose";
          __int16 v25 = 2082;
          uint64_t v26 = v10;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v10);
        if (!v7) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      uint64_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_path_create_evaluator_for_interpose";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_23;
  }

  objc_storeStrong((id *)v3 + 1, a1);
  *((_BYTE *)v4 + 107) |= 6u;
  if ((nw_path_evaluator_evaluate(v4, 0LL) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_path_create_evaluator_for_interpose";
      _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_26;
  }

      free(backtrace_string);
    }
  }

    if (v6) {
      free(v6);
    }
    goto LABEL_4;
  }

  WeakRetained = objc_loadWeakRetained(v1 + 6);
  if (!WeakRetained)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v17 = "nw_endpoint_edge_get_endpoint";
        os_log_type_t v18 = 2112;
        char v19 = v2;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s edge %@ has seen its endpoint be deallocated",  buf,  0x16u);
      }
    }

  if (v10) {
    free(v10);
  }
LABEL_31:

  return v5;
}

    if (v10) {
      free(v10);
    }
LABEL_4:

    ++v5;
    v6 += 16LL;
  }

  objc_storeStrong(location, v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint32_t v21 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v22 = (char *)*location;
    buf = 136446466;
    v31 = "-[NWConnectionStatistics activities]";
    __int16 v32 = 2112;
    v33 = v22;
    _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s Created array of UUIDs: %@",  (uint8_t *)&buf,  0x16u);
  }

  BOOL v3 = *location;
  return (NSArray *)v3;
}
  }

    if (v8) {
      free(v8);
    }
    goto LABEL_27;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  __int16 v20 = 0LL;
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 3221225472LL;
  v16[2] = __nw_http_connection_metadata_get_secondary_certificate_count_block_invoke;
  v16[3] = &unk_189BC60A8;
  v16[4] = buf;
  uint64_t v5 = *((void *)v2 + 4);
  if (v5)
  {
    __nw_http_connection_metadata_get_secondary_certificate_count_block_invoke((uint64_t)v16, v5);
    uint64_t v6 = *(void *)(*(void *)&buf[8] + 24LL);
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  _Block_object_dispose(buf, 8);
LABEL_28:

  return v6;
}

    goto LABEL_26;
  }

  if (type[0] == OS_LOG_TYPE_DEFAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v14 = (os_log_s *)(id)gLogObj;
    char v19 = type[1];
    if (os_log_type_enabled(v14, type[1]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_resolver_details";
      _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_25;
  }

  char v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v14 = (os_log_s *)(id)gLogObj;
  uint64_t v17 = type[1];
  os_log_type_t v18 = os_log_type_enabled(v14, type[1]);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_resolver_details";
      _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
    }

    goto LABEL_25;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_resolver_details";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v16;
    _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (!v13) {
    goto LABEL_28;
  }
LABEL_27:
  free(v13);
LABEL_28:

  *(_DWORD *)(*(void *)(a1 + 40) + 288LL) = nw_endpoint_handler_get_resolution_protocol(v8);
  *(_DWORD *)(*(void *)(a1 + 40) + 336LL) = nw_endpoint_handler_get_resolution_provider(v8, 0LL);
  buf[0] = 0;
  *(_WORD *)os_log_type_t type = 0;
  nw_endpoint_handler_get_svcb_report(v8, buf, (BOOL *)&type[1], (BOOL *)type);
  __int16 v20 = *(void *)(a1 + 40);
  uint32_t v21 = *(_DWORD *)(v20 + 1706) & 0xDFFFFFFF | ((unint64_t)*(unsigned __int16 *)(v20 + 1710) << 32) | ((unint64_t)buf[0] << 29);
  *(_DWORD *)(v20 + 1706) = *(_DWORD *)(v20 + 1706) & 0xDFFFFFFF | (buf[0] << 29);
  *(_WORD *)(v20 + 1710) = WORD2(v21);
  uint64_t v22 = *(void *)(a1 + 40);
  __int16 v23 = *(_DWORD *)(v22 + 1706) & 0xBFFFFFFF | ((unint64_t)*(unsigned __int16 *)(v22 + 1710) << 32) | ((unint64_t)type[1] << 30);
  *(_DWORD *)(v22 + 1706) = *(_DWORD *)(v22 + 1706) & 0xBFFFFFFF | (type[1] << 30);
  *(_WORD *)(v22 + 1710) = WORD2(v23);
  uint64_t v24 = *(void *)(a1 + 40);
  __int16 v25 = *(_DWORD *)(v24 + 1706) & 0x7FFFFFFF | ((unint64_t)*(unsigned __int16 *)(v24 + 1710) << 32) | ((unint64_t)type[0] << 31);
  *(_DWORD *)(v24 + 1706) = *(_DWORD *)(v24 + 1706) & 0x7FFFFFFF | (type[0] << 31);
  *(_WORD *)(v24 + 1710) = WORD2(v25);
  uint64_t v26 = v48;
  uint64_t v27 = *(void *)(a1 + 40);
  *(_DWORD *)(v27 + 252) = v49;
  *(_DWORD *)(v27 + 256) = v26;
  *(_BYTE *)(v27 + 349) = v47;
  *(_DWORD *)(v27 + 260) = v46;
  int v28 = nw_endpoint_handler_copy_endpoint(v8);
  unint64_t v29 = v28;
  if (v28)
  {
    unint64_t v30 = v28;
    v31 = -[nw_endpoint type](v30, "type");

    if (v31 == 1)
    {
      *(_DWORD *)(*(void *)(a1 + 40) + 1706LL) |= 0x10000u;
      __int16 v32 = v8;
      v33 = v32[4];

      if (v33)
      {
        __int16 v34 = v33;
        unint64_t v35 = (v34[12] & 0x40000LL) == 0;

        if (!v35) {
          *(_DWORD *)(*(void *)(a1 + 40) + 1706LL) |= 0x20000u;
        }
      }
    }
  }

LABEL_35:
}

    if (v12) {
      free(v12);
    }
    return 4294966394LL;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v9 = (os_log_s *)gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    uint64_t v11 = *(_DWORD *)(a5 + 368);
    *(_DWORD *)buf = 136447490;
    uint32_t v21 = "error_callback";
    uint64_t v22 = 2082;
    *(void *)__int16 v23 = a5 + 390;
    *(_WORD *)&v23[8] = 2080;
    *(void *)&v23[10] = " ";
    uint64_t v24 = 1024;
    __int16 v25 = v11;
    uint64_t v26 = 1024;
    uint64_t v27 = a2;
    int v28 = 2080;
    unint64_t v29 = a3;
    _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> error (%d: %s)", buf, 0x36u);
    return 0LL;
  }

  return result;
}

    free(backtrace_string);
    goto LABEL_35;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_http2_get_remote_endpoint";
    os_log_type_t v9 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
  }

  if (v8) {
    free(v8);
  }
  return 1LL;
}

  if (v6) {
    free(v6);
  }
LABEL_27:
  if (a1 < 5) {
    return (0x102050300uLL >> (8 * a1));
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v15 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  unint64_t v29 = "nw_interface_type_to_functional_type";
  unint64_t v30 = 1024;
  v31 = a1;
  char v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v26 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)(id)gLogObj;
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v29 = "nw_interface_type_to_functional_type";
      unint64_t v30 = 1024;
      v31 = a1;
      char v19 = "%{public}s Unknown interface_type %d";
LABEL_40:
      __int16 v23 = v17;
      uint64_t v24 = v18;
LABEL_41:
      _os_log_impl(&dword_181A5C000, v23, v24, v19, buf, 0x12u);
    }
  }

  else if (v26)
  {
    __int16 v20 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)(id)gLogObj;
    uint32_t v21 = type;
    uint64_t v22 = os_log_type_enabled(v17, type);
    if (v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446722;
        unint64_t v29 = "nw_interface_type_to_functional_type";
        unint64_t v30 = 1024;
        v31 = a1;
        __int16 v32 = 2082;
        v33 = v20;
        _os_log_impl( &dword_181A5C000,  v17,  v21,  "%{public}s Unknown interface_type %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v20);
      goto LABEL_43;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v29 = "nw_interface_type_to_functional_type";
      unint64_t v30 = 1024;
      v31 = a1;
      char v19 = "%{public}s Unknown interface_type %d, no backtrace";
      __int16 v23 = v17;
      uint64_t v24 = v21;
      goto LABEL_41;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)(id)gLogObj;
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v29 = "nw_interface_type_to_functional_type";
      unint64_t v30 = 1024;
      v31 = a1;
      char v19 = "%{public}s Unknown interface_type %d, backtrace limit exceeded";
      goto LABEL_40;
    }
  }

LABEL_43:
  if (v16) {
    free(v16);
  }
  LOBYTE(v4) = 0;
  return v4;
}

void sub_181A60C04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_dictionary_apply(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_apply";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v15 = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (v15 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v15;
      if (!os_log_type_enabled(v5, v15)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_apply";
      uint64_t v7 = "%{public}s called with null dictionary";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      goto LABEL_45;
    }

    if (!v14)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v15;
      if (os_log_type_enabled(v5, v15))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_apply";
        uint64_t v7 = "%{public}s called with null dictionary, backtrace limit exceeded";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = v15;
    BOOL v9 = os_log_type_enabled(v5, v15);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_apply";
        uint64_t v7 = "%{public}s called with null dictionary, no backtrace";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    if (!v9) {
      goto LABEL_31;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_dictionary_apply";
    __int16 v18 = 2082;
    char v19 = backtrace_string;
    os_log_type_t v10 = "%{public}s called with null dictionary, dumping backtrace:%{public}s";
LABEL_30:
    _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    goto LABEL_31;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_apply";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v15 = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (v15 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v15;
      if (!os_log_type_enabled(v5, v15)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_apply";
      uint64_t v7 = "%{public}s called with null applier";
      goto LABEL_44;
    }

    if (!v14)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v15;
      if (os_log_type_enabled(v5, v15))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_apply";
        uint64_t v7 = "%{public}s called with null applier, backtrace limit exceeded";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = v15;
    BOOL v11 = os_log_type_enabled(v5, v15);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_apply";
        uint64_t v7 = "%{public}s called with null applier, no backtrace";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    if (!v11) {
      goto LABEL_31;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_dictionary_apply";
    __int16 v18 = 2082;
    char v19 = backtrace_string;
    os_log_type_t v10 = "%{public}s called with null applier, dumping backtrace:%{public}s";
    goto LABEL_30;
  }

  id v2 = *(void **)(a1 + 16);
  if (v2)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 0x40000000LL;
    applier[2] = __nw_dictionary_apply_block_invoke;
    applier[3] = &unk_189BBF6C0;
    applier[4] = a2;
    applier[5] = a1;
    return xpc_dictionary_apply(v2, applier);
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_dictionary_apply";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v15 = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (v15 != OS_LOG_TYPE_FAULT)
  {
    if (!v14)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = v15;
      if (os_log_type_enabled(v5, v15))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_apply";
        uint64_t v7 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = v15;
    BOOL v12 = os_log_type_enabled(v5, v15);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_apply";
        uint64_t v7 = "%{public}s called with null dictionary->xpc_object, no backtrace";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_dictionary_apply";
      __int16 v18 = 2082;
      char v19 = backtrace_string;
      os_log_type_t v10 = "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s";
      goto LABEL_30;
    }

LABEL_31:
    free(backtrace_string);
    goto LABEL_45;
  }

  uint64_t v5 = (os_log_s *)__nwlog_obj();
  os_log_type_t v6 = v15;
  if (os_log_type_enabled(v5, v15))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_apply";
    uint64_t v7 = "%{public}s called with null dictionary->xpc_object";
    goto LABEL_44;
  }

LABEL_32:
    if (!v24) {
      goto LABEL_34;
    }
LABEL_33:
    free(v24);
    goto LABEL_34;
  }

  if (!v36)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v25 = (os_log_s *)(id)gLogObj;
    unint64_t v30 = v37;
    if (os_log_type_enabled(v25, v37))
    {
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_stack_copy";
      _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s [[nw_protocol_stack alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_31;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v25 = (os_log_s *)(id)gLogObj;
  int v28 = v37;
  unint64_t v29 = os_log_type_enabled(v25, v37);
  if (!backtrace_string)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_stack_copy";
      _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s [[nw_protocol_stack alloc] init] failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_31;
  }

  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    v39 = "nw_protocol_stack_copy";
    v40 = 2082;
    v41 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s [[nw_protocol_stack alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v24) {
    goto LABEL_33;
  }
LABEL_34:

  return v2;
}

    uint64_t v20 = dispatch_workloop_copy_current();
    goto LABEL_32;
  }

  __nwlog_obj(0LL, v18);
  v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v71 = "strict_calloc";
  v72 = 2048;
  v73 = 1LL;
  v74 = 2048;
  v75 = 56LL;
  v33 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v33);
  if (!result)
  {
    free(v33);
    if (v12) {
      goto LABEL_13;
    }
    goto LABEL_31;
  }

  __break(1u);
  return result;
}

    protocol = 0LL;
    goto LABEL_32;
  }

  protocol = 6LL;
LABEL_32:

  return protocol;
}

    free(backtrace_string);
    if (!v6) {
      return 0LL;
    }
    goto LABEL_51;
  }

  memcpy(__dst, __src, __n);
  if (__dst[0].sa_len > v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v115 = "nw_path_copy_endpoint_from_tlv";
    v116 = 1024;
    v117 = a1;
    v118 = 1024;
    v119 = v3;
    v120 = 2080;
    v121 = "nw_path_copy_endpoint_from_tlv";
    v122 = 1024;
    v123 = 1874;
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v112 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1874;
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }

      goto LABEL_49;
    }

    if (v112 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      int v28 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1874;
        _os_log_impl( &dword_181A5C000,  v7,  v28,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
      }

      goto LABEL_49;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    uint32_t v21 = type[0];
    uint64_t v22 = os_log_type_enabled(v7, type[0]);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1874;
        _os_log_impl( &dword_181A5C000,  v7,  v21,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
      }

      goto LABEL_49;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136447490;
      v115 = "nw_path_copy_endpoint_from_tlv";
      v116 = 1024;
      v117 = a1;
      v118 = 1024;
      v119 = v3;
      v120 = 2080;
      v121 = "nw_path_copy_endpoint_from_tlv";
      v122 = 1024;
      v123 = 1874;
      v124 = 2082;
      v125 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v21,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
    }

    goto LABEL_31;
  }

  BOOL v11 = __dst[0].sa_len - 8;
  if (v3 - 8 >= v11) {
    BOOL v12 = v11;
  }
  else {
    BOOL v12 = v3 - 8;
  }
  if (!__dst[0].sa_family)
  {
    host_with_numeric_port = 0LL;
    switch(*(_DWORD *)&__dst[0].sa_data[2])
    {
      case 0:
        return (nw_endpoint_t)host_with_numeric_port;
      case 2:
        __int16 v23 = strnlen(&__dst[0].sa_data[6], v12);
        if (v23 >= v12)
        {
          __nwlog_obj();
          v54 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1719;
          os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v55 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1719;
              _os_log_impl( &dword_181A5C000,  v7,  v55,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v70 = type[0];
            v71 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v71)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1719;
                v124 = 2082;
                v125 = v69;
                _os_log_impl( &dword_181A5C000,  v7,  v70,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
              }

              goto LABEL_185;
            }

            if (v71)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1719;
              _os_log_impl( &dword_181A5C000,  v7,  v70,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v88 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1719;
              _os_log_impl( &dword_181A5C000,  v7,  v88,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }
          }

          goto LABEL_49;
        }

        uint64_t v24 = v23;
        host_with_numeric_port = (id *)nw_endpoint_create_host_with_numeric_port( &__dst[0].sa_data[6],  bswap32(*(unsigned __int16 *)__dst[0].sa_data) >> 16);
        if (host_with_numeric_port)
        {
          __int16 v25 = v24 + 1;
          uint64_t v26 = v12 - (v24 + 1);
          if (v12 > v24 + 1) {
            goto LABEL_80;
          }
        }

        return (nw_endpoint_t)host_with_numeric_port;
      case 3:
        __int16 v32 = strnlen(&__dst[0].sa_data[6], v12);
        if (v32 >= v12)
        {
          __nwlog_obj();
          v56 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1735;
          os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v57 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1735;
              _os_log_impl( &dword_181A5C000,  v7,  v57,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v72 = type[0];
            v73 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v73)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1735;
                v124 = 2082;
                v125 = v69;
                _os_log_impl( &dword_181A5C000,  v7,  v72,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
              }

              goto LABEL_185;
            }

            if (v73)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1735;
              _os_log_impl( &dword_181A5C000,  v7,  v72,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v89 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1735;
              _os_log_impl( &dword_181A5C000,  v7,  v89,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }
          }

          goto LABEL_49;
        }

        v33 = &__dst[0].sa_data[v32 + 7];
        __int16 v34 = strnlen(v33, v12 - (v32 + 1)) + v32 + 1;
        if (v34 >= v12)
        {
          __nwlog_obj();
          v65 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1742;
          os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v66 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1742;
              _os_log_impl( &dword_181A5C000,  v7,  v66,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v84 = type[0];
            v85 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v85)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1742;
                v124 = 2082;
                v125 = v69;
                _os_log_impl( &dword_181A5C000,  v7,  v84,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
              }

              goto LABEL_185;
            }

            if (v85)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1742;
              _os_log_impl( &dword_181A5C000,  v7,  v84,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v99 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1742;
              _os_log_impl( &dword_181A5C000,  v7,  v99,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }
          }

          goto LABEL_49;
        }

        unint64_t v35 = &__dst[0].sa_data[v34 + 7];
        uint64_t v36 = strnlen(v35, v12 - (v34 + 1)) + v34 + 1;
        if (v36 >= v12)
        {
          __nwlog_obj();
          v80 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1749;
          os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v81 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1749;
              _os_log_impl( &dword_181A5C000,  v7,  v81,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v95 = type[0];
            v96 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v96)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1749;
                v124 = 2082;
                v125 = v69;
                _os_log_impl( &dword_181A5C000,  v7,  v95,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
              }

              goto LABEL_185;
            }

            if (v96)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1749;
              _os_log_impl( &dword_181A5C000,  v7,  v95,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v105 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1749;
              _os_log_impl( &dword_181A5C000,  v7,  v105,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }
          }

          goto LABEL_49;
        }

        host_with_numeric_port = (id *)nw_endpoint_create_bonjour_service(&__dst[0].sa_data[6], v33, v35);
        if (host_with_numeric_port)
        {
          __int16 v25 = v36 + 1;
          uint64_t v26 = v12 - (v36 + 1);
          if (v12 > v36 + 1) {
            goto LABEL_80;
          }
        }

        return (nw_endpoint_t)host_with_numeric_port;
      case 4:
        if (strnlen(&__dst[0].sa_data[6], v12) >= v12)
        {
          __nwlog_obj();
          v58 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1726;
          os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v59 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1726;
              _os_log_impl( &dword_181A5C000,  v7,  v59,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v74 = type[0];
            v75 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v75)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1726;
                v124 = 2082;
                v125 = v69;
                _os_log_impl( &dword_181A5C000,  v7,  v74,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
              }

              goto LABEL_185;
            }

            if (v75)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1726;
              _os_log_impl( &dword_181A5C000,  v7,  v74,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v90 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1726;
              _os_log_impl( &dword_181A5C000,  v7,  v90,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }
          }

          goto LABEL_49;
        }

        return nw_endpoint_create_url(&__dst[0].sa_data[6]);
      case 5:
        v52 = strnlen(&__dst[0].sa_data[6], v12);
        if (v52 >= v12)
        {
          __nwlog_obj();
          v60 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1846;
          os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v61 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1846;
              _os_log_impl( &dword_181A5C000,  v7,  v61,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          if (v112 == OS_LOG_TYPE_DEFAULT)
          {
            __nwlog_obj();
            uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v91 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1846;
              _os_log_impl( &dword_181A5C000,  v7,  v91,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          v69 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v76 = type[0];
          v77 = os_log_type_enabled(v7, type[0]);
          if (!v69)
          {
            if (v77)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1846;
              _os_log_impl( &dword_181A5C000,  v7,  v76,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }

            goto LABEL_49;
          }

          if (v77)
          {
            *(_DWORD *)buf = 136447490;
            v115 = "nw_path_copy_endpoint_from_tlv";
            v116 = 1024;
            v117 = a1;
            v118 = 1024;
            v119 = v3;
            v120 = 2080;
            v121 = "nw_path_copy_endpoint_from_tlv";
            v122 = 1024;
            v123 = 1846;
            v124 = 2082;
            v125 = v69;
            _os_log_impl( &dword_181A5C000,  v7,  v76,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
          }

  return v5;
}

    if (v13) {
      free(v13);
    }
    goto LABEL_33;
  }

  BOOL v3 = v1[19];
  if (!v3 || (uint64_t v4 = *(void **)(v3 + 24)) == 0LL)
  {
LABEL_33:
    BOOL v11 = 0LL;
    goto LABEL_34;
  }

  uint64_t v5 = v4;
  os_log_type_t v6 = nw_protocol_options_matches_definition(v5, (void *)g_udp_definition);

  uint64_t v7 = *(void **)(v2[19] + 24LL);
  if (!v6)
  {
    os_log_type_t v10 = v7;
LABEL_12:
    BOOL v11 = v10;
    goto LABEL_34;
  }

  if (!nw_udp_options_get_use_quic_stats(v7))
  {
    os_log_type_t v10 = *(id *)(v2[19] + 24LL);
    goto LABEL_12;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  __int16 v25 = __Block_byref_object_copy__19159;
  uint64_t v26 = __Block_byref_object_dispose__19160;
  uint64_t v27 = 0LL;
  uint64_t v8 = (nw_protocol_stack *)v2[19];
  if (v8)
  {
    iterate_block[0] = MEMORY[0x1895F87A8];
    iterate_block[1] = 3221225472LL;
    iterate_block[2] = __nw_parameters_get_upper_transport_protocol_options_block_invoke;
    iterate_block[3] = &unk_189BBD000;
    iterate_block[4] = buf;
    nw_protocol_stack_iterate_application_protocols(v8, iterate_block);
    BOOL v9 = *(void **)(*(void *)&buf[8] + 40LL);
  }

  else
  {
    BOOL v9 = 0LL;
  }

  BOOL v11 = v9;
  _Block_object_dispose(buf, 8);

LABEL_34:
  return v11;
}

    if (nw_endpoint_handler_get_minimize_logging(v19))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v19) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v41 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          v169 = nw_endpoint_handler_get_id_string(v19);
          v170 = nw_endpoint_handler_dry_run_string(v19);
          v171 = nw_endpoint_handler_copy_endpoint(v19);
          v172 = nw_endpoint_get_logging_description(v171);
          v173 = nw_endpoint_handler_state_string(v19);
          v174 = nw_endpoint_handler_mode_string(v19);
          v175 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v169;
          v215 = 2082;
          v216 = v170;
          v217 = 2082;
          v218 = (void *)v172;
          v219 = 2082;
          v220 = v173;
          v221 = 2082;
          v222 = v174;
          v223 = 2114;
          v224 = v175;
          _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] lost nexus assignment",  buf,  0x48u);
        }

        goto LABEL_136;
      }
    }

    else
    {
      v39 = v19;
      v40 = (*((_BYTE *)v39 + 268) & 0x20) == 0;

      if (v40)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v41 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
        {
          v42 = v39;

          v43 = v42;
          v44 = (*((_BYTE *)v39 + 268) & 1) == 0;

          if (v44) {
            v45 = "";
          }
          else {
            v45 = "dry-run ";
          }
          v46 = nw_endpoint_handler_copy_endpoint(v43);
          v47 = nw_endpoint_get_logging_description(v46);
          v48 = v43;
          v49 = v48;
          v50 = v48[30];
          else {
            v51 = off_189BBBBF0[v50];
          }
          v202 = v51;

          v106 = v49;
          v107 = "path";
          switch(v206->mode)
          {
            case 0:
              break;
            case 1:
              v107 = "resolver";
              break;
            case 2:
              v107 = nw_endpoint_flow_mode_string(v106[31]);
              break;
            case 3:
              v107 = "proxy";
              break;
            case 4:
              v107 = "fallback";
              break;
            case 5:
              v107 = "transform";
              break;
            default:
              v107 = "unknown-mode";
              break;
          }

          v198 = v107;

          v133 = v42;
          v134 = v41;
          v135 = v46;
          v136 = v45;
          v137 = v47;
          v138 = v106;
          os_unfair_lock_lock(p_lock);
          v139 = v19->current_path;
          os_unfair_lock_unlock(p_lock);

          v140 = v137;
          v141 = v135;
          v41 = v134;
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = v133->id_str;
          v215 = 2082;
          v216 = v136;
          v217 = 2082;
          v218 = (void *)v140;
          v219 = 2082;
          v220 = v202;
          v221 = 2082;
          v222 = v198;
          v223 = 2114;
          v224 = v139;
          _os_log_impl( &dword_181A5C000,  v134,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] lost nexus assignment",  buf,  0x48u);
        }

          uint32_t v21 = v293;
          uint64_t v20 = (size_t)v293[12];
          goto LABEL_32;
        }

        if (v17) {
          goto LABEL_31;
        }
        uint64_t v20 = dispatch_data_get_size(v16);
        uint32_t v21 = v293;
LABEL_32:
        uint64_t v24 = (size_t)v21[14];
        if (v20 <= v24) {
          LODWORD(v24) = 0;
        }
        __int16 v25 = v20 - v24;
LABEL_35:

        if ((_DWORD)v320 && v320 < v25)
        {
          __int16 v23 = 1;
          goto LABEL_48;
        }

        uint64_t v26 = v295->initial_write_requests;
        if (!v26) {
          uint64_t v26 = v295->write_requests;
        }
        __int16 v23 = nw_write_request_remaining_datagram_count(v26);
        if (!v23) {
          goto LABEL_47;
        }
LABEL_48:
        v318 = 0LL;
        v319 = &v318;
        v290 = v295->last_error;
        v31 = ((uint64_t (*)(void))v288->callbacks->get_output_frames)();
        if (v23 == -1)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          __int16 v32 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            v188 = nw_endpoint_handler_get_id_string(v291);
            v189 = nw_endpoint_handler_dry_run_string(v291);
            v190 = nw_endpoint_handler_copy_endpoint(v291);
            v191 = nw_endpoint_get_logging_description(v190);
            v192 = nw_endpoint_handler_state_string(v291);
            v193 = nw_endpoint_handler_mode_string(v291);
            v194 = nw_endpoint_handler_copy_current_path(v291);
            *(_DWORD *)buf = 136448002;
            *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v188;
            *(_WORD *)&buf[22] = 2082;
            v338 = v189;
            *(_WORD *)v339 = 2082;
            *(void *)&v339[2] = v191;
            *(_WORD *)&v339[10] = 2082;
            *(void *)&v339[12] = v192;
            *(_WORD *)&v339[20] = 2082;
            *(void *)&v339[22] = v193;
            v340 = 2114;
            v341 = v194;
            v342 = 1024;
            v343 = v31;
            _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u frames to write",  buf,  0x4Eu);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          __int16 v32 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            v33 = nw_endpoint_handler_get_id_string(v291);
            __int16 v34 = nw_endpoint_handler_dry_run_string(v291);
            unint64_t v35 = nw_endpoint_handler_copy_endpoint(v291);
            uint64_t v36 = nw_endpoint_get_logging_description(v35);
            v37 = nw_endpoint_handler_state_string(v291);
            v38 = nw_endpoint_handler_mode_string(v291);
            v39 = nw_endpoint_handler_copy_current_path(v291);
            *(_DWORD *)buf = 136448258;
            *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v33;
            *(_WORD *)&buf[22] = 2082;
            v338 = v34;
            *(_WORD *)v339 = 2082;
            *(void *)&v339[2] = v36;
            *(_WORD *)&v339[10] = 2082;
            *(void *)&v339[12] = v37;
            *(_WORD *)&v339[20] = 2082;
            *(void *)&v339[22] = v38;
            v340 = 2114;
            v341 = v39;
            v342 = 1024;
            v343 = v31;
            v344 = 1024;
            LODWORD(v345) = v23;
            _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u fra mes to write, request wants %u frames",  buf,  0x54u);
          }
        }

LABEL_56:
        if (!v318 || !v31)
        {
          if (v31 && (nw_endpoint_handler_get_logging_disabled(v291) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v215 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR))
            {
              v216 = nw_endpoint_handler_get_id_string(v291);
              v217 = nw_endpoint_handler_dry_run_string(v291);
              v218 = nw_endpoint_handler_copy_endpoint(v291);
              v219 = nw_endpoint_get_logging_description(v218);
              v220 = nw_endpoint_handler_state_string(v291);
              v221 = nw_endpoint_handler_mode_string(v291);
              v222 = nw_endpoint_handler_copy_current_path(v291);
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v216;
              *(_WORD *)&buf[22] = 2082;
              v338 = v217;
              *(_WORD *)v339 = 2082;
              *(void *)&v339[2] = v219;
              *(_WORD *)&v339[10] = 2082;
              *(void *)&v339[12] = v220;
              *(_WORD *)&v339[20] = 2082;
              *(void *)&v339[22] = v221;
              v340 = 2114;
              v341 = v222;
              v342 = 1024;
              v343 = v31;
              _os_log_impl( &dword_181A5C000,  v215,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler reported %u frames to write, but array is empty",  buf,  0x4Eu);
            }
          }

          last_error = v295->last_error;
          if (last_error)
          {
            if (v290 != last_error)
            {
              v224 = last_error;
              v225 = *((_DWORD *)v224 + 2);

              if (v225 == 1)
              {
                error_code = nw_error_get_error_code(v295->last_error);
                __nwlog_obj();
                v227 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v227, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v293;
                  *(_WORD *)&buf[22] = 1024;
                  LODWORD(v338) = error_code;
                  _os_log_impl( &dword_181A5C000,  v227,  OS_LOG_TYPE_ERROR,  "%{public}s Failing write request %{public}@ %{darwin.errno}d",  buf,  0x1Cu);
                }

                nw_write_request_fail(v293, error_code);
                v228 = (OS_nw_write_request *)nw_write_request_list_prune(v295->initial_write_requests);
                v229 = v295->initial_write_requests;
                v295->initial_write_requests = v228;

                v230 = (OS_nw_write_request *)nw_write_request_list_prune(v295->write_requests);
                v231 = v295->write_requests;
                v295->write_requests = v230;
              }
            }
          }

          goto LABEL_336;
        }

        v292 = v296;
        handle = (uint64_t)v295->protocol.handle;
        v294 = *(id *)(handle + 160);
        v335 = 0LL;
        v336 = &v335;
        v334 = 0LL;
        v41 = nw_flow_copy_write_request(handle, (uint64_t)&v320, &v334);
        v42 = v41;
        if (v41 && (v43 = nw_write_request_copy_data(v41)) != 0LL)
        {
          v307 = v43;
          v301 = dispatch_data_get_size(v43);
        }

        else
        {
          v301 = 0LL;
          v307 = 0LL;
        }

        v44 = v318;
        v45 = (uint64_t)v44;
        v46 = 0LL;
        if (!v42 || !v44) {
          goto LABEL_250;
        }
        v47 = 0LL;
        v48 = 0LL;
        while (1)
        {
          v49 = *(void **)(v45 + 32);
          if (!v49 && !*(void *)(v45 + 40)) {
            v49 = 0LL;
          }
          v316 = v49;
          v50 = v42;
          v51 = v50[9];

          if (!v51)
          {
            data = v307;
            if ((*(_WORD *)(handle + 332) & 0x800) == 0) {
              goto LABEL_97;
            }
            goto LABEL_96;
          }

          v52 = *(_DWORD *)(v45 + 52);
          if (v52)
          {
            v53 = *(_DWORD *)(v45 + 56) + *(_DWORD *)(v45 + 60);
            v54 = v50;
            data = 0LL;
            v55 = (v52 - v53);
            if (v52 != v53 && v50[9])
            {
              v56 = v54;
              v57 = v54[14];
              if ((_BYTE *)v54[12] - v57 >= v55) {
                v58 = (v52 - v53);
              }
              else {
                v58 = (_BYTE *)v54[12] - v57;
              }
              v325 = 0LL;
              alloc = (dispatch_data_s *)dispatch_data_create_alloc();
              v321 = 0LL;
              v322 = (uint64_t)&v321;
              v323 = 0x2020000000LL;
              v324[0] = 0LL;
              v60 = v50[9];
              *(void *)buf = MEMORY[0x1895F87A8];
              *(void *)&buf[8] = 3221225472LL;
              *(void *)&buf[16] = __nw_write_request_copy_data_from_fd_block_invoke;
              v338 = (const char *)&unk_189BBBED8;
              *(void *)v339 = &v321;
              *(void *)&v339[8] = v325;
              *(void *)&v339[16] = v58;
              nw_fd_wrapper_get_fd(v60, buf);
              v61 = *(void *)(v322 + 24);
              if (v61)
              {
                if (v61 == -1LL)
                {
                  posix_error = nw_error_create_posix_error(**(_DWORD **)(StatusReg + 8));
                  nw_write_request_report(v56, 0LL, posix_error);

                  data = 0LL;
                }

                else
                {
                  if (v61 >= v55) {
                    subrange = alloc;
                  }
                  else {
                    subrange = dispatch_data_create_subrange(alloc, 0LL, v61);
                  }
                  data = subrange;
                }
              }

              else
              {
                data = 0LL;
                *((_BYTE *)v56 + 128) |= 0x10u;
              }

              _Block_object_dispose(&v321, 8);
            }
          }

          else
          {
            v63 = v50;
            data = 0LL;
          }

          v65 = v50;
          v66 = (dispatch_data_s *)v65[7];
          v67 = v50[9];
          if (!v66)
          {
            if (!v67)
            {
              v301 = 0LL;
              goto LABEL_95;
            }

    free(v16);
    goto LABEL_32;
  }

  mode = v1->mode;

  if (mode != 1) {
    goto LABEL_25;
  }
  uint64_t v4 = nw_endpoint_handler_copy_resolver(v2);
  uint64_t v5 = *((void *)v4 + 5);
  if (v5) {
    os_log_type_t v6 = (*(void *)(v5 + 24) - *(void *)(v5 + 16)) >> 3;
  }
  else {
    os_log_type_t v6 = 0LL;
  }

LABEL_33:
  return v6;
}

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

            uint64_t v24 = 0;
            goto LABEL_32;
          }

          __nwlog_obj();
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          v33 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v61 = 0;
          if (!__nwlog_fault((const char *)v33, &type, &v61))
          {
LABEL_85:
            if (v33) {
              free(v33);
            }
            goto LABEL_31;
          }

          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v44 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_181A5C000, v34, v44, "%{public}s called with null should_release_snapshot", buf, 0xCu);
            }

  if (v15) {
    free(v15);
  }
LABEL_14:
}

    LOWORD(v10) = 0;
    LODWORD(v5) = 1;
    goto LABEL_34;
  }

  if (result != 45)
  {
    if (!v5) {
      goto LABEL_31;
    }
    os_log_type_t v10 = (result - 48);
    if (v10 > 9) {
      goto LABEL_31;
    }
    if (v5 == 1)
    {
LABEL_33:
      LODWORD(v5) = 0;
      goto LABEL_34;
    }

    if ((BYTE1(result) - 48) <= 9u)
    {
      LOWORD(v10) = 10 * v10 + (BYTE1(result) - 48);
      char v16 = v5 - 2;
      if (v5 != 2)
      {
        uint64_t v17 = (unsigned __int8 *)v24 + 2;
        while (1)
        {
          __int16 v18 = *v17 - 48;
          if (v18 > 9) {
            goto LABEL_31;
          }
          char v19 = (__int16)(10 * v10);
          os_log_type_t v10 = v19 + v18;
          LODWORD(v5) = 0;
          ++v17;
          if (!--v16) {
            goto LABEL_34;
          }
        }
      }

      goto LABEL_33;
    }

    goto LABEL_31;
  }

  if (v5)
  {
    if (v5 != 1)
    {
      BOOL v11 = (BYTE1(result) - 48);
      if (v11 > 9) {
        goto LABEL_31;
      }
      if (v5 == 2)
      {
        LODWORD(v5) = 0;
        os_log_type_t v10 = -v11;
        goto LABEL_34;
      }

      LOWORD(v10) = -10 * v11 - (BYTE2(result) - 48);
      uint64_t v20 = v5 - 3;
      if (v5 != 3)
      {
        uint32_t v21 = (unsigned __int8 *)v24 + 3;
        while (1)
        {
          uint64_t v22 = *v21 - 48;
          if (v22 > 9) {
            goto LABEL_31;
          }
          __int16 v23 = (__int16)(10 * v10);
          os_log_type_t v10 = v23 - v22;
          LODWORD(v5) = 0;
          ++v21;
          if (!--v20) {
            goto LABEL_34;
          }
        }
      }

      goto LABEL_33;
    }

    goto LABEL_57;
  }

  __break(1u);
LABEL_59:
  __break(1u);
  return result;
}

      BOOL result = 0LL;
      LOBYTE(v5) = 1;
      goto LABEL_34;
    }

    if (v5)
    {
      if (v5 != 1)
      {
        os_log_type_t v10 = (BYTE1(result) - 48);
        if (v10 <= 9)
        {
          if (v5 == 2)
          {
            LOBYTE(v5) = 0;
            BOOL result = -v10;
LABEL_34:
            LODWORD(v5) = v5 & 1;
            goto LABEL_35;
          }

          if ((BYTE2(result) - 48) <= 9u)
          {
            BOOL result = -10 * v10 - (BYTE2(result) - 48);
            char v19 = v5 - 3;
            if (v5 != 3)
            {
              uint64_t v20 = (unsigned __int8 *)v24 + 3;
              while (1)
              {
                uint32_t v21 = *v20 - 48;
                if (v21 > 9) {
                  goto LABEL_31;
                }
                uint64_t v22 = 10LL * (int)result;
                BOOL result = v22 - v21;
                LOBYTE(v5) = 0;
                ++v20;
                if (!--v19) {
                  goto LABEL_34;
                }
              }
            }

    BOOL v12 = 0LL;
    char v14 = 1;
    goto LABEL_44;
  }

  __break(1u);
LABEL_58:
  __break(1u);
  return result;
}

  if (!v17)
  {
    BOOL result = sub_181BF7C1C(47LL, 0xE100000000000000LL);
LABEL_29:
    uint64_t v22 = result;
LABEL_38:
    *a4 = v8;
    a4[1] = v14;
    a4[2] = v22;
    return result;
  }

  if (__OFADD__(location, v17)) {
    goto LABEL_50;
  }
  if (location + v17 < location)
  {
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }

  __int16 v23 = v17 + 1;
  if (__OFADD__(v17, 1LL))
  {
LABEL_52:
    __break(1u);
LABEL_53:
    *(_BYTE *)(MEMORY[0x18961AFE8] + 32LL) = 47;
    __break(1u);
    goto LABEL_54;
  }

  if ((v23 & 0x8000000000000000LL) == 0)
  {
    if (v17 != -1)
    {
      uint64_t v22 = sub_18264ED18();
      *(void *)(v22 + 16) = v23;
      *(_BYTE *)(v22 + 32) = 47;
      BOOL result = sub_18264F0CC();
      *(void *)(v22 + 16) = v23;
      goto LABEL_38;
    }

    goto LABEL_53;
  }

    uint32_t v21 = (v32 - 1) & v32;
    __int16 v25 = __clz(__rbit64(v32)) + (v23 << 6);
LABEL_12:
    uint64_t v26 = (uint64_t *)(*(void *)(v17 + 48) + 16 * v25);
    uint64_t v27 = *v26;
    int v28 = v26[1];
    sub_181BBE220();
    unint64_t v29 = (void *)swift_allocError();
    *(_DWORD *)unint64_t v30 = v9;
    *(_BYTE *)(v30 + 4) = v1;
    swift_bridgeObjectRetain();
    sub_181BED960(v27, v28, v29);

    swift_bridgeObjectRelease();
  }

  v33 = v31 + 5;
  if (v33 >= v22)
  {
LABEL_37:
    swift_release();
    swift_bridgeObjectRelease();
    return;
  }

  __int16 v32 = *(void *)(v18 + 8 * v33);
  if (v32)
  {
    __int16 v23 = v33;
    goto LABEL_31;
  }

  while (1)
  {
    __int16 v23 = v33 + 1;
    if (__OFADD__(v33, 1LL)) {
      break;
    }
    if (v23 >= v22) {
      goto LABEL_37;
    }
    __int16 v32 = *(void *)(v18 + 8 * v23);
    ++v33;
    if (v32) {
      goto LABEL_31;
    }
  }

  __break(1u);
}

  __break(1u);
  return result;
}

      swift_bridgeObjectRelease();
      uint64_t v4 = v77;
    }
  }

  BOOL v11 = v4 + 1;
  if (__OFADD__(v4, 1LL))
  {
    __break(1u);
    goto LABEL_65;
  }

  if (v11 >= v76) {
    goto LABEL_63;
  }
  BOOL v12 = *(void *)(v5 + 8 * v11);
  ++v4;
  if (v12) {
    goto LABEL_19;
  }
  uint64_t v4 = v11 + 1;
  if (v11 + 1 >= v76) {
    goto LABEL_63;
  }
  BOOL v12 = *(void *)(v5 + 8 * v4);
  if (v12) {
    goto LABEL_19;
  }
  uint64_t v4 = v11 + 2;
  if (v11 + 2 >= v76) {
    goto LABEL_63;
  }
  BOOL v12 = *(void *)(v5 + 8 * v4);
  if (v12)
  {
LABEL_19:
    uint64_t v8 = (v12 - 1) & v12;
    os_log_type_t v10 = __clz(__rbit64(v12)) + (v4 << 6);
    goto LABEL_20;
  }

  uint64_t v13 = v11 + 3;
  if (v13 >= v76)
  {
LABEL_63:
    BOOL result = swift_release();
    *a2 = v72;
    a2[1] = (unint64_t)dictionary;
    return result;
  }

  BOOL v12 = *(void *)(v5 + 8 * v13);
  if (v12)
  {
    uint64_t v4 = v13;
    goto LABEL_19;
  }

  while (1)
  {
    uint64_t v4 = v13 + 1;
    if (__OFADD__(v13, 1LL)) {
      break;
    }
    if (v4 >= v76) {
      goto LABEL_63;
    }
    BOOL v12 = *(void *)(v5 + 8 * v4);
    ++v13;
    if (v12) {
      goto LABEL_19;
    }
  }

      a2 = a5;
      if (__OFADD__(v10++, 1LL))
      {
        __break(1u);
        goto LABEL_34;
      }
    }
  }

  sub_181C93190(a4, a2, 0);
  return 0LL;
}

              os_log_type_t v10 = *(void *)(a1 + 48);
              if (!v10) {
                goto LABEL_58;
              }
LABEL_52:
              char v19 = *(void *)(v10 + 72);
              if (!v19
                || (++*(void *)(v19 + 32), (uint64_t v20 = *(void *)(a1 + 48)) == 0)
                || (uint32_t v21 = *(void *)(v20 + 72)) == 0)
              {
LABEL_58:
                ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                if (_nw_signposts_once != -1) {
                  dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
                }
                if (a2)
                {
LABEL_100:
                  kdebug_trace();
LABEL_62:
                  if (v93 >= 9) {
                    **(void **)(a1 + 48) = v93 + **(void **)(a1 + 48) - 8LL;
                  }
                  return 1LL;
                }

                __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                v97 = "__nw_frame_effective_length";
                v86 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t type = OS_LOG_TYPE_ERROR;
                v94 = 0;
                if (__nwlog_fault(v86, &type, &v94))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    v87 = (os_log_s *)__nwlog_obj();
                    v88 = type;
                    if (!os_log_type_enabled(v87, type)) {
                      goto LABEL_235;
                    }
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v89 = "%{public}s called with null frame";
                    goto LABEL_234;
                  }

                  if (!v94)
                  {
                    v87 = (os_log_s *)__nwlog_obj();
                    v88 = type;
                    if (!os_log_type_enabled(v87, type)) {
                      goto LABEL_235;
                    }
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v89 = "%{public}s called with null frame, backtrace limit exceeded";
                    goto LABEL_234;
                  }

                  v90 = (char *)__nw_create_backtrace_string();
                  v87 = (os_log_s *)__nwlog_obj();
                  v88 = type;
                  v91 = os_log_type_enabled(v87, type);
                  if (v90)
                  {
                    if (v91)
                    {
                      *(_DWORD *)buf = 136446466;
                      v97 = "__nw_frame_effective_length";
                      v98 = 2082;
                      v99 = v90;
                      _os_log_impl( &dword_181A5C000,  v87,  v88,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v90);
                    goto LABEL_235;
                  }

                  if (v91)
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v89 = "%{public}s called with null frame, no backtrace";
LABEL_234:
                    _os_log_impl(&dword_181A5C000, v87, v88, v89, buf, 0xCu);
                  }
                }

      free(backtrace_string);
      goto LABEL_41;
    }

    os_log_type_t v15 = (os_log_s *)__nwlog_obj();
    char v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_shoes_get_input_frames";
    uint64_t v17 = "%{public}s called with null protocol";
LABEL_40:
    _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
LABEL_41:
    if (v14) {
      free(v14);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_shoes_get_input_frames";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = (os_log_s *)__nwlog_obj();
      char v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_shoes_get_input_frames";
      uint64_t v17 = "%{public}s called with null shoes";
      goto LABEL_40;
    }

    if (!v22)
    {
      os_log_type_t v15 = (os_log_s *)__nwlog_obj();
      char v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_shoes_get_input_frames";
      uint64_t v17 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = (os_log_s *)__nwlog_obj();
    char v16 = type;
    uint32_t v21 = os_log_type_enabled(v15, type);
    if (backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v25 = "nw_protocol_shoes_get_input_frames";
        uint64_t v26 = 2082;
        uint64_t v27 = backtrace_string;
        uint64_t v20 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
        goto LABEL_30;
      }

      goto LABEL_31;
    }

    if (!v21) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_shoes_get_input_frames";
    uint64_t v17 = "%{public}s called with null shoes, no backtrace";
    goto LABEL_40;
  }

  if (handle[150] != 6) {
    return 0LL;
  }
  uint64_t v7 = *((void *)handle + 15);
  if (!v7) {
    return (*(uint64_t (**)(void))(*(void *)(*((void *)handle + 4) + 24LL) + 80LL))();
  }
  if ((_DWORD)a5)
  {
    uint64_t v8 = 1;
    while (1)
    {
      os_log_type_t v10 = *(void *)(v7 + 32);
      BOOL v11 = *(void **)(v7 + 40);
      BOOL v9 = (nw_frame **)(v7 + 32);
      if (v10)
      {
        *(void *)(v10 + 40) = v11;
        BOOL v11 = *(void **)(v7 + 40);
      }

      else
      {
        *((void *)handle + 16) = v11;
      }

      *BOOL v11 = v10;
      *BOOL v9 = 0LL;
      *(void *)(v7 + 40) = 0LL;
      tqh_last = a6->tqh_last;
      *(void *)(v7 + 40) = tqh_last;
      *tqh_last = (nw_frame *)v7;
      a6->tqh_last = v9;
      if ((_DWORD)a5 == v8) {
        break;
      }
      uint64_t v7 = *((void *)handle + 15);
      ++v8;
      if (!v7) {
        return (v8 - 1);
      }
    }
  }

  return a5;
}

    free(backtrace_string);
    goto LABEL_41;
  }

  id v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_shoes_copy_info";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_shoes_copy_info";
        BOOL v12 = "%{public}s called with null shoes";
        goto LABEL_40;
      }

      goto LABEL_41;
    }

    if (!v17)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_shoes_copy_info";
        BOOL v12 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_40;
      }

      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    char v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_shoes_copy_info";
        BOOL v12 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_40;
      }

      goto LABEL_41;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_protocol_shoes_copy_info";
      uint32_t v21 = 2082;
      uint64_t v22 = backtrace_string;
      os_log_type_t v15 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
      goto LABEL_30;
    }

    goto LABEL_31;
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 24)) != 0 && *(void *)(v5 + 224))
  {
    os_log_type_t v6 = nw_protocol_copy_info(v4, a2);
    if (a2 != 255) {
      return v6;
    }
  }

  else
  {
    os_log_type_t v6 = 0LL;
    if (a2 != 255) {
      return v6;
    }
  }

  uint64_t v7 = *(void **)(v2 + 88);
  if (v7)
  {
  }

  return v6;
}

      if (v9) {
LABEL_32:
      }
        free(v9);
LABEL_33:

      goto LABEL_34;
    }

    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v59 = "nw_context_cancel";
    v60 = 2048;
    v61 = v56;
    v62 = 2048;
    v63 = v22;
    uint64_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (__nwlog_fault(v27, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          v59 = "nw_context_cancel";
          v60 = 2048;
          v61 = v56;
          v62 = 2048;
          v63 = v22;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu",  buf,  0x20u);
        }
      }

      else if (v55)
      {
        v47 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v48 = type;
        v49 = os_log_type_enabled(v28, type);
        if (v47)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446978;
            v59 = "nw_context_cancel";
            v60 = 2048;
            v61 = v56;
            v62 = 2048;
            v63 = v22;
            v64 = 2082;
            v65 = v47;
            _os_log_impl( &dword_181A5C000,  v28,  v48,  "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v47);
          goto LABEL_107;
        }

        if (v49)
        {
          *(_DWORD *)buf = 136446722;
          v59 = "nw_context_cancel";
          v60 = 2048;
          v61 = v56;
          v62 = 2048;
          v63 = v22;
          _os_log_impl( &dword_181A5C000,  v28,  v48,  "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v53 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          v59 = "nw_context_cancel";
          v60 = 2048;
          v61 = v56;
          v62 = 2048;
          v63 = v22;
          _os_log_impl( &dword_181A5C000,  v28,  v53,  "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

      free(v29);
      goto LABEL_32;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      __int16 v32 = type;
      if (!os_log_type_enabled((os_log_t)v31, type))
      {
LABEL_29:

        goto LABEL_30;
      }

      *(_DWORD *)buf = 136446466;
      v44 = "-[NWNumericAccumulator dictionaryRepresentation]_block_invoke";
      v45 = 2112;
      v46 = (uint64_t)v21;
      v33 = "%{public}s failed to get name for state: %@";
    }

    else
    {
      if (v41)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v35 = (os_log_s *)(id)gLogObj;
        uint64_t v36 = type;
        v37 = os_log_type_enabled(v35, type);
        if (backtrace_string)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446722;
            v44 = "-[NWNumericAccumulator dictionaryRepresentation]_block_invoke";
            v45 = 2112;
            v46 = (uint64_t)v21;
            v47 = 2082;
            v48 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s failed to get name for state: %@, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          unint64_t v30 = v38;
          if (!v29) {
            goto LABEL_32;
          }
        }

        else
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446466;
            v44 = "-[NWNumericAccumulator dictionaryRepresentation]_block_invoke";
            v45 = 2112;
            v46 = (uint64_t)v21;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s failed to get name for state: %@, no backtrace",  buf,  0x16u);
          }

          unint64_t v30 = v38;
          if (!v29) {
            goto LABEL_32;
          }
        }

        goto LABEL_31;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      __int16 v32 = type;
      if (!os_log_type_enabled((os_log_t)v31, type)) {
        goto LABEL_29;
      }
      *(_DWORD *)buf = 136446466;
      v44 = "-[NWNumericAccumulator dictionaryRepresentation]_block_invoke";
      v45 = 2112;
      v46 = (uint64_t)v21;
      v33 = "%{public}s failed to get name for state: %@, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, (os_log_t)v31, v32, v33, buf, 0x16u);
    goto LABEL_29;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v24 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = [v10 count];
    uint64_t v26 = [*(id *)(*(void *)(a1 + 32) + 32) count];
    uint64_t v27 = [*(id *)(*(void *)(a1 + 32) + 40) count];
    *(_DWORD *)buf = 136446978;
    v44 = "-[NWNumericAccumulator dictionaryRepresentation]_block_invoke_2";
    v45 = 2048;
    v46 = v25;
    v47 = 2048;
    v48 = v26;
    v49 = 2048;
    v50 = v27;
    _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s Components count (%zu) != kvoWatchers count (%zu) + overriddenStates count (%zu)",  buf,  0x2Au);
  }

  if (a4) {
    *a4 = 1;
  }
LABEL_35:
}

        goto LABEL_32;
      }

      if (!v34)
      {
        __nwlog_obj();
        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v33,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_31;
      }

      uint64_t v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v30 = type;
      v31 = os_log_type_enabled(v9, type);
      if (!v27)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_181A5C000, v9, v30, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_31;
      }

      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_candidate_manager_set_state_changed_handler";
        v38 = 2082;
        v39 = v27;
        _os_log_impl( &dword_181A5C000,  v9,  v30,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

  __break(1u);
  return result;
}

    __int16 v23 = 1LL;
LABEL_87:

    goto LABEL_88;
  }

  os_log_type_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(*(void *)(v6 + 8) + 24LL);
  else {
    uint64_t v8 = *(void *)(a1 + 96) - v7;
  }
  if (!v7 && v8 >= *(void *)(a1 + 104))
  {
    int v28 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
    if (!v28)
    {
      if (!v8)
      {
        __nwlog_obj();
        v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v75 = "strict_malloc";
        v70 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v70);
        if (result) {
          goto LABEL_128;
        }
        free(v70);
      }

      unint64_t v29 = malloc(v8);
      if (!v29)
      {
        __nwlog_obj();
        v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        v75 = "strict_malloc";
        v76 = 2048;
        v77 = v8;
        v72 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v72);
        if (result) {
          goto LABEL_128;
        }
        free(v72);
      }

      *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v29;
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL)
                                                                              + 24LL);
      int v28 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
    }

    nw_dispatch_data_copyout_from_offset(v4, v28, v8, __n);
    unint64_t v30 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL));
    if (v30)
    {
      if (v30 >= v8) {
        __int16 v32 = v8;
      }
      else {
        __int16 v32 = v30;
      }
      nw_frame_claim((uint64_t)v3, v31, v32, 0);
    }

    if (*(_BYTE *)(a1 + 120) && !nw_frame_unclaimed_length(v3))
    {
      v33 = *((void *)v3 + 4);
      __int16 v34 = (void *)*((void *)v3 + 5);
      if (v33)
      {
        *(void *)(v33 + 40) = v34;
        __int16 v34 = (void *)*((void *)v3 + 5);
      }

      else
      {
        *(void *)(*(void *)(a1 + 88) + 8LL) = v34;
      }

      *__int16 v34 = v33;
      *((void *)v3 + 4) = 0LL;
      *((void *)v3 + 5) = 0LL;
      nw_frame_finalize((uint64_t)v3);
    }

    __int16 v23 = 0LL;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 1;
    goto LABEL_87;
  }

  if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL))
  {
LABEL_12:
    BOOL v11 = *(void *)(a1 + 104) - v7;
    if (v11 <= v5)
    {
      if (*(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL)) {
        uint64_t v8 = v11;
      }
      if (v8 == v5)
      {
        if (*(_BYTE *)(a1 + 121)) {
          uint64_t v26 = 1;
        }
        else {
          uint64_t v26 = *((char *)v3 + 186) < 0;
        }
        *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = v26;
      }

      if (gLogDatapath)
      {
        __nwlog_obj();
        v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          v52 = *(void *)(a1 + 32);
          if (v52) {
            v53 = (const char *)(v52 + 609);
          }
          else {
            v53 = "";
          }
          v54 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
          v55 = *(void *)(a1 + 104);
          *(_DWORD *)buf = 136447234;
          v75 = "nw_framer_parse_array_block_invoke";
          v76 = 2080;
          v77 = (size_t)v53;
          v78 = 2048;
          v79 = v54;
          v80 = 2048;
          v81 = v54 + v8;
          v82 = 2048;
          v83 = v55;
          _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Reading from %zu-%zu of %zu (complete)",  buf,  0x34u);
        }
      }

      nw_dispatch_data_copyout_from_offset( v4,  *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL)
      + *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL),
        v8,
        __n);
      __int16 v23 = 0LL;
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) += v8;
      goto LABEL_87;
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      {
        v42 = *(void *)(a1 + 32);
        if (v42) {
          v43 = (const char *)(v42 + 609);
        }
        else {
          v43 = "";
        }
        v44 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        v45 = *(void *)(a1 + 104);
        *(_DWORD *)buf = 136447234;
        v75 = "nw_framer_parse_array_block_invoke";
        v76 = 2080;
        v77 = (size_t)v43;
        v78 = 2048;
        v79 = v44;
        v80 = 2048;
        v81 = v44 + HIDWORD(__n);
        v82 = 2048;
        v83 = v45;
        _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Reading from %zu-%zu of %zu (partial)",  buf,  0x34u);
      }

      os_log_type_t v6 = *(void *)(a1 + 48);
      LODWORD(v5) = HIDWORD(__n);
    }

    nw_dispatch_data_copyout_from_offset( v4,  *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) + *(void *)(*(void *)(v6 + 8) + 24LL),  v5,  __n);
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) += HIDWORD(__n);
    goto LABEL_31;
  }

  BOOL v9 = *(void *)(a1 + 104);
  if (!v9)
  {
    __nwlog_obj();
    v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v75 = "strict_malloc";
    v62 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v62);
    if (result) {
      goto LABEL_128;
    }
    free(v62);
  }

  os_log_type_t v10 = malloc(v9);
  if (v10)
  {
LABEL_11:
    *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v10;
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL)
                                                                            + 24LL);
    os_log_type_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(*(void *)(v6 + 8) + 24LL);
    uint64_t v5 = HIDWORD(__n);
    goto LABEL_12;
  }

  __nwlog_obj();
  v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v75 = "strict_malloc";
  v76 = 2048;
  v77 = v9;
  v64 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v64);
  if (!result)
  {
    free(v64);
    os_log_type_t v10 = 0LL;
    goto LABEL_11;
  }

            free(v10);
            goto LABEL_32;
          }

          __nwlog_obj();
          v37 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v59 = "nw_framer_protocol_replace_input_handler";
          os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v56 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v38 = type;
            if (os_log_type_enabled(v31, type))
            {
              *(_DWORD *)buf = 136446210;
              v59 = "nw_framer_protocol_replace_input_handler";
              _os_log_impl(&dword_181A5C000, v31, v38, "%{public}s called with null new_input_handler", buf, 0xCu);
            }

    Connection = DNSServiceCreateDelegateConnection();
    if (!Connection)
    {

      goto LABEL_78;
    }

    if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
    {
      if (*v225)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v20 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_resolver_instantiate_dns_connection_for_parameters";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)v1 + 256;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = pid;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = Connection;
        uint32_t v21 = v20;
        uint64_t v22 = "%{public}s [C%{public}s] DNSServiceCreateDelegateConnection(..., epid=%u, NULL) failed: %d";
        __int16 v23 = 34;
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)(id)gLogObj;
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
LABEL_42:

          goto LABEL_43;
        }

        uint64_t v24 = *((_DWORD *)v1 + 85);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_resolver_instantiate_dns_connection_for_parameters";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v24;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = pid;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = Connection;
        uint32_t v21 = v20;
        uint64_t v22 = "%{public}s [R%u] DNSServiceCreateDelegateConnection(..., epid=%u, NULL) failed: %d";
        __int16 v23 = 30;
      }

      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_ERROR, v22, buf, v23);
      goto LABEL_42;
    }

        free(v22);
        goto LABEL_32;
      }

      os_log_type_t v15 = *((_DWORD *)v2 + 85);
      char v16 = nw_endpoint_get_logging_description(*((void **)v2 + 3));
      *(_DWORD *)buf = 136446978;
      v38 = "nw_resolver_start_query_timer";
      v39 = 1024;
      *(_DWORD *)v40 = v15;
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = 2;
      *(_WORD *)&v40[10] = 2082;
      *(void *)&v40[12] = v16;
      os_log_type_t v10 = "%{public}s [R%u] Starting %us query timer to receive all answers for %{public}s";
      BOOL v11 = v8;
      BOOL v12 = 34;
    }

    _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, v10, buf, v12);
    goto LABEL_20;
  }

  if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
  {
    if (*((_BYTE *)v1 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v3 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_33;
      }
      uint64_t v4 = nw_endpoint_get_logging_description(*((void **)v2 + 3));
      *(_DWORD *)buf = 136446722;
      v38 = "nw_resolver_start_query_timer";
      v39 = 2082;
      *(void *)v40 = (char *)v2 + 256;
      *(_WORD *)&v40[8] = 2082;
      *(void *)&v40[10] = v4;
      uint64_t v5 = "%{public}s [C%{public}s] Query timer already running for %{public}s";
      os_log_type_t v6 = v3;
      uint64_t v7 = 32;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v3 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
LABEL_33:

        goto LABEL_34;
      }

      uint64_t v13 = *((_DWORD *)v2 + 85);
      char v14 = nw_endpoint_get_logging_description(*((void **)v2 + 3));
      *(_DWORD *)buf = 136446722;
      v38 = "nw_resolver_start_query_timer";
      v39 = 1024;
      *(_DWORD *)v40 = v13;
      *(_WORD *)&v40[4] = 2082;
      *(void *)&v40[6] = v14;
      uint64_t v5 = "%{public}s [R%u] Query timer already running for %{public}s";
      os_log_type_t v6 = v3;
      uint64_t v7 = 28;
    }

    _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, v5, buf, v7);
    goto LABEL_33;
  }
}

      free(backtrace_string);
      goto LABEL_41;
    }

    BOOL v11 = (os_log_s *)__nwlog_obj();
    BOOL v12 = type[0];
    if (!os_log_type_enabled(v11, type[0])) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_trainer_top_flush_output";
    uint64_t v13 = "%{public}s called with null protocol";
LABEL_40:
    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
LABEL_41:
    if (v10) {
      free(v10);
    }
    return 0LL;
  }

  id v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_trainer_top_flush_output";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    uint64_t v27 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      BOOL v12 = type[0];
      if (!os_log_type_enabled(v11, type[0])) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_trainer_top_flush_output";
      uint64_t v13 = "%{public}s called with null trainer";
      goto LABEL_40;
    }

    if (!v27)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      BOOL v12 = type[0];
      if (!os_log_type_enabled(v11, type[0])) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_trainer_top_flush_output";
      uint64_t v13 = "%{public}s called with null trainer, backtrace limit exceeded";
      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = (os_log_s *)__nwlog_obj();
    BOOL v12 = type[0];
    uint64_t v17 = os_log_type_enabled(v11, type[0]);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_trainer_top_flush_output";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        char v16 = "%{public}s called with null trainer, dumping backtrace:%{public}s";
        goto LABEL_30;
      }

      goto LABEL_31;
    }

    if (!v17) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_trainer_top_flush_output";
    uint64_t v13 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_40;
  }

  if (!*(_DWORD *)(v2 + 192) || !*(void *)(v2 + 104)) {
    return 1LL;
  }
  BOOL v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 24);
    uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v4 + 88);
    if (v5 && *(void *)(v4 + 96))
    {
      *(void *)os_log_type_t type = 0LL;
      uint64_t v26 = type;
      v5(v3, a1, 1LL, 0xFFFFFFFFLL);
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      unint64_t v29 = 1;
      v18[0] = MEMORY[0x1895F87A8];
      v18[1] = 0x40000000LL;
      char v19 = (uint64_t (*)(void *))__nw_protocol_trainer_top_flush_output_block_invoke;
      uint64_t v20 = &unk_189BB87F0;
      uint32_t v21 = buf;
      uint64_t v22 = type;
      __int16 v23 = v2;
      uint64_t v24 = a1;
      os_log_type_t v6 = *(void *)type;
      do
      {
        if (!v6) {
          break;
        }
        uint64_t v7 = *(void *)(v6 + 32);
        uint64_t v8 = v19(v18);
        os_log_type_t v6 = v7;
      }

      while ((v8 & 1) != 0);
      BOOL v3 = (*(uint64_t (**)(uint64_t, os_log_type_t *))(*(void *)(v3 + 24) + 96LL))(v3, type);
      _Block_object_dispose(buf, 8);
      return v3;
    }

    return 0LL;
  }

  return v3;
}

    uint64_t v4 = 0LL;
    goto LABEL_32;
  }

  *((void *)handle + 13) = v10;
  handle[112] = v11 | 1;
  remote_endpoint = (void *)nw_protocol_get_remote_endpoint(*((void *)handle + 6));
  if (remote_endpoint)
  {
    uint64_t v20 = os_retain(remote_endpoint);
    uint32_t v21 = handle[128];
    if ((v21 & 1) == 0) {
      goto LABEL_37;
    }
  }

  else
  {
    uint64_t v20 = 0LL;
    uint32_t v21 = handle[128];
    if ((v21 & 1) == 0) {
      goto LABEL_37;
    }
  }

  uint64_t v22 = (void *)*((void *)handle + 15);
  if (v22)
  {
    os_release(v22);
    uint32_t v21 = handle[128];
  }

  free(v10);
  if (v4) {
LABEL_47:
  }
    free(v4);
}

  free(v9);
  if (v3) {
LABEL_47:
  }
    free(v3);
}

          free(v13);
          goto LABEL_5;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v14 = (id)gLogObj;
        __int16 v23 = type;
        if (!os_log_type_enabled((os_log_t)v14, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446466;
        unint64_t v30 = "nw_endpoint_flow_copy_multipath_tcp_info_block_invoke";
        v31 = 1024;
        __int16 v32 = v10;
        char v16 = (os_log_s *)v14;
        uint64_t v17 = v23;
        __int16 v18 = "%{public}s if_indextoname %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0x12u);
      goto LABEL_29;
    }
}

    return;
  }

  if (!v11 || nw_path_parameters_get_logging_disabled(v11[13])) {
    return;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  __int16 v25 = (id)gconnectionLogObj;
  uint64_t v26 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
  *(_DWORD *)buf = 136446466;
  v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
  v46 = 1024;
  v47 = v26;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v7 = (os_log_s *)(id)gconnectionLogObj;
    uint64_t v27 = type;
    if (os_log_type_enabled(v7, type))
    {
      int v28 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
      v46 = 1024;
      v47 = v28;
      _os_log_impl(&dword_181A5C000, v7, v27, "%{public}s [C%u] Connection does not support multi-path", buf, 0x12u);
    }

    goto LABEL_83;
  }

  if (!v42)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v7 = (os_log_s *)(id)gconnectionLogObj;
    v39 = type;
    if (os_log_type_enabled(v7, type))
    {
      v40 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
      v46 = 1024;
      v47 = v40;
      _os_log_impl( &dword_181A5C000,  v7,  v39,  "%{public}s [C%u] Connection does not support multi-path, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_83;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  uint64_t v7 = (os_log_s *)(id)gconnectionLogObj;
  unint64_t v35 = type;
  uint64_t v36 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (v36)
    {
      v41 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
      v46 = 1024;
      v47 = v41;
      _os_log_impl( &dword_181A5C000,  v7,  v35,  "%{public}s [C%u] Connection does not support multi-path, no backtrace",  buf,  0x12u);
    }

    goto LABEL_83;
  }

  if (v36)
  {
    v37 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    *(_DWORD *)buf = 136446722;
    v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
    v46 = 1024;
    v47 = v37;
    v48 = 2082;
    v49 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v7,  v35,  "%{public}s [C%u] Connection does not support multi-path, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

      free(backtrace_string);
      goto LABEL_41;
    }

    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_demux_connect";
    BOOL v12 = "%{public}s called with null protocol";
LABEL_40:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
LABEL_41:
    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_demux_connect";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_protocol_demux_connect";
      BOOL v12 = "%{public}s called with null demux";
      goto LABEL_40;
    }

    if (!v17)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_protocol_demux_connect";
      BOOL v12 = "%{public}s called with null demux, backtrace limit exceeded";
      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    char v16 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v20 = "nw_protocol_demux_connect";
        uint32_t v21 = 2082;
        uint64_t v22 = backtrace_string;
        os_log_type_t v15 = "%{public}s called with null demux, dumping backtrace:%{public}s";
        goto LABEL_30;
      }

      goto LABEL_31;
    }

    if (!v16) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_demux_connect";
    BOOL v12 = "%{public}s called with null demux, no backtrace";
    goto LABEL_40;
  }

  if ((nw_protocol *)handle[6] == a2)
  {
    BOOL result = handle[4];
    if (!result) {
      return result;
    }
    uint64_t v7 = *(void *)(result + 24);
    if (v7)
    {
      uint64_t v8 = *(uint64_t (**)(void))(v7 + 24);
      if (v8) {
        return v8();
      }
    }

    return 0LL;
  }

  if (a2)
  {
    callbacks = a2->callbacks;
    if (callbacks)
    {
      connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
      if (connected) {
        connected(a2, a1);
      }
    }
  }

  return 1LL;
}

  __break(1u);
  return result;
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_32;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "operator()";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "operator()";
    uint64_t v7 = "%{public}s called with null protocol";
    goto LABEL_31;
  }

  if (!v12)
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "operator()";
    uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_31;
  }

  uint64_t v8 = (char *)__nw_create_backtrace_string();
  uint64_t v5 = (os_log_s *)__nwlog_obj();
  os_log_type_t v6 = type;
  BOOL v9 = os_log_type_enabled(v5, type);
  if (!v8)
  {
    if (!v9) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "operator()";
    uint64_t v7 = "%{public}s called with null protocol, no backtrace";
    goto LABEL_31;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v15 = "operator()";
    char v16 = 2082;
    uint64_t v17 = v8;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v8);
  if (v4) {
    goto LABEL_33;
  }
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_45;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "operator()";
    BOOL v9 = "%{public}s called with null other_protocol";
    goto LABEL_44;
  }

  if (v17) {
    free(v17);
  }

  BOOL v12 = 0LL;
LABEL_4:

  return v12;
}

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

        goto LABEL_32;
      }

      if ((*((_BYTE *)v2 + 268) & 0x20) == 0) {
        goto LABEL_14;
      }
    }

    else if (!nw_parameters_get_indefinite(v1[4]))
    {
      goto LABEL_3;
    }

    if (a2) {
      char v19 = 8;
    }
    else {
      char v19 = 0;
    }
    HIBYTE(v4[39]._os_unfair_lock_opaque) = HIBYTE(v4[39]._os_unfair_lock_opaque) & 0xF7 | v19;
    os_unfair_lock_unlock(v4 + 30);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      uint32_t v21 = *(char **)&v4[24]._os_unfair_lock_opaque;
      *(_DWORD *)buf = 136446978;
      uint64_t v26 = "tcp_connection_get_socket";
      uint64_t v27 = 2048;
      int v28 = v21;
      unint64_t v29 = 1024;
      unint64_t v30 = os_unfair_lock_opaque;
      v31 = 1024;
      __int16 v32 = a2;
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %llu dupfd: %d, takeownership: %{BOOL}d",  buf,  0x22u);
    }

    goto LABEL_37;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v12 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "tcp_connection_get_socket";
    _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
  }

  os_unfair_lock_opaque = 0xFFFFFFFFLL;
LABEL_37:

  return os_unfair_lock_opaque;
}

    free(backtrace_string);
    goto LABEL_41;
  }

  os_log_type_t v15 = (os_log_s *)__nwlog_obj();
  char v16 = type;
  if (os_log_type_enabled(v15, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_http_encoding_create_inbound_frame";
    uint64_t v17 = "%{public}s called with null frame";
    goto LABEL_40;
  }

      free(backtrace_string);
    }
  }

      if (v6) {
        os_release(v6);
      }
      if (!outbound_message) {
        return;
      }
      v37 = outbound_message;
      goto LABEL_64;
    case 3:
      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      if ((*(_BYTE *)(*(void *)(a1 + 32) + 158LL) & 1) != 0) {
        return;
      }
      v39 = inbound_body_size;
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_30_44335);
      }
      uint32_t v21 = (os_log_s *)ghttpLogObj;
      if (!os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO)) {
        return;
      }
      v40 = *(void *)(a1 + 32);
      v41 = v40 + 74;
      v42 = *(void *)(v40 + 256);
      v43 = *(_DWORD *)(*(void *)(v40 + 248) + 372LL);
      if (v42) {
        LODWORD(v42) = *(_DWORD *)(v42 + 860);
      }
      v44 = *(_DWORD *)(v40 + 424);
      *(_DWORD *)buf = 136447746;
      v62 = "nw_http1_match_idle_connection_with_pending_stream_block_invoke";
      v63 = 2082;
      v64 = v41;
      v65 = 2080;
      v66 = " ";
      v67 = 1024;
      v68 = v43;
      v69 = 1024;
      v70 = v42;
      v71 = 1024;
      v72 = v44;
      v73 = 2048;
      v74 = v39;
      uint64_t v27 = "%{public}s %{public}s%s<i%u:c%u:s%u> finished receiving {body_bytes=%llu}";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_INFO, v27, buf, 0x3Cu);
      return;
    case 4:
      v45 = MEMORY[0x1895F87A8];
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 0x40000000LL;
      v58[2] = ___ZL50nw_http1_match_idle_connection_with_pending_streamP17nw_protocol_http1_block_invoke_48;
      v58[3] = &__block_descriptor_tmp_49_40227;
      v46 = *(void *)(a1 + 32);
      v58[4] = a2;
      v58[5] = v46;
      v47 = nw_http_transaction_metadata_get_outbound_message(a2);
      v48 = v47;
      if (v47)
      {
        v49 = nw_http_metadata_copy_request(v47);
        v50 = nw_http_metadata_copy_response(v48);
        inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message) {
          goto LABEL_52;
        }
        if (v49)
        {
          if (v50) {
            goto LABEL_53;
          }
          goto LABEL_51;
        }
      }

      else
      {
        v52 = nw_http_transaction_metadata_get_inbound_message(a2);
        v50 = 0LL;
        if (!v52)
        {
          v53 = 0;
          inbound_message = 0LL;
          goto LABEL_67;
        }

        inbound_message = v52;
      }

      v49 = nw_http_metadata_copy_request(inbound_message);
      if (v50) {
        goto LABEL_53;
      }
LABEL_51:
      v50 = nw_http_metadata_copy_response(inbound_message);
LABEL_52:
      if (!v50)
      {
        v53 = 0;
        if (!v49) {
          goto LABEL_67;
        }
LABEL_56:
        v56[0] = v45;
        v56[1] = 0x40000000LL;
        v56[2] = ___ZL50nw_http1_match_idle_connection_with_pending_streamP17nw_protocol_http1_block_invoke_50;
        v56[3] = &unk_189BBD5C8;
        v56[4] = v58;
        v57 = v53;
        v54 = v49;
        v55 = v56;
        _nw_http_request_access_method((uint64_t)v54, v55);

        if (!inbound_message) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }

    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    goto LABEL_32;
  }

  if (*(void *)(a1 + 48)) {
    return 0LL;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_http1_on_message_begin";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v10 = 0;
  if (__nwlog_fault(v2, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v3 = (os_log_s *)__nwlog_obj();
      uint64_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_http1_on_message_begin";
      uint64_t v5 = "%{public}s called with null http1_connection";
      goto LABEL_31;
    }

    if (!v10)
    {
      BOOL v3 = (os_log_s *)__nwlog_obj();
      uint64_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_http1_on_message_begin";
      uint64_t v5 = "%{public}s called with null http1_connection, backtrace limit exceeded";
      goto LABEL_31;
    }

    uint64_t v8 = (char *)__nw_create_backtrace_string();
    BOOL v3 = (os_log_s *)__nwlog_obj();
    uint64_t v4 = type;
    BOOL v9 = os_log_type_enabled(v3, type);
    if (!v8)
    {
      if (!v9) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_http1_on_message_begin";
      uint64_t v5 = "%{public}s called with null http1_connection, no backtrace";
      goto LABEL_31;
    }

    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_http1_on_message_begin";
      char v14 = 2082;
      os_log_type_t v15 = v8;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v8);
  }

    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    goto LABEL_32;
  }

  if (*(void *)(a1 + 48)) {
    return 0LL;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_http1_on_chunk_header";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v10 = 0;
  if (__nwlog_fault(v2, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v3 = (os_log_s *)__nwlog_obj();
      uint64_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_http1_on_chunk_header";
      uint64_t v5 = "%{public}s called with null http1_connection";
      goto LABEL_31;
    }

    if (!v10)
    {
      BOOL v3 = (os_log_s *)__nwlog_obj();
      uint64_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_http1_on_chunk_header";
      uint64_t v5 = "%{public}s called with null http1_connection, backtrace limit exceeded";
      goto LABEL_31;
    }

    uint64_t v8 = (char *)__nw_create_backtrace_string();
    BOOL v3 = (os_log_s *)__nwlog_obj();
    uint64_t v4 = type;
    BOOL v9 = os_log_type_enabled(v3, type);
    if (!v8)
    {
      if (!v9) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v13 = "nw_http1_on_chunk_header";
      uint64_t v5 = "%{public}s called with null http1_connection, no backtrace";
      goto LABEL_31;
    }

    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v13 = "nw_http1_on_chunk_header";
      char v14 = 2082;
      os_log_type_t v15 = v8;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v8);
  }

      if (v6) {
        os_release(v6);
      }
      if (!outbound_message) {
        return;
      }
      v37 = outbound_message;
      goto LABEL_64;
    case 3:
      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      if ((*(_BYTE *)(*(void *)(a1 + 32) + 158LL) & 1) != 0) {
        return;
      }
      v39 = inbound_body_size;
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_30_44335);
      }
      uint32_t v21 = (os_log_s *)ghttpLogObj;
      if (!os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO)) {
        return;
      }
      v40 = *(void *)(a1 + 32);
      v41 = v40 + 74;
      v42 = *(void *)(v40 + 256);
      v43 = *(_DWORD *)(*(void *)(v40 + 248) + 372LL);
      if (v42) {
        LODWORD(v42) = *(_DWORD *)(v42 + 860);
      }
      v44 = *(_DWORD *)(v40 + 424);
      *(_DWORD *)buf = 136447746;
      v62 = "nw_protocol_http1_connected_block_invoke";
      v63 = 2082;
      v64 = v41;
      v65 = 2080;
      v66 = " ";
      v67 = 1024;
      v68 = v43;
      v69 = 1024;
      v70 = v42;
      v71 = 1024;
      v72 = v44;
      v73 = 2048;
      v74 = v39;
      uint64_t v27 = "%{public}s %{public}s%s<i%u:c%u:s%u> finished receiving {body_bytes=%llu}";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_INFO, v27, buf, 0x3Cu);
      return;
    case 4:
      v45 = MEMORY[0x1895F87A8];
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 0x40000000LL;
      v58[2] = ___ZL27nw_protocol_http1_connectedP11nw_protocolS0__block_invoke_82;
      v58[3] = &__block_descriptor_tmp_83_41077;
      v46 = *(void *)(a1 + 32);
      v58[4] = a2;
      v58[5] = v46;
      v47 = nw_http_transaction_metadata_get_outbound_message(a2);
      v48 = v47;
      if (v47)
      {
        v49 = nw_http_metadata_copy_request(v47);
        v50 = nw_http_metadata_copy_response(v48);
        inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message) {
          goto LABEL_52;
        }
        if (v49)
        {
          if (v50) {
            goto LABEL_53;
          }
          goto LABEL_51;
        }
      }

      else
      {
        v52 = nw_http_transaction_metadata_get_inbound_message(a2);
        v50 = 0LL;
        if (!v52)
        {
          v53 = 0;
          inbound_message = 0LL;
          goto LABEL_67;
        }

        inbound_message = v52;
      }

      v49 = nw_http_metadata_copy_request(inbound_message);
      if (v50) {
        goto LABEL_53;
      }
LABEL_51:
      v50 = nw_http_metadata_copy_response(inbound_message);
LABEL_52:
      if (!v50)
      {
        v53 = 0;
        if (!v49) {
          goto LABEL_67;
        }
LABEL_56:
        v56[0] = v45;
        v56[1] = 0x40000000LL;
        v56[2] = ___ZL27nw_protocol_http1_connectedP11nw_protocolS0__block_invoke_84;
        v56[3] = &unk_189BBD7D8;
        v56[4] = v58;
        v57 = v53;
        v54 = v49;
        v55 = v56;
        _nw_http_request_access_method((uint64_t)v54, v55);

        if (!inbound_message) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }

      if (v6) {
        os_release(v6);
      }
      if (!outbound_message) {
        return;
      }
      v37 = outbound_message;
      goto LABEL_64;
    case 3:
      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      if ((*(_BYTE *)(*(void *)(a1 + 32) + 158LL) & 1) != 0) {
        return;
      }
      v39 = inbound_body_size;
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_30_44335);
      }
      uint32_t v21 = (os_log_s *)ghttpLogObj;
      if (!os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO)) {
        return;
      }
      v40 = *(void *)(a1 + 32);
      v41 = v40 + 74;
      v42 = *(void *)(v40 + 256);
      v43 = *(_DWORD *)(*(void *)(v40 + 248) + 372LL);
      if (v42) {
        LODWORD(v42) = *(_DWORD *)(v42 + 860);
      }
      v44 = *(_DWORD *)(v40 + 424);
      *(_DWORD *)buf = 136447746;
      v62 = "nw_protocol_http1_connect_block_invoke";
      v63 = 2082;
      v64 = v41;
      v65 = 2080;
      v66 = " ";
      v67 = 1024;
      v68 = v43;
      v69 = 1024;
      v70 = v42;
      v71 = 1024;
      v72 = v44;
      v73 = 2048;
      v74 = v39;
      uint64_t v27 = "%{public}s %{public}s%s<i%u:c%u:s%u> finished receiving {body_bytes=%llu}";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_INFO, v27, buf, 0x3Cu);
      return;
    case 4:
      v45 = MEMORY[0x1895F87A8];
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 0x40000000LL;
      v58[2] = ___ZL25nw_protocol_http1_connectP11nw_protocolS0__block_invoke_22;
      v58[3] = &__block_descriptor_tmp_24_41138;
      v46 = *(void *)(a1 + 32);
      v58[4] = a2;
      v58[5] = v46;
      v47 = nw_http_transaction_metadata_get_outbound_message(a2);
      v48 = v47;
      if (v47)
      {
        v49 = nw_http_metadata_copy_request(v47);
        v50 = nw_http_metadata_copy_response(v48);
        inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message) {
          goto LABEL_52;
        }
        if (v49)
        {
          if (v50) {
            goto LABEL_53;
          }
          goto LABEL_51;
        }
      }

      else
      {
        v52 = nw_http_transaction_metadata_get_inbound_message(a2);
        v50 = 0LL;
        if (!v52)
        {
          v53 = 0;
          inbound_message = 0LL;
          goto LABEL_67;
        }

        inbound_message = v52;
      }

      v49 = nw_http_metadata_copy_request(inbound_message);
      if (v50) {
        goto LABEL_53;
      }
LABEL_51:
      v50 = nw_http_metadata_copy_response(inbound_message);
LABEL_52:
      if (!v50)
      {
        v53 = 0;
        if (!v49) {
          goto LABEL_67;
        }
LABEL_56:
        v56[0] = v45;
        v56[1] = 0x40000000LL;
        v56[2] = ___ZL25nw_protocol_http1_connectP11nw_protocolS0__block_invoke_25;
        v56[3] = &unk_189BBD3E0;
        v56[4] = v58;
        v57 = v53;
        v54 = v49;
        v55 = v56;
        _nw_http_request_access_method((uint64_t)v54, v55);

        if (!inbound_message) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }

      if (v6) {
        os_release(v6);
      }
      if (!outbound_message) {
        return;
      }
      v37 = outbound_message;
      goto LABEL_64;
    case 3:
      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      if ((*(_BYTE *)(*(void *)(a1 + 32) + 158LL) & 1) != 0) {
        return;
      }
      v39 = inbound_body_size;
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_30_44335);
      }
      uint32_t v21 = (os_log_s *)ghttpLogObj;
      if (!os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO)) {
        return;
      }
      v40 = *(void *)(a1 + 32);
      v41 = v40 + 74;
      v42 = *(void *)(v40 + 256);
      v43 = *(_DWORD *)(*(void *)(v40 + 248) + 372LL);
      if (v42) {
        LODWORD(v42) = *(_DWORD *)(v42 + 860);
      }
      v44 = *(_DWORD *)(v40 + 424);
      *(_DWORD *)buf = 136447746;
      v62 = "nw_protocol_http1_connect_block_invoke";
      v63 = 2082;
      v64 = v41;
      v65 = 2080;
      v66 = " ";
      v67 = 1024;
      v68 = v43;
      v69 = 1024;
      v70 = v42;
      v71 = 1024;
      v72 = v44;
      v73 = 2048;
      v74 = v39;
      uint64_t v27 = "%{public}s %{public}s%s<i%u:c%u:s%u> finished receiving {body_bytes=%llu}";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_INFO, v27, buf, 0x3Cu);
      return;
    case 4:
      v45 = MEMORY[0x1895F87A8];
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 0x40000000LL;
      v58[2] = ___ZL25nw_protocol_http1_connectP11nw_protocolS0__block_invoke_34;
      v58[3] = &__block_descriptor_tmp_35_41127;
      v46 = *(void *)(a1 + 32);
      v58[4] = a2;
      v58[5] = v46;
      v47 = nw_http_transaction_metadata_get_outbound_message(a2);
      v48 = v47;
      if (v47)
      {
        v49 = nw_http_metadata_copy_request(v47);
        v50 = nw_http_metadata_copy_response(v48);
        inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message) {
          goto LABEL_52;
        }
        if (v49)
        {
          if (v50) {
            goto LABEL_53;
          }
          goto LABEL_51;
        }
      }

      else
      {
        v52 = nw_http_transaction_metadata_get_inbound_message(a2);
        v50 = 0LL;
        if (!v52)
        {
          v53 = 0;
          inbound_message = 0LL;
          goto LABEL_67;
        }

        inbound_message = v52;
      }

      v49 = nw_http_metadata_copy_request(inbound_message);
      if (v50) {
        goto LABEL_53;
      }
LABEL_51:
      v50 = nw_http_metadata_copy_response(inbound_message);
LABEL_52:
      if (!v50)
      {
        v53 = 0;
        if (!v49) {
          goto LABEL_67;
        }
LABEL_56:
        v56[0] = v45;
        v56[1] = 0x40000000LL;
        v56[2] = ___ZL25nw_protocol_http1_connectP11nw_protocolS0__block_invoke_36;
        v56[3] = &unk_189BBD488;
        v56[4] = v58;
        v57 = v53;
        v54 = v49;
        v55 = v56;
        _nw_http_request_access_method((uint64_t)v54, v55);

        if (!inbound_message) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }

        uint64_t v13 = 1;
        char v16 = 4;
        uint64_t v20 = *(void **)(v8 + 216);
        if (v20)
        {
LABEL_21:
          is_equal |= nw_endpoint_is_equal(v20, *(void **)(a1 + 32), 0LL);
          uint32_t v21 = *(void **)(v8 + 224);
          if (v21) {
            goto LABEL_22;
          }
          goto LABEL_33;
        }
  }
  }

    goto LABEL_32;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
    _os_log_impl(&dword_181A5C000, (os_log_t)v5, OS_LOG_TYPE_DEBUG, "%{public}s Mobile Asset not available", buf, 0xCu);
  }

  return v12;
}

      *a1 = v4;
LABEL_48:
      if ((v4 & 0x80) == 0 && ++v5 < a3) {
        continue;
      }
      goto LABEL_50;
    }

    os_log_type_t v6 = a1[1];
    if (!a1[1]) {
      goto LABEL_53;
    }
    if (v6 > 0xDF)
    {
      if (v6 == 224)
      {
        uint64_t v7 = *(char *)(a2 + v5);
        if (v4 == 2)
        {
          else {
            uint64_t v8 = 2;
          }
          goto LABEL_30;
        }

        goto LABEL_28;
      }

      if (v6 > 0xEC)
      {
        if (v6 == 237)
        {
          uint64_t v7 = *(char *)(a2 + v5);
          if (v4 == 2)
          {
            if (v7 > -97) {
              uint64_t v8 = -1;
            }
            else {
              uint64_t v8 = 2;
            }
            goto LABEL_30;
          }

          goto LABEL_28;
        }

        if (v6 > 0xEF)
        {
          if (v6 == 240)
          {
            uint64_t v7 = *(char *)(a2 + v5);
            if (v4 == 3)
            {
              else {
                uint64_t v8 = 3;
              }
              goto LABEL_30;
            }

            goto LABEL_28;
          }

          if (v6 > 0xF3)
          {
            if (v6 != 244) {
              goto LABEL_46;
            }
            BOOL v11 = *(char *)(a2 + v5);
            if (v4 == 3)
            {
              if (v11 > -113) {
                uint64_t v8 = -1;
              }
              else {
                uint64_t v8 = 3;
              }
              goto LABEL_30;
            }

            if (v11 < -64)
            {
LABEL_46:
              LOBYTE(v4) = v4 - 1;
              *a1 = v4;
              if (!(_BYTE)v4)
              {
                LOBYTE(v4) = 0;
                a1[1] = 0;
              }

              goto LABEL_48;
            }

            goto LABEL_29;
          }
        }
      }
    }

    uint64_t v7 = *(char *)(a2 + v5);
LABEL_28:
    if (v7 <= -65) {
      goto LABEL_46;
    }
LABEL_29:
    uint64_t v8 = -1;
LABEL_30:
    LOBYTE(v4) = v8 - 1;
    goto LABEL_31;
  }

          free(v33);
          if (!v26) {
            goto LABEL_88;
          }
          goto LABEL_69;
        }
      }

      else
      {
        __nwlog_obj();
        v68 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_ws_create_client_request";
        uint64_t v26 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v80[0]) = 0;
        if (__nwlog_fault(v26, type, v80))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v69 = type[0];
            if (os_log_type_enabled(v27, type[0]))
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_181A5C000, v27, v69, "%{public}s called with null endpoint", applier, 0xCu);
            }

            goto LABEL_67;
          }

          if (!LOBYTE(v80[0]))
          {
            __nwlog_obj();
            uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v78 = type[0];
            if (os_log_type_enabled(v27, type[0]))
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl( &dword_181A5C000,  v27,  v78,  "%{public}s called with null endpoint, backtrace limit exceeded",  applier,  0xCu);
            }

            goto LABEL_67;
          }

          v33 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v74 = type[0];
          v75 = os_log_type_enabled(v27, type[0]);
          if (!v33)
          {
            if (v75)
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl( &dword_181A5C000,  v27,  v74,  "%{public}s called with null endpoint, no backtrace",  applier,  0xCu);
            }

            goto LABEL_67;
          }

          if (v75)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = v33;
            _os_log_impl( &dword_181A5C000,  v27,  v74,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  applier,  0x16u);
          }

          goto LABEL_31;
        }
      }
    }

    else
    {
      __nwlog_obj();
      v66 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_ws_create_client_request";
      uint64_t v26 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v80[0]) = 0;
      if (__nwlog_fault(v26, type, v80))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v67 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            _os_log_impl(&dword_181A5C000, v27, v67, "%{public}s called with null framer", applier, 0xCu);
          }

          goto LABEL_67;
        }

        if (!LOBYTE(v80[0]))
        {
          __nwlog_obj();
          uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v77 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            _os_log_impl( &dword_181A5C000,  v27,  v77,  "%{public}s called with null framer, backtrace limit exceeded",  applier,  0xCu);
          }

          goto LABEL_67;
        }

        v33 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v72 = type[0];
        v73 = os_log_type_enabled(v27, type[0]);
        if (!v33)
        {
          if (v73)
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            _os_log_impl(&dword_181A5C000, v27, v72, "%{public}s called with null framer, no backtrace", applier, 0xCu);
          }

          goto LABEL_67;
        }

        if (v73)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = v33;
          _os_log_impl( &dword_181A5C000,  v27,  v72,  "%{public}s called with null framer, dumping backtrace:%{public}s",  applier,  0x16u);
        }

        goto LABEL_31;
      }
    }
  }

  else
  {
    __nwlog_obj();
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_ws_create_client_request";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80[0]) = 0;
    if (__nwlog_fault(v26, type, v80))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v65 = type[0];
        if (os_log_type_enabled(v27, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          _os_log_impl(&dword_181A5C000, v27, v65, "%{public}s called with null state", applier, 0xCu);
        }

        goto LABEL_67;
      }

      if (!LOBYTE(v80[0]))
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v76 = type[0];
        if (os_log_type_enabled(v27, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          _os_log_impl( &dword_181A5C000,  v27,  v76,  "%{public}s called with null state, backtrace limit exceeded",  applier,  0xCu);
        }

        goto LABEL_67;
      }

      v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v70 = type[0];
      v71 = os_log_type_enabled(v27, type[0]);
      if (!v33)
      {
        if (v71)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          _os_log_impl(&dword_181A5C000, v27, v70, "%{public}s called with null state, no backtrace", applier, 0xCu);
        }

        goto LABEL_67;
      }

      if (v71)
      {
        *(_DWORD *)applier = 136446466;
        *(void *)&applier[4] = "nw_ws_create_client_request";
        *(_WORD *)&applier[12] = 2082;
        *(void *)&applier[14] = v33;
        _os_log_impl( &dword_181A5C000,  v27,  v70,  "%{public}s called with null state, dumping backtrace:%{public}s",  applier,  0x16u);
      }

      goto LABEL_31;
    }
  }

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v13) {
    free(v13);
  }

  os_log_type_t v6 = 0LL;
LABEL_4:

  return v6;
}

  v39 = *(void **)(a1 + 40);
  if (v39)
  {
    v40 = v83[3];
    v41 = v39;
    v42 = dispatch_data_create_subrange(v41, v40, v48 - v40);
    v43 = *(void **)(a1 + 40);
    *(void *)(a1 + 40) = v42;

    char v14 = v49;
  }

  objc_storeWeak(v70 + 5, v28);
  v28[2](v28);
  v44 = *(dispatch_queue_s **)(a1 + 88);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __89__NWURLSessionMultipartParser_task_handleMultipartData_complete_error_completionHandler___block_invoke_2_74;
  block[3] = &unk_189BBF570;
  v52 = v80;
  v51 = v14;
  dispatch_group_notify(v26, v44, block);

  _Block_object_dispose(&v69, 8);
  objc_destroyWeak(&v74);

  _Block_object_dispose(v80, 8);
  _Block_object_dispose(&v82, 8);
  uint64_t v13 = v46;
  BOOL v11 = v47;
LABEL_34:
}

        goto LABEL_32;
      }

      if (gLogDatapath)
      {
        __nwlog_obj();
        os_log_type_t v15 = (id *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v20 = a1[5];
          *(_DWORD *)v39 = 136446722;
          *(void *)&v39[4] = "-[NWURLSessionMultipartParser task:handleMultipartData:complete:error:completionHandler:]_block_invoke";
          *(_WORD *)&v39[12] = 2112;
          *(void *)&v39[14] = v20;
          v40 = 1024;
          v41 = a3;
          _os_log_impl( &dword_181A5C000,  (os_log_t)v15,  OS_LOG_TYPE_DEBUG,  "%{public}s Discarding content, body %@, complete %{BOOL}d",  v39,  0x1Cu);
        }

        goto LABEL_31;
      }
    }

    if (!v6) {
      return;
    }
    goto LABEL_32;
  }

  uint64_t v5 = *(void *)(a1 + 32);
  *(_DWORD *)buf = 136446466;
  v86 = "nw_service_connector_cancel_block_invoke";
  v87 = 2114;
  v88 = v5;
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  v84 = OS_LOG_TYPE_ERROR;
  v83 = 0;
  if (v84 == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    uint64_t v8 = v84;
    if (os_log_type_enabled(v7, v84))
    {
      BOOL v9 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      v86 = "nw_service_connector_cancel_block_invoke";
      v87 = 2114;
      v88 = v9;
      _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s %{public}@ already cancelled", buf, 0x16u);
    }

  __int16 v34 = *(float *)(a1 + 228);
  unint64_t v35 = (float)*((unsigned int *)v9 + 18);
  if (v34 != 0.0) {
    unint64_t v35 = v34 + (float)(v35 - v34) * 0.4;
  }
  *(float *)(a1 + 228) = v35;
  if (a6 && a5 && (v9[13] & 2) != 0)
  {
    if (!*a6) {
      goto LABEL_62;
    }
    uint64_t v36 = v9[5];
    *a5 = 0x80;
    if (*a6 <= 0) {
      __assert_rtn("lsqpack_enc_int", "lsqpack.c", 759, "dst < end");
    }
    if (v36 > 0x7E)
    {
      v48 = &a5[*a6];
      *a5 = -1;
      v49 = a5 + 1;
      v50 = v36 - 127;
      if (v36 - 127 >= 0x80)
      {
        while (v49 < v48)
        {
          *v49++ = v50 | 0x80;
          uint64_t v36 = v50 >> 7;
          v51 = v50 >> 14;
          v50 >>= 7;
          if (!v51)
          {
            v52 = v49 - 1;
            goto LABEL_60;
          }
        }

        goto LABEL_62;
      }

      LOBYTE(v36) = v36 - 127;
      v52 = a5;
LABEL_60:
      if (v49 >= v48) {
        goto LABEL_62;
      }
      v37 = v52 + 2;
      *v49 = v36;
      if (v52 + 2 <= a5) {
        goto LABEL_62;
      }
    }

    else
    {
      *a5 = v36 | 0x80;
      v37 = a5 + 1;
    }

    v38 = (_DWORD)v37 - (_DWORD)a5;
    *a6 = v37 - a5;
    v39 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 24) += v38;
    if (v39)
    {
      v40 = *((_DWORD *)v9 + 16);
      v41 = 2 * v39 + v40 - *(_DWORD *)(a1 + 36);
      if (~(v41 / (2 * v39) * 2 * v39) + v41 < v39) {
        *(_DWORD *)(a1 + 36) = v40;
      }
    }
  }

  else if (a6)
  {
    *a6 = 0LL;
  }

  *a3 += v9[16];
  v42 = *(_DWORD *)(a1 + 28);
  v43 = *(_DWORD *)(a1 + 24) + *((_DWORD *)v9 + 12);
  *(_DWORD *)(a1 + 24) = v43;
  if (v42 >= 0x80000001)
  {
    *(_DWORD *)(a1 + 24) = (float)((float)((float)v43 * 1000.0) / (float)v42);
    *(_DWORD *)(a1 + 28) = 1000;
    v44 = *(FILE **)(a1 + 48);
    if (v44)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v44);
      v45 = *(FILE **)(a1 + 48);
      v46 = *(_DWORD *)(a1 + 28);
      if (v46)
      {
        v47 = (float)*(unsigned int *)(a1 + 24) / (float)v46;
        if (v45)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, *(FILE **)(a1 + 48));
          fprintf( *(FILE **)(a1 + 48),  "bytes in: %u; bytes out: %u, ratio: %.3f",
            *(_DWORD *)(a1 + 28),
            *(_DWORD *)(a1 + 24),
            v47);
          fputc(10, *(FILE **)(a1 + 48));
        }
      }

      else
      {
        v47 = 0.0;
      }

      fprintf(v45, "reset bytes in/out counters, ratio: %.3f", v47);
      fputc(10, *(FILE **)(a1 + 48));
    }
  }

  __int16 v18 = (FILE **)(a1 + 48);
  v53 = *(FILE **)(a1 + 48);
  if (v53)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v53);
    fprintf(*v18, "header block for stream %llu is done", v9[5]);
    v31 = 0LL;
    goto LABEL_28;
  }

  v31 = 0LL;
LABEL_63:
  v54 = *((_DWORD *)v9 + 26);
  if ((v54 & 0x10) != 0)
  {
    v55 = *v9;
    v56 = (void *)v9[1];
    if (*v9)
    {
      *(void *)(v55 + 8) = v56;
      *(void *)v9[1] = v55;
      if ((v54 & 4) == 0) {
        goto LABEL_72;
      }
    }

    else
    {
      *(void *)(a1 + 88) = v56;
      *v56 = 0LL;
      if ((v54 & 4) == 0)
      {
LABEL_72:
        free(v9);
        return v31;
      }
    }

    v57 = v9[2];
    if (v57) {
      *(void *)(v57 + 24) = v9[3];
    }
    else {
      *(void *)(a1 + 16LL * (v9[8] & 7) + 104) = v9[3];
    }
    *(void *)v9[3] = v57;
    --*(_DWORD *)(a1 + 224);
    goto LABEL_72;
  }

  return v31;
}

  if (!self) {
    goto LABEL_11;
  }
LABEL_10:
  fileURL = self->_fileURL;
  if (!fileURL) {
    goto LABEL_11;
  }
LABEL_37:
  v41 = fileURL;
  uint32_t v21 = v41;
  if (self->_isResuming) {
    v42 = 521;
  }
  else {
    v42 = 2561;
  }
  v43 = open(-[NSURL fileSystemRepresentation](v41, "fileSystemRepresentation"), v42, 438LL);
  if (v43 == -1) {
    goto LABEL_34;
  }
  __int16 v23 = v43;

  if (!v8) {
    goto LABEL_42;
  }
LABEL_18:
  unint64_t v29 = v8[50];
  unint64_t v30 = v29;
  if (v29) {
    v31 = (void *)*((void *)v29 + 18);
  }
  else {
    v31 = 0LL;
  }
LABEL_20:
  __int16 v32 = v31;
  cleanup_handler[0] = MEMORY[0x1895F87A8];
  cleanup_handler[1] = 3221225472LL;
  cleanup_handler[2] = __79__NWURLSessionResponseConsumerDownload_task_deliverResponse_completionHandler___block_invoke;
  cleanup_handler[3] = &unk_189BC08D0;
  cleanup_handler[4] = self;
  v48 = v23;
  v47 = v8;
  v33 = (OS_dispatch_io *)dispatch_io_create(0LL, v23, v32, cleanup_handler);
  if (self)
  {
    io = self->_io;
    self->_io = v33;

    unint64_t v35 = self->_io;
  }

  else
  {

    unint64_t v35 = 0LL;
  }

  dispatch_io_set_low_water((dispatch_io_t)v35, 0xFFFFFFFFFFFFFFFFLL);
  v11[2](v11, 1LL, 0LL);

LABEL_23:
}

    v39 = 0LL;
    goto LABEL_50;
  }

  *(_OWORD *)uu = *((_OWORD *)v36 + 8);

  *(void *)buf = 0LL;
  *(void *)&buf[8] = 0LL;
  can_support_user_packet_pool = nw_path_flow_nexus_can_support_user_packet_pool(v36);
  else {
    v50 = 0;
  }
  buf[12] = v50 | can_support_user_packet_pool;
  v51 = v36;
  v52 = v51[1];
  if (!v52 || (v53 = *((_DWORD *)v51 + 40)) == 0)
  {
    v53 = 0;
    v52 = 0LL;
  }

  *(_DWORD *)&buf[8] = v53;

  char v16 = &OBJC_IVAR___NWConcrete_tcp_connection_tc_event_disconnected_delivered;
  *(void *)buf = v52;
  v39 = nw_channel_create_with_attributes(v34, (unsigned __int8 *)uu, v37, (uint64_t)buf);
LABEL_50:
  v54 = a1[10];
  a1[10] = (id)v39;

  if (!a1[10])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v57 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      v58 = *(char **)((char *)v15 + v16[546]);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v13;
      v138 = 2114;
      v139 = v58;
      _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ nw_channel_create_with_nexus_flow for %{public}@ failed",  buf,  0x20u);
    }

    goto LABEL_102;
  }

  a1[13] = nw_ip_channel_inbox_protocol_identifier;
  a1[14] = &nw_ip_channel_inbox_protocol_callbacks;
  a1[16] = a1;
  nw_path_flow_get_id(*(id *)((char *)a1 + v16[546]), a1 + 11);
  nw_channel_set_close_automatically((uint64_t)a1[10], 1);
  nw_channel_set_defer_input_available((uint64_t)a1[10], 1);
  nw_channel_set_protocol_level((uint64_t)a1[10], *((_DWORD *)a1 + 14));
  protocol_handler = nw_channel_get_protocol_handler((uint64_t)a1[10]);
  if (((**(uint64_t (***)(uint64_t, uint64_t))(protocol_handler + 24))(protocol_handler, (uint64_t)(a1 + 11)) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v59 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
    v60 = (char *)_os_log_send_and_compose_impl();

    uu[0] = OS_LOG_TYPE_ERROR;
    v136 = 0;
    if (__nwlog_fault(v60, uu, &v136))
    {
      if (uu[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v61 = (os_log_s *)(id)gLogObj;
        v62 = uu[0];
        if (os_log_type_enabled(v61, uu[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl(&dword_181A5C000, v61, v62, "%{public}s channel protocol add_input_handler failed", buf, 0xCu);
        }
      }

      else if (v136)
      {
        v69 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v70 = uu[0];
        v71 = os_log_type_enabled(v61, uu[0]);
        if (v69)
        {
          if (v71)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v69;
            _os_log_impl( &dword_181A5C000,  v61,  v70,  "%{public}s channel protocol add_input_handler failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v69);
          if (!v60) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        if (v71)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl( &dword_181A5C000,  v61,  v70,  "%{public}s channel protocol add_input_handler failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v76 = uu[0];
        if (os_log_type_enabled(v61, uu[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl( &dword_181A5C000,  v61,  v76,  "%{public}s channel protocol add_input_handler failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v60)
    {
LABEL_101:

LABEL_102:
      a1 = 0LL;
      goto LABEL_103;
    }

    uint64_t v17 = *(void *)(v1 + 280);
    __int16 v18 = *(void **)(v1 + 288);
    *(void *)(v1 + 280) = v9 - 1;
    *(void *)(v1 + 288) = v12;
    ++*(void *)(v1 + 24);
    char v19 = v17 + 1;
    if (v17 == -1)
    {
      uint64_t v20 = 0;
    }

    else
    {
      int v28 = 0LL;
      uint64_t v20 = 0;
      do
      {
        unint64_t v29 = (void *)v18[v28];
        if (v29)
        {
          unint64_t v30 = *(void *)(v1 + 272);
          do
          {
            v18[v28] = *v29;
            v31 = 8 * ((v29[1] >> v30) & (v9 - 1));
            *unint64_t v29 = *(void *)(v12 + v31);
            *(void *)(v12 + v31) = v29;
            ++v20;
            unint64_t v29 = (void *)v18[v28];
          }

          while (v29);
        }

        ++v28;
      }

      while (v19 > v28);
    }

    if (gLogDatapath)
    {
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v39 = 136447234;
        *(void *)&v39[4] = "nw_mem_cache_hash_rescale";
        v40 = 2048;
        v41 = v1;
        v42 = 1024;
        v43 = v19;
        v44 = 1024;
        v45 = v9;
        v46 = 1024;
        v47 = v20;
        _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s nwm %p old_size %u new_size %u [%u moved]",  v39,  0x28u);
      }
    }

    if (v18) {
      free(v18);
    }
  }

      free(backtrace_string);
    }
  }

      if (nw_browser_fail_on_dns_error_locked( (NWConcrete_nw_browser *)v14,  a4,  "nw_browser_dns_service_browse_callback"))
      {
        goto LABEL_48;
      }

      uint64_t v27 = v14[18]._os_unfair_lock_opaque;
      if (v27 == 4)
      {
        nw_browser_set_state_locked(v14, 1, 0LL);
        uint64_t v27 = v14[18]._os_unfair_lock_opaque;
      }

      if (v27 != 1) {
        goto LABEL_48;
      }
      if (!a5 || !*a5)
      {
        if (!nw_parameters_get_logging_disabled(*(void *)&v14[10]._os_unfair_lock_opaque))
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          unint64_t v30 = (os_log_s *)(id)gbrowserLogObj;
          if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
          {
            v31 = v14[48]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446466;
            v93 = "nw_browser_dns_service_browse_callback";
            v94 = 1024;
            *(_DWORD *)v95 = v31;
            _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s [B%u] Received empty result, ignoring",  buf,  0x12u);
          }
        }

        goto LABEL_48;
      }

      if (a3 - 1 > 0xFFFFFFFD)
      {
        if (a3 == -1)
        {
          unint64_t v29 = nw_interface_create_with_name("lo0");
          if (!v29) {
            goto LABEL_121;
          }
        }

        else
        {
          unint64_t v29 = 0LL;
        }
      }

      else
      {
        if (nw_context_copy_implicit_context::onceToken != -1) {
          dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
        }
        int v28 = (id)nw_context_copy_implicit_context::implicit_context;
        unint64_t v29 = nw_path_copy_interface_with_generation(v28, a3, 0);

        if (!v29)
        {
LABEL_121:
          if (nw_parameters_get_logging_disabled(*(void *)&v14[10]._os_unfair_lock_opaque))
          {
LABEL_48:
            os_unfair_lock_unlock(lock);
            goto LABEL_49;
          }

          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          v60 = (id)gbrowserLogObj;
          v61 = v14[48]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v93 = "nw_browser_dns_service_browse_callback";
          v94 = 1024;
          *(_DWORD *)v95 = v61;
          *(_WORD *)&v95[4] = 1024;
          *(_DWORD *)&v95[6] = a3;
          v62 = (char *)_os_log_send_and_compose_impl();

          v79[0] = 16;
          LOBYTE(v104) = 0;
          if (__nwlog_fault(v62, v79, &v104))
          {
            if (v79[0] == 17)
            {
              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
              }
              v63 = (os_log_s *)(id)gbrowserLogObj;
              v64 = v79[0];
              if (os_log_type_enabled(v63, (os_log_type_t)v79[0]))
              {
                v65 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136446722;
                v93 = "nw_browser_dns_service_browse_callback";
                v94 = 1024;
                *(_DWORD *)v95 = v65;
                *(_WORD *)&v95[4] = 1024;
                *(_DWORD *)&v95[6] = a3;
                _os_log_impl( &dword_181A5C000,  v63,  v64,  "%{public}s [B%u] dns: no interface found for if_index %u",  buf,  0x18u);
              }
            }

            else if ((_BYTE)v104)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v67 = (char *)backtrace_string;
                if (__nwlog_browser_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                }
                v68 = (os_log_s *)(id)gbrowserLogObj;
                v69 = v79[0];
                if (os_log_type_enabled(v68, (os_log_type_t)v79[0]))
                {
                  v70 = v14[48]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446978;
                  v93 = "nw_browser_dns_service_browse_callback";
                  v94 = 1024;
                  *(_DWORD *)v95 = v70;
                  *(_WORD *)&v95[4] = 1024;
                  *(_DWORD *)&v95[6] = a3;
                  *(_WORD *)&v95[10] = 2082;
                  *(void *)&v95[12] = v67;
                  _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s [B%u] dns: no interface found for if_index %u, dumping backtrace:%{public}s",  buf,  0x22u);
                }

                free(v67);
                goto LABEL_148;
              }

              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
              }
              v63 = (os_log_s *)(id)gbrowserLogObj;
              v73 = v79[0];
              if (os_log_type_enabled(v63, (os_log_type_t)v79[0]))
              {
                v74 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136446722;
                v93 = "nw_browser_dns_service_browse_callback";
                v94 = 1024;
                *(_DWORD *)v95 = v74;
                *(_WORD *)&v95[4] = 1024;
                *(_DWORD *)&v95[6] = a3;
                _os_log_impl( &dword_181A5C000,  v63,  v73,  "%{public}s [B%u] dns: no interface found for if_index %u, no backtrace",  buf,  0x18u);
              }
            }

            else
            {
              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
              }
              v63 = (os_log_s *)(id)gbrowserLogObj;
              v71 = v79[0];
              if (os_log_type_enabled(v63, (os_log_type_t)v79[0]))
              {
                v72 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136446722;
                v93 = "nw_browser_dns_service_browse_callback";
                v94 = 1024;
                *(_DWORD *)v95 = v72;
                *(_WORD *)&v95[4] = 1024;
                *(_DWORD *)&v95[6] = a3;
                _os_log_impl( &dword_181A5C000,  v63,  v71,  "%{public}s [B%u] dns: no interface found for if_index %u, backtrace limit exceeded",  buf,  0x18u);
              }
            }
          }

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

            goto LABEL_32;
          }
        }

        else
        {
          uint64_t v13 = 0LL;
        }

        if (v10)
        {
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___Z44nw_endpoint_flow_get_multipath_subflow_countP27NWConcrete_nw_endpoint_flow_block_invoke;
          v44 = &unk_189BC78E8;
          v45 = type;
          nw_fd_wrapper_get_fd(v10, buf);
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Protocol not supported", buf, 0xCu);
          }
        }

        goto LABEL_31;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v25 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
      uint64_t v26 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v42 = 0;
      if (__nwlog_fault(v26, type, &v42))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v27 = (os_log_s *)(id)gLogObj;
          int v28 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null endpoint_flow", buf, 0xCu);
          }
        }

        else if (v42)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v27 = (os_log_s *)(id)gLogObj;
          v33 = type[0];
          __int16 v34 = os_log_type_enabled(v27, type[0]);
          if (backtrace_string)
          {
            if (v34)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v27,  v33,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_72;
          }

          if (v34)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl( &dword_181A5C000,  v27,  v33,  "%{public}s called with null endpoint_flow, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v27 = (os_log_s *)(id)gLogObj;
          uint64_t v36 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl( &dword_181A5C000,  v27,  v36,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    free(backtrace_string);
    goto LABEL_44;
  }

  if (*(_DWORD *)a2 != *(_DWORD *)a3
    || *(_DWORD *)(a2 + 4) != *(_DWORD *)(a3 + 4)
    || *(_DWORD *)(a2 + 8) != *(_DWORD *)(a3 + 8)
    || *(_DWORD *)(a2 + 12) != *(_DWORD *)(a3 + 12)
    || !a4 && ((*(_BYTE *)(a3 + 16) ^ *(_BYTE *)(a2 + 16)) & 3) != 0)
  {
LABEL_10:
    uint64_t v8 = 0LL;
    goto LABEL_11;
  }

  uint64_t v8 = 1LL;
LABEL_11:

  return v8;
}

  if (v10) {
    free(v10);
  }
}

      os_release(v8);
    }
  }

    _os_log_impl(&dword_181A5C000, v2, v3, v4, buf, 0xCu);
    goto LABEL_32;
  }

  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v12 = "nw_protocol_socket_notify";
  uint64_t v1 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v9 = 0;
  if (__nwlog_fault(v1, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v2 = (os_log_s *)__nwlog_obj();
      BOOL v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v12 = "nw_protocol_socket_notify";
      uint64_t v4 = "%{public}s called with null socket_handler";
      goto LABEL_31;
    }

    if (!v9)
    {
      id v2 = (os_log_s *)__nwlog_obj();
      BOOL v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v12 = "nw_protocol_socket_notify";
      uint64_t v4 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_31;
    }

    uint64_t v7 = (char *)__nw_create_backtrace_string();
    id v2 = (os_log_s *)__nwlog_obj();
    BOOL v3 = type;
    uint64_t v8 = os_log_type_enabled(v2, type);
    if (!v7)
    {
      if (!v8) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v12 = "nw_protocol_socket_notify";
      uint64_t v4 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_31;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v12 = "nw_protocol_socket_notify";
      uint64_t v13 = 2082;
      char v14 = v7;
      _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s called with null socket_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v7);
  }

  if (v10) {
    free(v10);
  }
}

  if (v16) {
    free(v16);
  }
  uint64_t v8 = 0LL;
LABEL_5:

  return v8;
}

  if (v19) {
    free(v19);
  }
  char v16 = 0LL;
LABEL_14:

  return v16;
}

        goto LABEL_32;
      }

      if (!LOBYTE(applier[0]))
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v36 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
          _os_log_impl( &dword_181A5C000,  v10,  v36,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_31;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v34 = type[0];
      unint64_t v35 = os_log_type_enabled(v10, type[0]);
      if (!backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
          _os_log_impl(&dword_181A5C000, v10, v34, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }

        goto LABEL_31;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v34,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

      free(v14);
      goto LABEL_32;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v23 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_181A5C000, v15, v23, "%{public}s called with null parameters", buf, 0xCu);
      }

      goto LABEL_29;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v26 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl( &dword_181A5C000,  v15,  v26,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v24 = type;
    __int16 v25 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_181A5C000, v15, v24, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_29;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v30 = "nw_path_create_evaluator_for_listener";
      v31 = 2082;
      __int16 v32 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v15,  v24,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_22;
  }

  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_evaluator);
  os_log_type_t v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unint64_t v30 = "nw_path_create_evaluator_for_listener";
    char v14 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = (os_log_s *)(id)gLogObj;
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed",  buf,  0xCu);
      }

    goto LABEL_32;
  }

  if (uuid_is_null(a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unint64_t v35 = "nw_path_increment_agent_use_count";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      BOOL v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null agent_uuid", buf, 0xCu);
      }
    }

    else if (v32)
    {
      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      char v16 = type;
      uint64_t v17 = os_log_type_enabled(v8, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v35 = "nw_path_increment_agent_use_count";
          uint64_t v36 = 2082;
          v37[0] = v15;
          _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null agent_uuid, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        if (!v7) {
          goto LABEL_34;
        }
        goto LABEL_33;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v35 = "nw_path_increment_agent_use_count";
        _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null agent_uuid, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)(id)gLogObj;
      __int16 v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v35 = "nw_path_increment_agent_use_count";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null agent_uuid, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_31;
  }

  os_log_type_t v10 = nw_parameters_copy_context(v5[2]);
  BOOL v11 = nw_path_shared_necp_fd(v10);

  if (v11 < 0) {
    goto LABEL_34;
  }
  v39 = 0LL;
  v38 = *(_OWORD *)a2;
  if (necp_client_action())
  {
    BOOL v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (os_log_s *)(id)gLogObj;
    char v14 = v13;
    if (v12 == 2)
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v35 = "nw_path_increment_agent_use_count";
        uint64_t v36 = 1024;
        LODWORD(v37[0]) = 2;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d",  buf,  0x12u);
      }

      goto LABEL_34;
    }

    *(_DWORD *)buf = 136446466;
    unint64_t v35 = "nw_path_increment_agent_use_count";
    uint64_t v36 = 1024;
    LODWORD(v37[0]) = v12;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v32 = 0;
    if (__nwlog_fault(v7, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = (os_log_s *)(id)gLogObj;
        uint64_t v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v35 = "nw_path_increment_agent_use_count";
          uint64_t v36 = 1024;
          LODWORD(v37[0]) = v12;
          _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d",  buf,  0x12u);
        }
      }

      else if (v32)
      {
        uint64_t v22 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v23 = type;
        uint64_t v24 = os_log_type_enabled(v8, type);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446722;
            unint64_t v35 = "nw_path_increment_agent_use_count";
            uint64_t v36 = 1024;
            LODWORD(v37[0]) = v12;
            WORD2(v37[0]) = 2082;
            *(void *)((char *)v37 + 6) = v22;
            _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v22);
          if (!v7) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }

        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v35 = "nw_path_increment_agent_use_count";
          uint64_t v36 = 1024;
          LODWORD(v37[0]) = v12;
          _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v25 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v35 = "nw_path_increment_agent_use_count";
          uint64_t v36 = 1024;
          LODWORD(v37[0]) = v12;
          _os_log_impl( &dword_181A5C000,  v8,  v25,  "%{public}s NECP_CLIENT_ACTION_AGENT_USE %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }
      }

      goto LABEL_31;
    }

      goto LABEL_32;
    }

    if (v42 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_path_copy_token_from_agent";
        _os_log_impl( &dword_181A5C000,  v8,  v40,  "%{public}s called with null out_token_length, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v35 = type[0];
    uint64_t v36 = os_log_type_enabled(v8, type[0]);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_path_copy_token_from_agent";
        _os_log_impl(&dword_181A5C000, v8, v35, "%{public}s called with null out_token_length, no backtrace", buf, 0xCu);
      }

      goto LABEL_31;
    }

    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v45 = "nw_path_copy_token_from_agent";
      v46 = 2082;
      *(void *)v47 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v8,  v35,  "%{public}s called with null out_token_length, dumping backtrace:%{public}s",  buf,  0x16u);
    }

        goto LABEL_32;
      }

      if (!LOBYTE(v58[0]))
      {
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v52 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_necp_append_tlv";
          *(_WORD *)&applier[12] = 2048;
          *(void *)&applier[14] = v8;
          *(_WORD *)&applier[22] = 2048;
          *(void *)v64 = v10;
          *(_WORD *)&v64[8] = 1024;
          *(_DWORD *)&v64[10] = 2;
          *(_WORD *)&v64[14] = 1024;
          *(_DWORD *)&v64[16] = size;
          _os_log_impl( &dword_181A5C000,  v14,  v52,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  applier,  0x2Cu);
        }

        goto LABEL_31;
      }

      v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v43 = type[0];
      v44 = os_log_type_enabled(v14, type[0]);
      if (!v42)
      {
        if (v44)
        {
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_necp_append_tlv";
          *(_WORD *)&applier[12] = 2048;
          *(void *)&applier[14] = v8;
          *(_WORD *)&applier[22] = 2048;
          *(void *)v64 = v10;
          *(_WORD *)&v64[8] = 1024;
          *(_DWORD *)&v64[10] = 2;
          *(_WORD *)&v64[14] = 1024;
          *(_DWORD *)&v64[16] = size;
          _os_log_impl( &dword_181A5C000,  v14,  v43,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  applier,  0x2Cu);
        }

        goto LABEL_31;
      }

      if (v44)
      {
        *(_DWORD *)applier = 136447490;
        *(void *)&applier[4] = "nw_necp_append_tlv";
        *(_WORD *)&applier[12] = 2048;
        *(void *)&applier[14] = v8;
        *(_WORD *)&applier[22] = 2048;
        *(void *)v64 = v10;
        *(_WORD *)&v64[8] = 1024;
        *(_DWORD *)&v64[10] = 2;
        *(_WORD *)&v64[14] = 1024;
        *(_DWORD *)&v64[16] = size;
        *(_WORD *)&v64[20] = 2082;
        *(void *)&v64[22] = v42;
        _os_log_impl( &dword_181A5C000,  v14,  v43,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  applier,  0x36u);
      }

      free(v42);
    }

  if (v13) {
    free(v13);
  }

  os_log_type_t v10 = 0LL;
LABEL_4:

  return v10;
}
  }

    if (v12) {
      free(v12);
    }
    return 0LL;
  }

  uint64_t v5 = calloc(1uLL, 0x100uLL);
  if (v5) {
    goto LABEL_3;
  }
  char v16 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v24 = "strict_calloc";
  __int16 v25 = 2048;
  uint64_t v26 = 1LL;
  uint64_t v27 = 2048;
  int v28 = 256LL;
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
LABEL_3:
    v5[14] = 0u;
    v5[15] = 0u;
    v5[12] = 0u;
    v5[13] = 0u;
    v5[10] = 0u;
    v5[11] = 0u;
    v5[8] = 0u;
    v5[9] = 0u;
    v5[6] = 0u;
    v5[7] = 0u;
    v5[4] = 0u;
    v5[5] = 0u;
    v5[2] = 0u;
    v5[3] = 0u;
    *uint64_t v5 = 0u;
    v5[1] = 0u;
    if (gLogDatapath)
    {
      __int16 v18 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v24 = "nw_protocol_http_alt_svc_create";
        __int16 v25 = 2082;
        uint64_t v26 = (uint64_t)v5 + 114;
        uint64_t v27 = 2080;
        int v28 = (uint64_t)" ";
        _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }

    if (nw_protocol_http_alt_svc_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http_alt_svc_identifier::onceToken, &__block_literal_global_70626);
    }
    *((void *)v5 + 2) = nw_protocol_http_alt_svc_identifier::protocol_identifier;
    *((void *)v5 + 3) = &nw_protocol_http_alt_svc_get_callbacks(void)::protocol_callbacks;
    *((void *)v5 + 5) = v5;
    os_log_type_t v6 = a4;
    uint64_t v7 = v6[12];

    *((_BYTE *)v5 + 248) = *((_BYTE *)v5 + 248) & 0xFE | ((v7 & 0x8000) != 0);
    uint64_t v8 = os_retain(v6);
    BOOL v9 = *((_BYTE *)v5 + 224);
    if ((v9 & 1) != 0)
    {
      os_log_type_t v10 = (void *)*((void *)v5 + 27);
      if (v10)
      {
        os_release(v10);
        BOOL v9 = *((_BYTE *)v5 + 224);
      }
    }

    *((void *)v5 + 27) = v8;
    *((_BYTE *)v5 + 224) = v9 | 1;
    *((void *)v5 + 8) = (char *)v5 + 104;
    nw_protocol_plugin_name_set_callbacks((uint64_t)v5, (uint64_t)nw_protocol_http_alt_svc_create::$_0::__invoke);
    return (BOOL)v5;
  }

  __break(1u);
  return result;
}

          free(v12);
          goto LABEL_42;
        }

        if (!v14) {
          goto LABEL_41;
        }
        *(_DWORD *)buf = 136446722;
        v33 = "nw_endpoint_create_with_peer_name";
        __int16 v34 = 1024;
        unint64_t v35 = v31;
        uint64_t v36 = 1024;
        LODWORD(v37[0]) = address[0].sa_len;
        BOOL v9 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u, no backtrace";
        uint32_t v21 = (sockaddr *)buf;
        uint64_t v22 = v7;
        __int16 v23 = v13;
LABEL_35:
        uint64_t v24 = 24;
LABEL_40:
        _os_log_impl(&dword_181A5C000, v22, v23, v9, &v21->sa_len, v24);
        goto LABEL_41;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      uint64_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446722;
      v33 = "nw_endpoint_create_with_peer_name";
      __int16 v34 = 1024;
      unint64_t v35 = v31;
      uint64_t v36 = 1024;
      LODWORD(v37[0]) = address[0].sa_len;
      BOOL v9 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u, backtrace limit exceeded";
    }

    uint32_t v21 = (sockaddr *)buf;
    uint64_t v22 = v7;
    __int16 v23 = v8;
    goto LABEL_35;
  }

  BOOL result = nw_endpoint_create_address(address);
  if (result && address[0].sa_family == 1) {
    *((_DWORD *)result + 96) = a1;
  }
  return result;
}

    goto LABEL_32;
  }

  uint64_t v4 = (id *)calloc(1uLL, 0x28uLL);
  if (!v4)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    uint64_t v27 = "strict_calloc";
    int v28 = 2048;
    unint64_t v29 = 1LL;
    unint64_t v30 = 2048;
    v31 = 40LL;
    uint64_t v17 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v17);
    if (result) {
      goto LABEL_35;
    }
    free(v17);
  }

  objc_storeStrong(v4 + 1, *(id *)(a2 + 8));
  uint64_t v5 = *(const char **)(a2 + 16);
  if (v5)
  {
    os_log_type_t v6 = strdup(v5);
    if (!v6)
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      uint64_t v27 = "strict_strdup";
      char v19 = (void *)_os_log_send_and_compose_impl();

      BOOL result = __nwlog_abort((uint64_t)v19);
      if (result) {
        goto LABEL_35;
      }
      free(v19);
    }

    v4[2] = v6;
  }

  uint64_t v7 = *(const char **)(a2 + 24);
  if (!v7)
  {
LABEL_9:
    BOOL v9 = (_BYTE)v4[4] & 0xFE | *(_BYTE *)(a2 + 32) & 1;
    *((_BYTE *)v4 + 32) = v9;
    *((_BYTE *)v4 + 32) = v9 & 0xF9 | *(_BYTE *)(a2 + 32) & 6;
    *uint64_t v4 = *(id *)a2;
LABEL_10:

    return (BOOL)v4;
  }

  uint64_t v8 = strdup(v7);
  if (v8)
  {
LABEL_8:
    v4[3] = v8;
    goto LABEL_9;
  }

  __nwlog_obj();
  uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v27 = "strict_strdup";
  uint32_t v21 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
    goto LABEL_8;
  }
  }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v38 = "nw_protocol_http_messaging_connect";
    v39 = 2048;
    v40 = a2;
    uint32_t v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v35 = 0;
    if (__nwlog_fault(v21, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)gLogObj;
        __int16 v23 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_58;
        }
        *(_DWORD *)buf = 136446466;
        v38 = "nw_protocol_http_messaging_connect";
        v39 = 2048;
        v40 = a2;
        uint64_t v24 = "%{public}s Protocol %p isn't an input handler of http messaging";
LABEL_57:
        _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0x16u);
        goto LABEL_58;
      }

      if (!v35)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)gLogObj;
        __int16 v23 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_58;
        }
        *(_DWORD *)buf = 136446466;
        v38 = "nw_protocol_http_messaging_connect";
        v39 = 2048;
        v40 = a2;
        uint64_t v24 = "%{public}s Protocol %p isn't an input handler of http messaging, backtrace limit exceeded";
        goto LABEL_57;
      }

      int v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)gLogObj;
      __int16 v23 = type;
      unint64_t v29 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v28)
      {
        if (!v29) {
          goto LABEL_58;
        }
        *(_DWORD *)buf = 136446466;
        v38 = "nw_protocol_http_messaging_connect";
        v39 = 2048;
        v40 = a2;
        uint64_t v24 = "%{public}s Protocol %p isn't an input handler of http messaging, no backtrace";
        goto LABEL_57;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446722;
        v38 = "nw_protocol_http_messaging_connect";
        v39 = 2048;
        v40 = a2;
        v41 = 2082;
        v42 = v28;
        _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s Protocol %p isn't an input handler of http messaging, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v28);
    }

  free(v10);
  if (v4) {
LABEL_47:
  }
    free(v4);
}

  free(v9);
  if (v3) {
LABEL_47:
  }
    free(v3);
}

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_32;
  }

  BOOL result = (uint64_t)(a1[3] - a1[2]) >> 3;
  if (result != (uint64_t)(a1[6] - a1[5]) >> 3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_parallel_array_get_count";
    BOOL v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_parallel_array_get_count";
      os_log_type_t v6 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size())";
      goto LABEL_31;
    }

    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_parallel_array_get_count";
      os_log_type_t v6 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size()), backtrace limit exceeded";
      goto LABEL_31;
    }

    BOOL v9 = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    os_log_type_t v10 = os_log_type_enabled(v4, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_parallel_array_get_count";
      os_log_type_t v6 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size()), no backtrace";
      goto LABEL_31;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_parallel_array_get_count";
      os_log_type_t v15 = 2082;
      char v16 = v9;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null (parray->vector1.size() == parray->vector2.size()), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v9);
LABEL_32:
    if (!v3) {
      return 0LL;
    }
LABEL_33:
    free(v3);
    return 0LL;
  }

  return result;
}

      free(v10);
      if (!v4) {
        return 1LL;
      }
      goto LABEL_47;
    }

    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_parallel_array_apply";
    uint64_t v7 = "%{public}s called with null (parray->vector1.size() == parray->vector2.size())";
    goto LABEL_45;
  }

  if (a2) {
    return nw_parallel_array_apply_with_range(a1, 0LL, v2, a2);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_parallel_array_apply";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v4, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_parallel_array_apply";
      uint64_t v7 = "%{public}s called with null applier";
      goto LABEL_45;
    }

    if (!v14)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_parallel_array_apply";
      uint64_t v7 = "%{public}s called with null applier, backtrace limit exceeded";
      goto LABEL_45;
    }

    os_log_type_t v10 = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    uint64_t v13 = os_log_type_enabled(v5, type);
    if (!v10)
    {
      if (!v13) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_parallel_array_apply";
      uint64_t v7 = "%{public}s called with null applier, no backtrace";
      goto LABEL_45;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_parallel_array_apply";
      __int16 v18 = 2082;
      char v19 = v10;
      BOOL v12 = "%{public}s called with null applier, dumping backtrace:%{public}s";
      goto LABEL_30;
    }

    goto LABEL_31;
  }

  if (v10) {
    free(v10);
  }

  uint64_t v7 = 0LL;
LABEL_4:

  return v7;
}

      if (!v8) {
        return;
      }
      goto LABEL_32;
    }

    char v14 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v9 = gconnectionLogObj;
    os_log_type_t v10 = type;
    os_log_type_t v15 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (!v14)
    {
      if (!v15) {
        goto LABEL_31;
      }
      __int16 v25 = *(_DWORD *)(a3 + 176);
      uint64_t v24 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447234;
      v47 = "http2_input_frame_metadata_reset";
      v48 = 2082;
      v49 = (void *)(a3 + 191);
      v50 = 2080;
      v51 = " ";
      v52 = 1024;
      v53 = v24;
      v54 = 1024;
      LODWORD(v55[0]) = v25;
      uint64_t v13 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, no backtrace";
      goto LABEL_29;
    }

    if (v15)
    {
      uint64_t v17 = *(_DWORD *)(a3 + 176);
      char v16 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447490;
      v47 = "http2_input_frame_metadata_reset";
      v48 = 2082;
      v49 = (void *)(a3 + 191);
      v50 = 2080;
      v51 = " ";
      v52 = 1024;
      v53 = v16;
      v54 = 1024;
      LODWORD(v55[0]) = v17;
      WORD2(v55[0]) = 2082;
      *(void *)((char *)v55 + 6) = v14;
      __int16 v18 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, dumping backtrace:%{public}s";
      char v19 = (os_log_s *)v9;
      uint64_t v20 = v10;
      uint32_t v21 = 54;
LABEL_20:
      _os_log_impl(&dword_181A5C000, v19, v20, v18, buf, v21);
      goto LABEL_21;
    }

    goto LABEL_21;
  }

  if (!a2)
  {
    v31 = "";
LABEL_47:
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    if (a2) {
      __int16 v34 = (const char *)(a2 + 390);
    }
    else {
      __int16 v34 = "";
    }
    unint64_t v35 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)buf = 136446978;
    v47 = "http2_input_frame_metadata_reset";
    v48 = 2082;
    v49 = (void *)v34;
    v50 = 2080;
    v51 = v31;
    v52 = 1024;
    v53 = v35;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v36 = gconnectionLogObj;
      v37 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_31;
      }
      v38 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      v47 = "http2_input_frame_metadata_reset";
      v48 = 2082;
      v49 = (void *)v34;
      v50 = 2080;
      v51 = v31;
      v52 = 1024;
      v53 = v38;
      uint64_t v13 = "%{public}s %{public}s%s<i%u> frame has no metadata";
    }

    else
    {
      v39 = v31;
      if (v44)
      {
        char v14 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v36 = gconnectionLogObj;
        v37 = type;
        v40 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v14)
        {
          if (v40)
          {
            v41 = *(_DWORD *)(a2 + 368);
            *(_DWORD *)buf = 136447234;
            v47 = "http2_input_frame_metadata_reset";
            v48 = 2082;
            v49 = (void *)v34;
            v50 = 2080;
            v51 = v39;
            v52 = 1024;
            v53 = v41;
            v54 = 2082;
            v55[0] = v14;
            __int16 v18 = "%{public}s %{public}s%s<i%u> frame has no metadata, dumping backtrace:%{public}s";
            char v19 = (os_log_s *)v36;
            uint64_t v20 = v37;
            uint32_t v21 = 48;
            goto LABEL_20;
          }

    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v37 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v38 = *(_DWORD *)(a1 + 368);
        v39 = *((_DWORD *)v63 + 6);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 390;
        *(_WORD *)&buf[22] = 2080;
        v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v38;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v39;
        _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> consumed %u bytes on connection",  buf,  0x2Cu);
      }
    }

    int v28 = *(char **)(a1 + 152);
    v55[0] = v2;
    v55[1] = 0x40000000LL;
    v55[2] = ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke_48;
    v55[3] = &__block_descriptor_tmp_49_82763;
    v55[4] = a1;
    nw_hash_table_apply(v28, (uint64_t)v55);
    if (gLogDatapath)
    {
      __int16 v34 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }

    *(void *)buf = v2;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_81998;
    v69 = (const char *)&__block_descriptor_tmp_30_81999;
    v70 = v67;
    LOBYTE(v71) = 1;
    unint64_t v29 = v67[0];
    do
    {
      if (!v29) {
        break;
      }
      unint64_t v30 = *(void *)(v29 + 32);
      v31 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      unint64_t v29 = v30;
    }

    while ((v31 & 1) != 0);
    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v32 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v33 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 390;
        *(_WORD *)&buf[22] = 2080;
        v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v33;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v7;
        _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> processed %u frames",  buf,  0x2Cu);
      }
    }

    _Block_object_dispose(type, 8);
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v40 = *(_DWORD *)(a1 + 368);
  *(_DWORD *)buf = 136446978;
  *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = a1 + 390;
  *(_WORD *)&buf[22] = 2080;
  v69 = " ";
  LOWORD(v70) = 1024;
  *(_DWORD *)((char *)&v70 + 2) = v40;
  v41 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v66 = OS_LOG_TYPE_DEFAULT;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v42 = (os_log_s *)gconnectionLogObj;
    v43 = type[0];
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
    {
      v44 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 390;
      *(_WORD *)&buf[22] = 2080;
      v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v44;
      v45 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback";
      goto LABEL_75;
    }

    goto LABEL_76;
  }

  if (v66 == OS_LOG_TYPE_DEFAULT)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v42 = (os_log_s *)gconnectionLogObj;
    v43 = type[0];
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
      goto LABEL_76;
    }
    v49 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 390;
    *(_WORD *)&buf[22] = 2080;
    v69 = " ";
    LOWORD(v70) = 1024;
    *(_DWORD *)((char *)&v70 + 2) = v49;
    v45 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, backtrace limit exceeded";
    goto LABEL_75;
  }

  v46 = (char *)__nw_create_backtrace_string();
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v42 = (os_log_s *)gconnectionLogObj;
  v43 = type[0];
  v47 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
  if (v46)
  {
    if (v47)
    {
      v48 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 390;
      *(_WORD *)&buf[22] = 2080;
      v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v48;
      HIWORD(v70) = 2082;
      v71 = v46;
      _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, dumping backtrace:%{public}s",  buf,  0x30u);
    }

    free(v46);
    goto LABEL_76;
  }

  if (v47)
  {
    v50 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 390;
    *(_WORD *)&buf[22] = 2080;
    v69 = " ";
    LOWORD(v70) = 1024;
    *(_DWORD *)((char *)&v70 + 2) = v50;
    v45 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, no backtrace";
LABEL_75:
    _os_log_impl(&dword_181A5C000, v42, v43, v45, buf, 0x26u);
  }

    free(backtrace_string);
    goto LABEL_45;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
    BOOL v9 = "%{public}s protocol options are not test protocol";
    goto LABEL_44;
  }

  __int16 v23 = *(void *)(a1 + 40);
  uint64_t v24 = *(os_unfair_lock_s **)(v23 + 40);
  if (!v24) {
    return;
  }
  if (!v24[10]._os_unfair_lock_opaque)
  {
    _nw_hash_table_release(v24, v15);
    *(void *)(*(void *)(a1 + 40) + 40LL) = 0LL;
    return;
  }

  if (nw_path_parameters_get_logging_disabled(*(void *)(v23 + 16))) {
    return;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  __int16 v25 = (id)gconnectionLogObj;
  uint64_t v26 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
  *(_DWORD *)buf = 136446466;
  v48 = "nw_association_schedule_deactivation_block_invoke";
  v49 = 2082;
  v50 = v26;
  uint64_t v27 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if ((__nwlog_fault(v27, &type, &v45) & 1) != 0)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v28 = (os_log_s *)(id)gconnectionLogObj;
      unint64_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        unint64_t v30 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
        *(_DWORD *)buf = 136446466;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v30;
        _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty",  buf,  0x16u);
      }
    }

    else if (v45)
    {
      unint64_t v35 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v28 = (os_log_s *)(id)gconnectionLogObj;
      uint64_t v36 = type;
      v37 = os_log_type_enabled(v28, type);
      if (v35)
      {
        if (v37)
        {
          v38 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
          *(_DWORD *)buf = 136446722;
          v48 = "nw_association_schedule_deactivation_block_invoke";
          v49 = 2082;
          v50 = v38;
          v51 = 2082;
          v52 = v35;
          _os_log_impl( &dword_181A5C000,  v28,  v36,  "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v35);
        if (v27) {
          goto LABEL_44;
        }
        return;
      }

      if (v37)
      {
        v44 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
        *(_DWORD *)buf = 136446466;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v44;
        _os_log_impl( &dword_181A5C000,  v28,  v36,  "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty, no backtrace",  buf,  0x16u);
      }
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v28 = (os_log_s *)(id)gconnectionLogObj;
      v41 = type;
      if (os_log_type_enabled(v28, type))
      {
        v42 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
        *(_DWORD *)buf = 136446466;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v42;
        _os_log_impl( &dword_181A5C000,  v28,  v41,  "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty, backtrace limit exceeded",  buf,  0x16u);
      }
    }
  }

  if (v27) {
LABEL_44:
  }
    free(v27);
}

    free(v21);
    if (!v16) {
      goto LABEL_108;
    }
    goto LABEL_107;
  }

  if (!nw_hash_table_get_node(v7, (uint64_t)v5, 0LL) && !nw_path_parameters_get_logging_disabled(*((void *)v3 + 2)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v8 = (id)gconnectionLogObj;
    BOOL v9 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446722;
    v71 = "nw_association_mark_flow_disconnected";
    v72 = 2082;
    v73 = (void *)v9;
    v74 = 2048;
    v75 = v5;
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v10, &type, &v68))
    {
LABEL_61:
      if (!v10) {
        goto LABEL_63;
      }
      goto LABEL_62;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v11 = (os_log_s *)(id)gconnectionLogObj;
      BOOL v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        uint64_t v13 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v13;
        v74 = 2048;
        v75 = v5;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s <nw_association %{public}s> does not have handle %p registered",  buf,  0x20u);
      }

    free(backtrace_string);
    goto LABEL_45;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "nw_protocol_ipv6_updated_path";
    BOOL v9 = "%{public}s called with null path";
    goto LABEL_44;
  }

    free(backtrace_string);
    goto LABEL_45;
  }

  uint64_t v7 = (os_log_s *)__nwlog_obj();
  uint64_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "nw_protocol_ipv4_updated_path";
    BOOL v9 = "%{public}s called with null path";
    goto LABEL_44;
  }

    if (v10) {
      free(v10);
    }
    return 0LL;
  }

  return nw_interface_create_with_index_and_name(a1, (unsigned __int8 *)v30);
}

LABEL_45:
  if (v4) {
    free(v4);
  }
  return 0LL;
}

      v31 = 1LL;
      if (device_model)
      {
LABEL_20:
        __int16 v32 = strlen(device_model) + 1;
        if (contact_id) {
          goto LABEL_21;
        }
        goto LABEL_47;
      }

    if (v17) {
      free(v17);
    }
LABEL_47:
    a1 = 0LL;
    goto LABEL_6;
  }

  objc_storeStrong(v8 + 1, a2);
  *((_OWORD *)a1 + 1) = *a3;
  BOOL v9 = (uint64_t (*)(void *))v7[18];
  if (v9)
  {
    a1[4] = (id)v9(v7);
  }

  else
  {
    BOOL v11 = v7[10];
    if (v11 && *(void *)(v11 + 232))
    {
      a1[4] = a1 + 5;
      (*(void (**)(void *))(v7[10] + 232LL))(v7);
    }
  }

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_46;
  }

  BOOL v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (a2)
    {
      uint64_t v5 = *(void *)(a2 + 56);
      if (v5)
      {
        if (a3)
        {
          *a3 = *(_DWORD *)(v3 + 436);
          a3[1] = a3[1] & 0xFFFFFFF8 | (*(unsigned __int8 *)(v5 + 153) >> 2) & 1;
        }

        return;
      }

      goto LABEL_53;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "__nw_protocol_get_output_handler_context";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 0;
    if (__nwlog_fault(v10, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v11 = (os_log_s *)__nwlog_obj();
        BOOL v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_51;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "__nw_protocol_get_output_handler_context";
        uint64_t v13 = "%{public}s called with null protocol";
        goto LABEL_50;
      }

      if (!v21)
      {
        BOOL v11 = (os_log_s *)__nwlog_obj();
        BOOL v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_51;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "__nw_protocol_get_output_handler_context";
        uint64_t v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_50;
      }

      __int16 v18 = (char *)__nw_create_backtrace_string();
      BOOL v11 = (os_log_s *)__nwlog_obj();
      BOOL v12 = type;
      char v19 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v24 = "__nw_protocol_get_output_handler_context";
          __int16 v25 = 2082;
          *(void *)uint64_t v26 = v18;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v18);
        goto LABEL_51;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "__nw_protocol_get_output_handler_context";
        uint64_t v13 = "%{public}s called with null protocol, no backtrace";
LABEL_50:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      }
    }

    free(v18);
    goto LABEL_46;
  }

  mode = v1->mode;

  if (mode != 1) {
    goto LABEL_27;
  }
  uint64_t v4 = nw_endpoint_handler_copy_resolver(v2);
  uint64_t v5 = *((void *)v4 + 5);
  if (v5
    && *(void *)(v5 + 16) != *(void *)(v5 + 24)
    && (nw_array_get_object_at_index(v5, 0LL), (os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue()) != 0LL))
  {
    uint64_t v7 = v6;
    uint64_t v8 = nw_endpoint_handler_copy_endpoint(v6);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

LABEL_47:
  return v8;
}

        free(v23);
        goto LABEL_46;
      }
    }

    else
    {
      uint64_t v8 = v7;
      if (v9) {
        goto LABEL_4;
      }
    }

    BOOL v9 = v7;
    goto LABEL_4;
  }

  v95 = v10;
  v170 = v8;
  v171 = v9;
  __nwlog_obj();
  v127 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v179 = "nw_endpoint_handler_get_alternate_path_state";
  v128 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v176 = 0;
  if (__nwlog_fault(v128, &type, &v176))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v130 = type;
      if (os_log_type_enabled(v129, type))
      {
        *(_DWORD *)buf = 136446210;
        v179 = "nw_endpoint_handler_get_alternate_path_state";
        _os_log_impl(&dword_181A5C000, v129, v130, "%{public}s called with null endpoint_handler", buf, 0xCu);
      }
    }

    else if (v176)
    {
      v131 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v132 = type;
      v133 = os_log_type_enabled(v129, type);
      if (v131)
      {
        if (v133)
        {
          *(_DWORD *)buf = 136446466;
          v179 = "nw_endpoint_handler_get_alternate_path_state";
          v180 = 2082;
          v181 = v131;
          _os_log_impl( &dword_181A5C000,  v129,  v132,  "%{public}s called with null endpoint_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v131);
        goto LABEL_183;
      }

      if (v133)
      {
        *(_DWORD *)buf = 136446210;
        v179 = "nw_endpoint_handler_get_alternate_path_state";
        _os_log_impl( &dword_181A5C000,  v129,  v132,  "%{public}s called with null endpoint_handler, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v141 = type;
      if (os_log_type_enabled(v129, type))
      {
        *(_DWORD *)buf = 136446210;
        v179 = "nw_endpoint_handler_get_alternate_path_state";
        _os_log_impl( &dword_181A5C000,  v129,  v141,  "%{public}s called with null endpoint_handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        if (v47) {
          goto LABEL_46;
        }
LABEL_47:
        objc_destroyWeak(v121);
        objc_destroyWeak(&location);
LABEL_48:

LABEL_49:
        if (*((_BYTE *)v116 + 24))
        {
          if (*(void *)(v109 + 40))
          {
            v50 = *((void *)v15[7] + 2);
            if (v50)
            {
              if (!nw_path_parameters_get_logging_disabled(*(void *)(v50 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v51 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                {
                  v52 = *((_DWORD *)v15[7] + 112);
                  *(_DWORD *)v119 = 136446466;
                  *(void *)&v119[4] = "nw_read_request_receive";
                  *(_WORD *)&v119[12] = 1024;
                  *(_DWORD *)&v119[14] = v52;
                  _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Retrying write to file descriptor, partial write without eof",  v119,  0x12u);
                }
              }
            }
          }
        }

        v54 = (unint64_t)v15[10];
        v53 = (unint64_t)v15[11];
        uint64_t v24 = v54 >= v53;
        v55 = v54 - v53;
        if (v24) {
          uint64_t v26 = v55;
        }
        else {
          uint64_t v26 = 0LL;
        }
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_51910);
        }

        _Block_object_dispose(&v101, 8);
        uint64_t v27 = v116 + 3;
        if (!*((_BYTE *)v116 + 24))
        {
          _Block_object_dispose(&v115, 8);
          goto LABEL_119;
        }
      }
    }

    v71 = (unint64_t)v15[10];
    v70 = (unint64_t)v15[11];
    uint64_t v24 = v71 >= v70;
    v73 = v71 - v70;
    v72 = v73 != 0 && v24;
    if (!v24) {
      v73 = 0LL;
    }
    if (!v72) {
      goto LABEL_135;
    }
    v74 = size;
    if (v73 >= size) {
      v75 = size;
    }
    else {
      v75 = v73;
    }
    if (v20 == 2)
    {
      v81 = (uint64_t)v15[15] + v70;
      *(void *)v119 = 0LL;
      *(void *)&v119[8] = v119;
      *(void *)&v119[16] = 0x2000000000LL;
      v120 = 0LL;
      v115 = 0LL;
      v116 = &v115;
      v117 = 0x2000000000LL;
      v118 = v81;
      v108 = MEMORY[0x1895F87A8];
      v109 = 0x40000000LL;
      v110 = (uint64_t)__nw_dispatch_data_copyout_block_invoke;
      v111 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BBF598;
      v113 = (dispatch_data_s *)&v115;
      v114 = v75;
      v112 = (void (*)(uint64_t))v119;
      dispatch_data_apply(v10, &v108);
      v75 = *(void *)(*(void *)&v119[8] + 24LL);
      _Block_object_dispose(&v115, 8);
      _Block_object_dispose(v119, 8);
      if (v74 == v75)
      {
        subrange = 0LL;
        v75 = v74;
      }

      else
      {
        subrange = dispatch_data_create_subrange(v10, v75, v74 - v75);
      }

      goto LABEL_129;
    }

    if (v20 != 1)
    {
      v75 = 0LL;
LABEL_130:
      v15[11] = (char *)v15[11] + v75;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_51910);
      }
      if (!_nw_signposts_enabled) {
        goto LABEL_137;
      }
      goto LABEL_135;
    }

    if (size <= v73)
    {
      subrange = 0LL;
      v78 = (dispatch_data_s *)v15[16];
      if (!v78) {
        goto LABEL_112;
      }
    }

    else
    {
      v76 = dispatch_data_create_subrange(v10, 0LL, v75);
      subrange = dispatch_data_create_subrange(v10, v75, v74 - v75);

      os_log_type_t v10 = v76;
      v78 = (dispatch_data_s *)v15[16];
      if (!v78)
      {
LABEL_112:
        concat = v10;
LABEL_127:
        v82 = v15[16];
        v15[16] = concat;

LABEL_129:
        os_log_type_t v10 = subrange;
        goto LABEL_130;
      }
    }

    concat = dispatch_data_create_concat(v78, v10);
    goto LABEL_127;
  }
      }
    }

    else
    {
      __nwlog_obj();
      v67 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v96 = "nw_endpoint_handler_get_sent_application_byte_count";
      uint32_t v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v93 = 0;
      if (__nwlog_fault(v21, &type, &v93))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v68 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_181A5C000, v22, v68, "%{public}s called with null handler", buf, 0xCu);
          }
        }

        else if (v93)
        {
          v78 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v79 = type;
          v80 = os_log_type_enabled(v22, type);
          if (v78)
          {
            if (v80)
            {
              *(_DWORD *)buf = 136446466;
              v96 = "nw_endpoint_handler_get_sent_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v78;
              _os_log_impl( &dword_181A5C000,  v22,  v79,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v78);
            if (!v21) {
              goto LABEL_48;
            }
            goto LABEL_47;
          }

          if (v80)
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_181A5C000, v22, v79, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v90 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl( &dword_181A5C000,  v22,  v90,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_45;
      }
    }

    if (!v21)
    {
LABEL_48:
      __int16 v18 = 0LL;
LABEL_49:

      *(void *)(*a2 + 176) = v18;
      __int16 v32 = v10[18];
      v33 = v32;
      if (v32)
      {
        __int16 v34 = (NWConcrete_nw_endpoint_handler *)v32;
        unint64_t v35 = v34->mode;

        if ((_DWORD)v35 == 2)
        {
          uint64_t v36 = nw_endpoint_handler_copy_flow(v34);
          v37 = *((void *)v36 + 134);

LABEL_87:
          *(void *)(*a2 + 168) = v37;
LABEL_88:

          return;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        else {
          v39 = off_189BBBBC0[v35];
        }
        *(_DWORD *)buf = 136446722;
        v96 = "nw_endpoint_handler_get_received_application_byte_count";
        v97 = 2082;
        v98 = (uint64_t)v39;
        v99 = 2082;
        v100 = (uint64_t)"flow";
        v40 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v93 = 0;
        if (__nwlog_fault(v40, &type, &v93))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v41 = (os_log_s *)(id)gLogObj;
            v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              else {
                v43 = off_189BBBBC0[v35];
              }
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v43;
              v99 = 2082;
              v100 = (uint64_t)"flow";
              _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
            }
          }

          else if (v93)
          {
            v44 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v41 = (os_log_s *)(id)gLogObj;
            v45 = type;
            v46 = os_log_type_enabled(v41, type);
            if (v44)
            {
              if (v46)
              {
                else {
                  v47 = off_189BBBBC0[v35];
                }
                *(_DWORD *)buf = 136446978;
                v96 = "nw_endpoint_handler_get_received_application_byte_count";
                v97 = 2082;
                v98 = (uint64_t)v47;
                v99 = 2082;
                v100 = (uint64_t)"flow";
                v101 = 2082;
                v102 = v44;
                _os_log_impl( &dword_181A5C000,  v41,  v45,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(v44);
              if (!v40) {
                goto LABEL_86;
              }
              goto LABEL_85;
            }

            if (v46)
            {
              else {
                v50 = off_189BBBBC0[v35];
              }
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v50;
              v99 = 2082;
              v100 = (uint64_t)"flow";
              _os_log_impl( &dword_181A5C000,  v41,  v45,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v41 = (os_log_s *)(id)gLogObj;
            v48 = type;
            if (os_log_type_enabled(v41, type))
            {
              else {
                v49 = off_189BBBBC0[v35];
              }
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v49;
              v99 = 2082;
              v100 = (uint64_t)"flow";
              _os_log_impl( &dword_181A5C000,  v41,  v48,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
            }
          }

    __break(1u);
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }

          __int16 v18 = 0LL;
          BOOL v9 = 1LL;
          goto LABEL_58;
        }

        __break(1u);
LABEL_75:
        __break(1u);
        return result;
      }

      __int16 v18 = (v9 - 48);
      if (v14 != 1)
      {
        __int16 v18 = 10LL * (v9 - 48) + (BYTE1(v9) - 48);
        __int16 v25 = v14 - 2;
        if (v25)
        {
          uint64_t v26 = (unsigned __int8 *)&v39 + 2;
          while (1)
          {
            uint64_t v27 = *v26 - 48;
            if (v27 > 9) {
              goto LABEL_45;
            }
            int v28 = 10 * v18;
            __int16 v18 = v28 + v27;
            BOOL v9 = 0LL;
            ++v26;
            if (!--v25) {
              goto LABEL_58;
            }
          }
        }
      }
    }

      sub_181C32588(v17, 0LL, 0LL, 2);
      return 1LL;
    }

    if (v9 == 2 && v7 == 1 && !(v8 | v6))
    {
      uint64_t v13 = 1LL;
      sub_181C32588(1LL, 0LL, 0LL, 2);
      sub_181C32588(1LL, 0LL, 0LL, 2);
      return v13;
    }

  __int16 v25 = a2->handle;
  BOOL v12 = v25 != &nw_protocol_ref_counted_handle;
  if (v25 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v26 = a2[1].callbacks;
    if (v26) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v26->add_input_handler + 1);
    }
  }

    goto LABEL_46;
  }

  if (v4)
  {
    if ((v3[17] & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      v28[0] = MEMORY[0x1895F87A8];
      v28[1] = 3221225472LL;
      v28[2] = __nw_context_add_proxy_block_invoke;
      v28[3] = &unk_189BC9238;
      unint64_t v29 = v3;
      unint64_t v30 = v5;
      nw_queue_context_async(v29, v28);
    }

    else
    {
      os_log_type_t v6 = v3[7];
      if (!v6)
      {
        uint64_t v7 = nw_array_create();
        uint64_t v8 = (void *)v3[7];
        v3[7] = v7;

        os_log_type_t v6 = v3[7];
      }

      nw_array_append(v6, v5);
      BOOL v9 = v3[5];
      if (v9)
      {
        os_log_type_t v10 = *(void *)(v9 + 56);
        if (!v10)
        {
          BOOL v11 = nw_array_create();
          BOOL v12 = v3[5];
          uint64_t v13 = *(void **)(v12 + 56);
          *(void *)(v12 + 56) = v11;

          os_log_type_t v10 = *(void *)(v3[5] + 56);
        }

        nw_array_append(v10, v5);
      }
    }

    goto LABEL_12;
  }

  __nwlog_obj();
  __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v34 = "nw_context_add_proxy";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  __int16 v32 = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (v32 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v19 = v32;
    if (os_log_type_enabled(v16, v32))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "nw_context_add_proxy";
      _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null proxy_config", buf, 0xCu);
    }

    goto LABEL_45;
  }

  if (!v31)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v27 = v32;
    if (os_log_type_enabled(v16, v32))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "nw_context_add_proxy";
      _os_log_impl( &dword_181A5C000,  v16,  v27,  "%{public}s called with null proxy_config, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_45;
  }

  __int16 v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v24 = v32;
  __int16 v25 = os_log_type_enabled(v16, v32);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "nw_context_add_proxy";
      _os_log_impl(&dword_181A5C000, v16, v24, "%{public}s called with null proxy_config, no backtrace", buf, 0xCu);
    }

    goto LABEL_45;
  }

  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v34 = "nw_context_add_proxy";
    unint64_t v35 = 2082;
    uint64_t v36 = v23;
    _os_log_impl( &dword_181A5C000,  v16,  v24,  "%{public}s called with null proxy_config, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v23);
  if (v15) {
    goto LABEL_47;
  }
LABEL_12:
}

  if (v29) {
    free(v29);
  }
LABEL_28:
}

    if (v29) {
      free(v29);
    }
    goto LABEL_15;
  }

  if (!v3[21])
  {
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    }
    uint64_t v5 = (os_log_s *)(id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = (char *)v4[1];
      *(_DWORD *)buf = 136446466;
      v66 = "nw_candidate_manager_start_advertise";
      v67 = 2048;
      v68 = v7;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s [CM%zu] Cannot advertise without a new connection handler",  buf,  0x16u);
    }

    goto LABEL_14;
  }

  if (v3[6] || v3[9])
  {
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    }
    uint64_t v5 = (os_log_s *)(id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v6 = (char *)v4[1];
      *(_DWORD *)buf = 136446466;
      v66 = "nw_candidate_manager_start_advertise";
      v67 = 2048;
      v68 = v6;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s [CM%zu] Cannot start an already started candidate_manager",  buf,  0x16u);
    }

    if (v22) {
      free(v22);
    }
    goto LABEL_8;
  }

    free(backtrace_string);
    goto LABEL_58;
  }

  BOOL v9 = v8;
  is_equal = nw_endpoint_is_equal(*(void **)(a1 + 48), v6, 31LL);
  if ((v9 & is_equal) == 1)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL), a3);
    BOOL v11 = 0LL;
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      BOOL v12 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v13 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        *(_DWORD *)buf = 136446722;
        unint64_t v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
        uint64_t v36 = 1024;
        *(_DWORD *)v37 = v13;
        *(_WORD *)&v37[4] = 2112;
        *(void *)&v37[6] = v5;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Connection %@ is compatible",  buf,  0x1Cu);
      }

LABEL_60:
      BOOL v11 = 0LL;
    }
  }

  else
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      char v14 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v15 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        *(_DWORD *)buf = 136447234;
        unint64_t v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
        uint64_t v36 = 1024;
        *(_DWORD *)v37 = v15;
        *(_WORD *)&v37[4] = 2112;
        *(void *)&v37[6] = v5;
        v38 = 1024;
        v39 = v9;
        v40 = 1024;
        v41 = is_equal;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Connection %@ is not compatible (parameters: %u, remote_endpoints: %u)",  buf,  0x28u);
      }
    }

    BOOL v11 = 1LL;
  }

  return v11;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v13) {
    free(v13);
  }
  return 0LL;
}

  if (v13) {
    free(v13);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v8) {
    free(v8);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v6) {
    free(v6);
  }
}

  if (v8) {
    free(v8);
  }
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
}

      free(v29);
      if (v19)
      {
LABEL_68:
        free(v19);
        return 0LL;
      }

      return 0LL;
    }

    uint64_t v20 = (os_log_s *)__nwlog_obj();
    uint32_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_67;
    }
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_new_objc";
    uint64_t v22 = "%{public}s called with null parameters";
LABEL_66:
    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_67;
  }

  {
    nw_protocol_new_objc::_objc_initiateDealloc = (uint64_t)sel_registerName("_objc_initiateDealloc");
  }

  if (!class_getInstanceMethod(cls, (SEL)nw_protocol_new_objc::_objc_initiateDealloc))
  {
    _class_setCustomDeallocInitiation();
    class_addMethod( cls,  (SEL)nw_protocol_new_objc::_objc_initiateDealloc,  (IMP)nw_protocol_new_objc::$_0::__invoke,  0LL);
  }

  InstanceSize = class_getInstanceSize(cls);
  os_log_type_t v10 = (void *)nw_protocol_new(InstanceSize, a2, a3, a4);
  if (!v10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_new_objc";
    char v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_new_objc";
      uint64_t v22 = "%{public}s called with null space";
      goto LABEL_66;
    }

    if (!v35)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint32_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_new_objc";
      uint64_t v22 = "%{public}s called with null space, backtrace limit exceeded";
      goto LABEL_66;
    }

    unint64_t v29 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    uint32_t v21 = type;
    __int16 v32 = os_log_type_enabled(v20, type);
    if (!v29)
    {
      if (!v32) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_new_objc";
      uint64_t v22 = "%{public}s called with null space, no backtrace";
      goto LABEL_66;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_protocol_new_objc";
      v39 = 2082;
      v40 = v29;
      v31 = "%{public}s called with null space, dumping backtrace:%{public}s";
      goto LABEL_44;
    }

    goto LABEL_45;
  }

  BOOL v11 = (uint64_t)v10;
  BOOL v12 = objc_constructInstance(cls, v10);
  if (!v12)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_new_objc";
    __int16 v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v35 = 0;
    if (__nwlog_fault(v23, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        __int16 v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_new_objc";
          uint64_t v26 = "%{public}s called with null obj";
LABEL_71:
          _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
        }
      }

      else if (v35)
      {
        v33 = (char *)__nw_create_backtrace_string();
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        __int16 v25 = type;
        __int16 v34 = os_log_type_enabled(v24, type);
        if (v33)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v38 = "nw_protocol_new_objc";
            v39 = 2082;
            v40 = v33;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null obj, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v33);
          goto LABEL_72;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_new_objc";
          uint64_t v26 = "%{public}s called with null obj, no backtrace";
          goto LABEL_71;
        }
      }

      else
      {
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        __int16 v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_new_objc";
          uint64_t v26 = "%{public}s called with null obj, backtrace limit exceeded";
          goto LABEL_71;
        }
      }
    }

  return v17;
}

LABEL_46:
      if (v10) {
        free(v10);
      }
      goto LABEL_12;
    }

    if (!v22)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint32_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_group_descriptor_copy_member";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called on group descriptor that supports multiple endpoints, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v18 = type;
    char v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_group_descriptor_copy_member";
        _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called on group descriptor that supports multiple endpoints, no backtrace",  buf,  0xCu);
      }

      goto LABEL_45;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v25 = "nw_group_descriptor_copy_member";
      uint64_t v26 = 2082;
      uint64_t v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called on group descriptor that supports multiple endpoints, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (v21) {
      free(v21);
    }
    goto LABEL_25;
  }

  BOOL v3 = v1;
  uint64_t v4 = v3;
  tqh_last = v3->pending_outbound_frames.tqh_last;
  if (tqh_last)
  {
    os_log_type_t v6 = *((_DWORD *)tqh_last + 10);

    if (v6)
    {
LABEL_8:
      BYTE4(v4->flow_in_connected) |= 8u;
      if ((SBYTE5(v4->flow_in_connected) & 0x80000000) == 0 && gLogDatapath)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_destroy";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = (char *)&v4->flow_in_connected + 7;
          *(_WORD *)&buf[22] = 2080;
          unint64_t v35 = " ";
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDeferring destroying protocol",  buf,  0x20u);
        }
      }

      goto LABEL_46;
    }

    __nwlog_obj();
    v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v77 = "__nw_protocol_notify";
    v47 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(p_paths_log_id_num) = 0;
    if (__nwlog_fault(v47, type, &p_paths_log_id_num))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v77 = "__nw_protocol_notify";
          _os_log_impl(&dword_181A5C000, v48, v49, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if ((_BYTE)p_paths_log_id_num)
      {
        v57 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v58 = type[0];
        v59 = os_log_type_enabled(v48, type[0]);
        if (v57)
        {
          if (v59)
          {
            *(_DWORD *)buf = 136446466;
            v77 = "__nw_protocol_notify";
            v78 = 2082;
            v79 = v57;
            _os_log_impl( &dword_181A5C000,  v48,  v58,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v57);
          goto LABEL_137;
        }

        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          v77 = "__nw_protocol_notify";
          _os_log_impl(&dword_181A5C000, v48, v58, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v64 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v77 = "__nw_protocol_notify";
          _os_log_impl( &dword_181A5C000,  v48,  v64,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        goto LABEL_46;
      }

      if (!v25)
      {
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          int v28 = "nw_protocol_instance_copy_options";
          _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null (flow == (_nw_protocol_default_flow)), backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint32_t v21 = type;
      uint64_t v22 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          int v28 = "nw_protocol_instance_copy_options";
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null (flow == (_nw_protocol_default_flow)), no backtrace",  buf,  0xCu);
        }

        goto LABEL_45;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        int v28 = "nw_protocol_instance_copy_options";
        unint64_t v29 = 2082;
        unint64_t v30 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null (flow == (_nw_protocol_default_flow)), dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_33;
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v28 = "nw_protocol_instance_copy_options";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v25 = 0;
    if (__nwlog_fault(v13, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          int v28 = "nw_protocol_instance_copy_options";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (!v25)
      {
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v23 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          int v28 = "nw_protocol_instance_copy_options";
          _os_log_impl( &dword_181A5C000,  v14,  v23,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_45;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v19 = type;
      uint64_t v20 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          int v28 = "nw_protocol_instance_copy_options";
          _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_45;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        int v28 = "nw_protocol_instance_copy_options";
        unint64_t v29 = 2082;
        unint64_t v30 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    free(backtrace_string);
    goto LABEL_52;
  }

  *(_DWORD *)(internal + 48) &= ~2u;
  v6[30] = (void *)internal;
LABEL_9:
  BOOL v9 = calloc(1uLL, v7 + 4);
  if (v9)
  {
LABEL_10:
    *BOOL v9 = v7;
    memcpy(v9 + 1, a2, v7);
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_type_t v10 = nw_hash_table_add_object((uint64_t)v6[30], (uint64_t)v9, (char *)&type);
    if (type) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    BOOL v12 = !v11;
    if (!v11)
    {
      *(void *)(v10 + 32) = a3;
      uint64_t v13 = 1LL;
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136447234;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)v6 + 407;
      v52 = 2080;
      v53 = " ";
      v54 = 2048;
      v55 = a2;
      v56 = 2048;
      v57 = a3;
      os_log_type_t v15 = "%{public}s %{public}s%sAdded key %p to custom flow mapping table for flow id: %llx";
      char v16 = v14;
      uint64_t v17 = OS_LOG_TYPE_DEBUG;
      __int16 v18 = 52;
      goto LABEL_34;
    }

    if ((*((char *)v6 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
LABEL_35:

        uint64_t v13 = v12;
        goto LABEL_30;
      }

      *(_DWORD *)buf = 136446978;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)v6 + 407;
      v52 = 2080;
      v53 = " ";
      v54 = 2048;
      v55 = a2;
      os_log_type_t v15 = "%{public}s %{public}s%sFailed to add key %p to custom flow mapping table";
      char v16 = v14;
      uint64_t v17 = OS_LOG_TYPE_ERROR;
      __int16 v18 = 42;
LABEL_34:
      _os_log_impl(&dword_181A5C000, v16, v17, v15, buf, v18);
      goto LABEL_35;
    }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v36 = gLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          *(_DWORD *)buf = 136446210;
          v59 = "nw_http_authentication_apply_authorization";
          unint64_t v29 = "%{public}s Unable to find authorization";
          unint64_t v30 = (os_log_s *)v36;
          v31 = 12;
          goto LABEL_47;
        }

        return result;
      }

      if (nw_http_authentication_apply_credentials(*(__CFHTTPMessage **)(v9 + 912), a2, a3))
      {
        if (a4 == 5)
        {
          NegotiateHeaderForRequest = (const __CFString *)_CFHTTPAuthenticationCreateNTLMHeaderForRequest();
          if (NegotiateHeaderForRequest) {
            goto LABEL_14;
          }
          goto LABEL_45;
        }

        __int16 v32 = (__CFHTTPMessage **)(v9 + 912);
        if (!a6)
        {
          __int16 v34 = *v32;
          unint64_t v35 = @"Authorization";
LABEL_44:
          NegotiateHeaderForRequest = CFHTTPMessageCopyHeaderFieldValue(v34, v35);
          if (NegotiateHeaderForRequest) {
            goto LABEL_14;
          }
          goto LABEL_45;
        }

LABEL_19:
    if (!v10)
    {
LABEL_21:
      uint64_t v8 = 0LL;
      goto LABEL_22;
    }

      os_log_type_t v10 = v360;
      goto LABEL_46;
    }

    if (a3 == 20) {
      goto LABEL_45;
    }
    v358 = v11;
    v359 = v13;
    v356 = (unsigned int *)v14;
    if (nw_endpoint_handler_get_minimize_logging(v14))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v34 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v14);
        v347 = nw_endpoint_handler_dry_run_string(v14);
        v312 = nw_endpoint_handler_copy_endpoint(v14);
        v344 = nw_endpoint_get_logging_description(v312);
        loga = nw_endpoint_handler_state_string(v14);
        v313 = nw_endpoint_handler_mode_string(v14);
        v314 = nw_endpoint_handler_copy_current_path(v14);
        v315 = v314;
        if (a3 > 0x1A) {
          v316 = "unknown";
        }
        else {
          v316 = off_189BBE330[a3];
        }
        *(_DWORD *)buf = 136448002;
        v373 = "nw_flow_notify";
        v374 = 2082;
        v375 = (void *)id_string;
        v376 = 2082;
        v377 = v347;
        v378 = 2082;
        v379 = v344;
        v380 = 2082;
        v381 = loga;
        v382 = 2082;
        v383 = v313;
        v384 = 2114;
        v385 = v314;
        v386 = 2082;
        v387 = v316;
        _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received notification %{public}s",  buf,  0x52u);
      }
    }

    else
    {
      __int16 v32 = v14;
      v33 = *((_BYTE *)v32 + 268);

      if ((v33 & 0x20) != 0)
      {
LABEL_57:
        switch(a3)
        {
          case 0u:
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v62 = (id)gconnectionLogObj;
            v63 = nw_endpoint_handler_get_id_string(v14);
            v64 = nw_endpoint_handler_dry_run_string(v14);
            v65 = nw_endpoint_handler_copy_endpoint(v14);
            v66 = nw_endpoint_get_logging_description(v65);
            v67 = nw_endpoint_handler_state_string(v14);
            v68 = nw_endpoint_handler_mode_string(v14);
            v69 = nw_endpoint_handler_copy_current_path(v14);
            *(_DWORD *)buf = 136448002;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v63;
            v376 = 2082;
            v377 = v64;
            v378 = 2082;
            v379 = v66;
            v380 = 2082;
            v381 = v67;
            v382 = 2082;
            v383 = v68;
            v384 = 2114;
            v385 = v69;
            v386 = 2082;
            v387 = "undefined";
            v70 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v71 = (char *)v70;
            if ((__nwlog_fault(v70, &type, &v364) & 1) == 0) {
              goto LABEL_252;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v72 = (os_log_s *)(id)gconnectionLogObj;
              v73 = type;
              if (os_log_type_enabled(v72, type))
              {
                v74 = nw_endpoint_handler_get_id_string(v356);
                v75 = nw_endpoint_handler_dry_run_string(v356);
                v76 = nw_endpoint_handler_copy_endpoint(v356);
                v77 = nw_endpoint_get_logging_description(v76);
                v78 = nw_endpoint_handler_state_string(v356);
                v79 = nw_endpoint_handler_mode_string(v356);
                v80 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v74;
                v376 = 2082;
                v377 = v75;
                v378 = 2082;
                v379 = v77;
                v380 = 2082;
                v381 = v78;
                v382 = 2082;
                v383 = v79;
                v384 = 2114;
                v385 = v80;
                v386 = 2082;
                v387 = "undefined";
                _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s notification",  buf,  0x52u);
              }

              goto LABEL_250;
            }

            if (v364)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v179 = (char *)backtrace_string;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v180 = (os_log_s *)(id)gconnectionLogObj;
                v181 = type;
                if (os_log_type_enabled(v180, type))
                {
                  v182 = nw_endpoint_handler_get_id_string(v356);
                  v183 = nw_endpoint_handler_dry_run_string(v356);
                  v352 = nw_endpoint_handler_copy_endpoint(v356);
                  v184 = nw_endpoint_get_logging_description(v352);
                  v185 = nw_endpoint_handler_state_string(v356);
                  v186 = nw_endpoint_handler_mode_string(v356);
                  v187 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448258;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v182;
                  v376 = 2082;
                  v377 = v183;
                  v378 = 2082;
                  v379 = v184;
                  v380 = 2082;
                  v381 = v185;
                  v382 = 2082;
                  v383 = v186;
                  v384 = 2114;
                  v385 = v187;
                  v386 = 2082;
                  v387 = "undefined";
                  v388 = 2082;
                  v389 = v179;
                  _os_log_impl( &dword_181A5C000,  v180,  v181,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s no tification, dumping backtrace:%{public}s",  buf,  0x5Cu);
                }

                goto LABEL_175;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v72 = (os_log_s *)(id)gconnectionLogObj;
              v256 = type;
              if (os_log_type_enabled(v72, type))
              {
                v257 = nw_endpoint_handler_get_id_string(v356);
                v258 = nw_endpoint_handler_dry_run_string(v356);
                v259 = nw_endpoint_handler_copy_endpoint(v356);
                v260 = nw_endpoint_get_logging_description(v259);
                v261 = nw_endpoint_handler_state_string(v356);
                v262 = nw_endpoint_handler_mode_string(v356);
                v263 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v257;
                v376 = 2082;
                v377 = v258;
                v378 = 2082;
                v379 = v260;
                v380 = 2082;
                v381 = v261;
                v382 = 2082;
                v383 = v262;
                v384 = 2114;
                v385 = v263;
                v386 = 2082;
                v387 = "undefined";
                _os_log_impl( &dword_181A5C000,  v72,  v256,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s noti fication, no backtrace",  buf,  0x52u);
              }
            }

            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v72 = (os_log_s *)(id)gconnectionLogObj;
              v218 = type;
              if (os_log_type_enabled(v72, type))
              {
                v219 = nw_endpoint_handler_get_id_string(v356);
                v220 = nw_endpoint_handler_dry_run_string(v356);
                v221 = nw_endpoint_handler_copy_endpoint(v356);
                v222 = nw_endpoint_get_logging_description(v221);
                v223 = nw_endpoint_handler_state_string(v356);
                v224 = nw_endpoint_handler_mode_string(v356);
                v225 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v219;
                v376 = 2082;
                v377 = v220;
                v378 = 2082;
                v379 = v222;
                v380 = 2082;
                v381 = v223;
                v382 = 2082;
                v383 = v224;
                v384 = 2114;
                v385 = v225;
                v386 = 2082;
                v387 = "undefined";
                _os_log_impl( &dword_181A5C000,  v72,  v218,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s noti fication, backtrace limit exceeded",  buf,  0x52u);
              }
            }

            goto LABEL_250;
          case 1u:
            v94 = nw_endpoint_handler_copy_endpoint(v14);
            v95 = nw_endpoint_handler_copy_parameters(v14);
            v96 = nw_endpoint_flow_copy_path(v14);
            nw_connection_report_symptom_internal_on_nw_queue(421892, v94, v95, v96, 0LL, 0LL, 0LL, 0, 0, 0);

            uint64_t v13 = v359;
            if (!*((void *)v359 + 105)) {
              goto LABEL_45;
            }
            v97 = (const void *)*((void *)v359 + 127);
            if (!v97) {
              goto LABEL_45;
            }
            v98 = _Block_copy(v97);
            v99 = (dispatch_queue_s *)*((void *)v359 + 105);
            v370[0] = MEMORY[0x1895F87A8];
            v370[1] = 3221225472LL;
            v370[2] = ___ZL14nw_flow_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke;
            v370[3] = &unk_189BC8740;
            v371 = v98;
            v100 = v98;
            dispatch_async(v99, v370);

            goto LABEL_44;
          case 2u:
            v87 = nw_endpoint_handler_copy_endpoint(v14);
            v88 = nw_endpoint_handler_copy_parameters(v14);
            v89 = nw_endpoint_flow_copy_path(v14);
            nw_connection_report_symptom_internal_on_nw_queue(421891, v87, v88, v89, 0LL, 0LL, 0LL, 0, 0, 0);

            uint64_t v13 = v359;
            if (!*((void *)v359 + 105)) {
              goto LABEL_45;
            }
            v90 = (const void *)*((void *)v359 + 128);
            if (!v90) {
              goto LABEL_45;
            }
            v91 = _Block_copy(v90);
            v92 = (dispatch_queue_s *)*((void *)v359 + 105);
            block[0] = MEMORY[0x1895F87A8];
            block[1] = 3221225472LL;
            block[2] = ___ZL14nw_flow_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke_2;
            block[3] = &unk_189BC8740;
            v369 = v91;
            v93 = v91;
            dispatch_async(v92, block);

            goto LABEL_44;
          case 3u:
            if (*((void *)v13 + 129))
            {
              if (*((void *)v13 + 123))
              {
                ++*((_DWORD *)v13 + 248);
                if (*((_DWORD *)v13 + 249)) {

                }
                  int64 = networkd_settings_get_int64((const char *)nw_setting_tcpconn_keepalive_cnt);
                else {
                  int64 = 0;
                }
                v226 = v14;
                if (*((_DWORD *)v13 + 250)
                  && networkd_settings_get_int64((const char *)nw_setting_tcpconn_keepalive_time))
                {
                  v227 = 60000000000LL;
                }

                else
                {
                  v227 = 0LL;
                }

                if (!int64 || *((_DWORD *)v13 + 248) >= 0xAu)
                {
                  v228 = *((void *)v13 + 123);
                  v229 = mach_continuous_time();
                  if (v229 <= 1) {
                    v230 = 1LL;
                  }
                  else {
                    v230 = v229;
                  }
                  v231 = nw_delta_nanos(v228, v230) / (unint64_t)*((unsigned int *)v13 + 248) > v227;
                  v232 = v226;
                  if (!v231)
                  {
                    if ((nw_endpoint_handler_get_logging_disabled(v226) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v233 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v233, OS_LOG_TYPE_DEBUG))
                      {
                        v234 = nw_endpoint_handler_get_id_string(v226);
                        v235 = nw_endpoint_handler_dry_run_string(v226);
                        v236 = nw_endpoint_handler_copy_endpoint(v226);
                        v237 = nw_endpoint_get_logging_description(v236);
                        v238 = nw_endpoint_handler_state_string(v226);
                        v239 = nw_endpoint_handler_mode_string(v226);
                        v240 = nw_endpoint_handler_copy_current_path(v226);
                        v241 = *((_DWORD *)v359 + 248);
                        *(_DWORD *)buf = 136448002;
                        v373 = "nw_flow_notify";
                        v374 = 2082;
                        v375 = (void *)v234;
                        v376 = 2082;
                        v377 = v235;
                        v378 = 2082;
                        v379 = v237;
                        v380 = 2082;
                        v381 = v238;
                        v382 = 2082;
                        v383 = v239;
                        v384 = 2114;
                        v385 = v240;
                        v386 = 1024;
                        LODWORD(v387) = v241;
                        _os_log_impl( &dword_181A5C000,  v233,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Keepalive not ify (count = %u)",  buf,  0x4Eu);
                      }

                      uint64_t v13 = v359;
                      v232 = v226;
                    }

                    if (*((void *)v13 + 105))
                    {
                      v242 = (const void *)*((void *)v13 + 129);
                      if (v242)
                      {
                        v243 = _Block_copy(v242);
                        v244 = (dispatch_queue_s *)*((void *)v13 + 105);
                        v366[0] = MEMORY[0x1895F87A8];
                        v366[1] = 3221225472LL;
                        v366[2] = ___ZL14nw_flow_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke_90;
                        v366[3] = &unk_189BC8740;
                        v367 = v243;
                        v245 = v243;
                        dispatch_async(v244, v366);

                        v232 = v226;
                      }
                    }
                  }

                  if ((nw_endpoint_handler_get_logging_disabled(v232) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v246 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v246, OS_LOG_TYPE_DEBUG))
                    {
                      v247 = nw_endpoint_handler_get_id_string(v232);
                      v248 = nw_endpoint_handler_dry_run_string(v232);
                      v249 = nw_endpoint_handler_copy_endpoint(v232);
                      v250 = nw_endpoint_get_logging_description(v249);
                      v251 = v232;
                      v252 = nw_endpoint_handler_state_string(v232);
                      v253 = nw_endpoint_handler_mode_string(v251);
                      v254 = nw_endpoint_handler_copy_current_path(v251);
                      v255 = *((_DWORD *)v359 + 248);
                      *(_DWORD *)buf = 136448002;
                      v373 = "nw_flow_notify";
                      v374 = 2082;
                      v375 = (void *)v247;
                      v376 = 2082;
                      v377 = v248;
                      v378 = 2082;
                      v379 = v250;
                      v380 = 2082;
                      v381 = v252;
                      v382 = 2082;
                      v383 = v253;
                      v384 = 2114;
                      v385 = v254;
                      v386 = 1024;
                      LODWORD(v387) = v255;
                      _os_log_impl( &dword_181A5C000,  v246,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Clear keepalive state (count = %u)",  buf,  0x4Eu);
                    }

                    uint64_t v13 = v359;
                  }

                  *((void *)v13 + 123) = 0LL;
                  *((_DWORD *)v13 + 248) = 0;
                }
              }

              else
              {
                *((_DWORD *)v13 + 248) = 1;
                v216 = mach_continuous_time();
                if (v216 <= 1) {
                  v217 = 1LL;
                }
                else {
                  v217 = v216;
                }
                *((void *)v13 + 123) = v217;
              }
            }

            goto LABEL_45;
          case 5u:
            if (!*((void *)v13 + 105) || !*((void *)v13 + 130)) {
              goto LABEL_45;
            }
            v81 = nw_protocol_definition_create_with_identifier(*(__int128 **)(a2 + 16));
            if (v81)
            {
              v82 = nw_endpoint_flow_copy_protocol_metadata(v14, v13, v81, 1, 0);
              if (v82) {
                (*(void (**)(void))(*((void *)v13 + 130) + 16LL))();
              }
              v83 = v13;

              goto LABEL_75;
            }

            v83 = v13;
            __nwlog_obj();
            v332 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v373 = "nw_flow_notify";
            v333 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v334 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v335 = type;
              if (os_log_type_enabled(v334, type))
              {
                *(_DWORD *)buf = 136446210;
                v373 = "nw_flow_notify";
                _os_log_impl(&dword_181A5C000, v334, v335, "%{public}s called with null definition", buf, 0xCu);
              }
            }

            else if (v364)
            {
              v336 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v334 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v337 = type;
              v338 = os_log_type_enabled(v334, type);
              if (v336)
              {
                if (v338)
                {
                  *(_DWORD *)buf = 136446466;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = v336;
                  _os_log_impl( &dword_181A5C000,  v334,  v337,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v336);
LABEL_288:
                if (v333) {
                  free(v333);
                }
LABEL_75:

                uint64_t v13 = v83;
                goto LABEL_45;
              }

              if (v338)
              {
                *(_DWORD *)buf = 136446210;
                v373 = "nw_flow_notify";
                _os_log_impl( &dword_181A5C000,  v334,  v337,  "%{public}s called with null definition, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v334 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v339 = type;
              if (os_log_type_enabled(v334, type))
              {
                *(_DWORD *)buf = 136446210;
                v373 = "nw_flow_notify";
                _os_log_impl( &dword_181A5C000,  v334,  v339,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
              }
            }

            goto LABEL_288;
          case 0xCu:
            v84 = *((char *)v13 + 34);
            if (v84 < 0) {
              goto LABEL_45;
            }
            *((_BYTE *)v13 + 34) = v84 | 0x80;
            v85 = 8;
            goto LABEL_98;
          case 0x13u:
            nw_endpoint_flow_rebuild_stack(v14, (nw_protocol *)a2);
            goto LABEL_45;
          case 0x16u:
            if (*((_DWORD *)v13 + 251) <= 0x13u)
            {
              minimize_logging = nw_endpoint_handler_get_minimize_logging(v14);
              logging_disabled = nw_endpoint_handler_get_logging_disabled(v14);
              if (minimize_logging)
              {
                if ((logging_disabled & 1) != 0)
                {
LABEL_97:
                  ++*((_DWORD *)v13 + 251);
                  nw_endpoint_flow_rebuild_stack(v14, (nw_protocol *)a1);
                  v85 = 4;
LABEL_98:
                  v14->event.domain = 3;
                  v14->event.event = v85;
                  nw_endpoint_handler_report(v14, 0LL, &v14->event.domain, 0LL);
                  goto LABEL_45;
                }

                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v103 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
                {
                  v317 = nw_endpoint_handler_get_id_string(v356);
                  v318 = nw_endpoint_handler_dry_run_string(v356);
                  v319 = nw_endpoint_handler_copy_endpoint(v356);
                  v320 = nw_endpoint_get_logging_description(v319);
                  v321 = nw_endpoint_handler_state_string(v356);
                  v322 = nw_endpoint_handler_mode_string(v356);
                  v323 = nw_endpoint_handler_copy_current_path(v356);
                  v324 = *((_DWORD *)v359 + 251);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v317;
                  v376 = 2082;
                  v377 = v318;
                  v378 = 2082;
                  v379 = v320;
                  v380 = 2082;
                  v381 = v321;
                  v382 = 2082;
                  v383 = v322;
                  v384 = 2114;
                  v385 = v323;
                  v386 = 1024;
                  LODWORD(v387) = v324;
                  _os_log_impl( &dword_181A5C000,  v103,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart wi th count %u, rebuilding stack",  buf,  0x4Eu);
                }
              }

              else
              {
                if ((logging_disabled & 1) != 0) {
                  goto LABEL_97;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v103 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v103, OS_LOG_TYPE_INFO))
                {
                  v104 = nw_endpoint_handler_get_id_string(v14);
                  v105 = nw_endpoint_handler_dry_run_string(v14);
                  v106 = nw_endpoint_handler_copy_endpoint(v14);
                  v107 = nw_endpoint_get_logging_description(v106);
                  v108 = v14;
                  v109 = nw_endpoint_handler_state_string(v14);
                  v110 = nw_endpoint_handler_mode_string(v108);
                  v111 = nw_endpoint_handler_copy_current_path(v108);
                  v112 = *((_DWORD *)v359 + 251);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v104;
                  v376 = 2082;
                  v377 = v105;
                  v378 = 2082;
                  v379 = v107;
                  v380 = 2082;
                  v381 = v109;
                  v382 = 2082;
                  v383 = v110;
                  v384 = 2114;
                  v385 = v111;
                  v386 = 1024;
                  LODWORD(v387) = v112;
                  _os_log_impl( &dword_181A5C000,  v103,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart wi th count %u, rebuilding stack",  buf,  0x4Eu);
                }
              }

              uint64_t v13 = v359;
              char v14 = (NWConcrete_nw_endpoint_handler *)v356;
              goto LABEL_97;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v127 = (id)gconnectionLogObj;
            v128 = nw_endpoint_handler_get_id_string(v14);
            v129 = nw_endpoint_handler_dry_run_string(v14);
            v130 = nw_endpoint_handler_copy_endpoint(v14);
            v131 = nw_endpoint_get_logging_description(v130);
            v132 = v14;
            v133 = nw_endpoint_handler_state_string(v14);
            v134 = nw_endpoint_handler_mode_string(v132);
            v135 = nw_endpoint_handler_copy_current_path(v132);
            *(_DWORD *)buf = 136447746;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v128;
            v376 = 2082;
            v377 = v129;
            v378 = 2082;
            v379 = v131;
            v380 = 2082;
            v381 = v133;
            v382 = 2082;
            v383 = v134;
            v384 = 2114;
            v385 = v135;
            v351 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v136 = (char *)v351;
            if ((__nwlog_fault(v351, &type, &v364) & 1) == 0) {
              goto LABEL_238;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v137 = (os_log_s *)(id)gconnectionLogObj;
              v138 = type;
              if (os_log_type_enabled(v137, type))
              {
                v139 = nw_endpoint_handler_get_id_string(v356);
                v140 = nw_endpoint_handler_dry_run_string(v356);
                v141 = nw_endpoint_handler_copy_endpoint(v356);
                v142 = nw_endpoint_get_logging_description(v141);
                v143 = nw_endpoint_handler_state_string(v356);
                v144 = nw_endpoint_handler_mode_string(v356);
                v145 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136447746;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v139;
                v376 = 2082;
                v377 = v140;
                v378 = 2082;
                v379 = v142;
                v380 = 2082;
                v381 = v143;
                v382 = 2082;
                v383 = v144;
                v384 = 2114;
                v385 = v145;
                _os_log_impl( &dword_181A5C000,  v137,  v138,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with out connecting too many times, failing flow",  buf,  0x48u);
              }
            }

            else if (v364)
            {
              v190 = __nw_create_backtrace_string();
              if (v190)
              {
                v191 = (char *)v190;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v192 = (os_log_s *)(id)gconnectionLogObj;
                v193 = type;
                if (os_log_type_enabled(v192, type))
                {
                  v194 = nw_endpoint_handler_get_id_string(v356);
                  v195 = nw_endpoint_handler_dry_run_string(v356);
                  v346 = nw_endpoint_handler_copy_endpoint(v356);
                  v196 = nw_endpoint_get_logging_description(v346);
                  v197 = nw_endpoint_handler_state_string(v356);
                  v198 = nw_endpoint_handler_mode_string(v356);
                  v199 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v194;
                  v376 = 2082;
                  v377 = v195;
                  v378 = 2082;
                  v379 = v196;
                  v380 = 2082;
                  v381 = v197;
                  v382 = 2082;
                  v383 = v198;
                  v384 = 2114;
                  v385 = v199;
                  v386 = 2082;
                  v387 = v191;
                  _os_log_impl( &dword_181A5C000,  v192,  v193,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart wi thout connecting too many times, failing flow, dumping backtrace:%{public}s",  buf,  0x52u);
                }

                free(v191);
                goto LABEL_237;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v137 = (os_log_s *)(id)gconnectionLogObj;
              v288 = type;
              if (os_log_type_enabled(v137, type))
              {
                v289 = nw_endpoint_handler_get_id_string(v356);
                v290 = nw_endpoint_handler_dry_run_string(v356);
                v291 = nw_endpoint_handler_copy_endpoint(v356);
                v292 = nw_endpoint_get_logging_description(v291);
                v293 = nw_endpoint_handler_state_string(v356);
                v294 = nw_endpoint_handler_mode_string(v356);
                v295 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136447746;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v289;
                v376 = 2082;
                v377 = v290;
                v378 = 2082;
                v379 = v292;
                v380 = 2082;
                v381 = v293;
                v382 = 2082;
                v383 = v294;
                v384 = 2114;
                v385 = v295;
                _os_log_impl( &dword_181A5C000,  v137,  v288,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with out connecting too many times, failing flow, no backtrace",  buf,  0x48u);
              }
            }

            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v137 = (os_log_s *)(id)gconnectionLogObj;
              v264 = type;
              if (os_log_type_enabled(v137, type))
              {
                v265 = nw_endpoint_handler_get_id_string(v356);
                v266 = nw_endpoint_handler_dry_run_string(v356);
                v267 = nw_endpoint_handler_copy_endpoint(v356);
                v268 = nw_endpoint_get_logging_description(v267);
                v269 = nw_endpoint_handler_state_string(v356);
                v270 = nw_endpoint_handler_mode_string(v356);
                v271 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136447746;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v265;
                v376 = 2082;
                v377 = v266;
                v378 = 2082;
                v379 = v268;
                v380 = 2082;
                v381 = v269;
                v382 = 2082;
                v383 = v270;
                v384 = 2114;
                v385 = v271;
                _os_log_impl( &dword_181A5C000,  v137,  v264,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with out connecting too many times, failing flow, backtrace limit exceeded",  buf,  0x48u);
              }
            }

LABEL_237:
            v136 = (char *)v351;
LABEL_238:
            uint64_t v13 = v359;
            if (v136) {
              free(v136);
            }
LABEL_240:
            nw_protocol_disconnected((void *)a1, *(void *)(a1 + 32));
            goto LABEL_45;
          case 0x17u:
            if (a4 && a5 == 1)
            {
              v125 = *a4;
              v126 = *((_BYTE *)v13 + 35);
              *((_BYTE *)v13 + 35) = v126 & 0xEF | (16 * v125);
              if (!v125 && (v126 & 8) != 0)
              {
                *((_BYTE *)v13 + 35) = v126 & 0xE7 | (16 * v125);
                nw_endpoint_flow_start_child(v14);
              }

              goto LABEL_45;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v162 = (id)gconnectionLogObj;
            v163 = nw_endpoint_handler_get_id_string(v14);
            v164 = nw_endpoint_handler_dry_run_string(v14);
            v165 = nw_endpoint_handler_copy_endpoint(v14);
            v166 = nw_endpoint_get_logging_description(v165);
            v167 = nw_endpoint_handler_state_string(v14);
            v168 = nw_endpoint_handler_mode_string(v14);
            v169 = nw_endpoint_handler_copy_current_path(v14);
            *(_DWORD *)buf = 136448002;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v163;
            v376 = 2082;
            v377 = v164;
            v378 = 2082;
            v379 = v166;
            v380 = 2082;
            v381 = v167;
            v382 = 2082;
            v383 = v168;
            v384 = 2114;
            v385 = v169;
            v386 = 2080;
            v387 = "delay_child";
            v70 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v71 = (char *)v70;
            if ((__nwlog_fault(v70, &type, &v364) & 1) == 0) {
              goto LABEL_252;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v72 = (os_log_s *)(id)gconnectionLogObj;
              v170 = type;
              if (os_log_type_enabled(v72, type))
              {
                v171 = nw_endpoint_handler_get_id_string(v356);
                v172 = nw_endpoint_handler_dry_run_string(v356);
                v173 = nw_endpoint_handler_copy_endpoint(v356);
                v174 = nw_endpoint_get_logging_description(v173);
                v175 = nw_endpoint_handler_state_string(v356);
                v176 = nw_endpoint_handler_mode_string(v356);
                v177 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v171;
                v376 = 2082;
                v377 = v172;
                v378 = 2082;
                v379 = v174;
                v380 = 2082;
                v381 = v175;
                v382 = 2082;
                v383 = v176;
                v384 = 2114;
                v385 = v177;
                v386 = 2080;
                v387 = "delay_child";
                _os_log_impl( &dword_181A5C000,  v72,  v170,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pass ed to %s notification",  buf,  0x52u);
              }

              goto LABEL_250;
            }

            if (v364)
            {
              v208 = __nw_create_backtrace_string();
              if (v208)
              {
                v179 = (char *)v208;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v180 = (os_log_s *)(id)gconnectionLogObj;
                v209 = type;
                if (os_log_type_enabled(v180, type))
                {
                  v210 = nw_endpoint_handler_get_id_string(v356);
                  v211 = nw_endpoint_handler_dry_run_string(v356);
                  v354 = nw_endpoint_handler_copy_endpoint(v356);
                  v212 = nw_endpoint_get_logging_description(v354);
                  v213 = nw_endpoint_handler_state_string(v356);
                  v214 = nw_endpoint_handler_mode_string(v356);
                  v215 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448258;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v210;
                  v376 = 2082;
                  v377 = v211;
                  v378 = 2082;
                  v379 = v212;
                  v380 = 2082;
                  v381 = v213;
                  v382 = 2082;
                  v383 = v214;
                  v384 = 2114;
                  v385 = v215;
                  v386 = 2080;
                  v387 = "delay_child";
                  v388 = 2082;
                  v389 = v179;
                  _os_log_impl( &dword_181A5C000,  v180,  v209,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pa ssed to %s notification, dumping backtrace:%{public}s",  buf,  0x5Cu);
                }

                goto LABEL_175;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v72 = (os_log_s *)(id)gconnectionLogObj;
              v304 = type;
              if (os_log_type_enabled(v72, type))
              {
                v305 = nw_endpoint_handler_get_id_string(v356);
                v306 = nw_endpoint_handler_dry_run_string(v356);
                v307 = nw_endpoint_handler_copy_endpoint(v356);
                v308 = nw_endpoint_get_logging_description(v307);
                v309 = nw_endpoint_handler_state_string(v356);
                v310 = nw_endpoint_handler_mode_string(v356);
                v311 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v305;
                v376 = 2082;
                v377 = v306;
                v378 = 2082;
                v379 = v308;
                v380 = 2082;
                v381 = v309;
                v382 = 2082;
                v383 = v310;
                v384 = 2114;
                v385 = v311;
                v386 = 2080;
                v387 = "delay_child";
                _os_log_impl( &dword_181A5C000,  v72,  v304,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pass ed to %s notification, no backtrace",  buf,  0x52u);
              }
            }

            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v72 = (os_log_s *)(id)gconnectionLogObj;
              v280 = type;
              if (os_log_type_enabled(v72, type))
              {
                v281 = nw_endpoint_handler_get_id_string(v356);
                v282 = nw_endpoint_handler_dry_run_string(v356);
                v283 = nw_endpoint_handler_copy_endpoint(v356);
                v284 = nw_endpoint_get_logging_description(v283);
                v285 = nw_endpoint_handler_state_string(v356);
                v286 = nw_endpoint_handler_mode_string(v356);
                v287 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v281;
                v376 = 2082;
                v377 = v282;
                v378 = 2082;
                v379 = v284;
                v380 = 2082;
                v381 = v285;
                v382 = 2082;
                v383 = v286;
                v384 = 2114;
                v385 = v287;
                v386 = 2080;
                v387 = "delay_child";
                _os_log_impl( &dword_181A5C000,  v72,  v280,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pass ed to %s notification, backtrace limit exceeded",  buf,  0x52u);
              }
            }

            goto LABEL_250;
          case 0x18u:
            if (a5 == 8)
            {
              v350 = a4;
              v113 = nw_endpoint_handler_get_minimize_logging(v14);
              v114 = nw_endpoint_handler_get_logging_disabled(v14);
              if (v113)
              {
                if ((v114 & 1) != 0) {
                  goto LABEL_150;
                }
                v123 = v14;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v115 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
                {
                  v325 = nw_endpoint_handler_get_id_string(v14);
                  v326 = nw_endpoint_handler_dry_run_string(v14);
                  v327 = nw_endpoint_handler_copy_endpoint(v14);
                  v328 = nw_endpoint_get_logging_description(v327);
                  v329 = nw_endpoint_handler_state_string(v14);
                  v330 = nw_endpoint_handler_mode_string(v123);
                  v331 = nw_endpoint_handler_copy_current_path(v123);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v325;
                  v376 = 2082;
                  v377 = v326;
                  v378 = 2082;
                  v379 = v328;
                  v380 = 2082;
                  v381 = v329;
                  v382 = 2082;
                  v383 = v330;
                  v384 = 2114;
                  v385 = v331;
                  v386 = 2112;
                  v387 = (const char *)v350;
                  _os_log_impl( &dword_181A5C000,  v115,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received migration interface %@",  buf,  0x52u);
                }
              }

              else
              {
                if ((v114 & 1) != 0)
                {
LABEL_150:
                  v188 = (void *)*((void *)v13 + 104);
                  if (v188)
                  {
                    v189 = nw_path_flow_registration_copy_path(v188);
                    os_unfair_lock_lock((os_unfair_lock_t)v13 + 220);
                    objc_storeStrong((id *)v13 + 2, (id)v189);
                    if ((*((_BYTE *)v13 + 33) & 4) != 0) {
                      objc_storeStrong((id *)v13 + 1, (id)v189);
                    }
                    os_unfair_lock_unlock((os_unfair_lock_t)v13 + 220);
                  }

                  nw_endpoint_handler_migration_callback(v14, v350);

                  goto LABEL_44;
                }

                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v115 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v115, OS_LOG_TYPE_INFO))
                {
                  v116 = nw_endpoint_handler_get_id_string(v14);
                  v117 = nw_endpoint_handler_dry_run_string(v14);
                  v118 = nw_endpoint_handler_copy_endpoint(v14);
                  v119 = nw_endpoint_get_logging_description(v118);
                  v120 = v14;
                  v121 = nw_endpoint_handler_state_string(v14);
                  v122 = nw_endpoint_handler_mode_string(v120);
                  v123 = v120;
                  v124 = nw_endpoint_handler_copy_current_path(v120);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v116;
                  v376 = 2082;
                  v377 = v117;
                  v378 = 2082;
                  v379 = v119;
                  v380 = 2082;
                  v381 = v121;
                  v382 = 2082;
                  v383 = v122;
                  v384 = 2114;
                  v385 = v124;
                  v386 = 2112;
                  v387 = (const char *)v350;
                  _os_log_impl( &dword_181A5C000,  v115,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received migration interface %@",  buf,  0x52u);
                }

                else
                {
                  v123 = v14;
                }
              }

              uint64_t v13 = v359;
              char v14 = v123;
              goto LABEL_150;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v146 = (id)gconnectionLogObj;
            v147 = nw_endpoint_handler_get_id_string(v14);
            v148 = nw_endpoint_handler_dry_run_string(v14);
            v149 = nw_endpoint_handler_copy_endpoint(v14);
            v150 = nw_endpoint_get_logging_description(v149);
            v151 = nw_endpoint_handler_state_string(v14);
            v152 = nw_endpoint_handler_mode_string(v14);
            v153 = nw_endpoint_handler_copy_current_path(v14);
            *(_DWORD *)buf = 136448002;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v147;
            v376 = 2082;
            v377 = v148;
            v378 = 2082;
            v379 = v150;
            v380 = 2082;
            v381 = v151;
            v382 = 2082;
            v383 = v152;
            v384 = 2114;
            v385 = v153;
            v386 = 2080;
            v387 = "migration";
            v70 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v71 = (char *)v70;
            if ((__nwlog_fault(v70, &type, &v364) & 1) == 0) {
              goto LABEL_252;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v72 = (os_log_s *)(id)gconnectionLogObj;
              v154 = type;
              if (os_log_type_enabled(v72, type))
              {
                v155 = nw_endpoint_handler_get_id_string(v356);
                v156 = nw_endpoint_handler_dry_run_string(v356);
                v157 = nw_endpoint_handler_copy_endpoint(v356);
                v158 = nw_endpoint_get_logging_description(v157);
                v159 = nw_endpoint_handler_state_string(v356);
                v160 = nw_endpoint_handler_mode_string(v356);
                v161 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v155;
                v376 = 2082;
                v377 = v156;
                v378 = 2082;
                v379 = v158;
                v380 = 2082;
                v381 = v159;
                v382 = 2082;
                v383 = v160;
                v384 = 2114;
                v385 = v161;
                v386 = 2080;
                v387 = "migration";
                _os_log_impl( &dword_181A5C000,  v72,  v154,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pass ed to %s notification",  buf,  0x52u);
              }
            }

            else if (v364)
            {
              v200 = __nw_create_backtrace_string();
              if (v200)
              {
                v179 = (char *)v200;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v180 = (os_log_s *)(id)gconnectionLogObj;
                v201 = type;
                if (os_log_type_enabled(v180, type))
                {
                  v202 = nw_endpoint_handler_get_id_string(v356);
                  v203 = nw_endpoint_handler_dry_run_string(v356);
                  v353 = nw_endpoint_handler_copy_endpoint(v356);
                  v204 = nw_endpoint_get_logging_description(v353);
                  v205 = nw_endpoint_handler_state_string(v356);
                  v206 = nw_endpoint_handler_mode_string(v356);
                  v207 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448258;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v202;
                  v376 = 2082;
                  v377 = v203;
                  v378 = 2082;
                  v379 = v204;
                  v380 = 2082;
                  v381 = v205;
                  v382 = 2082;
                  v383 = v206;
                  v384 = 2114;
                  v385 = v207;
                  v386 = 2080;
                  v387 = "migration";
                  v388 = 2082;
                  v389 = v179;
                  _os_log_impl( &dword_181A5C000,  v180,  v201,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pa ssed to %s notification, dumping backtrace:%{public}s",  buf,  0x5Cu);
                }

  if (v14) {
    free(v14);
  }
}

  if (v17) {
    free(v17);
  }
}

      free(v10);
      goto LABEL_46;
    }

    __nwlog_obj();
    __int16 v34 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "nw_parameters_create_quic";
    unint64_t v29 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (__nwlog_fault(v29, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v35 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)buf = 136446210;
          v58 = "nw_parameters_create_quic";
          _os_log_impl( &dword_181A5C000,  v30,  v35,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_default_configuration))",  buf,  0xCu);
        }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_46;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    if (*((_DWORD *)handle + 127) != 5)
    {
      if ((handle[529] & 1) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v5 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
        {
          logging_description = nw_endpoint_get_logging_description(*((void **)handle + 39));
          *(_DWORD *)buf = 136446722;
          __int16 v23 = handle + 531;
          uint64_t v24 = 2080;
          __int16 v25 = " ";
          uint64_t v26 = 2082;
          uint64_t v27 = logging_description;
          _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s%sClosing connection for %{public}s",  buf,  0x20u);
        }
      }

      nw_protocol_remove_instance((uint64_t)a1);
      *((_DWORD *)handle + 127) = 5;
      if (a2)
      {
        callbacks = a2->callbacks;
        if (callbacks)
        {
          disconnected = (void (*)(nw_protocol *, nw_protocol *))callbacks->disconnected;
          if (disconnected) {
            disconnected(a2, a1);
          }
        }
      }

      BOOL v9 = *((void *)handle + 4);
      if (v9)
      {
        os_log_type_t v10 = *(void *)(v9 + 24);
        if (v10)
        {
          BOOL v11 = *(void (**)(void))(v10 + 32);
          if (v11) {
            v11();
          }
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v23 = "nw_protocol_masque_disconnect";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v20 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    char v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_masque_disconnect";
    os_log_type_t v15 = "%{public}s called with null masque";
    goto LABEL_45;
  }

  if (!v20)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    char v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_masque_disconnect";
    os_log_type_t v15 = "%{public}s called with null masque, backtrace limit exceeded";
    goto LABEL_45;
  }

  __int16 v18 = (char *)__nw_create_backtrace_string();
  uint64_t v13 = (os_log_s *)__nwlog_obj();
  char v14 = type;
  char v19 = os_log_type_enabled(v13, type);
  if (!v18)
  {
    if (!v19) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_masque_disconnect";
    os_log_type_t v15 = "%{public}s called with null masque, no backtrace";
    goto LABEL_45;
  }

  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v23 = "nw_protocol_masque_disconnect";
    uint64_t v24 = 2082;
    __int16 v25 = v18;
    _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v18);
  if (v12) {
    goto LABEL_47;
  }
}

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_46;
  }

  BOOL v3 = *(void **)(a1 + 320);
  if (v3)
  {
    memset(uu, 0, 16);
    uint64_t v5 = v3;
    os_log_type_t v6 = v5[23];

    if (v6)
    {
      uint64_t v7 = (char *)v6;
      *(_OWORD *)uu = *(_OWORD *)(v7 + 56);

      os_release(v7);
    }

    is_null = uuid_is_null((const unsigned __int8 *)uu);
    BOOL v9 = *(_DWORD *)(a1 + 527);
    if (is_null)
    {
      if ((v9 & 0x10000) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        os_log_type_t v10 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v22 = (const char *)(a1 + 531);
          __int16 v23 = 2080;
          uint64_t v24 = " ";
          __int16 v25 = 1024;
          uint64_t v26 = a2;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s%sCannot report error %d, no proxy agent",  buf,  0x1Cu);
        }
      }
    }

    else
    {
      if ((v9 & 0x10000) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        BOOL v11 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136447234;
          uint64_t v22 = (const char *)(a1 + 531);
          __int16 v23 = 2080;
          uint64_t v24 = " ";
          __int16 v25 = 1024;
          uint64_t v26 = a2;
          uint64_t v27 = 1042;
          int v28 = 16;
          unint64_t v29 = 2098;
          unint64_t v30 = (unsigned __int8 *)uu;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s%sReporting error %d to proxy agent %{public, uuid_t}.16P",  buf,  0x2Cu);
        }
      }

      nw_path_report_error_to_agent(*(void **)(a1 + 336), (const unsigned __int8 *)uu, a2);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();
  uu[0] = OS_LOG_TYPE_ERROR;
  uint64_t v20 = 0;
  if (uu[0] == OS_LOG_TYPE_FAULT)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    char v14 = uu[0];
    if (!os_log_type_enabled(v13, uu[0])) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
    os_log_type_t v15 = "%{public}s called with null masque->parameters";
    goto LABEL_45;
  }

  if (!v20)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    char v14 = uu[0];
    if (!os_log_type_enabled(v13, uu[0])) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
    os_log_type_t v15 = "%{public}s called with null masque->parameters, backtrace limit exceeded";
    goto LABEL_45;
  }

  __int16 v18 = (char *)__nw_create_backtrace_string();
  uint64_t v13 = (os_log_s *)__nwlog_obj();
  char v14 = uu[0];
  char v19 = os_log_type_enabled(v13, uu[0]);
  if (!v18)
  {
    if (!v19) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
    os_log_type_t v15 = "%{public}s called with null masque->parameters, no backtrace";
    goto LABEL_45;
  }

  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
    __int16 v23 = 2082;
    uint64_t v24 = v18;
    _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null masque->parameters, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v18);
  if (v12) {
    goto LABEL_47;
  }
}

    free(backtrace_string);
    goto LABEL_55;
  }

  char v16 = (os_log_s *)__nwlog_obj();
  uint64_t v17 = v37;
  if (os_log_type_enabled(v16, (os_log_type_t)v37))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
    __int16 v18 = "%{public}s called with null protocol";
LABEL_54:
    _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
  }

    if (v15) {
      free(v15);
    }
    uint64_t v7 = 0LL;
    goto LABEL_53;
  }

  uint64_t v7 = v6;
  uint64_t v8 = nw_protocol_metadata_copy_definition(v6);
  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_52);
  }
  is_equal = nw_protocol_definition_is_equal( v8,  (nw_protocol_definition_t)nw_protocol_copy_http_client_definition_definition);

  if (!is_equal)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_initial_request";
    char v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v32 = 0;
    if (__nwlog_fault(v19, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)(id)gLogObj;
        uint32_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_initial_request";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s metadata must be http_client", buf, 0xCu);
        }
      }

      else if (v32)
      {
        __int16 v25 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)(id)gLogObj;
        uint64_t v26 = type;
        uint64_t v27 = os_log_type_enabled(v20, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_initial_request";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v25;
            _os_log_impl( &dword_181A5C000,  v20,  v26,  "%{public}s metadata must be http_client, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v25);
          goto LABEL_51;
        }

        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_initial_request";
          _os_log_impl(&dword_181A5C000, v20, v26, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)(id)gLogObj;
        unint64_t v29 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_initial_request";
          _os_log_impl( &dword_181A5C000,  v20,  v29,  "%{public}s metadata must be http_client, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v14) {
    free(v14);
  }
LABEL_47:
  BOOL v12 = 0LL;
  return (NSString *)v12;
}

LABEL_63:
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

    goto LABEL_17;
  }

  __int16 v25 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v23 = type;
  uint64_t v26 = os_log_type_enabled(v22, type);
  if (!v25)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v30 = "tcp_connection_write_buffer";
      uint64_t v24 = "%{public}s called with null handler, no backtrace";
      goto LABEL_44;
    }

    goto LABEL_45;
  }

  if (v26)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v30 = "tcp_connection_write_buffer";
    v31 = 2082;
    __int16 v32 = v25;
    _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v25);
  if (v12) {
LABEL_26:
  }
    free(v12);
LABEL_27:
}

        close(v12);
      }

    goto LABEL_46;
  }

  if (!v39)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v23 = (os_log_s *)(id)gLogObj;
    unint64_t v30 = type;
    if (os_log_type_enabled(v23, type))
    {
      else {
        v31 = off_189BBBBC0[v9];
      }
      *(_DWORD *)buf = 136446722;
      v42 = "-[NWConcrete_nw_endpoint_fallback cancelWithHandler:forced:]";
      v43 = 2082;
      v44 = (void *)v31;
      v45 = 2082;
      v46 = "fallback";
      _os_log_impl( &dword_181A5C000,  v23,  v30,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_45;
  }

  uint64_t v26 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v23 = (os_log_s *)(id)gLogObj;
  uint64_t v27 = type;
  int v28 = os_log_type_enabled(v23, type);
  if (!v26)
  {
    if (v28)
    {
      else {
        __int16 v32 = off_189BBBBC0[v9];
      }
      *(_DWORD *)buf = 136446722;
      v42 = "-[NWConcrete_nw_endpoint_fallback cancelWithHandler:forced:]";
      v43 = 2082;
      v44 = (void *)v32;
      v45 = 2082;
      v46 = "fallback";
      _os_log_impl( &dword_181A5C000,  v23,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_45;
  }

  if (v28)
  {
    else {
      unint64_t v29 = off_189BBBBC0[v9];
    }
    *(_DWORD *)buf = 136446978;
    v42 = "-[NWConcrete_nw_endpoint_fallback cancelWithHandler:forced:]";
    v43 = 2082;
    v44 = (void *)v29;
    v45 = 2082;
    v46 = "fallback";
    v47 = 2082;
    v48 = v26;
    _os_log_impl( &dword_181A5C000,  v23,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v26);
  if (v22) {
    goto LABEL_47;
  }
LABEL_48:
}

        __int16 v23 = 0LL;
LABEL_46:
        _Block_object_dispose(v79, 8);
        return v23;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_http2_transport_get_input_frames";
      __int16 v25 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v63) = 0;
      if (__nwlog_fault(v25, type, &v63))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v26 = (os_log_s *)gLogObj;
          uint64_t v27 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_43;
          }
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_http2_transport_get_input_frames";
          int v28 = "%{public}s called with null input_protocol";
          goto LABEL_42;
        }

        if (!(_BYTE)v63)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v26 = (os_log_s *)gLogObj;
          uint64_t v27 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_43;
          }
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_http2_transport_get_input_frames";
          int v28 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_42;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v26 = (os_log_s *)gLogObj;
        uint64_t v27 = type[0];
        unint64_t v30 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v72 = "nw_protocol_http2_transport_get_input_frames";
            v73 = 2082;
            v74 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_43;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_http2_transport_get_input_frames";
          int v28 = "%{public}s called with null input_protocol, no backtrace";
LABEL_42:
          _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
        }
      }

      BOOL v9 = 0LL;
      goto LABEL_11;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v53 = "http2_transport_create_input_frame";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();
    v51 = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v15, &v51, &v39))
    {
      if (v51 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (os_log_s *)gLogObj;
        uint64_t v17 = v51;
        if (os_log_type_enabled((os_log_t)gLogObj, v51))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "http2_transport_create_input_frame";
          __int16 v18 = "%{public}s nw_frame_create new input frame failed";
LABEL_40:
          _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
        }
      }

      else if (v39)
      {
        uint64_t v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (os_log_s *)gLogObj;
        uint64_t v17 = v51;
        __int16 v23 = os_log_type_enabled((os_log_t)gLogObj, v51);
        if (v22)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v53 = "http2_transport_create_input_frame";
            v54 = 2082;
            v55 = (uint64_t)v22;
            _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s nw_frame_create new input frame failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v22);
          goto LABEL_41;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v53 = "http2_transport_create_input_frame";
          __int16 v18 = "%{public}s nw_frame_create new input frame failed, no backtrace";
          goto LABEL_40;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (os_log_s *)gLogObj;
        uint64_t v17 = v51;
        if (os_log_type_enabled((os_log_t)gLogObj, v51))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "http2_transport_create_input_frame";
          __int16 v18 = "%{public}s nw_frame_create new input frame failed, backtrace limit exceeded";
          goto LABEL_40;
        }
      }
    }

      if (!v3) {
        return;
      }
      goto LABEL_46;
    }

    if (v69 == OS_LOG_TYPE_DEFAULT)
    {
      unint64_t v30 = (os_log_s *)__nwlog_obj();
      v31 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
        uint64_t v20 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_109;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v30 = (os_log_s *)__nwlog_obj();
    v31 = type[0];
    v43 = os_log_type_enabled(v30, type[0]);
    if (!backtrace_string)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
        uint64_t v20 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_109;
      }

      goto LABEL_45;
    }

    if (!v43) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    __int16 v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_76:
    uint64_t v24 = v30;
    __int16 v25 = v31;
    uint64_t v26 = 22;
    goto LABEL_36;
  }

  BOOL v3 = *(void *)(v2 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
    BOOL v3 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v69 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v30 = (os_log_s *)__nwlog_obj();
      v31 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
        uint64_t v20 = "%{public}s called with null http2_transport";
        goto LABEL_109;
      }

      goto LABEL_45;
    }

    if (v69 == OS_LOG_TYPE_DEFAULT)
    {
      unint64_t v30 = (os_log_s *)__nwlog_obj();
      v31 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
        uint64_t v20 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_109;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v30 = (os_log_s *)__nwlog_obj();
    v31 = type[0];
    v44 = os_log_type_enabled(v30, type[0]);
    if (!backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
        uint64_t v20 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_109;
      }

      goto LABEL_45;
    }

    if (!v44) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    __int16 v23 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_76;
  }

  if (gLogDatapath)
  {
    __int16 v32 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v3 + 205;
      _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  uint64_t v4 = *(void *)(v3 + 72);
  if (v4)
  {
    nw_queue_cancel_source(v4, a2);
    *(void *)(v3 + 72) = 0LL;
  }

  uint64_t v5 = *(void *)(v3 + 112);
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = v3 + 205;
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v3 + 205;
    BOOL v3 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v69 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v18 = gLogObj;
      char v19 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v17;
      uint64_t v20 = "%{public}s %{public}s http2_transport_streams_protocol NULL when destroying";
LABEL_43:
      uint64_t v27 = (os_log_s *)v18;
      int v28 = v19;
      unint64_t v29 = 22;
LABEL_44:
      _os_log_impl(&dword_181A5C000, v27, v28, v20, buf, v29);
      goto LABEL_45;
    }

    if (v69 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v18 = gLogObj;
      char v19 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v17;
      uint64_t v20 = "%{public}s %{public}s http2_transport_streams_protocol NULL when destroying, backtrace limit exceeded";
      goto LABEL_43;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v18 = gLogObj;
    char v19 = type[0];
    uint64_t v22 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (!v22) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v17;
      uint64_t v20 = "%{public}s %{public}s http2_transport_streams_protocol NULL when destroying, no backtrace";
      goto LABEL_43;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2082;
      v77 = backtrace_string;
      __int16 v23 = "%{public}s %{public}s http2_transport_streams_protocol NULL when destroying, dumping backtrace:%{public}s";
      uint64_t v24 = (os_log_s *)v18;
      __int16 v25 = v19;
      uint64_t v26 = 32;
LABEL_36:
      _os_log_impl(&dword_181A5C000, v24, v25, v23, buf, v26);
    }

  if (v12) {
    free(v12);
  }
  uint64 = 0LL;
LABEL_12:

  return uint64;
}

      free(v24);
    }
  }

      free(v29);
    }
  }

    goto LABEL_46;
  }

  if (!v21)
  {
    __nwlog_obj();
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v19 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_content_context_set_relative_priority";
      _os_log_impl( &dword_181A5C000,  v7,  v19,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_45;
  }

  uint64_t v13 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  char v14 = type;
  os_log_type_t v15 = os_log_type_enabled(v7, type);
  if (!v13)
  {
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_content_context_set_relative_priority";
      _os_log_impl(&dword_181A5C000, v7, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
    }

    goto LABEL_45;
  }

  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v24 = "nw_content_context_set_relative_priority";
    __int16 v25 = 2082;
    uint64_t v26 = v13;
    _os_log_impl( &dword_181A5C000,  v7,  v14,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v13);
LABEL_46:
  if (v10) {
LABEL_47:
  }
    free(v10);
LABEL_12:
}

    goto LABEL_46;
  }

  if (!v7)
  {
    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        char v16 = "%{public}s called with null queue";
        goto LABEL_44;
      }
    }

    else
    {
      if (v30)
      {
        __int16 v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        uint64_t v26 = os_log_type_enabled(v14, type);
        if (v25)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
            __int16 v34 = 2082;
            unint64_t v35 = v25;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v25);
          if (!v13) {
            goto LABEL_48;
          }
          goto LABEL_47;
        }

        if (!v26) {
          goto LABEL_45;
        }
        *(_DWORD *)buf = 136446210;
        v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        char v16 = "%{public}s called with null queue, no backtrace";
        goto LABEL_44;
      }

      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        char v16 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_44;
      }
    }

    goto LABEL_45;
  }

  v29.receiver = self;
  v29.super_class = (Class)&OBJC_CLASS___NWNetworkAgentRegistration;
  BOOL v9 = -[NWNetworkAgentRegistration init](&v29, sel_init);
  if (v9)
  {
    os_log_type_t v10 = v9;
    v9->_networkAgentClass = a3;
    v9->_registrationSocket = -1;
    objc_storeStrong((id *)&v9->_queue, a4);
    goto LABEL_5;
  }

  __nwlog_obj();
  __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
  char v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v30 = 0;
  if (__nwlog_fault(v19, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint32_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        uint64_t v22 = "%{public}s [super init] failed";
LABEL_51:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else
    {
      if (v30)
      {
        uint64_t v27 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint32_t v21 = type;
        int v28 = os_log_type_enabled(v20, type);
        if (v27)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
            __int16 v34 = 2082;
            unint64_t v35 = v27;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v27);
          goto LABEL_53;
        }

        if (!v28) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        uint64_t v22 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_51;
      }

      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint32_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        uint64_t v22 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_51;
      }
    }

  return (char)v8;
}

    goto LABEL_46;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v9 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v28 = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      BOOL v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
        uint64_t v13 = "%{public}s called with null request";
LABEL_29:
        char v19 = v11;
        uint64_t v20 = v12;
LABEL_30:
        _os_log_impl(&dword_181A5C000, v19, v20, v13, buf, 0xCu);
      }
    }

    else
    {
      if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type;
        char v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            int v28 = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
            unint64_t v29 = 2082;
            unint64_t v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (!v16) {
          goto LABEL_31;
        }
        *(_DWORD *)buf = 136446210;
        int v28 = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
        uint64_t v13 = "%{public}s called with null request, no backtrace";
        char v19 = v11;
        uint64_t v20 = v15;
        goto LABEL_30;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      BOOL v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
        uint64_t v13 = "%{public}s called with null request, backtrace limit exceeded";
        goto LABEL_29;
      }
    }

    free(backtrace_string);
    goto LABEL_55;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        __int16 v23 = "%{public}s called with null context";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    if (!v30)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        __int16 v23 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    uint64_t v27 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        __int16 v23 = "%{public}s called with null context, no backtrace";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v26 = "%{public}s called with null context, dumping backtrace:%{public}s";
      goto LABEL_44;
    }

    goto LABEL_45;
  }

  uint64_t v7 = a3;
  uint64_t v8 = v7;
  if (((_BYTE)v7[17] & 8) == 0) {
    dispatch_assert_queue_V2(v7[1]);
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  v33 = 0LL;
  BOOL v9 = MEMORY[0x1895F87A8];
  os_log_type_t v10 = a1;
  do
  {
    if (*(void *)(*(void *)&buf[8] + 24LL)) {
      break;
    }
    BOOL v11 = *(void *)(v10 + 16);
    if (*(_DWORD *)(v11 + 36) == 2)
    {
      BOOL v12 = &g_registration_list;
      while (1)
      {
        BOOL v12 = (uint64_t *)*v12;
        if (!v12) {
          break;
        }
        if (*(void *)v11 == v12[4]
          && *(void *)(v11 + 8) == v12[5]
          && *(void *)(v11 + 16) == v12[6]
          && *(void *)(v11 + 24) == v12[7]
          && *(void *)(v11 + 32) == v12[8])
        {
          uint64_t v17 = (unsigned __int8 *)v12[9];
          v28[0] = v9;
          v28[1] = 0x40000000LL;
          v28[2] = __nw_protocol_copy_shared_connection_state_block_invoke;
          v28[3] = &unk_189BBE2E8;
          v28[4] = buf;
          v28[5] = v10;
          v28[6] = a1;
          v28[7] = a2;
          v28[8] = v8;
          unint64_t v29 = a4;
          nw_array_apply(v17, (uint64_t)v28);
          break;
        }
      }
    }

    os_log_type_t v10 = *(void *)(v10 + 32);
  }

  while (v10);
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  __int16 v18 = *(void *)(*(void *)&buf[8] + 24LL);
  _Block_object_dispose(buf, 8);
  return v18;
}

    free(backtrace_string);
    if (!v23) {
      goto LABEL_86;
    }
    goto LABEL_85;
  }

  CFHTTPMessageSetHeaderFieldValue(v10, @"Upgrade", @"WebSocket");
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v57[3], @"Connection", @"Upgrade");
  BOOL v11 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 24), @"Sec-WebSocket-Key");
  BOOL v12 = v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v26 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v61 = "nw_ws_write_server_response";
      v62 = 2082;
      v63 = (char *)(a1 + 227);
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s keyRef should not be nil",  buf,  0x16u);
    }

    uint64_t v27 = (const void *)v57[3];
    if (v27)
    {
      CFRelease(v27);
      v57[3] = 0LL;
    }

    goto LABEL_40;
  }

  uint64_t v13 = nw_ws_copy_response_for_challenge(v11);
  CFRelease(v12);
  if (!v13)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v31 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v61 = "nw_ws_write_server_response";
      v62 = 2082;
      v63 = (char *)(a1 + 227);
      _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s acceptRef should not be nil",  buf,  0x16u);
    }

    __int16 v32 = (const void *)v57[3];
    if (v32)
    {
      CFRelease(v32);
      v57[3] = 0LL;
    }

    free(v18);
    if (v3) {
      goto LABEL_62;
    }
    return;
  }

  uint64_t v7 = a1;
  LOBYTE(v8) = *((_WORD *)a1 + 102);
  if ((*((_WORD *)a1 + 102) & 4) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v47 = "__nw_frame_split_finalizer";
    v48 = 2048;
    v49 = (uint64_t)v7;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_134;
      }
LABEL_12:
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_frame_split_finalizer";
      v48 = 2048;
      v49 = (uint64_t)v7;
      BOOL v12 = "%{public}s frame %p has no split metadata";
    }

    else if (v44)
    {
      uint64_t v22 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)gLogObj;
      BOOL v11 = type;
      __int16 v23 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v22)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446722;
          v47 = "__nw_frame_split_finalizer";
          v48 = 2048;
          v49 = (uint64_t)v7;
          v50 = 2082;
          v51 = (uint64_t)v22;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v22);
LABEL_134:
        if (v9)
        {
LABEL_135:
          uint64_t v27 = (char *)v9;
LABEL_136:
          free(v27);
        }

        return;
      }

      if (!v23) {
        goto LABEL_134;
      }
LABEL_132:
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_frame_split_finalizer";
      v48 = 2048;
      v49 = (uint64_t)v7;
      BOOL v12 = "%{public}s frame %p has no split metadata, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_134;
      }
LABEL_64:
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_frame_split_finalizer";
      v48 = 2048;
      v49 = (uint64_t)v7;
      BOOL v12 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0x16u);
    goto LABEL_134;
  }

  if ((*((_BYTE *)a1 + 217) & 4) != 0)
  {
    if (gLogDatapath)
    {
      uint32_t v21 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = (uint64_t)v7;
        _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s frame %p processed in loop, stopping",  buf,  0x16u);
      }
    }

    return;
  }

  while (1)
  {
    if ((v8 & 4) != 0) {
      uint64_t v13 = (char *)v7 + 208;
    }
    else {
      uint64_t v13 = 0LL;
    }
    if ((v8 & 4) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_frame_split_finalizer";
      v48 = 2048;
      v49 = (uint64_t)v7;
      BOOL v9 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_134;
        }
        goto LABEL_12;
      }

      if (!v44)
      {
        os_log_type_t v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_134;
        }
        goto LABEL_64;
      }

      unint64_t v30 = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      v31 = os_log_type_enabled(v10, type);
      if (!v30)
      {
        if (!v31) {
          goto LABEL_134;
        }
        goto LABEL_132;
      }

      if (v31)
      {
        *(_DWORD *)buf = 136446722;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = (uint64_t)v7;
        v50 = 2082;
        v51 = (uint64_t)v30;
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v30);
      if (v9) {
        goto LABEL_135;
      }
      return;
    }

    char v14 = *(void *)v13;
    if (!*(void *)v13)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v47 = "__nw_frame_split_finalizer";
      BOOL v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s called with null parent_frame";
      }

      else if (v44)
      {
        __int16 v18 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        v41 = os_log_type_enabled(v4, type);
        if (v18)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            v47 = "__nw_frame_split_finalizer";
            v48 = 2082;
            v49 = (uint64_t)v18;
            uint64_t v20 = "%{public}s called with null parent_frame, dumping backtrace:%{public}s";
            goto LABEL_44;
          }

          goto LABEL_45;
        }

        if (!v41) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s called with null parent_frame, no backtrace";
      }

      else
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s called with null parent_frame, backtrace limit exceeded";
      }

      goto LABEL_59;
    }

    if (gLogDatapath)
    {
      log = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = (uint64_t)v7;
        v50 = 2048;
        v51 = v14;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s processing finalize for frame %p with parent_frame %p",  buf,  0x20u);
      }
    }

    os_log_type_t v15 = v13[8];
    if (!v13[8])
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v47 = "__nw_frame_split_finalizer";
      BOOL v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s processing finalize for split frame that isn't a child";
        goto LABEL_59;
      }

      if (!v44)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s processing finalize for split frame that isn't a child, backtrace limit exceeded";
        goto LABEL_59;
      }

      __int16 v18 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      __int16 v32 = os_log_type_enabled(v4, type);
      if (!v18)
      {
        if (!v32) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s processing finalize for split frame that isn't a child, no backtrace";
        goto LABEL_59;
      }

      if (!v32) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_frame_split_finalizer";
      v48 = 2082;
      v49 = (uint64_t)v18;
      uint64_t v20 = "%{public}s processing finalize for split frame that isn't a child, dumping backtrace:%{public}s";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v4, v5, v20, buf, 0x16u);
      goto LABEL_45;
    }

    if (v15 == 3)
    {
      if (gLogDatapath)
      {
        v42 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v47 = "__nw_frame_split_finalizer";
          v48 = 2048;
          v49 = (uint64_t)v7;
          v50 = 2048;
          v51 = v14;
          _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s finalizing top of tree frame %p, finalizing parent immediately (%p)",  buf,  0x20u);
        }
      }

      nw_frame_finalize(v14);
      if ((v13[9] & 4) != 0) {
        nw_frame_finalize((uint64_t)v7);
      }
      nw_frame_reset((uint64_t)v7, 0LL, 0, 0LL, 0LL);
      os_release(v7);
      return;
    }

    if (*(void *)(v14 + 88) != 16435934LL)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v47 = "__nw_frame_split_finalizer";
      BOOL v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s processing finalize for split frame that has parent missing sentinel";
        goto LABEL_59;
      }

      if (!v44)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s processing finalize for split frame that has parent missing sentinel, backtrace limit exceeded";
        goto LABEL_59;
      }

      __int16 v18 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      v33 = os_log_type_enabled(v4, type);
      if (!v18)
      {
        if (!v33) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s processing finalize for split frame that has parent missing sentinel, no backtrace";
        goto LABEL_59;
      }

      if (!v33) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_frame_split_finalizer";
      v48 = 2082;
      v49 = (uint64_t)v18;
      uint64_t v20 = "%{public}s processing finalize for split frame that has parent missing sentinel, dumping backtrace:%{public}s";
      goto LABEL_44;
    }

    if ((*(_WORD *)(v14 + 204) & 4) == 0)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_frame_split_finalizer";
      v48 = 2048;
      v49 = v14;
      BOOL v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v28 = (os_log_s *)__nwlog_obj();
        unint64_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446466;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = v14;
        os_log_type_t v6 = "%{public}s frame %p has no split metadata";
LABEL_144:
        uint64_t v24 = v28;
        __int16 v25 = v29;
        uint64_t v26 = 22;
        goto LABEL_60;
      }

      if (!v44)
      {
        int v28 = (os_log_s *)__nwlog_obj();
        unint64_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446466;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = v14;
        os_log_type_t v6 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
        goto LABEL_144;
      }

      __int16 v34 = (char *)__nw_create_backtrace_string();
      int v28 = (os_log_s *)__nwlog_obj();
      unint64_t v29 = type;
      unint64_t v35 = os_log_type_enabled(v28, type);
      if (!v34)
      {
        if (!v35) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446466;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = v14;
        os_log_type_t v6 = "%{public}s frame %p has no split metadata, no backtrace";
        goto LABEL_144;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446722;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = v14;
        v50 = 2082;
        v51 = (uint64_t)v34;
        _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v34);
      if (v3) {
        goto LABEL_62;
      }
      return;
    }

    if (v15 == 2) {
      break;
    }
    if (v15 != 1) {
      goto LABEL_31;
    }
    if ((*(_BYTE *)(v14 + 217) & 1) == 0)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v47 = "__nw_frame_split_finalizer";
      BOOL v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s parent frame is not waiting for our start child finalizer";
        goto LABEL_59;
      }

      if (!v44)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        uint64_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s parent frame is not waiting for our start child finalizer, backtrace limit exceeded";
        goto LABEL_59;
      }

      __int16 v18 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      uint64_t v36 = os_log_type_enabled(v4, type);
      if (v18)
      {
        if (!v36) {
          goto LABEL_45;
        }
        *(_DWORD *)buf = 136446466;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2082;
        v49 = (uint64_t)v18;
        uint64_t v20 = "%{public}s parent frame is not waiting for our start child finalizer, dumping backtrace:%{public}s";
        goto LABEL_44;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_frame_split_finalizer";
        os_log_type_t v6 = "%{public}s parent frame is not waiting for our start child finalizer, no backtrace";
        goto LABEL_59;
      }

      goto LABEL_61;
    }

    char v16 = *(_BYTE *)(v14 + 217) & 0xFE;
LABEL_30:
    *(_BYTE *)(v14 + 217) = v16;
LABEL_31:
    *(void *)uint64_t v13 = 0LL;
    if ((v13[9] & 4) != 0) {
      nw_frame_finalize((uint64_t)v7);
    }
    nw_frame_reset((uint64_t)v7, 0LL, 0, 0LL, 0LL);
    os_release(v7);
    if ((*(_BYTE *)(v14 + 217) & 3) != 0) {
      return;
    }
    if (gLogDatapath)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v47 = "__nw_frame_split_finalizer";
        v48 = 2048;
        v49 = v14;
        _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s continuing to parent frame %p because both children have been finalized",  buf,  0x16u);
      }
    }

    *(_BYTE *)(v14 + 217) |= 4u;
    uint64_t v8 = *(_WORD *)(v14 + 204);
    uint64_t v7 = (nw_frame *)v14;
  }

  if ((*(_BYTE *)(v14 + 217) & 2) != 0)
  {
    char v16 = *(_BYTE *)(v14 + 217) & 0xFD;
    goto LABEL_30;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v47 = "__nw_frame_split_finalizer";
  BOOL v3 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v44 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_61;
    }
    *(_DWORD *)buf = 136446210;
    v47 = "__nw_frame_split_finalizer";
    os_log_type_t v6 = "%{public}s parent frame is not waiting for our end child finalizer";
    goto LABEL_59;
  }

  if (!v44)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_61;
    }
    *(_DWORD *)buf = 136446210;
    v47 = "__nw_frame_split_finalizer";
    os_log_type_t v6 = "%{public}s parent frame is not waiting for our end child finalizer, backtrace limit exceeded";
    goto LABEL_59;
  }

  __int16 v18 = (char *)__nw_create_backtrace_string();
  uint64_t v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  v37 = os_log_type_enabled(v4, type);
  if (v18)
  {
    if (!v37) {
      goto LABEL_45;
    }
    *(_DWORD *)buf = 136446466;
    v47 = "__nw_frame_split_finalizer";
    v48 = 2082;
    v49 = (uint64_t)v18;
    uint64_t v20 = "%{public}s parent frame is not waiting for our end child finalizer, dumping backtrace:%{public}s";
    goto LABEL_44;
  }

  if (v37)
  {
    *(_DWORD *)buf = 136446210;
    v47 = "__nw_frame_split_finalizer";
    os_log_type_t v6 = "%{public}s parent frame is not waiting for our end child finalizer, no backtrace";
    goto LABEL_59;
  }

            goto LABEL_46;
          }

          if (!v56)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (os_log_s *)(id)gLogObj;
            v33 = v57;
            if (os_log_type_enabled(v24, v57))
            {
              __int16 v34 = v17->endpoint;
              *(_DWORD *)os_log_type_t type = 136446722;
              v59 = "nw_service_connector_remove_pending_incoming_request";
              v60 = 2114;
              v61 = v34;
              v62 = 2082;
              service = v17->service;
              _os_log_impl( &dword_181A5C000,  v24,  v33,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded",  (uint8_t *)type,  0x20u);
            }

            goto LABEL_45;
          }

          backtrace_string = __nw_create_backtrace_string();
          if (!backtrace_string)
          {
            __nwlog_obj();
            uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            unint64_t v35 = v57;
            if (os_log_type_enabled(v24, v57))
            {
              uint64_t v36 = v17->endpoint;
              *(_DWORD *)os_log_type_t type = 136446722;
              v59 = "nw_service_connector_remove_pending_incoming_request";
              v60 = 2114;
              v61 = v36;
              v62 = 2082;
              service = v17->service;
              _os_log_impl( &dword_181A5C000,  v24,  v35,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace",  (uint8_t *)type,  0x20u);
            }

            goto LABEL_45;
          }

          unint64_t v29 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v30 = (os_log_s *)(id)gLogObj;
          v31 = v57;
          if (os_log_type_enabled(v30, v57))
          {
            __int16 v32 = v17->endpoint;
            *(_DWORD *)os_log_type_t type = 136446978;
            v59 = "nw_service_connector_remove_pending_incoming_request";
            v60 = 2114;
            v61 = v32;
            v62 = 2082;
            service = v17->service;
            v64 = 2082;
            v65 = v29;
            _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s",  (uint8_t *)type,  0x2Au);
          }

LABEL_33:
          free(v29);
          if (!v23)
          {
LABEL_48:

            v37 = *((_BYTE *)v8 + 616);
            *((_BYTE *)v8 + 616) = v37 & 0xFD;
            if ((v37 & 4) != 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v43 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
                *(_WORD *)&buf[12] = 2114;
                *(void *)&buf[14] = v15;
                *(_WORD *)&buf[22] = 2114;
                *(void *)&buf[24] = v17;
                _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ not rejecting accepted incoming request %{public}@",  buf,  0x20u);
              }

              goto LABEL_64;
            }

    if (!v6) {
      return;
    }
    goto LABEL_46;
  }

  BOOL v3 = (unsigned __int8 *)(a1 + 40);
  do
    uint64_t v4 = __ldxr(v3);
  while (__stxr(0xFFu, v3));
  if (v4)
  {
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_array_assign";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v6))
    {
      free(v6);
      do
        __ldxr(v3);
      while (__stlxr(v4, v3));
      return;
    }

    if (v14) {
      free(v14);
    }
    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v28 = "nw_quic_access_application_result_on_queue";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_quic_access_application_result_on_queue";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null association", buf, 0xCu);
      }
    }

    else if (v25)
    {
      uint64_t v17 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v18 = type;
      char v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          int v28 = "nw_quic_access_application_result_on_queue";
          unint64_t v29 = 2082;
          unint64_t v30 = v17;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null association, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_40;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_quic_access_application_result_on_queue";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_quic_access_application_result_on_queue";
        _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null association, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v13) {
      free(v13);
    }
    goto LABEL_9;
  }

  __nwlog_obj();
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v27 = "nw_quic_access_token_on_queue";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v24 = 0;
  if (__nwlog_fault(v9, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_quic_access_token_on_queue";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null association", buf, 0xCu);
      }
    }

    else if (v24)
    {
      char v16 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = type;
      __int16 v18 = os_log_type_enabled(v10, type);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v27 = "nw_quic_access_token_on_queue";
          int v28 = 2082;
          unint64_t v29 = v16;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null association, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v16);
        goto LABEL_40;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_quic_access_token_on_queue";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_quic_access_token_on_queue";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null association, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v14) {
      free(v14);
    }
    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v28 = "nw_quic_access_0rtt_state_on_queue";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_quic_access_0rtt_state_on_queue";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null association", buf, 0xCu);
      }
    }

    else if (v25)
    {
      uint64_t v17 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v18 = type;
      char v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          int v28 = "nw_quic_access_0rtt_state_on_queue";
          unint64_t v29 = 2082;
          unint64_t v30 = v17;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null association, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_40;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_quic_access_0rtt_state_on_queue";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_quic_access_0rtt_state_on_queue";
        _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null association, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v43) {
    free(v43);
  }
LABEL_28:
}

    if (v26) {
      free(v26);
    }
    goto LABEL_18;
  }

  if (*((_DWORD *)v1 + 18) == 1)
  {
    BOOL v3 = xpc_dictionary_create(0LL, 0LL, 0LL);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    v58 = __Block_byref_object_copy__56735;
    v59 = __Block_byref_object_dispose__56736;
    v60 = nw_parallel_array_create();
    uint64_t v4 = (void *)*((void *)v2 + 20);
    uint64_t v5 = MEMORY[0x1895F87A8];
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke;
    applier[3] = &unk_189BC1468;
    os_log_type_t v6 = v3;
    v48 = v6;
    uint64_t v7 = v2;
    v49 = v7;
    v50 = buf;
    xpc_dictionary_apply(v4, applier);
    uint64_t v8 = *(id *)(*(void *)&buf[8] + 40LL);
    if (nw_browse_descriptor_get_type(*((void **)v7 + 4)) != 2)
    {
      char v16 = v8;
LABEL_14:
      char v19 = _Block_copy(*((const void **)v7 + 7));
      count = nw_parallel_array_get_count(v16);
      if (v19)
      {
        uint32_t v21 = count;
        if (count)
        {
          uint64_t v22 = (dispatch_queue_s *)*((void *)v2 + 2);
          block[0] = v5;
          block[1] = 3221225472LL;
          block[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_121;
          block[3] = &unk_189BC1490;
          v43 = v16;
          v44 = v7;
          v46 = v21;
          v45 = v19;
          dispatch_async(v22, block);
        }
      }

      __int16 v23 = (void *)*((void *)v2 + 20);
      *((void *)v2 + 20) = v6;
      uint64_t v24 = v6;

      _Block_object_dispose(buf, 8);
      goto LABEL_18;
    }

    BOOL v9 = *(void **)(*(void *)&buf[8] + 40LL);
    os_log_type_t v10 = v7;
    BOOL v11 = v9;
    if (v11)
    {
      BOOL v12 = nw_parallel_array_create();
      *(void *)v61 = v5;
      *(void *)&v61[8] = 3221225472LL;
      *(void *)&v61[16] = ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke;
      v62 = &unk_189BC14B8;
      uint64_t v13 = (id)v12;
      v63 = v13;
      nw_parallel_array_apply(v11, (uint64_t)v61);
      *(void *)os_log_type_t type = v5;
      v52 = 3221225472LL;
      v53 = ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke_2;
      v54 = &unk_189BC14B8;
      char v14 = v13;
      v55 = v14;
      nw_parallel_array_apply(v11, (uint64_t)type);
      os_log_type_t v15 = v55;
      char v16 = v14;

LABEL_6:
      goto LABEL_14;
    }

    __nwlog_obj();
    __int16 v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v61 = 136446210;
    *(void *)&v61[4] = "nw_browser_create_ordered_array";
    v41 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v56 = 0;
    v33 = (char *)v41;
    if (!__nwlog_fault(v41, type, &v56))
    {
LABEL_54:
      if (v33) {
        free(v33);
      }
      char v16 = 0LL;
      goto LABEL_6;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)v61 = 136446210;
        *(void *)&v61[4] = "nw_browser_create_ordered_array";
        _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s called with null results", v61, 0xCu);
      }
    }

    else if (v56)
    {
      v37 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = type[0];
      v38 = os_log_type_enabled(v34, type[0]);
      if (v37)
      {
        if (v38)
        {
          *(_DWORD *)v61 = 136446466;
          *(void *)&v61[4] = "nw_browser_create_ordered_array";
          *(_WORD *)&v61[12] = 2082;
          *(void *)&v61[14] = v37;
          _os_log_impl( &dword_181A5C000,  v34,  v40,  "%{public}s called with null results, dumping backtrace:%{public}s",  v61,  0x16u);
        }

        free(v37);
        goto LABEL_53;
      }

      if (v38)
      {
        *(_DWORD *)v61 = 136446210;
        *(void *)&v61[4] = "nw_browser_create_ordered_array";
        _os_log_impl(&dword_181A5C000, v34, v40, "%{public}s called with null results, no backtrace", v61, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v39 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)v61 = 136446210;
        *(void *)&v61[4] = "nw_browser_create_ordered_array";
        _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s called with null results, backtrace limit exceeded",  v61,  0xCu);
      }
    }

LABEL_53:
    v33 = (char *)v41;
    goto LABEL_54;
  }

  if (!nw_parameters_get_logging_disabled(*((void *)v1 + 5)))
  {
    if (__nwlog_browser_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
    }
    uint64_t v17 = (os_log_s *)(id)gbrowserLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      __int16 v18 = *((_DWORD *)v2 + 48);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_browser_notify_browse_result_changes_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v18;
      _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] not in ready state", buf, 0x12u);
    }
  }

  __break(1u);
  return result;
}

    unint64_t v29 = 0LL;
LABEL_46:
    v11 += v18 + 5LL;
    if (v11 > a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v131 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v18;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v11;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = a3;
      v132 = (char *)_os_log_send_and_compose_impl();

      v178[0] = 16;
      v177 = 0;
      if (v178[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v133 = (os_log_s *)(id)gLogObj;
        v134 = v178[0];
        if (os_log_type_enabled(v133, (os_log_type_t)v178[0]))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v11;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = a3;
          _os_log_impl( &dword_181A5C000,  v133,  v134,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu)",  buf,  0x26u);
        }
      }

      else
      {
        if (v177)
        {
          v135 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v136 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v137 = v178[0];
          v138 = os_log_type_enabled(v136, (os_log_type_t)v178[0]);
          if (v135)
          {
            if (v138)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              *(_WORD *)&buf[18] = 2048;
              *(void *)&buf[20] = v11;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = a3;
              *(_WORD *)&buf[38] = 2082;
              *(void *)&buf[40] = v135;
              _os_log_impl( &dword_181A5C000,  v136,  v137,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), dumping backtrace:%{public}s",  buf,  0x30u);
            }

            free(v135);
            if (!v132)
            {
LABEL_334:
              if (v11 == a3)
              {
LABEL_335:
                if ((v170 & 0x100000000LL) != 0)
                {
                  local_endpoint = v10->local_endpoint;
                  if (local_endpoint
                    && (v141 = local_endpoint,
                        v142 = -[OS_nw_endpoint type](v141, "type"),
                        v141,
                        v142 == 1))
                  {
                    address = nw_endpoint_get_address(v10->local_endpoint);
                    v144 = nw_endpoint_create_address_with_ethernet(address, &v175);
                    v145 = v10->local_endpoint;
                    v10->local_endpoint = v144;
                  }

                  else
                  {
                    *(void *)&buf[8] = 0LL;
                    *(void *)&buf[2] = 0LL;
                    *(_WORD *)buf = 16;
                    v146 = nw_endpoint_create_address_with_ethernet((const sockaddr *)buf, &v175);
                    v147 = v10->local_endpoint;
                    v10->local_endpoint = v146;
                  }
                }

                v148 = object;
                if ((v170 & 1) != 0)
                {
                  remote_endpoint = v10->remote_endpoint;
                  if (remote_endpoint)
                  {
                    v150 = remote_endpoint;
                    v151 = -[OS_nw_endpoint type](v150, "type");

                    v148 = object;
                    if (v151 == 1)
                    {
                      v152 = nw_endpoint_get_address(v10->remote_endpoint);
                      v153 = nw_endpoint_create_address_with_ethernet(v152, &v173);
                      v154 = v10->remote_endpoint;
                      v10->remote_endpoint = v153;

                      nw_endpoint_clone_parent_endpoint_properties(v10->remote_endpoint, v4->endpoint);
                      v148 = object;
                    }
                  }
                }

                v155 = v10;

                goto LABEL_345;
              }

              __nwlog_obj();
              v156 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v11;
              *(_WORD *)&buf[22] = 2048;
              *(void *)&buf[24] = a3;
              v157 = (char *)_os_log_send_and_compose_impl();

              v178[0] = 16;
              v177 = 0;
              if (__nwlog_fault(v157, v178, &v177))
              {
                if (v178[0] == 17)
                {
                  __nwlog_obj();
                  v158 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v159 = v178[0];
                  if (os_log_type_enabled(v158, (os_log_type_t)v178[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                    *(_WORD *)&buf[12] = 2048;
                    *(void *)&buf[14] = v11;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)&buf[24] = a3;
                    _os_log_impl( &dword_181A5C000,  v158,  v159,  "%{public}s cursor has unexpected value %zu != %zu",  buf,  0x20u);
                  }
                }

                else
                {
                  if (v177)
                  {
                    v160 = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    v161 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    v162 = v178[0];
                    v163 = os_log_type_enabled(v161, (os_log_type_t)v178[0]);
                    if (v160)
                    {
                      if (v163)
                      {
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                        *(_WORD *)&buf[12] = 2048;
                        *(void *)&buf[14] = v11;
                        *(_WORD *)&buf[22] = 2048;
                        *(void *)&buf[24] = a3;
                        *(_WORD *)&buf[32] = 2082;
                        *(void *)&buf[34] = v160;
                        _os_log_impl( &dword_181A5C000,  v161,  v162,  "%{public}s cursor has unexpected value %zu != %zu, dumping backtrace:%{public}s",  buf,  0x2Au);
                      }

                      free(v160);
                    }

                    else
                    {
                      if (v163)
                      {
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                        *(_WORD *)&buf[12] = 2048;
                        *(void *)&buf[14] = v11;
                        *(_WORD *)&buf[22] = 2048;
                        *(void *)&buf[24] = a3;
                        _os_log_impl( &dword_181A5C000,  v161,  v162,  "%{public}s cursor has unexpected value %zu != %zu, no backtrace",  buf,  0x20u);
                      }
                    }

                    goto LABEL_363;
                  }

                  __nwlog_obj();
                  v158 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v164 = v178[0];
                  if (os_log_type_enabled(v158, (os_log_type_t)v178[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                    *(_WORD *)&buf[12] = 2048;
                    *(void *)&buf[14] = v11;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)&buf[24] = a3;
                    _os_log_impl( &dword_181A5C000,  v158,  v164,  "%{public}s cursor has unexpected value %zu != %zu, backtrace limit exceeded",  buf,  0x20u);
                  }
                }
              }

      free(v29);
      if (!v25) {
        return;
      }
LABEL_53:
      free(v25);
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v61 = "nw_http3_add_edges";
    __int16 v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(buffer_ptr) = 16;
    LOBYTE(size_ptr) = 0;
    if (buffer_ptr == 17)
    {
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      uint64_t v27 = buffer_ptr;
      if (!os_log_type_enabled(v26, (os_log_type_t)buffer_ptr)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      v61 = "nw_http3_add_edges";
      int v28 = "%{public}s http3->remote_endpoint is NULL when connected";
      goto LABEL_51;
    }

    if (!(_BYTE)size_ptr)
    {
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      uint64_t v27 = buffer_ptr;
      if (os_log_type_enabled(v26, (os_log_type_t)buffer_ptr))
      {
        *(_DWORD *)buf = 136446210;
        v61 = "nw_http3_add_edges";
        int v28 = "%{public}s http3->remote_endpoint is NULL when connected, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    unint64_t v29 = (char *)__nw_create_backtrace_string();
    uint64_t v26 = (os_log_s *)__nwlog_obj();
    uint64_t v27 = buffer_ptr;
    v54 = os_log_type_enabled(v26, (os_log_type_t)buffer_ptr);
    if (!v29)
    {
      if (v54)
      {
        *(_DWORD *)buf = 136446210;
        v61 = "nw_http3_add_edges";
        int v28 = "%{public}s http3->remote_endpoint is NULL when connected, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (!v54) {
      goto LABEL_45;
    }
    *(_DWORD *)buf = 136446466;
    v61 = "nw_http3_add_edges";
    v62 = 2082;
    v63 = (nw_protocol *)v29;
    v31 = "%{public}s http3->remote_endpoint is NULL when connected, dumping backtrace:%{public}s";
LABEL_44:
    _os_log_impl(&dword_181A5C000, v26, v27, v31, buf, 0x16u);
    goto LABEL_45;
  }

  size_ptr = 0LL;
  buffer_ptr = 0LL;
  uint64_t v22 = (dispatch_data_s *)*((void *)handle + 144);
  if (!v22)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v61 = "nw_protocol_http3_connected";
    __int16 v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (os_log_s *)gLogObj;
      uint64_t v27 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      v61 = "nw_protocol_http3_connected";
      int v28 = "%{public}s Could not find persisted SETTINGS";
      goto LABEL_51;
    }

    if (!v56)
    {
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      uint64_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      v61 = "nw_protocol_http3_connected";
      int v28 = "%{public}s Could not find persisted SETTINGS, backtrace limit exceeded";
      goto LABEL_51;
    }

    unint64_t v29 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v26 = (os_log_s *)gLogObj;
    uint64_t v27 = type;
    unint64_t v30 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v29)
    {
      if (!v30) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      v61 = "nw_protocol_http3_connected";
      int v28 = "%{public}s Could not find persisted SETTINGS, no backtrace";
      goto LABEL_51;
    }

    if (!v30) {
      goto LABEL_45;
    }
    *(_DWORD *)buf = 136446466;
    v61 = "nw_protocol_http3_connected";
    v62 = 2082;
    v63 = (nw_protocol *)v29;
    v31 = "%{public}s Could not find persisted SETTINGS, dumping backtrace:%{public}s";
    goto LABEL_44;
  }

  __int16 v23 = dispatch_data_create_map(v22, (const void **)&buffer_ptr, &size_ptr);
  nw_http3_parse_settings((uint64_t)handle, buffer_ptr, (unsigned __int16)size_ptr, v24);
  if (v23) {
    dispatch_release(v23);
  }
}

    if (v14) {
      free(v14);
    }
    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v28 = "nw_listen_protocol_disconnected";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null listener", buf, 0xCu);
      }
    }

    else if (v25)
    {
      uint64_t v17 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v18 = type;
      char v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          int v28 = "nw_listen_protocol_disconnected";
          unint64_t v29 = 2082;
          unint64_t v30 = v17;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_40;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_listen_protocol_disconnected";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        int v28 = "nw_listen_protocol_disconnected";
        _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null listener, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v31) {
      free(v31);
    }
    flow_inner = 0LL;
    goto LABEL_8;
  }

  __nwlog_obj();
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v45 = "nw_path_flow_registration_create_new_flow";
  uint64_t v27 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v27, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_path_flow_registration_create_new_flow";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null existing_flow_registration", buf, 0xCu);
      }
    }

    else if (v42)
    {
      __int16 v34 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v35 = type;
      uint64_t v36 = os_log_type_enabled(v28, type);
      if (v34)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_path_flow_registration_create_new_flow";
          v46 = 2082;
          v47 = v34;
          _os_log_impl( &dword_181A5C000,  v28,  v35,  "%{public}s called with null existing_flow_registration, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v34);
        goto LABEL_39;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_path_flow_registration_create_new_flow";
        _os_log_impl( &dword_181A5C000,  v28,  v35,  "%{public}s called with null existing_flow_registration, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_path_flow_registration_create_new_flow";
        _os_log_impl( &dword_181A5C000,  v28,  v40,  "%{public}s called with null existing_flow_registration, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    BOOL v11 = 0;
  }

      free(v20);
    }
  }

      v31 = 1LL;
      goto LABEL_46;
    }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_46;
  }

  id v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 272) & 0x20) != 0) {
      return;
    }
    *(_BYTE *)(v2 + 272) |= 0x20u;
    nw_protocol_remove_instance(v2);
    uint64_t v5 = *(_BYTE **)(v2 + 128);
    uint64_t v4 = *(_BYTE **)(v2 + 136);
    os_log_type_t v6 = v4 - v5;
    if (v4 == v5)
    {
      uint64_t v7 = 0LL;
      os_log_type_t v10 = *(void *)(v2 + 152);
      if (!v10)
      {
LABEL_10:
        BOOL v11 = *(_BYTE *)(v2 + 272);
        *(_BYTE *)(v2 + 272) = v11 & 0xDF;
        if ((v11 & 4) == 0 && !*(void *)(v2 + 48) && *(void *)(v2 + 160) == *(void *)(v2 + 168)) {
          nw_http_messaging_destroy(v2);
        }
        if (v7) {
          operator delete(v7);
        }
        return;
      }
    }

    else
    {
      if (v6 < 0) {
        abort();
      }
      uint64_t v7 = (char *)operator new(v4 - v5);
      memcpy(v7, v5, v6);
      uint64_t v8 = 0LL;
      BOOL v9 = 8 * (v6 >> 3);
      do
      {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)&v7[v8] + 8LL))(*(void *)&v7[v8], v2, a2);
        v8 += 8LL;
      }

      while (v9 != v8);
      os_log_type_t v10 = *(void *)(v2 + 152);
      if (!v10) {
        goto LABEL_10;
      }
    }

    nw_protocol_remove_listen_handler(v10, v2 + 64);
    *(void *)(v2 + 152) = 0LL;
    goto LABEL_10;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v23 = "nw_protocol_http_messaging_teardown";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v20 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    char v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_http_messaging_teardown";
    os_log_type_t v15 = "%{public}s called with null http_messaging";
    goto LABEL_45;
  }

  if (!v20)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    char v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_http_messaging_teardown";
    os_log_type_t v15 = "%{public}s called with null http_messaging, backtrace limit exceeded";
    goto LABEL_45;
  }

  __int16 v18 = (char *)__nw_create_backtrace_string();
  uint64_t v13 = (os_log_s *)__nwlog_obj();
  char v14 = type;
  char v19 = os_log_type_enabled(v13, type);
  if (!v18)
  {
    if (!v19) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v23 = "nw_protocol_http_messaging_teardown";
    os_log_type_t v15 = "%{public}s called with null http_messaging, no backtrace";
    goto LABEL_45;
  }

  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v23 = "nw_protocol_http_messaging_teardown";
    uint64_t v24 = 2082;
    __int16 v25 = v18;
    _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null http_messaging, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v18);
  if (v12) {
LABEL_47:
  }
    free(v12);
}

      os_release(v10);
LABEL_46:
      if (v6) {
        os_release(v6);
      }
      if (!outbound_message) {
        return;
      }
      v53 = outbound_message;
      goto LABEL_77;
    case 3:
      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      v55 = *(void *)(a1 + 32);
      if (v55)
      {
        if (((*(unsigned __int16 *)(v55 + 188) | (*(unsigned __int8 *)(v55 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_30_44335);
          }
          unint64_t v30 = (os_log_s *)ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            v56 = *(void *)(a1 + 32);
            v57 = (const char *)(v56 + 191);
            v58 = "";
            v59 = v56 == 0;
            if (!v56) {
              v57 = "";
            }
            v62 = v56 + 176;
            v60 = *(_DWORD *)(v56 + 176);
            v61 = *(_DWORD *)(v62 + 4);
            if (!v59) {
              v58 = " ";
            }
            *(_DWORD *)buf = 136447490;
            v103 = "nw_http2_stream_connect_block_invoke";
            v104 = 2082;
            v105 = v57;
            v106 = 2080;
            v107 = v58;
            v108 = 1024;
            v109 = v61;
            v110 = 1024;
            LODWORD(v111[0]) = v60;
            WORD2(v111[0]) = 2048;
            *(void *)((char *)v111 + 6) = inbound_body_size;
            v38 = "%{public}s %{public}s%s<i%u:s%d> finished receiving {body_bytes=%llu}";
LABEL_60:
            _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_INFO, v38, buf, 0x36u);
          }
        }
      }

      else
      {
        v75 = *(void *)(a1 + 40);
        if (!v75 || (*(__int16 *)(v75 + 388) & 0x80000000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_30_44335);
          }
          v68 = (os_log_s *)ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            v76 = *(void *)(a1 + 40);
            v77 = (const char *)(v76 + 390);
            v78 = "";
            v79 = v76 == 0;
            v80 = *(_DWORD *)(v76 + 368);
            v103 = "nw_http2_stream_connect_block_invoke";
            if (v79) {
              v77 = "";
            }
            v104 = 2082;
            *(_DWORD *)buf = 136447234;
            if (!v79) {
              v78 = " ";
            }
            v105 = v77;
            v106 = 2080;
            v107 = v78;
            v108 = 1024;
            v109 = v80;
            v110 = 2048;
            v111[0] = inbound_body_size;
            v74 = "%{public}s %{public}s%s<i%u> finished receiving {body_bytes=%llu}";
LABEL_102:
            _os_log_impl(&dword_181A5C000, v68, OS_LOG_TYPE_INFO, v74, buf, 0x30u);
          }
        }
      }

      return;
    case 4:
      uint64_t v22 = MEMORY[0x1895F87A8];
      v96[0] = MEMORY[0x1895F87A8];
      v96[1] = 0x40000000LL;
      v96[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_39;
      v96[3] = &__block_descriptor_tmp_41_82735;
      v96[4] = a2;
      v97 = *(_OWORD *)(a1 + 32);
      __int16 v23 = nw_http_transaction_metadata_get_outbound_message(a2);
      uint64_t v24 = v23;
      if (v23)
      {
        __int16 v25 = nw_http_metadata_copy_request(v23);
        uint64_t v26 = nw_http_metadata_copy_response(v24);
        inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message) {
          goto LABEL_65;
        }
        if (v25)
        {
          if (v26) {
            goto LABEL_66;
          }
          goto LABEL_64;
        }
      }

      else
      {
        v63 = nw_http_transaction_metadata_get_inbound_message(a2);
        uint64_t v26 = 0LL;
        if (!v63)
        {
          v64 = 0;
          inbound_message = 0LL;
          goto LABEL_80;
        }

        inbound_message = v63;
      }

      __int16 v25 = nw_http_metadata_copy_request(inbound_message);
      if (v26) {
        goto LABEL_66;
      }
LABEL_64:
      uint64_t v26 = nw_http_metadata_copy_response(inbound_message);
LABEL_65:
      if (!v26)
      {
        v64 = 0;
        if (!v25) {
          goto LABEL_80;
        }
LABEL_69:
        v94[0] = v22;
        v94[1] = 0x40000000LL;
        v94[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_42;
        v94[3] = &unk_189BC7D20;
        v94[4] = v96;
        v95 = v64;
        v65 = v25;
        v66 = v94;
        _nw_http_request_access_method((uint64_t)v65, v66);

        if (!inbound_message) {
          goto LABEL_71;
        }
        goto LABEL_70;
      }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v21) {
LABEL_46:
  }
    free(v21);
LABEL_47:

LABEL_48:
  v39 = 0LL;
LABEL_59:

  return v39;
}

uint64_t __nw_dictionary_apply_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t pointer = xpc_dictionary_get_pointer();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 16))(v3, a2, pointer);
}

uint64_t __nw_channel_purge_idle_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (unsigned __int16 *)(a3 + 444);
  int v4 = *(unsigned __int16 *)(a3 + 444) | (*(unsigned __int8 *)(a3 + 446) << 16);
  if ((v4 & 0x60000) == 0 && *(void *)(a3 + 136))
  {
    *uint64_t v3 = *(_WORD *)(a3 + 444);
    *(_BYTE *)(a3 + 446) = BYTE2(v4) | 4;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v11 = 136446210;
      BOOL v12 = "nw_channel_purge_idle_block_invoke";
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s Purging channel packet pool after going idle",  (uint8_t *)&v11,  0xCu);
    }

    if (os_channel_packet_pool_purge())
    {
      uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (!v10)
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = nw_array_create();
        uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      }

      nw_array_append(v10, (void *)a3);
    }
  }

  unsigned int v8 = (*v3 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0xFFFDFFFF;
  *uint64_t v3 = *v3;
  *((_BYTE *)v3 + 2) = BYTE2(v8);
  return 1LL;
}

void nw_hash_table_apply(char *a1, uint64_t a2)
{
  uint64_t v156 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v147 = "nw_hash_table_apply";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v144 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v126 = (os_log_s *)__nwlog_obj();
      os_log_type_t v127 = type;
      if (!os_log_type_enabled(v126, type)) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null table";
      goto LABEL_208;
    }

    if (!v144)
    {
      v126 = (os_log_s *)__nwlog_obj();
      os_log_type_t v127 = type;
      if (!os_log_type_enabled(v126, type)) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null table, backtrace limit exceeded";
      goto LABEL_208;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v126 = (os_log_s *)__nwlog_obj();
    os_log_type_t v127 = type;
    BOOL v136 = os_log_type_enabled(v126, type);
    if (!backtrace_string)
    {
      if (!v136) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null table, no backtrace";
      goto LABEL_208;
    }

    if (v136)
    {
      *(_DWORD *)buf = 136446466;
      v147 = "nw_hash_table_apply";
      __int16 v148 = 2082;
      v149 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v126,  v127,  "%{public}s called with null table, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_209:
    if (!v3) {
      return;
    }
    goto LABEL_165;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v147 = "nw_hash_table_apply";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v144 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v126 = (os_log_s *)__nwlog_obj();
      os_log_type_t v127 = type;
      if (!os_log_type_enabled(v126, type)) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null apply_block";
      goto LABEL_208;
    }

    if (!v144)
    {
      v126 = (os_log_s *)__nwlog_obj();
      os_log_type_t v127 = type;
      if (!os_log_type_enabled(v126, type)) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null apply_block, backtrace limit exceeded";
      goto LABEL_208;
    }

    v137 = (char *)__nw_create_backtrace_string();
    v126 = (os_log_s *)__nwlog_obj();
    os_log_type_t v127 = type;
    BOOL v138 = os_log_type_enabled(v126, type);
    if (v137)
    {
      if (v138)
      {
        *(_DWORD *)buf = 136446466;
        v147 = "nw_hash_table_apply";
        __int16 v148 = 2082;
        v149 = v137;
        _os_log_impl( &dword_181A5C000,  v126,  v127,  "%{public}s called with null apply_block, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v137);
      if (!v3) {
        return;
      }
      goto LABEL_165;
    }

    if (v138)
    {
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null apply_block, no backtrace";
LABEL_208:
      _os_log_impl(&dword_181A5C000, v126, v127, v128, buf, 0xCu);
      goto LABEL_209;
    }

    goto LABEL_209;
  }

  uint64_t v3 = a1;
  if (*((_DWORD *)a1 + 8))
  {
    int v4 = *((_DWORD *)a1 + 12);
    if ((v4 & 2) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  v129 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v129, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v147 = "nw_hash_table_lock";
  v130 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v130))
  {
LABEL_218:
    __break(1u);
    return;
  }

  free(v130);
  int v4 = *((_DWORD *)v3 + 12);
  if ((v4 & 2) != 0)
  {
LABEL_5:
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 13);
    int v4 = *((_DWORD *)v3 + 12);
  }

LABEL_6:
  if ((v4 & 1) != 0)
  {
    uint64_t v5 = *((unsigned int *)v3 + 11) + 1LL;
    uint64_t v6 = v5 << 31 >> 31;
    *((_DWORD *)v3 + 11) = v5;
    if (v6 == v5 && (v6 & 0x8000000000000000LL) == 0)
    {
      if (!*((_DWORD *)v3 + 8)) {
        goto LABEL_139;
      }
LABEL_27:
      int v21 = 0;
      uint64_t v22 = v3 + 56;
      lock = (os_unfair_lock_s *)(v3 + 52);
      while (1)
      {
        int v141 = v21;
        __int16 v23 = (uint64_t *)*v22;
        if (*v22) {
          break;
        }
LABEL_28:
        int v21 = v141 + 1;
        v22 += 2;
      }

      v143 = v22;
      while (1)
      {
        uint64_t v24 = v23;
        __int16 v23 = (uint64_t *)*v23;
        __int16 v25 = (uint64_t **)v24[1];
        if (!v25 || *v25 != v24)
        {
          v101 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v101, OS_LOG_TYPE_ERROR);
          unint64_t v102 = *((unsigned __int8 *)v24 + 30);
          v103 = "invalid_state";
          if (v102 <= 3) {
            v103 = off_189BC49E0[v102];
          }
          int v104 = *((unsigned __int16 *)v24 + 14);
          *(_DWORD *)buf = 136446722;
          v147 = "nw_hash_table_apply";
          __int16 v148 = 2082;
          v149 = v103;
          __int16 v150 = 1024;
          LODWORD(v151) = v104;
          v105 = (void *)_os_log_send_and_compose_impl();
          free(v105);
        }

        int v26 = *((unsigned __int8 *)v24 + 30);
        if (v26 != 1)
        {
          if (v26 == 2)
          {
            if (*((_WORD *)v24 + 14))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v36 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446210;
                v147 = "nw_hash_table_apply";
                _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s Ignoring temp node remove",  buf,  0xCu);
              }
            }

            else
            {
              nw_hash_node_free((uint64_t)v22, v24);
            }
          }

          else
          {
            v106 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
            unint64_t v107 = *((unsigned __int8 *)v24 + 30);
            v108 = "invalid_state";
            if (v107 <= 3) {
              v108 = off_189BC49E0[v107];
            }
            int v109 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446722;
            v147 = "nw_hash_table_apply";
            __int16 v148 = 2082;
            v149 = v108;
            __int16 v150 = 1024;
            LODWORD(v151) = v109;
            v110 = (void *)_os_log_send_and_compose_impl();
            free(v110);
          }

          goto LABEL_32;
        }

        int v27 = (unsigned __int16)(*((_WORD *)v24 + 14))++ + 1;
        if ((v27 & 0x10000) != 0) {
          break;
        }
LABEL_59:
        if (!v23) {
          goto LABEL_78;
        }
        int v46 = (unsigned __int16)(*((_WORD *)v23 + 14))++ + 1;
        if ((v46 & 0x10000) == 0) {
          goto LABEL_78;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v47 = *((unsigned __int16 *)v23 + 14);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        __int16 v148 = 2082;
        v149 = "next_node->apply_count";
        __int16 v150 = 2048;
        uint64_t v151 = 1LL;
        __int16 v152 = 2048;
        uint64_t v153 = v47;
        v48 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v144 = 0;
        if (__nwlog_fault(v48, &type, &v144))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v49 = gLogObj;
            os_log_type_t v50 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v51 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "next_node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v51;
              v52 = (os_log_s *)v49;
              os_log_type_t v53 = v50;
              v54 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_74:
              _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0x2Au);
            }
          }

          else if (v144)
          {
            v55 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v56 = (os_log_s *)gLogObj;
            os_log_type_t v57 = type;
            BOOL v58 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v55)
            {
              if (v58)
              {
                uint64_t v59 = *((unsigned __int16 *)v23 + 14);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                __int16 v148 = 2082;
                v149 = "next_node->apply_count";
                __int16 v150 = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v59;
                __int16 v154 = 2082;
                v155 = v55;
                _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v55);
              goto LABEL_75;
            }

            if (v58)
            {
              uint64_t v63 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "next_node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v63;
              v52 = v56;
              os_log_type_t v53 = v57;
              v54 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_74;
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v60 = gLogObj;
            os_log_type_t v61 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v62 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "next_node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v62;
              v52 = (os_log_s *)v60;
              os_log_type_t v53 = v61;
              v54 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_74;
            }
          }
        }

  return a1;
}

  uint64_t v5 = 0LL;
LABEL_10:

  return v5;
}

    *(void *)(result + 8) = v5;
    goto LABEL_7;
  }

  int v4 = a3[4];
  uint64_t v5 = (void *)a3[5];
  uint64_t v3 = a3 + 4;
  if (!v4) {
    goto LABEL_6;
  }
  *(void *)(v4 + 40) = v5;
  uint64_t v5 = (void *)a3[5];
LABEL_7:
  *uint64_t v5 = v4;
  *uint64_t v3 = 0LL;
  v3[1] = 0LL;
  return result;
}

LABEL_7:
      if (!v4) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }

    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      uint64_t v28 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v35 = "-[NWConcrete_nw_endpoint_flow dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v28,  "%{public}s over-release of nw_endpoint_flow_t! Object should not be internally retained and deallocating, back trace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    os_log_type_t v20 = type;
    int v21 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v35 = "-[NWConcrete_nw_endpoint_flow dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v20,  "%{public}s over-release of nw_endpoint_flow_t! Object should not be internally retained and deallocating, no backtrace",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v35 = "-[NWConcrete_nw_endpoint_flow dealloc]";
      uint64_t v36 = 2082;
      v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v5,  v20,  "%{public}s over-release of nw_endpoint_flow_t! Object should not be internally retained and deallocating, dumpin g backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    if (v4) {
LABEL_8:
    }
      free(v4);
  }

LABEL_7:
      if (!v4) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }

    if (!v18)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      BOOL v16 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)int v21 = "-[NWConcrete_nw_connection dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v16,  "%{public}s over-release of nw_connection_t! Object should not be internally retained and deallocating, backtra ce limit exceeded",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    char v14 = type;
    os_log_type_t v15 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)int v21 = "-[NWConcrete_nw_connection dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s over-release of nw_connection_t! Object should not be internally retained and deallocating, no backtrace",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)int v21 = "-[NWConcrete_nw_connection dealloc]";
      *(_WORD *)&v21[8] = 2082;
      *(void *)&v21[10] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s over-release of nw_connection_t! Object should not be internally retained and deallocating, dumping b acktrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    if (v4) {
LABEL_8:
    }
      free(v4);
  }

    v2[148] &= ~1u;
    os_unfair_lock_lock((os_unfair_lock_t)(*((void *)v2 + 1) + 96LL));
    uint64_t v6 = *((void *)v2 + 1);
    uint64_t v7 = *(_DWORD *)(v6 + 100);
    if (v7)
    {
      *(_DWORD *)(v6 + 100) = v7 - 1;
      goto LABEL_42;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v48 = "nw_path_flow_registration_close";
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v45 = 0;
    if (__nwlog_fault((const char *)v9, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_path_flow_registration_close";
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s Path evaluator flow count unexpectedly 0 when closing flow",  buf,  0xCu);
        }
      }

      else if (v45)
      {
        uint64_t v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        uint64_t v18 = type;
        char v19 = os_log_type_enabled(v10, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v48 = "nw_path_flow_registration_close";
            uint64_t v49 = 2082;
            *(void *)os_log_type_t v50 = v17;
            _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s Path evaluator flow count unexpectedly 0 when closing flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v17);
          if (!v9) {
            goto LABEL_42;
          }
LABEL_41:
          free(v9);
LABEL_42:
          os_unfair_lock_unlock((os_unfair_lock_t)(*((void *)v2 + 1) + 96LL));
          int v26 = nw_parameters_copy_context(*(void **)(*((void *)v2 + 1) + 8LL));
          globals_for_path = nw_context_get_globals_for_path(v26);

          os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
          uint64_t v28 = *(void *)(globals_for_path + 40);
          if (v28)
          {
            node = nw_hash_table_get_node(v28, (uint64_t)(v2 + 32), 16LL);
            if (node) {
              nw_hash_table_remove_node(*(void *)(globals_for_path + 40), node);
            }
          }

          os_unfair_lock_unlock((os_unfair_lock_t)(globals_for_path + 124));
          goto LABEL_46;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_path_flow_registration_close";
          _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s Path evaluator flow count unexpectedly 0 when closing flow, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        __int16 v25 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_path_flow_registration_close";
          _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s Path evaluator flow count unexpectedly 0 when closing flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }

  __nwlog_obj();
  unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v48 = "nw_path_flow_registration_close";
  uint64_t v32 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v45 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v36 = type;
    if (os_log_type_enabled(v33, type))
    {
      *(_DWORD *)buf = 136446210;
      v48 = "nw_path_flow_registration_close";
      _os_log_impl(&dword_181A5C000, v33, v36, "%{public}s called with null registration->parent_evaluator", buf, 0xCu);
    }

    goto LABEL_87;
  }

  if (!v45)
  {
    __nwlog_obj();
    v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v44 = type;
    if (os_log_type_enabled(v33, type))
    {
      *(_DWORD *)buf = 136446210;
      v48 = "nw_path_flow_registration_close";
      _os_log_impl( &dword_181A5C000,  v33,  v44,  "%{public}s called with null registration->parent_evaluator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_87;
  }

  BOOL v40 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v41 = type;
  uint64_t v42 = os_log_type_enabled(v33, type);
  if (!v40)
  {
    if (v42)
    {
      *(_DWORD *)buf = 136446210;
      v48 = "nw_path_flow_registration_close";
      _os_log_impl( &dword_181A5C000,  v33,  v41,  "%{public}s called with null registration->parent_evaluator, no backtrace",  buf,  0xCu);
    }

    goto LABEL_87;
  }

  if (v42)
  {
    *(_DWORD *)buf = 136446466;
    v48 = "nw_path_flow_registration_close";
    uint64_t v49 = 2082;
    *(void *)os_log_type_t v50 = v40;
    _os_log_impl( &dword_181A5C000,  v33,  v41,  "%{public}s called with null registration->parent_evaluator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v40);
  if (v32) {
    goto LABEL_89;
  }
LABEL_46:
}

        uint64_t v66 = __clz(__rbit64(v60));
        v60 &= v60 - 1;
      }
    }

    uint64_t v70 = v61 + 1;
    if (v61 + 1 < v117)
    {
      os_log_type_t v69 = *(void *)(v116 + 8 * v70);
      if (v69) {
        goto LABEL_16;
      }
      uint64_t v70 = v61 + 2;
      if (v61 + 2 < v117)
      {
        os_log_type_t v69 = *(void *)(v116 + 8 * v70);
        if (!v69)
        {
          uint64_t v70 = v61 + 3;
          if (v61 + 3 < v117)
          {
            os_log_type_t v69 = *(void *)(v116 + 8 * v70);
            if (v69) {
              goto LABEL_16;
            }
            while (1)
            {
              os_log_type_t v61 = v70 + 1;
              if (__OFADD__(v70, 1LL)) {
                goto LABEL_48;
              }
              if (v61 >= v117) {
                goto LABEL_26;
              }
              os_log_type_t v69 = *(void *)(v116 + 8 * v61);
              ++v70;
              if (v69) {
                goto LABEL_17;
              }
            }
          }

          goto LABEL_26;
        }

  if ((a3 & 0xC) == v13)
  {
    BOOL result = sub_181C23710(a3, a4, a5);
    a3 = result;
    if ((a5 & 0x1000000000000000LL) == 0) {
      goto LABEL_8;
    }
  }

  else if ((a5 & 0x1000000000000000LL) == 0)
  {
LABEL_8:
    BOOL result = (a3 >> 16) - (v10 >> 16);
    goto LABEL_21;
  }

  uint64_t v17 = HIBYTE(a5) & 0xF;
  if ((a5 & 0x2000000000000000LL) == 0) {
    uint64_t v17 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v17 < v10 >> 16) {
    goto LABEL_100;
  }
  if (v17 < a3 >> 16)
  {
LABEL_101:
    __break(1u);
    goto LABEL_102;
  }

  BOOL result = sub_18264EBBC();
LABEL_21:
  uint64_t v18 = v15 + result;
  if (__OFADD__(v15, result))
  {
    __break(1u);
    goto LABEL_99;
  }

  if (v18 < v15)
  {
LABEL_99:
    __break(1u);
LABEL_100:
    __break(1u);
    goto LABEL_101;
  }

  char v19 = (unsigned __int8 *)(v11 + v15);
  if (!v11) {
    char v19 = 0LL;
  }
  os_log_type_t v20 = *v19;
  if (v20 == 43)
  {
    if (result >= 1)
    {
      if (result != 1)
      {
        os_log_type_t v31 = a6 + 87;
        if (a6 > 10)
        {
          uint64_t v32 = a6 + 55;
        }

        else
        {
          os_log_type_t v31 = 97;
          uint64_t v32 = 65;
        }

        if (a6 <= 10) {
          v33 = a6 + 48;
        }
        else {
          v33 = 58;
        }
        if (v19)
        {
          LOBYTE(v24) = 0;
          os_log_type_t v34 = v19 + 1;
          unint64_t v35 = result - 1;
          do
          {
            uint64_t v36 = *v34;
            if (v36 < 0x30 || v36 >= v33)
            {
              if (v36 < 0x41 || v36 >= v32)
              {
                unint64_t v29 = 0;
                uint64_t v30 = 1;
                if (v36 < 0x61 || v36 >= v31) {
                  return v29 | (v30 << 8);
                }
                v37 = -87;
              }

              else
              {
                v37 = -55;
              }
            }

            else
            {
              v37 = -48;
            }

            uint64_t v24 = (v24 * a6) + (v36 + v37);
            if (((v24 >> 8) & 1) != 0) {
              goto LABEL_96;
            }
            ++v34;
            --v35;
          }

          while (v35);
LABEL_72:
          uint64_t v30 = 0;
          unint64_t v29 = v24;
          return v29 | (v30 << 8);
        }

        goto LABEL_95;
      }

          uint64_t v11 = __clz(__rbit64(v7));
          v7 &= v7 - 1;
        }
      }

      os_log_type_t v15 = v13 + 3;
      if (v15 < v8)
      {
        char v14 = *(void *)(v18 + 8 * v15);
        if (v14)
        {
          os_log_type_t v10 = v15;
          goto LABEL_20;
        }

        while (1)
        {
          os_log_type_t v10 = v15 + 1;
          if (__OFADD__(v15, 1LL)) {
            goto LABEL_26;
          }
          if (v10 >= v8) {
            return swift_release();
          }
          char v14 = *(void *)(v18 + 8 * v10);
          ++v15;
          if (v14) {
            goto LABEL_20;
          }
        }
      }
    }

    return swift_release();
  }

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

    if (!v5) {
LABEL_7:
    }
      *((_BYTE *)handle + 150) = 5;
    return (*(uint64_t (**)(void))(*(void *)(handle[4] + 24LL) + 96LL))();
  }

  return 0LL;
}

LABEL_7:
      uint64_t v11 = 0xFFFFFFFFLL;
LABEL_17:
      BOOL v136 = v11;
      goto LABEL_145;
    }

    goto LABEL_33;
  }

  if ((v7 & 2) != 0)
  {
    uint64_t v11 = 2LL;
    goto LABEL_17;
  }

  if (!*(void *)(v6 + 72))
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 72LL) = CFHTTPMessageCreateEmpty( (CFAllocatorRef)*MEMORY[0x189604DB0],  (v7 & 4) != 0);
    uint64_t v5 = *(void *)(a1 + 40);
    if (!*(void *)(*(void *)(v5 + 8) + 72LL))
    {
      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 12);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v17;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s CFHTTPMessageCreateEmpty",  buf,  0x16u);
      }

      goto LABEL_6;
    }
  }

  v134 = v4;
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  v158[0] = 0;
  *(void *)os_log_type_t type = 0LL;
  __int16 v148 = type;
  v149 = 0x2020000000LL;
  __int16 v150 = 0LL;
  BOOL v12 = *(void **)(a1 + 32);
  parse[0] = MEMORY[0x1895F87A8];
  parse[1] = 3221225472LL;
  parse[2] = __nw_protocol_copy_ws_definition_block_invoke_7;
  parse[3] = &unk_189BB64F0;
  char v144 = v5;
  v143 = v12;
  v145 = type;
  v146 = buf;
  nw_framer_parse_input(v143, 1uLL, 0xFFFFFFFFuLL, 0LL, parse);
  if (!*(_BYTE *)(*(void *)&buf[8] + 24LL))
  {
    char v14 = 0;
    os_log_type_t v15 = 1LL;
LABEL_22:
    BOOL v136 = v15;
    goto LABEL_32;
  }

  uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 8LL) + 48LL;
  if ((*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 273LL) & 4) != 0)
  {
    if ((nw_ws_validate_client_request(v13, *(void **)(a1 + 32)) & 1) != 0)
    {
      BOOL v16 = (_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 273LL);
      *v16 |= 2u;
      nw_ws_present_request_to_user(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL, *(void **)(a1 + 32));
      char v14 = 0;
LABEL_21:
      os_log_type_t v15 = 2LL;
      goto LABEL_22;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v21 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
      *(_DWORD *)uint64_t v151 = 136446466;
      __int16 v152 = "nw_protocol_copy_ws_definition_block_invoke";
      uint64_t v153 = 2082;
      __int16 v154 = v21;
      os_log_type_t v20 = "%{public}s %{public}s nw_ws_validate_client request";
      goto LABEL_30;
    }
  }

  else
  {
    if ((nw_ws_validate_server_response(v13) & 1) != 0)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v131 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
        {
          v132 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
          if ((*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 273LL) & 4) != 0) {
            os_log_type_t v133 = "server";
          }
          else {
            os_log_type_t v133 = "client";
          }
          *(_DWORD *)uint64_t v151 = 136446722;
          __int16 v152 = "nw_protocol_copy_ws_definition_block_invoke";
          uint64_t v153 = 2082;
          __int16 v154 = v132;
          v155 = 2082;
          uint64_t v156 = v133;
          _os_log_impl( &dword_181A5C000,  v131,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s %{public}s handshake complete",  v151,  0x20u);
        }
      }

      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 228LL) = 2;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 236LL) = 2;
      nw_framer_mark_ready(*(nw_framer_t *)(a1 + 32));
      char v14 = *((void *)v148 + 3) != 0LL;
      goto LABEL_21;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      char v19 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
      *(_DWORD *)uint64_t v151 = 136446466;
      __int16 v152 = "nw_protocol_copy_ws_definition_block_invoke";
      uint64_t v153 = 2082;
      __int16 v154 = v19;
      os_log_type_t v20 = "%{public}s %{public}s nw_ws_validate_server_response";
LABEL_30:
      _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_ERROR, v20, v151, 0x16u);
    }
  }

  nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 53);
  char v14 = 0;
  BOOL v136 = 0LL;
LABEL_32:

  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  int v4 = v134;
  if (!v14) {
    goto LABEL_145;
  }
LABEL_33:
  uint64_t v22 = &qword_18C45F000;
  v135 = v4;
  BOOL v136 = 2LL;
  __int16 v23 = MEMORY[0x1895F87A8];
  while (1)
  {
    uint64_t v24 = *(void *)(a1 + 40);
    __int16 v25 = *(void *)(v24 + 8);
    int v26 = *(_DWORD *)(v25 + 228);
    if (v26 != 2) {
      goto LABEL_40;
    }
    if (*((_BYTE *)v22 + 1537))
    {
      __nwlog_obj();
      v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v72 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v72;
        _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s input nw_ws_parse_state_header",  buf,  0x16u);
      }

      __int16 v25 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v22 = &qword_18C45F000;
    }

    if (!nw_framer_parse_input( *(nw_framer_t *)(a1 + 32),  2uLL,  2uLL,  (uint8_t *)(v25 + 264),  &__block_literal_global_12_3686)) {
      goto LABEL_144;
    }
    *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 273LL) = *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                           + 273LL) & 0xFDFF | (*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 264LL) >> 5) & 0x200;
    int v27 = *(void *)(*(void *)(a1 + 40) + 8LL);
    if ((*(_WORD *)(v27 + 264) & 0x3000) != 0) {
      break;
    }
    *(_WORD *)(v27 + 273) = *(_WORD *)(v27 + 273) & 0xFFF7 | (*(_WORD *)(v27 + 264) >> 12) & 8;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 232LL) = *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                            + 265LL) & 0xF;
    uint64_t v28 = *(void *)(*(void *)(a1 + 40) + 8LL);
    unint64_t v29 = nw_ws_validate_frame( (nw_ws_state_t *)(v28 + 48),  (*(unsigned __int16 *)(v28 + 273) >> 3) & 1,  (*(unsigned __int16 *)(v28 + 273) >> 9) & 1,  *(_DWORD *)(v28 + 232),  (*(unsigned __int16 *)(v28 + 264) >> 7) & 1,  *(_WORD *)(v28 + 264) & 0x7F,  1);
    uint64_t v30 = *(void *)(*(void *)(a1 + 40) + 8LL);
    if ((v29 & 1) == 0)
    {
      nw_ws_write_header(v30 + 48, *(void **)(a1 + 32), 8, 0x3EAu, 0LL, 0, 1);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v96 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v98 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v98;
        _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s input nw_ws_validate_server_response",  buf,  0x16u);
      }

      goto LABEL_133;
    }

    *(_DWORD *)(v30 + 228) = 3;
    uint64_t v24 = *(void *)(a1 + 40);
    int v26 = *(_DWORD *)(*(void *)(v24 + 8) + 228LL);
LABEL_40:
    if (v26 == 3)
    {
      if (*((_BYTE *)v22 + 1537))
      {
        __nwlog_obj();
        v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
        {
          v74 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v74;
          _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s input nw_ws_parse_state_payload_length",  buf,  0x16u);
        }

        uint64_t v24 = *(void *)(a1 + 40);
        uint64_t v22 = &qword_18C45F000;
      }

      *(void *)(*(void *)(v24 + 8) + 160LL) = 0LL;
      os_log_type_t v31 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v32 = *(_WORD *)(v31 + 264) & 0x7F;
      if ((_DWORD)v32 == 126)
      {
        if (!nw_framer_parse_input( *(nw_framer_t *)(a1 + 32),  2uLL,  2uLL,  (uint8_t *)(v31 + 266),  &__block_literal_global_17)) {
          goto LABEL_144;
        }
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 160LL) = bswap32(*(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 266LL)) >> 16;
        if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 160LL) < 0x7EuLL)
        {
          __nwlog_obj();
          v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
          {
            uint64_t v114 = *(void *)(*(void *)(a1 + 40) + 8LL);
            v115 = v114 + 275;
            v116 = *(void *)(v114 + 160);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v115;
            *(_WORD *)&buf[22] = 2048;
            *(void *)v158 = v116;
            v111 = "%{public}s %{public}s expected a payload length of greater than 125, but received %zu";
            v112 = v101;
            int v113 = 32;
LABEL_150:
            _os_log_impl(&dword_181A5C000, v112, OS_LOG_TYPE_ERROR, v111, buf, v113);
          }

    uint64_t v13 = 0;
    goto LABEL_17;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  os_log_type_t v50 = input_length;
  if (input_length)
  {
    *((void *)v7 + 63) = input_length;
    objc_storeStrong((id *)v7 + 48, message);
    if (v4) {
      char v14 = 8;
    }
    else {
      char v14 = 0;
    }
    *((_BYTE *)v7 + 607) = *((_BYTE *)v7 + 607) & 0xF7 | v14;
    v40[0] = MEMORY[0x1895F87A8];
    v40[1] = 3221225472LL;
    uint64_t v41 = __nw_framer_deliver_input_no_copy_block_invoke;
    uint64_t v42 = &unk_189BB6770;
    uint64_t v45 = buf;
    os_log_type_t v43 = v7;
    uint64_t v44 = v10;
    int v46 = v4;
    os_log_type_t v15 = *((void *)v7 + 64);
    do
    {
      if (!v15) {
        break;
      }
      BOOL v16 = *(void *)(v15 + 32);
      uint64_t v17 = ((uint64_t (*)(void *))v41)(v40);
      os_log_type_t v15 = v16;
    }

    while ((v17 & 1) != 0);
    uint64_t v13 = *((void *)v7 + 63) == 0LL;

    frame = (uint64_t)v43;
  }

  else
  {
    frame = nw_framer_protocol_create_frame( v7,  0,  (uint64_t)nw_framer_protocol_inbound_data_finalizer,  (uint64_t)v7 + 464,  0);
    uint64_t v13 = 1;
    nw_frame_set_metadata(frame, (nw_protocol_metadata *)v10, 1, v4);
    *(void *)(frame + 32) = 0LL;
    char v19 = (uint64_t *)*((void *)v7 + 67);
    *(void *)(frame + 40) = v19;
    *char v19 = frame;
    *((void *)v7 + 67) = frame + 32;
    ++*((_DWORD *)v7 + 136);
  }

  _Block_object_dispose(buf, 8);
LABEL_17:

  return v13;
}
}

  if (object_getClass(v2) != v4)
  {
LABEL_7:
    uint64_t v7 = 0LL;
    goto LABEL_8;
  }

  BOOL v16 = xpc_dictionary_get_value(v2, "proxied_next_hop_endpoints");
  uint64_t v7 = v16;
  if (v16)
  {
    if (object_getClass(v16) != (Class)MEMORY[0x1895F9220]) {
      goto LABEL_7;
    }
    uint64_t v7 = xpc_retain(v7);
    if (v7)
    {
      uint64_t v17 = nw_array_create();
      proxied_next_hop_endpoints = v5->proxied_next_hop_endpoints;
      v5->proxied_next_hop_endpoints = (OS_nw_array *)v17;

      v52[0] = MEMORY[0x1895F87A8];
      v52[1] = 3221225472LL;
      v52[2] = __nw_establishment_report_create_from_dictionary_block_invoke_2;
      v52[3] = &unk_189BC8CB8;
      os_log_type_t v53 = v5;
      xpc_array_apply(v7, v52);
    }
  }

      int v4 = 0LL;
LABEL_7:
      if ((SBYTE5(v2->flow_in_connected) & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = (char *)&v2->flow_in_connected + 7;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v78 = " ";
          _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sExisting paths:", buf, 0x20u);
        }
      }

      flow_registration = (char *)v2->flow_registration;
      uint64_t v7 = MEMORY[0x1895F87A8];
      v75[0] = MEMORY[0x1895F87A8];
      v75[1] = 3221225472LL;
      v75[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke;
      v75[3] = &unk_189BC86F0;
      unsigned int v8 = v2;
      os_log_type_t v76 = v8;
      nw_hash_table_apply(flow_registration, (uint64_t)v75);
      uint64_t v9 = v8[36];
      if (v9)
      {
        if ((SBYTE5(v2->flow_in_connected) & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v10 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = (char *)v8 + 407;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v78 = " ";
            _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sInterface options:",  buf,  0x20u);
          }

          uint64_t v9 = v8[36];
        }

        v73[0] = v7;
        v73[1] = 3221225472LL;
        v73[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_254;
        v73[3] = &unk_189BB7710;
        v74 = v8;
        nw_path_enumerate_interface_options(v9, v73);
      }

      uint64_t v11 = xpc_array_create(0LL, 0LL);
      BOOL v12 = v8[36];
      if (v12)
      {
        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2020000000LL;
        uint64_t v78 = 0LL;
        __buf[0] = 0LL;
        __buf[1] = (uint64_t)__buf;
        __buf[2] = 0x2020000000LL;
        os_log_type_t v72 = 1;
        v69[0] = 0LL;
        v69[1] = v69;
        v69[2] = 0x2020000000LL;
        uint64_t v70 = 0;
        uint64_t v13 = v12;
        char v14 = v13[3];

        os_log_type_t v15 = v8[36];
        v62[0] = v7;
        v62[1] = 3221225472LL;
        v62[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_256;
        v62[3] = &unk_189BB7738;
        uint64_t v63 = v8;
        char v64 = v14;
        unsigned int v65 = v11;
        uint64_t v66 = __buf;
        v67 = buf;
        uint64_t v68 = v69;
        BOOL v16 = v14;
        nw_path_enumerate_interface_options_with_details(v15, v62);

        _Block_object_dispose(v69, 8);
        _Block_object_dispose(__buf, 8);
        _Block_object_dispose(buf, 8);
      }

      uint64_t v17 = xpc_array_create(0LL, 0LL);
      if (v8[36])
      {
        uint64_t v18 = (char *)v2->flow_registration;
        v59[0] = v7;
        v59[1] = 3221225472LL;
        v59[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_259;
        v59[3] = &unk_189BB7560;
        uint64_t v60 = v8;
        os_log_type_t v61 = v17;
        nw_hash_table_apply(v18, (uint64_t)v59);
      }

      if (v4) {
        ((void (*)(void **, uint64_t, uint64_t, BOOL))v2->parent_definition->extended_state->var26)( v8,  v4,  3LL,  v4 == (void)v8[39]);
      }
      applier[0] = v7;
      applier[1] = 3221225472LL;
      applier[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_260;
      applier[3] = &unk_189BB7788;
      BOOL v58 = v4;
      char v19 = v8;
      os_log_type_t v57 = v19;
      xpc_array_apply(v11, applier);
      if (xpc_array_get_count(v17))
      {
        v53[0] = v7;
        v53[1] = 3221225472LL;
        v53[2] = ___ZL43nw_protocol_instance_update_available_pathsP31NWConcrete_nw_protocol_instance_block_invoke_2_261;
        v53[3] = &unk_189BC9238;
        v54 = v17;
        v55 = v19;
        nw_protocol_instance_async(v55, v53);
      }

      should_fallback = nw_path_should_fallback(v8[36], 1);
      is_weak = nw_path_fallback_is_weak(v8[36]);
      uint64_t v22 = is_weak;
      __int16 v23 = BYTE5(v2->flow_in_connected);
      if (should_fallback == ((v23 & 0x10) == 0) || ((is_weak ^ ((v23 & 0x20) == 0)) & 1) == 0)
      {
        if (should_fallback) {
          uint64_t v24 = 16;
        }
        else {
          uint64_t v24 = 0;
        }
        __int16 v25 = v23 & 0xCF;
        if ((_DWORD)is_weak) {
          int v26 = 32;
        }
        else {
          int v26 = 0;
        }
        BYTE5(v2->flow_in_connected) = v26 | v24 | v25;
        fallback_interface_index = nw_path_get_fallback_interface_index((uint64_t)v8[36]);
        if (nw_context_copy_implicit_context::onceToken != -1) {
          dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
        }
        uint64_t v28 = (id)nw_context_copy_implicit_context::implicit_context;
        unint64_t v29 = nw_path_copy_interface_with_generation(v28, fallback_interface_index, 0);

        if (v29)
        {
          var27 = (void (*)(void **, NWConcrete_nw_interface *, BOOL, uint64_t))v2->parent_definition->extended_state->var27;
          if (var27) {
            var27(v19, v29, should_fallback, v22);
          }
        }
      }

      goto LABEL_41;
    }

    v2->flow_registration = 0LL;
    __nwlog_obj();
    os_log_type_t v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
    BOOL v40 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__buf[0]) = 16;
    LOBYTE(v69[0]) = 0;
    if (LOBYTE(__buf[0]) == 17)
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v42 = __buf[0];
      if (os_log_type_enabled(v41, __buf[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
        _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s nw_hash_table_create_no_lock failed", buf, 0xCu);
      }
    }

    else if (LOBYTE(v69[0]))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v44 = __buf[0];
      uint64_t v45 = os_log_type_enabled(v41, __buf[0]);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v41,  v44,  "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_70;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
        _os_log_impl( &dword_181A5C000,  v41,  v44,  "%{public}s nw_hash_table_create_no_lock failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v47 = __buf[0];
      if (os_log_type_enabled(v41, __buf[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_update_available_paths";
        _os_log_impl( &dword_181A5C000,  v41,  v47,  "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_70:
    if (v40) {
      free(v40);
    }
  }

LABEL_7:
      if (!v4) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }

    if (!v24)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      char v19 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "-[NWConcrete_nw_listener dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v19,  "%{public}s over-release of nw_listener_t! Object should not be internally retained and deallocating, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    char v14 = type;
    os_log_type_t v15 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        int v27 = "-[NWConcrete_nw_listener dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s over-release of nw_listener_t! Object should not be internally retained and deallocating, no backtrace",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      int v27 = "-[NWConcrete_nw_listener dealloc]";
      uint64_t v28 = 2082;
      unint64_t v29 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s over-release of nw_listener_t! Object should not be internally retained and deallocating, dumping bac ktrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    if (v4) {
LABEL_8:
    }
      free(v4);
  }

  return a1;
}

  return 0LL;
}

  return 0LL;
}

      uint64_t v9 = *((id *)v4 + 8);
      goto LABEL_7;
    }

    __nwlog_obj();
    unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_endpoint_flow_copy_flow_path";
    uint64_t v36 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v45 = 0;
    if (__nwlog_fault(v36, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_endpoint_flow_copy_flow_path";
          _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v45)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v40 = type;
        uint64_t v41 = os_log_type_enabled(v37, type);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            v48 = "nw_endpoint_flow_copy_flow_path";
            uint64_t v49 = 2082;
            os_log_type_t v50 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v37,  v40,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }

        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_endpoint_flow_copy_flow_path";
          _os_log_impl(&dword_181A5C000, v37, v40, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v42 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_endpoint_flow_copy_flow_path";
          _os_log_impl( &dword_181A5C000,  v37,  v42,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  nw_protocol_remove_instance(a1);
  int v4 = *(void *)(a1 + 352);
  if (v4)
  {
    nw_queue_cancel_source(v4, v3);
    *(void *)(a1 + 352) = 0LL;
  }

  uint64_t v5 = *(void *)(a1 + 256);
  if (v5)
  {
    do
    {
      uint64_t v6 = *(void *)(v5 + 16);
      nw_frame_finalize(v5);
      uint64_t v5 = v6;
    }

    while (v6);
  }

  uint64_t v7 = *(char **)(a1 + 480);
  unsigned int v8 = MEMORY[0x1895F87A8];
  if (v7)
  {
    v35[0] = MEMORY[0x1895F87A8];
    v35[1] = 0x40000000LL;
    v35[2] = ___ZL26nw_masque_protocol_destroyP9nw_masque_block_invoke_2;
    v35[3] = &__block_descriptor_tmp_55_27997;
    v35[4] = a1;
    nw_hash_table_apply(v7, (uint64_t)v35);
    os_log_type_t v10 = *(os_unfair_lock_s **)(a1 + 480);
    if (v10)
    {
      _nw_hash_table_release(v10, v9);
      *(void *)(a1 + 480) = 0LL;
    }
  }

  uint64_t v11 = *(void *)(a1 + 464);
  if (v11)
  {
    *(void *)buf = v8;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL32nw_masque_listener_set_callbacksP20nw_protocol_metadataPv_block_invoke;
    v37 = (const char *)&__block_descriptor_tmp_56;
    v38 = 0LL;
    BOOL v12 = *(void *)(v11 + 32);
    if (v12) {
      ___ZL32nw_masque_listener_set_callbacksP20nw_protocol_metadataPv_block_invoke((uint64_t)buf, v12);
    }
  }

  uint64_t v13 = *(void **)(a1 + 472);
  if (v13)
  {
    *(void *)buf = v8;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL23nw_masque_set_callbacksP20nw_protocol_metadataPv_block_invoke;
    v37 = (const char *)&__block_descriptor_tmp_192;
    v38 = 0LL;
    char v14 = v13[4];
    if (!v14
      || (___ZL23nw_masque_set_callbacksP20nw_protocol_metadataPv_block_invoke((uint64_t)buf, v14),
          (uint64_t v13 = *(void **)(a1 + 472)) != 0LL))
    {
      os_release(v13);
      *(void *)(a1 + 472) = 0LL;
    }
  }

  os_log_type_t v15 = *(void **)(a1 + 488);
  if (v15)
  {
    os_release(v15);
    *(void *)(a1 + 488) = 0LL;
  }

  BOOL v16 = *(void **)(a1 + 464);
  if (v16)
  {
    os_release(v16);
    *(void *)(a1 + 464) = 0LL;
  }

  uint64_t v17 = *(void **)(a1 + 304);
  if (v17)
  {
    os_release(v17);
    *(void *)(a1 + 304) = 0LL;
  }

  uint64_t v18 = *(void **)(a1 + 312);
  if (v18)
  {
    os_release(v18);
    *(void *)(a1 + 312) = 0LL;
  }

  char v19 = *(void **)(a1 + 320);
  if (v19)
  {
    os_release(v19);
    *(void *)(a1 + 320) = 0LL;
  }

  os_log_type_t v20 = *(void **)(a1 + 328);
  if (v20)
  {
    os_release(v20);
    *(void *)(a1 + 328) = 0LL;
  }

  int v21 = *(void **)(a1 + 336);
  if (v21)
  {
    os_release(v21);
    *(void *)(a1 + 336) = 0LL;
  }

  uint64_t v22 = *(void **)(a1 + 344);
  if (v22)
  {
    os_release(v22);
    *(void *)(a1 + 344) = 0LL;
  }

  __int16 v23 = *(void **)(a1 + 424);
  if (v23)
  {
    os_release(v23);
    *(void *)(a1 + 424) = 0LL;
  }

  uint64_t v24 = *(void **)(a1 + 416);
  if (v24)
  {
    os_release(v24);
    *(void *)(a1 + 416) = 0LL;
  }

  __int16 v25 = *(void **)(a1 + 456);
  if (v25)
  {
    os_release(v25);
    *(void *)(a1 + 456) = 0LL;
  }

  int v26 = *(void **)(a1 + 360);
  if (v26)
  {
    os_release(v26);
    *(void *)(a1 + 360) = 0LL;
  }

  int v27 = *(void **)(a1 + 368);
  if (v27)
  {
    os_release(v27);
    *(void *)(a1 + 368) = 0LL;
  }

  uint64_t v28 = *(void **)(a1 + 376);
  if (v28)
  {
    os_release(v28);
    *(void *)(a1 + 376) = 0LL;
  }

  unint64_t v29 = *(dispatch_object_s **)(a1 + 384);
  if (v29)
  {
    dispatch_release(v29);
    *(void *)(a1 + 384) = 0LL;
  }

  uint64_t v30 = *(dispatch_object_s **)(a1 + 392);
  if (v30)
  {
    dispatch_release(v30);
    *(void *)(a1 + 392) = 0LL;
  }

  os_log_type_t v31 = *(dispatch_object_s **)(a1 + 400);
  if (v31)
  {
    dispatch_release(v31);
    *(void *)(a1 + 400) = 0LL;
  }

  uint64_t v32 = *(dispatch_object_s **)(a1 + 408);
  if (v32)
  {
    dispatch_release(v32);
    *(void *)(a1 + 408) = 0LL;
  }

  (*(void (**)(void, void))(*(void *)(a1 + 496) + 16LL))(*(void *)(a1 + 496), 0LL);
  v33 = *(const void **)(a1 + 496);
  if (v33) {
    _Block_release(v33);
  }
  free((void *)a1);
}

  id v2 = MEMORY[0x1895F87A8];
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33155;
  v48 = (const char *)&__block_descriptor_tmp_56_33156;
  uint64_t v49 = 0;
  uint64_t v3 = *(void *)(v1 + 560);
  do
  {
    if (!v3) {
      break;
    }
    int v4 = *(void *)(v3 + 16);
    uint64_t v5 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    uint64_t v3 = v4;
  }

  while ((v5 & 1) != 0);
  if (!*(void *)(v1 + 560)) {
    goto LABEL_10;
  }
  __nwlog_obj();
  *(_DWORD *)os_log_type_t v43 = 136446210;
  uint64_t v44 = "nw_protocol_finalize_master_frame_array";
  uint64_t v18 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v41 = 0;
  if (__nwlog_fault(v18, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_85;
      }
      *(_DWORD *)os_log_type_t v43 = 136446210;
      uint64_t v44 = "nw_protocol_finalize_master_frame_array";
      int v21 = "%{public}s frame array is not empty after finalize";
      goto LABEL_84;
    }

    if (!v41)
    {
      char v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_85;
      }
      *(_DWORD *)os_log_type_t v43 = 136446210;
      uint64_t v44 = "nw_protocol_finalize_master_frame_array";
      int v21 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
      goto LABEL_84;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v19 = (os_log_s *)__nwlog_obj();
    os_log_type_t v20 = type;
    uint64_t v36 = os_log_type_enabled(v19, type);
    if (backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)os_log_type_t v43 = 136446466;
        uint64_t v44 = "nw_protocol_finalize_master_frame_array";
        uint64_t v45 = 2082;
        int v46 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s",  v43,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_85;
    }

    if (v36)
    {
      *(_DWORD *)os_log_type_t v43 = 136446210;
      uint64_t v44 = "nw_protocol_finalize_master_frame_array";
      int v21 = "%{public}s frame array is not empty after finalize, no backtrace";
LABEL_84:
      _os_log_impl(&dword_181A5C000, v19, v20, v21, v43, 0xCu);
    }
  }

  uint64_t v7 = nw_hash_table_add_object(internal, a2, (char *)&v38);
  if (v38 == OS_LOG_TYPE_DEFAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (char *)(a1 + 205);
    os_log_type_t v10 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)buf = 136446722;
    BOOL v40 = "nw_http2_transport_add_to_id_table";
    uint64_t v41 = 2082;
    uint64_t v42 = (char *)(a1 + 205);
    os_log_type_t v43 = 1024;
    *(_DWORD *)uint64_t v44 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_35;
      }
      char v14 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)buf = 136446722;
      BOOL v40 = "nw_http2_transport_add_to_id_table";
      uint64_t v41 = 2082;
      uint64_t v42 = v9;
      os_log_type_t v43 = 1024;
      *(_DWORD *)uint64_t v44 = v14;
      os_log_type_t v15 = "%{public}s %{public}s http2_transport already has stream id registered for %d";
    }

    else if (v36)
    {
      BOOL v16 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = type;
      uint64_t v17 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v16)
      {
        if (v17)
        {
          uint64_t v18 = *(_DWORD *)(a2 + 32);
          *(_DWORD *)buf = 136446978;
          BOOL v40 = "nw_http2_transport_add_to_id_table";
          uint64_t v41 = 2082;
          uint64_t v42 = v9;
          os_log_type_t v43 = 1024;
          *(_DWORD *)uint64_t v44 = v18;
          *(_WORD *)&v44[4] = 2082;
          *(void *)&v44[6] = v16;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s %{public}s http2_transport already has stream id registered for %d, dumping backtrace:%{public}s",  buf,  0x26u);
        }

        free(v16);
LABEL_35:
        if (v11)
        {
          uint64_t v28 = (char *)v11;
LABEL_44:
          free(v28);
          return 0LL;
        }

        return 0LL;
      }

      if (!v17) {
        goto LABEL_35;
      }
      int v27 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)buf = 136446722;
      BOOL v40 = "nw_http2_transport_add_to_id_table";
      uint64_t v41 = 2082;
      uint64_t v42 = v9;
      os_log_type_t v43 = 1024;
      *(_DWORD *)uint64_t v44 = v27;
      os_log_type_t v15 = "%{public}s %{public}s http2_transport already has stream id registered for %d, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_35;
      }
      int v26 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)buf = 136446722;
      BOOL v40 = "nw_http2_transport_add_to_id_table";
      uint64_t v41 = 2082;
      uint64_t v42 = v9;
      os_log_type_t v43 = 1024;
      *(_DWORD *)uint64_t v44 = v26;
      os_log_type_t v15 = "%{public}s %{public}s http2_transport already has stream id registered for %d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v15, buf, 0x1Cu);
    goto LABEL_35;
  }

  unsigned int v8 = v7;
  if (gLogDatapath)
  {
    uint64_t v32 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      v33 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)buf = 136446722;
      BOOL v40 = "nw_http2_transport_add_to_id_table";
      uint64_t v41 = 2082;
      uint64_t v42 = (char *)(a1 + 205);
      os_log_type_t v43 = 1024;
      *(_DWORD *)uint64_t v44 = v33;
      _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s added stream %d to stream id hash table",  buf,  0x1Cu);
    }
  }

  if (a3)
  {
    if (gLogDatapath)
    {
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        BOOL v40 = "nw_http2_transport_add_to_id_table";
        uint64_t v41 = 2082;
        uint64_t v42 = (char *)(a1 + 205);
        os_log_type_t v43 = 2048;
        *(void *)uint64_t v44 = a2;
        *(_WORD *)&v44[8] = 2048;
        *(void *)&v44[10] = v8;
        uint64_t v45 = 2048;
        int v46 = a3;
        _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s connecting stream %p node %p with protocol %p",  buf,  0x34u);
      }
    }

    *(void *)nw_hash_node_get_extra(v8) = a3;
  }

  return v8;
}

          v7 |= 0x20u;
          *((_BYTE *)v6 + 171) = v7;
          goto LABEL_7;
        }
      }

      else if ((*((_BYTE *)v5 + 170) & 2) == 0)
      {
        goto LABEL_5;
      }

      *((_BYTE *)v6 + 170) |= 2u;
      if ((*((_BYTE *)v5 + 171) & 0x20) == 0) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }

    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_proxy_config_create_merged";
    char v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v28 = 0;
    if (__nwlog_fault(v14, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v18 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_proxy_config_create_merged";
          _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null (lower_config->mode == nw_proxy_mode_protocol)",  buf,  0xCu);
        }

  uint64_t v5 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    BOOL v140 = "nw_protocol_http1_finalize_output_frames_block_invoke";
    int v141 = 2048;
    v142 = (const char *)a2;
    os_log_type_t v10 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    BOOL v138 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)gLogObj;
      BOOL v12 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v140 = "nw_protocol_http1_finalize_output_frames_block_invoke";
      int v141 = 2048;
      v142 = (const char *)a2;
      uint64_t v13 = "%{public}s frame %p has no connection in its context";
      goto LABEL_89;
    }

    if (v138 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)gLogObj;
      BOOL v12 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v140 = "nw_protocol_http1_finalize_output_frames_block_invoke";
      int v141 = 2048;
      v142 = (const char *)a2;
      uint64_t v13 = "%{public}s frame %p has no connection in its context, backtrace limit exceeded";
      goto LABEL_89;
    }

    __int16 v23 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)gLogObj;
    BOOL v12 = type[0];
    uint64_t v24 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v23)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446722;
        BOOL v140 = "nw_protocol_http1_finalize_output_frames_block_invoke";
        int v141 = 2048;
        v142 = (const char *)a2;
        v143 = 2082;
        char v144 = v23;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s frame %p has no connection in its context, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v23);
      if (!v10) {
        goto LABEL_93;
      }
LABEL_91:
      BOOL v58 = (char *)v10;
LABEL_92:
      free(v58);
      goto LABEL_93;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v140 = "nw_protocol_http1_finalize_output_frames_block_invoke";
      int v141 = 2048;
      v142 = (const char *)a2;
      uint64_t v13 = "%{public}s frame %p has no connection in its context, no backtrace";
LABEL_89:
      _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0x16u);
      goto LABEL_90;
    }

    goto LABEL_90;
  }

  uint64_t v6 = *(void *)(a1[5] + 8LL);
  uint64_t v7 = *(void *)(v6 + 24);
  if (v7)
  {
    if ((*(_WORD *)(v7 + 428) & 0x100) == 0) {
      goto LABEL_110;
    }
LABEL_29:
    uint64_t v18 = nw_frame_unclaimed_length((_DWORD *)a2);
    *(_DWORD *)os_log_type_t type = 0;
    nw_frame_get_buffer(a2, type);
    if (*(void *)(*(void *)(a1[4] + 8LL) + 24LL))
    {
      os_log_type_t v20 = *(_DWORD *)type;
      if (*(_DWORD *)type)
      {
        int v21 = 0;
        do
        {
          ++v21;
          uint64_t v22 = v20 > 0xF;
          v20 >>= 4;
        }

        while (v22);
      }

      else
      {
        int v21 = 0;
      }

      __int16 v25 = v21 + 2;
      int v26 = 7;
      goto LABEL_44;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v140 = "nw_http1_connection_get_chunked_extra_size";
    v91 = (char *)_os_log_send_and_compose_impl();
    BOOL v138 = OS_LOG_TYPE_ERROR;
    v137 = 0;
    if (__nwlog_fault(v91, &v138, &v137))
    {
      if (v138 == OS_LOG_TYPE_FAULT)
      {
        v92 = (os_log_s *)__nwlog_obj();
        v93 = v138;
        if (os_log_type_enabled(v92, v138))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v140 = "nw_http1_connection_get_chunked_extra_size";
          os_log_type_t v94 = "%{public}s called with null http1_connection";
LABEL_251:
          _os_log_impl(&dword_181A5C000, v92, v93, v94, buf, 0xCu);
        }
      }

      else if (v137)
      {
        v110 = (char *)__nw_create_backtrace_string();
        v92 = (os_log_s *)__nwlog_obj();
        v93 = v138;
        v111 = os_log_type_enabled(v92, v138);
        if (v110)
        {
          if (v111)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v140 = "nw_http1_connection_get_chunked_extra_size";
            int v141 = 2082;
            v142 = v110;
            _os_log_impl( &dword_181A5C000,  v92,  v93,  "%{public}s called with null http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v110);
          goto LABEL_252;
        }

        if (v111)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v140 = "nw_http1_connection_get_chunked_extra_size";
          os_log_type_t v94 = "%{public}s called with null http1_connection, no backtrace";
          goto LABEL_251;
        }
      }

      else
      {
        v92 = (os_log_s *)__nwlog_obj();
        v93 = v138;
        if (os_log_type_enabled(v92, v138))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v140 = "nw_http1_connection_get_chunked_extra_size";
          os_log_type_t v94 = "%{public}s called with null http1_connection, backtrace limit exceeded";
          goto LABEL_251;
        }
      }
    }

  return v8;
}
}

    uint64_t v5 = (uint64_t **)*v5;
    if (!v5) {
      goto LABEL_82;
    }
  }

  LOBYTE(v6) = 0;
  uint64_t v7 = v5[6];
  if (!v7) {
    goto LABEL_17;
  }
LABEL_9:
  if (nw_protocol_metadata_matches_definition((uint64_t)v7, g_ip_definition))
  {
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag((nw_protocol_metadata_t)v7) & 3;
    dscp_value = nw_ip_metadata_get_dscp_value(v7);
    if (dscp_value < 0x40)
    {
      *(_BYTE *)(a2 + 184) = dscp_value;
      goto LABEL_14;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v70 = "__nw_frame_set_dscp_value";
    BOOL v40 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v41 = (os_log_s *)__nwlog_obj();
      uint64_t v42 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v70 = "__nw_frame_set_dscp_value";
        os_log_type_t v43 = v41;
        uint64_t v44 = v42;
        uint64_t v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
        goto LABEL_79;
      }

      goto LABEL_80;
    }

    if (!v67)
    {
      v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = type[0];
      if (!os_log_type_enabled(v52, type[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v70 = "__nw_frame_set_dscp_value";
      os_log_type_t v43 = v52;
      uint64_t v44 = v53;
      uint64_t v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
      goto LABEL_79;
    }

    v48 = (char *)__nw_create_backtrace_string();
    uint64_t v49 = (os_log_s *)__nwlog_obj();
    os_log_type_t v50 = type[0];
    uint64_t v51 = os_log_type_enabled(v49, type[0]);
    if (v48)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v70 = "__nw_frame_set_dscp_value";
        v71 = 2082;
        os_log_type_t v72 = (uint64_t)v48;
        _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v48);
      goto LABEL_80;
    }

    if (v51)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v70 = "__nw_frame_set_dscp_value";
      os_log_type_t v43 = v49;
      uint64_t v44 = v50;
      uint64_t v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace";
LABEL_79:
      _os_log_impl(&dword_181A5C000, v43, v44, v45, buf, 0xCu);
    }
}

  BOOL v12 = nw_http_metadata_get_type(a1);
  v198 = 0LL;
  v199 = &v198;
  v200 = 0x2000000000LL;
  v201 = a5;
  v194 = 0LL;
  v195 = &v194;
  v196 = 0x2000000000LL;
  v197 = a6;
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v205 = "_http_safe_append";
    uint64_t v70 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__src == 17)
    {
      v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = __src;
      if (!os_log_type_enabled(v71, (os_log_type_t)__src)) {
        goto LABEL_303;
      }
      *(_DWORD *)buf = 136446210;
      v205 = "_http_safe_append";
      v73 = "%{public}s called with null (*remaining >= length)";
    }

    else if (type[0])
    {
      uint64_t v86 = (char *)__nw_create_backtrace_string();
      v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = __src;
      os_log_type_t v87 = os_log_type_enabled(v71, (os_log_type_t)__src);
      if (v86)
      {
        if (v87)
        {
          *(_DWORD *)buf = 136446466;
          v205 = "_http_safe_append";
          v206 = 2082;
          v207 = v86;
          _os_log_impl( &dword_181A5C000,  v71,  v72,  "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v86);
LABEL_303:
        if (v70) {
          free(v70);
        }
        v199[3] = 0LL;
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v205 = "nw_http_fillout_binary_message_inner";
        uint64_t v78 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(__src) = 16;
        type[0] = OS_LOG_TYPE_DEFAULT;
        if (__src == 17)
        {
          uint64_t v79 = (os_log_s *)__nwlog_obj();
          os_log_type_t v80 = __src;
          if (!os_log_type_enabled(v79, (os_log_type_t)__src)) {
            goto LABEL_363;
          }
          *(_DWORD *)buf = 136446210;
          v205 = "nw_http_fillout_binary_message_inner";
          uint64_t v81 = "%{public}s called with null cursor";
          goto LABEL_362;
        }

        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          uint64_t v79 = (os_log_s *)__nwlog_obj();
          os_log_type_t v80 = __src;
          if (!os_log_type_enabled(v79, (os_log_type_t)__src)) {
            goto LABEL_363;
          }
          *(_DWORD *)buf = 136446210;
          v205 = "nw_http_fillout_binary_message_inner";
          uint64_t v81 = "%{public}s called with null cursor, backtrace limit exceeded";
          goto LABEL_362;
        }

        v108 = (char *)__nw_create_backtrace_string();
        uint64_t v79 = (os_log_s *)__nwlog_obj();
        os_log_type_t v80 = __src;
        __int16 v148 = os_log_type_enabled(v79, (os_log_type_t)__src);
        if (!v108)
        {
          if (!v148) {
            goto LABEL_363;
          }
          *(_DWORD *)buf = 136446210;
          v205 = "nw_http_fillout_binary_message_inner";
          uint64_t v81 = "%{public}s called with null cursor, no backtrace";
          goto LABEL_362;
        }

        if (v148)
        {
          *(_DWORD *)buf = 136446466;
          v205 = "nw_http_fillout_binary_message_inner";
          v206 = 2082;
          v207 = v108;
          v110 = "%{public}s called with null cursor, dumping backtrace:%{public}s";
          goto LABEL_313;
        }

      if (v7 == &a1[a2]) {
        break;
      }
      if (v8 == v6)
      {
        uint64_t v9 = 2LL;
        *(_DWORD *)a5 = 2;
        return v9 | (a4 << 32);
      }

LABEL_7:
      if (!v4) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }

    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      char v19 = v26;
      if (os_log_type_enabled(v5, v26))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "-[NWConcrete_nw_nat64_prefixes_resolver dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v19,  "%{public}s over-release of nw_nat64_prefixes_resolver_t! Object should not be internally retained and dealloca ting, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    char v14 = v26;
    os_log_type_t v15 = os_log_type_enabled(v5, v26);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "-[NWConcrete_nw_nat64_prefixes_resolver dealloc]";
        _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s over-release of nw_nat64_prefixes_resolver_t! Object should not be internally retained and dealloca ting, no backtrace",  buf,  0xCu);
      }

      goto LABEL_6;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v28 = "-[NWConcrete_nw_nat64_prefixes_resolver dealloc]";
      unint64_t v29 = 2082;
      uint64_t v30 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v5,  v14,  "%{public}s over-release of nw_nat64_prefixes_resolver_t! Object should not be internally retained and deallocati ng, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    if (v4) {
LABEL_8:
    }
      free(v4);
  }

  return v6;
}

    free(v5);
    goto LABEL_7;
  }

  __break(1u);
}

    *a2 = v9;
    goto LABEL_7;
  }

  if (!nw_browse_descriptor_is_custom_type(v3))
  {
LABEL_54:
    os_log_type_t v10 = 28LL;
    goto LABEL_55;
  }

  BOOL v16 = (dispatch_data_s *)nw_browse_descriptor_copy_custom_data(v3);
  uint64_t v17 = v16;
  if (!v16)
  {
LABEL_53:

    goto LABEL_54;
  }

  size = dispatch_data_get_size(v16);
  if (size >= 0x401)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_path_struct_size_for_browse_descriptor";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1024;
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v31 = 0;
    if (__nwlog_fault(v20, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_struct_size_for_browse_descriptor";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1024;
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v27 = type;
        uint64_t v28 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_path_struct_size_for_browse_descriptor";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1024;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v21,  v27,  "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_51;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_struct_size_for_browse_descriptor";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1024;
          _os_log_impl( &dword_181A5C000,  v21,  v27,  "%{public}s Custom data size must be no larger than %d, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v29 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_struct_size_for_browse_descriptor";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1024;
          _os_log_impl( &dword_181A5C000,  v21,  v29,  "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    uint64_t v6 = *(void *)(v3 + 24);
    if (v6)
    {
      uint64_t v7 = *(void (**)(uint64_t, void))(v6 + 24);
      if (v7)
      {
        v7(v3, *(void *)(a1 + 1072));
        return;
      }
    }

    __nwlog_obj();
    uint64_t v9 = *(const char **)(v3 + 16);
    if (!v9) {
      uint64_t v9 = "invalid";
    }
LABEL_47:
    *(_DWORD *)buf = 136446466;
    v33 = "nw_http3_start_decoder_stream_if_needed";
    os_log_type_t v34 = 2082;
    unint64_t v35 = v9;
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      __int16 v23 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        __int16 v23 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http3_start_decoder_stream_if_needed";
      os_log_type_t v34 = 2082;
      unint64_t v35 = v23;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback";
    }

    else if (v30)
    {
      __int16 v25 = (char *)__nw_create_backtrace_string();
      int v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      int v26 = os_log_type_enabled(v21, type);
      if (v25)
      {
        if (v26)
        {
          int v27 = "invalid";
          if (v3 && *(void *)(v3 + 16)) {
            int v27 = *(const char **)(v3 + 16);
          }
          *(_DWORD *)buf = 136446722;
          v33 = "nw_http3_start_decoder_stream_if_needed";
          os_log_type_t v34 = 2082;
          unint64_t v35 = v27;
          uint64_t v36 = 2082;
          v37 = v25;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v25);
        goto LABEL_73;
      }

      if (!v26)
      {
LABEL_73:
        if (v20) {
          free(v20);
        }
        return;
      }

      unint64_t v29 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        unint64_t v29 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http3_start_decoder_stream_if_needed";
      os_log_type_t v34 = 2082;
      unint64_t v35 = v29;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }

    else
    {
      int v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      uint64_t v28 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        uint64_t v28 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http3_start_decoder_stream_if_needed";
      os_log_type_t v34 = 2082;
      unint64_t v35 = v28;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x16u);
    goto LABEL_73;
  }

    uint64_t v6 = *(void *)(v3 + 24);
    if (v6)
    {
      uint64_t v7 = *(void (**)(uint64_t, void))(v6 + 24);
      if (v7)
      {
        v7(v3, *(void *)(a1 + 1056));
        return;
      }
    }

    __nwlog_obj();
    uint64_t v9 = *(const char **)(v3 + 16);
    if (!v9) {
      uint64_t v9 = "invalid";
    }
LABEL_47:
    *(_DWORD *)buf = 136446466;
    v33 = "nw_http3_start_encoder_stream_if_needed";
    os_log_type_t v34 = 2082;
    unint64_t v35 = v9;
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      __int16 v23 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        __int16 v23 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http3_start_encoder_stream_if_needed";
      os_log_type_t v34 = 2082;
      unint64_t v35 = v23;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback";
    }

    else if (v30)
    {
      __int16 v25 = (char *)__nw_create_backtrace_string();
      int v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      int v26 = os_log_type_enabled(v21, type);
      if (v25)
      {
        if (v26)
        {
          int v27 = "invalid";
          if (v3 && *(void *)(v3 + 16)) {
            int v27 = *(const char **)(v3 + 16);
          }
          *(_DWORD *)buf = 136446722;
          v33 = "nw_http3_start_encoder_stream_if_needed";
          os_log_type_t v34 = 2082;
          unint64_t v35 = v27;
          uint64_t v36 = 2082;
          v37 = v25;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v25);
        goto LABEL_73;
      }

      if (!v26)
      {
LABEL_73:
        if (v20) {
          free(v20);
        }
        return;
      }

      unint64_t v29 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        unint64_t v29 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http3_start_encoder_stream_if_needed";
      os_log_type_t v34 = 2082;
      unint64_t v35 = v29;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }

    else
    {
      int v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_73;
      }
      uint64_t v28 = "invalid";
      if (v3 && *(void *)(v3 + 16)) {
        uint64_t v28 = *(const char **)(v3 + 16);
      }
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http3_start_encoder_stream_if_needed";
      os_log_type_t v34 = 2082;
      unint64_t v35 = v28;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x16u);
    goto LABEL_73;
  }

      id v2 = v8;
    }

    while (v8);
  }

  return v7;
}

            goto LABEL_7;
          }
        }

        BOOL v16 = (const char *)objc_msgSend(v13, "UTF8String", v29);
        if (!v16)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v24 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v29;
            v37 = "NWUtilsCreateXPCDictionaryFromNSDictionary";
            v38 = 2114;
            os_log_type_t v39 = v13;
            BOOL v40 = 2114;
            uint64_t v41 = v14;
            __int16 v25 = v24;
            int v26 = "%{public}s Could not parse trimmed key %{public}@ for %{public}@";
            int v27 = 32;
LABEL_5:
            _os_log_impl(&dword_181A5C000, v25, OS_LOG_TYPE_ERROR, v26, buf, v27);
          }

          goto LABEL_6;
        }

        xpc_dictionary_set_value(xdict, v16, XPCArrayFromNSArray);
LABEL_7:
      }

      uint64_t v5 = [v2 countByEnumeratingWithState:&v32 objects:v42 count:16];
    }

    while (v5);
  }

  return xdict;
}

  uint64_t v5 = 0LL;
LABEL_84:

  return v5;
}

  return v6;
}

  *(_WORD *)(a1 + 388) = v2 & 0xFFF3 | 8;
  nw_protocol_remove_instance(a1);
  uint64_t v3 = *(char **)(a1 + 160);
  int v4 = MEMORY[0x1895F87A8];
  if (v3)
  {
    v32[0] = MEMORY[0x1895F87A8];
    v32[1] = 0x40000000LL;
    v32[2] = ___ZL25nw_http2_connection_closeP17nw_protocol_http2_block_invoke;
    v32[3] = &__block_descriptor_tmp_19_81919;
    v32[4] = a1;
    nw_hash_table_apply(v3, (uint64_t)v32);
  }

  else if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v5 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v36 = "nw_http2_connection_close";
      v37 = 2082;
      v38 = (void *)(a1 + 390);
      os_log_type_t v39 = 2080;
      BOOL v40 = " ";
      uint64_t v41 = 1024;
      uint64_t v42 = v6;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> id table is NULL, cannot close streams",  buf,  0x26u);
    }
  }

  nw_http2_send_goaway(a1);
  uint64_t v7 = *(char **)(a1 + 152);
  if (v7)
  {
    v31[0] = v4;
    v31[1] = 0x40000000LL;
    v31[2] = ___ZL25nw_http2_connection_closeP17nw_protocol_http2_block_invoke_20;
    v31[3] = &__block_descriptor_tmp_21_81925;
    v31[4] = a1;
    nw_hash_table_apply(v7, (uint64_t)v31);
    return;
  }

  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    unsigned int v8 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    uint64_t v36 = "nw_http2_connection_close";
    v37 = 2082;
    v38 = (void *)(a1 + 390);
    os_log_type_t v39 = 2080;
    BOOL v40 = " ";
    uint64_t v41 = 1024;
    uint64_t v42 = v8;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v10 = (os_log_s *)gconnectionLogObj;
      uint64_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_38;
      }
      BOOL v12 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v36 = "nw_http2_connection_close";
      v37 = 2082;
      v38 = (void *)(a1 + 390);
      os_log_type_t v39 = 2080;
      BOOL v40 = " ";
      uint64_t v41 = 1024;
      uint64_t v42 = v12;
      uint64_t v13 = "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers";
    }

    else if (v33)
    {
      char v14 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v10 = (os_log_s *)gconnectionLogObj;
      uint64_t v11 = type;
      os_log_type_t v15 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v14)
      {
        if (v15)
        {
          BOOL v16 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          uint64_t v36 = "nw_http2_connection_close";
          v37 = 2082;
          v38 = (void *)(a1 + 390);
          os_log_type_t v39 = 2080;
          BOOL v40 = " ";
          uint64_t v41 = 1024;
          uint64_t v42 = v16;
          os_log_type_t v43 = 2082;
          uint64_t v44 = v14;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers, dumping backtrace:%{public}s",  buf,  0x30u);
        }

        free(v14);
        goto LABEL_38;
      }

      if (!v15)
      {
LABEL_38:
        if (v9) {
          free(v9);
        }
        return;
      }

      uint64_t v18 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v36 = "nw_http2_connection_close";
      v37 = 2082;
      v38 = (void *)(a1 + 390);
      os_log_type_t v39 = 2080;
      BOOL v40 = " ";
      uint64_t v41 = 1024;
      uint64_t v42 = v18;
      uint64_t v13 = "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers, no backtrace";
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v10 = (os_log_s *)gconnectionLogObj;
      uint64_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_38;
      }
      uint64_t v17 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v36 = "nw_http2_connection_close";
      v37 = 2082;
      v38 = (void *)(a1 + 390);
      os_log_type_t v39 = 2080;
      BOOL v40 = " ";
      uint64_t v41 = 1024;
      uint64_t v42 = v17;
      uint64_t v13 = "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v10, v11, v13, buf, 0x26u);
    goto LABEL_38;
  }

  if ((v2 & 0x200) == 0)
  {
    uint64_t v3 = 0;
    *(_WORD *)(a1 + 388) = v2 | 0x100;
    int v4 = MEMORY[0x1895F87A8];
    while (1)
    {
      uint64_t v6 = nghttp2_session_want_write();
      uint64_t v7 = *(__int16 *)(a1 + 388);
      if (!v6)
      {
LABEL_73:
        *(_WORD *)(a1 + 388) = v7 & 0xFEFF;
        if ((v3 & 1) != 0) {
          nw_http2_connection_close(a1);
        }
        return;
      }

      if ((v7 & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unint64_t v35 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v36 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http2_session_send";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 390;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v36;
          _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> nghttp2 wants to write",  buf,  0x26u);
        }
      }

      *(_WORD *)(a1 + 388) &= ~0x2000u;
      unsigned int v8 = nghttp2_session_send();
      if (!v8) {
        goto LABEL_40;
      }
      uint64_t v9 = v8;
      if (v8 != -902 || (*(_WORD *)(a1 + 388) & 0x10) == 0) {
        break;
      }
      if ((*(_WORD *)(a1 + 388) & 0x8000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v19 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
        {
          os_log_type_t v20 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http2_session_send";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 390;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v20;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%s<i%u> tunnel error, send failed, closing",  buf,  0x26u);
        }
      }

    *(_WORD *)(a1 + 388) = v2 | 0x400;
    if ((v2 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v12 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v13 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        uint64_t v22 = "nw_http2_drain_output_frames";
        __int16 v23 = 2082;
        uint64_t v24 = (void *)(a1 + 390);
        __int16 v25 = 2080;
        int v26 = " ";
        int v27 = 1024;
        uint64_t v28 = v13;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> draining output frames",  buf,  0x26u);
      }
    }

    uint64_t v3 = *(char **)(a1 + 152);
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 0x40000000LL;
    v18[2] = ___ZL28nw_http2_drain_output_framesP17nw_protocol_http2_block_invoke;
    v18[3] = &__block_descriptor_tmp_26_81786;
    v18[4] = a1;
    nw_hash_table_apply(v3, (uint64_t)v18);
    *(_WORD *)(a1 + 388) &= ~0x400u;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_http2_drain_output_frames";
  unsigned int v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_http2_drain_output_frames";
      uint64_t v11 = "%{public}s called with null http2";
      goto LABEL_41;
    }

    if (!v19)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_http2_drain_output_frames";
      uint64_t v11 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    uint64_t v17 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "nw_http2_drain_output_frames";
        __int16 v23 = 2082;
        uint64_t v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null http2, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_42;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_http2_drain_output_frames";
      uint64_t v11 = "%{public}s called with null http2, no backtrace";
LABEL_41:
      _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    }
  }

      uint64_t v3 = *(_DWORD *)(a1 + 364);
      if (!v3) {
        goto LABEL_19;
      }
      if ((v2 & 0x80) != 0)
      {
        if ((v3 & 1) == 0 && (v2 & 0x8000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v36 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          uint64_t v51 = "nw_http2_send_goaway";
          v52 = 2082;
          os_log_type_t v53 = a1 + 390;
          v54 = 2080;
          v55 = " ";
          v56 = 1024;
          os_log_type_t v57 = v36;
          BOOL v58 = 1024;
          uint64_t v59 = v3;
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v48 = 0;
          uint64_t v5 = (char *)_os_log_send_and_compose_impl();
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v6 = (os_log_s *)gconnectionLogObj;
            uint64_t v7 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              v37 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447234;
              uint64_t v51 = "nw_http2_send_goaway";
              v52 = 2082;
              os_log_type_t v53 = a1 + 390;
              v54 = 2080;
              v55 = " ";
              v56 = 1024;
              os_log_type_t v57 = v37;
              BOOL v58 = 1024;
              uint64_t v59 = v3;
              uint64_t v9 = "%{public}s %{public}s%s<i%u> Last stream value %d is even, but we are the server";
              goto LABEL_112;
            }

  return v6;
}

LABEL_75:
        if (v48) {
          free(v48);
        }
        *((_WORD *)v23 + 14) = -1;
        uint64_t v22 = v143;
LABEL_78:
        if ((v3[48] & 2) != 0) {
          os_unfair_lock_unlock(lock);
        }
        char v64 = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 16))(a2, v24);
        if (*((_DWORD *)v3 + 8))
        {
          if ((v3[48] & 2) == 0) {
            goto LABEL_83;
          }
LABEL_82:
          os_unfair_lock_lock(lock);
          goto LABEL_83;
        }

        v111 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v111, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v147 = "nw_hash_table_lock";
        v112 = (void *)_os_log_send_and_compose_impl();
        free(v112);
        if ((v3[48] & 2) != 0) {
          goto LABEL_82;
        }
LABEL_83:
        unsigned int v65 = (unsigned __int16)(*((_WORD *)v24 + 14))-- - 1;
        if (v65 < 0x10000) {
          goto LABEL_101;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v66 = *((unsigned __int16 *)v24 + 14);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        __int16 v148 = 2082;
        v149 = "node->apply_count";
        __int16 v150 = 2048;
        uint64_t v151 = 1LL;
        __int16 v152 = 2048;
        uint64_t v153 = v66;
        v67 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v144 = 0;
        if (__nwlog_fault(v67, &type, &v144))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v68 = gLogObj;
            os_log_type_t v69 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v70 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v70;
              v71 = (os_log_s *)v68;
              os_log_type_t v72 = v69;
              v73 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_97:
              _os_log_impl(&dword_181A5C000, v71, v72, v73, buf, 0x2Au);
            }
          }

          else if (v144)
          {
            v74 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v75 = (os_log_s *)gLogObj;
            os_log_type_t v76 = type;
            BOOL v77 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v74)
            {
              if (v77)
              {
                uint64_t v78 = *((unsigned __int16 *)v24 + 14);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                __int16 v148 = 2082;
                v149 = "node->apply_count";
                __int16 v150 = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v78;
                __int16 v154 = 2082;
                v155 = v74;
                _os_log_impl( &dword_181A5C000,  v75,  v76,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v74);
              goto LABEL_98;
            }

            if (v77)
            {
              uint64_t v82 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v82;
              v71 = v75;
              os_log_type_t v72 = v76;
              v73 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_97;
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v79 = gLogObj;
            os_log_type_t v80 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v81 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v81;
              v71 = (os_log_s *)v79;
              os_log_type_t v72 = v80;
              v73 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_97;
            }
          }
        }

      goto LABEL_76;
    }

    if (!v105)
    {
      __nwlog_obj();
      v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v46 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_context_activate";
        _os_log_impl( &dword_181A5C000,  v38,  v46,  "%{public}s dispatch_workloop_create failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_75;
    }

    BOOL v40 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v41 = type;
    uint64_t v42 = os_log_type_enabled(v38, type);
    if (!v40)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_context_activate";
        _os_log_impl(&dword_181A5C000, v38, v41, "%{public}s dispatch_workloop_create failed, no backtrace", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      v108 = "nw_context_activate";
      int v109 = 2082;
      v110 = (__uint64_t)v40;
      _os_log_impl( &dword_181A5C000,  v38,  v41,  "%{public}s dispatch_workloop_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v40);
  }

    goto LABEL_76;
  }

  if (!v67)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v51 = (os_log_s *)(id)gLogObj;
    BOOL v58 = type;
    if (os_log_type_enabled(v51, type))
    {
      if (mode > 5) {
        uint64_t v59 = "unknown-mode";
      }
      else {
        uint64_t v59 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v59;
      *(_WORD *)&buf[22] = 2082;
      uint64_t v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
      _os_log_impl( &dword_181A5C000,  v51,  v58,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_75;
  }

  v54 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v51 = (os_log_s *)(id)gLogObj;
  v55 = type;
  v56 = os_log_type_enabled(v51, type);
  if (!v54)
  {
    if (v56)
    {
      if (mode > 5) {
        uint64_t v60 = "unknown-mode";
      }
      else {
        uint64_t v60 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v60;
      *(_WORD *)&buf[22] = 2082;
      uint64_t v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
      _os_log_impl( &dword_181A5C000,  v51,  v55,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_75;
  }

  if (v56)
  {
    if (mode > 5) {
      os_log_type_t v57 = "unknown-mode";
    }
    else {
      os_log_type_t v57 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v57;
    *(_WORD *)&buf[22] = 2082;
    uint64_t v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
    LOWORD(v71) = 2082;
    *(void *)((char *)&v71 + 2) = v54;
    _os_log_impl( &dword_181A5C000,  v51,  v55,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v54);
  if (v50) {
    goto LABEL_77;
  }
LABEL_78:
}
}

    if (v44) {
      free(v44);
    }
    goto LABEL_55;
  }

  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  }
  int v4 = (os_log_s *)(id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = v3[1];
    *(_DWORD *)buf = 136446722;
    v89 = "nw_candidate_manager_handle_ids_path";
    os_log_type_t v90 = 2048;
    v91 = v5;
    v92 = 2112;
    v93 = v61;
    _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] path: %@", buf, 0x20u);
  }

  unsigned int v65 = 0LL;
  uint64_t v66 = &v65;
  v67 = 0x3032000000LL;
  uint64_t v68 = __Block_byref_object_copy__2761;
  os_log_type_t v69 = __Block_byref_object_dispose__2762;
  uint64_t v6 = MEMORY[0x1895F87A8];
  uint64_t v70 = 0LL;
  v62[0] = MEMORY[0x1895F87A8];
  v62[1] = 3221225472LL;
  v62[2] = ___ZL36nw_candidate_manager_handle_ids_pathP31NWConcrete_nw_candidate_managerPU21objcproto10OS_nw_path8NSObject_block_invoke;
  v62[3] = &unk_189BB6290;
  char v64 = &v65;
  uint64_t v7 = v59;
  uint64_t v63 = v7;
  nw_path_enumerate_resolve_options(v61, v62);
  objc_storeStrong(v7 + 3, (id)v66[5]);
  unsigned int v8 = nw_path_copy_resolved_endpoints(v61);
  uint64_t v9 = v7;
  object = (unsigned __int8 *)v8;
  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  }
  os_log_type_t v10 = (os_log_s *)(id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = (char *)v9[1];
    *(_DWORD *)buf = 136446722;
    v89 = "nw_candidate_manager_handle_ids_endpoints";
    os_log_type_t v90 = 2048;
    v91 = v11;
    v92 = 2112;
    v93 = object;
    _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] endpoints: %@", buf, 0x20u);
  }

  BOOL v12 = v9[4];
  if (v12)
  {
    uint64_t v13 = (void *)MEMORY[0x189603FA8];
    [v12 allKeys];
    char v14 = (id)objc_claimAutoreleasedReturnValue();
    [v13 arrayWithArray:v14];
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_12:

    v77[0] = v6;
    v77[1] = 3221225472LL;
    v77[2] = ___ZL41nw_candidate_manager_handle_ids_endpointsP31NWConcrete_nw_candidate_managerPU22objcproto11OS_nw_array8NSObject_block_invoke;
    v77[3] = &unk_189BC5030;
    BOOL v16 = v15;
    uint64_t v78 = v16;
    uint64_t v17 = v9;
    uint64_t v79 = v17;
    nw_array_apply(object, (uint64_t)v77);
    *(_OWORD *)v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    os_log_type_t v76 = 0u;
    uint64_t v18 = v16;
    char v19 = [v18 countByEnumeratingWithState:v73 objects:buf count:16];
    if (!v19) {
      goto LABEL_53;
    }
    os_log_type_t v20 = *(void *)v74;
    while (1)
    {
      int v21 = 0LL;
      do
      {
        if (*(void *)v74 != v20) {
          objc_enumerationMutation(v18);
        }
        uint64_t v22 = *(void *)(*(void *)&v73[8] + 8 * v21);
        __int16 v23 = objc_msgSend(v9[4], "objectForKeyedSubscript:", v22, v52, v53);
        [v9[4] removeObjectForKey:v22];
        if (v23)
        {
        }

        else
        {
          if (__nwlog_candidate_manager_log::onceToken != -1) {
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
          }
          uint64_t v24 = (id)gcandidate_managerLogObj;
          __int16 v25 = v17[1];
          *(_DWORD *)os_log_type_t v80 = 136446722;
          uint64_t v81 = "nw_candidate_manager_handle_ids_endpoints";
          uint64_t v82 = 2048;
          unsigned int v83 = v25;
          uint64_t v84 = 2112;
          v85 = v22;
          LODWORD(v53) = 32;
          v52 = v80;
          BOOL v58 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v71 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v57 = v7;
            if (__nwlog_candidate_manager_log::onceToken != -1) {
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            }
            int v26 = (os_log_s *)(id)gcandidate_managerLogObj;
            int v27 = type;
            if (os_log_type_enabled(v26, type))
            {
              uint64_t v28 = v17[1];
              *(_DWORD *)os_log_type_t v80 = 136446722;
              uint64_t v81 = "nw_candidate_manager_handle_ids_endpoints";
              uint64_t v82 = 2048;
              unsigned int v83 = v28;
              uint64_t v84 = 2112;
              v85 = v22;
              _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s [CM%zu] No resolver for %@", v80, 0x20u);
            }

            uint64_t v7 = v57;
LABEL_32:
            unint64_t v29 = (char *)v58;
            if (!v58) {
              goto LABEL_21;
            }
LABEL_33:
            free(v29);
            goto LABEL_21;
          }

          if (!v71)
          {
            if (__nwlog_candidate_manager_log::onceToken != -1) {
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            }
            os_log_type_t v34 = (os_log_s *)(id)gcandidate_managerLogObj;
            unint64_t v35 = type;
            loga = v34;
            if (os_log_type_enabled(v34, type))
            {
              uint64_t v36 = v17[1];
              *(_DWORD *)os_log_type_t v80 = 136446722;
              uint64_t v81 = "nw_candidate_manager_handle_ids_endpoints";
              uint64_t v82 = 2048;
              unsigned int v83 = v36;
              uint64_t v84 = 2112;
              v85 = v22;
              _os_log_impl( &dword_181A5C000,  loga,  v35,  "%{public}s [CM%zu] No resolver for %@, backtrace limit exceeded",  v80,  0x20u);
            }

            goto LABEL_46;
          }

          uint64_t v30 = __nw_create_backtrace_string();
          if (!v30)
          {
            if (__nwlog_candidate_manager_log::onceToken != -1) {
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            }
            v37 = (os_log_s *)(id)gcandidate_managerLogObj;
            v38 = type;
            loga = v37;
            if (os_log_type_enabled(v37, type))
            {
              os_log_type_t v39 = v17[1];
              *(_DWORD *)os_log_type_t v80 = 136446722;
              uint64_t v81 = "nw_candidate_manager_handle_ids_endpoints";
              uint64_t v82 = 2048;
              unsigned int v83 = v39;
              uint64_t v84 = 2112;
              v85 = v22;
              _os_log_impl( &dword_181A5C000,  loga,  v38,  "%{public}s [CM%zu] No resolver for %@, no backtrace",  v80,  0x20u);
            }

        goto LABEL_76;
      }

      __nwlog_obj();
      os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_implementation_input_flush";
      BOOL v12 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v34 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v16 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }

        goto LABEL_75;
      }

      if (!v34)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v32 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_75;
      }

      uint64_t v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v25 = type;
      int v26 = os_log_type_enabled(v13, type);
      if (!v22)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
        }

        goto LABEL_75;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_protocol_implementation_input_flush";
        v38 = 2082;
        os_log_type_t v39 = v22;
        _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_implementation_input_flush";
      BOOL v12 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v34 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_75;
      }

      if (!v34)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl( &dword_181A5C000,  v13,  v31,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_75;
      }

      uint64_t v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v23 = type;
      uint64_t v24 = os_log_type_enabled(v13, type);
      if (!v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_181A5C000, v13, v23, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_75;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_protocol_implementation_input_flush";
        v38 = 2082;
        os_log_type_t v39 = v22;
        _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    free(v22);
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_77;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_protocol_implementation_input_flush";
  unsigned int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v34 = 0;
  if (__nwlog_fault(v8, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_implementation_input_flush";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v34)
    {
      char v19 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      int v21 = os_log_type_enabled(v9, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_protocol_implementation_input_flush";
          v38 = 2082;
          os_log_type_t v39 = v19;
          _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        goto LABEL_65;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_implementation_input_flush";
        _os_log_impl(&dword_181A5C000, v9, v20, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_implementation_input_flush";
        _os_log_impl( &dword_181A5C000,  v9,  v30,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

          goto LABEL_76;
        }

        if (!v39)
        {
          __nwlog_obj();
          char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v38 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v42 = "nw_protocol_create_inbound_data";
            _os_log_impl( &dword_181A5C000,  v14,  v38,  "%{public}s nw_frame_create failed, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_75;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        unint64_t v35 = os_log_type_enabled(v14, type);
        if (!backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v42 = "nw_protocol_create_inbound_data";
            _os_log_impl(&dword_181A5C000, v14, v34, "%{public}s nw_frame_create failed, no backtrace", buf, 0xCu);
          }

          goto LABEL_75;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v42 = "nw_protocol_create_inbound_data";
          os_log_type_t v43 = 2082;
          uint64_t v44 = (size_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v34,  "%{public}s nw_frame_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_57;
      }

      goto LABEL_76;
    }

    if (!v108)
    {
      __nwlog_obj();
      int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v96 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl( &dword_181A5C000,  v27,  v96,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_75;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v93 = type;
    os_log_type_t v94 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v94)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_181A5C000, v27, v93, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (v94)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v27,  v93,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

                            goto LABEL_137;
                          }

                          if (!v147)
                          {
                            __nwlog_obj();
                            unsigned int v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            os_log_type_t v87 = type;
                            if (os_log_type_enabled(v65, type))
                            {
                              *(_DWORD *)buf = 136446210;
                              __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                              _os_log_impl( &dword_181A5C000,  v65,  v87,  "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded",  buf,  0xCu);
                            }

                            goto LABEL_75;
                          }

                          os_log_type_t v76 = (char *)__nw_create_backtrace_string();
                          __nwlog_obj();
                          BOOL v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          uint64_t v78 = type;
                          uint64_t v79 = os_log_type_enabled(v77, type);
                          if (v76)
                          {
                            if (v79)
                            {
                              *(_DWORD *)buf = 136446466;
                              __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                              uint64_t v151 = 2082;
                              __int16 v152 = v76;
                              _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
                            }

                            free(v76);
                            if (!v64) {
                              goto LABEL_139;
                            }
                            goto LABEL_138;
                          }

                          if (v79)
                          {
                            *(_DWORD *)buf = 136446210;
                            __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                            _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s nw_protocol_transform_create failed, no backtrace",  buf,  0xCu);
                          }
                        }
}

              goto LABEL_76;
            }

            if (!v91)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v19 = (os_log_s *)(id)gLogObj;
              v48 = type;
              if (os_log_type_enabled(v19, type))
              {
                *(_DWORD *)buf = 136446722;
                os_log_type_t v94 = "nw_read_request_create_with_buffer";
                BOOL v95 = 2048;
                *(void *)uint64_t v96 = v16;
                *(_WORD *)&v96[8] = 2048;
                *(void *)&v96[10] = a4;
                _os_log_impl( &dword_181A5C000,  v19,  v48,  "%{public}s minlength (%zu) > max_data_count (%zu), backtrace limit exceeded",  buf,  0x20u);
              }

              goto LABEL_75;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v19 = (os_log_s *)(id)gLogObj;
            BOOL v40 = type;
            uint64_t v41 = os_log_type_enabled(v19, type);
            if (!backtrace_string)
            {
              if (v41)
              {
                *(_DWORD *)buf = 136446722;
                os_log_type_t v94 = "nw_read_request_create_with_buffer";
                BOOL v95 = 2048;
                *(void *)uint64_t v96 = v16;
                *(_WORD *)&v96[8] = 2048;
                *(void *)&v96[10] = a4;
                _os_log_impl( &dword_181A5C000,  v19,  v40,  "%{public}s minlength (%zu) > max_data_count (%zu), no backtrace",  buf,  0x20u);
              }

              goto LABEL_75;
            }

            if (v41)
            {
              *(_DWORD *)buf = 136446978;
              os_log_type_t v94 = "nw_read_request_create_with_buffer";
              BOOL v95 = 2048;
              *(void *)uint64_t v96 = v16;
              *(_WORD *)&v96[8] = 2048;
              *(void *)&v96[10] = a4;
              uint64_t v97 = 2082;
              os_log_type_t v98 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v19,  v40,  "%{public}s minlength (%zu) > max_data_count (%zu), dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            if (v18) {
LABEL_77:
            }
              free(v18);
LABEL_87:

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v55 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            os_log_type_t v94 = "nw_connection_read_buffer";
            v56 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v91 = 0;
            if (__nwlog_fault(v56, &type, &v91))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v57 = (os_log_s *)(id)gLogObj;
                BOOL v58 = type;
                if (os_log_type_enabled(v57, type))
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v94 = "nw_connection_read_buffer";
                  _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s nw_read_request_create_with_buffer failed",  buf,  0xCu);
                }
              }

              else if (v91)
              {
                uint64_t v59 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v57 = (os_log_s *)(id)gLogObj;
                uint64_t v60 = type;
                os_log_type_t v61 = os_log_type_enabled(v57, type);
                if (v59)
                {
                  if (v61)
                  {
                    *(_DWORD *)buf = 136446466;
                    os_log_type_t v94 = "nw_connection_read_buffer";
                    BOOL v95 = 2082;
                    *(void *)uint64_t v96 = v59;
                    _os_log_impl( &dword_181A5C000,  v57,  v60,  "%{public}s nw_read_request_create_with_buffer failed, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v59);
                  if (!v56) {
                    goto LABEL_106;
                  }
                  goto LABEL_105;
                }

                if (v61)
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v94 = "nw_connection_read_buffer";
                  _os_log_impl( &dword_181A5C000,  v57,  v60,  "%{public}s nw_read_request_create_with_buffer failed, no backtrace",  buf,  0xCu);
                }
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v57 = (os_log_s *)(id)gLogObj;
                uint64_t v62 = type;
                if (os_log_type_enabled(v57, type))
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v94 = "nw_connection_read_buffer";
                  _os_log_impl( &dword_181A5C000,  v57,  v62,  "%{public}s nw_read_request_create_with_buffer failed, backtrace limit exceeded",  buf,  0xCu);
                }
              }
            }

            if (!v56)
            {
LABEL_106:
              v33 = 0LL;
              uint64_t v32 = 0LL;
LABEL_107:

              goto LABEL_108;
            }

        goto LABEL_76;
      }

      if (!v47)
      {
        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v46 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl( &dword_181A5C000,  v36,  v46,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_75;
      }

      BOOL v40 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      uint64_t v44 = os_log_type_enabled(v36, type);
      if (!v40)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_181A5C000, v36, v43, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }

        goto LABEL_75;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
        uint64_t v51 = 2082;
        v52 = v40;
        _os_log_impl( &dword_181A5C000,  v36,  v43,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_63;
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
    unint64_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v47 = 0;
    if (__nwlog_fault(v35, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_181A5C000, v36, v37, "%{public}s called with null endpoint", buf, 0xCu);
        }

        goto LABEL_75;
      }

      if (!v47)
      {
        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v45 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl( &dword_181A5C000,  v36,  v45,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_75;
      }

      BOOL v40 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v41 = type;
      uint64_t v42 = os_log_type_enabled(v36, type);
      if (!v40)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_181A5C000, v36, v41, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_75;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v50 = "tcp_connection_create_with_endpoint_and_parameters";
        uint64_t v51 = 2082;
        v52 = v40;
        _os_log_impl( &dword_181A5C000,  v36,  v41,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v43);
      if (!v32) {
        return;
      }
LABEL_121:
      unsigned int v65 = (char *)v32;
LABEL_140:
      free(v65);
      return;
    }

    v33 = (os_log_s *)__nwlog_obj();
    os_log_type_t v34 = type;
    if (!os_log_type_enabled(v33, type)) {
      goto LABEL_120;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v82 = "nw_protocol_http_connect_input_finished";
    unint64_t v35 = "%{public}s called with null http_connect";
LABEL_119:
    _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0xCu);
    goto LABEL_120;
  }

  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v82 = "nw_protocol_http_connect_input_finished";
    uint64_t v32 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v79 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_120;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v82 = "nw_protocol_http_connect_input_finished";
      unint64_t v35 = "%{public}s called with null protocol->default_input_handler";
      goto LABEL_119;
    }

    if (!v79)
    {
      v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_120;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v82 = "nw_protocol_http_connect_input_finished";
      unint64_t v35 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
      goto LABEL_119;
    }

    os_log_type_t v43 = (char *)__nw_create_backtrace_string();
    v33 = (os_log_s *)__nwlog_obj();
    os_log_type_t v34 = type;
    int v46 = os_log_type_enabled(v33, type);
    if (!v43)
    {
      if (!v46) {
        goto LABEL_120;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v82 = "nw_protocol_http_connect_input_finished";
      unint64_t v35 = "%{public}s called with null protocol->default_input_handler, no backtrace";
      goto LABEL_119;
    }

    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v82 = "nw_protocol_http_connect_input_finished";
      unsigned int v83 = 2082;
      uint64_t v84 = v43;
      uint64_t v45 = "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s";
      goto LABEL_74;
    }

    goto LABEL_75;
  }

  if (*((_DWORD *)handle + 70) == 1)
  {
    if (a1->output_handler != a2)
    {
      callbacks = default_input_handler->callbacks;
      if (!callbacks || (input_finished = (void (*)(void))callbacks->input_finished) == 0LL)
      {
        __nwlog_obj();
        unsigned int v8 = a1->default_input_handler;
        uint64_t v9 = "invalid";
        if (v8)
        {
          identifier = v8->identifier;
          if (identifier) {
            uint64_t v9 = (const char *)identifier;
          }
        }

        *(_DWORD *)buf = 136446466;
        uint64_t v82 = "nw_protocol_http_connect_input_finished";
        unsigned int v83 = 2082;
        uint64_t v84 = (void *)v9;
        uint64_t v11 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint64_t v79 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v12 = (os_log_s *)__nwlog_obj();
          uint64_t v13 = type;
          if (!os_log_type_enabled(v12, type)) {
            goto LABEL_138;
          }
          char v14 = a1->default_input_handler;
          os_log_type_t v15 = "invalid";
          if (v14)
          {
            BOOL v16 = v14->identifier;
            if (v16) {
              os_log_type_t v15 = (const char *)v16;
            }
          }

  PBDataWriterWriteBOOLField();
  has = (__int16)self->_has;
  if ((has & 0x100) == 0)
  {
LABEL_20:
    if ((has & 0x2000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_77;
  }

  if (v22) {
    free(v22);
  }
  return -902LL;
}

    free(backtrace_string);
    goto LABEL_93;
  }

  *(void *)os_log_type_t type = 0LL;
  v48 = type;
  uint64_t v49 = 0x2000000000LL;
  os_log_type_t v50 = 0LL;
  if (gLogDatapath)
  {
    uint64_t v28 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v53 = "http2_transport_create_input_frame";
      v54 = 2082;
      v55 = a1 + 205;
      v56 = 1024;
      LODWORD(v57) = v4;
      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s requested input frame of length %u",  buf,  0x1Cu);
    }
  }

  v40[0] = MEMORY[0x1895F87A8];
  v40[1] = 0x40000000LL;
  uint64_t v41 = ___ZL34http2_transport_create_input_frameP27nw_protocol_http2_transportP22http2_transport_streamj_block_invoke;
  uint64_t v42 = &unk_189BBCE38;
  int v46 = v4;
  uint64_t v44 = a1;
  uint64_t v45 = a2;
  os_log_type_t v43 = type;
  uint64_t v6 = *(void *)(a1 + 160);
  do
  {
    if (!v6) {
      break;
    }
    uint64_t v7 = *(void *)(v6 + 16);
    unsigned int v8 = ((uint64_t (*)(void *))v41)(v40);
    uint64_t v6 = v7;
  }

  while ((v8 & 1) != 0);
  if (*((void *)v48 + 3)) {
    goto LABEL_9;
  }
  if (gLogDatapath)
  {
    uint64_t v36 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v53 = "http2_transport_create_input_frame";
      v54 = 2082;
      v55 = a1 + 205;
      v56 = 1024;
      LODWORD(v57) = v4;
      _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s no input frame to reuse for length %u",  buf,  0x1Cu);
    }
  }

  uint64_t v11 = calloc(1uLL, v4);
  if (v11)
  {
    BOOL v12 = (uint64_t)v11;
    goto LABEL_16;
  }

  v37 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v53 = "strict_calloc";
  v54 = 2048;
  v55 = 1LL;
  v56 = 2048;
  os_log_type_t v57 = v4;
  v38 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v38);
  if (!result)
  {
    free(v38);
    BOOL v12 = 0LL;
LABEL_16:
    uint64_t v13 = nw_frame_create(16, v12, v4, (uint64_t)nw_protocol_http2_transport_frame_input_finalizer, 0LL);
    *((void *)v48 + 3) = v13;
    if (v13)
    {
      if ((http2_transport_input_frame_context_reset(v13, a1, a2) & 1) != 0)
      {
        if (!gLogDatapath)
        {
LABEL_10:
          uint64_t v9 = *((void *)v48 + 3);
LABEL_11:
          _Block_object_dispose(type, 8);
          return v9;
        }

        char v14 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v53 = "http2_transport_create_input_frame";
          v54 = 2082;
          v55 = a1 + 205;
          v56 = 1024;
          LODWORD(v57) = v4;
          _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s allocated new input frame of length %u",  buf,  0x1Cu);
        }

      if (v33) {
        free(v33);
      }
      return 0LL;
    }

    if (!v45)
    {
      os_log_type_t v34 = (os_log_s *)__nwlog_obj();
      unint64_t v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_create";
        uint64_t v36 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_74;
      }

      goto LABEL_75;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v34 = (os_log_s *)__nwlog_obj();
    unint64_t v35 = type;
    os_log_type_t v43 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_create";
        uint64_t v36 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_74;
      }

      goto LABEL_75;
    }

    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_create";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v41 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_60;
    }

    if (!v14) {
      goto LABEL_77;
    }
    goto LABEL_76;
  }

  uint64_t v9 = *((void *)handle + 1);
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_http1_get_http1_protocol";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = (os_log_s *)__nwlog_obj();
      BOOL v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_http1_get_http1_protocol";
      uint64_t v17 = "%{public}s called with null handle->http1_stream";
      goto LABEL_74;
    }

    if (!v33)
    {
      os_log_type_t v15 = (os_log_s *)__nwlog_obj();
      BOOL v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_http1_get_http1_protocol";
      uint64_t v17 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_74;
    }

    os_log_type_t v20 = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = (os_log_s *)__nwlog_obj();
    BOOL v16 = type;
    int v26 = os_log_type_enabled(v15, type);
    if (!v20)
    {
      if (!v26) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "nw_http1_get_http1_protocol";
      uint64_t v17 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_74;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_http1_get_http1_protocol";
      v37 = 2082;
      v38 = v20;
      uint64_t v22 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_59;
    }

    goto LABEL_60;
  }

  handle = (_DWORD *)(v9 + 248);
LABEL_10:
  os_log_type_t v10 = *(void *)handle;
  if (!*(void *)handle) {
    goto LABEL_77;
  }
  if (*(void *)(v10 + 328))
  {
    if ((*(_BYTE *)(v10 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)gLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      uint64_t v13 = *(_DWORD *)(v10 + 372);
      *(_DWORD *)buf = 136446978;
      uint64_t v36 = "nw_protocol_http1_add_listen_handler";
      v37 = 2082;
      v38 = (char *)(v10 + 74);
      os_log_type_t v39 = 2080;
      BOOL v40 = " ";
      uint64_t v41 = 1024;
      uint64_t v42 = v13;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> already have a listen handler, ignoring add",  buf,  0x26u);
    }

    return 0LL;
  }

  if ((*(_BYTE *)(v10 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      __int16 v23 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v24 = *(_DWORD *)(v10 + 372);
        *(_DWORD *)buf = 136446978;
        uint64_t v36 = "nw_protocol_http1_add_listen_handler";
        v37 = 2082;
        v38 = (char *)(v10 + 74);
        os_log_type_t v39 = 2080;
        BOOL v40 = " ";
        uint64_t v41 = 1024;
        uint64_t v42 = v24;
        _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> added protocol listen handler",  buf,  0x26u);
      }
    }
  }

  *(void *)(v10 + 328) = a2;
  a2->protocol_handler = (nw_protocol *)v10;
  if ((a3 & 1) != 0) {
    nw_protocol_remove_instance((uint64_t)a1);
  }
  return 1LL;
}

    _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0xCu);
    goto LABEL_76;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 372) & 1) == 0)
    {
      int v4 = handle[14];
      if (v4)
      {
        output_handler = a1->output_handler;
        do
        {
          uint64_t v6 = (uint64_t)output_handler;
          output_handler = output_handler->output_handler;
        }

        while (output_handler);
        do
        {
          uint64_t v7 = v4;
          int v4 = *(void *)(v4 + 32);
        }

        while (v4);
        nw_protocol_set_output_handler(v7, v6);
      }

      unsigned int v8 = handle[15];
      if (v8)
      {
        uint64_t v9 = a1->output_handler;
        do
        {
          os_log_type_t v10 = (uint64_t)v9;
          uint64_t v9 = v9->output_handler;
        }

        while (v9);
        do
        {
          uint64_t v11 = v8;
          unsigned int v8 = *(void *)(v8 + 32);
        }

        while (v8);
        nw_protocol_set_output_handler(v11, v10);
      }

      BOOL v12 = handle[16];
      if (v12)
      {
        uint64_t v13 = a1->output_handler;
        do
        {
          char v14 = (uint64_t)v13;
          uint64_t v13 = v13->output_handler;
        }

        while (v13);
        do
        {
          os_log_type_t v15 = v12;
          BOOL v12 = *(void *)(v12 + 32);
        }

        while (v12);
        nw_protocol_set_output_handler(v15, v14);
      }

      BOOL v16 = handle[17];
      if (v16)
      {
        uint64_t v17 = a1->output_handler;
        do
        {
          uint64_t v18 = (uint64_t)v17;
          uint64_t v17 = v17->output_handler;
        }

        while (v17);
        do
        {
          char v19 = v16;
          BOOL v16 = *(void *)(v16 + 32);
        }

        while (v16);
        nw_protocol_set_output_handler(v19, v18);
      }

      os_log_type_t v20 = handle[18];
      if (v20)
      {
        int v21 = a1->output_handler;
        do
        {
          uint64_t v22 = (uint64_t)v21;
          int v21 = v21->output_handler;
        }

        while (v21);
        do
        {
          __int16 v23 = v20;
          os_log_type_t v20 = *(void *)(v20 + 32);
        }

        while (v20);
        nw_protocol_set_output_handler(v23, v22);
      }

      uint64_t v24 = handle[19];
      if (v24)
      {
        __int16 v25 = a1->output_handler;
        do
        {
          int v26 = (uint64_t)v25;
          __int16 v25 = v25->output_handler;
        }

        while (v25);
        do
        {
          int v27 = v24;
          uint64_t v24 = *(void *)(v24 + 32);
        }

        while (v24);
        nw_protocol_set_output_handler(v27, v26);
      }

      uint64_t v28 = handle[20];
      if (v28)
      {
        unint64_t v29 = a1->output_handler;
        do
        {
          uint64_t v30 = (uint64_t)v29;
          unint64_t v29 = v29->output_handler;
        }

        while (v29);
        do
        {
          os_log_type_t v31 = v28;
          uint64_t v28 = *(void *)(v28 + 32);
        }

        while (v28);
        nw_protocol_set_output_handler(v31, v30);
      }

      uint64_t v32 = handle[21];
      if (v32)
      {
        v33 = a1->output_handler;
        do
        {
          os_log_type_t v34 = (uint64_t)v33;
          v33 = v33->output_handler;
        }

        while (v33);
        do
        {
          unint64_t v35 = v32;
          uint64_t v32 = *(void *)(v32 + 32);
        }

        while (v32);
        nw_protocol_set_output_handler(v35, v34);
      }

      *((_BYTE *)handle + 372) |= 1u;
    }

    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      connected = (void (*)(void))default_input_handler->callbacks->connected;
      if (connected) {
        connected();
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v49 = "nw_protocol_replicate_connected";
  v38 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  int v46 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v39 = (os_log_s *)__nwlog_obj();
    BOOL v40 = type;
    if (!os_log_type_enabled(v39, type)) {
      goto LABEL_76;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v49 = "nw_protocol_replicate_connected";
    uint64_t v41 = "%{public}s called with null replicate";
    goto LABEL_75;
  }

  if (!v46)
  {
    os_log_type_t v39 = (os_log_s *)__nwlog_obj();
    BOOL v40 = type;
    if (!os_log_type_enabled(v39, type)) {
      goto LABEL_76;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v49 = "nw_protocol_replicate_connected";
    uint64_t v41 = "%{public}s called with null replicate, backtrace limit exceeded";
    goto LABEL_75;
  }

  uint64_t v44 = (char *)__nw_create_backtrace_string();
  os_log_type_t v39 = (os_log_s *)__nwlog_obj();
  BOOL v40 = type;
  uint64_t v45 = os_log_type_enabled(v39, type);
  if (!v44)
  {
    if (!v45) {
      goto LABEL_76;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v49 = "nw_protocol_replicate_connected";
    uint64_t v41 = "%{public}s called with null replicate, no backtrace";
    goto LABEL_75;
  }

  if (v45)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v49 = "nw_protocol_replicate_connected";
    os_log_type_t v50 = 2082;
    uint64_t v51 = v44;
    _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s called with null replicate, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v44);
  if (v38) {
LABEL_77:
  }
    free(v38);
}

        if (v45) {
          free(v45);
        }
        int v27 = 0;
        if (v26) {
          goto LABEL_30;
        }
LABEL_78:
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        uint64_t v62 = "__nw_frame_set_service_class";
        uint64_t v51 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint64_t v59 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          if (!os_log_type_enabled(v52, type)) {
            goto LABEL_92;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "__nw_frame_set_service_class";
          v54 = "%{public}s called with null frame";
        }

        else if (v59)
        {
          v55 = (char *)__nw_create_backtrace_string();
          v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          v56 = os_log_type_enabled(v52, type);
          if (v55)
          {
            if (v56)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v62 = "__nw_frame_set_service_class";
              uint64_t v63 = 2082;
              char v64 = v55;
              _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v55);
            goto LABEL_92;
          }

          if (!v56)
          {
LABEL_92:
            if (v51) {
              free(v51);
            }
            goto LABEL_31;
          }

          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "__nw_frame_set_service_class";
          v54 = "%{public}s called with null frame, no backtrace";
        }

        else
        {
          v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          if (!os_log_type_enabled(v52, type)) {
            goto LABEL_92;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "__nw_frame_set_service_class";
          v54 = "%{public}s called with null frame, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
        goto LABEL_92;
      }

      if (!v37) {
        goto LABEL_59;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v62 = "__nw_frame_get_expire_time";
      unint64_t v35 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v62 = "__nw_frame_get_expire_time";
      unint64_t v35 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0xCu);
    goto LABEL_59;
  }

  if ((*(_WORD *)(a2 + 204) & 0x10) == 0) {
    goto LABEL_29;
  }
  os_log_type_t v10 = *(void *)(a2 + 152);
  if (!v10) {
    goto LABEL_29;
  }
  BOOL v12 = a1[6];
  uint64_t v11 = a1[7];
  uint64_t v13 = a1[8];
  char v14 = dword_18C45F3A4;
  if (v11 < 0)
  {
    uint64_t v17 = -1000000 * v11;
    if (!dword_18C45F3A4)
    {
      mach_timebase_info((mach_timebase_info_t)&time_base);
      char v14 = dword_18C45F3A4;
    }

    BOOL v16 = time_base;
    uint64_t v18 = v17 * (unint64_t)v14 / time_base;
    char v19 = v10 >= v18;
    int v21 = v10 - v18;
    os_log_type_t v20 = v21 != 0 && v19;
    if (!v19) {
      int v21 = 0LL;
    }
    if (v20) {
      os_log_type_t v10 = v21;
    }
    if (!v12) {
      goto LABEL_26;
    }
  }

  else
  {
    os_log_type_t v15 = 1000000 * v11;
    if (!dword_18C45F3A4)
    {
      mach_timebase_info((mach_timebase_info_t)&time_base);
      char v14 = dword_18C45F3A4;
    }

    v10 += v15 * (unint64_t)v14 / time_base;
    BOOL v16 = time_base;
    if (!v12) {
      goto LABEL_26;
    }
  }

  if (!v13) {
    goto LABEL_26;
  }
  if (!v14)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    BOOL v16 = time_base;
    char v14 = dword_18C45F3A4;
  }

  uint64_t v22 = 1000000 * v13 * (unint64_t)v14 / v16 + v12;
  if (v22 >= v10) {
LABEL_26:
  }
    uint64_t v22 = v10;
  __int16 v23 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v23)
  {
    __int16 v25 = *(_WORD *)(v23 + 204);
    uint64_t v24 = (_WORD *)(v23 + 204);
    uint64_t *v24 = v25 | 0x10;
    *(void *)(v24 - 26) = v22;
    goto LABEL_29;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v62 = "__nw_frame_set_expire_time";
  v38 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v59 = 0;
  os_log_type_t v39 = (char *)v38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v40 = (os_log_s *)__nwlog_obj();
    uint64_t v41 = type;
    if (!os_log_type_enabled(v40, type)) {
      goto LABEL_99;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v62 = "__nw_frame_set_expire_time";
    uint64_t v42 = "%{public}s called with null frame";
    goto LABEL_98;
  }

  if (!v59)
  {
    BOOL v40 = (os_log_s *)__nwlog_obj();
    uint64_t v41 = type;
    if (!os_log_type_enabled(v40, type)) {
      goto LABEL_99;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v62 = "__nw_frame_set_expire_time";
    uint64_t v42 = "%{public}s called with null frame, backtrace limit exceeded";
    goto LABEL_98;
  }

  os_log_type_t v43 = (char *)__nw_create_backtrace_string();
  BOOL v40 = (os_log_s *)__nwlog_obj();
  uint64_t v41 = type;
  uint64_t v44 = os_log_type_enabled(v40, type);
  if (v43)
  {
    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v62 = "__nw_frame_set_expire_time";
      uint64_t v63 = 2082;
      char v64 = v43;
      _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v43);
    goto LABEL_99;
  }

  if (v44)
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v62 = "__nw_frame_set_expire_time";
    uint64_t v42 = "%{public}s called with null frame, no backtrace";
LABEL_98:
    _os_log_impl(&dword_181A5C000, v40, v41, v42, buf, 0xCu);
  }

                      *(_WORD *)(a1 + 225) &= ~0x40u;
                      goto LABEL_76;
                    }

                    v19 |= 8u;
                    *(_BYTE *)(a1 + 221) = 8;
                    ++v20;
                  }
                }

                if ((v19 & 2) != 0)
                {
                  __nwlog_obj();
                  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    uint64_t v32 = "nw_ws_validate_client_request";
                    v33 = 2082;
                    os_log_type_t v34 = (const char *)(a1 + 227);
                    __int16 v23 = "%{public}s %{public}s Duplicate value for client_no_context_takeover";
                    goto LABEL_68;
                  }

                  goto LABEL_75;
                }

                v19 |= 2u;
                *(_WORD *)(a1 + 225) &= ~0x100u;
                ++v20;
              }
            }
          }
        }

        ++v14;
      }

    if (v44) {
      free(v44);
    }
    int v4 = 0xFFFFFFFFLL;
    uint64_t v11 = __CFADD__((_DWORD)v38, v40);
    v38 = v38 + v40;
    if (!v11) {
      goto LABEL_52;
    }
LABEL_79:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    uint64_t v79 = "nw_frame_array_get_frame_count";
    os_log_type_t v80 = 2082;
    uint64_t v81 = "byte_count";
    uint64_t v82 = 2048;
    unsigned int v83 = v40;
    uint64_t v84 = 2048;
    v85 = v38;
    v56 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v76 = 0;
    if (__nwlog_fault(v56, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v57 = gLogObj;
        BOOL v58 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v79 = "nw_frame_array_get_frame_count";
          os_log_type_t v80 = 2082;
          uint64_t v81 = "byte_count";
          uint64_t v82 = 2048;
          unsigned int v83 = v40;
          uint64_t v84 = 2048;
          v85 = v38;
          uint64_t v59 = (os_log_s *)v57;
          uint64_t v60 = v58;
          os_log_type_t v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_92:
          _os_log_impl(&dword_181A5C000, v59, v60, v61, buf, 0x2Au);
        }
      }

      else if (v76)
      {
        uint64_t v62 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v63 = (os_log_s *)gLogObj;
        char v64 = type;
        unsigned int v65 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v62)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136447234;
            uint64_t v79 = "nw_frame_array_get_frame_count";
            os_log_type_t v80 = 2082;
            uint64_t v81 = "byte_count";
            uint64_t v82 = 2048;
            unsigned int v83 = v40;
            uint64_t v84 = 2048;
            v85 = v38;
            uint64_t v86 = 2082;
            os_log_type_t v87 = v62;
            _os_log_impl( &dword_181A5C000,  v63,  v64,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v62);
          goto LABEL_93;
        }

        if (v65)
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v79 = "nw_frame_array_get_frame_count";
          os_log_type_t v80 = 2082;
          uint64_t v81 = "byte_count";
          uint64_t v82 = 2048;
          unsigned int v83 = v40;
          uint64_t v84 = 2048;
          v85 = v38;
          uint64_t v59 = v63;
          uint64_t v60 = v64;
          os_log_type_t v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_92;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v66 = gLogObj;
        v67 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v79 = "nw_frame_array_get_frame_count";
          os_log_type_t v80 = 2082;
          uint64_t v81 = "byte_count";
          uint64_t v82 = 2048;
          unsigned int v83 = v40;
          uint64_t v84 = 2048;
          v85 = v38;
          uint64_t v59 = (os_log_s *)v66;
          uint64_t v60 = v67;
          os_log_type_t v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_92;
        }
      }
    }

        uint64_t v63 = 0LL;
        goto LABEL_76;
      default:
        __nwlog_obj();
        uint64_t v7 = (id *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
        if ((*(_BYTE *)&v6->_has & 1) != 0) {
          command = v6->_command;
        }
        else {
          command = 0;
        }
        *(_DWORD *)buf = 136446466;
        unsigned int v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        uint64_t v84 = 1024;
        LODWORD(v85) = command;
        unsigned int v8 = "%{public}s Unknown command %u sent to connection receiver";
        uint64_t v9 = (os_log_s *)v7;
        os_log_type_t v10 = 18;
        goto LABEL_15;
    }
  }

  __nwlog_obj();
  os_log_type_t v72 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  unsigned int v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
  v73 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v79 = 0;
  if (__nwlog_fault(v73, &type, &v79))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        os_log_type_t v76 = "%{public}s called with null commandData";
LABEL_103:
        _os_log_impl(&dword_181A5C000, v74, v75, v76, buf, 0xCu);
      }
    }

    else
    {
      if (v79)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v75 = type;
        uint64_t v78 = os_log_type_enabled(v74, type);
        if (backtrace_string)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            unsigned int v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
            uint64_t v84 = 2082;
            v85 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s called with null commandData, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_105;
        }

        if (!v78) {
          goto LABEL_104;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        os_log_type_t v76 = "%{public}s called with null commandData, no backtrace";
        goto LABEL_103;
      }

      __nwlog_obj();
      v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        os_log_type_t v76 = "%{public}s called with null commandData, backtrace limit exceeded";
        goto LABEL_103;
      }
    }

    free(backtrace_string);
    goto LABEL_90;
  }

  if (a3 && a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
    os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();
    v65[0] = 16;
    v63[0] = 0;
    if (v65[0] == 17)
    {
      uint64_t v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = v65[0];
      if (os_log_type_enabled(v44, (os_log_type_t)v65[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        int v46 = "%{public}s called with null (!(indeterminate && body_length > 0))";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (!v63[0])
    {
      uint64_t v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = v65[0];
      if (os_log_type_enabled(v44, (os_log_type_t)v65[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        int v46 = "%{public}s called with null (!(indeterminate && body_length > 0)), backtrace limit exceeded";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v44 = (os_log_s *)__nwlog_obj();
    uint64_t v45 = v65[0];
    v54 = os_log_type_enabled(v44, (os_log_type_t)v65[0]);
    if (!backtrace_string)
    {
      if (v54)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        int v46 = "%{public}s called with null (!(indeterminate && body_length > 0)), no backtrace";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (v54)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v49 = "%{public}s called with null (!(indeterminate && body_length > 0)), dumping backtrace:%{public}s";
      goto LABEL_74;
    }

    goto LABEL_75;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  uint64_t v68 = 0LL;
  os_log_type_t type = nw_http_metadata_get_type(a1);
  ++*(void *)(*(void *)&buf[8] + 24LL);
  uint64_t v7 = MEMORY[0x1895F87A8];
  if (type == 1)
  {
    unsigned int v8 = nw_http_metadata_copy_request(a1);
    if (v8)
    {
      v62[0] = v7;
      v62[1] = 0x40000000LL;
      v62[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke;
      v62[3] = &unk_189BBF7A0;
      v62[4] = buf;
      uint64_t v9 = v8;
      os_log_type_t v10 = v62;
      _nw_http_request_access_method((uint64_t)v9, v10);

      v61[0] = v7;
      v61[1] = 0x40000000LL;
      v61[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_2;
      v61[3] = &unk_189BBF7C8;
      v61[4] = buf;
      uint64_t v11 = v9;
      BOOL v12 = v61;
      _nw_http_request_access_scheme((uint64_t)v11, v12);

      v60[0] = v7;
      v60[1] = 0x40000000LL;
      v60[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_3;
      v60[3] = &unk_189BBF7F0;
      v60[4] = buf;
      uint64_t v13 = v11;
      char v14 = v60;
      _nw_http_request_access_authority((uint64_t)v13, v14);

      v59[0] = v7;
      v59[1] = 0x40000000LL;
      v59[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_4;
      v59[3] = &unk_189BBF818;
      v59[4] = buf;
      os_log_type_t v15 = v13;
      BOOL v16 = v59;
      _nw_http_request_access_path((uint64_t)v15, v16);

LABEL_12:
      os_release(v15);
      goto LABEL_13;
    }

    __nwlog_obj();
    *(_DWORD *)unsigned int v65 = 136446210;
    *(void *)&v65[4] = "nw_http_get_binary_message_length_inner";
    os_log_type_t v50 = (char *)_os_log_send_and_compose_impl();
    v63[0] = 16;
    LOBYTE(v69) = 0;
    if (__nwlog_fault(v50, v63, &v69))
    {
      if (v63[0] == 17)
      {
        uint64_t v51 = (os_log_s *)__nwlog_obj();
        v52 = v63[0];
        if (os_log_type_enabled(v51, (os_log_type_t)v63[0]))
        {
          *(_DWORD *)unsigned int v65 = 136446210;
          *(void *)&v65[4] = "nw_http_get_binary_message_length_inner";
          os_log_type_t v53 = "%{public}s called with null request";
LABEL_97:
          _os_log_impl(&dword_181A5C000, v51, v52, v53, v65, 0xCu);
        }
      }

      else if ((_BYTE)v69)
      {
        v55 = (char *)__nw_create_backtrace_string();
        uint64_t v51 = (os_log_s *)__nwlog_obj();
        v52 = v63[0];
        v56 = os_log_type_enabled(v51, (os_log_type_t)v63[0]);
        if (v55)
        {
          if (v56)
          {
            *(_DWORD *)unsigned int v65 = 136446466;
            *(void *)&v65[4] = "nw_http_get_binary_message_length_inner";
            *(_WORD *)&v65[12] = 2082;
            *(void *)&v65[14] = v55;
            _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s called with null request, dumping backtrace:%{public}s",  v65,  0x16u);
          }

          free(v55);
          goto LABEL_98;
        }

        if (v56)
        {
          *(_DWORD *)unsigned int v65 = 136446210;
          *(void *)&v65[4] = "nw_http_get_binary_message_length_inner";
          os_log_type_t v53 = "%{public}s called with null request, no backtrace";
          goto LABEL_97;
        }
      }

      else
      {
        uint64_t v51 = (os_log_s *)__nwlog_obj();
        v52 = v63[0];
        if (os_log_type_enabled(v51, (os_log_type_t)v63[0]))
        {
          *(_DWORD *)unsigned int v65 = 136446210;
          *(void *)&v65[4] = "nw_http_get_binary_message_length_inner";
          os_log_type_t v53 = "%{public}s called with null request, backtrace limit exceeded";
          goto LABEL_97;
        }
      }
    }

    free(backtrace_string);
    goto LABEL_90;
  }

  uint64_t v3 = bswap32(*(_DWORD *)a2);
  int v4 = v3 & 0xFF000000;
  if ((v3 & 0xFF000000) == 0 || v4 == 2130706432) {
    return 0LL;
  }
  uint64_t v6 = v3 & 0xFFFF0000;
  uint64_t v7 = v3 >> 8 == 12605539 || v6 == -1442971648;
  if (v7 || (v3 & 0xFFFFFFF8) == -1073741824) {
    return 0LL;
  }
  BOOL result = 0LL;
  if (*(_DWORD *)a2 != -1 && (v3 & 0xF0000000) != 0xE0000000)
  {
    if (*__src ^ 0x9BFF64000000000CLL | __src[1]
      || (BOOL result = 0LL, v3 >> 22 != 401) && v6 != -1062731776 && v4 != 167772160 && (v3 & 0xFFF00000) != 0xAC100000)
    {
      *(void *)__dst = 0LL;
      *((void *)__dst + 1) = 0LL;
      switch(*(_DWORD *)__src)
      {
        case 4:
          *((_DWORD *)__dst + 1) = *(_DWORD *)a2;
          goto LABEL_36;
        case 5:
          uint64_t v11 = *a2;
          __dst[7] = *((_BYTE *)a2 + 2);
          *(_WORD *)(__dst + 5) = v11;
          __dst[9] = *((_BYTE *)a2 + 3);
          goto LABEL_36;
        case 6:
          *((_WORD *)__dst + 3) = *a2;
          *(_WORD *)(__dst + 9) = a2[1];
          goto LABEL_36;
        case 7:
          __dst[7] = *(_BYTE *)a2;
          BOOL v12 = *(__int16 *)((char *)a2 + 1);
          __dst[11] = *((_BYTE *)a2 + 3);
          *(_WORD *)(__dst + 9) = v12;
          goto LABEL_36;
        case 8:
          *(_DWORD *)(__dst + 9) = *(_DWORD *)a2;
          goto LABEL_36;
        case 0xC:
          *((_DWORD *)__dst + 3) = *(_DWORD *)a2;
LABEL_36:
          memcpy(__dst, (char *)__src + 4, *(unsigned int *)__src);
          return 1LL;
        default:
          __nwlog_obj();
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
          char v14 = *(_DWORD *)__src;
          *(_DWORD *)buf = 136446466;
          BOOL v40 = "nw_nat64_synthesize_v6";
          uint64_t v41 = 1024;
          *(_DWORD *)uint64_t v42 = v14;
          os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v37 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              uint64_t v18 = *(_DWORD *)__src;
              *(_DWORD *)buf = 136446466;
              BOOL v40 = "nw_nat64_synthesize_v6";
              uint64_t v41 = 1024;
              *(_DWORD *)uint64_t v42 = v18;
              char v19 = "%{public}s invalid prefix length %d";
LABEL_46:
              _os_log_impl(&dword_181A5C000, v16, v17, v19, buf, 0x12u);
              goto LABEL_47;
            }

            goto LABEL_47;
          }

          if (!v37)
          {
            __nwlog_obj();
            BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              __int16 v23 = *(_DWORD *)__src;
              *(_DWORD *)buf = 136446466;
              BOOL v40 = "nw_nat64_synthesize_v6";
              uint64_t v41 = 1024;
              *(_DWORD *)uint64_t v42 = v23;
              char v19 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
              goto LABEL_46;
            }

      free(v38);
      if (!browser_key_for) {
        goto LABEL_55;
      }
      goto LABEL_54;
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_browser_start_query_record_for_endpoint_locked";
    browser_key_for = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(out_signature_length) = 0;
    if (__nwlog_fault((const char *)browser_key_for, type, &out_signature_length))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v35 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A5C000, v20, v35, "%{public}s called with null endpoint", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (!(_BYTE)out_signature_length)
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl( &dword_181A5C000,  v20,  v43,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_52;
      }

      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type[0];
      BOOL v40 = os_log_type_enabled(v20, type[0]);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_181A5C000, v20, v39, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v48 = "nw_browser_start_query_record_for_endpoint_locked";
        uint64_t v49 = 2082;
        *(void *)os_log_type_t v50 = v38;
        _os_log_impl( &dword_181A5C000,  v20,  v39,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_75;
    }
  }

    free(backtrace_string);
    goto LABEL_94;
  }

  if (!txt_len)
  {
    __nwlog_obj();
    unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_txt_record_create_with_bytes";
    int v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_181A5C000, v27, v30, "%{public}s txt_record cannot have length 0", buf, 0xCu);
      }

      goto LABEL_93;
    }

    if (!v45)
    {
      __nwlog_obj();
      int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl( &dword_181A5C000,  v27,  v43,  "%{public}s txt_record cannot have length 0, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_93;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v38 = type;
    os_log_type_t v39 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_181A5C000, v27, v38, "%{public}s txt_record cannot have length 0, no backtrace", buf, 0xCu);
      }

      goto LABEL_93;
    }

    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v48 = "nw_txt_record_create_with_bytes";
      uint64_t v49 = 2082;
      os_log_type_t v50 = (size_t)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v27,  v38,  "%{public}s txt_record cannot have length 0, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_75;
  }

  if (txt_len >= 0x10000)
  {
    __nwlog_obj();
    os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_txt_record_create_with_bytes";
    int v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v45 = 0;
    if (__nwlog_fault(v26, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v32 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl(&dword_181A5C000, v27, v32, "%{public}s txt_record cannot have length > 65535", buf, 0xCu);
        }

    __break(1u);
    return v31;
  }

  __nwlog_obj();
  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v48 = "nw_txt_record_set_key";
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v45 = 0;
  if (__nwlog_fault(v13, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_181A5C000, v14, v33, "%{public}s called with null txt_record", buf, 0xCu);
      }

    free(backtrace_string);
    goto LABEL_94;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
    v37 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v50 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        BOOL v40 = "%{public}s called with null http3_stream";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    if (!v50)
    {
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        BOOL v40 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = (os_log_s *)__nwlog_obj();
    os_log_type_t v39 = type;
    uint64_t v45 = os_log_type_enabled(v38, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        BOOL v40 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    if (v45)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
      v54 = 2082;
      *(void *)v55 = backtrace_string;
      uint64_t v44 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_74;
    }

    goto LABEL_75;
  }

  if (gLogDatapath)
  {
    uint64_t v41 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
      v54 = 2048;
      *(void *)v55 = handle;
      _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }

  uint64_t v11 = handle[8];
  if (v11 == -1LL || *((_BYTE *)handle + 130))
  {
    BOOL v12 = 0;
    output_handler = a1->output_handler;
    if (!output_handler) {
      return 0LL;
    }
    goto LABEL_23;
  }

  if (v11 < 0x40)
  {
    BOOL v12 = 1;
    goto LABEL_18;
  }

  if (v11 < 0x4000)
  {
    BOOL v12 = 2;
    goto LABEL_18;
  }

  if (!(v11 >> 30))
  {
    BOOL v12 = 4;
    goto LABEL_18;
  }

  if (!(v11 >> 62))
  {
    BOOL v12 = 8;
    goto LABEL_18;
  }

  char v14 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  os_log_type_t v53 = "_http_vle_length";
  v54 = 2048;
  *(void *)v55 = v11;
  os_log_type_t v15 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v15);
  if (!result)
  {
    free(v15);
    BOOL v12 = 0;
LABEL_18:
    uint64_t v17 = __CFADD__(a3, v12);
    uint64_t v18 = a3 + v12;
    if (v17)
    {
      if (gLogDatapath)
      {
        uint64_t v49 = handle;
        int v46 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
          v54 = 2082;
          *(void *)v55 = "minimum_bytes";
          *(_WORD *)&v55[8] = 2048;
          *(void *)v56 = v12;
          *(_WORD *)&v56[8] = 2048;
          os_log_type_t v57 = v18;
          _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
        }

        handle = v49;
        uint64_t v17 = __CFADD__(a4, v12);
        char v19 = a4 + v12;
        if (!v17)
        {
LABEL_22:
          output_handler = a1->output_handler;
          if (!output_handler) {
            return 0LL;
          }
LABEL_23:
          callbacks = output_handler->callbacks;
          if (!callbacks) {
            return 0LL;
          }
          get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *))callbacks->get_output_frames;
          if (!get_output_frames) {
            return 0LL;
          }
          uint64_t v22 = get_output_frames(output_handler, a1);
          if (!(_DWORD)v22 || !v12) {
            return v22;
          }
          tqh_first = a6->tqh_first;
          uint64_t v24 = nw_frame_unclaimed_length(tqh_first);
          if (v24 >= v12)
          {
            if (nw_frame_uses_external_data((uint64_t)tqh_first))
            {
              os_log_type_t v31 = (uint64_t)tqh_first;
              uint64_t v32 = 0;
              v33 = v12;
            }

            else
            {
              os_log_type_t v31 = (uint64_t)tqh_first;
              uint64_t v32 = v12;
              v33 = 0;
            }

            nw_frame_claim(v31, v30, v32, v33);
            *((_BYTE *)handle + 130) = v12;
            return v22;
          }

          __int16 v25 = v24;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446722;
          os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
          v54 = 1024;
          *(_DWORD *)v55 = v12;
          *(_WORD *)&v55[4] = 1024;
          *(_DWORD *)&v55[6] = v25;
          int v26 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          os_log_type_t v50 = 0;
          if (__nwlog_fault(v26, &type, &v50))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v27 = (os_log_s *)gLogObj;
              uint64_t v28 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                goto LABEL_51;
              }
              *(_DWORD *)buf = 136446722;
              os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              unint64_t v29 = "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u)";
LABEL_50:
              _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0x18u);
              goto LABEL_51;
            }

            if (!v50)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v27 = (os_log_s *)gLogObj;
              uint64_t v28 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                goto LABEL_51;
              }
              *(_DWORD *)buf = 136446722;
              os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              unint64_t v29 = "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u), backtrace limit exceeded";
              goto LABEL_50;
            }

            os_log_type_t v34 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v27 = (os_log_s *)gLogObj;
            uint64_t v28 = type;
            unint64_t v35 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (!v34)
            {
              if (!v35) {
                goto LABEL_51;
              }
              *(_DWORD *)buf = 136446722;
              os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              unint64_t v29 = "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u), no backtrace";
              goto LABEL_50;
            }

            if (v35)
            {
              *(_DWORD *)buf = 136446978;
              os_log_type_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              *(_WORD *)v56 = 2082;
              *(void *)&v56[2] = v34;
              _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u), dumping backtrace:%{public}s",  buf,  0x22u);
            }

            free(v34);
          }

  if (v20) {
    free(v20);
  }
  return 0LL;
}

  if (v22) {
    free(v22);
  }
  return 0LL;
}

    goto LABEL_81;
  }

  memset(out, 0, sizeof(out));
  uuid_unparse(a5, out);
  v54 = 0LL;
  asprintf(&v54, "%s%s%s%s%s", a3, "<token=", out, ">", a4);
  if (!v54)
  {
    __nwlog_obj();
    int v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t type = 136446210;
    v56 = "nw_proxy_hop_add_token_header";
    uint64_t v13 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t v53 = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (v53 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v28 = v53;
      if (os_log_type_enabled(v27, v53))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        v56 = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null value", (uint8_t *)type, 0xCu);
      }

    goto LABEL_76;
  }

  unsigned int v8 = v5;
  uint64_t v9 = *((id *)v8 + 1);

  if (nw_protocol_copy_http_connection_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_connection_definition_onceToken, &__block_literal_global_62);
  }
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v9,  nw_protocol_copy_http_connection_definition_definition);

  if (!is_equal_unsafe)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v19 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s metadata must be http_connection", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (!v39)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v35 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl( &dword_181A5C000,  v16,  v35,  "%{public}s metadata must be http_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_75;
    }

    int v27 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v28 = type;
    unint64_t v29 = os_log_type_enabled(v16, type);
    if (!v27)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl(&dword_181A5C000, v16, v28, "%{public}s metadata must be http_connection, no backtrace", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
      os_log_type_t v43 = 2082;
      uint64_t v44 = v27;
      _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s metadata must be http_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_50;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl(&dword_181A5C000, v16, v21, "%{public}s called with null closed_handler", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (!v39)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v36 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl( &dword_181A5C000,  v16,  v36,  "%{public}s called with null closed_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_75;
    }

    int v27 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v30 = type;
    os_log_type_t v31 = os_log_type_enabled(v16, type);
    if (!v27)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl(&dword_181A5C000, v16, v30, "%{public}s called with null closed_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
      os_log_type_t v43 = 2082;
      uint64_t v44 = v27;
      _os_log_impl( &dword_181A5C000,  v16,  v30,  "%{public}s called with null closed_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_50;
  }

  if (!v7)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v23 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl(&dword_181A5C000, v16, v23, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (!v39)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl( &dword_181A5C000,  v16,  v37,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_75;
    }

    int v27 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v32 = type;
    v33 = os_log_type_enabled(v16, type);
    if (!v27)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
        _os_log_impl(&dword_181A5C000, v16, v32, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_75;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v42 = "nw_http_connection_metadata_set_connection_closed_handler";
      os_log_type_t v43 = 2082;
      uint64_t v44 = v27;
      _os_log_impl( &dword_181A5C000,  v16,  v32,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
    }

          goto LABEL_76;
        }
      }

      else
      {
        uint64_t v28 = v7[2];
        if (!v28 || nw_path_parameters_get_logging_disabled(v28[13]))
        {
          os_log_type_t v10 = 0LL;
          effective_process_name = 0LL;
          goto LABEL_76;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v11 = (id)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR))
        {
          unint64_t v29 = *((_DWORD *)v7 + 112);
          *(_DWORD *)buf = 136446466;
          uint64_t v62 = "nw_report_excessive_data_usage_event";
          uint64_t v63 = 1024;
          LODWORD(v64) = v29;
          _os_log_impl( &dword_181A5C000,  (os_log_t)v11,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Connection has no path",  buf,  0x12u);
        }
      }

      effective_process_name = 0LL;
      goto LABEL_75;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v62 = "nw_report_excessive_data_usage_event";
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v59 = 0;
    if (__nwlog_fault(v20, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "nw_report_excessive_data_usage_event";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v59)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)(id)gLogObj;
        int v26 = type;
        int v27 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v62 = "nw_report_excessive_data_usage_event";
            uint64_t v63 = 2082;
            char v64 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v20) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }

        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "nw_report_excessive_data_usage_event";
          _os_log_impl(&dword_181A5C000, v21, v26, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)(id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "nw_report_excessive_data_usage_event";
          _os_log_impl( &dword_181A5C000,  v21,  v33,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v20)
    {
LABEL_53:
      effective_process_name = 0LL;
LABEL_78:

      goto LABEL_79;
    }

      free(backtrace_string);
      goto LABEL_97;
    }

    __int16 v23 = (os_log_s *)__nwlog_obj();
    uint64_t v24 = type[0];
    if (!os_log_type_enabled(v23, type[0])) {
      goto LABEL_97;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
    __int16 v25 = "%{public}s called with null protocol";
LABEL_96:
    _os_log_impl(&dword_181A5C000, v23, v24, v25, buf, 0xCu);
LABEL_97:
    if (v22) {
      free(v22);
    }
    return 0LL;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v74 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v23 = (os_log_s *)__nwlog_obj();
      uint64_t v24 = type[0];
      if (!os_log_type_enabled(v23, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
      __int16 v25 = "%{public}s called with null http2";
      goto LABEL_96;
    }

    if (v74 == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v23 = (os_log_s *)__nwlog_obj();
      uint64_t v24 = type[0];
      if (!os_log_type_enabled(v23, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
      __int16 v25 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_96;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v23 = (os_log_s *)__nwlog_obj();
    uint64_t v24 = type[0];
    unint64_t v35 = os_log_type_enabled(v23, type[0]);
    if (backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
        BOOL v77 = 2082;
        uint64_t v78 = backtrace_string;
        os_log_type_t v34 = "%{public}s called with null http2, dumping backtrace:%{public}s";
        goto LABEL_74;
      }

      goto LABEL_75;
    }

    if (!v35) {
      goto LABEL_97;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
    __int16 v25 = "%{public}s called with null http2, no backtrace";
    goto LABEL_96;
  }

  uint64_t v7 = *((_WORD *)handle + 194);
  if (v7 < 0 || !gLogDatapath)
  {
    if (*((void *)handle + 18)) {
      goto LABEL_6;
    }
LABEL_50:
    if ((v7 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v36 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v37 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
        BOOL v77 = 2082;
        uint64_t v78 = handle + 390;
        uint64_t v79 = 2080;
        os_log_type_t v80 = " ";
        uint64_t v81 = 1024;
        uint64_t v82 = v37;
        _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> added protocol listen handler",  buf,  0x26u);
      }
    }

    *((void *)handle + 18) = a2;
    a2->protocol_handler = a1;
    if ((a3 & 1) != 0) {
      nw_protocol_remove_instance((uint64_t)a1);
    }
    if ((*((_WORD *)handle + 194) & 0x1000) == 0) {
      return 1LL;
    }
    if ((*((_WORD *)handle + 194) & 0x8000) == 0)
    {
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v38 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v39 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          os_log_type_t v76 = "nw_protocol_http2_add_listen_handler";
          BOOL v77 = 2082;
          uint64_t v78 = handle + 390;
          uint64_t v79 = 2080;
          os_log_type_t v80 = " ";
          uint64_t v81 = 1024;
          uint64_t v82 = v39;
          _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> waiting for listen handler, resuming processing of connected",  buf,  0x26u);
        }
      }

      uint64_t v28 = *((__int16 *)handle + 194);
      if (v28 < 0)
      {
        if ((v28 & 0x80) == 0)
        {
LABEL_60:
          if ((v28 & 0x8000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            unint64_t v29 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v30 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446978;
              os_log_type_t v76 = "nw_protocol_http2_process_connected";
              BOOL v77 = 2082;
              uint64_t v78 = handle + 390;
              uint64_t v79 = 2080;
              os_log_type_t v80 = " ";
              uint64_t v81 = 1024;
              uint64_t v82 = v30;
              os_log_type_t v31 = "%{public}s %{public}s%s<i%u> not server, processing input without waiting";
LABEL_159:
              _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_DEBUG, v31, buf, 0x26u);
              goto LABEL_104;
            }
          }

          goto LABEL_104;
        }

              if (v24) {
                free(v24);
              }
              os_release(v8);
              return 0LL;
            }
          }

          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
          os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          uint64_t v66 = 0;
          if (__nwlog_fault(v20, type, &v66))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              int v21 = (os_log_s *)__nwlog_obj();
              uint64_t v22 = type[0];
              if (!os_log_type_enabled(v21, type[0])) {
                goto LABEL_66;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
              __int16 v23 = "%{public}s called with null definition";
              goto LABEL_65;
            }

            if (!v66)
            {
              int v21 = (os_log_s *)__nwlog_obj();
              uint64_t v22 = type[0];
              if (!os_log_type_enabled(v21, type[0])) {
                goto LABEL_66;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
              __int16 v23 = "%{public}s called with null definition, backtrace limit exceeded";
              goto LABEL_65;
            }

            uint64_t v32 = (char *)__nw_create_backtrace_string();
            int v21 = (os_log_s *)__nwlog_obj();
            uint64_t v22 = type[0];
            v33 = os_log_type_enabled(v21, type[0]);
            if (!v32)
            {
              if (!v33) {
                goto LABEL_66;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
              __int16 v23 = "%{public}s called with null definition, no backtrace";
              goto LABEL_65;
            }

            if (v33)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v32;
              os_log_type_t v34 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_48:
              _os_log_impl(&dword_181A5C000, v21, v22, v34, buf, 0x16u);
              goto LABEL_49;
            }

            goto LABEL_49;
          }

          goto LABEL_66;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
        os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        uint64_t v66 = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v21 = (os_log_s *)__nwlog_obj();
          uint64_t v22 = type[0];
          if (!os_log_type_enabled(v21, type[0])) {
            goto LABEL_66;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
          __int16 v23 = "%{public}s called with null parameters";
        }

        else if (v66)
        {
          uint64_t v32 = (char *)__nw_create_backtrace_string();
          int v21 = (os_log_s *)__nwlog_obj();
          uint64_t v22 = type[0];
          os_log_type_t v53 = os_log_type_enabled(v21, type[0]);
          if (v32)
          {
            if (v53)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v32;
              os_log_type_t v34 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
              goto LABEL_48;
            }

            goto LABEL_49;
          }

          if (!v53) {
            goto LABEL_66;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
          __int16 v23 = "%{public}s called with null parameters, no backtrace";
        }

        else
        {
          int v21 = (os_log_s *)__nwlog_obj();
          uint64_t v22 = type[0];
          if (!os_log_type_enabled(v21, type[0])) {
            goto LABEL_66;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_access_options";
          __int16 v23 = "%{public}s called with null parameters, backtrace limit exceeded";
        }

  if (v8) {
LABEL_76:
  }
    free(v8);
  return 0LL;
}

  if (v8) {
LABEL_76:
  }
    free(v8);
  return 0LL;
}

          if (v240) {
            free(v240);
          }
          os_log_type_t v31 = v245;
          goto LABEL_78;
        }

        if (v252)
        {
          int v46 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v52 = gLogObj;
          v232 = type[0];
          os_log_type_t v53 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v46)
          {
            if (v53)
            {
              *(_DWORD *)buf = 136446466;
              v254 = "__nw_frame_set_segment_count";
              v255 = 2082;
              v256[0] = v46;
              uint64_t v49 = (os_log_s *)v52;
              os_log_type_t v50 = v232;
              uint64_t v51 = "%{public}s Attempt to set segment-count on a chain-member, dumping backtrace:%{public}s";
LABEL_64:
              _os_log_impl(&dword_181A5C000, v49, v50, v51, buf, 0x16u);
            }

            goto LABEL_65;
          }

          if (!v53) {
            goto LABEL_75;
          }
          *(_DWORD *)buf = 136446210;
          v254 = "__nw_frame_set_segment_count";
          BOOL v40 = (os_log_s *)v52;
          uint64_t v41 = v232;
          uint64_t v42 = "%{public}s Attempt to set segment-count on a chain-member, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = gLogObj;
          os_log_type_t v57 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_75;
          }
          *(_DWORD *)buf = 136446210;
          v254 = "__nw_frame_set_segment_count";
          BOOL v40 = (os_log_s *)v56;
          uint64_t v41 = v57;
          uint64_t v42 = "%{public}s Attempt to set segment-count on a chain-member, backtrace limit exceeded";
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v37 = (const char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v252 = OS_LOG_TYPE_DEFAULT;
        v240 = (char *)v37;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = gLogObj;
          os_log_type_t v39 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v254 = "nw_channel_add_input_frames";
            BOOL v40 = (os_log_s *)v38;
            uint64_t v41 = v39;
            uint64_t v42 = "%{public}s No segment-count set on single-IP aggregate";
            goto LABEL_74;
          }

          goto LABEL_75;
        }

        if (v252)
        {
          int v46 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v47 = gLogObj;
          v231 = type[0];
          v48 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v46)
          {
            if (v48)
            {
              *(_DWORD *)buf = 136446466;
              v254 = "nw_channel_add_input_frames";
              v255 = 2082;
              v256[0] = v46;
              uint64_t v49 = (os_log_s *)v47;
              os_log_type_t v50 = v231;
              uint64_t v51 = "%{public}s No segment-count set on single-IP aggregate, dumping backtrace:%{public}s";
              goto LABEL_64;
            }

LABEL_98:
        if (v67) {
          free(v67);
        }
        *((_WORD *)v24 + 14) = 0;
        uint64_t v22 = v143;
LABEL_101:
        if (!v23) {
          goto LABEL_120;
        }
        unsigned int v83 = (unsigned __int16)(*((_WORD *)v23 + 14))-- - 1;
        if (v83 < 0x10000) {
          goto LABEL_120;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v84 = *((unsigned __int16 *)v23 + 14);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        __int16 v148 = 2082;
        v149 = "next_node->apply_count";
        __int16 v150 = 2048;
        uint64_t v151 = 1LL;
        __int16 v152 = 2048;
        uint64_t v153 = v84;
        v85 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v144 = 0;
        if (__nwlog_fault(v85, &type, &v144))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v86 = gLogObj;
            os_log_type_t v87 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v88 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "next_node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v88;
              v89 = (os_log_s *)v86;
              os_log_type_t v90 = v87;
              v91 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_116:
              _os_log_impl(&dword_181A5C000, v89, v90, v91, buf, 0x2Au);
            }
          }

          else if (v144)
          {
            v92 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v93 = (os_log_s *)gLogObj;
            os_log_type_t v94 = type;
            BOOL v95 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v92)
            {
              if (v95)
              {
                uint64_t v96 = *((unsigned __int16 *)v23 + 14);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                __int16 v148 = 2082;
                v149 = "next_node->apply_count";
                __int16 v150 = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v96;
                __int16 v154 = 2082;
                v155 = v92;
                _os_log_impl( &dword_181A5C000,  v93,  v94,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v92);
              goto LABEL_117;
            }

            if (v95)
            {
              uint64_t v100 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "next_node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v100;
              v89 = v93;
              os_log_type_t v90 = v94;
              v91 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_116;
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v97 = gLogObj;
            os_log_type_t v98 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v99 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "next_node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v99;
              v89 = (os_log_s *)v97;
              os_log_type_t v90 = v98;
              v91 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_116;
            }
          }
        }

        goto LABEL_99;
      }

      if (!v57)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)uu = 136446466;
          *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl( &dword_181A5C000,  v22,  v50,  "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded",  uu,  0x12u);
        }

        goto LABEL_98;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = type;
      uint64_t v49 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)uu = 136446466;
          *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl( &dword_181A5C000,  v22,  v48,  "%{public}s Custom data size must be no larger than %d, no backtrace",  uu,  0x12u);
        }

        goto LABEL_98;
      }

      if (v49)
      {
        *(_DWORD *)uu = 136446722;
        *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
        *(_WORD *)&uu[12] = 1024;
        *(_DWORD *)&uu[14] = 1024;
        os_log_type_t v61 = 2082;
        uint64_t v62 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v22,  v48,  "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s",  uu,  0x1Cu);
      }

      free(backtrace_string);
LABEL_99:
      if (v21) {
        free(v21);
      }
LABEL_101:
      os_log_type_t v10 = 28LL;
LABEL_9:

      uint64_t v11 = v10 + 5;
      if ((a3 & 1) != 0)
      {
        *(void *)uu = 0LL;
        *(void *)&uu[8] = 0LL;
        nw_endpoint_get_agent_identifier(v5, uu);
        if (!uuid_is_null(uu)) {
          uint64_t v11 = v10 + 26;
        }
      }

      if ((a3 & 2) != 0)
      {
        device_id = (const char *)nw_endpoint_get_device_id(v5);
        if (device_id) {
          uint64_t v13 = strlen(device_id) + 5;
        }
        else {
          uint64_t v13 = 0LL;
        }
        v11 += v13;
      }

      if ((a3 & 4) != 0)
      {
        v55 = 0u;
        v56 = 0u;
        os_log_type_t v53 = 0u;
        v54 = 0u;
        char v14 = nw_endpoint_copy_public_keys(v5);
        os_log_type_t v15 = [v14 countByEnumeratingWithState:&v53 objects:v59 count:16];
        if (v15)
        {
          BOOL v16 = *(void *)v54;
          do
          {
            for (i = 0LL; i != v15; ++i)
            {
              if (*(void *)v54 != v16) {
                objc_enumerationMutation(v14);
              }
              v11 += objc_msgSend(*(id *)(*((void *)&v53 + 1) + 8 * i), "length", v51, v52) + 5;
            }

            os_log_type_t v15 = [v14 countByEnumeratingWithState:&v53 objects:v59 count:16];
          }

          while (v15);
        }
      }

      return v11;
  }

    if (v39) {
      free(v39);
    }
    int v26 = 0LL;
    goto LABEL_94;
  }

  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_80157);
  }
  v1->event = (nw_endpoint_handler_event_s)196611;
  nw_endpoint_handler_report(v1, 0LL, &v1->event.domain, 0LL);
  uint64_t v3 = (const char *)*((void *)v2 + 51);
  if (!v3)
  {
    if (nw_endpoint_handler_get_minimize_logging(v1))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      unsigned int v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v1);
        os_log_type_t v50 = nw_endpoint_handler_dry_run_string(v1);
        uint64_t v51 = nw_endpoint_handler_copy_endpoint(v1);
        logging_description = nw_endpoint_get_logging_description(v51);
        os_log_type_t v53 = nw_endpoint_handler_state_string(v1);
        v54 = nw_endpoint_handler_mode_string(v1);
        v55 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        os_log_type_t v69 = "nw_endpoint_flow_connect";
        uint64_t v70 = 2082;
        v71 = (void *)id_string;
        os_log_type_t v72 = 2082;
        v73 = v50;
        v74 = 2082;
        v75 = (void *)logging_description;
        os_log_type_t v76 = 2082;
        BOOL v77 = v53;
        uint64_t v78 = 2082;
        uint64_t v79 = v54;
        os_log_type_t v80 = 2114;
        uint64_t v81 = v55;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connect bottom protocol",  buf,  0x48u);
      }
    }

    else
    {
      uint64_t v6 = v1;
      uint64_t v7 = *((_BYTE *)v6 + 268);

      if ((v7 & 0x20) != 0)
      {
LABEL_43:
        int v26 = 1LL;
        goto LABEL_94;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      unsigned int v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = v6;

        os_log_type_t v10 = v9;
        uint64_t v11 = *((_BYTE *)v6 + 268);

        if ((v11 & 1) != 0) {
          BOOL v12 = "dry-run ";
        }
        else {
          BOOL v12 = "";
        }
        uint64_t v13 = nw_endpoint_handler_copy_endpoint(v10);
        char v14 = nw_endpoint_get_logging_description(v13);
        id_str = v9->id_str;
        BOOL v16 = v10;
        uint64_t v17 = v16;
        uint64_t v18 = v16[30];
        else {
          char v19 = off_189BBBBF0[v18];
        }
        os_log_type_t v61 = v19;

        int v27 = v17;
        uint64_t v28 = v27;
        unint64_t v29 = "path";
        switch(*((_DWORD *)v27 + 29))
        {
          case 0:
            break;
          case 1:
            unint64_t v29 = "resolver";
            break;
          case 2:
            unint64_t v29 = nw_endpoint_flow_mode_string(v27[31]);
            break;
          case 3:
            unint64_t v29 = "proxy";
            break;
          case 4:
            unint64_t v29 = "fallback";
            break;
          case 5:
            unint64_t v29 = "transform";
            break;
          default:
            unint64_t v29 = "unknown-mode";
            break;
        }

        uint64_t v30 = v28;
        os_unfair_lock_lock((os_unfair_lock_t)v30 + 28);
        os_log_type_t v31 = v30[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v30 + 28);

        *(_DWORD *)buf = 136447746;
        os_log_type_t v69 = "nw_endpoint_flow_connect";
        uint64_t v70 = 2082;
        v71 = id_str;
        os_log_type_t v72 = 2082;
        v73 = v12;
        v74 = 2082;
        v75 = (void *)v14;
        os_log_type_t v76 = 2082;
        BOOL v77 = v61;
        uint64_t v78 = 2082;
        uint64_t v79 = v29;
        os_log_type_t v80 = 2114;
        uint64_t v81 = v31;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connect bottom protocol",  buf,  0x48u);
      }
    }

    goto LABEL_43;
  }

  int v4 = (void *)*((void *)v3 + 5);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v20 = *((void *)v3 + 11);
    if (v20) {
      *((void *)v3 + 11) = v20 + 1;
    }
    uint64_t v5 = -1;
  }

  else
  {
    uint64_t v5 = 0;
  }

  *(void *)uint64_t v66 = v3;
  v67 = v5;
  int v21 = (void *)*((void *)v2 + 52);
  if (v21 == &nw_protocol_ref_counted_handle)
  {
    __int16 v23 = *((void *)v2 + 58);
    if (v23) {
      *((void *)v2 + 58) = v23 + 1;
    }
    uint64_t v22 = -1;
  }

  else
  {
    uint64_t v22 = 0;
  }

  char v64 = (uint64_t)v2 + 376;
  unsigned int v65 = v22;
  uint64_t v24 = *((void *)v3 + 3);
  if (v24)
  {
    __int16 v25 = *(uint64_t (**)(const char *, char *))(v24 + 24);
    if (v25)
    {
      int v26 = v25(v3, (char *)v2 + 376);
      if (v21 != &nw_protocol_ref_counted_handle) {
        goto LABEL_31;
      }
      goto LABEL_92;
    }
  }

  __nwlog_obj();
  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = (const char *)*((void *)v3 + 2);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v69 = "__nw_protocol_connect";
  if (!v33) {
    v33 = "invalid";
  }
  uint64_t v70 = 2082;
  v71 = (void *)v33;
  os_log_type_t v72 = 2048;
  v73 = v3;
  os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v62 = 0;
  if (__nwlog_fault(v34, &type, &v62))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        v37 = (const char *)*((void *)v3 + 2);
        if (!v37) {
          v37 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v69 = "__nw_protocol_connect";
        uint64_t v70 = 2082;
        v71 = (void *)v37;
        os_log_type_t v72 = 2048;
        v73 = v3;
        _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s protocol %{public}s (%p) has invalid connect callback",  buf,  0x20u);
      }

        free(v42);
        goto LABEL_99;
      }

      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_181A5C000, v43, v51, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v58 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl( &dword_181A5C000,  v43,  v58,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v41) {
      free(v41);
    }
    goto LABEL_13;
  }

      goto LABEL_99;
    }

    os_log_type_t v72 = a4;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v16 = (id)gconnectionLogObj;
    uint64_t v17 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
    *(_DWORD *)buf = 136446722;
    uint64_t v78 = "nw_association_set_cached_content_for_protocol";
    uint64_t v79 = 2082;
    os_log_type_t v80 = (void *)v17;
    uint64_t v81 = 2048;
    uint64_t v82 = v13;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v75 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v18, &type, &v75))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v19 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          int v21 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
          *(_DWORD *)buf = 136446722;
          uint64_t v78 = "nw_association_set_cached_content_for_protocol";
          uint64_t v79 = 2082;
          os_log_type_t v80 = (void *)v21;
          uint64_t v81 = 2048;
          uint64_t v82 = v13;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p",  buf,  0x20u);
        }
      }

      else if (v75)
      {
        uint64_t v22 = __nw_create_backtrace_string();
        if (v22)
        {
          __int16 v23 = (char *)v22;
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v24 = (os_log_s *)(id)gconnectionLogObj;
          __int16 v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            int v26 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
            *(_DWORD *)buf = 136446978;
            uint64_t v78 = "nw_association_set_cached_content_for_protocol";
            uint64_t v79 = 2082;
            os_log_type_t v80 = (void *)v26;
            uint64_t v81 = 2048;
            uint64_t v82 = v13;
            unsigned int v83 = 2082;
            uint64_t v84 = v23;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v23);
          if (!v18) {
            goto LABEL_43;
          }
          goto LABEL_42;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v19 = (os_log_s *)(id)gconnectionLogObj;
        unint64_t v29 = type;
        if (os_log_type_enabled(v19, type))
        {
          uint64_t v30 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
          *(_DWORD *)buf = 136446722;
          uint64_t v78 = "nw_association_set_cached_content_for_protocol";
          uint64_t v79 = 2082;
          os_log_type_t v80 = (void *)v30;
          uint64_t v81 = 2048;
          uint64_t v82 = v13;
          _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v19 = (os_log_s *)(id)gconnectionLogObj;
        int v27 = type;
        if (os_log_type_enabled(v19, type))
        {
          uint64_t v28 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
          *(_DWORD *)buf = 136446722;
          uint64_t v78 = "nw_association_set_cached_content_for_protocol";
          uint64_t v79 = 2082;
          os_log_type_t v80 = (void *)v28;
          uint64_t v81 = 2048;
          uint64_t v82 = v13;
          _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    if (!v18)
    {
LABEL_43:
      a4 = v72;
      goto LABEL_44;
    }

      goto LABEL_99;
    }

    if (!v63)
    {
      __nwlog_obj();
      uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v55 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl( &dword_181A5C000,  v42,  v55,  "%{public}s called with null workloop, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_98;
    }

    uint64_t v51 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v57 = type;
    v52 = os_log_type_enabled(v42, type);
    if (!v51)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_181A5C000, v42, v57, "%{public}s called with null workloop, no backtrace", buf, 0xCu);
      }

      goto LABEL_98;
    }

    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v66 = "nw_candidate_manager_copy_workloop";
      v67 = 2082;
      uint64_t v68 = v51;
      _os_log_impl( &dword_181A5C000,  v42,  v57,  "%{public}s called with null workloop, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v51);
  }

          if (v72) {
            free(v72);
          }
          **(_DWORD **)(a1 + 112) = -1;
LABEL_101:
          uint64_t v82 = *(void *)(*(void *)(a1 + 32) + 8LL);
          unsigned int v83 = *(unsigned int *)(v82 + 24) + 1LL;
          uint64_t v84 = v83 << 31 >> 31;
          *(_DWORD *)(v82 + 24) = v83;
          if (v84 == v83 && (v84 & 0x8000000000000000LL) == 0)
          {
LABEL_120:
            return;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v85 = (const char *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v149 = 2082;
          *(void *)__int16 v150 = "count";
          *(_WORD *)&v150[8] = 2048;
          uint64_t v151 = 1LL;
          __int16 v152 = 2048;
          uint64_t v153 = v85;
          uint64_t v86 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v146 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v86, type, &v146))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v87 = (os_log_s *)gLogObj;
              uint64_t v88 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                v89 = (const char *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)__int16 v150 = "count";
                *(_WORD *)&v150[8] = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v89;
                os_log_type_t v90 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_116:
                _os_log_impl(&dword_181A5C000, v87, v88, v90, buf, 0x2Au);
              }
            }

            else if (v146)
            {
              v91 = (char *)__nw_create_backtrace_string();
              os_log_type_t v87 = (os_log_s *)__nwlog_obj();
              uint64_t v88 = type[0];
              v92 = os_log_type_enabled(v87, type[0]);
              if (v91)
              {
                if (v92)
                {
                  v93 = (const char *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                  *(_DWORD *)buf = 136447234;
                  __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  v149 = 2082;
                  *(void *)__int16 v150 = "count";
                  *(_WORD *)&v150[8] = 2048;
                  uint64_t v151 = 1LL;
                  __int16 v152 = 2048;
                  uint64_t v153 = v93;
                  __int16 v154 = 2082;
                  v155 = v91;
                  _os_log_impl( &dword_181A5C000,  v87,  v88,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v91);
                goto LABEL_117;
              }

              if (v92)
              {
                BOOL v95 = (const char *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)__int16 v150 = "count";
                *(_WORD *)&v150[8] = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v95;
                os_log_type_t v90 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_116;
              }
            }

            else
            {
              os_log_type_t v87 = (os_log_s *)__nwlog_obj();
              uint64_t v88 = type[0];
              if (os_log_type_enabled(v87, type[0]))
              {
                os_log_type_t v94 = (const char *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)__int16 v150 = "count";
                *(_WORD *)&v150[8] = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v94;
                os_log_type_t v90 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_116;
              }
            }
          }

      free(v6);
      goto LABEL_99;
    case 2uLL:
      string = xpc_dictionary_get_string(v2, "hostname");
      os_log_type_t v10 = xpc_dictionary_get_uint64(v2, "port");
      address = (nw_endpoint_t)nw_endpoint_create_host_with_numeric_port(string, bswap32(v10) >> 16);
      goto LABEL_15;
    case 3uLL:
      BOOL v12 = xpc_dictionary_get_string(v2, "bonjour_name");
      uint64_t v13 = xpc_dictionary_get_string(v2, "bonjour_type");
      char v14 = xpc_dictionary_get_string(v2, "bonjour_domain");
      address = nw_endpoint_create_bonjour_service(v12, v13, v14);
      goto LABEL_15;
    case 4uLL:
      os_log_type_t v15 = xpc_dictionary_get_string(v2, "url");
      address = nw_endpoint_create_url(v15);
      goto LABEL_15;
    case 5uLL:
      BOOL v16 = xpc_dictionary_get_string(v2, "srv_name");
      address = (nw_endpoint_t)nw_endpoint_create_srv(v16);
LABEL_15:
      uint64_t v17 = address;
      goto LABEL_16;
    case 6uLL:
      uint64_t v42 = v2;
      os_log_type_t v43 = xpc_dictionary_get_string(v42, "application_service_name");
      uint64_t v44 = xpc_dictionary_get_string(v42, "application_service_alias");
      uuid = xpc_dictionary_get_uuid(v42, "service_identifier");
      length[0] = 0LL;
      length[1] = 0LL;
      if (uuid) {
        *(_OWORD *)length = *(_OWORD *)uuid;
      }
      int v46 = xpc_dictionary_get_string(v42, "device_name");
      uint64_t v47 = xpc_dictionary_get_string(v42, "device_model");
      int64 = xpc_dictionary_get_int64(v42, "device_color");
      uint64_t v49 = xpc_dictionary_get_int64(v42, "route");
      os_log_type_t v50 = xpc_dictionary_get_string(v42, "contact_id");
      uint64_t v51 = -[NWConcrete_nw_application_service_endpoint initWithApplicationService:alias:serviceUUID:deviceName:deviceModel:contactID:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_application_service_endpoint),  v43,  v44,  (const unsigned __int8 *)length,  v46,  v47,  v50);
      uint64_t v17 = (nw_endpoint_t)v51;
      if (v51)
      {
        nw_endpoint_set_device_color((void *)v51, int64);
        nw_endpoint_set_advertised_route(v17, v49);
        v52 = v17;
        goto LABEL_108;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v60 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_create_application_service_from_dictionary";
      os_log_type_t v61 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v85 = 0;
      if ((__nwlog_fault(v61, &type, &v85) & 1) == 0) {
        goto LABEL_106;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v62 = (os_log_s *)(id)gLogObj;
        uint64_t v63 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_create_application_service_from_dictionary";
          _os_log_impl( &dword_181A5C000,  v62,  v63,  "%{public}s NWOSApplicationServiceEndpoint alloc/init failed",  buf,  0xCu);
        }

          if (v36) {
            free(v36);
          }
          goto LABEL_100;
        }

        __nwlog_obj();
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
        uint64_t v17 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v50 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v23 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_89;
        }

        if (!v50)
        {
          __nwlog_obj();
          uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v42 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v18,  v42,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_89;
        }

        uint64_t v30 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v33 = type;
        os_log_type_t v34 = os_log_type_enabled(v18, type);
        if (!v30)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v18,  v33,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_89;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
          v54 = 2082;
          v55 = v30;
          _os_log_impl( &dword_181A5C000,  v18,  v33,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
        uint64_t v17 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v50 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v21 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_89;
        }

        if (!v50)
        {
          __nwlog_obj();
          uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v41 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v18,  v41,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_89;
        }

        uint64_t v30 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        uint64_t v32 = os_log_type_enabled(v18, type);
        if (!v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v18,  v31,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_89;
        }

        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
          v54 = 2082;
          v55 = v30;
          _os_log_impl( &dword_181A5C000,  v18,  v31,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      free(v30);
      if (!v17) {
        goto LABEL_107;
      }
      goto LABEL_91;
    }

    __nwlog_obj();
    BOOL v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v50 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v50)
    {
      int v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v28 = type;
      unint64_t v29 = os_log_type_enabled(v18, type);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
          v54 = 2082;
          v55 = v27;
          _os_log_impl( &dword_181A5C000,  v18,  v28,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v27);
LABEL_90:
        if (!v17) {
          goto LABEL_107;
        }
LABEL_91:
        free(v17);
        goto LABEL_107;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
        _os_log_impl(&dword_181A5C000, v18, v28, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v40 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_protocol_implementation_get_message_properties";
        _os_log_impl( &dword_181A5C000,  v18,  v40,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_99;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v23 = (id)gLogObj;
  else {
    uint64_t v24 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  unint64_t v102 = "nw_endpoint_handler_unregister_context";
  v103 = 2082;
  int v104 = (void *)v24;
  v105 = 2082;
  v106 = "flow";
  __int16 v25 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v99 = 0;
  if (__nwlog_fault(v25, &type, &v99))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v26 = (os_log_s *)(id)gLogObj;
      int v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        else {
          uint64_t v28 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        unint64_t v102 = "nw_endpoint_handler_unregister_context";
        v103 = 2082;
        int v104 = (void *)v28;
        v105 = 2082;
        v106 = "flow";
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    else if (v99)
    {
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v26 = (os_log_s *)(id)gLogObj;
      os_log_type_t v31 = type;
      uint64_t v32 = os_log_type_enabled(v26, type);
      if (v30)
      {
        if (v32)
        {
          else {
            v33 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446978;
          unint64_t v102 = "nw_endpoint_handler_unregister_context";
          v103 = 2082;
          int v104 = (void *)v33;
          v105 = 2082;
          v106 = "flow";
          unint64_t v107 = 2082;
          v108 = v30;
          _os_log_impl( &dword_181A5C000,  v26,  v31,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v30);
        if (v25) {
          goto LABEL_81;
        }
        goto LABEL_99;
      }

      if (v32)
      {
        else {
          os_log_type_t v61 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        unint64_t v102 = "nw_endpoint_handler_unregister_context";
        v103 = 2082;
        int v104 = (void *)v61;
        v105 = 2082;
        v106 = "flow";
        _os_log_impl( &dword_181A5C000,  v26,  v31,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v26 = (os_log_s *)(id)gLogObj;
      uint64_t v47 = type;
      if (os_log_type_enabled(v26, type))
      {
        else {
          v48 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        unint64_t v102 = "nw_endpoint_handler_unregister_context";
        v103 = 2082;
        int v104 = (void *)v48;
        v105 = 2082;
        v106 = "flow";
        _os_log_impl( &dword_181A5C000,  v26,  v47,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }

    goto LABEL_79;
  }

        if (v40) {
          free(v40);
        }

        goto LABEL_14;
      }

      nw_listener_clear_trigger_agents_on_queue((NWConcrete_nw_listener *)v8);
    }

    else
    {
      nw_listener_clear_trigger_agents_on_queue((NWConcrete_nw_listener *)v8);
      __int16 v23 = *((void *)v8 + 2);
      if (!v23 || nw_path_parameters_get_logging_disabled(*(void *)(v23 + 104)))
      {

        goto LABEL_31;
      }

      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      uint64_t v11 = (id)glistenerLogObj;
      if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = nw_listener_get_id_string(v8);
        *(_DWORD *)os_log_type_t v80 = 136446466;
        uint64_t v81 = "nw_listener_update_trigger_agents_on_queue";
        uint64_t v82 = 2082;
        unsigned int v83 = (void *)v24;
        _os_log_impl( &dword_181A5C000,  (os_log_t)v11,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] no inactive agent information",  v80,  0x16u);
      }
    }

    goto LABEL_31;
  }

  if (v29) {
LABEL_99:
  }
    free(v29);
LABEL_7:
  int v4 = 0LL;
LABEL_59:

  return v4;
}

LABEL_99:
  a1 = v158;
  uint64_t v3 = v159;
  uint64_t v7 = v157;
LABEL_100:
  if (v7 != 4 || (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1, !*(_BYTE *)(a1 + 57)))
  {
LABEL_103:
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), v3);
    os_log_type_t v90 = 1LL;
    goto LABEL_104;
  }

  os_log_type_t v90 = 0LL;
LABEL_104:

  return v90;
}

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  if (!gLogDatapath) {
    return 0LL;
  }
  uint64_t v44 = (os_log_s *)__nwlog_obj();
  BOOL result = os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    uint64_t v45 = nw_frame_unclaimed_length(*(_DWORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    *(_DWORD *)buf = 136446466;
    v55 = "nw_frame_cache_create_frame_block_invoke";
    v56 = 1024;
    *(_DWORD *)os_log_type_t v57 = v45;
    _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s returning frame with unclaimed bytes %u",  buf,  0x12u);
    return 0LL;
  }

  return result;
}

              goto LABEL_99;
            }

            v131 = v18;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            unint64_t v107 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
            {
              logb = nw_endpoint_handler_get_id_string(v2);
              uint64_t v122 = nw_endpoint_handler_dry_run_string(v2);
              v108 = nw_endpoint_handler_copy_endpoint(v2);
              int v109 = nw_endpoint_get_logging_description(v108);
              v110 = nw_endpoint_handler_state_string(v2);
              v111 = nw_endpoint_handler_mode_string(v2);
              v112 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v2);
              *(_DWORD *)buf = 136448002;
              BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
              int v141 = 2082;
              v142 = (void *)logb;
              v143 = 2082;
              char v144 = v122;
              v145 = 2082;
              v146 = v109;
              v147 = 2082;
              __int16 v148 = v110;
              v149 = 2082;
              __int16 v150 = v111;
              uint64_t v151 = 2114;
              __int16 v152 = v112;
              uint64_t v153 = 2048;
              __int16 v154 = count;
              v56 = v107;
              _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %zu triggered agents not yet updated",  buf,  0x52u);

              uint64_t v18 = v131;
LABEL_97:

              goto LABEL_98;
            }
          }

          else
          {
            *((_BYTE *)v2 + 268) &= ~2u;
            inactive_agent_uuids = v2->inactive_agent_uuids;
            v2->inactive_agent_uuids = 0LL;
            v73 = v2;

            inactive_agent_dictionaries = v2->inactive_agent_dictionaries;
            v2->inactive_agent_dictionaries = 0LL;

            triggered_agent_uuids = v2->triggered_agent_uuids;
            v2->triggered_agent_uuids = 0LL;

            if (!nw_endpoint_handler_get_minimize_logging(v73))
            {
              os_log_type_t v76 = v73;
              BOOL v77 = *((_BYTE *)v2 + 268);

              if ((v77 & 0x20) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v56 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
                {
                  loga = v56;
                  id_string = nw_endpoint_handler_get_id_string(v76);
                  uint64_t v79 = nw_endpoint_handler_dry_run_string(v76);
                  os_log_type_t v80 = nw_endpoint_handler_copy_endpoint(v76);
                  uint64_t v81 = nw_endpoint_get_logging_description(v80);
                  uint64_t v82 = nw_endpoint_handler_state_string(v76);
                  unsigned int v83 = nw_endpoint_handler_mode_string(v76);
                  uint64_t v84 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v76);
                  *(_DWORD *)buf = 136447746;
                  BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
                  int v141 = 2082;
                  v142 = (void *)id_string;
                  v143 = 2082;
                  char v144 = v79;
                  v145 = 2082;
                  v146 = v81;
                  v147 = 2082;
                  __int16 v148 = v82;
                  v149 = 2082;
                  __int16 v150 = v83;
                  uint64_t v151 = 2114;
                  __int16 v152 = v84;
                  v56 = loga;
                  _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all triggered agents updated",  buf,  0x48u);
                }

                goto LABEL_97;
              }

              goto LABEL_98;
            }

            v131 = v18;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            unint64_t v107 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
            {
              int v113 = nw_endpoint_handler_get_id_string(v73);
              uint64_t v114 = nw_endpoint_handler_dry_run_string(v73);
              v115 = nw_endpoint_handler_copy_endpoint(v73);
              v116 = nw_endpoint_get_logging_description(v115);
              os_log_type_t v117 = nw_endpoint_handler_state_string(v73);
              uint64_t v118 = nw_endpoint_handler_mode_string(v73);
              v119 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v73);
              *(_DWORD *)buf = 136447746;
              BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
              int v141 = 2082;
              v142 = (void *)v113;
              v143 = 2082;
              char v144 = v114;
              v145 = 2082;
              v146 = v116;
              v147 = 2082;
              __int16 v148 = v117;
              v149 = 2082;
              __int16 v150 = v118;
              uint64_t v151 = 2114;
              __int16 v152 = v119;
              v56 = v107;
              _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all triggered agents updated",  buf,  0x48u);

              uint64_t v18 = v131;
              goto LABEL_97;
            }
          }

          uint64_t v18 = v131;
          v56 = v107;
          goto LABEL_97;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v68 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
        os_log_type_t v69 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v137 = 0;
        if (__nwlog_fault(v69, &type, &v137))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v70 = (os_log_s *)(id)gLogObj;
            v71 = type;
            if (os_log_type_enabled(v70, type))
            {
              *(_DWORD *)buf = 136446210;
              BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
              _os_log_impl(&dword_181A5C000, v70, v71, "%{public}s xpc_array_create failed", buf, 0xCu);
            }
          }

          else if (v137)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v86 = type;
            os_log_type_t v87 = os_log_type_enabled(v70, type);
            if (backtrace_string)
            {
              if (v87)
              {
                *(_DWORD *)buf = 136446466;
                BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
                int v141 = 2082;
                v142 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v70,  v86,  "%{public}s xpc_array_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
              if (!v69) {
                goto LABEL_90;
              }
              goto LABEL_89;
            }

            if (v87)
            {
              *(_DWORD *)buf = 136446210;
              BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
              _os_log_impl(&dword_181A5C000, v70, v86, "%{public}s xpc_array_create failed, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v96 = type;
            if (os_log_type_enabled(v70, type))
            {
              *(_DWORD *)buf = 136446210;
              BOOL v140 = "nw_endpoint_handler_triggered_agents_updated";
              _os_log_impl( &dword_181A5C000,  v70,  v96,  "%{public}s xpc_array_create failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v69)
        {
LABEL_90:
          uint64_t v18 = 0LL;
          uint64_t v11 = 0LL;
          goto LABEL_99;
        }

  if (!*((void *)handle + 6))
  {
    nw_protocol_set_input_handler((uint64_t)handle, (uint64_t)v30);
    *(_OWORD *)handle = *(_OWORD *)v329->flow_id;
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v65 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v66 = handle[115];
        v67 = *((void *)handle + 6);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 116;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v66;
        *(_WORD *)&v345[6] = 2048;
        *(void *)&v345[8] = v67;
        _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Set session default_input_handler: %p",  buf,  0x30u);
      }
    }
  }

  uint64_t v68 = handle[137] & 0x20;
  os_log_type_t v69 = handle[112];
  if (v69 != 1)
  {
    if (!v69)
    {
      if (v29)
      {
        if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v261 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v261, OS_LOG_TYPE_DEBUG))
            {
              v262 = v30[11];
              if (v262) {
                v263 = *(_DWORD *)(v262 + 460);
              }
              else {
                v263 = -1;
              }
              v295 = v30[8];
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v30 + 24;
              *(_WORD *)&buf[22] = 2080;
              v344 = (uint64_t)" ";
              *(_WORD *)v345 = 1024;
              *(_DWORD *)&v345[2] = v263;
              *(_WORD *)&v345[6] = 2048;
              *(void *)&v345[8] = v295;
              *(_WORD *)&v345[16] = 2048;
              *(void *)&v345[18] = v30;
              *(_WORD *)&v345[26] = 1024;
              LODWORD(v346) = v68 >> 5;
              _os_log_impl( &dword_181A5C000,  v261,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u",  buf,  0x40u);
            }
          }
        }

        uint64_t v70 = v30[11];
        if (*(void **)(v70 + 416) == v30)
        {
          if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v283 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v283, OS_LOG_TYPE_DEBUG))
              {
                v284 = v30[11];
                if (v284) {
                  v285 = *(_DWORD *)(v284 + 460);
                }
                else {
                  v285 = -1;
                }
                v313 = v30[8];
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v30 + 24;
                *(_WORD *)&buf[22] = 2080;
                v344 = (uint64_t)" ";
                *(_WORD *)v345 = 1024;
                *(_DWORD *)&v345[2] = v285;
                *(_WORD *)&v345[6] = 2048;
                *(void *)&v345[8] = v313;
                _os_log_impl( &dword_181A5C000,  v283,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream",  buf,  0x30u);
              }
            }
          }

          nw_protocol_connected((void *)v30[6], (uint64_t)v30);
          goto LABEL_256;
        }

        v30[3] = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
        nw_protocol_set_output_handler((uint64_t)v30, v70);
        v71 = nw_parameters_copy_protocol_options_legacy((void *)v30[18], (nw_protocol *)v30);
        if (!v71)
        {
          if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v99 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              uint64_t v100 = v30[11];
              if (v100) {
                v101 = *(_DWORD *)(v100 + 460);
              }
              else {
                v101 = -1;
              }
              BOOL v138 = v30[8];
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v30 + 24;
              *(_WORD *)&buf[22] = 2080;
              v344 = (uint64_t)" ";
              *(_WORD *)v345 = 1024;
              *(_DWORD *)&v345[2] = v101;
              *(_WORD *)&v345[6] = 2048;
              *(void *)&v345[8] = v138;
              _os_log_impl( &dword_181A5C000,  v99,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring",  buf,  0x30u);
            }
          }

          goto LABEL_256;
        }

        os_log_type_t v72 = v71;
        if (v68)
        {
          if ((*((_BYTE *)v30 + 276) & 0x10) != 0) {
            goto LABEL_255;
          }
          if (!gLogDatapath) {
            goto LABEL_255;
          }
          unint64_t v102 = (os_log_s *)__nwlog_obj();
          if (!os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_255;
          }
          v103 = v30[11];
          if (v103) {
            int v104 = *(_DWORD *)(v103 + 460);
          }
          else {
            int v104 = -1;
          }
          v314 = v30[8];
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v30 + 24;
          *(_WORD *)&buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v104;
          *(_WORD *)&v345[6] = 2048;
          *(void *)&v345[8] = v314;
          v161 = "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment to setup metadata";
          v162 = v102;
          v163 = OS_LOG_TYPE_DEBUG;
        }

        else
        {
          if (nw_protocol_options_is_webtransport(v71))
          {
            *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xFC | 1;
            if (nw_webtransport_options_get_is_datagram(v72)) {
              v73 = 8;
            }
            else {
              v73 = 0;
            }
            *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xF7 | v73;
            is_unidirectional = nw_webtransport_options_get_is_unidirectional(v72);
            v75 = *((_BYTE *)v30 + 276);
            if (is_unidirectional) {
              os_log_type_t v76 = 4;
            }
            else {
              os_log_type_t v76 = 0;
            }
            *((_BYTE *)v30 + 276) = v75 & 0xFB | v76;
            if ((v75 & 0x10) == 0)
            {
              BOOL v77 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_INFO))
              {
                uint64_t v78 = v30[11];
                if (v78) {
                  uint64_t v79 = *(_DWORD *)(v78 + 460);
                }
                else {
                  uint64_t v79 = -1;
                }
                uint64_t v156 = v30[8];
                v157 = *((unsigned __int8 *)v30 + 276);
                *(_DWORD *)buf = 136448002;
                *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v30 + 24;
                *(_WORD *)&buf[22] = 2080;
                v344 = (uint64_t)" ";
                *(_WORD *)v345 = 1024;
                *(_DWORD *)&v345[2] = v79;
                *(_WORD *)&v345[6] = 2048;
                *(void *)&v345[8] = v156;
                *(_WORD *)&v345[16] = 1024;
                *(_DWORD *)&v345[18] = (v157 >> 1) & 1;
                *(_WORD *)&v345[22] = 1024;
                *(_DWORD *)&v345[24] = (v157 >> 3) & 1;
                LOWORD(v346) = 1024;
                *(_DWORD *)((char *)&v346 + 2) = (v157 >> 2) & 1;
                _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u",  buf,  0x42u);
              }
            }

            nw_webtransport_metadata_set_is_peer_initiated((void *)v30[20], (*((_BYTE *)v30 + 276) & 2) != 0);
            nw_webtransport_metadata_set_is_datagram((void *)v30[20], (*((_BYTE *)v30 + 276) & 8) != 0);
            nw_webtransport_metadata_set_is_unidirectional((void *)v30[20], (*((_BYTE *)v30 + 276) & 4) != 0);
            goto LABEL_255;
          }

          if ((*((_BYTE *)v30 + 276) & 0x10) != 0
            || (os_log_type_t v127 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v127, OS_LOG_TYPE_ERROR)))
          {
LABEL_255:
            os_release(v72);
LABEL_256:
            nw_protocol_connected(v30, (uint64_t)handle);
            goto LABEL_589;
          }

          v128 = v30[11];
          if (v128) {
            v129 = *(_DWORD *)(v128 + 460);
          }
          else {
            v129 = -1;
          }
          v160 = v30[8];
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v30 + 24;
          *(_WORD *)&buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v129;
          *(_WORD *)&v345[6] = 2048;
          *(void *)&v345[8] = v160;
          v161 = "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream";
          v162 = v127;
          v163 = OS_LOG_TYPE_ERROR;
        }

        _os_log_impl(&dword_181A5C000, v162, v163, v161, buf, 0x30u);
        goto LABEL_255;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
      v251 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(aBlock) = 16;
      v339[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v251, &aBlock, v339))
      {
        if (aBlock == 17)
        {
          v252 = (os_log_s *)__nwlog_obj();
          v253 = aBlock;
          if (!os_log_type_enabled(v252, (os_log_type_t)aBlock)) {
            goto LABEL_543;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          v254 = "%{public}s called with null webtransport_stream";
          goto LABEL_542;
        }

        if (v339[0] == OS_LOG_TYPE_DEFAULT)
        {
          v252 = (os_log_s *)__nwlog_obj();
          v253 = aBlock;
          if (!os_log_type_enabled(v252, (os_log_type_t)aBlock)) {
            goto LABEL_543;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          v254 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_542;
        }

        v274 = (char *)__nw_create_backtrace_string();
        v252 = (os_log_s *)__nwlog_obj();
        v253 = aBlock;
        v275 = os_log_type_enabled(v252, (os_log_type_t)aBlock);
        if (v274)
        {
          if (v275)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v274;
            _os_log_impl( &dword_181A5C000,  v252,  v253,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v274);
          goto LABEL_543;
        }

        if (v275)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          v254 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_542:
          _os_log_impl(&dword_181A5C000, v252, v253, v254, buf, 0xCu);
        }
      }

  [MEMORY[0x189607968] numberWithBool:self->_fastOpen];
  unsigned int v65 = (void *)objc_claimAutoreleasedReturnValue();
  [v4 setObject:v65 forKey:@"fastOpen"];

  has = (__int16)self->_has;
  if ((has & 0x800) == 0)
  {
LABEL_19:
    if ((has & 0x100) == 0) {
      goto LABEL_20;
    }
    goto LABEL_100;
  }

        v73 = *(void *)(a1 + 80);
        if (*(_BYTE *)(a1 + 88))
        {
          *(void *)(v16 + 32) = 0LL;
          v74 = v16 + 32;
        }

        else
        {
          *(void *)(v16 + 16) = 0LL;
          v74 = v16 + 16;
        }

        v75 = *(uint64_t **)(v73 + 8);
        *(void *)(v74 + 8) = v75;
        os_log_s *v75 = v16;
        *(void *)(v73 + 8) = v74;
        os_log_type_t v76 = *(void *)(*(void *)(a1 + 48) + 8LL);
        BOOL v77 = *(unsigned int *)(v76 + 24) + 1LL;
        uint64_t v78 = v77 << 31 >> 31;
        *(_DWORD *)(v76 + 24) = v77;
        if (v78 == v77 && (v78 & 0x8000000000000000LL) == 0) {
          goto LABEL_120;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v79 = *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_http1_connection_process_input_frames_block_invoke";
        __int16 v148 = 2082;
        v149 = "frames_processed";
        __int16 v150 = 2048;
        *(void *)uint64_t v151 = 1LL;
        *(_WORD *)&v151[8] = 2048;
        *(void *)&v151[10] = v79;
        os_log_type_t v80 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v144 = 0;
        if (__nwlog_fault(v80, &type, &v144))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v81 = (os_log_s *)gLogObj;
            uint64_t v82 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              unsigned int v83 = *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_http1_connection_process_input_frames_block_invoke";
              __int16 v148 = 2082;
              v149 = "frames_processed";
              __int16 v150 = 2048;
              *(void *)uint64_t v151 = 1LL;
              *(_WORD *)&v151[8] = 2048;
              *(void *)&v151[10] = v83;
              uint64_t v84 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_116:
              _os_log_impl(&dword_181A5C000, v81, v82, v84, buf, 0x2Au);
            }
          }

          else if (v144)
          {
            v85 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v81 = (os_log_s *)gLogObj;
            uint64_t v82 = type;
            uint64_t v86 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v85)
            {
              if (v86)
              {
                os_log_type_t v87 = *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_http1_connection_process_input_frames_block_invoke";
                __int16 v148 = 2082;
                v149 = "frames_processed";
                __int16 v150 = 2048;
                *(void *)uint64_t v151 = 1LL;
                *(_WORD *)&v151[8] = 2048;
                *(void *)&v151[10] = v87;
                *(_WORD *)&v151[18] = 2082;
                __int16 v152 = v85;
                _os_log_impl( &dword_181A5C000,  v81,  v82,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v85);
              goto LABEL_117;
            }

            if (v86)
            {
              v89 = *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_http1_connection_process_input_frames_block_invoke";
              __int16 v148 = 2082;
              v149 = "frames_processed";
              __int16 v150 = 2048;
              *(void *)uint64_t v151 = 1LL;
              *(_WORD *)&v151[8] = 2048;
              *(void *)&v151[10] = v89;
              uint64_t v84 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_116;
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v81 = (os_log_s *)gLogObj;
            uint64_t v82 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v88 = *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_http1_connection_process_input_frames_block_invoke";
              __int16 v148 = 2082;
              v149 = "frames_processed";
              __int16 v150 = 2048;
              *(void *)uint64_t v151 = 1LL;
              *(_WORD *)&v151[8] = 2048;
              *(void *)&v151[10] = v88;
              uint64_t v84 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_116;
            }
          }
        }

    if (v39) {
      free(v39);
    }
    goto LABEL_44;
  }

  return 1LL;
}
  }

  if (v42) {
    free(v42);
  }
  return 0LL;
}

  if (!v82 || (SecPolicySetATSPinning() & 1) != 0) {
    goto LABEL_128;
  }
  uint64_t v59 = v24;
  if (__nwlog_url_log::onceToken != -1) {
    dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
  }
  uint64_t v60 = (id)gurlLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
  LODWORD(v77) = 12;
  os_log_type_t v76 = buf;
  os_log_type_t v61 = (char *)_os_log_send_and_compose_impl();

  v91 = OS_LOG_TYPE_ERROR;
  os_log_type_t v90 = 0;
  if (!__nwlog_fault(v61, &v91, &v90))
  {
LABEL_126:
    if (!v61) {
      goto LABEL_128;
    }
    goto LABEL_127;
  }

  if (v91 == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_url_log::onceToken != -1) {
      dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
    }
    uint64_t v62 = (os_log_s *)(id)gurlLogObj;
    uint64_t v63 = v91;
    if (!os_log_type_enabled(v62, v91)) {
      goto LABEL_125;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
    char v64 = "%{public}s SecPolicySetATSPinning failed";
LABEL_124:
    _os_log_impl(&dword_181A5C000, v62, v63, v64, buf, 0xCu);
LABEL_125:

    goto LABEL_126;
  }

  if (!v90)
  {
    if (__nwlog_url_log::onceToken != -1) {
      dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
    }
    uint64_t v62 = (os_log_s *)(id)gurlLogObj;
    uint64_t v63 = v91;
    if (!os_log_type_enabled(v62, v91)) {
      goto LABEL_125;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
    char v64 = "%{public}s SecPolicySetATSPinning failed, backtrace limit exceeded";
    goto LABEL_124;
  }

  unsigned int v65 = (char *)__nw_create_backtrace_string();
  if (__nwlog_url_log::onceToken != -1) {
    dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
  }
  uint64_t v66 = (os_log_s *)(id)gurlLogObj;
  v67 = v91;
  uint64_t v68 = os_log_type_enabled(v66, v91);
  if (v65)
  {
    if (v68)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
      BOOL v95 = 2082;
      *(void *)uint64_t v96 = v65;
      _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s SecPolicySetATSPinning failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v65);
    uint64_t v24 = v59;
    if (!v61) {
      goto LABEL_128;
    }
LABEL_127:
    free(v61);
    goto LABEL_128;
  }

  if (v68)
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
    _os_log_impl(&dword_181A5C000, v66, v67, "%{public}s SecPolicySetATSPinning failed, no backtrace", buf, 0xCu);
  }

  uint64_t v24 = v59;
  if (v61) {
    goto LABEL_127;
  }
LABEL_128:

  v33 = v81;
  if (!self) {
    goto LABEL_129;
  }
LABEL_35:
  os_log_type_t v34 = self->_configuration;
  if (v34)
  {
    -[NSURLSessionConfiguration _tlsTrustPinningPolicyName](v34->_configuration, "_tlsTrustPinningPolicyName");
    unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    if (v35) {
      SecTrustSetPinningPolicyName();
    }
  }

  else
  {
    unint64_t v35 = 0LL;
  }

  -[NWURLSessionTask setSecTrust:](self, "setSecTrust:", v33, v76, v77);
  uint64_t v36 = self->_configuration;
  if (v36
    && -[NSURLSessionConfiguration _alwaysPerformDefaultTrustEvaluation]( v36->_configuration,  "_alwaysPerformDefaultTrustEvaluation"))
  {
    queue = (dispatch_queue_s *)self->_queue;
    result[0] = MEMORY[0x1895F87A8];
    result[1] = 3221225472LL;
    result[2] = __95__NWURLSessionTask_loaderDidReceiveServerTrustChallenge_secProtocolMetadata_completionHandler___block_invoke;
    result[3] = &unk_189BBEFF0;
    v38 = (void (**)(id, void))v10;
    v89 = v38;
    if (SecTrustEvaluateAsyncWithError(v33, queue, result)) {
      v38[2](v38, 0LL);
    }
    os_log_type_t v39 = v89;
    goto LABEL_137;
  }

                    if (a2 == a3) {
                      return 226LL;
                    }
                    *(void *)(a1 + 8) = a2;
                    *(void *)(a1 + 16) = llhttp__on_version;
LABEL_100:
                    if (a2 == a3) {
                      return 225LL;
                    }
                    v38 = *a2 - 48;
                    if (v38 >= 0xA)
                    {
                      v324 = *(void *)(a1 + 8);
                      *(void *)(a1 + 8) = 0LL;
                      v325 = *(void *)(a1 + 88);
                      if (v325)
                      {
                        v326 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v325 + 32);
                        if (v326)
                        {
                          v327 = v326(a1, v324, &a2[-v324]);
                          if (v327)
                          {
                            v328 = v327;
                            if (v327 == -1)
                            {
                              *(void *)(a1 + 32) = "Span callback error in on_version";
                              v328 = 24;
                            }

                            BOOL result = 0LL;
                            *(_DWORD *)(a1 + 24) = v328;
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 224LL;
                            return result;
                          }
                        }
                      }

                      goto LABEL_1410;
                    }

                    ++a2;
                    *(_BYTE *)(a1 + 74) = v38;
LABEL_103:
                    if (a2 == a3) {
                      return 223LL;
                    }
                    if (*a2 != 46)
                    {
                      v329 = *(void *)(a1 + 8);
                      *(void *)(a1 + 8) = 0LL;
                      v330 = *(void *)(a1 + 88);
                      if (v330)
                      {
                        v331 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v330 + 32);
                        if (v331)
                        {
                          v332 = v331(a1, v329, &a2[-v329]);
                          if (v332)
                          {
                            v333 = v332;
                            if (v332 == -1)
                            {
                              *(void *)(a1 + 32) = "Span callback error in on_version";
                              v333 = 24;
                            }

                            BOOL result = 0LL;
                            *(_DWORD *)(a1 + 24) = v333;
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 222LL;
                            return result;
                          }
                        }
                      }

                      goto LABEL_1417;
                    }

                    ++a2;
LABEL_106:
                    if (a2 == a3) {
                      return 221LL;
                    }
                    os_log_type_t v39 = 0;
                    BOOL v40 = 0;
                    uint64_t v41 = 1;
                    uint64_t v42 = 1;
                    switch(*a2)
                    {
                      case '0':
                        goto LABEL_133;
                      case '1':
                        uint64_t v41 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 1;
                        goto LABEL_133;
                      case '2':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 2;
                        goto LABEL_133;
                      case '3':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 3;
                        goto LABEL_133;
                      case '4':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 4;
                        goto LABEL_133;
                      case '5':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 5;
                        goto LABEL_133;
                      case '6':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 6;
                        goto LABEL_133;
                      case '7':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 7;
                        goto LABEL_133;
                      case '8':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        os_log_type_t v39 = 0;
                        BOOL v40 = 8;
                        goto LABEL_133;
                      case '9':
                        uint64_t v41 = 0;
                        uint64_t v42 = 0;
                        BOOL v40 = 9;
                        os_log_type_t v39 = 1;
LABEL_133:
                        ++a2;
                        *(_BYTE *)(a1 + 75) = v40;
                        if ((*(_WORD *)(a1 + 78) & 0x10) != 0) {
                          goto LABEL_138;
                        }
                        uint64_t v47 = *(unsigned __int8 *)(a1 + 74);
                        if (*(_BYTE *)(a1 + 74))
                        {
                          if (v47 == 1)
                          {
                            if ((v42 & 1) == 0) {
                              goto LABEL_195;
                            }
                          }

                          else if (v47 != 2 || (v41 & 1) == 0)
                          {
LABEL_195:
                            uint64_t v78 = *(void *)(a1 + 8);
                            *(void *)(a1 + 8) = 0LL;
                            uint64_t v79 = *(void *)(a1 + 88);
                            if (v79)
                            {
                              os_log_type_t v80 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v79 + 32);
                              if (v80)
                              {
                                uint64_t v81 = v80(a1, v78, &a2[-v78]);
                                if (v81)
                                {
                                  uint64_t v82 = v81;
                                  if (v81 == -1)
                                  {
                                    *(void *)(a1 + 32) = "Span callback error in on_version";
                                    uint64_t v82 = 24;
                                  }

                                  BOOL result = 0LL;
                                  *(_DWORD *)(a1 + 24) = v82;
                                  *(void *)(a1 + 40) = a2;
                                  *(void *)(a1 + 56) = 219LL;
                                  return result;
                                }
                              }
                            }

                            goto LABEL_1283;
                          }
                        }

                        else if ((v39 & 1) == 0)
                        {
                          goto LABEL_195;
                        }

  if (v47)
  {
LABEL_99:
    uint64_t v42 = (unsigned __int8 *)v47;
LABEL_48:
    free(v42);
  }

    if (v50) {
      free(v50);
    }
    v38 = 0LL;
    goto LABEL_42;
  }

  os_log_type_t v15 = nw_http_metadata_copy_response(a1);
  status_code = nw_http_response_get_status_code(v15);
  uint64_t v18 = 4LL;
  if (status_code < 0x4000) {
    uint64_t v18 = 2LL;
  }
  if (status_code < 0x40) {
    uint64_t v18 = 1LL;
  }
  *(void *)(*(void *)&buf[8] + 24LL) += v18;
  if (v15) {
    goto LABEL_12;
  }
LABEL_13:
  *(void *)unsigned int v65 = 0LL;
  *(void *)&v65[8] = v65;
  *(void *)&v65[16] = 0x2000000000LL;
  uint64_t v66 = 0LL;
  char v19 = nw_http_metadata_copy_header_fields(a1);
  v58[0] = v7;
  v58[1] = 0x40000000LL;
  v58[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_5;
  v58[3] = &unk_189BBF840;
  v58[4] = v65;
  nw_http_fields_enumerate(v19, v58);
  os_log_type_t v20 = *(void *)&v65[8];
  int v21 = *(void *)(*(void *)&v65[8] + 24LL);
  if (a2)
  {
    uint64_t v22 = *(void *)&buf[8];
    __int16 v23 = v21 + *(void *)(*(void *)&buf[8] + 24LL);
    goto LABEL_39;
  }

  if (v21 >= 0x40)
  {
    if (v21 >= 0x4000)
    {
      if (v21 >> 30)
      {
        if (v21 >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v63 = 136446466;
          *(void *)&v63[4] = "_http_vle_length";
          *(_WORD *)&v63[12] = 2048;
          *(void *)&v63[14] = v21;
          __int16 v25 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v25);
          if (result) {
            goto LABEL_101;
          }
          free(v25);
          uint64_t v24 = 0LL;
          os_log_type_t v20 = *(void *)&v65[8];
        }

        else
        {
          uint64_t v24 = 8LL;
        }
      }

      else
      {
        uint64_t v24 = 4LL;
      }
    }

    else
    {
      uint64_t v24 = 2LL;
    }
  }

  else
  {
    uint64_t v24 = 1LL;
  }

  int v27 = *(void *)&buf[8];
  uint64_t v28 = *(void *)(*(void *)&buf[8] + 24LL) + v24;
  *(void *)(*(void *)&buf[8] + 24LL) = v28;
  unint64_t v29 = *(void *)(v20 + 24) + v28;
  *(void *)(v27 + 24) = v29;
  if (a3 >= 0x40)
  {
    if (a3 >= 0x4000)
    {
      if (a3 >> 30)
      {
        if (a3 >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v63 = 136446466;
          *(void *)&v63[4] = "_http_vle_length";
          *(_WORD *)&v63[12] = 2048;
          *(void *)&v63[14] = a3;
          os_log_type_t v31 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v31);
          if (result) {
            goto LABEL_101;
          }
          free(v31);
          uint64_t v30 = 0LL;
          int v27 = *(void *)&buf[8];
          unint64_t v29 = *(void *)(*(void *)&buf[8] + 24LL);
        }

        else
        {
          uint64_t v30 = 8LL;
        }
      }

      else
      {
        uint64_t v30 = 4LL;
      }
    }

    else
    {
      uint64_t v30 = 2LL;
    }
  }

  else
  {
    uint64_t v30 = 1LL;
  }

  *(void *)(v27 + 24) = v30 + a3 + v29;
  uint64_t v32 = nw_http_metadata_copy_trailer_fields(a1);
  if (!v32)
  {
    uint64_t v22 = *(void *)&buf[8];
    __int16 v23 = *(void *)(*(void *)&buf[8] + 24LL);
LABEL_39:
    v38 = v23 + 1;
    *(void *)(v22 + 24) = v23 + 1;
    if (!v19)
    {
LABEL_41:
      _Block_object_dispose(v65, 8);
LABEL_42:
      _Block_object_dispose(buf, 8);
      return v38;
    }

    free(backtrace_string);
    goto LABEL_177;
  }

  uint64_t v6 = __dst;
  if (!a1 && a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
    os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      uint64_t v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
        v37 = "%{public}s called with null body_content";
        goto LABEL_176;
      }

      goto LABEL_177;
    }

    if (!(_BYTE)v80)
    {
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      uint64_t v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
        v37 = "%{public}s called with null body_content, backtrace limit exceeded";
        goto LABEL_176;
      }

      goto LABEL_177;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v35 = (os_log_s *)__nwlog_obj();
    uint64_t v36 = type[0];
    os_log_type_t v57 = os_log_type_enabled(v35, type[0]);
    if (!backtrace_string)
    {
      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
        v37 = "%{public}s called with null body_content, no backtrace";
        goto LABEL_176;
      }

      goto LABEL_177;
    }

    if (v57)
    {
      *(_DWORD *)buf = 136446466;
      v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
      v92 = 2082;
      v93 = backtrace_string;
      BOOL v40 = "%{public}s called with null body_content, dumping backtrace:%{public}s";
      goto LABEL_97;
    }

    goto LABEL_98;
  }

  *(void *)os_log_type_t type = 0LL;
  v85 = type;
  uint64_t v86 = 0x2000000000LL;
  os_log_type_t v87 = __dst;
  os_log_type_t v80 = 0LL;
  uint64_t v81 = &v80;
  uint64_t v82 = 0x2000000000LL;
  unsigned int v83 = a6;
  if (!a2) {
    goto LABEL_13;
  }
  if (a2 <= 0x3F)
  {
    __src = a2;
    uint64_t v11 = 1LL;
    BOOL v12 = a6 - 1;
    if (a6) {
      goto LABEL_7;
    }
LABEL_30:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v91 = "_http_safe_append";
    __int16 v25 = (char *)_os_log_send_and_compose_impl();
    v89 = OS_LOG_TYPE_ERROR;
    uint64_t v88 = 0;
    if (__nwlog_fault(v25, &v89, &v88))
    {
      if (v89 == OS_LOG_TYPE_FAULT)
      {
        int v26 = (os_log_s *)__nwlog_obj();
        int v27 = v89;
        if (os_log_type_enabled(v26, v89))
        {
          *(_DWORD *)buf = 136446210;
          v91 = "_http_safe_append";
          uint64_t v28 = "%{public}s called with null (*remaining >= length)";
LABEL_158:
          _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
        }
      }

      else if (v88)
      {
        v55 = (char *)__nw_create_backtrace_string();
        int v26 = (os_log_s *)__nwlog_obj();
        int v27 = v89;
        v56 = os_log_type_enabled(v26, v89);
        if (v55)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            v91 = "_http_safe_append";
            v92 = 2082;
            v93 = v55;
            _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v55);
          goto LABEL_159;
        }

        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          v91 = "_http_safe_append";
          uint64_t v28 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_158;
        }
      }

      else
      {
        int v26 = (os_log_s *)__nwlog_obj();
        int v27 = v89;
        if (os_log_type_enabled(v26, v89))
        {
          *(_DWORD *)buf = 136446210;
          v91 = "_http_safe_append";
          uint64_t v28 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_158;
        }
      }
    }

              free(v15);
              goto LABEL_99;
            }

            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v16 = (os_log_s *)(id)gLogObj;
              v56 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_181A5C000, v16, v56, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
              }

        if (v36) {
          free(v36);
        }
        dns_error = v75;
        goto LABEL_101;
      }

      if ((a2 & 2) != 0 && a7)
      {
        bonjour_service = nw_endpoint_create_bonjour_service(a5, a6, a7);
        *(void *)uint64_t v79 = 0LL;
        ValidationData = (const void *)DNSServiceGetValidationData();
        if (ValidationData && *(void *)v79) {
          nw_endpoint_set_signature(bonjour_service, ValidationData, *(size_t *)v79);
        }
        if (!nw_browser_add_result_locked(v14, (const char *)buf, bonjour_service, v29, 0))
        {
          os_unfair_lock_unlock(lock);

          goto LABEL_102;
        }

        if (LOBYTE(v14[49]._os_unfair_lock_opaque)) {
          nw_browser_start_query_record_for_endpoint_locked(v14, bonjour_service, (const char *)buf, v29);
        }
      }

      else if ((nw_browser_remove_result_locked(v14, (const char *)buf, v29) & 1) == 0)
      {
LABEL_86:
        os_unfair_lock_unlock(lock);
LABEL_102:

        goto LABEL_49;
      }

      if ((a2 & 1) == 0) {
        nw_browser_notify_browse_result_changes_locked((NWConcrete_nw_browser *)v14);
      }
      goto LABEL_86;
    }

    v79[8] = 0;
    *(void *)uint64_t v79 = 0LL;
    v105 = 0;
    int v104 = 0LL;
    if (a5)
    {
      uint64_t v17 = strlen(a5);
      uint64_t v18 = v79;
      __nwlog_salted_hash(a5, v17, v79);
      if (a7)
      {
LABEL_10:
        char v19 = strlen(a7);
        os_log_type_t v20 = (const char *)&v104;
        __nwlog_salted_hash(a7, v19, (char *)&v104);
        goto LABEL_25;
      }
    }

    else
    {
      uint64_t v18 = "<NULL>";
      if (a7) {
        goto LABEL_10;
      }
    }

    os_log_type_t v20 = "<NULL>";
LABEL_25:
    if (!nw_parameters_get_logging_disabled(*(void *)&v14[10]._os_unfair_lock_opaque))
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
      }
      __int16 v25 = (os_log_s *)(id)gbrowserLogObj;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        int v26 = v14[48]._os_unfair_lock_opaque;
        *(_DWORD *)buf = 136448002;
        v93 = "nw_browser_dns_service_browse_callback";
        os_log_type_t v94 = 1024;
        *(_DWORD *)BOOL v95 = v26;
        *(_WORD *)&v95[4] = 2082;
        *(void *)&v95[6] = v18;
        *(_WORD *)&v95[14] = 2082;
        *(void *)&v95[16] = a6;
        uint64_t v96 = 2082;
        uint64_t v97 = v20;
        os_log_type_t v98 = 1024;
        uint64_t v99 = a2;
        uint64_t v100 = 1024;
        v101 = a3;
        unint64_t v102 = 1024;
        v103 = a4;
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] dns: (#%{public}s %{public}s #%{public}s), flags: %d, if_index: %d, error: %d",  buf,  0x42u);
      }
    }

    goto LABEL_31;
  }

  __nwlog_obj();
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v93 = "nw_browser_dns_service_browse_callback";
  os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

  v79[0] = 16;
  LOBYTE(v104) = 0;
  if (__nwlog_fault(v53, v79, &v104))
  {
    if (v79[0] == 17)
    {
      __nwlog_obj();
      v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v55 = v79[0];
      if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if ((_BYTE)v104)
    {
      v56 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = v79[0];
      BOOL v58 = os_log_type_enabled(v54, (os_log_type_t)v79[0]);
      if (v56)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446466;
          v93 = "nw_browser_dns_service_browse_callback";
          os_log_type_t v94 = 2082;
          *(void *)BOOL v95 = v56;
          _os_log_impl( &dword_181A5C000,  v54,  v57,  "%{public}s called with null browser, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v56);
        goto LABEL_119;
      }

      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_181A5C000, v54, v57, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v59 = v79[0];
      if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_dns_service_browse_callback";
        _os_log_impl( &dword_181A5C000,  v54,  v59,  "%{public}s called with null browser, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v33) {
    free(v33);
  }
  v60[0] = MEMORY[0x1895F87A8];
  v60[1] = 3221225472LL;
  v60[2] = __nw_activity_retrieve_metrics_block_invoke;
  v60[3] = &unk_189BC8740;
  os_log_type_t v61 = v8;
  uint64_t v49 = (dispatch_queue_s *)v6;
  os_log_type_t v50 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v10, 0, v60);
  dispatch_async(v49, v50);

LABEL_22:
}
              }
            }

    if (!v5)
    {
LABEL_100:
      uint64_t v5 = 0LL;
LABEL_101:

      return (BOOL)v5;
    }

    a1 = v28;
    if (v30) {
      free(v30);
    }
    BOOL v16 = 0LL;
    goto LABEL_35;
  }

  uint64_t v9 = a1[6];
  if (!v9)
  {
    uint64_t v28 = a1;
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_necp_append_tlv";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (__nwlog_fault(v30, type, v58))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v31, v34, "%{public}s called with null beyond", applier, 0xCu);
        }

  if (v47) {
    free(v47);
  }
  effective_process_name = 0LL;
LABEL_79:

  return effective_process_name;
}

    if (v66) {
      free(v66);
    }
    mode = 0;
    goto LABEL_101;
  }

  mode = v1->mode;

  if (mode == 2)
  {
    int v4 = nw_endpoint_handler_copy_flow(v2);
    uint64_t v5 = v4;
    if (*((void *)v4 + 127))
    {
      uint64_t v6 = *((_DWORD *)v4 + 252);
      if (!v6) {
        uint64_t v6 = 5;
      }
      v89 = v6;
      uint64_t v7 = (void *)*((void *)v4 + 51);
      if (!v7) {
        goto LABEL_30;
      }
      unsigned int v8 = v7[3];
      if (!v8) {
        goto LABEL_30;
      }
      uint64_t v9 = *(uint64_t (**)(void))(v8 + 144);
      if (!v9) {
        goto LABEL_30;
      }
      os_log_type_t v10 = (void *)v7[5];
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = v7[11];
        if (v17) {
          v7[11] = v17 + 1;
        }
        uint64_t v11 = -1;
      }

      else
      {
        uint64_t v11 = 0;
      }

      *(void *)buf = v7;
      buf[8] = v11;
      uint64_t v18 = (void *)*((void *)v5 + 52);
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v20 = *((void *)v5 + 58);
        if (v20) {
          *((void *)v5 + 58) = v20 + 1;
        }
        char v19 = -1;
      }

      else
      {
        char v19 = 0;
      }

      *(void *)os_log_type_t type = (char *)v5 + 376;
      v91 = v19;
      int v21 = v9();
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_26:
          if ((v21 & 1) != 0) {
            goto LABEL_81;
          }
LABEL_30:
          uint64_t v22 = v2;
          __int16 v23 = (*((_BYTE *)v22 + 268) & 0x20) == 0;

          if (v23)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v24 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              __int16 v25 = v22;

              int v26 = v25;
              int v27 = (*((_BYTE *)v22 + 268) & 1) == 0;

              if (v27) {
                uint64_t v28 = "";
              }
              else {
                uint64_t v28 = "dry-run ";
              }
              unint64_t v29 = nw_endpoint_handler_copy_endpoint(v26);
              logging_description = nw_endpoint_get_logging_description(v29);
              os_log_type_t v31 = v26;
              uint64_t v32 = v31;
              v33 = v31[30];
              else {
                os_log_type_t v34 = off_189BBBBF0[v33];
              }
              os_log_type_t v87 = v34;

              unint64_t v35 = v32;
              uint64_t v36 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  uint64_t v36 = "resolver";
                  break;
                case 2:
                  uint64_t v36 = nw_endpoint_flow_mode_string(v35[31]);
                  break;
                case 3:
                  uint64_t v36 = "proxy";
                  break;
                case 4:
                  uint64_t v36 = "fallback";
                  break;
                case 5:
                  uint64_t v36 = "transform";
                  break;
                default:
                  uint64_t v36 = "unknown-mode";
                  break;
              }

              uint64_t v86 = v36;

              os_log_type_t v57 = v35;
              BOOL v58 = v25;
              os_unfair_lock_lock((os_unfair_lock_t)v57 + 28);
              uint64_t v59 = v57[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v57 + 28);

              uint64_t v60 = v59;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
              v93 = 2082;
              id_str = v58->id_str;
              BOOL v95 = 2082;
              uint64_t v96 = v28;
              uint64_t v97 = 2082;
              os_log_type_t v98 = (void *)logging_description;
              uint64_t v99 = 2082;
              uint64_t v100 = v87;
              v101 = 2082;
              unint64_t v102 = v86;
              v103 = 2114;
              int v104 = v60;
              v105 = 2082;
              v106 = "read_timeout";
              _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification f or %{public}s failed",  buf,  0x52u);
            }

    if (v66) {
      free(v66);
    }
    mode = 0;
    goto LABEL_101;
  }

  mode = v1->mode;

  if (mode == 2)
  {
    int v4 = nw_endpoint_handler_copy_flow(v2);
    uint64_t v5 = v4;
    if (*((void *)v4 + 128))
    {
      uint64_t v6 = *((_DWORD *)v4 + 253);
      if (!v6) {
        uint64_t v6 = 5;
      }
      v89 = v6;
      uint64_t v7 = (void *)*((void *)v4 + 51);
      if (!v7) {
        goto LABEL_30;
      }
      unsigned int v8 = v7[3];
      if (!v8) {
        goto LABEL_30;
      }
      uint64_t v9 = *(uint64_t (**)(void))(v8 + 144);
      if (!v9) {
        goto LABEL_30;
      }
      os_log_type_t v10 = (void *)v7[5];
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = v7[11];
        if (v17) {
          v7[11] = v17 + 1;
        }
        uint64_t v11 = -1;
      }

      else
      {
        uint64_t v11 = 0;
      }

      *(void *)buf = v7;
      buf[8] = v11;
      uint64_t v18 = (void *)*((void *)v5 + 52);
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v20 = *((void *)v5 + 58);
        if (v20) {
          *((void *)v5 + 58) = v20 + 1;
        }
        char v19 = -1;
      }

      else
      {
        char v19 = 0;
      }

      *(void *)os_log_type_t type = (char *)v5 + 376;
      v91 = v19;
      int v21 = v9();
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_26:
          if ((v21 & 1) != 0) {
            goto LABEL_81;
          }
LABEL_30:
          uint64_t v22 = v2;
          __int16 v23 = (*((_BYTE *)v22 + 268) & 0x20) == 0;

          if (v23)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v24 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              __int16 v25 = v22;

              int v26 = v25;
              int v27 = (*((_BYTE *)v22 + 268) & 1) == 0;

              if (v27) {
                uint64_t v28 = "";
              }
              else {
                uint64_t v28 = "dry-run ";
              }
              unint64_t v29 = nw_endpoint_handler_copy_endpoint(v26);
              logging_description = nw_endpoint_get_logging_description(v29);
              os_log_type_t v31 = v26;
              uint64_t v32 = v31;
              v33 = v31[30];
              else {
                os_log_type_t v34 = off_189BBBBF0[v33];
              }
              os_log_type_t v87 = v34;

              unint64_t v35 = v32;
              uint64_t v36 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  uint64_t v36 = "resolver";
                  break;
                case 2:
                  uint64_t v36 = nw_endpoint_flow_mode_string(v35[31]);
                  break;
                case 3:
                  uint64_t v36 = "proxy";
                  break;
                case 4:
                  uint64_t v36 = "fallback";
                  break;
                case 5:
                  uint64_t v36 = "transform";
                  break;
                default:
                  uint64_t v36 = "unknown-mode";
                  break;
              }

              uint64_t v86 = v36;

              os_log_type_t v57 = v35;
              BOOL v58 = v25;
              os_unfair_lock_lock((os_unfair_lock_t)v57 + 28);
              uint64_t v59 = v57[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v57 + 28);

              uint64_t v60 = v59;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
              v93 = 2082;
              id_str = v58->id_str;
              BOOL v95 = 2082;
              uint64_t v96 = v28;
              uint64_t v97 = 2082;
              os_log_type_t v98 = (void *)logging_description;
              uint64_t v99 = 2082;
              uint64_t v100 = v87;
              v101 = 2082;
              unint64_t v102 = v86;
              v103 = 2114;
              int v104 = v60;
              v105 = 2082;
              v106 = "write_timeout";
              _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification f or %{public}s failed",  buf,  0x52u);
            }

      if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v48 = gconnectionLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v49 = *(_DWORD *)(a3 + 368);
        *(_DWORD *)buf = 136447234;
        os_log_type_t v87 = "nw_http2_sending_ping";
        uint64_t v88 = 2082;
        *(void *)v89 = a3 + 390;
        *(_WORD *)&v89[8] = 2080;
        *(void *)os_log_type_t v90 = " ";
        *(_WORD *)&v90[8] = 1024;
        *(_DWORD *)v91 = v49;
        *(_WORD *)&v91[4] = 2048;
        *(void *)&v91[6] = v39;
        int v26 = "%{public}s %{public}s%s<i%u> unrecognized ping data %llu";
        int v27 = (os_log_s *)v48;
        uint64_t v28 = OS_LOG_TYPE_ERROR;
        unint64_t v29 = 48;
        goto LABEL_103;
      }

      return 0LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v87 = "on_frame_send_callback";
    char v64 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v85 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v65 = (os_log_s *)__nwlog_obj();
      uint64_t v66 = type[0];
      if (os_log_type_enabled(v65, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2";
        goto LABEL_156;
      }

      goto LABEL_157;
    }

    if (!v85)
    {
      unsigned int v65 = (os_log_s *)__nwlog_obj();
      uint64_t v66 = type[0];
      if (os_log_type_enabled(v65, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
        goto LABEL_156;
      }

      goto LABEL_157;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v65 = (os_log_s *)__nwlog_obj();
    uint64_t v66 = type[0];
    os_log_type_t v72 = os_log_type_enabled(v65, type[0]);
    if (!backtrace_string)
    {
      if (v72)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
        goto LABEL_156;
      }

      goto LABEL_157;
    }

    if (v72)
    {
LABEL_142:
      *(_DWORD *)buf = 136446466;
      os_log_type_t v87 = "on_frame_send_callback";
      uint64_t v88 = 2082;
      *(void *)v89 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v15)
  {
LABEL_99:
    uint64_t v45 = (char *)v15;
    goto LABEL_100;
  }

  return a1 != 0;
}

    LODWORD(v52) = v52 | 0x10;
    if (a11)
    {
LABEL_85:
      LODWORD(v52) = v52 | 0x20;
      if (!a12) {
        goto LABEL_86;
      }
      goto LABEL_100;
    }

    if (v32) {
      free(v32);
    }
    uint64_t v51 = v17;
    goto LABEL_107;
  }

  char v19 = v18;
  if (!nw_protocol_options_is_test_protocol(v18))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v72 = "nw_protocol_test_access_options";
    uint64_t v36 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v69 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = (os_log_s *)gLogObj;
      v38 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v72 = "nw_protocol_test_access_options";
      os_log_type_t v39 = "%{public}s Failed to copy test protocol options";
    }

    else if (v69)
    {
      uint64_t v45 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = (os_log_s *)gLogObj;
      v38 = type;
      int v46 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v45)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v72 = "nw_protocol_test_access_options";
          v73 = 2082;
          v74 = v45;
          _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v45);
        goto LABEL_104;
      }

      if (!v46)
      {
LABEL_104:
        if (v36) {
          free(v36);
        }
        goto LABEL_106;
      }

      *(_DWORD *)buf = 136446210;
      os_log_type_t v72 = "nw_protocol_test_access_options";
      os_log_type_t v39 = "%{public}s Failed to copy test protocol options, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = (os_log_s *)gLogObj;
      v38 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v72 = "nw_protocol_test_access_options";
      os_log_type_t v39 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v37, v38, v39, buf, 0xCu);
    goto LABEL_104;
  }

  ___ZL39nw_protocol_test_get_message_propertiesP11nw_protocolS0_P30nw_protocol_message_properties_block_invoke( (uint64_t)v68,  v19);
LABEL_106:
  os_release(v17);
  uint64_t v51 = v19;
LABEL_107:
  os_release(v51);
}

LABEL_117:
        if (v85) {
          free(v85);
        }
        *((_WORD *)v23 + 14) = 0;
        uint64_t v22 = v143;
LABEL_120:
        if (*((_BYTE *)v24 + 30) == 2 && !*((_WORD *)v24 + 14)) {
          nw_hash_node_free((uint64_t)v22, v24);
        }
        if ((v64 & 1) == 0)
        {
          if (v23 && *((_BYTE *)v23 + 30) == 2 && !*((_WORD *)v23 + 14)) {
            nw_hash_node_free((uint64_t)v22, v23);
          }
LABEL_138:
          LODWORD(v5) = *((_DWORD *)v3 + 11);
LABEL_139:
          *((_DWORD *)v3 + 11) = v5 - 1;
          if ((_DWORD)v5)
          {
            int v113 = *((_DWORD *)v3 + 12);
            if ((_DWORD)v5 != 1)
            {
              if ((v113 & 2) != 0) {
                goto LABEL_142;
              }
              return;
            }

        v71 = v34;

        BOOL v136 = v71;
        goto LABEL_118;
      }

    if (v95) {
      free(v95);
    }
    a3 = v338;
    goto LABEL_120;
  }

  if (nw_endpoint_handler_get_minimize_logging(v9))
  {
    if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v13 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v78 = nw_endpoint_handler_get_id_string(v9);
        uint64_t v79 = nw_endpoint_handler_dry_run_string(v9);
        v352 = v9;
        os_log_type_t v80 = nw_endpoint_handler_copy_endpoint(v9);
        uint64_t v81 = nw_endpoint_get_logging_description(v80);
        uint64_t v82 = nw_endpoint_handler_state_string(v352);
        unsigned int v83 = nw_endpoint_handler_mode_string(v352);
        uint64_t v84 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v352);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v78;
        *(_WORD *)&buf[22] = 2082;
        v379 = v79;
        *(_WORD *)v380 = 2082;
        *(void *)&v380[2] = v81;
        *(_WORD *)&v380[10] = 2082;
        *(void *)&v380[12] = v82;
        v381 = 2082;
        v382 = v83;
        v383 = 2114;
        v384 = v84;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring resolver update",  buf,  0x48u);
      }

      goto LABEL_82;
    }
  }

  else
  {
    uint64_t v11 = v9;
    BOOL v12 = *((_BYTE *)v11 + 268);

    if ((v12 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v13 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        char v14 = v11;

        os_log_type_t v15 = v14;
        BOOL v16 = *((_BYTE *)v11 + 268);

        if ((v16 & 1) != 0) {
          uint64_t v17 = "dry-run ";
        }
        else {
          uint64_t v17 = "";
        }
        uint64_t v18 = nw_endpoint_handler_copy_endpoint(v15);
        char v19 = nw_endpoint_get_logging_description(v18);
        v365 = v6;
        os_log_type_t v20 = v14->id_str;
        int v21 = v15;
        uint64_t v22 = v21;
        __int16 v23 = v9->state;
        else {
          uint64_t v24 = off_189BBBBF0[v23];
        }

        uint64_t v60 = v22;
        os_log_type_t v61 = v60;
        uint64_t v62 = "path";
        switch(v7[29])
        {
          case 0u:
            break;
          case 1u:
            uint64_t v62 = "resolver";
            break;
          case 2u:
            uint64_t v62 = nw_endpoint_flow_mode_string(v60[31]);
            break;
          case 3u:
            uint64_t v62 = "proxy";
            break;
          case 4u:
            uint64_t v62 = "fallback";
            break;
          case 5u:
            uint64_t v62 = "transform";
            break;
          default:
            uint64_t v62 = "unknown-mode";
            break;
        }

        uint64_t v66 = v61;
        os_unfair_lock_lock((os_unfair_lock_t)v66 + 28);
        v67 = v66[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v66 + 28);

        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v20;
        *(_WORD *)&buf[22] = 2082;
        v379 = v17;
        *(_WORD *)v380 = 2082;
        *(void *)&v380[2] = v19;
        *(_WORD *)&v380[10] = 2082;
        *(void *)&v380[12] = v24;
        v381 = 2082;
        v382 = v62;
        v383 = 2114;
        v384 = v67;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring resolver update",  buf,  0x48u);

        uint64_t v6 = v365;
      }

            _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0x20u);
            goto LABEL_118;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v50 = v197;
          *(void *)os_log_type_t type = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            uint64_t v51 = v26->identifier->name;
            if (!v51) {
              uint64_t v51 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v51;
            *(_WORD *)&buf[22] = 2048;
            v199 = (const char *)v26;
            v52 = *(os_log_s **)type;
            os_log_type_t v53 = v50;
            v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
            goto LABEL_117;
          }
        }

          __src = bswap32(v26);
          if ((unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
          {
            unsigned int v83 = v21;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v67 = (os_log_s *)v3[131];
            if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446978;
              uint64_t v100 = "nw_shoes_create_request";
              v101 = 2082;
              unint64_t v102 = a1 + 151;
              v103 = 2082;
              int v104 = "traffic_class";
              v105 = 1024;
              *(_DWORD *)v106 = v26;
              _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s sending tlv: %{public}s(%u)",  buf,  0x26u);
            }

            v57 += nw_shoes_add_tlv( (uint64_t)v35 + (unsigned __int16)(v57 + 2),  (unsigned __int16)(v25 - (v57 + 2)),  1u,  4uLL,  &__src);
            int v21 = v83;
          }

          goto LABEL_121;
        }
      }

      os_log_type_t v50 = 1LL;
      BOOL v77 = v26;
      uint64_t v78 = v22;
      if (bonjour_service_domain) {
        goto LABEL_71;
      }
      goto LABEL_78;
    }

          if (v86) {
            free(v86);
          }
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = -1;
          goto LABEL_120;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (const char *)**(unsigned int **)(a1 + 104);
        *(_DWORD *)buf = 136446978;
        __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v149 = 2082;
        *(void *)__int16 v150 = "maximum_frame_count";
        *(_WORD *)&v150[8] = 2048;
        uint64_t v151 = 1LL;
        __int16 v152 = 2048;
        uint64_t v153 = v38;
        os_log_type_t v39 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v146 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v39, type, &v146))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            BOOL v40 = (os_log_s *)__nwlog_obj();
            uint64_t v41 = type[0];
            if (os_log_type_enabled(v40, type[0]))
            {
              uint64_t v42 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(void *)__int16 v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v42;
              os_log_type_t v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_78:
              _os_log_impl(&dword_181A5C000, v40, v41, v43, buf, 0x2Au);
            }
          }

          else if (v146)
          {
            os_log_type_t v61 = (char *)__nw_create_backtrace_string();
            BOOL v40 = (os_log_s *)__nwlog_obj();
            uint64_t v41 = type[0];
            uint64_t v62 = os_log_type_enabled(v40, type[0]);
            if (v61)
            {
              if (v62)
              {
                uint64_t v63 = (const char *)**(unsigned int **)(a1 + 104);
                *(_DWORD *)buf = 136447234;
                __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)__int16 v150 = "maximum_frame_count";
                *(_WORD *)&v150[8] = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v63;
                __int16 v154 = 2082;
                v155 = v61;
                _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v61);
              goto LABEL_79;
            }

            if (v62)
            {
              uint64_t v68 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(void *)__int16 v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v68;
              os_log_type_t v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_78;
            }
          }

          else
          {
            BOOL v40 = (os_log_s *)__nwlog_obj();
            uint64_t v41 = type[0];
            if (os_log_type_enabled(v40, type[0]))
            {
              v67 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              __int16 v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(void *)__int16 v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v67;
              os_log_type_t v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_78;
            }
          }
        }

        unint64_t v29 = metadataa;
        goto LABEL_38;
      }

      goto LABEL_38;
    }

    if (v53) {
      free(v53);
    }
    goto LABEL_119;
  }

  os_log_type_t v10 = strdup(a1);
  if (v10)
  {
LABEL_7:
    *((void *)v9 + 1) = v10;
LABEL_8:
    uint64_t v11 = (void *)*((void *)v9 + 2);
    if ((*((_BYTE *)v9 + 24) & 1) != 0 && v11)
    {
      *((void *)v9 + 2) = 0LL;

      uint64_t v11 = (void *)*((void *)v9 + 2);
    }

    *((void *)v9 + 2) = 0LL;

    BOOL v12 = (void *)*((void *)v9 + 2);
    *((void *)v9 + 2) = v5;

    *((_BYTE *)v9 + 24) |= 1u;
    uint64_t v13 = _Block_copy(v7);

    char v14 = _Block_copy(v13);
    os_log_type_t v15 = (void *)*((void *)v9 + 4);
    if ((*((_BYTE *)v9 + 40) & 1) != 0 && v15)
    {
      *((void *)v9 + 4) = 0LL;

      os_log_type_t v15 = (void *)*((void *)v9 + 4);
    }

    *((void *)v9 + 4) = 0LL;

    BOOL v16 = _Block_copy(v14);
    uint64_t v17 = (void *)*((void *)v9 + 4);
    *((void *)v9 + 4) = v16;

    *((_BYTE *)v9 + 40) |= 1u;
    LODWORD(v81.receiver) = -1;
    uint64_t v18 = (const char *)*((void *)v9 + 1);
    char v19 = (dispatch_queue_s *)*((id *)v9 + 2);
    os_log_type_t v20 = MEMORY[0x1895F87A8];
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = __nw_interface_use_observer_create_block_invoke;
    handler[3] = &unk_189BB70D8;
    uint64_t v7 = v9;
    uint64_t v78 = v7;
    int v21 = notify_register_dispatch(v18, (int *)&v81, v19, handler);

    if (!v21)
    {
      uint64_t v28 = (int)v81.receiver;
      if (LODWORD(v81.receiver) == -1)
      {
        os_log_type_t v31 = 0LL;
      }

      else
      {
        v7[12] = v81.receiver;
        unint64_t v29 = nw_interface_use_observer_get_in_use(v28);
        if (v29 >= 0x100u)
        {
          uint64_t v30 = (dispatch_queue_s *)*((void *)v9 + 2);
          block[0] = v20;
          block[1] = 3221225472LL;
          block[2] = __nw_interface_use_observer_create_block_invoke_5;
          block[3] = &unk_189BB7100;
          v75 = v7;
          os_log_type_t v76 = v29;
          dispatch_async(v30, block);
        }

        os_log_type_t v31 = v7;
      }

      goto LABEL_40;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = (id)gLogObj;
    __int16 v23 = (char *)*((void *)v9 + 1);
    *(_DWORD *)buf = 136446722;
    unsigned int v83 = "nw_interface_use_observer_create";
    uint64_t v84 = 2082;
    v85 = v23;
    uint64_t v86 = 1024;
    os_log_type_t v87 = v21;
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v79 = 0;
    if (__nwlog_fault(v24, &type, &v79))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v25 = (os_log_s *)(id)gLogObj;
        int v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          int v27 = (char *)*((void *)v9 + 1);
          *(_DWORD *)buf = 136446722;
          unsigned int v83 = "nw_interface_use_observer_create";
          uint64_t v84 = 2082;
          v85 = v27;
          uint64_t v86 = 1024;
          os_log_type_t v87 = v21;
          _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s notify_register_dispatch(%{public}s) [status %u] failed",  buf,  0x1Cu);
        }
      }

      else if (v79)
      {
        uint64_t v32 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v25 = (os_log_s *)(id)gLogObj;
        v33 = type;
        os_log_type_t v34 = os_log_type_enabled(v25, type);
        if (v32)
        {
          if (v34)
          {
            unint64_t v35 = (char *)*((void *)v9 + 1);
            *(_DWORD *)buf = 136446978;
            unsigned int v83 = "nw_interface_use_observer_create";
            uint64_t v84 = 2082;
            v85 = v35;
            uint64_t v86 = 1024;
            os_log_type_t v87 = v21;
            uint64_t v88 = 2082;
            v89 = v32;
            _os_log_impl( &dword_181A5C000,  v25,  v33,  "%{public}s notify_register_dispatch(%{public}s) [status %u] failed, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(v32);
          if (!v24) {
            goto LABEL_39;
          }
          goto LABEL_38;
        }

        if (v34)
        {
          v38 = (char *)*((void *)v9 + 1);
          *(_DWORD *)buf = 136446722;
          unsigned int v83 = "nw_interface_use_observer_create";
          uint64_t v84 = 2082;
          v85 = v38;
          uint64_t v86 = 1024;
          os_log_type_t v87 = v21;
          _os_log_impl( &dword_181A5C000,  v25,  v33,  "%{public}s notify_register_dispatch(%{public}s) [status %u] failed, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v25 = (os_log_s *)(id)gLogObj;
        uint64_t v36 = type;
        if (os_log_type_enabled(v25, type))
        {
          v37 = (char *)*((void *)v9 + 1);
          *(_DWORD *)buf = 136446722;
          unsigned int v83 = "nw_interface_use_observer_create";
          uint64_t v84 = 2082;
          v85 = v37;
          uint64_t v86 = 1024;
          os_log_type_t v87 = v21;
          _os_log_impl( &dword_181A5C000,  v25,  v36,  "%{public}s notify_register_dispatch(%{public}s) [status %u] failed, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

    if (!v24)
    {
LABEL_39:
      os_log_type_t v31 = 0LL;
      LODWORD(v81.receiver) = -1;
LABEL_40:

LABEL_41:
      return v31;
    }

    if (v38) {
      free(v38);
    }
    char v14 = 0LL;
    goto LABEL_19;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v63 = "__nw_protocol_replace_input_handler";
  os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v60 = 0;
  if (__nwlog_fault(v34, &type, &v60))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      uint64_t v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v63 = "__nw_protocol_replace_input_handler";
        v37 = "%{public}s called with null protocol";
LABEL_110:
        _os_log_impl(&dword_181A5C000, v35, v36, v37, buf, 0xCu);
      }
    }

    else if (v60)
    {
      os_log_type_t v50 = (char *)__nw_create_backtrace_string();
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      uint64_t v36 = type;
      uint64_t v51 = os_log_type_enabled(v35, type);
      if (v50)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v63 = "__nw_protocol_replace_input_handler";
          char v64 = 2082;
          unsigned int v65 = v50;
          _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v50);
        goto LABEL_111;
      }

      if (v51)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v63 = "__nw_protocol_replace_input_handler";
        v37 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_110;
      }
    }

    else
    {
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      uint64_t v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v63 = "__nw_protocol_replace_input_handler";
        v37 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_110;
      }
    }
  }

    if (v83) {
      free(v83);
    }
    goto LABEL_79;
  }

  unsigned int v8 = v7;
  uint64_t v9 = v8[2];

  if (nw_interface_shallow_compare(v9, v5))
  {

    goto LABEL_9;
  }

  os_log_type_t v72 = *(void *)(a1 + 32);
  if (!v72 || (*(char *)(v72 + 405) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v73 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      v74 = *(void *)(a1 + 32);
      v75 = v74 == 0;
      if (v74) {
        os_log_type_t v76 = (const char *)(v74 + 407);
      }
      else {
        os_log_type_t v76 = "";
      }
      *(_DWORD *)buf = 136446978;
      v108 = "nw_protocol_instance_update_available_paths_block_invoke";
      int v109 = 2082;
      v110 = (void *)v76;
      if (v75) {
        BOOL v77 = "";
      }
      else {
        BOOL v77 = " ";
      }
      v111 = 2080;
      v112 = v77;
      int v113 = 2112;
      uint64_t v114 = (uint64_t)v5;
      _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSkipping path over %@, doesn't match endpoint interface",  buf,  0x2Au);
    }
  }

LABEL_80:
}

              goto LABEL_82;
            }

            if (type[0] == OS_LOG_TYPE_DEFAULT)
            {
              __nwlog_obj();
              uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v55 = type[4];
              if (os_log_type_enabled(v30, type[4]))
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v62 = "nw_protocol_implementation_updated_path";
                _os_log_impl( &dword_181A5C000,  v30,  v55,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_117;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v49 = type[4];
            os_log_type_t v50 = os_log_type_enabled(v30, type[4]);
            if (!backtrace_string)
            {
              if (v50)
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v62 = "nw_protocol_implementation_updated_path";
                _os_log_impl(&dword_181A5C000, v30, v49, "%{public}s called with null path, no backtrace", buf, 0xCu);
              }

              goto LABEL_117;
            }

            if (v50)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v62 = "nw_protocol_implementation_updated_path";
              uint64_t v63 = 2082;
              char v64 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v30,  v49,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            goto LABEL_81;
          }

        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        goto LABEL_118;
      }

      __nwlog_obj();
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v169 = "nw_protocol_implementation_connect";
      v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v54 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null instance->parent_definition->start",  buf,  0xCu);
        }

            goto LABEL_118;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v14 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v79 = nw_endpoint_handler_get_id_string(v9);
            os_log_type_t v80 = nw_endpoint_handler_dry_run_string(v9);
            uint64_t v81 = nw_endpoint_handler_copy_endpoint(v9);
            uint64_t v82 = nw_endpoint_get_logging_description(v81);
            unsigned int v83 = nw_endpoint_handler_state_string(v119);
            uint64_t v84 = nw_endpoint_handler_mode_string(v119);
            v85 = nw_endpoint_handler_copy_current_path(v119);
            *(_DWORD *)buf = 136448002;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            v130 = 2082;
            id_str = (char *)v79;
            v132 = 2082;
            os_log_type_t v133 = v80;
            v134 = 2082;
            v135 = (void *)v82;
            BOOL v136 = 2082;
            v137 = v83;
            BOOL v138 = 2082;
            v139 = v84;
            BOOL v140 = 2114;
            int v141 = v85;
            v142 = 2112;
            v143 = v8;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding interface option d etails %@ to endpoint handler",  buf,  0x52u);

            uint64_t v11 = &qword_18C45F000;
          }
        }

        else
        {
          BOOL v12 = v9;
          uint64_t v13 = *((_BYTE *)v12 + 268);

          if ((v13 & 0x20) != 0) {
            goto LABEL_55;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v14 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            os_log_type_t v15 = v12;

            BOOL v16 = v15;
            uint64_t v17 = *((_BYTE *)v12 + 268);

            if ((v17 & 1) != 0) {
              uint64_t v18 = "dry-run ";
            }
            else {
              uint64_t v18 = "";
            }
            char v19 = nw_endpoint_handler_copy_endpoint(v16);
            os_log_type_t v117 = nw_endpoint_get_logging_description(v19);
            os_log_type_t v20 = v15->id_str;
            int v21 = v16;
            uint64_t v22 = v21;
            __int16 v23 = v21[30];
            else {
              uint64_t v24 = off_189BBBBF0[v23];
            }

            unint64_t v35 = v22;
            uint64_t v36 = v35;
            v37 = "path";
            switch(v9->mode)
            {
              case 0:
                break;
              case 1:
                v37 = "resolver";
                break;
              case 2:
                v37 = nw_endpoint_flow_mode_string(v35[31]);
                break;
              case 3:
                v37 = "proxy";
                break;
              case 4:
                v37 = "fallback";
                break;
              case 5:
                v37 = "transform";
                break;
              default:
                v37 = "unknown-mode";
                break;
            }

            uint64_t v41 = v36;
            os_unfair_lock_lock((os_unfair_lock_t)v41 + 28);
            uint64_t v42 = v41[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v41 + 28);

            *(_DWORD *)buf = 136448002;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            v130 = 2082;
            id_str = v20;
            v132 = 2082;
            os_log_type_t v133 = v18;
            v134 = 2082;
            v135 = (void *)v117;
            BOOL v136 = 2082;
            v137 = v24;
            BOOL v138 = 2082;
            v139 = v37;
            BOOL v140 = 2114;
            int v141 = v42;
            v142 = 2112;
            v143 = v120;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding interface option d etails %@ to endpoint handler",  buf,  0x52u);

            uint64_t v11 = &qword_18C45F000;
          }
        }

        uint64_t v9 = v119;
        unsigned int v8 = v120;
        goto LABEL_55;
      }

      __nwlog_obj();
      BOOL v77 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v129 = "nw_endpoint_handler_add_extra_interface_option";
      int v27 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v124) = 0;
      if (__nwlog_fault(v27, type, &v124))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v78 = type[0];
          if (os_log_type_enabled(v28, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            _os_log_impl(&dword_181A5C000, v28, v78, "%{public}s called with null interface_option_details", buf, 0xCu);
          }
        }

        else if ((_BYTE)v124)
        {
          v92 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v93 = type[0];
          os_log_type_t v94 = os_log_type_enabled(v28, type[0]);
          if (v92)
          {
            if (v94)
            {
              *(_DWORD *)buf = 136446466;
              v129 = "nw_endpoint_handler_add_extra_interface_option";
              v130 = 2082;
              id_str = v92;
              _os_log_impl( &dword_181A5C000,  v28,  v93,  "%{public}s called with null interface_option_details, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v92);
            if (!v27) {
              goto LABEL_119;
            }
            goto LABEL_110;
          }

          if (v94)
          {
            *(_DWORD *)buf = 136446210;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            _os_log_impl( &dword_181A5C000,  v28,  v93,  "%{public}s called with null interface_option_details, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v108 = type[0];
          if (os_log_type_enabled(v28, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            _os_log_impl( &dword_181A5C000,  v28,  v108,  "%{public}s called with null interface_option_details, backtrace limit exceeded",  buf,  0xCu);
          }
        }

            goto LABEL_118;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v16 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v125 = nw_endpoint_handler_get_id_string(v9);
            os_log_type_t v87 = nw_endpoint_handler_dry_run_string(v9);
            uint64_t v88 = nw_endpoint_handler_copy_endpoint(v9);
            v89 = nw_endpoint_get_logging_description(v88);
            os_log_type_t v90 = nw_endpoint_handler_state_string(v9);
            v91 = nw_endpoint_handler_mode_string(v9);
            v92 = nw_endpoint_handler_copy_current_path(v9);
            *(_DWORD *)buf = 136448002;
            v137 = "nw_endpoint_handler_remove_extra_interface_option";
            BOOL v138 = 2082;
            v139 = (void *)v125;
            BOOL v140 = 2082;
            int v141 = v87;
            v142 = 2082;
            v143 = (void *)v89;
            char v144 = 2082;
            v145 = v90;
            v146 = 2082;
            v147 = v91;
            __int16 v148 = 2114;
            v149 = v92;
            __int16 v150 = 2112;
            uint64_t v151 = v128;
            _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removing interface option details %@",  buf,  0x52u);
          }
        }

        else
        {
          char v14 = v9;
          os_log_type_t v15 = *((_BYTE *)v14 + 268);

          if ((v15 & 0x20) != 0) {
            goto LABEL_76;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v16 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            uint64_t v17 = v14;

            uint64_t v18 = v17;
            char v19 = *((_BYTE *)v14 + 268);

            if ((v19 & 1) != 0) {
              os_log_type_t v20 = "dry-run ";
            }
            else {
              os_log_type_t v20 = "";
            }
            int v21 = nw_endpoint_handler_copy_endpoint(v18);
            uint64_t v22 = nw_endpoint_get_logging_description(v21);
            __int16 v23 = v17->id_str;
            uint64_t v24 = v18;
            __int16 v25 = v24;
            int v26 = v24[30];
            else {
              int v27 = off_189BBBBF0[v26];
            }
            uint64_t v122 = v27;

            v55 = v25;
            v56 = v55;
            uint64_t v124 = v9;
            os_log_type_t v57 = v9->mode;
            BOOL v58 = v22;
            uint64_t v59 = "path";
            switch(v57)
            {
              case 0:
                break;
              case 1:
                uint64_t v59 = "resolver";
                break;
              case 2:
                uint64_t v59 = nw_endpoint_flow_mode_string(v55[31]);
                break;
              case 3:
                uint64_t v59 = "proxy";
                break;
              case 4:
                uint64_t v59 = "fallback";
                break;
              case 5:
                uint64_t v59 = "transform";
                break;
              default:
                uint64_t v59 = "unknown-mode";
                break;
            }

            char v64 = v56;
            os_unfair_lock_lock((os_unfair_lock_t)v64 + 28);
            unsigned int v65 = v64[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v64 + 28);

            *(_DWORD *)buf = 136448002;
            v137 = "nw_endpoint_handler_remove_extra_interface_option";
            BOOL v138 = 2082;
            v139 = v23;
            BOOL v140 = 2082;
            int v141 = v20;
            v142 = 2082;
            v143 = (void *)v58;
            char v144 = 2082;
            v145 = v122;
            v146 = 2082;
            v147 = v59;
            __int16 v148 = 2114;
            v149 = v65;
            __int16 v150 = 2112;
            uint64_t v151 = v128;
            _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removing interface option details %@",  buf,  0x52u);

            uint64_t v9 = v124;
          }
        }

        unsigned int v8 = v128;
        goto LABEL_76;
      }

      __nwlog_obj();
      unsigned int v83 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v137 = "nw_endpoint_handler_remove_extra_interface_option";
      uint64_t v84 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v132) = 0;
      if (__nwlog_fault(v84, type, &v132))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v86 = type[0];
          if (os_log_type_enabled(v85, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v137 = "nw_endpoint_handler_remove_extra_interface_option";
            _os_log_impl(&dword_181A5C000, v85, v86, "%{public}s called with null details", buf, 0xCu);
          }
        }

        else if ((_BYTE)v132)
        {
          os_log_type_t v98 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v99 = type[0];
          uint64_t v100 = os_log_type_enabled(v85, type[0]);
          if (v98)
          {
            if (v100)
            {
              *(_DWORD *)buf = 136446466;
              v137 = "nw_endpoint_handler_remove_extra_interface_option";
              BOOL v138 = 2082;
              v139 = v98;
              _os_log_impl( &dword_181A5C000,  v85,  v99,  "%{public}s called with null details, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v98);
            goto LABEL_176;
          }

          if (v100)
          {
            *(_DWORD *)buf = 136446210;
            v137 = "nw_endpoint_handler_remove_extra_interface_option";
            _os_log_impl(&dword_181A5C000, v85, v99, "%{public}s called with null details, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v113 = type[0];
          if (os_log_type_enabled(v85, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v137 = "nw_endpoint_handler_remove_extra_interface_option";
            _os_log_impl( &dword_181A5C000,  v85,  v113,  "%{public}s called with null details, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    free(backtrace_string);
  }

        unsigned int v65 = 0;
LABEL_118:
        pthread_mutex_unlock(&sOutstandingPacURLMutex);

        if (v65) {
          uint64_t v88 = 64;
        }
        else {
          uint64_t v88 = 0;
        }
        goto LABEL_121;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v77 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
      uint64_t v78 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v261) = 0;
      if (__nwlog_fault(v78, type, &v261))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v79 = (os_log_s *)(id)gLogObj;
          os_log_type_t v80 = type[0];
          if (os_log_type_enabled(v79, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
            _os_log_impl(&dword_181A5C000, v79, v80, "%{public}s nw_get_outstanding_pac_urls failed", buf, 0xCu);
          }
        }

        else if ((_BYTE)v261)
        {
          uint64_t v84 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v79 = (os_log_s *)(id)gLogObj;
          v85 = type[0];
          uint64_t v86 = os_log_type_enabled(v79, type[0]);
          if (v84)
          {
            if (v86)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v84;
              _os_log_impl( &dword_181A5C000,  v79,  v85,  "%{public}s nw_get_outstanding_pac_urls failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v84);
            if (!v78) {
              goto LABEL_117;
            }
            goto LABEL_116;
          }

          if (v86)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
            _os_log_impl( &dword_181A5C000,  v79,  v85,  "%{public}s nw_get_outstanding_pac_urls failed, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v79 = (os_log_s *)(id)gLogObj;
          os_log_type_t v87 = type[0];
          if (os_log_type_enabled(v79, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
            _os_log_impl( &dword_181A5C000,  v79,  v87,  "%{public}s nw_get_outstanding_pac_urls failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v78) {
        goto LABEL_117;
      }
LABEL_116:
      free(v78);
      goto LABEL_117;
    }

    __nwlog_obj();
    v208 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
    v209 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v261) = 0;
    if (__nwlog_fault(v209, type, &v261))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v210 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v211 = type[0];
        if (os_log_type_enabled(v210, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
          _os_log_impl(&dword_181A5C000, v210, v211, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if ((_BYTE)v261)
      {
        v213 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v210 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v214 = type[0];
        v215 = os_log_type_enabled(v210, type[0]);
        if (v213)
        {
          if (v215)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v213;
            _os_log_impl( &dword_181A5C000,  v210,  v214,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v213);
          goto LABEL_267;
        }

        if (v215)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
          _os_log_impl(&dword_181A5C000, v210, v214, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v210 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v216 = type[0];
        if (os_log_type_enabled(v210, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_pac_resolver_endpoint_is_pac_url";
          _os_log_impl( &dword_181A5C000,  v210,  v216,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  BOOL v77 = *(void *)(v9 + 616);
  uint64_t v78 = *(void *)(v9 + 632);
  uint64_t v79 = *v10 & 0x204;
  if ((*v10 & 0x2000) != 0)
  {
    v89 = v77 | v78;
    os_log_type_t v90 = (v77 | v78) == 0;
    v91 = ((*v10 | (*((unsigned __int8 *)v10 + 2) << 16)) >> 9) & 1;
    if (v79 == 4) {
      v91 = 1;
    }
    if (v89 || !v91)
    {
      if (v79 == 4) {
        goto LABEL_159;
      }
      if (!v90) {
        goto LABEL_159;
      }
      *(_DWORD *)(v9 + 864) = 5;
      if ((*(_BYTE *)(v9 + 158) & 1) != 0) {
        goto LABEL_159;
      }
      os_log_type_t v80 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_159;
      }
      uint64_t v99 = *(void *)(v9 + 488);
      uint64_t v100 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
      v101 = *(_DWORD *)(v9 + 860);
      if (v99) {
        LODWORD(v99) = *(_DWORD *)(v99 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v9 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v100;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v101;
      LOWORD(v262) = 1024;
      *(_DWORD *)((char *)&v262 + 2) = v99;
      uint64_t v84 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: connection error";
    }

    else
    {
      *(_DWORD *)(v9 + 864) = 4;
      if ((*(_BYTE *)(v9 + 158) & 1) != 0) {
        goto LABEL_159;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v80 = (os_log_s *)gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_159;
      }
      v92 = *(void *)(v9 + 488);
      v93 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
      os_log_type_t v94 = *(_DWORD *)(v9 + 860);
      if (v92) {
        LODWORD(v92) = *(_DWORD *)(v92 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v9 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v93;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v94;
      LOWORD(v262) = 1024;
      *(_DWORD *)((char *)&v262 + 2) = v92;
      uint64_t v84 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: connection complete";
    }

  if (v47) {
    free(v47);
  }
}

        if (v80) {
          free(v80);
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = -1;
LABEL_120:
        os_log_type_t v90 = *(void *)(*(void *)(a1 + 56) + 8LL);
        v91 = *(_DWORD *)(v90 + 24);
        *(_DWORD *)(v90 + 24) = v91 + a3;
        if (!__CFADD__(v91, a3)) {
          return;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v92 = a3;
        v93 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_http1_connection_process_input_frames_block_invoke";
        __int16 v148 = 2082;
        v149 = "bytes_processed";
        __int16 v150 = 2048;
        *(void *)uint64_t v151 = a3;
        *(_WORD *)&v151[8] = 2048;
        *(void *)&v151[10] = v93;
        os_log_type_t v94 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v144 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v95 = (os_log_s *)gLogObj;
          uint64_t v96 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v97 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_http1_connection_process_input_frames_block_invoke";
            __int16 v148 = 2082;
            v149 = "bytes_processed";
            __int16 v150 = 2048;
            *(void *)uint64_t v151 = v92;
            *(_WORD *)&v151[8] = 2048;
            *(void *)&v151[10] = v97;
            os_log_type_t v98 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_135:
            _os_log_impl(&dword_181A5C000, v95, v96, v98, buf, 0x2Au);
          }
        }

        else if (v144)
        {
          uint64_t v99 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v95 = (os_log_s *)gLogObj;
          uint64_t v96 = type;
          uint64_t v100 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v99)
          {
            if (v100)
            {
              v101 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
              *(_DWORD *)buf = 136447234;
              v147 = "nw_http1_connection_process_input_frames_block_invoke";
              __int16 v148 = 2082;
              v149 = "bytes_processed";
              __int16 v150 = 2048;
              *(void *)uint64_t v151 = v92;
              *(_WORD *)&v151[8] = 2048;
              *(void *)&v151[10] = v101;
              *(_WORD *)&v151[18] = 2082;
              __int16 v152 = v99;
              _os_log_impl( &dword_181A5C000,  v95,  v96,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v99);
            goto LABEL_136;
          }

          if (v100)
          {
            v103 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_http1_connection_process_input_frames_block_invoke";
            __int16 v148 = 2082;
            v149 = "bytes_processed";
            __int16 v150 = 2048;
            *(void *)uint64_t v151 = v92;
            *(_WORD *)&v151[8] = 2048;
            *(void *)&v151[10] = v103;
            os_log_type_t v98 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_135;
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v95 = (os_log_s *)gLogObj;
          uint64_t v96 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            unint64_t v102 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_http1_connection_process_input_frames_block_invoke";
            __int16 v148 = 2082;
            v149 = "bytes_processed";
            __int16 v150 = 2048;
            *(void *)uint64_t v151 = v92;
            *(_WORD *)&v151[8] = 2048;
            *(void *)&v151[10] = v102;
            os_log_type_t v98 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_135;
          }
        }

      free(v30);
      goto LABEL_118;
    }

    __nwlog_obj();
    unint64_t v102 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(error) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v103 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
        _os_log_impl(&dword_181A5C000, v31, v103, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else
    {
      if ((_BYTE)error)
      {
        int v104 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v106 = type[0];
        unint64_t v107 = os_log_type_enabled(v105, type[0]);
        if (v104)
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
            LOWORD(v126[0]) = 2082;
            *(void *)((char *)v126 + 2) = v104;
            _os_log_impl( &dword_181A5C000,  v105,  v106,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v104);
        }

        else
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
            _os_log_impl( &dword_181A5C000,  v105,  v106,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
          }
        }

        goto LABEL_116;
      }

      __nwlog_obj();
      os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v109 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
        _os_log_impl( &dword_181A5C000,  v31,  v109,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (!v54) {
      goto LABEL_72;
    }
    goto LABEL_109;
  }

  os_log_type_t v10 = strlen(a4);
  alloc = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v11 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], a2, 0x8000100u);
  if (!strcmp(a4, "clear"))
  {
    [v74[1] removeHTTPAlternativeServiceEntriesWithHost:v11 port:a3];
  }

  else
  {
    uint64_t v68 = v11;
    BOOL v12 = objc_alloc_init(MEMORY[0x189601F50]);
    if (v10 != -1LL)
    {
      cStr = (char *)a2;
      uint64_t v13 = 0LL;
      os_log_type_t v69 = a3;
      char v14 = 2;
      os_log_type_t v15 = MEMORY[0x1895F8770];
      BOOL v16 = a4;
      v75 = v10;
      while (1)
      {
        uint64_t v18 = &a4[v13];
        char v19 = a4[v13];
        if (v19 == 61)
        {
          *uint64_t v18 = 0;
          os_log_type_t v20 = (char *)(v16 - 1);
          do
          {
            while (1)
            {
              uint64_t v22 = v20;
              __int16 v23 = v20[1];
              uint64_t v24 = v20[1];
              if ((v23 & 0x80000000) == 0) {
                break;
              }
            }

            ++v20;
          }

          while ((*(_DWORD *)(v15 + 4LL * v23 + 60) & 0x4000) != 0);
LABEL_15:
          if (v24)
          {
            __int16 v25 = &v22[strlen(v20)];
            while (1)
            {
              int v27 = v25;
              if (v25 <= v20) {
                break;
              }
              uint64_t v28 = *v25;
              if (*v25 < 0)
              {
                int v26 = __maskrune(v28, 0x4000uLL);
                __int16 v25 = v27 - 1;
                if (!v26) {
                  break;
                }
              }

              else
              {
                --v25;
                if ((*(_DWORD *)(v15 + 4 * v28 + 60) & 0x4000) == 0) {
                  break;
                }
              }
            }

            v27[1] = 0;
          }

          uint64_t v18 = &a4[v13];
          BOOL v16 = &a4[v13 + 1];
          if (!strcmp(v20, "h3"))
          {
            [v12 setServiceType:1];
            unint64_t v29 = (__CFString *)CFStringCreateWithCString(alloc, cStr, 0x8000100u);
            [v12 setHost:v29];

            [v12 setPort:v69];
            if (a5)
            {
              uint64_t v30 = (__CFString *)CFStringCreateWithCString(alloc, a5, 0x8000100u);
              [MEMORY[0x189604030] URLWithString:v30];
              os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
              [v31 host];
              uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
              [v12 setPartition:v32];
            }

            char v14 = 0;
            uint64_t v18 = &a4[v13];
          }

          else if (!strcmp(v20, "ma"))
          {
            char v14 = 1;
          }

          else
          {
            char v14 = 2;
          }
        }

        v33 = v19 > 0x3B || ((1LL << v19) & 0x800100000000001LL) == 0;
        if (v33) {
          goto LABEL_9;
        }
        *uint64_t v18 = 0;
        os_log_type_t v34 = v16 - 1;
        do
        {
          uint64_t v36 = v16;
          v37 = v34;
          v38 = *(unsigned __int8 *)v16;
          if (*v16 < 0) {
            unint64_t v35 = __maskrune(*(unsigned __int8 *)v16, 0x4000uLL);
          }
          else {
            unint64_t v35 = *(_DWORD *)(v15 + 4LL * *(unsigned __int8 *)v16 + 60) & 0x4000;
          }
          ++v16;
          ++v34;
        }

        while (v35);
        if (v38)
        {
          os_log_type_t v39 = (char *)&v37[strlen(v36)];
          while (1)
          {
            uint64_t v41 = v39;
            if (v39 <= v36) {
              break;
            }
            uint64_t v42 = *v39;
            if (*v39 < 0)
            {
              BOOL v40 = __maskrune(v42, 0x4000uLL);
              os_log_type_t v39 = v41 - 1;
              if (!v40) {
                break;
              }
            }

            else
            {
              --v39;
              if ((*(_DWORD *)(v15 + 4 * v42 + 60) & 0x4000) == 0) {
                break;
              }
            }
          }

          v41[1] = 0;
        }

        if (v14 == 1) {
          break;
        }
        os_log_type_t v43 = &a4[v13];
        if (!v14)
        {
          uint64_t v44 = v12;
          uint64_t v45 = strlen(v36);
          if (v45 >= 2 && *v36 == 34 && v36[v45 - 1] == 34)
          {
            if (v45 == -1LL)
            {
LABEL_54:
              int v46 = 0LL;
            }

            else
            {
              int v46 = 0LL;
              while (v34[v46] != 58)
              {
                if (v45 + 1 == ++v46) {
                  goto LABEL_54;
                }
              }
            }

            v36[v46] = 0;
            uint64_t v47 = &v36[v46 + 1];
            v36[v45 - 1] = 0;
            if (*v16)
            {
              v48 = (uint64_t)CFStringCreateWithCString(alloc, v36 + 1, 0x8000100u);
            }

            else
            {
              v48 = [v44 host];
            }

            uint64_t v51 = (void *)v48;
            [v44 setAlternateHost:v48];

            if (*v47) {
              v52 = atoi(v47);
            }
            else {
              v52 = [v44 port];
            }
            os_log_type_t v43 = &a4[v13];
            [v44 setAlternatePort:v52];
          }

          goto LABEL_61;
        }

              if (!nw_parameters_get_logging_disabled(*(void *)&v39[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                }
                unsigned int v65 = (os_log_s *)(id)gbrowserLogObj;
                if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
                {
                  if (v18) {
                    uint64_t v66 = (uint64_t)(*(void *)(v18 + 24) - *(void *)(v18 + 16)) >> 3;
                  }
                  else {
                    uint64_t v66 = 0LL;
                  }
                  v67 = v39[48]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v67;
                  *(_WORD *)&buf[18] = 2080;
                  *(void *)&buf[20] = key;
                  *(_WORD *)&buf[28] = 2048;
                  *(void *)&buf[30] = v66;
                  _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] txt: %s has count of %zu in txt_array,",  buf,  0x26u);
                }

                os_log_type_t v39 = v105;
              }

              uint64_t v68 = nw_browser_copy_old_result_locked((NWConcrete_nw_browser *)v39, key);
              os_log_type_t v69 = v68;
              if (v68)
              {
                uint64_t v70 = (id *)v68;
                left = (nw_txt_record *)v70[3];

                os_log_type_t v39 = v105;
              }

              else
              {
                left = 0LL;
              }

              uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)&v16[40]._os_unfair_lock_opaque, key);
              unint64_t v102 = nw_browser_copy_result_to_modify_locked((NWConcrete_nw_browser *)v39, key, uint64);
              if (!nw_parameters_get_logging_disabled(*(void *)&v39[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                }
                os_log_type_t v72 = (os_log_s *)(id)gbrowserLogObj;
                if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
                {
                  v73 = left;
                  if (left)
                  {
                    v74 = *((_DWORD *)left + 4);
                    v73 = (nw_txt_record *)*((void *)left + 1);
                  }

                  else
                  {
                    v74 = 0;
                  }

                  v75 = v39[48]._os_unfair_lock_opaque;
                  if (v40)
                  {
                    BOOL v77 = *((void *)v40 + 1);
                    os_log_type_t v76 = *((void *)v40 + 2);
                  }

                  else
                  {
                    LODWORD(v76) = 0;
                    BOOL v77 = 0LL;
                  }

                  *(_DWORD *)buf = 136447490;
                  *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v75;
                  *(_WORD *)&buf[18] = 1040;
                  *(_DWORD *)&buf[20] = v74;
                  *(_WORD *)&buf[24] = 2096;
                  *(void *)&buf[26] = v73;
                  *(_WORD *)&buf[34] = 1040;
                  *(_DWORD *)&buf[36] = v76;
                  LOWORD(v118) = 2096;
                  *(void *)((char *)&v118 + 2) = v77;
                  _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] txt: txt record changed from %{network:data}.*P to %{network:data}.*P",  buf,  0x32u);
                }

                os_log_type_t v39 = v105;
              }

              if (uint64)
              {
                if (v40)
                {
                  if (*((void *)v40 + 2) == 1LL) {
                    uint64_t v78 = 0LL;
                  }
                  else {
                    uint64_t v78 = v40;
                  }
                }

                else
                {
                  uint64_t v78 = 0LL;
                }

                nw_browse_result_set_txt_record_object((void *)v102, v78);
                *(void *)uint64_t v123 = 0LL;
                ValidationData = (const void *)DNSServiceGetValidationData();
                if (ValidationData && *(void *)v123)
                {
                  endpoint = nw_browse_result_get_endpoint((void *)v102);
                  uint64_t v81 = endpoint;
                }

                uint64_t v82 = uint64 | 0x20;
                xpc_dictionary_set_uint64(*(xpc_object_t *)&v16[40]._os_unfair_lock_opaque, key, v82);
                if (!nw_parameters_get_logging_disabled(*(void *)&v105[10]._os_unfair_lock_opaque))
                {
                  if (__nwlog_browser_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                  }
                  unsigned int v83 = (os_log_s *)(id)gbrowserLogObj;
                  if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v84 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v84;
                    *(_WORD *)&buf[18] = 2080;
                    *(void *)&buf[20] = key;
                    *(_WORD *)&buf[28] = 2048;
                    *(void *)&buf[30] = v82;
                    _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] changes_map: %s |= txt_record_changed(%llu)",  buf,  0x26u);
                  }
                }

                os_log_type_t v39 = v105;
LABEL_161:
                if ((v104 & 1) == 0 && (!v18 || *(void *)(v18 + 24) - *(void *)(v18 + 16) <= 0xFuLL))
                {
                  nw_browser_notify_browse_result_changes_locked((NWConcrete_nw_browser *)v39);
                  if (!nw_parameters_get_logging_disabled(*(void *)&v39[10]._os_unfair_lock_opaque))
                  {
                    if (__nwlog_browser_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                    }
                    v85 = (os_log_s *)(id)gbrowserLogObj;
                    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v86 = v39[48]._os_unfair_lock_opaque;
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v86;
                      *(_WORD *)&buf[18] = 2080;
                      *(void *)&buf[20] = key;
                      _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] txt: notify txt record change for %s",  buf,  0x1Cu);
                    }
                  }
                }

                os_unfair_lock_unlock(v16 + 2);
                goto LABEL_171;
              }

              if (nw_parameters_get_logging_disabled(*(void *)&v39[10]._os_unfair_lock_opaque))
              {
LABEL_202:
                os_unfair_lock_unlock(v16 + 2);

LABEL_171:
                goto LABEL_172;
              }

              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
              }
              os_log_type_t v87 = (id)gbrowserLogObj;
              uint64_t v88 = v105[48]._os_unfair_lock_opaque;
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v88;
              v89 = (char *)_os_log_send_and_compose_impl();

              v123[0] = 16;
              LOBYTE(v111[0]) = 0;
              if (__nwlog_fault(v89, v123, v111))
              {
                if (v123[0] == 17)
                {
                  if (__nwlog_browser_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                  }
                  os_log_type_t v90 = (os_log_s *)(id)gbrowserLogObj;
                  v91 = v123[0];
                  if (os_log_type_enabled(v90, (os_log_type_t)v123[0]))
                  {
                    v92 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v92;
                    _os_log_impl( &dword_181A5C000,  v90,  v91,  "%{public}s [B%u] change should not be invalid",  buf,  0x12u);
                  }
                }

                else if (LOBYTE(v111[0]))
                {
                  backtrace_string = __nw_create_backtrace_string();
                  if (backtrace_string)
                  {
                    os_log_type_t v94 = (char *)backtrace_string;
                    if (__nwlog_browser_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                    }
                    BOOL v95 = (os_log_s *)(id)gbrowserLogObj;
                    uint64_t v96 = v123[0];
                    if (os_log_type_enabled(v95, (os_log_type_t)v123[0]))
                    {
                      uint64_t v97 = v105[48]._os_unfair_lock_opaque;
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v97;
                      *(_WORD *)&buf[18] = 2082;
                      *(void *)&buf[20] = v94;
                      _os_log_impl( &dword_181A5C000,  v95,  v96,  "%{public}s [B%u] change should not be invalid, dumping backtrace:%{public}s",  buf,  0x1Cu);
                    }

                    free(v94);
                    goto LABEL_200;
                  }

                  if (__nwlog_browser_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                  }
                  os_log_type_t v90 = (os_log_s *)(id)gbrowserLogObj;
                  uint64_t v100 = v123[0];
                  if (os_log_type_enabled(v90, (os_log_type_t)v123[0]))
                  {
                    v101 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v101;
                    _os_log_impl( &dword_181A5C000,  v90,  v100,  "%{public}s [B%u] change should not be invalid, no backtrace",  buf,  0x12u);
                  }
                }

                else
                {
                  if (__nwlog_browser_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                  }
                  os_log_type_t v90 = (os_log_s *)(id)gbrowserLogObj;
                  os_log_type_t v98 = v123[0];
                  if (os_log_type_enabled(v90, (os_log_type_t)v123[0]))
                  {
                    uint64_t v99 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v99;
                    _os_log_impl( &dword_181A5C000,  v90,  v98,  "%{public}s [B%u] change should not be invalid, backtrace limit exceeded",  buf,  0x12u);
                  }
                }
              }

          if ((v4 & 0x1000) != 0)
          {
            if ((*v2 & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              os_log_type_t v72 = (os_log_s *)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)os_log_type_t type = 136446466;
                *(void *)&type[4] = "nw_socket_handle_socket_event";
                *(_WORD *)&type[12] = 2082;
                *(void *)&type[14] = v1 + 308;
                _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Socket received DISCONNECTED event",  type,  0x16u);
              }
            }

            if (_nw_signposts_once == -1)
            {
              if (!_nw_signposts_enabled) {
                goto LABEL_192;
              }
            }

            else
            {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
              if (!_nw_signposts_enabled) {
                goto LABEL_192;
              }
            }
          }

          else if ((v6 & 1) == 0)
          {
            if ((v4 & 2) == 0) {
              goto LABEL_130;
            }
            if ((*v2 & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              BOOL v58 = (os_log_s *)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)os_log_type_t type = 136446466;
                *(void *)&type[4] = "nw_socket_handle_socket_event";
                *(_WORD *)&type[12] = 2082;
                *(void *)&type[14] = v1 + 308;
                _os_log_impl( &dword_181A5C000,  v58,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Socket received READ_CLOSE event",  type,  0x16u);
              }
            }

            if (_nw_signposts_once == -1)
            {
              if (_nw_signposts_enabled) {
                goto LABEL_127;
              }
            }

            else
            {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
              if (_nw_signposts_enabled)
              {
LABEL_127:
              }
            }

            nw_socket_input_finished((nw_protocol *)(v1 - 96), v3);
LABEL_130:
            if ((v4 & 4) == 0) {
              goto LABEL_140;
            }
            if ((*v2 & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v59 = (os_log_s *)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)os_log_type_t type = 136446466;
                *(void *)&type[4] = "nw_socket_handle_socket_event";
                *(_WORD *)&type[12] = 2082;
                *(void *)&type[14] = v1 + 308;
                _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Socket received WRITE_CLOSE event",  type,  0x16u);
              }
            }

            if (_nw_signposts_once == -1)
            {
              if (!_nw_signposts_enabled) {
                goto LABEL_140;
              }
            }

            else
            {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
              if (!_nw_signposts_enabled) {
                goto LABEL_140;
              }
            }

  if (!nw_tcp_options_get_retransmit_fin_drop(a2) || !setsockopt(*(_DWORD *)(a1 + 172), 6, 256, v105, 4u)) {
    goto LABEL_142;
  }
  uint64_t v45 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  int v46 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    unint64_t v107 = "nw_socket_set_bidirectional_tcp_sockopts";
    v108 = 2080;
    *(void *)int v109 = a1 + 308;
    *(_WORD *)&v109[8] = 1024;
    *(_DWORD *)&v109[10] = v45;
    _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v47 = (os_log_s *)gLogObj;
  if (v45 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)int v109 = 22;
      _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d",  buf,  0x12u);
    }

    goto LABEL_142;
  }

  *(_DWORD *)buf = 136446466;
  unint64_t v107 = "nw_socket_set_bidirectional_tcp_sockopts";
  v108 = 1024;
  *(_DWORD *)int v109 = v45;
  v48 = (char *)_os_log_send_and_compose_impl();
  v103[0] = OS_LOG_TYPE_ERROR;
  v102[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v48, v103, v102))
  {
    if (v103[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v49 = (os_log_s *)gLogObj;
      os_log_type_t v50 = v103[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v103[0])) {
        goto LABEL_140;
      }
      *(_DWORD *)buf = 136446466;
      unint64_t v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)int v109 = v45;
      uint64_t v51 = "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d";
      goto LABEL_139;
    }

    if (v102[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v49 = (os_log_s *)__nwlog_obj();
      os_log_type_t v50 = v103[0];
      if (!os_log_type_enabled(v49, v103[0])) {
        goto LABEL_140;
      }
      *(_DWORD *)buf = 136446466;
      unint64_t v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)int v109 = v45;
      uint64_t v51 = "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_139;
    }

    v52 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v49 = (os_log_s *)gLogObj;
    os_log_type_t v50 = v103[0];
    os_log_type_t v53 = os_log_type_enabled((os_log_t)gLogObj, v103[0]);
    if (v52)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446722;
        unint64_t v107 = "nw_socket_set_bidirectional_tcp_sockopts";
        v108 = 1024;
        *(_DWORD *)int v109 = v45;
        *(_WORD *)&v109[4] = 2082;
        *(void *)&v109[6] = v52;
        _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v52);
      goto LABEL_140;
    }

    if (v53)
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)int v109 = v45;
      uint64_t v51 = "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, no backtrace";
LABEL_139:
      _os_log_impl(&dword_181A5C000, v49, v50, v51, buf, 0x12u);
    }
  }

      if (!v38) {
        return 0LL;
      }
      uint64_t v36 = (char *)v38;
      goto LABEL_75;
    }

    if (!v47)
    {
      os_log_type_t v39 = (os_log_s *)__nwlog_obj();
      BOOL v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "nw_protocol_http_messaging_remove_input_handler";
        uint64_t v41 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_116;
      }

      goto LABEL_117;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v39 = (os_log_s *)__nwlog_obj();
    BOOL v40 = type;
    int v46 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "nw_protocol_http_messaging_remove_input_handler";
        uint64_t v41 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_116;
      }

      goto LABEL_117;
    }

    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v50 = "nw_protocol_http_messaging_remove_input_handler";
      uint64_t v51 = 2082;
      v52 = (nw_protocol *)backtrace_string;
      uint64_t v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_102;
    }

    goto LABEL_118;
  }

  if (!v88)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v73 = (os_log_s *)(id)gLogObj;
    os_log_type_t v80 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        uint64_t v81 = "unknown-mode";
      }
      else {
        uint64_t v81 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
      os_log_type_t v90 = 2082;
      id_str = (void *)v81;
      v92 = 2082;
      v93 = "flow";
      _os_log_impl( &dword_181A5C000,  v73,  v80,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_117;
  }

  os_log_type_t v76 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v73 = (os_log_s *)(id)gLogObj;
  BOOL v77 = type[0];
  uint64_t v78 = os_log_type_enabled(v73, type[0]);
  if (!v76)
  {
    if (v78)
    {
      if (mode > 5) {
        uint64_t v82 = "unknown-mode";
      }
      else {
        uint64_t v82 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
      os_log_type_t v90 = 2082;
      id_str = (void *)v82;
      v92 = 2082;
      v93 = "flow";
      _os_log_impl( &dword_181A5C000,  v73,  v77,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_117;
  }

  if (v78)
  {
    if (mode > 5) {
      uint64_t v79 = "unknown-mode";
    }
    else {
      uint64_t v79 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
    os_log_type_t v90 = 2082;
    id_str = (void *)v79;
    v92 = 2082;
    v93 = "flow";
    os_log_type_t v94 = 2082;
    BOOL v95 = v76;
    _os_log_impl( &dword_181A5C000,  v73,  v77,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v76);
  if (v72) {
    goto LABEL_119;
  }
LABEL_120:
}

    goto LABEL_118;
  }

  if (!v88)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v73 = (os_log_s *)(id)gLogObj;
    os_log_type_t v80 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        uint64_t v81 = "unknown-mode";
      }
      else {
        uint64_t v81 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
      os_log_type_t v90 = 2082;
      id_str = (void *)v81;
      v92 = 2082;
      v93 = "flow";
      _os_log_impl( &dword_181A5C000,  v73,  v80,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_117;
  }

  os_log_type_t v76 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v73 = (os_log_s *)(id)gLogObj;
  BOOL v77 = type[0];
  uint64_t v78 = os_log_type_enabled(v73, type[0]);
  if (!v76)
  {
    if (v78)
    {
      if (mode > 5) {
        uint64_t v82 = "unknown-mode";
      }
      else {
        uint64_t v82 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
      os_log_type_t v90 = 2082;
      id_str = (void *)v82;
      v92 = 2082;
      v93 = "flow";
      _os_log_impl( &dword_181A5C000,  v73,  v77,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_117;
  }

  if (v78)
  {
    if (mode > 5) {
      uint64_t v79 = "unknown-mode";
    }
    else {
      uint64_t v79 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
    os_log_type_t v90 = 2082;
    id_str = (void *)v79;
    v92 = 2082;
    v93 = "flow";
    os_log_type_t v94 = 2082;
    BOOL v95 = v76;
    _os_log_impl( &dword_181A5C000,  v73,  v77,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v76);
  if (v72) {
    goto LABEL_119;
  }
LABEL_120:
}

          if (v54)
          {
            os_log_type_t v72 = (char *)v54;
LABEL_119:
            free(v72);
          }

          return 0LL;
        }

            _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0x20u);
            goto LABEL_118;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v50 = v197;
          *(void *)os_log_type_t type = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            uint64_t v51 = v26->identifier->name;
            if (!v51) {
              uint64_t v51 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v51;
            *(_WORD *)&buf[22] = 2048;
            v199 = (const char *)v26;
            v52 = *(os_log_s **)type;
            os_log_type_t v53 = v50;
            v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
            goto LABEL_117;
          }
        }

  if (v44) {
    free(v44);
  }
  return v28;
}

    goto LABEL_118;
  }

  if (v9)
  {
    os_log_type_t v10 = (void *)v8[3];
    uint64_t v11 = (void *)v8[17];
    BOOL v12 = (void *)v104[14];
    uint64_t v13 = (void *)v104[12];
    v106 = v9;
    char v14 = v10;
    unint64_t v107 = v104;
    v101 = v11;
    unint64_t v102 = v12;
    v103 = v13;
    uint64_t v100 = v14;
    if (v14)
    {
      os_log_type_t v15 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_masque_connection);
      os_log_type_t v98 = v106;
      BOOL v16 = v14;
      uint64_t v17 = v107;
      uint64_t v18 = v101;
      char v19 = v102;
      os_log_type_t v20 = v103;
      if (!v15) {
        goto LABEL_10;
      }
      aBlock.receiver = v15;
      aBlock.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_masque_connection;
      int v21 = objc_msgSendSuper2(&aBlock, sel_init);
      os_log_type_t v15 = (NWConcrete_nw_masque_connection *)v21;
      if (v21)
      {
        do
          uint64_t v22 = __ldaxr(&s_last_connection_id);
        while (__stlxr(v22 + 1, &s_last_connection_id));
        *((void *)v21 + 1) = v22;
        objc_storeStrong((id *)v21 + 4, v10);
        objc_storeStrong((id *)v15 + 6, a2);
        __int16 v23 = nw_dictionary_create();
        uint64_t v24 = (void *)*((void *)v15 + 7);
        *((void *)v15 + 7) = v23;

        __int16 v25 = nw_dictionary_create();
        int v26 = (void *)*((void *)v15 + 8);
        *((void *)v15 + 8) = v25;

        *((_BYTE *)v15 + 112) = 1;
        objc_storeWeak((id *)v15 + 5, v17);
        objc_storeStrong((id *)v15 + 9, v11);
        objc_storeStrong((id *)v15 + 10, v12);
        int v27 = _Block_copy(v20);
        uint64_t v28 = (void *)*((void *)v15 + 11);
        *((void *)v15 + 11) = v27;

        goto LABEL_10;
      }

      __nwlog_obj();
      uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identity:outb"
                           "ound_interface:outer_connection_handler:]";
      uint64_t v79 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v119 = 0;
      if ((__nwlog_fault(v79, type, &v119) & 1) != 0)
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v81 = type[0];
          if (os_log_type_enabled(v80, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identit"
                                 "y:outbound_interface:outer_connection_handler:]";
            _os_log_impl(&dword_181A5C000, v80, v81, "%{public}s [super init] failed", buf, 0xCu);
          }
        }

        else if (v119)
        {
          v91 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v92 = type[0];
          v93 = os_log_type_enabled(v80, type[0]);
          if (v91)
          {
            if (v93)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_ident"
                                   "ity:outbound_interface:outer_connection_handler:]";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v91;
              _os_log_impl( &dword_181A5C000,  v80,  v92,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v91);
            goto LABEL_129;
          }

          if (v93)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identit"
                                 "y:outbound_interface:outer_connection_handler:]";
            _os_log_impl(&dword_181A5C000, v80, v92, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v97 = type[0];
          if (os_log_type_enabled(v80, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identit"
                                 "y:outbound_interface:outer_connection_handler:]";
            _os_log_impl( &dword_181A5C000,  v80,  v97,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

LABEL_162:
            if ((v113 & 2) != 0) {
              os_unfair_lock_unlock((os_unfair_lock_t)v3 + 13);
            }
            if ((v113 & 1) != 0) {
              return;
            }
LABEL_165:
            free(v3);
            return;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v114 = *((unsigned int *)v3 + 11);
          *(_DWORD *)buf = 136446978;
          v147 = "nw_hash_table_apply";
          __int16 v148 = 2082;
          v149 = "table->apply_count";
          __int16 v150 = 2048;
          uint64_t v151 = 1LL;
          __int16 v152 = 2048;
          uint64_t v153 = v114;
          v115 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v144 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v116 = (os_log_s *)gLogObj;
            os_log_type_t v117 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              uint64_t v118 = *((unsigned int *)v3 + 11);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "table->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v118;
              v119 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
              goto LABEL_158;
            }

            goto LABEL_159;
          }

          if (v144)
          {
            v120 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v116 = (os_log_s *)gLogObj;
            os_log_type_t v117 = type;
            BOOL v121 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v120)
            {
              if (v121)
              {
                uint64_t v122 = *((unsigned int *)v3 + 11);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                __int16 v148 = 2082;
                v149 = "table->apply_count";
                __int16 v150 = 2048;
                uint64_t v151 = 1LL;
                __int16 v152 = 2048;
                uint64_t v153 = v122;
                __int16 v154 = 2082;
                v155 = v120;
                _os_log_impl( &dword_181A5C000,  v116,  v117,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v120);
              goto LABEL_159;
            }

            if (!v121)
            {
LABEL_159:
              if (v115) {
                free(v115);
              }
              *((_DWORD *)v3 + 11) = 0;
              int v113 = *((_DWORD *)v3 + 12);
              goto LABEL_162;
            }

            uint64_t v125 = *((unsigned int *)v3 + 11);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            __int16 v148 = 2082;
            v149 = "table->apply_count";
            __int16 v150 = 2048;
            uint64_t v151 = 1LL;
            __int16 v152 = 2048;
            uint64_t v153 = v125;
            v119 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v116 = (os_log_s *)gLogObj;
            os_log_type_t v117 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_159;
            }
            uint64_t v123 = *((unsigned int *)v3 + 11);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            __int16 v148 = 2082;
            v149 = "table->apply_count";
            __int16 v150 = 2048;
            uint64_t v151 = 1LL;
            __int16 v152 = 2048;
            uint64_t v153 = v123;
            v119 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          }

            v159 = 0LL;
          }

          break;
        case 158:
          if (v159)
          {
            *(void *)buf = 0LL;
            asprintf((char **)buf, "%.*s", v20, (const char *)v27);
            nw_endpoint_set_device_id(v159, *(const char **)buf);
            if (*(void *)buf) {
              free(*(void **)buf);
            }
            break;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v67 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_parse_necp_result";
            _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s No previous endpoint to apply endpoint device id to",  buf,  0xCu);
          }

          goto LABEL_162;
        case 159:
          if (v159)
          {
            [MEMORY[0x189603F48] dataWithBytes:v27 length:v20];
            uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_append_public_key(v159, v62);

            break;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v67 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_parse_necp_result";
            _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s No previous endpoint to apply public key to",  buf,  0xCu);
          }

          goto LABEL_162;
        case 210:
          if ((_DWORD)v20 == 4) {
            goto LABEL_60;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            os_log_type_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 210;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_60:
            v160->effective_traffic_class = *(_DWORD *)v27;
          }

          break;
        case 211:
          if ((_DWORD)v20 == 4) {
            goto LABEL_91;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            uint64_t v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 211;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_91:
            *((_BYTE *)v160 + 474) = *((_BYTE *)v160 + 474) & 0xFD | (2 * (*(_BYTE *)v27 & 1));
          }

          break;
        case 212:
          uint64_t v63 = nw_path_copy_endpoint_from_tlv(212, v20, (void *)v27);

          unint64_t v35 = v63;
          if (v35)
          {
            gateways = (uint64_t)v160->gateways;
            if (!gateways)
            {
              unsigned int v65 = nw_array_create();
              uint64_t v66 = v160->gateways;
              v160->gateways = (OS_nw_array *)v65;

              gateways = (uint64_t)v160->gateways;
            }

            nw_array_append(gateways, v35);
          }

          goto LABEL_68;
        case 213:
          os_log_type_t v34 = nw_path_copy_endpoint_from_tlv(213, v20, (void *)v27);

          unint64_t v35 = v34;
          if (v35)
          {
            group_members = (uint64_t)v160->group_members;
            if (!group_members)
            {
              v37 = nw_array_create();
              v38 = v160->group_members;
              v160->group_members = (OS_nw_array *)v37;

              group_members = (uint64_t)v160->group_members;
            }

            nw_array_append(group_members, v35);
          }

    if (v64) {
      free(v64);
    }
    goto LABEL_36;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_channel_remove_input_handler";
  char v14 = (char *)_os_log_send_and_compose_impl();
  v77[0] = 16;
  os_log_type_t v76 = OS_LOG_TYPE_DEFAULT;
  if (v77[0] == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = (os_log_s *)gLogObj;
    BOOL v16 = v77[0];
    if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v77[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_remove_input_handler";
      uint64_t v17 = "%{public}s called with null input_protocol";
LABEL_76:
      _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
      goto LABEL_77;
    }

    goto LABEL_77;
  }

  if (v76)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = (os_log_s *)gLogObj;
    BOOL v16 = v77[0];
    uint64_t v24 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v77[0]);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_channel_remove_input_handler";
        uint64_t v17 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    if (!v24)
    {
LABEL_43:
      free(backtrace_string);
      goto LABEL_77;
    }

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_remove_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    __int16 v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_181A5C000, v15, v16, v25, buf, 0x16u);
    goto LABEL_43;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v15 = (os_log_s *)gLogObj;
  BOOL v16 = v77[0];
  if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v77[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_remove_input_handler";
    uint64_t v17 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    goto LABEL_76;
  }

                if (v93) {
                  free(v93);
                }
LABEL_164:
                nw_endpoint_flow_cleanup_protocol(v6, (uint64_t)v237, 1);
                v186 = (void *)*((void *)v237 + 23);
                *((void *)v237 + 23) = 0LL;

                free(v237);
                goto LABEL_121;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              char v64 = (id)gconnectionLogObj;
              unsigned int v65 = nw_endpoint_handler_get_id_string(v6);
              uint64_t v66 = nw_endpoint_handler_dry_run_string(v6);
              v67 = nw_endpoint_handler_copy_endpoint(v6);
              uint64_t v68 = nw_endpoint_get_logging_description(v67);
              os_log_type_t v69 = nw_endpoint_handler_state_string(v6);
              uint64_t v70 = v6;
              v71 = nw_endpoint_handler_mode_string(v6);
              os_log_type_t v72 = nw_endpoint_handler_copy_current_path(v70);
              *(_DWORD *)buf = 136447746;
              v245 = "nw_flow_listener_new_flow";
              v246 = 2082;
              v247 = (uint64_t)v65;
              v248 = 2082;
              v249 = (uint64_t)v66;
              v250 = 2082;
              v251 = v68;
              v252 = 2082;
              v253 = v69;
              v254 = 2082;
              v255 = v71;
              uint64_t v6 = v70;
              v256 = 2114;
              v257 = v72;
              v73 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              v242 = OS_LOG_TYPE_DEFAULT;
              if ((__nwlog_fault(v73, &type, &v242) & 1) != 0)
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v74 = (os_log_s *)(id)gconnectionLogObj;
                  v75 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    os_log_type_t v76 = nw_endpoint_handler_get_id_string(v70);
                    BOOL v77 = nw_endpoint_handler_dry_run_string(v70);
                    uint64_t v78 = nw_endpoint_handler_copy_endpoint(v70);
                    v224 = v73;
                    uint64_t v79 = nw_endpoint_get_logging_description(v78);
                    os_log_type_t v80 = nw_endpoint_handler_state_string(v70);
                    uint64_t v81 = nw_endpoint_handler_mode_string(v70);
                    uint64_t v82 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    v245 = "nw_flow_listener_new_flow";
                    v246 = 2082;
                    v247 = (uint64_t)v76;
                    v248 = 2082;
                    v249 = (uint64_t)v77;
                    v250 = 2082;
                    v251 = v79;
                    v252 = 2082;
                    v253 = v80;
                    v254 = 2082;
                    v255 = v81;
                    uint64_t v6 = v70;
                    v256 = 2114;
                    v257 = v82;
                    _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find in bound flow metadata",  buf,  0x48u);

                    v73 = v224;
                  }
                }

                else if (v242)
                {
                  v131 = __nw_create_backtrace_string();
                  if (v131)
                  {
                    v132 = (char *)v131;
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    os_log_type_t v133 = (os_log_s *)(id)gconnectionLogObj;
                    v134 = type;
                    if (os_log_type_enabled(v133, type))
                    {
                      v135 = nw_endpoint_handler_get_id_string(v70);
                      BOOL v136 = nw_endpoint_handler_dry_run_string(v70);
                      v226 = v73;
                      logb = nw_endpoint_handler_copy_endpoint(v70);
                      v137 = nw_endpoint_get_logging_description(logb);
                      BOOL v138 = nw_endpoint_handler_state_string(v70);
                      v139 = nw_endpoint_handler_mode_string(v70);
                      BOOL v140 = nw_endpoint_handler_copy_current_path(v70);
                      *(_DWORD *)buf = 136448002;
                      v245 = "nw_flow_listener_new_flow";
                      v246 = 2082;
                      v247 = (uint64_t)v135;
                      v248 = 2082;
                      v249 = (uint64_t)v136;
                      v250 = 2082;
                      v251 = v137;
                      v252 = 2082;
                      v253 = v138;
                      v254 = 2082;
                      v255 = v139;
                      uint64_t v6 = v70;
                      v256 = 2114;
                      v257 = v140;
                      v258 = 2082;
                      v259 = v132;
                      _os_log_impl( &dword_181A5C000,  v133,  v134,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata, dumping backtrace:%{public}s",  buf,  0x52u);

                      v73 = v226;
                    }

                    free(v132);
                    goto LABEL_154;
                  }

                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v74 = (os_log_s *)(id)gconnectionLogObj;
                  v169 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    v170 = nw_endpoint_handler_get_id_string(v70);
                    v171 = nw_endpoint_handler_dry_run_string(v70);
                    v172 = nw_endpoint_handler_copy_endpoint(v70);
                    v229 = v73;
                    v173 = nw_endpoint_get_logging_description(v172);
                    v174 = nw_endpoint_handler_state_string(v70);
                    v175 = nw_endpoint_handler_mode_string(v70);
                    v176 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    v245 = "nw_flow_listener_new_flow";
                    v246 = 2082;
                    v247 = (uint64_t)v170;
                    v248 = 2082;
                    v249 = (uint64_t)v171;
                    v250 = 2082;
                    v251 = v173;
                    v252 = 2082;
                    v253 = v174;
                    v254 = 2082;
                    v255 = v175;
                    uint64_t v6 = v70;
                    v256 = 2114;
                    v257 = v176;
                    _os_log_impl( &dword_181A5C000,  v74,  v169,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find in bound flow metadata, no backtrace",  buf,  0x48u);

                    v73 = v229;
                  }
                }

                else
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v74 = (os_log_s *)(id)gconnectionLogObj;
                  __int16 v152 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    uint64_t v153 = nw_endpoint_handler_get_id_string(v70);
                    __int16 v154 = nw_endpoint_handler_dry_run_string(v70);
                    v155 = nw_endpoint_handler_copy_endpoint(v70);
                    v228 = v73;
                    uint64_t v156 = nw_endpoint_get_logging_description(v155);
                    v157 = nw_endpoint_handler_state_string(v70);
                    v158 = nw_endpoint_handler_mode_string(v70);
                    v159 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    v245 = "nw_flow_listener_new_flow";
                    v246 = 2082;
                    v247 = (uint64_t)v153;
                    v248 = 2082;
                    v249 = (uint64_t)v154;
                    v250 = 2082;
                    v251 = v156;
                    v252 = 2082;
                    v253 = v157;
                    v254 = 2082;
                    v255 = v158;
                    uint64_t v6 = v70;
                    v256 = 2114;
                    v257 = v159;
                    _os_log_impl( &dword_181A5C000,  v74,  v152,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find in bound flow metadata, backtrace limit exceeded",  buf,  0x48u);

                    v73 = v228;
                  }
                }
              }

  if (v51) {
    free(v51);
  }
  return 0LL;
}

      free(v30);
      goto LABEL_163;
    }

    os_log_type_t v31 = (os_log_s *)__nwlog_obj();
    uint64_t v32 = type[0];
    if (!os_log_type_enabled(v31, type[0])) {
      goto LABEL_161;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v82 = "nw_http1_get_http1_protocol";
    v33 = "%{public}s called with null handle";
    goto LABEL_160;
  }

  int v4 = handle[6];
  if (v4 == 1) {
    goto LABEL_10;
  }
  if (v4 != 2)
  {
    if (v4 != 3) {
      goto LABEL_163;
    }
    uint64_t v5 = *((void *)handle + 2);
    if (v5)
    {
      handle = (_DWORD *)(v5 + 480);
      goto LABEL_10;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v82 = "nw_http1_get_http1_protocol";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v71) = 0;
    if (__nwlog_fault(v30, type, &v71))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v31 = (os_log_s *)__nwlog_obj();
        uint64_t v32 = type[0];
        if (!os_log_type_enabled(v31, type[0])) {
          goto LABEL_161;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v82 = "nw_http1_get_http1_protocol";
        v33 = "%{public}s called with null handle->http1_connection";
        goto LABEL_160;
      }

      if (!(_BYTE)v71)
      {
        os_log_type_t v31 = (os_log_s *)__nwlog_obj();
        uint64_t v32 = type[0];
        if (!os_log_type_enabled(v31, type[0])) {
          goto LABEL_161;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v82 = "nw_http1_get_http1_protocol";
        v33 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_160;
      }

      BOOL v40 = (char *)__nw_create_backtrace_string();
      os_log_type_t v31 = (os_log_s *)__nwlog_obj();
      uint64_t v32 = type[0];
      uint64_t v60 = os_log_type_enabled(v31, type[0]);
      if (!v40)
      {
        if (!v60) {
          goto LABEL_161;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v82 = "nw_http1_get_http1_protocol";
        v33 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_160;
      }

      if (v60)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v82 = "nw_http1_get_http1_protocol";
        unsigned int v83 = 2082;
        uint64_t v84 = v40;
        uint64_t v42 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
        goto LABEL_123;
      }

      goto LABEL_124;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
    uint64_t v68 = (char *)_os_log_send_and_compose_impl();
    v89 = OS_LOG_TYPE_ERROR;
    uint64_t v88 = 0;
    if (v89 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v69 = (os_log_s *)__nwlog_obj();
      uint64_t v70 = v89;
      if (!os_log_type_enabled(v69, v89)) {
        goto LABEL_220;
      }
      *(_DWORD *)buf = 136446210;
      v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
      v71 = "%{public}s called with null cursor";
    }

    else if (v88)
    {
      os_log_type_t v72 = (char *)__nw_create_backtrace_string();
      os_log_type_t v69 = (os_log_s *)__nwlog_obj();
      uint64_t v70 = v89;
      v74 = os_log_type_enabled(v69, v89);
      if (v72)
      {
        if (!v74) {
          goto LABEL_193;
        }
        goto LABEL_192;
      }

      if (!v74) {
        goto LABEL_220;
      }
      *(_DWORD *)buf = 136446210;
      v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
      v71 = "%{public}s called with null cursor, no backtrace";
    }

    else
    {
      os_log_type_t v69 = (os_log_s *)__nwlog_obj();
      uint64_t v70 = v89;
      if (!os_log_type_enabled(v69, v89)) {
        goto LABEL_220;
      }
      *(_DWORD *)buf = 136446210;
      v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
      v71 = "%{public}s called with null cursor, backtrace limit exceeded";
    }

    goto LABEL_219;
  }

  __break(1u);
  return result;
}

        free(backtrace_string);
        goto LABEL_163;
      }

    if (!v81)
    {
LABEL_164:
      char v19 = 0LL;
      uint64_t v18 = v174;
      uint64_t v36 = v175;
      os_log_type_t v15 = v172;
LABEL_165:
      if ((v173 & 1) != 0) {
        goto LABEL_186;
      }
      goto LABEL_166;
    }

      free(backtrace_string);
      goto LABEL_220;
    }

    if (!v62) {
      goto LABEL_220;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_encrypt_chunked_oblivious_response_chunk";
    uint64_t v47 = "%{public}s called with null (exported_secret_length == response_nonce_length), no backtrace";
LABEL_219:
    _os_log_impl(&dword_181A5C000, v45, v46, v47, (uint8_t *)__str, 0xCu);
LABEL_220:
    if (v44) {
      free(v44);
    }
    return 0LL;
  }

  uint64_t v17 = v14;
  uint64_t v84 = a2;
  uint64_t v18 = calloc(1uLL, a11);
  if (!v18)
  {
    v48 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1LL;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = a11;
    uint64_t v49 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v49);
    if (result) {
      goto LABEL_230;
    }
    free(v49);
  }

  unint64_t v102 = 0u;
  v103 = 0u;
  uint64_t v100 = 0u;
  v101 = 0u;
  os_log_type_t v98 = 0u;
  uint64_t v99 = 0u;
  uint64_t v96 = 0u;
  uint64_t v97 = 0u;
  os_log_type_t v94 = 0u;
  BOOL v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  os_log_type_t v90 = 0u;
  v91 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s chunked response", a3);
  strlen(__str);
  char v19 = cchpke_responder_export();
  if (v19)
  {
    os_log_type_t v20 = v19;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v21 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v106 = 1024;
      LODWORD(v107) = v20;
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (!v18) {
      return 0LL;
    }
    goto LABEL_20;
  }

  if (!(a11 + a9))
  {
    uint64_t v63 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v105 = "strict_calloc";
    char v64 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v64);
    if (result) {
      goto LABEL_230;
    }
    free(v64);
  }

  __int16 v23 = (char *)calloc(1uLL, a11 + a9);
  if (!v23)
  {
    unsigned int v65 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v105 = "strict_calloc";
    v106 = 2048;
    unint64_t v107 = 1LL;
    v108 = 2048;
    int v109 = a11 + a9;
    uint64_t v66 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v66);
    if (result) {
      goto LABEL_230;
    }
    free(v66);
  }

  memcpy(v23, a8, a9);
  memcpy(&v23[a9], a10, a11);
  uint64_t v24 = cchpke_params_sizeof_kdf_hash();
  if (!v24)
  {
    v67 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v105 = "strict_calloc";
    uint64_t v68 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v68);
    if (result) {
      goto LABEL_230;
    }
    free(v68);
  }

  __int16 v25 = calloc(1uLL, v24);
  if (!v25)
  {
    os_log_type_t v69 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v105 = "strict_calloc";
    v106 = 2048;
    unint64_t v107 = 1LL;
    v108 = 2048;
    int v109 = v24;
    uint64_t v70 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v70);
    if (result) {
      goto LABEL_230;
    }
    free(v70);
  }

  ccsha256_di();
  int v26 = cchkdf_extract();
  if (v23) {
    free(v23);
  }
  if (v18) {
    free(v18);
  }
  if (v26)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v27 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v106 = 1024;
      LODWORD(v107) = v26;
      _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (!v25) {
      return 0LL;
    }
    uint64_t v22 = v25;
    goto LABEL_34;
  }

  if (!v17)
  {
    v71 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v105 = "strict_calloc";
    os_log_type_t v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_230;
    }
    free(v72);
  }

  uint64_t v18 = calloc(1uLL, v17);
  if (!v18)
  {
    v73 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v105 = "strict_calloc";
    v106 = 2048;
    unint64_t v107 = 1LL;
    v108 = 2048;
    int v109 = v17;
    v74 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v74);
    if (result) {
      goto LABEL_230;
    }
    free(v74);
  }

  uint64_t v30 = cchkdf_expand();
  if (v30)
  {
    os_log_type_t v31 = v30;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v32 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v106 = 1024;
      LODWORD(v107) = v31;
      _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (v25) {
      free(v25);
    }
    if (!v18) {
      return 0LL;
    }
LABEL_20:
    uint64_t v22 = v18;
LABEL_34:
    free(v22);
    return 0LL;
  }

  v33 = __size;
  if (!__size)
  {
    v75 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v105 = "strict_calloc";
    os_log_type_t v76 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v76);
    if (result) {
      goto LABEL_230;
    }
    free(v76);
    v33 = 0LL;
  }

  os_log_type_t v34 = (char *)calloc(1uLL, v33);
  if (!v34)
  {
    BOOL v77 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v105 = "strict_calloc";
    v106 = 2048;
    unint64_t v107 = 1LL;
    v108 = 2048;
    int v109 = v33;
    uint64_t v78 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v78);
    if (result) {
      goto LABEL_230;
    }
    free(v78);
  }

  unint64_t v35 = cchkdf_expand();
  if (v25) {
    free(v25);
  }
  if (v35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v36 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v106 = 1024;
      LODWORD(v107) = v35;
      v37 = "%{public}s Nonce expand error: %d";
      v38 = (os_log_s *)v36;
      os_log_type_t v39 = 18;
LABEL_56:
      _os_log_impl(&dword_181A5C000, v38, OS_LOG_TYPE_ERROR, v37, (uint8_t *)&buf, v39);
      goto LABEL_57;
    }

    goto LABEL_57;
  }

  if (__size <= 7)
  {
    BOOL v40 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v105 = "nw_http_encrypt_chunked_oblivious_response_chunk";
      v106 = 2048;
      unint64_t v107 = __size;
      v37 = "%{public}s Bad nonce length: %zu";
      v38 = v40;
      os_log_type_t v39 = 22;
      goto LABEL_56;
    }

    if (v42) {
      free(v42);
    }
    uint64_t v36 = 0LL;
    goto LABEL_50;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_http_alt_svc_connect";
  v38 = (char *)_os_log_send_and_compose_impl();
  v114[0] = 16;
  LOBYTE(v101) = 0;
  if (v114[0] != 17)
  {
    if (!(_BYTE)v101)
    {
      os_log_type_t v39 = (os_log_s *)__nwlog_obj();
      BOOL v40 = v114[0];
      if (os_log_type_enabled(v39, (os_log_type_t)v114[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_alt_svc_connect";
        uint64_t v41 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v39 = (os_log_s *)__nwlog_obj();
    BOOL v40 = v114[0];
    uint64_t v62 = os_log_type_enabled(v39, (os_log_type_t)v114[0]);
    if (!backtrace_string)
    {
      if (v62)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_alt_svc_connect";
        uint64_t v41 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_155;
      }

      goto LABEL_156;
    }

    if (v62)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_alt_svc_connect";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v60 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_103;
    }

  if (v110) {
    free(v110);
  }
LABEL_238:
}

              if (((unsigned __int16)v86 & 0x4000) != 0)
              {
                if (gLogDatapath)
                {
                  v169 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v169, OS_LOG_TYPE_DEBUG))
                  {
                    v170 = *((_DWORD *)v316 + 6);
                    *(_DWORD *)v323 = 136446722;
                    *(void *)&v323[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v323[12] = 2082;
                    *(void *)&v323[14] = a1 + 2;
                    *(_WORD *)&v323[22] = 1024;
                    *(_DWORD *)v324 = v170;
                    _os_log_impl( &dword_181A5C000,  v169,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s before interleaving empty frames, had %u frames",  v323,  0x1Cu);
                  }
                }

                *(void *)v323 = 0LL;
                *(void *)&v323[8] = v323;
                *(void *)&v323[16] = 0x2000000000LL;
                *(void *)v324 = 0LL;
                v282[0] = v49;
                v282[1] = 0x40000000LL;
                v283 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_34;
                v284 = &unk_189BC84B8;
                v287 = v9;
                v288 = a6;
                v285 = v323;
                v286 = &v315;
                tqh_first = a6->tqh_first;
                do
                {
                  if (!tqh_first) {
                    break;
                  }
                  unint64_t v102 = (nw_frame *)*((void *)tqh_first + 4);
                  v103 = v283(v282);
                  tqh_first = v102;
                }

                while ((v103 & 1) != 0);
                _Block_object_dispose(v323, 8);
                uint64_t v86 = *v9;
              }

              if (((unsigned __int16)v86 & 0x8000) != 0)
              {
                if (gLogDatapath)
                {
                  v171 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
                  {
                    v172 = *((_DWORD *)v316 + 6);
                    *(_DWORD *)v323 = 136446722;
                    *(void *)&v323[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v323[12] = 2082;
                    *(void *)&v323[14] = v9 + 4;
                    *(_WORD *)&v323[22] = 1024;
                    *(_DWORD *)v324 = v172;
                    _os_log_impl( &dword_181A5C000,  v171,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s before making one byte frames, had %u frames",  v323,  0x1Cu);
                  }
                }

                int v104 = &nwlog_legacy_init(void)::init_once;
                v105 = nwlog_legacy_init_once;
                v106 = &qword_18C45F000;
                while (1)
                {
                  v110 = a6->tqh_first;
                  if (!a6->tqh_first) {
                    break;
                  }
                  *(void *)v330 = a6->tqh_first;
                  v111 = *((void *)v110 + 4);
                  v112 = (nw_frame **)*((void *)v110 + 5);
                  if (v111)
                  {
                    *(void *)(v111 + 40) = v112;
                    v112 = (nw_frame **)*((void *)v110 + 5);
                  }

                  else
                  {
                    a6->tqh_last = v112;
                  }

                  void *v112 = (nw_frame *)v111;
                  *((void *)v110 + 4) = 0LL;
                  *((void *)v110 + 5) = 0LL;
                  while (nw_frame_unclaimed_length(*(_DWORD **)v330) >= 2)
                  {
                    int v113 = nw_frame_split((uint64_t *)v330, 1u);
                    if (gLogDatapath)
                    {
                      pthread_once(v104, v105);
                      networkd_settings_init();
                      v115 = (os_log_s *)v106[131];
                      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
                      {
                        v116 = v105;
                        os_log_type_t v117 = v104;
                        uint64_t v118 = v36;
                        v119 = *(void *)v330;
                        v120 = nw_frame_unclaimed_length(*(_DWORD **)v330);
                        *(_DWORD *)v323 = 136447234;
                        *(void *)&v323[4] = "nw_protocol_test_get_input_frames";
                        *(_WORD *)&v323[12] = 2082;
                        *(void *)&v323[14] = v9 + 4;
                        *(_WORD *)&v323[22] = 2048;
                        *(void *)v324 = v113;
                        *(_WORD *)&v324[8] = 2048;
                        *(void *)&v324[10] = v119;
                        uint64_t v36 = v118;
                        int v104 = v117;
                        v105 = v116;
                        v106 = &qword_18C45F000;
                        *(_WORD *)&v324[18] = 1024;
                        *(_DWORD *)&v324[20] = v120;
                        _os_log_impl( &dword_181A5C000,  v115,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s appending one byte frame %p made from existing frame %p (%u bytes)",  v323,  0x30u);
                      }
                    }

                    *(void *)(v113 + 32) = 0LL;
                    uint64_t v114 = (uint64_t *)v9[2];
                    *(void *)(v113 + 40) = v114;
                    *uint64_t v114 = v113;
                    v9[2] = (nw_protocol *)(v113 + 32);
                  }

                  unint64_t v107 = *(void *)v330;
                  v108 = *(void *)v330;
                  *(void *)(*(void *)v330 + 32LL) = 0LL;
                  int v109 = v9[2];
                  *(void *)(v107 + 40) = v109;
                  *(void *)v109->flow_id = v107;
                  v9[2] = (nw_protocol *)(v108 + 32);
                }

                *((_DWORD *)v316 + 6) = 0;
                BOOL v121 = v9[1];
                if (v121)
                {
                  uint64_t v123 = v121->output_handler;
                  uint64_t v124 = (nw_protocol *)v121->handle;
                  uint64_t v122 = (nw_frame **)&v121->output_handler;
                  if (v123)
                  {
                    v123->handle = v124;
                    uint64_t v124 = (nw_protocol *)v121->handle;
                  }

                  else
                  {
                    v9[2] = v124;
                  }

                  *(void *)v124->flow_id = v123;
                  *uint64_t v122 = 0LL;
                  v121->handle = 0LL;
                  uint64_t v125 = a6->tqh_last;
                  v121->handle = v125;
                  *uint64_t v125 = (nw_frame *)v121;
                  a6->tqh_last = v122;
                  *((_DWORD *)v316 + 6) = 1;
                }
              }

              *(_DWORD *)v323 = 0;
              nw_frame_array_get_frame_count((uint64_t *)a6, 1, v323);
              if (gLogDatapath)
              {
                v155 = *(_DWORD *)v323;
                uint64_t v156 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v156, OS_LOG_TYPE_DEBUG))
                {
                  v157 = *((_DWORD *)v316 + 6);
                  *(_DWORD *)v323 = 136446978;
                  *(void *)&v323[4] = "nw_protocol_test_get_input_frames";
                  *(_WORD *)&v323[12] = 2082;
                  *(void *)&v323[14] = v9 + 4;
                  *(_WORD *)&v323[22] = 1024;
                  *(_DWORD *)v324 = v157;
                  *(_WORD *)&v324[4] = 1024;
                  *(_DWORD *)&v324[6] = v155;
                  _os_log_impl( &dword_181A5C000,  v156,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s returning %u frames (total %u bytes)",  v323,  0x22u);
                }
              }

              uint64_t v18 = *((unsigned int *)v316 + 6);
              _Block_object_dispose(&v315, 8);
              v126 = v281;
              if ((v36 & 1) != 0)
              {
                if (v281)
                {
                  if (v281->handle == &nw_protocol_ref_counted_handle)
                  {
                    v128 = v281[1].callbacks;
                    if (v128)
                    {
                      v129 = (nw_protocol_callbacks *)((char *)v128 - 1);
                      v281[1].callbacks = v129;
                      if (!v129)
                      {
                        v130 = *(void (***)(void))v281[1].flow_id;
                        if (v130)
                        {
                          *(void *)v281[1].flow_id = 0LL;
                          v130[2](v130);
                          _Block_release(v130);
                          v126 = v281;
                        }

                        if ((v126[1].flow_id[8] & 1) != 0)
                        {
                          v131 = *(const void **)v126[1].flow_id;
                          if (v131)
                          {
                            _Block_release(v131);
                            v126 = v281;
                          }
                        }

                        free(v126);
                      }
                    }
                  }
                }
              }

              _Block_object_dispose(buf, 8);
              return v18;
            }

            v295[0] = MEMORY[0x1895F87A8];
            v295[1] = 0x40000000LL;
            v296 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_30;
            v297 = &__block_descriptor_tmp_31_84217;
            v298 = p_output_handler;
            v299 = a2;
            v300 = a1;
            os_log_type_t v57 = *(void *)(*(void *)&buf[8] + 40LL);
            do
            {
              if (!v57) {
                break;
              }
              BOOL v58 = *(void *)(v57 + 32);
              uint64_t v59 = v296(v295);
              os_log_type_t v57 = v58;
            }

            while ((v59 & 1) != 0);
          }

LABEL_158:
          _os_log_impl(&dword_181A5C000, v116, v117, v119, buf, 0x2Au);
          goto LABEL_159;
        }

    if (v87) {
      free(v87);
    }
    goto LABEL_172;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v90 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v120 = 136446210;
    *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
    v91 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v91, buf, &type))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v93 = buf[0];
        if (os_log_type_enabled(v92, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_181A5C000, v92, v93, "%{public}s called with null endpoint", v120, 0xCu);
        }
      }

      else if (type)
      {
        v101 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v102 = buf[0];
        v103 = os_log_type_enabled(v92, (os_log_type_t)buf[0]);
        if (v101)
        {
          if (v103)
          {
            *(_DWORD *)v120 = 136446466;
            *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2082;
            *(void *)&v120[14] = v101;
            _os_log_impl( &dword_181A5C000,  v92,  v102,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  v120,  0x16u);
          }

          free(v101);
          goto LABEL_163;
        }

        if (v103)
        {
          *(_DWORD *)v120 = 136446210;
          *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_181A5C000, v92, v102, "%{public}s called with null endpoint, no backtrace", v120, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v115 = buf[0];
        if (os_log_type_enabled(v92, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl( &dword_181A5C000,  v92,  v115,  "%{public}s called with null endpoint, backtrace limit exceeded",  v120,  0xCu);
        }
      }
    }

              goto LABEL_159;
            }

            __nwlog_obj();
            uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
            os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();

            type[0] = 16;
            LOBYTE(v279) = 0;
            if (__nwlog_fault(v43, type, &v279))
            {
              if (type[0] == 17)
              {
                __nwlog_obj();
                uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                uint64_t v45 = type[0];
                if (os_log_type_enabled(v44, (os_log_type_t)type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                  _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s called with null protocol", buf, 0xCu);
                }

            goto LABEL_159;
          }

          if (!(_BYTE)v75)
          {
            __nwlog_obj();
            v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v70 = type[0];
            if (os_log_type_enabled(v55, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
              _os_log_impl( &dword_181A5C000,  v55,  v70,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_158;
          }

          uint64_t v49 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          unsigned int v65 = type[0];
          uint64_t v66 = os_log_type_enabled(v55, type[0]);
          if (!v49)
          {
            if (v66)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
              _os_log_impl(&dword_181A5C000, v55, v65, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
            }

            goto LABEL_158;
          }

          if (v66)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_disconnected";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v49;
            _os_log_impl( &dword_181A5C000,  v55,  v65,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

LABEL_125:
          free(v49);
          if (!v29) {
            goto LABEL_42;
          }
          goto LABEL_160;
        }

        __nwlog_obj();
        os_log_type_t v34 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        unint64_t v29 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v75) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          unint64_t v35 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl( &dword_181A5C000,  v30,  v35,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_140;
        }

        if (!(_BYTE)v75)
        {
          __nwlog_obj();
          uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v64 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl( &dword_181A5C000,  v30,  v64,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_140;
        }

        uint64_t v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v52 = type[0];
        os_log_type_t v53 = os_log_type_enabled(v30, type[0]);
        if (!v49)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl( &dword_181A5C000,  v30,  v52,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_140;
        }

        if (v53)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v49;
          _os_log_impl( &dword_181A5C000,  v30,  v52,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        unint64_t v29 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v75) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v33 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl( &dword_181A5C000,  v30,  v33,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_140;
        }

        if (!(_BYTE)v75)
        {
          __nwlog_obj();
          uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v63 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl( &dword_181A5C000,  v30,  v63,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_140;
        }

        uint64_t v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type[0];
        uint64_t v51 = os_log_type_enabled(v30, type[0]);
        if (!v49)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
            _os_log_impl( &dword_181A5C000,  v30,  v50,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_140;
        }

        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v49;
          _os_log_impl( &dword_181A5C000,  v30,  v50,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      goto LABEL_125;
    }

    __nwlog_obj();
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
    unint64_t v29 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v75) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if ((_BYTE)v75)
    {
      int v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v47 = type[0];
      v48 = os_log_type_enabled(v30, type[0]);
      if (v46)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v46;
          _os_log_impl( &dword_181A5C000,  v30,  v47,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v46);
LABEL_159:
        if (!v29) {
          goto LABEL_42;
        }
LABEL_160:
        free(v29);
        goto LABEL_42;
      }

      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_181A5C000, v30, v47, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v62 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl( &dword_181A5C000,  v30,  v62,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      v6[2](v6, 0LL);
      int v21 = 0LL;
LABEL_159:
      _Block_object_dispose(v119, 8);

      goto LABEL_106;
    }

    if (v5->sc_state)
    {
LABEL_124:
      *(void *)v119 = 0LL;
      *(void *)&v119[8] = v119;
      *(void *)&v119[16] = 0x3032000000LL;
      v120 = __Block_byref_object_copy__16053;
      BOOL v121 = __Block_byref_object_dispose__16054;
      uint64_t v122 = 0LL;
      goto LABEL_158;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v46 = (id)gLogObj;
    *(_DWORD *)v119 = 136446466;
    *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
    *(_WORD *)&v119[12] = 2114;
    *(void *)&v119[14] = v5;
    uint64_t v47 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v47, buf, &buffer))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v49 = buf[0];
        if (os_log_type_enabled(v48, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v119 = 136446466;
          *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v5;
          _os_log_impl( &dword_181A5C000,  v48,  v49,  "%{public}s %{public}@ cannot send reply from invalid state",  v119,  0x16u);
        }
      }

      else if ((_BYTE)buffer)
      {
        uint64_t v63 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v64 = buf[0];
        unsigned int v65 = os_log_type_enabled(v48, (os_log_type_t)buf[0]);
        if (v63)
        {
          if (v65)
          {
            *(_DWORD *)v119 = 136446722;
            *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
            *(_WORD *)&v119[12] = 2114;
            *(void *)&v119[14] = v5;
            *(_WORD *)&v119[22] = 2082;
            v120 = (uint64_t (*)(uint64_t, uint64_t))v63;
            _os_log_impl( &dword_181A5C000,  v48,  v64,  "%{public}s %{public}@ cannot send reply from invalid state, dumping backtrace:%{public}s",  v119,  0x20u);
          }

          free(v63);
          goto LABEL_122;
        }

        if (v65)
        {
          *(_DWORD *)v119 = 136446466;
          *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v5;
          _os_log_impl( &dword_181A5C000,  v48,  v64,  "%{public}s %{public}@ cannot send reply from invalid state, no backtrace",  v119,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v66 = buf[0];
        if (os_log_type_enabled(v48, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v119 = 136446466;
          *(void *)&v119[4] = "nw_socks5_connection_send_reply_on_queue";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v5;
          _os_log_impl( &dword_181A5C000,  v48,  v66,  "%{public}s %{public}@ cannot send reply from invalid state, backtrace limit exceeded",  v119,  0x16u);
        }
      }
    }

                  v202[0] = 0;
                  goto LABEL_159;
                }
              }

              uint64_t v118 = strlen(*(const char **)&v11->path_parameters->joinable_path_value.fallback_mode);
              v111 = v212;
              __nwlog_salted_hash(*(const void **)&v11->path_parameters->joinable_path_value.fallback_mode, v118, v212);
              goto LABEL_141;
            }

            free(v107);
            goto LABEL_168;
          }

          if (!v110) {
            goto LABEL_168;
          }
          *(_DWORD *)v227 = 136446210;
          *(void *)&v227[4] = "nw_http_encoding_create_inbound_frame";
          uint64_t v97 = logb;
          os_log_type_t v98 = v109;
          uint64_t v99 = "%{public}s called with null http_encoding, no backtrace";
        }

        else
        {
          os_log_type_t v117 = (os_log_s *)__nwlog_obj();
          uint64_t v118 = v226;
          if (!os_log_type_enabled(v117, v226)) {
            goto LABEL_168;
          }
          *(_DWORD *)v227 = 136446210;
          *(void *)&v227[4] = "nw_http_encoding_create_inbound_frame";
          uint64_t v97 = v117;
          os_log_type_t v98 = v118;
          uint64_t v99 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        }
      }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)(v12 + 24) + 96LL))(v12, &v166);
  uint64_t v84 = v168;
  Request = v153;
  if (v168)
  {
    *(void *)v161 = 0LL;
    v162 = v161;
    v164 = 0;
    v163 = 0x2000000000LL;
    *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
    v157 = 0x40000000LL;
    v158 = (uint64_t)___ZL26nw_http_connect_send_bytesP24nw_protocol_http_connectPKhj_block_invoke;
    v159 = &unk_189BBCAB0;
    v160 = v161;
    do
    {
      if (!v84) {
        break;
      }
      v85 = *(void *)(v84 + 32);
      uint64_t v86 = ((uint64_t (*)(os_log_type_t *))v158)(type);
      uint64_t v84 = v85;
    }

    while ((v86 & 1) != 0);
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v87 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v88 = *((_DWORD *)v162 + 6);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http_connect_send_bytes";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        LOWORD(v172) = 1024;
        *(_DWORD *)((char *)&v172 + 2) = v88;
        _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to use %u frames, marking as failed",  buf,  0x26u);
      }
    }

    _Block_object_dispose(v161, 8);
  }

  v89 = *(void *)(a1 + 168);
  if ((!v89 || *(_DWORD *)(v89 + 124) != 4) && (*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v90 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_http_connect_send_request";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      _os_log_impl( &dword_181A5C000,  v90,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sSent http connect request to proxy",  buf,  0x20u);
    }
  }

  *(_WORD *)(a1 + 368) |= 8u;
  os_log_type_t v76 = 1LL;
  if (v153) {
    goto LABEL_145;
  }
LABEL_146:
  CFRelease(v7);
  return v76;
}

    _os_log_impl(&dword_181A5C000, v80, OS_LOG_TYPE_DEBUG, v84, buf, 0x32u);
    goto LABEL_159;
  }

  if (v79 != 4)
  {
    if ((*(_BYTE *)(v9 + 158) & 1) != 0) {
      goto LABEL_159;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v80 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_159;
    }
    unint64_t v102 = *(void *)(v9 + 488);
    v103 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
    int v104 = *(_DWORD *)(v9 + 860);
    if (v102) {
      LODWORD(v102) = *(_DWORD *)(v102 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v9 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v103;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v104;
    LOWORD(v262) = 1024;
    *(_DWORD *)((char *)&v262 + 2) = v102;
    uint64_t v84 = "%{public}s %{public}s%s<i%u:c%u:s%u> no change to http1 connection state";
    goto LABEL_158;
  }

  if (v77 | v78)
  {
    if (!v77) {
      goto LABEL_159;
    }
    if (v78) {
      goto LABEL_159;
    }
    *(_DWORD *)(v9 + 864) = 3;
    if ((*(_BYTE *)(v9 + 158) & 1) != 0) {
      goto LABEL_159;
    }
    os_log_type_t v80 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_159;
    }
    unint64_t v107 = *(void *)(v9 + 488);
    v108 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
    int v109 = *(_DWORD *)(v9 + 860);
    if (v107) {
      LODWORD(v107) = *(_DWORD *)(v107 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v9 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v108;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v109;
    LOWORD(v262) = 1024;
    *(_DWORD *)((char *)&v262 + 2) = v107;
    uint64_t v84 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: stream pending";
    goto LABEL_158;
  }

  *(_DWORD *)(v9 + 864) = 2;
  if ((*(_BYTE *)(v9 + 158) & 1) == 0)
  {
    os_log_type_t v80 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v81 = *(void *)(v9 + 488);
      uint64_t v82 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
      unsigned int v83 = *(_DWORD *)(v9 + 860);
      if (v81) {
        LODWORD(v81) = *(_DWORD *)(v81 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v9 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v82;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v83;
      LOWORD(v262) = 1024;
      *(_DWORD *)((char *)&v262 + 2) = v81;
      uint64_t v84 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: stream complete";
      goto LABEL_158;
    }
  }

  __break(1u);
  return result;
}

                                  if (v93) {
                                    free(v93);
                                  }
                                  goto LABEL_115;
                                }

      if (v24) {
        free(v24);
      }
      return 0LL;
    }

    if (!v50)
    {
      __int16 v25 = (os_log_s *)__nwlog_obj();
      int v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_decrypt_standalone_aead_chunk";
        int v27 = "%{public}s called with null (encrypted_length > tag_length), backtrace limit exceeded";
        goto LABEL_157;
      }

      goto LABEL_158;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v25 = (os_log_s *)__nwlog_obj();
    int v26 = type;
    v48 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_decrypt_standalone_aead_chunk";
        int v27 = "%{public}s called with null (encrypted_length > tag_length), no backtrace";
        goto LABEL_157;
      }

      goto LABEL_158;
    }

    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v53 = "nw_http_decrypt_standalone_aead_chunk";
      v54 = 2082;
      v55 = (uint64_t)backtrace_string;
      os_log_type_t v39 = "%{public}s called with null (encrypted_length > tag_length), dumping backtrace:%{public}s";
      goto LABEL_115;
    }

      if (v9) {
LABEL_159:
      }
        free(v9);
LABEL_160:

      return posix_error;
    }

    uint64_t v41 = self->super._local_endpoint;
    if (v41)
    {
      uint64_t v42 = nw_endpoint_get_address(v41);
      if (v42)
      {
        *(_DWORD *)v89 = 0;
        os_log_type_t v90 = 4;
        sa_family = v42->sa_family;
        if (sa_family == 30)
        {
          if (getsockopt(sockfd_from_client, 41, 125, v89, &v90))
          {
            posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
            v48 = nw_error_get_error_code((nw_error_t)posix_error);
            __nwlog_obj();
            uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)os_log_type_t type = 136446722;
            os_log_type_t v94 = "-[nw_listener_inbox_socket start]";
            BOOL v95 = 1024;
            uint64_t v96 = sockfd_from_client;
            uint64_t v97 = 1024;
            *(_DWORD *)os_log_type_t v98 = v48;
            uint64_t v9 = (char *)_os_log_send_and_compose_impl();

            uint64_t v88 = OS_LOG_TYPE_ERROR;
            os_log_type_t v87 = 0;
            if (v88 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v50 = v88;
              if (os_log_type_enabled(v46, v88))
              {
                *(_DWORD *)os_log_type_t type = 136446722;
                os_log_type_t v94 = "-[nw_listener_inbox_socket start]";
                BOOL v95 = 1024;
                uint64_t v96 = sockfd_from_client;
                uint64_t v97 = 1024;
                *(_DWORD *)os_log_type_t v98 = v48;
                _os_log_impl( &dword_181A5C000,  v46,  v50,  "%{public}s getsockopt(%d, IPV6_BOUND_IF) failed %{darwin.errno}d",  (uint8_t *)type,  0x18u);
              }

              goto LABEL_157;
            }

            if (!v87)
            {
              __nwlog_obj();
              int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v80 = v88;
              if (os_log_type_enabled(v46, v88))
              {
                *(_DWORD *)os_log_type_t type = 136446722;
                os_log_type_t v94 = "-[nw_listener_inbox_socket start]";
                BOOL v95 = 1024;
                uint64_t v96 = sockfd_from_client;
                uint64_t v97 = 1024;
                *(_DWORD *)os_log_type_t v98 = v48;
                _os_log_impl( &dword_181A5C000,  v46,  v80,  "%{public}s getsockopt(%d, IPV6_BOUND_IF) failed %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)type,  0x18u);
              }

              goto LABEL_157;
            }

            int v26 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v77 = v88;
            uint64_t v78 = os_log_type_enabled(v46, v88);
            if (!v26)
            {
              if (v78)
              {
                *(_DWORD *)os_log_type_t type = 136446722;
                os_log_type_t v94 = "-[nw_listener_inbox_socket start]";
                BOOL v95 = 1024;
                uint64_t v96 = sockfd_from_client;
                uint64_t v97 = 1024;
                *(_DWORD *)os_log_type_t v98 = v48;
                _os_log_impl( &dword_181A5C000,  v46,  v77,  "%{public}s getsockopt(%d, IPV6_BOUND_IF) failed %{darwin.errno}d, no backtrace",  (uint8_t *)type,  0x18u);
              }

              goto LABEL_157;
            }

            if (v78)
            {
              *(_DWORD *)os_log_type_t type = 136446978;
              os_log_type_t v94 = "-[nw_listener_inbox_socket start]";
              BOOL v95 = 1024;
              uint64_t v96 = sockfd_from_client;
              uint64_t v97 = 1024;
              *(_DWORD *)os_log_type_t v98 = v48;
              *(_WORD *)&v98[4] = 2082;
              *(void *)&v98[6] = v26;
              _os_log_impl( &dword_181A5C000,  v46,  v77,  "%{public}s getsockopt(%d, IPV6_BOUND_IF) failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)type,  0x22u);
            }

            goto LABEL_140;
          }
        }

        else
        {
          if (sa_family != 2) {
            goto LABEL_92;
          }
          if (getsockopt(sockfd_from_client, 0, 25, v89, &v90))
          {
            posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
            uint64_t v44 = nw_error_get_error_code((nw_error_t)posix_error);
            __nwlog_obj();
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)os_log_type_t type = 136446722;
            os_log_type_t v94 = "-[nw_listener_inbox_socket start]";
            BOOL v95 = 1024;
            uint64_t v96 = sockfd_from_client;
            uint64_t v97 = 1024;
            *(_DWORD *)os_log_type_t v98 = v44;
            uint64_t v9 = (char *)_os_log_send_and_compose_impl();

            uint64_t v88 = OS_LOG_TYPE_ERROR;
            os_log_type_t v87 = 0;
            if (v88 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v47 = v88;
              if (os_log_type_enabled(v46, v88))
              {
                *(_DWORD *)os_log_type_t type = 136446722;
                os_log_type_t v94 = "-[nw_listener_inbox_socket start]";
                BOOL v95 = 1024;
                uint64_t v96 = sockfd_from_client;
                uint64_t v97 = 1024;
                *(_DWORD *)os_log_type_t v98 = v44;
                _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s getsockopt(%d, IP_BOUND_IF) failed %{darwin.errno}d",  (uint8_t *)type,  0x18u);
              }

                        free(v68);
                        goto LABEL_159;
                      }

                      if (v74)
                      {
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
                        *(_WORD *)&buf[12] = 2048;
                        *(void *)&buf[14] = v63;
                        *(_WORD *)&buf[22] = 2048;
                        uint64_t v153 = v13;
                        __int16 v154 = 1024;
                        *(_DWORD *)v155 = v65;
                        _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, no backtrace",  buf,  0x26u);
                      }
                    }

                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v69 = (os_log_s *)(id)gLogObj;
                      v75 = type;
                      if (os_log_type_enabled(v69, type))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
                        *(_WORD *)&buf[12] = 2048;
                        *(void *)&buf[14] = v63;
                        *(_WORD *)&buf[22] = 2048;
                        uint64_t v153 = v13;
                        __int16 v154 = 1024;
                        *(_DWORD *)v155 = v65;
                        _os_log_impl( &dword_181A5C000,  v69,  v75,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, backtrace limit exceeded",  buf,  0x26u);
                      }

        free(v53);
        goto LABEL_159;
      }

      if (v67)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s called with null parameters_buffer_size, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v70 = v79[0];
      if (os_log_type_enabled(v54, v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v81 = "nw_path_copy_path_for_tlv";
        _os_log_impl( &dword_181A5C000,  v54,  v70,  "%{public}s called with null parameters_buffer_size, backtrace limit exceeded",  buf,  0xCu);
      }
    }

  __break(1u);
  return result;
}

LABEL_32:
        if (!v23) {
          goto LABEL_28;
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = *((unsigned __int16 *)v24 + 14);
      *(_DWORD *)buf = 136446978;
      v147 = "nw_hash_table_apply";
      __int16 v148 = 2082;
      v149 = "node->apply_count";
      __int16 v150 = 2048;
      uint64_t v151 = 1LL;
      __int16 v152 = 2048;
      uint64_t v153 = v28;
      unint64_t v29 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v144 = 0;
      if (__nwlog_fault(v29, &type, &v144))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v30 = gLogObj;
          os_log_type_t v31 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v32 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            __int16 v148 = 2082;
            v149 = "node->apply_count";
            __int16 v150 = 2048;
            uint64_t v151 = 1LL;
            __int16 v152 = 2048;
            uint64_t v153 = v32;
            v33 = (os_log_s *)v30;
            os_log_type_t v34 = v31;
            unint64_t v35 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_55:
            _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0x2Au);
          }
        }

        else if (v144)
        {
          v37 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = (os_log_s *)gLogObj;
          os_log_type_t v39 = type;
          BOOL v40 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v37)
          {
            if (v40)
            {
              uint64_t v41 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136447234;
              v147 = "nw_hash_table_apply";
              __int16 v148 = 2082;
              v149 = "node->apply_count";
              __int16 v150 = 2048;
              uint64_t v151 = 1LL;
              __int16 v152 = 2048;
              uint64_t v153 = v41;
              __int16 v154 = 2082;
              v155 = v37;
              _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v37);
            goto LABEL_56;
          }

          if (v40)
          {
            uint64_t v45 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            __int16 v148 = 2082;
            v149 = "node->apply_count";
            __int16 v150 = 2048;
            uint64_t v151 = 1LL;
            __int16 v152 = 2048;
            uint64_t v153 = v45;
            v33 = v38;
            os_log_type_t v34 = v39;
            unint64_t v35 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_55;
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v42 = gLogObj;
          os_log_type_t v43 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v44 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            __int16 v148 = 2082;
            v149 = "node->apply_count";
            __int16 v150 = 2048;
            uint64_t v151 = 1LL;
            __int16 v152 = 2048;
            uint64_t v153 = v44;
            v33 = (os_log_s *)v42;
            os_log_type_t v34 = v43;
            unint64_t v35 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_55;
          }
        }
      }

      goto LABEL_33;
    }

    if (!v14)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_synchronize";
        unsigned int v8 = "%{public}s called with null lock, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v7 = type;
    uint64_t v11 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_synchronize";
        unsigned int v8 = "%{public}s called with null lock, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_synchronize";
      uint64_t v18 = 2082;
      char v19 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null lock, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_33:
    if (!v5) {
      return;
    }
    goto LABEL_34;
  }

  if (*(void *)a2)
  {
    os_unfair_lock_lock(a1);
    (*(void (**)(void))(*(void *)a2 + 16LL))();
    os_unfair_lock_unlock(a1);
    return;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_synchronize";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v7 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_synchronize";
      unsigned int v8 = "%{public}s called with null func";
      goto LABEL_31;
    }

    goto LABEL_32;
  }

  if (!v14)
  {
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v7 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_synchronize";
      unsigned int v8 = "%{public}s called with null func, backtrace limit exceeded";
      goto LABEL_31;
    }

    goto LABEL_32;
  }

  BOOL v12 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v7 = type;
  uint64_t v13 = os_log_type_enabled(v6, type);
  if (!v12)
  {
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_synchronize";
      unsigned int v8 = "%{public}s called with null func, no backtrace";
      goto LABEL_31;
    }

    goto LABEL_32;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_synchronize";
    uint64_t v18 = 2082;
    char v19 = v12;
    _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null func, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v12);
  if (v5) {
LABEL_34:
  }
    free(v5);
}

LABEL_33:
    if (!v16) {
      goto LABEL_36;
    }
    goto LABEL_34;
  }

  if (!v43)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)(id)gLogObj;
    uint64_t v22 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446466;
      int v46 = "nw_protocol_transform_append_protocol";
      uint64_t v47 = 1024;
      *(_DWORD *)v48 = a2;
      _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s Unsupported protocol level %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_32;
  }

  char v19 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v17 = (os_log_s *)(id)gLogObj;
  os_log_type_t v20 = type;
  int v21 = os_log_type_enabled(v17, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      int v46 = "nw_protocol_transform_append_protocol";
      uint64_t v47 = 1024;
      *(_DWORD *)v48 = a2;
      _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s Unsupported protocol level %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_32;
  }

  if (v21)
  {
    *(_DWORD *)buf = 136446722;
    int v46 = "nw_protocol_transform_append_protocol";
    uint64_t v47 = 1024;
    *(_DWORD *)v48 = a2;
    v48[2] = 2082;
    *(void *)&v48[3] = v19;
    _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s Unsupported protocol level %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v19);
  if (v16)
  {
LABEL_34:
    __int16 v23 = (char *)v16;
LABEL_35:
    free(v23);
  }

  if (v13) {
    free(v13);
  }
  uint64_t v7 = 0LL;
LABEL_15:

  return v7;
}

  if (v13) {
    free(v13);
  }
  uint64_t v7 = 0LL;
LABEL_15:

  return v7;
}

  if (v13) {
    free(v13);
  }
  uint64_t v7 = 0LL;
LABEL_15:

  return v7;
}

  if (v13) {
    free(v13);
  }
  uint64_t v7 = 0LL;
LABEL_15:

  return v7;
}

    unsigned int v8 = 0;
    goto LABEL_33;
  }

  if (nw_udp_options_get_use_quic_stats(v7)) {
    unsigned int v8 = -3;
  }
  else {
    unsigned int v8 = 0;
  }
LABEL_33:

  return v8;
}

      free(v10);
      if (!v4) {
        return 0LL;
      }
      goto LABEL_48;
    }

    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy_value";
    uint64_t v7 = "%{public}s called with null key";
LABEL_46:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_47;
  }

  if (!*(void *)(a1 + 16))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy_value";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      uint64_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      uint64_t v7 = "%{public}s called with null dictionary->xpc_object";
      goto LABEL_46;
    }

    if (!v14)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      uint64_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      uint64_t v7 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
      goto LABEL_46;
    }

    os_log_type_t v10 = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    uint64_t v6 = type;
    uint64_t v13 = os_log_type_enabled(v5, type);
    if (!v10)
    {
      if (!v13) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      uint64_t v7 = "%{public}s called with null dictionary->xpc_object, no backtrace";
      goto LABEL_46;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_dictionary_copy_value";
      uint64_t v18 = 2082;
      char v19 = v10;
      BOOL v12 = "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s";
      goto LABEL_31;
    }

    goto LABEL_32;
  }

  uint64_t pointer = (void *)xpc_dictionary_get_pointer();
  return 0LL;
}

  if (v3) {
LABEL_33:
  }
    free(v3);
  return 0LL;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_6;
  }

  if ((a2 & 1) == 0
    && ((*((_BYTE *)v3 + 473) & 8) == 0 && (nw_parameters_get_no_fallback(v3[2]) & 1) != 0
     || (nw_parameters_get_fallback_applied(v4[2]) & 1) != 0))
  {
LABEL_6:
    uint64_t v5 = 0LL;
    goto LABEL_15;
  }

  if (v4[14] || v4[21] && v4[22])
  {
    uint64_t v5 = 1LL;
  }

  else
  {
    uint64_t v6 = v4;
    else {
      uint64_t v5 = 0LL;
    }
  }

    if (v31) {
      free(v31);
    }
    mode = 0;
    goto LABEL_35;
  }

  mode = v1->mode;

  if (mode == 5)
  {
    int v4 = nw_endpoint_handler_copy_transform(v2);
    uint64_t v5 = v2;
    os_unfair_lock_lock(&v5->lock);
    uint64_t v6 = v5->current_path;
    os_unfair_lock_unlock(&v5->lock);

    v67 = 0LL;
    uint64_t v68 = &v67;
    os_log_type_t v69 = 0x2020000000LL;
    uint64_t v70 = 1;
    uint64_t v7 = v5;
    unsigned int v8 = v7[4];

    uint64_t v9 = (unsigned __int8 *)nw_parameters_copy_transform_array(v8);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    v73 = __Block_byref_object_copy__77715;
    *(void *)&v74 = __Block_byref_object_dispose__77716;
    *((void *)&v74 + 1) = 0LL;
    *(void *)os_log_type_t type = 0LL;
    uint64_t v62 = type;
    uint64_t v63 = 0x3032000000LL;
    char v64 = __Block_byref_object_copy__77715;
    unsigned int v65 = __Block_byref_object_dispose__77716;
    uint64_t v66 = 0LL;
    v53[0] = MEMORY[0x1895F87A8];
    v53[1] = 3221225472LL;
    v53[2] = ___ZL34nw_endpoint_transform_add_childrenP30NWConcrete_nw_endpoint_handler_block_invoke;
    v53[3] = &unk_189BC6D60;
    os_log_type_t v10 = v8;
    v54 = v10;
    uint64_t v11 = v4;
    v55 = v11;
    BOOL v12 = v7;
    v56 = v12;
    BOOL v58 = &v67;
    uint64_t v13 = v6;
    os_log_type_t v57 = v13;
    uint64_t v59 = buf;
    uint64_t v60 = type;
    nw_array_apply(v9, (uint64_t)v53);
    if (*((_BYTE *)v68 + 24))
    {
      char v14 = *((id *)v11 + 7);
      os_log_type_t v15 = v10;
      BOOL v16 = (NWConcrete_nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v15,  0,  0);

      nw_parameters_set_no_transform(v16, 1);
      if (nw_path_get_client_id(v13, &v71)) {
        nw_parameters_set_parent_id_inner(v16, (const unsigned __int8 *)&v71, 0);
      }
      inner = nw_endpoint_handler_create_inner(v14, v16, nw_endpoint_transform_receive_report, v12, v12, 0, 0);
      uint64_t v18 = *((void *)v11 + 1);
      if (!v18)
      {
        char v19 = nw_array_create();
        os_log_type_t v20 = (void *)*((void *)v11 + 1);
        *((void *)v11 + 1) = v19;

        uint64_t v18 = *((void *)v11 + 1);
      }

      nw_array_append(v18, inner);
    }

    int v21 = *(void *)(*(void *)&buf[8] + 40LL);
    if (v21)
    {
      uint64_t v22 = (void *)*((void *)v62 + 5);
      if (v22)
      {
        uint64_t v24 = *(void *)(v21 + 16);
        __int16 v23 = *(void *)(v21 + 24);
        if (xpc_array_get_count(v22) == (v23 - v24) >> 3)
        {
          combined_array = nw_array_create_combined_array(*((void **)v11 + 1), *(void **)(*(void *)&buf[8] + 40LL));
          int v26 = (void *)*((void *)v11 + 1);
          *((void *)v11 + 1) = combined_array;

          if (!*((void *)v11 + 3))
          {
            int v27 = xpc_array_create(0LL, 0LL);
            uint64_t v28 = (void *)*((void *)v11 + 3);
            *((void *)v11 + 3) = v27;
          }

          unint64_t v29 = (void *)*((void *)v62 + 5);
          applier[0] = MEMORY[0x1895F87A8];
          applier[1] = 3221225472LL;
          applier[2] = ___ZL34nw_endpoint_transform_add_childrenP30NWConcrete_nw_endpoint_handler_block_invoke_98;
          applier[3] = &unk_189BC8CB8;
          v52 = v11;
          xpc_array_apply(v29, applier);
        }
      }
    }

    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);

    _Block_object_dispose(&v67, 8);
    goto LABEL_56;
  }

      goto LABEL_33;
    }

    if (!v13)
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_metadata_matches_definition";
        uint64_t v7 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    uint64_t v9 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v6 = type;
    os_log_type_t v10 = os_log_type_enabled(v5, type);
    if (!v9)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_metadata_matches_definition";
        uint64_t v7 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v16 = "nw_protocol_metadata_matches_definition";
      uint64_t v17 = 2082;
      uint64_t v18 = v9;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v9);
  }

    if (v11) {
      free(v11);
    }
    goto LABEL_12;
  }

  uint64_t v3 = v1;
  int v4 = (void *)v3[3];
  if (v4
    && (*(void *)length = 0LL, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) != 0LL)
    && *(void *)length >= 0xD8uLL
    && (uint64_t v6 = data, *(void *)length == data[53] + 216LL)
    && ((data[52] & 0xE080) != 0 ? (uint64_t v7 = (data[52] & 0x13) == 1) : (uint64_t v7 = 1), !v7))
  {

    if (v6[53] >= 0xCCu)
    {
      unsigned int v8 = v6[104] & 1;
      goto LABEL_13;
    }
  }

  else
  {
  }

    if (v11) {
      free(v11);
    }
    goto LABEL_12;
  }

  uint64_t v3 = v1;
  int v4 = (void *)v3[3];
  if (v4
    && (*(void *)length = 0LL, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) != 0LL)
    && *(void *)length >= 0xD8uLL
    && (uint64_t v6 = data, *(void *)length == data[53] + 216LL)
    && ((data[52] & 0xE080) != 0 ? (uint64_t v7 = (data[52] & 0x13) == 1) : (uint64_t v7 = 1), !v7))
  {

    if (v6[53] >= 0xCCu)
    {
      unsigned int v8 = (*((unsigned __int8 *)v6 + 416) >> 2) & 1;
      goto LABEL_13;
    }
  }

  else
  {
  }

            free((void *)v2);
          }
        }
      }

    if (v9) {
      free(v9);
    }
LABEL_34:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v23 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_endpoint_handler_get_resolution_protocol";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v24, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v25 = (os_log_s *)(id)gLogObj;
        int v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_endpoint_handler_get_resolution_protocol";
          _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }

      else if (v33)
      {
        uint64_t v28 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v25 = (os_log_s *)(id)gLogObj;
        unint64_t v29 = type;
        uint64_t v30 = os_log_type_enabled(v25, type);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v36 = "nw_endpoint_handler_get_resolution_protocol";
            v37 = 2082;
            v38 = v28;
            _os_log_impl( &dword_181A5C000,  v25,  v29,  "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v28);
          if (!v24) {
            goto LABEL_41;
          }
          goto LABEL_40;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_endpoint_handler_get_resolution_protocol";
          _os_log_impl( &dword_181A5C000,  v25,  v29,  "%{public}s Endpoint handler is not a resolver, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v25 = (os_log_s *)(id)gLogObj;
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_endpoint_handler_get_resolution_protocol";
          _os_log_impl( &dword_181A5C000,  v25,  v31,  "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v24)
    {
LABEL_41:
      uint64_t v7 = 0LL;
      goto LABEL_42;
    }

      LOBYTE(v10) = 0;
      goto LABEL_33;
    }

    goto LABEL_61;
  }

  __break(1u);
LABEL_63:
  __break(1u);
  return result;
}

      LOWORD(v10) = 0;
      goto LABEL_33;
    }

    goto LABEL_61;
  }

  __break(1u);
LABEL_63:
  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

    __break(1u);
LABEL_33:
    __break(1u);
    return;
  }

  if (!*(_BYTE *)(a1 + 24))
  {
    if (v2 > 0x7FFFFFFF)
    {
      __break(1u);
    }

    else if (v2 >= (uint64_t)0xFFFFFFFF80000000LL && v3 >= (uint64_t)0xFFFFFFFF80000000LL)
    {
      if (v3 <= 0x7FFFFFFF)
      {
        nw_activity_complete_with_reason_and_underlying_error(*(void **)(v1 + 16), 3u, v2, v3);
        return;
      }

      goto LABEL_31;
    }

    __break(1u);
LABEL_31:
    __break(1u);
    goto LABEL_32;
  }

  if (v4 | v3) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = v2 == 2;
  }
  if (v8) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 4;
  }
  if (v2 == 1 && (v4 | v3) == 0) {
    uint64_t v11 = 2;
  }
  else {
    uint64_t v11 = v9;
  }
  if (v4 | v3 | v2) {
    BOOL v12 = v11;
  }
  else {
    BOOL v12 = 1;
  }
  nw_activity_complete_with_reason(*(void **)(v1 + 16), v12);
}

    os_log_type_t v31 = (v37 - 1) & v37;
    v33 = __clz(__rbit64(v37)) + (v27 << 6);
LABEL_15:
    (*(void (**)(char *, unint64_t, uint64_t))(v7 + 16))( v12,  *(void *)(v24 + 56) + *(void *)(v7 + 72) * v33,  v6);
    (*(void (**)(char *, char *, uint64_t))(v7 + 32))(v10, v12, v6);
    sub_181BF7EF8();
    os_log_type_t v34 = swift_allocError();
    *(_OWORD *)unint64_t v35 = v53;
    *(void *)(v35 + 16) = 0xB000000000000000LL;
    v55 = v34;
    sub_18264ED78();
    (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v6);
  }

  v38 = v36 + 4;
  if (v38 < v1)
  {
    v37 = *(void *)(v28 + 8 * v38);
    if (!v37)
    {
      while (1)
      {
        int v27 = v38 + 1;
        if (__OFADD__(v38, 1LL)) {
          goto LABEL_37;
        }
        if (v27 >= v1) {
          goto LABEL_33;
        }
        v37 = *(void *)(v28 + 8 * v27);
        ++v38;
        if (v37) {
          goto LABEL_32;
        }
      }
    }

    int v27 = v38;
    goto LABEL_32;
  }

  BOOL result = sub_18264F360();
  __break(1u);
  return result;
}

  BOOL result = sub_18264F360();
  __break(1u);
  return result;
}

  BOOL result = sub_18264F360();
  __break(1u);
  return result;
}

  BOOL result = sub_18264F360();
  __break(1u);
  return result;
}

  if (v4) {
LABEL_33:
  }
    free(v4);
  return 0LL;
}

  if (v4) {
LABEL_33:
  }
    free(v4);
  return 0LL;
}

    (*(void (**)(uint64_t, char *))(*(void *)(v31 + 24) + 40LL))(v31, handle);
  }

  if (gLogDatapath)
  {
    uint64_t v59 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v84 = "nw_shoes_read_reply";
      v85 = 2082;
      uint64_t v86 = v20;
      uint64_t v6 = "%{public}s %{public}s Failed to read shoes reply length";
LABEL_110:
      uint64_t v7 = v59;
      v55 = OS_LOG_TYPE_DEBUG;
      goto LABEL_92;
    }
  }

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v23 = (os_log_s *)gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      uint64_t v24 = v4[2];
      *(_DWORD *)v55 = 136446978;
      *(void *)&v55[4] = "nw_protocol_shoes_send_request_inner";
      *(_WORD *)&v55[12] = 2082;
      *(void *)&v55[14] = handle + 151;
      *(_WORD *)&v55[22] = 1024;
      LODWORD(v56) = v24;
      WORD2(v56) = 1024;
      *(_DWORD *)((char *)&v56 + 6) = v5;
      _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Failed to send shoes request (type %u inner length %u)",  v55,  0x22u);
      return 0LL;
    }

    return result;
  }

  uint64_t v49 = v6;
  os_log_type_t v50 = v5;
  uint64_t v11 = v4;
  while (1)
  {
    BOOL v12 = *(void *)(v10 + 32);
    if (v12 || *(void *)(v10 + 40))
    {
      uint64_t v13 = *(void *)(v10 + 112);
      if (!v13) {
        goto LABEL_17;
      }
    }

    else
    {
      BOOL v12 = 0LL;
      uint64_t v13 = *(void *)(v10 + 112);
      if (!v13) {
        goto LABEL_17;
      }
    }

    if ((*(_WORD *)(v10 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v10, *(void *)(v10 + 88)))
    {
      LODWORD(v13) = 0;
LABEL_17:
      os_log_type_t v15 = 0LL;
      goto LABEL_18;
    }

    LODWORD(v13) = *(_DWORD *)(v10 + 52);
    char v14 = *(unsigned int *)(v10 + 56);
    if ((_DWORD)v13) {
      LODWORD(v13) = v13 - (v14 + *(_DWORD *)(v10 + 60));
    }
    os_log_type_t v15 = (void *)(*(void *)(v10 + 112) + v14);
LABEL_18:
    BOOL v16 = v13 >= v7 ? v7 : v13;
    memcpy(v15, v11, v16);
    if (!nw_frame_claim(v10, v17, v16, 0)) {
      break;
    }
    nw_frame_collapse(v10);
    nw_frame_unclaim(v10, v18, v16, 0);
    char v19 = *(void *)(v10 + 32);
    os_log_type_t v20 = *(void **)(v10 + 40);
    if (v19)
    {
      *(void *)(v19 + 40) = v20;
      os_log_type_t v20 = *(void **)(v10 + 40);
    }

    else
    {
      v54 = *(uint64_t **)(v10 + 40);
    }

    *os_log_type_t v20 = v19;
    int v21 = v52;
    *(void *)(v10 + 32) = 0LL;
    *(void *)(v10 + 40) = v21;
    char *v21 = v10;
    v52 = (uint64_t *)(v10 + 32);
    if (v12)
    {
      v11 += v16;
      os_log_type_t v10 = v12;
      v7 -= v16;
      if (v7) {
        continue;
      }
    }

    goto LABEL_36;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v25 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_shoes_send";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v49 + 151;
    *(_WORD *)&buf[22] = 1024;
    unsigned int v65 = v16;
    _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Claiming frame with %u bytes failed",  buf,  0x1Cu);
  }

  if (v5) {
    free(v5);
  }
  return 1LL;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
          uint64_t v30 = (char *)_os_log_send_and_compose_impl();
          type.__r_.__value_.__s.__data_[0] = 16;
          LOBYTE(v151[0]) = 0;
          if (type.__r_.__value_.__s.__data_[0] == 17)
          {
            os_log_type_t v31 = (os_log_s *)__nwlog_obj();
            uint64_t v32 = type.__r_.__value_.__s.__data_[0];
            if (!os_log_type_enabled(v31, (os_log_type_t)type.__r_.__value_.__s.__data_[0])) {
              goto LABEL_279;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
            v33 = "%{public}s called with null http_sniffing";
LABEL_278:
            _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
            goto LABEL_279;
          }

          if (!LOBYTE(v151[0]))
          {
            os_log_type_t v31 = (os_log_s *)__nwlog_obj();
            uint64_t v32 = type.__r_.__value_.__s.__data_[0];
            if (os_log_type_enabled(v31, (os_log_type_t)type.__r_.__value_.__s.__data_[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
              v33 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
              goto LABEL_278;
            }

            goto LABEL_279;
          }

          uint64_t v118 = (char *)__nw_create_backtrace_string();
          os_log_type_t v31 = (os_log_s *)__nwlog_obj();
          uint64_t v32 = type.__r_.__value_.__s.__data_[0];
          v119 = os_log_type_enabled(v31, (os_log_type_t)type.__r_.__value_.__s.__data_[0]);
          if (!v118)
          {
            if (v119)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
              v33 = "%{public}s called with null http_sniffing, no backtrace";
              goto LABEL_278;
            }

            goto LABEL_279;
          }

          if (!v119) {
            goto LABEL_231;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v118;
          v120 = "%{public}s called with null http_sniffing, dumping backtrace:%{public}s";
LABEL_230:
          _os_log_impl(&dword_181A5C000, v31, v32, v120, buf, 0x16u);
          goto LABEL_231;
        }

  if (v5) {
    free(v5);
  }
  return 0LL;
}

          goto LABEL_67;
        }

        if (v48)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v42 = type;
          os_log_type_t v43 = os_log_type_enabled(v36, type);
          if (backtrace_string)
          {
            if (v43)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v36,  v42,  "%{public}s called with null evaluator, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            goto LABEL_47;
          }

          if (v43)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_181A5C000, v36, v42, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v46 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl( &dword_181A5C000,  v36,  v46,  "%{public}s called with null evaluator, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
        uint64_t v28 = (char *)_os_log_send_and_compose_impl();

        int v21 = v47;
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v48 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          unint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v32 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null destination", buf, 0xCu);
          }

          goto LABEL_32;
        }

        if (v48)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v40 = type;
          uint64_t v41 = os_log_type_enabled(v36, type);
          if (backtrace_string)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v36,  v40,  "%{public}s called with null destination, dumping backtrace:%{public}s",  buf,  0x16u);
            }

  if (v8) {
LABEL_33:
  }
    free(v8);
LABEL_34:
}

    if (v11) {
      free(v11);
    }
    goto LABEL_10;
  }

  if (v3[7] || v3[9] || v3[6])
  {
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    }
    uint64_t v5 = (os_log_s *)(id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = (char *)v4[1];
      *(_DWORD *)buf = 136446466;
      int v21 = "nw_candidate_manager_start_client";
      uint64_t v22 = 2048;
      __int16 v23 = v6;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s [CM%zu] Cannot start an already started candidate_manager",  buf,  0x16u);
    }

LABEL_10:
    uint64_t v7 = 0LL;
    goto LABEL_11;
  }

  if (a2) {
    uint64_t v9 = 2;
  }
  else {
    uint64_t v9 = 0;
  }
  *((_BYTE *)v3 + 184) = v3[23] & 0xFD | v9;
  nw_candidate_manager_start_bonjour_service_resolve(v3);
  uint64_t v7 = v4[6] != 0LL;
LABEL_11:

  return v7;
}

  if (v6) {
LABEL_33:
  }
    free(v6);
  return 0LL;
}

  if (v12) {
    free(v12);
  }
  uint64_t v9 = 0LL;
LABEL_9:

  return v9;
}

    free(backtrace_string);
    goto LABEL_45;
  }

  if ((nw_protocol_metadata_supports_replies(v3) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s Protocol does not support replies, cannot copy reply",  buf,  0xCu);
    }

LABEL_9:
    uint64_t v9 = 0LL;
    goto LABEL_12;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  uint64_t v28 = __Block_byref_object_copy__4444;
  unint64_t v29 = __Block_byref_object_dispose__4445;
  uint64_t v30 = 0LL;
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3221225472LL;
  v24[2] = __nw_framer_message_copy_original_message_block_invoke;
  v24[3] = &unk_189BC60A8;
  v24[4] = buf;
  uint64_t v6 = *((void *)v3 + 4);
  if (v6)
  {
    __nw_framer_message_copy_original_message_block_invoke((uint64_t)v24, v6);
    uint64_t v7 = *(void **)(*(void *)&buf[8] + 40LL);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  uint64_t v9 = v7;
  _Block_object_dispose(buf, 8);

LABEL_12:
  return v9;
}

  __int16 v25 = *((_DWORD *)v14 + 20);
  if (v25 == 1)
  {
    int v26 = 2056;
  }

  else
  {
    if (v25 != 2) {
      goto LABEL_37;
    }
    int v26 = 1028;
  }

  *((_WORD *)v14 + 44) |= v26;
LABEL_37:
  if (!a4)
  {
    if (!a5) {
      goto LABEL_85;
    }
    if (a5->sa_len > 0x80u) {
      goto LABEL_85;
    }
    uint64_t v30 = a5->sa_family;
    if (v30 != 30 && v30 != 2) {
      goto LABEL_85;
    }
    if ((a3 & 2) != 0)
    {
      if (v30 == 30)
      {
        if (a6) {
          os_log_type_t v39 = 512;
        }
        else {
          os_log_type_t v39 = 8;
        }
        *((_WORD *)v44 + 44) |= v39;
        if (v13) {
          v13->flags |= 8u;
        }
      }

      else
      {
        if (a6) {
          uint64_t v36 = 256;
        }
        else {
          uint64_t v36 = 4;
        }
        *((_WORD *)v44 + 44) |= v36;
        if (v13) {
          v13->flags |= 4u;
        }
      }

      goto LABEL_85;
    }

    if (v30 == 30)
    {
      if (v13)
      {
        flags = v13->flags;
        uint64_t v32 = -11;
        goto LABEL_75;
      }

      v38 = v44;
      BOOL v40 = *((_WORD *)v44 + 44);
      uint64_t v41 = -11;
    }

    else
    {
      if (v13)
      {
        flags = v13->flags;
        uint64_t v32 = -6;
LABEL_75:
        v13->flags = flags & v32;
        goto LABEL_85;
      }

      v38 = v44;
      BOOL v40 = *((_WORD *)v44 + 44);
      uint64_t v41 = -6;
    }

    v37 = v40 & v41;
    goto LABEL_84;
  }

  if (a4 != -65554 || !a5)
  {
    if (v13)
    {
      v13->flags |= 3u;
      if ((*((_WORD *)v14 + 44) & 0xC) != 0) {
        goto LABEL_85;
      }
    }

    else
    {
      v33 = *((_WORD *)v14 + 44) | 3;
      *((_WORD *)v14 + 44) = v33;
      if ((v33 & 0xC) != 0) {
        goto LABEL_85;
      }
    }

    *((_DWORD *)v44 + 21) = a4;
    goto LABEL_85;
  }

  int v27 = a5->sa_family;
  if (v27 != 30)
  {
    if (v27 != 2) {
      goto LABEL_85;
    }
    if (v13)
    {
      uint64_t v28 = v13->flags;
      v13->flags = v28 | 1;
      if (a7)
      {
        unint64_t v29 = 1025;
LABEL_61:
        v13->flags = v28 | v29;
        goto LABEL_85;
      }

      goto LABEL_85;
    }

    os_log_type_t v34 = *((_WORD *)v44 + 44);
    *((_WORD *)v44 + 44) = v34 | 1;
    if (!a7) {
      goto LABEL_85;
    }
    unint64_t v35 = 1025;
    goto LABEL_72;
  }

  if (!v13)
  {
    os_log_type_t v34 = *((_WORD *)v14 + 44);
    *((_WORD *)v14 + 44) = v34 | 2;
    if (!a7) {
      goto LABEL_85;
    }
    unint64_t v35 = 2050;
LABEL_72:
    v37 = v34 | v35;
    v38 = v44;
LABEL_84:
    *((_WORD *)v38 + 44) = v37;
    goto LABEL_85;
  }

  uint64_t v28 = v13->flags;
  v13->flags = v28 | 2;
  if (a7)
  {
    unint64_t v29 = 2050;
    goto LABEL_61;
  }

  if (v14) {
    free(v14);
  }
LABEL_15:
}

          goto LABEL_33;
        }

        if (!v61)
        {
          __nwlog_obj();
          int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v41 = type;
          if (os_log_type_enabled(v26, type))
          {
            uint64_t v42 = nw_group_descriptor_get_type(v5[8]);
            if (v42 > 4) {
              os_log_type_t v43 = "unknown";
            }
            else {
              os_log_type_t v43 = off_189BB74C8[v42];
            }
            *(_DWORD *)buf = 136446466;
            char v64 = "nw_connection_group_copy_protocol_metadata_for_message";
            unsigned int v65 = 2080;
            uint64_t v66 = (void *)v43;
            _os_log_impl( &dword_181A5C000,  v26,  v41,  "%{public}s Unsupported group descriptor type: %s, backtrace limit exceeded",  buf,  0x16u);
          }

          goto LABEL_32;
        }

        uint64_t v36 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        v38 = os_log_type_enabled(v26, type);
        if (!v36)
        {
          if (v38)
          {
            uint64_t v44 = nw_group_descriptor_get_type(v5[8]);
            if (v44 > 4) {
              uint64_t v45 = "unknown";
            }
            else {
              uint64_t v45 = off_189BB74C8[v44];
            }
            *(_DWORD *)buf = 136446466;
            char v64 = "nw_connection_group_copy_protocol_metadata_for_message";
            unsigned int v65 = 2080;
            uint64_t v66 = (void *)v45;
            _os_log_impl( &dword_181A5C000,  v26,  v37,  "%{public}s Unsupported group descriptor type: %s, no backtrace",  buf,  0x16u);
          }

          goto LABEL_32;
        }

        if (v38)
        {
          os_log_type_t v39 = nw_group_descriptor_get_type(v5[8]);
          if (v39 > 4) {
            BOOL v40 = "unknown";
          }
          else {
            BOOL v40 = off_189BB74C8[v39];
          }
          *(_DWORD *)buf = 136446722;
          char v64 = "nw_connection_group_copy_protocol_metadata_for_message";
          unsigned int v65 = 2080;
          uint64_t v66 = (void *)v40;
          v67 = 2082;
          uint64_t v68 = v36;
          _os_log_impl( &dword_181A5C000,  v26,  v37,  "%{public}s Unsupported group descriptor type: %s, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v36);
      }

            free((void *)v2);
          }
        }
      }

            free((void *)v2);
          }
        }
      }

            free((void *)v2);
          }
        }
      }

            free((void *)v2);
          }
        }
      }

            free((void *)v2);
          }
        }
      }

            free((void *)v2);
          }
        }
      }

            free((void *)v2);
          }
        }
      }

            free((void *)v2);
          }
        }
      }

  if (v10) {
    free(v10);
  }
}

  if (v10) {
    free(v10);
  }
}

    if (v19) {
      free(v19);
    }
    goto LABEL_13;
  }

  os_log_type_t v10 = strdup(v7 + 407);
  if (v10)
  {
LABEL_3:
    uint64_t v11 = strlen(v10);
    if (v11) {
      v10[v11 - 1] = 0;
    }
    BOOL v12 = v11 > 2;
    uint64_t v13 = *((unsigned __int16 *)v7 + 200);
    char v14 = 0xFFFF;
    if (v13 != 0xFFFF)
    {
      char v14 = v13 + 1;
      *((_WORD *)v7 + 200) = v13 + 1;
    }

    os_log_type_t v15 = (char *)v8;
    BOOL v16 = v15;
    if (v10)
    {
      if (v10[2 * v12])
      {
        *((_WORD *)v15 + 68) = v14;
        snprintf(v15 + 48, 0x54uLL, "[%s%s:%u]", "C", &v10[2 * v12], v14);
      }

      free(v10);
    }

    else
    {
    }

    uint64_t v17 = v16;
    *((void *)v17 + 2) = a4;

LABEL_13:
    return;
  }

  __nwlog_obj();
  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v31 = "strict_strdup";
  __int16 v23 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v23))
  {
    free(v23);
    goto LABEL_3;
  }

  __break(1u);
}

    free(backtrace_string);
    goto LABEL_45;
  }

  if (*(_DWORD *)(*((void *)v5 + 1) + 64LL) != 3 || (unsigned int v8 = *((void *)v5 + 29)) == 0)
  {
LABEL_11:
    os_log_type_t v10 = 0LL;
    goto LABEL_12;
  }

  node = nw_hash_table_get_node(v8, a2, 8LL);
  if (!node)
  {
    if ((v5[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446978;
        unint64_t v29 = "nw_protocol_instance_access_flow_state";
        uint64_t v30 = 2082;
        os_log_type_t v31 = v5 + 407;
        uint64_t v32 = 2080;
        v33 = " ";
        os_log_type_t v34 = 2048;
        unint64_t v35 = a2;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sFlow %llx not present, not getting state",  buf,  0x2Au);
      }
    }

    goto LABEL_11;
  }

  os_log_type_t v10 = v7[2](v7, *(void *)(node + 32));
LABEL_12:

  return v10;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

    if (v13) {
      free(v13);
    }
    goto LABEL_13;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    unsigned int v8 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446722;
    int v27 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
    uint64_t v28 = 2114;
    unint64_t v29 = v8;
    uint64_t v30 = 1024;
    os_log_type_t v31 = v5;
    _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ out connection write close error %{darwin.errno}d",  buf,  0x1Cu);
  }

    if (v13) {
      free(v13);
    }
    goto LABEL_13;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    unsigned int v8 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446722;
    int v27 = "nw_socks5_connection_outer_connection_read_on_queue_block_invoke";
    uint64_t v28 = 2114;
    unint64_t v29 = v8;
    uint64_t v30 = 1024;
    os_log_type_t v31 = v5;
    _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ in connection write close error %{darwin.errno}d",  buf,  0x1Cu);
  }

  if (v28) {
    free(v28);
  }
LABEL_6:
}

    free(backtrace_string);
    goto LABEL_42;
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_protocol_trainer_top_inject_output";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_trainer_top_inject_output";
        int v21 = "%{public}s called with null trainer";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    if (!v28)
    {
      char v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_trainer_top_inject_output";
        int v21 = "%{public}s called with null trainer, backtrace limit exceeded";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v19 = (os_log_s *)__nwlog_obj();
    os_log_type_t v20 = type;
    int v27 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_trainer_top_inject_output";
        int v21 = "%{public}s called with null trainer, no backtrace";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_protocol_trainer_top_inject_output";
      uint64_t v32 = 2082;
      v33 = backtrace_string;
      uint64_t v24 = "%{public}s called with null trainer, dumping backtrace:%{public}s";
      goto LABEL_31;
    }

    goto LABEL_32;
  }

  os_log_type_t v10 = 0LL;
  uint64_t v11 = 0;
  if (a4)
  {
    BOOL v12 = __size;
    if ((_DWORD)__size)
    {
      os_log_type_t v10 = malloc(__size);
      if (!v10)
      {
        __int16 v25 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        os_log_type_t v31 = "strict_malloc";
        uint64_t v32 = 2048;
        v33 = (char *)v12;
        int v26 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v26);
        if (result)
        {
          __break(1u);
          return result;
        }

        free(v26);
      }

      memcpy(v10, a4, v12);
      uint64_t v11 = v12;
    }
  }

  uint64_t v13 = nw_frame_create(0, (uint64_t)v10, v11, (uint64_t)nw_protocol_trainer_frame_finalizer, a1);
  char v14 = (void *)v13;
  if (a2) {
    nw_frame_set_metadata(v13, a2, 0, a3);
  }
  if (v10) {
    nw_frame_set_buffer_used_malloc((uint64_t)v14, 1);
  }
  v14[2] = 0LL;
  os_log_type_t v15 = *(void **)(v6 + 80);
  v14[3] = v15;
  os_log_s *v15 = v14;
  *(void *)(v6 + 80) = v14 + 2;
  v14[4] = 0LL;
  BOOL v16 = *(void **)(v6 + 112);
  v14[5] = v16;
  *BOOL v16 = v14;
  *(void *)(v6 + 112) = v14 + 4;
  ++*(_DWORD *)(v6 + 192);
  return 1LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_42;
  }

  __int16 v23 = (os_log_s *)__nwlog_obj();
  uint64_t v24 = type;
  if (os_log_type_enabled(v23, type))
  {
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_trainer_bottom_get_output_frames";
    __int16 v25 = "%{public}s called with null protocol";
LABEL_41:
    _os_log_impl(&dword_181A5C000, v23, v24, v25, buf, 0xCu);
  }

  if (v23) {
    free(v23);
  }
LABEL_4:
  *(_OWORD *)BOOL v40 = *(_OWORD *)a3;
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v11 && !nw_path_parameters_get_logging_disabled(*(void *)(v11 + 104)))
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    BOOL v12 = (os_log_s *)(id)glistenerLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      id_string = nw_listener_get_id_string(*(void **)(a1 + 32));
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_listener_reconcile_inboxes_on_queue_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = id_string;
      *(_WORD *)&buf[22] = 1042;
      LODWORD(v37) = 16;
      WORD2(v37) = 2098;
      *(void *)((char *)&v37 + 6) = v40;
      HIWORD(v37) = 2114;
      v38 = v5;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_INFO,  "%{public}s [%{public}s] adding flow registration for nexus %{public,uuid_t}.16P on %{public}@",  buf,  0x30u);
    }
  }

  flow_inner = nw_path_evaluator_create_flow_inner( *(void **)(*(void *)(a1 + 32) + 168LL),  0,  1,  0,  0,  v40,  0LL,  0,  0LL);
  os_log_type_t v15 = *(void *)(*(void *)(a1 + 32) + 152LL);
  if (v15
    || (BOOL v16 = nw_array_create(),
        uint64_t v17 = *(void *)(a1 + 32),
        uint64_t v18 = *(void **)(v17 + 152),
        *(void *)(v17 + 152) = v16,
        v18,
        char v19 = *(void **)(a1 + 32),
        (os_log_type_t v15 = v19[19]) != 0))
  {
    nw_array_append(v15, flow_inner);
    char v19 = *(void **)(a1 + 32);
  }

  os_log_type_t v20 = (void *)v19[3];
  v31[0] = v7;
  v31[1] = 3221225472LL;
  v31[2] = ___ZL38nw_listener_reconcile_inboxes_on_queueP22NWConcrete_nw_listener_block_invoke_203;
  v31[3] = &unk_189BC9238;
  uint64_t v32 = v19;
  int v21 = flow_inner;
  v33 = v21;
  nw_queue_context_async(v20, v31);

LABEL_15:
}

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F92F0];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void ***)(v3[13] + 176LL);
        uint64_t v9 = *v8;
        char *v8 = v7;

        goto LABEL_13;
      }
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F92F0];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void *)(v3[13] + 176LL);
        uint64_t v9 = *(void **)(v8 + 8);
        *(void *)(v8 + 8) = v7;

        goto LABEL_13;
      }
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F92F0];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void *)(v3[13] + 176LL);
        uint64_t v9 = *(void **)(v8 + 16);
        *(void *)(v8 + 16) = v7;

        goto LABEL_13;
      }
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F9250];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void *)(v3[13] + 176LL);
        uint64_t v9 = *(void **)(v8 + 24);
        *(void *)(v8 + 24) = v7;

        goto LABEL_13;
      }
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F92F8];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void *)(v3[13] + 176LL);
        uint64_t v9 = *(void **)(v8 + 48);
        *(void *)(v8 + 48) = v7;

        goto LABEL_13;
      }
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F92F8];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void *)(v3[13] + 176LL);
        uint64_t v9 = *(void **)(v8 + 72);
        *(void *)(v8 + 72) = v7;

        goto LABEL_13;
      }
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F92F8];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void *)(v3[13] + 176LL);
        uint64_t v9 = *(void **)(v8 + 96);
        *(void *)(v8 + 96) = v7;

        goto LABEL_13;
      }
    }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  if (*(void *)(v3[13] + 176LL))
  {
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (!v4)
  {
LABEL_13:

    return;
  }

  uint64_t v6 = calloc(1uLL, 0x90uLL);
  if (v6)
  {
LABEL_7:
    *(void *)(v3[13] + 176LL) = v6;
LABEL_8:
    if (object_getClass(v5) == (Class)MEMORY[0x1895F9220])
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke;
      __int16 v23 = (uint64_t)&__block_descriptor_tmp_86584;
      uint64_t v24 = MEMORY[0x1895F92F8];
      if (xpc_array_apply(v5, applier))
      {
        uint64_t v7 = xpc_retain(v5);
LABEL_12:
        unsigned int v8 = *(void *)(v3[13] + 176LL);
        uint64_t v9 = *(void **)(v8 + 120);
        *(void *)(v8 + 120) = v7;

        goto LABEL_13;
      }
    }

LABEL_33:
        goto LABEL_34;
      }

      __nwlog_obj();
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
      os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v67 = 0;
      if (__nwlog_fault(v43, type, &v67))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v45 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s called with null join_stack", buf, 0xCu);
          }
        }

        else if (v67)
        {
          v55 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v56 = type[0];
          os_log_type_t v57 = os_log_type_enabled(v44, type[0]);
          if (v55)
          {
            if (v57)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
              os_log_type_t v69 = 2082;
              uint64_t v70 = v55;
              _os_log_impl( &dword_181A5C000,  v44,  v56,  "%{public}s called with null join_stack, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v55);
            goto LABEL_104;
          }

          if (v57)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_181A5C000, v44, v56, "%{public}s called with null join_stack, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v61 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl( &dword_181A5C000,  v44,  v61,  "%{public}s called with null join_stack, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_33;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http_client_bottom_get_parameters";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_client_bottom_get_parameters";
      uint64_t v6 = "%{public}s called with null http_client_bottom";
      goto LABEL_32;
    }

    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_client_bottom_get_parameters";
      uint64_t v6 = "%{public}s called with null http_client_bottom, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v9 = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    os_log_type_t v10 = os_log_type_enabled(v4, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_client_bottom_get_parameters";
      uint64_t v6 = "%{public}s called with null http_client_bottom, no backtrace";
      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_http_client_bottom_get_parameters";
      os_log_type_t v15 = 2082;
      BOOL v16 = v9;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null http_client_bottom, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v9);
LABEL_33:
    if (!v3) {
      return 0LL;
    }
LABEL_34:
    free(v3);
    return 0LL;
  }

  BOOL result = handle[13];
  if (!result) {
    return nw_protocol_get_parameters(handle[6]);
  }
  return result;
}

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_33;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http_client_bottom_get_remote_endpoint";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_client_bottom_get_remote_endpoint";
      uint64_t v6 = "%{public}s called with null http_client_bottom";
      goto LABEL_32;
    }

    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_client_bottom_get_remote_endpoint";
      uint64_t v6 = "%{public}s called with null http_client_bottom, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v9 = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    os_log_type_t v10 = os_log_type_enabled(v4, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_client_bottom_get_remote_endpoint";
      uint64_t v6 = "%{public}s called with null http_client_bottom, no backtrace";
      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_http_client_bottom_get_remote_endpoint";
      os_log_type_t v15 = 2082;
      BOOL v16 = v9;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null http_client_bottom, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v9);
LABEL_33:
    if (!v3) {
      return 0LL;
    }
LABEL_34:
    free(v3);
    return 0LL;
  }

  BOOL result = handle[15];
  if (!result) {
    return nw_protocol_get_remote_endpoint(handle[6]);
  }
  return result;
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_33;
  }

  if (a2)
  {
    int v4 = nw_endpoint_copy_registrar_for_identifier(*(void **)(a1 + 120), *(__int128 **)(a1 + 16), 0);
    nw_protocol_instance_registrar_add_wildcard_edge_for_instance(v4, *(void **)(a1 + 120), a1, a2);
    if (v4) {
      os_release(v4);
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_http_client_bottom_endpoint_joinable";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_protocol_http_client_bottom_endpoint_joinable";
    unsigned int v8 = "%{public}s called with null endpoint";
    goto LABEL_32;
  }

  if (!v13)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_protocol_http_client_bottom_endpoint_joinable";
    unsigned int v8 = "%{public}s called with null endpoint, backtrace limit exceeded";
    goto LABEL_32;
  }

  uint64_t v11 = (char *)__nw_create_backtrace_string();
  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = type;
  BOOL v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_protocol_http_client_bottom_endpoint_joinable";
    unsigned int v8 = "%{public}s called with null endpoint, no backtrace";
    goto LABEL_32;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v16 = "nw_protocol_http_client_bottom_endpoint_joinable";
    uint64_t v17 = 2082;
    uint64_t v18 = v11;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v5) {
LABEL_34:
  }
    free(v5);
}
  }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v7) {
LABEL_33:
  }
    free(v7);
  return 0LL;
}

  if (v3) {
LABEL_33:
  }
    free(v3);
  return 0LL;
}

  free(v11);
  if (v5) {
LABEL_48:
  }
    free(v5);
}

  free(v13);
  if (v7) {
LABEL_48:
  }
    free(v7);
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  free(v9);
  if (v3) {
LABEL_48:
  }
    free(v3);
}

    if (v8) {
      free(v8);
    }
    return 0LL;
  }

  uint64_t v5 = calloc(1uLL, 0x1B8uLL);
  if (v5)
  {
LABEL_3:
    if (nw_protocol_oblivious_http_contexts_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_oblivious_http_contexts_identifier::onceToken, &__block_literal_global_3_28583);
    }
    if (nw_protocols_are_equal(a1, &nw_protocol_oblivious_http_contexts_identifier::ohttp_protocol_identifier))
    {
      if (nw_protocol_oblivious_http_contexts_identifier::onceToken != -1) {
        dispatch_once(&nw_protocol_oblivious_http_contexts_identifier::onceToken, &__block_literal_global_3_28583);
      }
      uint64_t v6 = &nw_protocol_oblivious_http_contexts_identifier::ohttp_protocol_identifier;
    }

    else
    {
      if (nw_protocol_oblivious_http_identifier::onceToken != -1) {
        dispatch_once(&nw_protocol_oblivious_http_identifier::onceToken, &__block_literal_global_28577);
      }
      uint64_t v6 = (uint64_t *)&nw_protocol_oblivious_http_identifier::ohttp_protocol_identifier;
    }

    v5[2] = v6;
    v5[3] = &nw_protocol_ohttp_get_callbacks(void)::ohttp_protocol_callbacks;
    v5[41] = 0LL;
    v5[42] = v5 + 41;
    v5[9] = 0LL;
    v5[10] = v5 + 9;
    v5[11] = 0LL;
    v5[5] = v5;
    v5[12] = v5 + 11;
    v5[13] = 0LL;
    v5[14] = v5 + 13;
    return (BOOL)v5;
  }

  BOOL v12 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  char v19 = "strict_calloc";
  os_log_type_t v20 = 2048;
  int v21 = 1LL;
  uint64_t v22 = 2048;
  __int16 v23 = 440LL;
  uint64_t v13 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v36 && !nw_http_fillout_indeterminate_binary_message_body_chunk(v16, v15, 0, 0LL, (char *)&v22[v33], v36))
  {
    if (v22) {
      free(v22);
    }
    uint64_t v41 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)buf = 136446210;
    v126 = "nw_http_create_oblivious_request";
    uint64_t v42 = "%{public}s Failed to fill out binary message chunk";
    goto LABEL_136;
  }

  int v21 = 0LL;
  os_log_type_t v15 = v111;
  os_log_type_t v20 = a9;
  BOOL v16 = v22;
  uint64_t v11 = "message/bhttp";
  uint64_t v13 = a7;
  BOOL v12 = a8;
LABEL_48:
  if (!a2 || !a3)
  {
    if (!a2)
    {
      os_log_type_t v53 = (char *)nw_http_encrypt_oblivious_request( v16,  v15 + v21,  v11,  v13,  v12,  (char **)(a1 + 112),  (void *)(a1 + 120),  (void *)(a1 + 96),  (size_t *)(a1 + 104),  v20);
      if (v22)
      {
        v54 = v22;
LABEL_152:
        free(v54);
      }

      return (BOOL)v53;
    }

    v48 = 0LL;
    *(void *)os_log_type_t type = 0LL;
    if (*(void *)(a1 + 112)
      || (v48 = nw_http_encrypt_chunked_oblivious_request_header( v11,  v13,  v12,  (char **)(a1 + 112),  (void *)(a1 + 120),  (void *)(a1 + 96),  (size_t *)(a1 + 104),  type)))
    {
      __n = 0LL;
      if (!v15)
      {
        v52 = 0LL;
        uint64_t v51 = 0LL;
        uint64_t v49 = a6;
LABEL_65:
        if (v49) {
          v55 = 0LL;
        }
        else {
          v55 = v52;
        }
        uint64_t v122 = 0LL;
        if (v55 > 0x3F)
        {
          if (v55 >> 14)
          {
            if (v55 >> 30)
            {
              if (v55 >> 62)
              {
                v73 = (os_log_s *)__nwlog_obj();
                os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
                *(_DWORD *)buf = 136446466;
                v126 = "_http_vle_encode";
                os_log_type_t v127 = 2048;
                v128 = v55;
                v74 = (void *)_os_log_send_and_compose_impl();
                BOOL result = __nwlog_abort((uint64_t)v74);
                if (result) {
                  goto LABEL_318;
                }
                free(v74);
                v56 = 0LL;
                v52 = __n;
              }

              else
              {
                uint64_t v122 = bswap64(v55 | 0xC000000000000000LL);
                v56 = 8LL;
              }
            }

            else
            {
              uint64_t v122 = bswap32(v55 | 0x80000000);
              v56 = 4LL;
            }
          }

          else
          {
            uint64_t v122 = bswap32(v55 | 0x4000) >> 16;
            v56 = 2LL;
          }
        }

        else
        {
          uint64_t v122 = v55;
          v56 = 1LL;
        }

        v75 = *(void *)type + v56 + v52;
        *os_log_type_t v20 = v75;
        if (!v75)
        {
          os_log_type_t v94 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v94, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          v126 = "strict_calloc";
          BOOL v95 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v95);
          if (result) {
            goto LABEL_318;
          }
          free(v95);
        }

        os_log_type_t v53 = (char *)calloc(1uLL, v75);
        if (v53)
        {
          if (v48) {
LABEL_142:
          }
            memcpy(v53, (const void *)v48, *(size_t *)type);
        }

        else
        {
          uint64_t v96 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v96, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          v126 = "strict_calloc";
          os_log_type_t v127 = 2048;
          v128 = 1LL;
          v129 = 2048;
          v130 = v75;
          uint64_t v97 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v97);
          if (result) {
            goto LABEL_318;
          }
          free(v97);
          if (v48) {
            goto LABEL_142;
          }
        }

        memcpy(&v53[*(void *)type], &v122, v56);
        if (__n) {
          memcpy(&v53[*(void *)type + v56], v51, __n);
        }
        if (!v22) {
          goto LABEL_148;
        }
        os_log_type_t v72 = v22;
        goto LABEL_147;
      }

      uint64_t v49 = a6;
      os_log_type_t v50 = nw_http_encrypt_chunked_oblivious_request_chunk( v16,  v15 + v21,  a6,  *(void *)(a1 + 112),  *(void *)(a1 + 120),  *(void *)(a1 + 96),  *(void *)(a1 + 104),  &__n);
      if (v50)
      {
        uint64_t v51 = (void *)v50;
        v52 = __n;
        goto LABEL_65;
      }

      if (v22) {
        free(v22);
      }
      if (v48) {
        free((void *)v48);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v41 = (os_log_s *)gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        return 0LL;
      }
      *(_DWORD *)buf = 136446210;
      v126 = "nw_http_create_oblivious_request";
      uint64_t v42 = "%{public}s Failed to fill out OHTTP chunk";
    }

    else
    {
      if (v22) {
        free(v22);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v41 = (os_log_s *)gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        return 0LL;
      }
      *(_DWORD *)buf = 136446210;
      v126 = "nw_http_create_oblivious_request";
      uint64_t v42 = "%{public}s Failed to fill out OHTTP header";
    }

  if (v29) {
    free(v29);
  }
LABEL_15:
}

    nw_endpoint_handler_reset_mode(v2, (v4 >> 3) & 1);
    goto LABEL_33;
  }

  __nwlog_obj();
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v45 = "nw_endpoint_handler_handle_failure";
  __int16 v25 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v42 = 0;
  if (__nwlog_fault(v25, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v29 = type;
      uint64_t v30 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v45 = "nw_endpoint_handler_handle_failure";
          int v46 = 2082;
          uint64_t v47 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v26,  v29,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_55;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_181A5C000, v26, v29, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl( &dword_181A5C000,  v26,  v39,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        goto LABEL_33;
      }

      if (!v31)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v30 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "tcp_connection_get_local";
          _os_log_impl( &dword_181A5C000,  v17,  v30,  "%{public}s called with null outlocal, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_32;
      }

      int v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v28 = type;
      unint64_t v29 = os_log_type_enabled(v17, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "tcp_connection_get_local";
          _os_log_impl(&dword_181A5C000, v17, v28, "%{public}s called with null outlocal, no backtrace", buf, 0xCu);
        }

        goto LABEL_32;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v34 = "tcp_connection_get_local";
        unint64_t v35 = 2082;
        uint64_t v36 = v27;
        _os_log_impl( &dword_181A5C000,  v17,  v28,  "%{public}s called with null outlocal, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v27);
    }

        goto LABEL_33;
      }

      if (!v31)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v30 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "tcp_connection_get_remote";
          _os_log_impl( &dword_181A5C000,  v17,  v30,  "%{public}s called with null outremote, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_32;
      }

      int v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v28 = type;
      unint64_t v29 = os_log_type_enabled(v17, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_181A5C000, v17, v28, "%{public}s called with null outremote, no backtrace", buf, 0xCu);
        }

        goto LABEL_32;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v34 = "tcp_connection_get_remote";
        unint64_t v35 = 2082;
        uint64_t v36 = v27;
        _os_log_impl( &dword_181A5C000,  v17,  v28,  "%{public}s called with null outremote, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v27);
    }

  if (v5) {
    free(v5);
  }
  return 1LL;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  free(v12);
  if (v4) {
LABEL_49:
  }
    free(v4);
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

        free(v11);
        goto LABEL_33;
      }

      nghttp2_session_callbacks_set_before_frame_send_callback();
      nghttp2_session_callbacks_set_on_header_callback();
      nghttp2_session_callbacks_set_on_begin_headers_callback();
      nghttp2_session_callbacks_set_on_frame_recv_callback();
      nghttp2_session_callbacks_set_on_data_chunk_recv_callback();
      nghttp2_session_callbacks_set_on_stream_close_callback();
      nghttp2_session_callbacks_set_on_frame_send_callback();
      nghttp2_session_callbacks_set_send_callback();
      nghttp2_session_callbacks_set_send_data_callback();
      nghttp2_session_callbacks_set_on_frame_not_send_callback();
      nghttp2_session_callbacks_set_on_invalid_frame_recv_callback();
      nghttp2_session_callbacks_set_error_callback2();
      nghttp2_set_debug_vprintf_callback();
      nghttp2_option_new();
      nghttp2_option_set_no_auto_window_update();
      nghttp2_option_set_peer_max_concurrent_streams();
      nghttp2_option_set_no_http_messaging();
      nghttp2_option_set_no_http_semantics();
      nghttp2_option_set_no_closed_streams();
      if ((v4[204] & 0x10) != 0)
      {
        if ((nghttp2_session_server_new2() & 0x80000000) != 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v29 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          uint64_t v49 = "nw_protocol_http2_transport_create";
          os_log_type_t v50 = 2082;
          uint64_t v51 = (uint64_t)(v4 + 205);
          v52 = 2082;
          os_log_type_t v53 = v29;
          uint64_t v11 = (char *)_os_log_send_and_compose_impl();
          int v46 = OS_LOG_TYPE_ERROR;
          uint64_t v44 = 0;
          if (v46 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v17 = (os_log_s *)gLogObj;
            uint64_t v18 = v46;
            if (!os_log_type_enabled((os_log_t)gLogObj, v46)) {
              goto LABEL_31;
            }
            goto LABEL_17;
          }

          if (v44)
          {
            uint64_t v30 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v17 = (os_log_s *)gLogObj;
            uint64_t v18 = v46;
            uint64_t v32 = os_log_type_enabled((os_log_t)gLogObj, v46);
            if (v30)
            {
              if (!v32) {
                goto LABEL_48;
              }
              goto LABEL_47;
            }

            if (!v32) {
              goto LABEL_31;
            }
LABEL_57:
            unint64_t v35 = nghttp2_strerror();
            *(_DWORD *)buf = 136446722;
            uint64_t v49 = "nw_protocol_http2_transport_create";
            os_log_type_t v50 = 2082;
            uint64_t v51 = (uint64_t)(v4 + 205);
            v52 = 2082;
            os_log_type_t v53 = v35;
            os_log_type_t v15 = "%{public}s %{public}s nghttp2_session_server_new2 failed: %{public}s, no backtrace";
            goto LABEL_58;
          }

          uint64_t v17 = (os_log_s *)__nwlog_obj();
          uint64_t v18 = v46;
          if (!os_log_type_enabled(v17, v46)) {
            goto LABEL_31;
          }
LABEL_51:
          os_log_type_t v34 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          uint64_t v49 = "nw_protocol_http2_transport_create";
          os_log_type_t v50 = 2082;
          uint64_t v51 = (uint64_t)(v4 + 205);
          v52 = 2082;
          os_log_type_t v53 = v34;
          os_log_type_t v15 = "%{public}s %{public}s nghttp2_session_server_new2 failed: %{public}s, backtrace limit exceeded";
          goto LABEL_58;
        }
      }

      else if ((nghttp2_session_client_new2() & 0x80000000) != 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        uint64_t v49 = "nw_protocol_http2_transport_create";
        os_log_type_t v50 = 2082;
        uint64_t v51 = (uint64_t)(v4 + 205);
        v52 = 2082;
        os_log_type_t v53 = v16;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl();
        int v46 = OS_LOG_TYPE_ERROR;
        uint64_t v44 = 0;
        if (v46 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = (os_log_s *)gLogObj;
          uint64_t v18 = v46;
          if (!os_log_type_enabled((os_log_t)gLogObj, v46)) {
            goto LABEL_31;
          }
LABEL_17:
          char v19 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          uint64_t v49 = "nw_protocol_http2_transport_create";
          os_log_type_t v50 = 2082;
          uint64_t v51 = (uint64_t)(v4 + 205);
          v52 = 2082;
          os_log_type_t v53 = v19;
          os_log_type_t v15 = "%{public}s %{public}s nghttp2_session_server_new2 failed: %{public}s";
LABEL_58:
          __int16 v25 = v17;
          int v26 = v18;
          int v27 = 32;
          goto LABEL_30;
        }

        if (v44)
        {
          uint64_t v30 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = (os_log_s *)gLogObj;
          uint64_t v18 = v46;
          os_log_type_t v31 = os_log_type_enabled((os_log_t)gLogObj, v46);
          if (v30)
          {
            if (!v31) {
              goto LABEL_48;
            }
LABEL_47:
            v33 = nghttp2_strerror();
            *(_DWORD *)buf = 136446978;
            uint64_t v49 = "nw_protocol_http2_transport_create";
            os_log_type_t v50 = 2082;
            uint64_t v51 = (uint64_t)(v4 + 205);
            v52 = 2082;
            os_log_type_t v53 = v33;
            v54 = 2082;
            v55 = v30;
            _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s %{public}s nghttp2_session_server_new2 failed: %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
LABEL_48:
            free(v30);
            if (!v11) {
              goto LABEL_33;
            }
            goto LABEL_32;
          }

          if (!v31) {
            goto LABEL_31;
          }
          goto LABEL_57;
        }

        uint64_t v17 = (os_log_s *)__nwlog_obj();
        uint64_t v18 = v46;
        if (!os_log_type_enabled(v17, v46)) {
          goto LABEL_31;
        }
        goto LABEL_51;
      }

      MEMORY[0x186E10E0C](__memptr);
      MEMORY[0x186E10DA0](*(void *)type);
      return (BOOL)v4;
    }
  }

  v37 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v49 = "strict_memalign";
  os_log_type_t v50 = 2048;
  uint64_t v51 = 8LL;
  v52 = 2048;
  os_log_type_t v53 = 296LL;
  v38 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v38);
  if (!result)
  {
    free(v38);
    int v4 = __memptr;
    if (__memptr) {
      goto LABEL_4;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    uint64_t v49 = "nw_protocol_http2_transport_create";
    os_log_type_t v50 = 2048;
    uint64_t v51 = 296LL;
    int v4 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(__memptr) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v4, &__memptr, type))
    {
      if (__memptr == 17)
      {
        os_log_type_t v39 = (os_log_s *)__nwlog_obj();
        BOOL v40 = __memptr;
        if (!os_log_type_enabled(v39, (os_log_type_t)__memptr)) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v49 = "nw_protocol_http2_transport_create";
        os_log_type_t v50 = 2048;
        uint64_t v51 = 296LL;
        uint64_t v41 = "%{public}s calloc(%zu) failed";
LABEL_76:
        _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0x16u);
        goto LABEL_77;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v39 = (os_log_s *)__nwlog_obj();
        BOOL v40 = __memptr;
        if (!os_log_type_enabled(v39, (os_log_type_t)__memptr)) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v49 = "nw_protocol_http2_transport_create";
        os_log_type_t v50 = 2048;
        uint64_t v51 = 296LL;
        uint64_t v41 = "%{public}s calloc(%zu) failed, backtrace limit exceeded";
        goto LABEL_76;
      }

      uint64_t v42 = (char *)__nw_create_backtrace_string();
      os_log_type_t v39 = (os_log_s *)__nwlog_obj();
      BOOL v40 = __memptr;
      os_log_type_t v43 = os_log_type_enabled(v39, (os_log_type_t)__memptr);
      if (!v42)
      {
        if (!v43) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v49 = "nw_protocol_http2_transport_create";
        os_log_type_t v50 = 2048;
        uint64_t v51 = 296LL;
        uint64_t v41 = "%{public}s calloc(%zu) failed, no backtrace";
        goto LABEL_76;
      }

      if (v43)
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v49 = "nw_protocol_http2_transport_create";
        os_log_type_t v50 = 2048;
        uint64_t v51 = 296LL;
        v52 = 2082;
        os_log_type_t v53 = (uint64_t)v42;
        _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s calloc(%zu) failed, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v42);
    }

  if (v13) {
    free(v13);
  }
}

      free(backtrace_string);
    }
  }

  if (v2) {
LABEL_33:
  }
    free(v2);
  return 0xFFFFFFFFLL;
}

  if (v7) {
    free(v7);
  }
  return 0xFFFFFFFFLL;
}

  if (v3) {
    free(v3);
  }
  return 0xFFFFFFFFLL;
}

  if (v2) {
LABEL_33:
  }
    free(v2);
  return 0xFFFFFFFFLL;
}

  if (v8) {
LABEL_33:
  }
    free(v8);
  return 0LL;
}

  if (v8) {
LABEL_33:
  }
    free(v8);
  return 0LL;
}

  if (v2) {
LABEL_33:
  }
    free(v2);
  return 0LL;
}

        uint64_t v13 = 1;
        BOOL v16 = 5;
        int v21 = *(void **)(v8 + 224);
        if (v21)
        {
LABEL_22:
          is_equal |= nw_endpoint_is_equal(v21, *(void **)(a1 + 32), 0LL);
          uint64_t v22 = *(void **)(v8 + 232);
          if (v22) {
            goto LABEL_23;
          }
          goto LABEL_34;
        }

LABEL_33:
      if (v5) {
        free(v5);
      }
      return 0LL;
    }

    if (!v14)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_endpoint_create_host";
        unsigned int v8 = "%{public}s called with null hostname, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v7 = type;
    uint64_t v11 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_endpoint_create_host";
        unsigned int v8 = "%{public}s called with null hostname, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_endpoint_create_host";
      uint64_t v18 = 2082;
      char v19 = backtrace_string;
      BOOL v12 = "%{public}s called with null hostname, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v6, v7, v12, buf, 0x16u);
    }

  if (v5) {
    free(v5);
  }
  return 0LL;
}

LABEL_33:
      if (v8) {
        free(v8);
      }
      goto LABEL_35;
    }

    if (!v18)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        int v21 = "-[NWNetworkAgentRegistration addToken:]";
        uint64_t v11 = "%{public}s called with null token, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v10 = type;
    char v14 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        int v21 = "-[NWNetworkAgentRegistration addToken:]";
        uint64_t v11 = "%{public}s called with null token, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      int v21 = "-[NWNetworkAgentRegistration addToken:]";
      uint64_t v22 = 2082;
      __int16 v23 = backtrace_string;
      os_log_type_t v15 = "%{public}s called with null token, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v9, v10, v15, buf, 0x16u);
    }

  if (v24) {
    free(v24);
  }
  int v21 = 0LL;
LABEL_16:

  return v21;
}

  if (v10) {
    free(v10);
  }
LABEL_46:
}
  }

          fixFilePermissions(v10);
          uint64_t v11 = 0LL;
LABEL_33:

          goto LABEL_34;
        }
  }
  }
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    _Block_object_dispose(&v31, 8);
    _Block_object_dispose(&v35, 8);
  }
}

  __break(1u);
  return result;
}

    free(backtrace_string);
    goto LABEL_45;
  }

  if ((*((_BYTE *)v5 + 36) & 1) == 0)
  {
    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_txt_record_access_key";
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s txt_record is not of type dictionary",  buf,  0xCu);
    }

    goto LABEL_19;
  }

  if ((nw_txt_record_key_is_valid((uint64_t)key) & 1) == 0)
  {
    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_txt_record_access_key";
      _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, "%{public}s invalid key", buf, 0xCu);
    }

  __break(1u);
  return result;
}

  if (v4) {
LABEL_33:
  }
    free(v4);
  return 0LL;
}

  if (v4) {
LABEL_33:
  }
    free(v4);
  return 0LL;
}

LABEL_45:
        if (!v22) {
          goto LABEL_19;
        }
LABEL_46:
        free(v22);
        goto LABEL_19;
      }

      __int16 v25 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v26 = (os_log_s *)(id)gLogObj;
      int v27 = type;
      uint64_t v28 = os_log_type_enabled(v26, type);
      if (!v25)
      {
        if (v28)
        {
          *(_DWORD *)v71 = 136446466;
          os_log_type_t v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          v73 = 1024;
          LODWORD(v74[0]) = v19;
          _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s if_indextoname %{darwin.errno}d, no backtrace",  v71,  0x12u);
        }

        goto LABEL_45;
      }

      if (v28)
      {
        *(_DWORD *)v71 = 136446722;
        os_log_type_t v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
        v73 = 1024;
        LODWORD(v74[0]) = v19;
        WORD2(v74[0]) = 2082;
        *(void *)((char *)v74 + 6) = v25;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s if_indextoname %{darwin.errno}d, dumping backtrace:%{public}s",  v71,  0x1Cu);
      }

      free(v25);
      if (v22) {
        goto LABEL_46;
      }
    }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

        if (v21) {
          free(v21);
        }
        uint64_t v3 = v20;
        BOOL v16 = v18;
        if (!v18) {
          goto LABEL_35;
        }
      }
    }

    if (v268) {
      break;
    }
    unint64_t v35 = (void *)*((void *)v272 + 5);
    if (!v35) {
      goto LABEL_59;
    }
    do
    {
      while (1)
      {
        uint64_t v36 = (void (*)(void *, uint64_t, uint64_t))v35[10];
        v37 = (void *)v35[4];
        if (!v36) {
          break;
        }
        v38 = v35[11];
        v35[10] = 0LL;
        v35[11] = 0LL;
        v36(v35, 1LL, v38);
        unint64_t v35 = v37;
        if (!v37) {
          goto LABEL_58;
        }
      }

      os_log_type_t v39 = v3;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      BOOL v40 = (char *)_os_log_send_and_compose_impl();
      v279[0] = 16;
      LOBYTE(error) = 0;
      if (__nwlog_fault(v40, v279, &error))
      {
        if (v279[0] == 17)
        {
          uint64_t v41 = (os_log_s *)__nwlog_obj();
          uint64_t v42 = v279[0];
          if (!os_log_type_enabled(v41, (os_log_type_t)v279[0])) {
            goto LABEL_55;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          os_log_type_t v43 = v41;
          uint64_t v44 = v42;
          uint64_t v45 = "%{public}s called with null frame->finalizer";
LABEL_54:
          _os_log_impl(&dword_181A5C000, v43, v44, v45, buf, 0xCu);
          goto LABEL_55;
        }

        if (!(_BYTE)error)
        {
          os_log_type_t v50 = (os_log_s *)__nwlog_obj();
          uint64_t v51 = v279[0];
          if (!os_log_type_enabled(v50, (os_log_type_t)v279[0])) {
            goto LABEL_55;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          os_log_type_t v43 = v50;
          uint64_t v44 = v51;
          uint64_t v45 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_54;
        }

        int v46 = (char *)__nw_create_backtrace_string();
        uint64_t v47 = (os_log_s *)__nwlog_obj();
        v48 = v279[0];
        uint64_t v49 = os_log_type_enabled(v47, (os_log_type_t)v279[0]);
        if (!v46)
        {
          if (!v49) {
            goto LABEL_55;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          os_log_type_t v43 = v47;
          uint64_t v44 = v48;
          uint64_t v45 = "%{public}s called with null frame->finalizer, no backtrace";
          goto LABEL_54;
        }

        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v46;
          _os_log_impl( &dword_181A5C000,  v47,  v48,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v46);
      }

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(a1[6] + 1200LL), &offset);
  int v4 = *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
  uint64_t v5 = *(dispatch_object_s **)(a1[6] + 1200LL);
  uint64_t v6 = offset < v4;
  if (offset < v4)
  {
    *(void *)(a1[6] + 1200LL) = dispatch_data_create_subrange( *(dispatch_data_t *)(a1[6] + 1200LL),  offset,  0xFFFFFFFFFFFFFFFFLL);
    if (v5) {
      dispatch_release(v5);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(a1[6] + 1200LL));
    *(void *)(a1[6] + 1200LL) = 0LL;
  }

  if (**(void **)(*(void *)(*(void *)(a1[5] + 8LL) + 48LL) + 8LL) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_http3_encoder_stream_process_output_block_invoke";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    os_log_type_t v20 = 0;
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_encoder_stream_process_output_block_invoke";
      char v14 = "%{public}s Too much space for sdtc";
    }

    else if (v20)
    {
      uint64_t v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      uint64_t v18 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
      if (v17)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v24 = "nw_http3_encoder_stream_process_output_block_invoke";
          __int16 v25 = 2082;
          int v26 = v17;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s Too much space for sdtc, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_41;
      }

      if (!v18)
      {
LABEL_41:
        if (v11) {
          free(v11);
        }
        return v6;
      }

      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_encoder_stream_process_output_block_invoke";
      char v14 = "%{public}s Too much space for sdtc, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_encoder_stream_process_output_block_invoke";
      char v14 = "%{public}s Too much space for sdtc, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_41;
  }

  return v6;
}

          uint64_t v9 = v299;
          uint64_t v36 = *(void *)(*(void *)(v299[6] + 8LL) + 24LL);
          if (v36 < *(void *)(*(void *)(v299[5] + 8LL) + 24LL) + *(void *)(*(void *)(v299[4] + 8LL) + 24LL))
          {
            v37 = *(dispatch_data_s **)(*(void *)(v299[13] + 8LL) + 24LL);
            *(void *)(*(void *)(v299[13] + 8LL) + 24LL) = dispatch_data_create_subrange(v37, 0LL, v36);
            if (v37) {
              dispatch_release(v37);
            }
          }

          *(void *)(*(void *)(v299[5] + 8LL) + 24LL) += 512LL;
          alloc = (dispatch_data_s *)dispatch_data_create_alloc();
          os_log_type_t v39 = *(dispatch_data_s **)(*(void *)(v299[13] + 8LL) + 24LL);
          *(void *)(*(void *)(v299[13] + 8LL) + 24LL) = dispatch_data_create_concat(v39, alloc);
          if (v39) {
            dispatch_release(v39);
          }
          BOOL v40 = v289;
          uint64_t v41 = v290;
          if (alloc) {
            goto LABEL_27;
          }
          goto LABEL_28;
        }

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(a1[6] + 528LL), &offset);
  int v4 = *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
  uint64_t v5 = *(dispatch_object_s **)(a1[6] + 528LL);
  uint64_t v6 = offset < v4;
  if (offset < v4)
  {
    *(void *)(a1[6] + 528LL) = dispatch_data_create_subrange( *(dispatch_data_t *)(a1[6] + 528LL),  offset,  0xFFFFFFFFFFFFFFFFLL);
    if (v5) {
      dispatch_release(v5);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(a1[6] + 528LL));
    *(void *)(a1[6] + 528LL) = 0LL;
  }

  if (**(void **)(*(void *)(*(void *)(a1[5] + 8LL) + 48LL) + 8LL) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    os_log_type_t v20 = 0;
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
      char v14 = "%{public}s Too much space on encoder stream";
    }

    else if (v20)
    {
      uint64_t v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      uint64_t v18 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
      if (v17)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
          __int16 v25 = 2082;
          int v26 = v17;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s Too much space on encoder stream, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_41;
      }

      if (!v18)
      {
LABEL_41:
        if (v11) {
          free(v11);
        }
        return v6;
      }

      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
      char v14 = "%{public}s Too much space on encoder stream, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
      char v14 = "%{public}s Too much space on encoder stream, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_41;
  }

  return v6;
}

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(a1[6] + 520LL), &offset);
  int v4 = *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
  uint64_t v5 = *(dispatch_object_s **)(a1[6] + 520LL);
  uint64_t v6 = offset < v4;
  if (offset < v4)
  {
    *(void *)(a1[6] + 520LL) = dispatch_data_create_subrange( *(dispatch_data_t *)(a1[6] + 520LL),  offset,  0xFFFFFFFFFFFFFFFFLL);
    if (v5) {
      dispatch_release(v5);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(a1[6] + 520LL));
    *(void *)(a1[6] + 520LL) = 0LL;
  }

  if (**(void **)(*(void *)(*(void *)(a1[5] + 8LL) + 48LL) + 8LL) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    os_log_type_t v20 = 0;
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
      char v14 = "%{public}s Too much space in fields frame";
    }

    else if (v20)
    {
      uint64_t v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      uint64_t v18 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
      if (v17)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
          __int16 v25 = 2082;
          int v26 = v17;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s Too much space in fields frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_41;
      }

      if (!v18)
      {
LABEL_41:
        if (v11) {
          free(v11);
        }
        return v6;
      }

      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
      char v14 = "%{public}s Too much space in fields frame, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_http3_stream_send_fields_block_invoke";
      char v14 = "%{public}s Too much space in fields frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_41;
  }

  return v6;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    free(backtrace_string);
    if (!v14) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }

  if (!v6)
  {
    __nwlog_obj();
    char v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
    char v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
        _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v37)
    {
      int v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v27 = type;
      uint64_t v28 = os_log_type_enabled(v15, type);
      if (v26)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interpose_flow_get_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v26;
          _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null flow, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v26);
LABEL_57:
        if (!v14)
        {
LABEL_59:

          goto LABEL_60;
        }

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v3) {
LABEL_33:
  }
    free(v3);
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v1) {
LABEL_33:
  }
    free(v1);
}

      if ((*v2 & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v16 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_handle_socket_event";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v1 + 308;
          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Socket received TIMEOUT event",  buf,  0x16u);
        }
      }

      if (_nw_signposts_once == -1)
      {
        if (!_nw_signposts_enabled) {
          goto LABEL_41;
        }
      }

      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
        if (!_nw_signposts_enabled) {
          goto LABEL_41;
        }
      }

    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "__nw_frame_get_ecn_flag";
    int v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v146) = 16;
    LOBYTE(v143) = 0;
    if (v146 == 17)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      unint64_t v29 = v146;
      if (!os_log_type_enabled(v28, (os_log_type_t)v146)) {
        goto LABEL_213;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "__nw_frame_get_ecn_flag";
      uint64_t v30 = "%{public}s called with null frame";
    }

    else if ((_BYTE)v143)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      unint64_t v29 = v146;
      v108 = os_log_type_enabled(v28, (os_log_type_t)v146);
      if (backtrace_string)
      {
        if (v108)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "__nw_frame_get_ecn_flag";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null frame, dumping backtrace:%{public}s",  applier,  0x16u);
        }

        free(backtrace_string);
LABEL_213:
        if (v27) {
          free(v27);
        }
        __nwlog_obj();
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "__nw_frame_get_dscp_value";
        BOOL v121 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v146) = 16;
        LOBYTE(v143) = 0;
        if (v146 == 17)
        {
          uint64_t v122 = (os_log_s *)__nwlog_obj();
          uint64_t v123 = v146;
          if (os_log_type_enabled(v122, (os_log_type_t)v146))
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "__nw_frame_get_dscp_value";
            uint64_t v124 = "%{public}s called with null frame";
LABEL_233:
            _os_log_impl(&dword_181A5C000, v122, v123, v124, applier, 0xCu);
          }
        }

        else if ((_BYTE)v143)
        {
          uint64_t v125 = (char *)__nw_create_backtrace_string();
          uint64_t v122 = (os_log_s *)__nwlog_obj();
          uint64_t v123 = v146;
          v126 = os_log_type_enabled(v122, (os_log_type_t)v146);
          if (v125)
          {
            if (v126)
            {
              *(_DWORD *)applier = 136446466;
              *(void *)&applier[4] = "__nw_frame_get_dscp_value";
              *(_WORD *)&applier[12] = 2082;
              *(void *)&applier[14] = v125;
              _os_log_impl( &dword_181A5C000,  v122,  v123,  "%{public}s called with null frame, dumping backtrace:%{public}s",  applier,  0x16u);
            }

            free(v125);
            goto LABEL_234;
          }

          if (v126)
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "__nw_frame_get_dscp_value";
            uint64_t v124 = "%{public}s called with null frame, no backtrace";
            goto LABEL_233;
          }
        }

        else
        {
          uint64_t v122 = (os_log_s *)__nwlog_obj();
          uint64_t v123 = v146;
          if (os_log_type_enabled(v122, (os_log_type_t)v146))
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "__nw_frame_get_dscp_value";
            uint64_t v124 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_233;
          }
        }

  if (v8) {
LABEL_33:
  }
    free(v8);
  return 0LL;
}
}

    if (v9) {
LABEL_33:
    }
      free(v9);
LABEL_34:
    char v19 = 0LL;
    goto LABEL_35;
  }

  if (!v6 || object_getClass(v6) != (Class)MEMORY[0x1895F9250])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(applier[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v11 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null netagent_dict", buf, 0xCu);
      }
    }

    else if (LOBYTE(applier[0]))
    {
      BOOL v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v13 = type[0];
      char v14 = os_log_type_enabled(v10, type[0]);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v12;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null netagent_dict, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v12);
        if (!v9) {
          goto LABEL_34;
        }
        goto LABEL_33;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null netagent_dict, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      int v21 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s called with null netagent_dict, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_31;
  }

  *(void *)buf = 0LL;
  data = xpc_dictionary_get_data(v7, "data", (size_t *)buf);
  if (!data || *(void *)buf < 0xD8uLL || (BOOL v16 = data, *(void *)buf != *((unsigned int *)data + 53) + 216LL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v20 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to get agent from dictionary",  buf,  0xCu);
    }

    goto LABEL_34;
  }

  if ((data[208] & 1) == 0) {
    goto LABEL_34;
  }
  uint64_t v45 = 0LL;
  int v46 = &v45;
  uint64_t v47 = 0x2020000000LL;
  v48 = 0;
  uint64_t v17 = nw_parameters_copy_required_netagent_uuids(v5[2]);
  uint64_t v18 = v17;
  if (v17)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke;
    applier[3] = &unk_189BC5538;
    applier[4] = &v45;
    applier[5] = v16;
    xpc_array_apply(v17, applier);
  }

  if (*((_BYTE *)v46 + 24))
  {
    char v19 = 1LL;
  }

  else
  {
    __int16 v23 = nw_parameters_copy_required_netagent_domains(v5[2]);
    uint64_t v24 = nw_parameters_copy_required_netagent_types(v5[2]);
    __int16 v25 = v24;
    if (v23)
    {
      if (v24)
      {
        count = xpc_array_get_count(v23);
        if (count == xpc_array_get_count(v25))
        {
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke_2;
          os_log_type_t v50 = &unk_189BC5560;
          uint64_t v51 = v25;
          v52 = &v45;
          os_log_type_t v53 = v16;
          xpc_array_apply(v23, buf);
        }
      }
    }

    if (*((_BYTE *)v46 + 24))
    {
      char v19 = 1LL;
    }

    else
    {
      int v27 = nw_parameters_copy_preferred_netagent_domains(v5[2]);
      uint64_t v28 = nw_parameters_copy_preferred_netagent_types(v5[2]);
      unint64_t v29 = v28;
      if (v27)
      {
        if (v28)
        {
          uint64_t v30 = xpc_array_get_count(v27);
          if (v30 == xpc_array_get_count(v29))
          {
            *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
            v38 = 3221225472LL;
            os_log_type_t v39 = ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke_3;
            BOOL v40 = &unk_189BC5560;
            uint64_t v41 = v29;
            uint64_t v42 = &v45;
            os_log_type_t v43 = v16;
            xpc_array_apply(v27, type);
          }
        }
      }

      char v19 = *((_BYTE *)v46 + 24) != 0;
    }
  }

  _Block_object_dispose(&v45, 8);
LABEL_35:

  return v19;
}

    if (v15) {
      free(v15);
    }
    goto LABEL_13;
  }

  v48 = 0uLL;
  v41[0] = 0LL;
  v41[1] = v41;
  v41[2] = 0x2020000000LL;
  v41[3] = &v48;
  unint64_t v35 = 0LL;
  uint64_t v36 = &v35;
  v37 = 0x3032000000LL;
  v38 = __Block_byref_object_copy__67543;
  os_log_type_t v39 = __Block_byref_object_dispose__67544;
  BOOL v40 = 0LL;
  os_unfair_lock_lock(v1 + 12);
  uint64_t v3 = *(void **)&v2[8]._os_unfair_lock_opaque;
  int v4 = MEMORY[0x1895F87A8];
  *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
  unint64_t v29 = 3221225472LL;
  uint64_t v30 = ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke;
  os_log_type_t v31 = &unk_189BC5498;
  uint64_t v5 = v2;
  uint64_t v32 = v5;
  v33 = &v35;
  os_log_type_t v34 = v41;
  fd = nw_fd_wrapper_get_fd(v3, type);
  uint64_t v7 = (void (**)(void *, __int128 *, void))_Block_copy(*(const void **)&v5[4]._os_unfair_lock_opaque);
  unsigned int v8 = (dispatch_queue_s *)*(id *)&v5[2]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2 + 12);
  if (v7) {
    uint64_t v9 = fd;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v9 != 1) {
    goto LABEL_12;
  }
  if (!v8)
  {
    BOOL v12 = v5;
    os_unfair_lock_lock(v2 + 12);
    uint64_t v13 = *(void *)&v5[4]._os_unfair_lock_opaque == 0LL;
    os_unfair_lock_unlock(v2 + 12);

    if (!v13) {
      v7[2](v7, &v48, v36[5]);
    }
    goto LABEL_12;
  }

  uint64_t v24 = 0LL;
  __int16 v25 = &v24;
  int v26 = 0x2020000000LL;
  os_log_type_t v10 = malloc(0x10uLL);
  if (v10)
  {
    uint64_t v11 = &v24;
LABEL_9:
    int v27 = v10;
    *(_OWORD *)v11[3] = v48;
    *(void *)block = v4;
    *(void *)&block[8] = 3221225472LL;
    *(void *)&block[16] = ___ZL23nw_path_observer_updateP27NWConcrete_nw_path_observer_block_invoke_420;
    os_log_type_t v43 = &unk_189BC54C0;
    uint64_t v44 = v5;
    uint64_t v45 = v7;
    int v46 = &v24;
    uint64_t v47 = &v35;
    dispatch_async(v8, block);

    _Block_object_dispose(&v24, 8);
LABEL_12:

    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(v41, 8);
LABEL_13:

    return;
  }

  __nwlog_obj();
  int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)block = 136446466;
  *(void *)&block[4] = "strict_malloc";
  *(_WORD *)&block[12] = 2048;
  *(void *)&block[14] = 16LL;
  uint64_t v22 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v22))
  {
    free(v22);
    uint64_t v11 = v25;
    goto LABEL_9;
  }

  __break(1u);
}

  if (v12) {
    free(v12);
  }
LABEL_15:
}

  if (v13) {
    free(v13);
  }
  int v4 = 0LL;
LABEL_15:

  return v4;
}

    if (v7) {
LABEL_33:
    }
      free(v7);
LABEL_34:
    char v19 = 0LL;
    goto LABEL_35;
  }

  *a3 = v39;
  char v19 = 1LL;
LABEL_35:

  return v19;
}

    if (v7) {
LABEL_33:
    }
      free(v7);
LABEL_34:
    BOOL v12 = 0LL;
    goto LABEL_35;
  }

  __nwlog_obj();
  v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v45 = "strict_calloc";
  int v46 = 2048;
  *(void *)uint64_t v47 = 1LL;
  *(_WORD *)&v47[8] = 2048;
  *(void *)&v47[10] = 4096LL;
  v38 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v38);
  if (!result)
  {
    free(v38);
    goto LABEL_11;
  }

  __break(1u);
  return result;
}

        goto LABEL_33;
      }

      if (!v34)
      {
        __nwlog_obj();
        BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_copy_resolver_config_for_identifier";
          _os_log_impl( &dword_181A5C000,  v12,  v32,  "%{public}s called with null is_config_agent_type_dns(agent), backtrace limit exceeded",  length,  0xCu);
        }

        goto LABEL_32;
      }

      int v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v27 = type;
      uint64_t v28 = os_log_type_enabled(v12, type);
      if (!v26)
      {
        if (v28)
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_copy_resolver_config_for_identifier";
          _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null is_config_agent_type_dns(agent), no backtrace",  length,  0xCu);
        }

        goto LABEL_32;
      }

      if (v28)
      {
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "nw_path_copy_resolver_config_for_identifier";
        v37 = 2082;
        *(void *)v38 = v26;
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null is_config_agent_type_dns(agent), dumping backtrace:%{public}s",  length,  0x16u);
      }

      free(v26);
    }

    if (v9) {
      free(v9);
    }
    uint64_t v5 = 0LL;
    goto LABEL_15;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  os_log_type_t v20 = 0;
  if ((v1[5] || v1[6]) && *((_DWORD *)v1 + 86))
  {
    uint64_t v3 = 0LL;
    int v4 = 8LL;
    do
    {
      if (!uuid_is_null((const unsigned __int8 *)(v2[38] + v4)))
      {
        uint64_t v5 = 1LL;
        *(_BYTE *)(*(void *)&buf[8] + 24LL) = 1;
        goto LABEL_14;
      }

      ++v3;
      v4 += 24LL;
    }

    while (v3 < *((unsigned int *)v2 + 86));
    if (!*(_BYTE *)(*(void *)&buf[8] + 24LL)) {
      goto LABEL_10;
    }
    uint64_t v5 = 1LL;
  }

  else
  {
LABEL_10:
    uint64_t v6 = (void *)v2[28];
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_path_supports_browse_block_invoke;
      applier[3] = &unk_189BC71C0;
      applier[4] = buf;
      xpc_dictionary_apply(v6, applier);
      uint64_t v5 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    }

    else
    {
      uint64_t v5 = 0LL;
    }
  }

    if (!v13)
    {
LABEL_34:
      BOOL v16 = 0LL;
      a1 = v57;
      goto LABEL_35;
    }

  if (v11) {
    free(v11);
  }
  unsigned int v8 = 0LL;
LABEL_5:

  return v8;
}

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http1_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http1_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http1_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_messaging_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_messaging_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_messaging_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v21)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_deserialize_options";
          os_log_type_t v15 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v14 = type;
      uint64_t v18 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_deserialize_options";
          os_log_type_t v15 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v18) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_deserialize_options";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      char v19 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http2_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http2_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http2_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_cookie_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_cookie_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_cookie_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_alt_svc_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_alt_svc_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_alt_svc_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_authentication_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_authentication_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_authentication_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_encoding_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_encoding_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_encoding_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_redirect_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_redirect_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_redirect_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_retry_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_retry_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_retry_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_security_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_security_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_security_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_early_data_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_early_data_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_early_data_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_sniffing_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_sniffing_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_sniffing_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

        goto LABEL_33;
      }

      if (!v19)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_client_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_http_client_deserialize_options";
          uint64_t v13 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_32;
      }

      if (!v16) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_http_client_deserialize_options";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      uint64_t v17 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
  }

  if (v11) {
    free(v11);
  }
LABEL_5:
}

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_33;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http_messaging_get_parameters";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_messaging_get_parameters";
      uint64_t v6 = "%{public}s called with null http_messaging";
      goto LABEL_32;
    }

    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_messaging_get_parameters";
      uint64_t v6 = "%{public}s called with null http_messaging, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v9 = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    os_log_type_t v10 = os_log_type_enabled(v4, type);
    if (!v9)
    {
      if (!v10) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_http_messaging_get_parameters";
      uint64_t v6 = "%{public}s called with null http_messaging, no backtrace";
      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_http_messaging_get_parameters";
      os_log_type_t v15 = 2082;
      BOOL v16 = v9;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null http_messaging, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v9);
LABEL_33:
    if (!v3) {
      return 0LL;
    }
LABEL_34:
    free(v3);
    return 0LL;
  }

  BOOL result = handle[12];
  if (!result) {
    return nw_protocol_get_parameters(handle[6]);
  }
  return result;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

    v93 = 0uLL;
    v91 = 0;
    nw_channel_get_nexus_instance(*(void *)(v16 + 80), &v93, &v91);
    os_log_type_t v90 = 0;
    key = nw_channel_get_key(*(void *)(*(void *)(a1 + 56) + 80LL), &v90);
    uint64_t v84 = (const void *)key;
    if (v17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v29 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_38;
      }
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      WORD2(buf[1]) = 1040;
      *(_DWORD *)((char *)&buf[1] + 6) = 16;
      WORD1(buf[2]) = 2096;
      *(void *)((char *)&buf[2] + 4) = &v93;
      WORD2(buf[3]) = 2080;
      *(void *)((char *)&buf[3] + 6) = __str;
      uint64_t v30 = "%{public}s Reusing channel on nexus %{uuid_t}.16P for %s";
    }

    else
    {
      nw_nexus_bind_client_port(*(void *)(*(void *)(a1 + 40) + 248LL), (uint64_t)&v93, 0LL, 0LL, key, v90);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v29 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_38;
      }
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      WORD2(buf[1]) = 1040;
      *(_DWORD *)((char *)&buf[1] + 6) = 16;
      WORD1(buf[2]) = 2096;
      *(void *)((char *)&buf[2] + 4) = &v93;
      WORD2(buf[3]) = 2080;
      *(void *)((char *)&buf[3] + 6) = __str;
      uint64_t v30 = "%{public}s Creating channel on nexus %{uuid_t}.16P for %s";
    }

    _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_DEBUG, v30, (uint8_t *)buf, 0x26u);
LABEL_38:

    os_log_type_t v87 = nw_framer_options_copy_peer_protocol_definition(*(void **)(a1 + 64));
    os_log_type_t v31 = *(void **)(a1 + 32);
    v33 = *(void **)(a1 + 48);
    uint64_t v32 = *(void **)(a1 + 56);
    os_log_type_t v34 = *(void **)(a1 + 64);
    unint64_t v35 = *(id *)(a1 + 40);
    uint64_t v36 = v32;
    v85 = v31;
    uint64_t v86 = v33;
    v37 = v34;
    v38 = v37;
    if (v35)
    {
      if (!v36)
      {
        __nwlog_obj();
        os_log_type_t v57 = (void *)objc_claimAutoreleasedReturnValue();
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
        os_log_type_t v50 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v92 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v58 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_181A5C000, v51, v58, "%{public}s called with null client", (uint8_t *)buf, 0xCu);
          }

          goto LABEL_142;
        }

        if (v92 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v81 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl( &dword_181A5C000,  v51,  v81,  "%{public}s called with null client, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
          }

          goto LABEL_142;
        }

        v67 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v68 = type[0];
        os_log_type_t v69 = os_log_type_enabled(v51, type[0]);
        if (!v67)
        {
          if (v69)
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl( &dword_181A5C000,  v51,  v68,  "%{public}s called with null client, no backtrace",  (uint8_t *)buf,  0xCu);
          }

          goto LABEL_142;
        }

        if (v69)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v67;
          _os_log_impl( &dword_181A5C000,  v51,  v68,  "%{public}s called with null client, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
        }

        goto LABEL_96;
      }

      if (v37)
      {
        os_log_type_t v39 = nw_parameters_copy_context(v36[5]);
        buf[0] = MEMORY[0x1895F87A8];
        buf[1] = 3221225472LL;
        buf[2] = ___ZL31nw_agent_client_attach_protocolP19NWConcrete_nw_agentP26NWConcrete_nw_agent_clientPU25objcproto14OS_nw_endpoint8NSObjectS5_PU33objcproto22OS_nw_protocol_optionsS3__block_invoke;
        buf[3] = &unk_189BC77D0;
        uint8_t buf[4] = v35;
        uint64_t v100 = v36;
        v101 = v38;
        unint64_t v102 = v85;
        v103 = v86;
        nw_queue_context_async(v39, buf);

        goto LABEL_42;
      }

      __nwlog_obj();
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
      os_log_type_t v50 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v92 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v50, type, &v92))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v60 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_181A5C000, v51, v60, "%{public}s called with null options", (uint8_t *)buf, 0xCu);
          }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    if (v16) {
      free(v16);
    }
    return 0LL;
  }

  uint64_t v3 = calloc(1uLL, 0x30uLL);
  if (v3) {
    goto LABEL_3;
  }
  os_log_type_t v20 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  int v27 = "strict_calloc";
  uint64_t v28 = 2048;
  unint64_t v29 = 1LL;
  uint64_t v30 = 2048;
  os_log_type_t v31 = 48LL;
  int v21 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
LABEL_3:
    v3[1] = 0u;
    v3[2] = 0u;
    *uint64_t v3 = 0u;
    *(void *)uint64_t v3 = *a2;
    int v4 = (const void *)a2[1];
    if (v4)
    {
      uint64_t v5 = _Block_copy(v4);
      uint64_t v6 = *((_BYTE *)v3 + 16);
      if ((v6 & 1) != 0)
      {
        uint64_t v7 = (const void *)*((void *)v3 + 1);
        if (v7)
        {
          _Block_release(v7);
          uint64_t v6 = *((_BYTE *)v3 + 16);
        }
      }
    }

    else
    {
      uint64_t v5 = 0LL;
      uint64_t v6 = 0;
    }

    *((void *)v3 + 1) = v5;
    *((_BYTE *)v3 + 16) = v6 | 1;
    unsigned int v8 = (const void *)a2[3];
    if (v8)
    {
      uint64_t v9 = _Block_copy(v8);
      os_log_type_t v10 = *((_BYTE *)v3 + 32);
      if ((v10 & 1) == 0) {
        goto LABEL_14;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
      os_log_type_t v10 = *((_BYTE *)v3 + 32);
      if ((v10 & 1) == 0)
      {
LABEL_14:
        *((void *)v3 + 3) = v9;
        *((_BYTE *)v3 + 32) = v10 | 1;
        *((_DWORD *)v3 + 10) = *((_DWORD *)a2 + 10);
        BOOL v12 = *((_BYTE *)v3 + 44) & 0xFE | *((_BYTE *)a2 + 44) & 1;
        *((_BYTE *)v3 + 44) = v12;
        uint64_t v13 = v12 & 0xFFFFFFFD | (2 * ((*((unsigned __int8 *)a2 + 44) >> 1) & 1));
        *((_BYTE *)v3 + 44) = v13;
        char v14 = v13 & 0xFFFFFFFB | (4 * ((*((unsigned __int8 *)a2 + 44) >> 2) & 1));
        *((_BYTE *)v3 + 44) = v14;
        *((_BYTE *)v3 + 44) = v14 & 0xF7 | *((_BYTE *)a2 + 44) & 8;
        return (BOOL)v3;
      }
    }

    uint64_t v11 = (const void *)*((void *)v3 + 3);
    if (v11)
    {
      _Block_release(v11);
      os_log_type_t v10 = *((_BYTE *)v3 + 32);
    }

    goto LABEL_14;
  }

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  free(v12);
  if (v6) {
LABEL_48:
  }
    free(v6);
}

          goto LABEL_55;
        }

        if (!v72)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v42 = (os_log_s *)(id)gLogObj;
          uint64_t v49 = type;
          if (os_log_type_enabled(v42, type))
          {
            *(_DWORD *)buf = 136446210;
            v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
            _os_log_impl( &dword_181A5C000,  v42,  v49,  "%{public}s nw_listener_create failed, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_32;
        }

        uint64_t v45 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v46 = (os_log_s *)(id)gLogObj;
        uint64_t v47 = type;
        v48 = os_log_type_enabled(v46, type);
        if (v45)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
            os_log_type_t v76 = 2082;
            BOOL v77 = v45;
            _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s nw_listener_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v45);
          if (!v41) {
            goto LABEL_57;
          }
          goto LABEL_56;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
          _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s nw_listener_create failed, no backtrace", buf, 0xCu);
        }
      }

    if (!v15)
    {
LABEL_34:
      char v14 = 0LL;
      goto LABEL_35;
    }