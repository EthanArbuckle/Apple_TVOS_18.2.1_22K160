LABEL_320:
      free(backtrace_string);
      goto LABEL_414;
    }

    if (!v147) {
      goto LABEL_414;
    }
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    v135 = "%{public}s called with null return_array, no backtrace";
LABEL_413:
    _os_log_impl(&dword_181A5C000, v133, v134, v135, (uint8_t *)buf, 0xCu);
LABEL_414:
    if (v132) {
      free(v132);
    }
    return 0LL;
  }

  if ((*(_BYTE *)(v7 + 142) & 2) != 0)
  {
    if (gLogDatapath)
    {
      v146 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v146, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
        _os_log_impl( &dword_181A5C000,  v146,  OS_LOG_TYPE_DEBUG,  "%{public}s get_input_frames called reentrantly, returning",  (uint8_t *)buf,  0xCu);
        return 0LL;
      }
    }

    return 0LL;
  }

  *(_BYTE *)(v7 + 142) |= 2u;
  v12 = *(void *)(v6 + 88);
  if (v12 && (*(_BYTE *)(v12 + 212) & 1) == 0) {
    *(_BYTE *)(v12 + 212) |= 1u;
  }
  v232 = a4;
  v233 = a3;
  v231 = a5;
  v13 = a1[5];
  if (!v13)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v142 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v143 = (os_log_s *)__nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0])) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null protocol->handle";
      goto LABEL_451;
    }

    if (!LOBYTE(v258[0]))
    {
      v143 = (os_log_s *)__nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0])) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_451;
    }

    v161 = (char *)__nw_create_backtrace_string();
    v143 = (os_log_s *)__nwlog_obj();
    v144 = type[0];
    v162 = os_log_type_enabled(v143, type[0]);
    if (!v161)
    {
      if (!v162) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null protocol->handle, no backtrace";
      goto LABEL_451;
    }

    if (!v162) {
      goto LABEL_360;
    }
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v161;
    v163 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
LABEL_359:
    _os_log_impl(&dword_181A5C000, v143, v144, v163, (uint8_t *)buf, 0x16u);
    goto LABEL_360;
  }

  v14 = *(void *)(v13 + 72);
  if (!v14)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v142 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v143 = (os_log_s *)__nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0])) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin";
      goto LABEL_451;
    }

    if (!LOBYTE(v258[0]))
    {
      v143 = (os_log_s *)__nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0])) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_451;
    }

    v161 = (char *)__nw_create_backtrace_string();
    v143 = (os_log_s *)__nwlog_obj();
    v144 = type[0];
    v164 = os_log_type_enabled(v143, type[0]);
    if (!v161)
    {
      if (!v164) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin, no backtrace";
      goto LABEL_451;
    }

    if (!v164) {
      goto LABEL_360;
    }
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v161;
    v163 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
    goto LABEL_359;
  }

  if ((*(_BYTE *)(v14 + 142) & 2) == 0)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v142 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v143 = (os_log_s *)__nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0])) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin->getting_input_frames";
      goto LABEL_451;
    }

    if (!LOBYTE(v258[0]))
    {
      v143 = (os_log_s *)__nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0])) {
        goto LABEL_452;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin->getting_input_frames, backtrace limit exceeded";
      goto LABEL_451;
    }

    v161 = (char *)__nw_create_backtrace_string();
    v143 = (os_log_s *)__nwlog_obj();
    v144 = type[0];
    v166 = os_log_type_enabled(v143, type[0]);
    if (v161)
    {
      if (v166)
      {
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v161;
        v163 = "%{public}s called with null metadata_plugin->getting_input_frames, dumping backtrace:%{public}s";
        goto LABEL_359;
      }

          goto LABEL_321;
        }

        __nwlog_obj();
        v218 = v36;
        v199 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nwsc_save_remote_pub_key";
        v196 = (void *)_os_log_send_and_compose_impl();

        applier[0] = 16;
        LOBYTE(buffer) = 0;
        if (applier[0] == 17)
        {
          __nwlog_obj();
          v197 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v200 = applier[0];
          if (os_log_type_enabled(v197, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl( &dword_181A5C000,  v197,  v200,  "%{public}s called with null serviceConnector->remotePubKeys",  buf,  0xCu);
          }

          goto LABEL_311;
        }

        if (!(_BYTE)buffer)
        {
          __nwlog_obj();
          v197 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v213 = applier[0];
          if (os_log_type_enabled(v197, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl( &dword_181A5C000,  v197,  v213,  "%{public}s called with null serviceConnector->remotePubKeys, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_311;
        }

        v203 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v207 = applier[0];
        v208 = os_log_type_enabled(v204, (os_log_type_t)applier[0]);
        if (!v203)
        {
          if (v208)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl( &dword_181A5C000,  v204,  v207,  "%{public}s called with null serviceConnector->remotePubKeys, no backtrace",  buf,  0xCu);
          }

          goto LABEL_320;
        }

        if (v208)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nwsc_save_remote_pub_key";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v203;
          _os_log_impl( &dword_181A5C000,  v204,  v207,  "%{public}s called with null serviceConnector->remotePubKeys, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        v218 = v36;
        v195 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nwsc_save_remote_pub_key";
        v196 = (void *)_os_log_send_and_compose_impl();

        applier[0] = 16;
        LOBYTE(buffer) = 0;
        if (applier[0] == 17)
        {
          __nwlog_obj();
          v197 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v198 = applier[0];
          if (os_log_type_enabled(v197, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_181A5C000, v197, v198, "%{public}s called with null serviceConnector", buf, 0xCu);
          }

          goto LABEL_311;
        }

        if (!(_BYTE)buffer)
        {
          __nwlog_obj();
          v197 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v212 = applier[0];
          if (os_log_type_enabled(v197, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl( &dword_181A5C000,  v197,  v212,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_311;
        }

        v203 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v205 = applier[0];
        v206 = os_log_type_enabled(v204, (os_log_type_t)applier[0]);
        if (!v203)
        {
          if (v206)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl( &dword_181A5C000,  v204,  v205,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
          }

          goto LABEL_320;
        }

        if (v206)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nwsc_save_remote_pub_key";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v203;
          _os_log_impl( &dword_181A5C000,  v204,  v205,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      free(v203);
      if (!v196) {
        goto LABEL_323;
      }
      goto LABEL_322;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
    v45 = (char *)_os_log_send_and_compose_impl();

    applier[0] = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v45, applier, &buffer))
    {
      if (applier[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v46 = (os_log_s *)(id)gLogObj;
        v47 = applier[0];
        if (os_log_type_enabled(v46, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s nw_dispatch_data_copyout failed", buf, 0xCu);
        }
      }

      else if ((_BYTE)buffer)
      {
        v62 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v63 = applier[0];
        v64 = os_log_type_enabled(v46, (os_log_type_t)applier[0]);
        if (v62)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v62;
            _os_log_impl( &dword_181A5C000,  v46,  v63,  "%{public}s nw_dispatch_data_copyout failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v62);
          v65 = v222;
          if (!v45) {
            goto LABEL_108;
          }
          goto LABEL_107;
        }

        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v46,  v63,  "%{public}s nw_dispatch_data_copyout failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v86 = applier[0];
        if (os_log_type_enabled(v46, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v46,  v86,  "%{public}s nw_dispatch_data_copyout failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    v65 = v222;
    if (!v45)
    {
LABEL_108:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      goto LABEL_270;
    }

LABEL_360:
      free(v161);
      goto LABEL_452;
    }

    if (!v166) {
      goto LABEL_452;
    }
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v145 = "%{public}s called with null metadata_plugin->getting_input_frames, no backtrace";
LABEL_451:
    _os_log_impl(&dword_181A5C000, v143, v144, v145, (uint8_t *)buf, 0xCu);
LABEL_452:
    if (v142) {
      free(v142);
    }
    goto LABEL_15;
  }

  v229 = 0;
  v230 = 0;
  if (*(_BYTE *)(v14 + 140) == 2)
  {
    if (gLogDatapath)
    {
      v165 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        _os_log_impl( &dword_181A5C000,  v165,  OS_LOG_TYPE_DEBUG,  "%{public}s cannot process frames, waiting for saved input frames to be resumed",  (uint8_t *)buf,  0xCu);
        v15 = 0LL;
        goto LABEL_148;
      }
    }

    if (v165) {
      free(v165);
    }
    v123 = 0LL;
    v28 = (unint64_t)v222;
    v2 = v163;
    goto LABEL_197;
  }

    free(v213);
    if (!v195) {
      goto LABEL_370;
    }
    goto LABEL_369;
  }

  if (v259)
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
    v200 = "%{public}s called with null http1_stream->protocol_http1, no backtrace";
    goto LABEL_443;
  }

LABEL_514:
    if (v176) {
      free(v176);
    }
    v58 = 0;
LABEL_115:
    v38 = __CFADD__((_DWORD)v15, v58);
    v15 = v15 + v58;
    v230 = v15;
    if (!v38) {
      goto LABEL_121;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    LODWORD(buf[0]) = 136446978;
    v59 = v58;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = "count";
    HIWORD(buf[2]) = 2048;
    v261 = v58;
    LOWORD(v262[0]) = 2048;
    *(void *)((char *)v262 + 2) = v15;
    v60 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (__nwlog_fault(v60, type, v258))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v61 = (os_log_s *)gLogObj;
        v62 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_136;
        }
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = "count";
        HIWORD(buf[2]) = 2048;
        v261 = v59;
        LOWORD(v262[0]) = 2048;
        *(void *)((char *)v262 + 2) = v15;
        v63 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_134:
        v68 = v61;
LABEL_135:
        _os_log_impl(&dword_181A5C000, v68, v62, v63, (uint8_t *)buf, 0x2Au);
        goto LABEL_136;
      }

      if (!LOBYTE(v258[0]))
      {
        v61 = (os_log_s *)__nwlog_obj();
        v62 = type[0];
        if (!os_log_type_enabled(v61, type[0])) {
          goto LABEL_136;
        }
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = "count";
        HIWORD(buf[2]) = 2048;
        v261 = v59;
        LOWORD(v262[0]) = 2048;
        *(void *)((char *)v262 + 2) = v15;
        v63 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_134;
      }

      v66 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v62 = type[0];
      loga = (os_log_s *)gLogObj;
      v67 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v66)
      {
        if (v67)
        {
          LODWORD(buf[0]) = 136447234;
          *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = "count";
          HIWORD(buf[2]) = 2048;
          v261 = v59;
          LOWORD(v262[0]) = 2048;
          *(void *)((char *)v262 + 2) = v15;
          WORD1(v262[1]) = 2082;
          *(void *)((char *)&v262[1] + 4) = v66;
          _os_log_impl( &dword_181A5C000,  loga,  v62,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x34u);
        }

        free(v66);
      }

      else if (v67)
      {
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = "count";
        HIWORD(buf[2]) = 2048;
        v261 = v59;
        LOWORD(v262[0]) = 2048;
        *(void *)((char *)v262 + 2) = v15;
        v63 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        v68 = loga;
        goto LABEL_135;
      }
    }
  }

                      v362 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v362, OS_LOG_TYPE_DEBUG))
                      {
                        v363 = *(void *)(v293 + 256);
                        v364 = *(_DWORD *)(*(void *)(v293 + 248) + 372LL);
                        if (v363) {
                          LODWORD(v363) = *(_DWORD *)(v363 + 860);
                        }
                        v365 = *(_DWORD *)(v293 + 424);
                        *(_DWORD *)buf = 136448258;
                        *(void *)&buf[4] = "nw_http1_start_new_connection_for_stream";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v293 + 74;
                        *(_WORD *)&buf[22] = 2080;
                        v608 = (uint64_t)" ";
                        *(_WORD *)v609 = 1024;
                        *(_DWORD *)&v609[2] = v364;
                        *(_WORD *)&v609[6] = 1024;
                        *(_DWORD *)&v609[8] = v363;
                        *(_WORD *)&v609[12] = 1024;
                        *(_DWORD *)&v609[14] = v365;
                        *(_WORD *)&v609[18] = 2048;
                        *(void *)&v609[20] = v261;
                        *(_WORD *)&v609[28] = 1024;
                        *(_DWORD *)&v609[30] = v365;
                        *(_WORD *)&v609[34] = 2048;
                        *(void *)&v609[36] = v293;
                        _os_log_impl( &dword_181A5C000,  v362,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> created new connection %p for stream %u (%p)",  buf,  0x4Cu);
                      }

                      goto LABEL_518;
                    }

                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
                    v502 = (char *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    LOBYTE(aBlock) = 0;
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v503 = (os_log_s *)__nwlog_obj();
                      v504 = type[0];
                      if (!os_log_type_enabled(v503, type[0])) {
                        goto LABEL_914;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
                      v505 = "%{public}s called with null http1_stream->protocol_http1";
                    }

                    else if ((_BYTE)aBlock)
                    {
                      v539 = (char *)__nw_create_backtrace_string();
                      v503 = (os_log_s *)__nwlog_obj();
                      v504 = type[0];
                      v540 = os_log_type_enabled(v503, type[0]);
                      if (v539)
                      {
                        if (v540)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v539;
                          _os_log_impl( &dword_181A5C000,  v503,  v504,  "%{public}s called with null http1_stream->protocol_http1, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v539);
                        goto LABEL_914;
                      }

                      if (!v540)
                      {
LABEL_914:
                        if (v502) {
                          free(v502);
                        }
                        goto LABEL_896;
                      }

                      *(_DWORD *)buf = 136446210;
                      *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
                      v505 = "%{public}s called with null http1_stream->protocol_http1, no backtrace";
                    }

                    else
                    {
                      v503 = (os_log_s *)__nwlog_obj();
                      v504 = type[0];
                      if (!os_log_type_enabled(v503, type[0])) {
                        goto LABEL_914;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
                      v505 = "%{public}s called with null http1_stream->protocol_http1, backtrace limit exceeded";
                    }

                    _os_log_impl(&dword_181A5C000, v503, v504, v505, buf, 0xCu);
                    goto LABEL_914;
                  }

                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  *(void *)&buf[4] = "nw_protocol_http1_set_up_association";
                  v498 = (char *)_os_log_send_and_compose_impl();
                  type[0] = OS_LOG_TYPE_ERROR;
                  LOBYTE(aBlock) = 0;
                  if (__nwlog_fault(v498, type, &aBlock))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v499 = (os_log_s *)__nwlog_obj();
                      v500 = type[0];
                      if (!os_log_type_enabled(v499, type[0])) {
                        goto LABEL_907;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&buf[4] = "nw_protocol_http1_set_up_association";
                      v501 = "%{public}s called with null parameters";
LABEL_906:
                      _os_log_impl(&dword_181A5C000, v499, v500, v501, buf, 0xCu);
                      goto LABEL_907;
                    }

                    if (!(_BYTE)aBlock)
                    {
                      v499 = (os_log_s *)__nwlog_obj();
                      v500 = type[0];
                      if (!os_log_type_enabled(v499, type[0])) {
                        goto LABEL_907;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&buf[4] = "nw_protocol_http1_set_up_association";
                      v501 = "%{public}s called with null parameters, backtrace limit exceeded";
                      goto LABEL_906;
                    }

                    v537 = (char *)__nw_create_backtrace_string();
                    v499 = (os_log_s *)__nwlog_obj();
                    v500 = type[0];
                    v538 = os_log_type_enabled(v499, type[0]);
                    if (!v537)
                    {
                      if (!v538) {
                        goto LABEL_907;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&buf[4] = "nw_protocol_http1_set_up_association";
                      v501 = "%{public}s called with null parameters, no backtrace";
                      goto LABEL_906;
                    }

                    if (v538)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(void *)&buf[4] = "nw_protocol_http1_set_up_association";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v537;
                      _os_log_impl( &dword_181A5C000,  v499,  v500,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v537);
                  }

LABEL_166:
            v82 = *(_BYTE *)(v7 + 142);
            if ((v82 & 4) == 0 || *(void *)v7 || *(void *)(v7 + 16)) {
              goto LABEL_184;
            }
            *(_BYTE *)(v7 + 142) = v82 & 0xFB;
            v83 = v74[4];
            v84 = (void *)v74[5];
            if (v84 == &nw_protocol_ref_counted_handle)
            {
              v85 = v74[11];
              if (v85) {
                v74[11] = v85 + 1;
              }
            }

            if (v83)
            {
              v86 = *(void **)(v83 + 40);
              if (v86 == &nw_protocol_ref_counted_handle)
              {
                v87 = *(void *)(v83 + 88);
                if (v87) {
                  *(void *)(v83 + 88) = v87 + 1;
                }
              }

              v88 = v74[3];
              if (v88)
              {
                v89 = *(void (**)(void *, uint64_t))(v88 + 184);
                if (v89)
                {
                  v89(v74, v83);
LABEL_179:
                  v74 = a1;
                  if (v86 != &nw_protocol_ref_counted_handle) {
                    goto LABEL_181;
                  }
                  if (*(_UNKNOWN **)(v83 + 40) != &nw_protocol_ref_counted_handle) {
                    goto LABEL_181;
                  }
                  v128 = *(void *)(v83 + 88);
                  if (!v128) {
                    goto LABEL_181;
                  }
                  v129 = v128 - 1;
                  *(void *)(v83 + 88) = v129;
                  if (v129) {
                    goto LABEL_181;
                  }
                  v130 = *(void (***)(void))(v83 + 64);
                  if (v130)
                  {
                    *(void *)(v83 + 64) = 0LL;
                    v130[2](v130);
                    _Block_release(v130);
                  }

                  if ((*(_BYTE *)(v83 + 72) & 1) != 0)
                  {
                    v131 = *(const void **)(v83 + 64);
                    if (v131) {
                      _Block_release(v131);
                    }
                  }

                  free((void *)v83);
LABEL_272:
                  v74 = a1;
LABEL_181:
                  if (v84 == &nw_protocol_ref_counted_handle && (_UNKNOWN *)v74[5] == &nw_protocol_ref_counted_handle)
                  {
                    v123 = v74[11];
                    if (v123)
                    {
                      v124 = v123 - 1;
                      v74[11] = v124;
                      if (!v124)
                      {
                        v125 = (void (**)(void))v74[8];
                        if (v125)
                        {
                          v74[8] = 0LL;
                          v125[2](v125);
                          _Block_release(v125);
                          v74 = a1;
                        }

                        v126 = v74;
                        if ((v74[9] & 1) != 0)
                        {
                          v127 = (const void *)v74[8];
                          if (v127) {
                            _Block_release(v127);
                          }
                        }

                        free(v126);
                        v74 = v126;
                      }
                    }
                  }

                  v82 = *(_BYTE *)(v7 + 142);
LABEL_184:
                  if ((v82 & 8) == 0) {
                    return v15;
                  }
                  *(_BYTE *)(v7 + 142) = v82 & 0xF7;
                  v91 = v74[4];
                  v90 = (void *)v74[5];
                  if (v90 == &nw_protocol_ref_counted_handle)
                  {
                    v92 = v74[11];
                    if (v92) {
                      v74[11] = v92 + 1;
                    }
                  }

                  if (v91)
                  {
                    v93 = *(void **)(v91 + 40);
                    if (v93 == &nw_protocol_ref_counted_handle)
                    {
                      v94 = *(void *)(v91 + 88);
                      if (v94) {
                        *(void *)(v91 + 88) = v94 + 1;
                      }
                    }

                    v95 = v74[3];
                    if (v95)
                    {
                      v96 = *(void (**)(void *, uint64_t))(v95 + 48);
                      if (v96)
                      {
                        v96(v74, v91);
LABEL_195:
                        v97 = a1;
                        if (v93 != &nw_protocol_ref_counted_handle
                          || *(_UNKNOWN **)(v91 + 40) != &nw_protocol_ref_counted_handle
                          || (v117 = *(void *)(v91 + 88)) == 0
                          || (v118 = v117 - 1, (*(void *)(v91 + 88) = v118) != 0LL))
                        {
LABEL_197:
                          if (v90 == &nw_protocol_ref_counted_handle
                            && (_UNKNOWN *)v97[5] == &nw_protocol_ref_counted_handle)
                          {
                            v112 = v97[11];
                            if (v112)
                            {
                              v113 = v112 - 1;
                              v97[11] = v113;
                              if (!v113)
                              {
                                v114 = (void (**)(void))v97[8];
                                if (v114)
                                {
                                  v97[8] = 0LL;
                                  v114[2](v114);
                                  _Block_release(v114);
                                  v97 = a1;
                                }

                                v115 = v97;
                                if ((v97[9] & 1) != 0)
                                {
                                  v116 = (const void *)v97[8];
                                  if (v116) {
                                    _Block_release(v116);
                                  }
                                }

                                free(v115);
                              }
                            }
                          }

                          return v15;
                        }

                        v119 = *(void (***)(void))(v91 + 64);
                        if (v119)
                        {
                          *(void *)(v91 + 64) = 0LL;
                          v119[2](v119);
                          _Block_release(v119);
                        }

                        if ((*(_BYTE *)(v91 + 72) & 1) != 0)
                        {
                          v120 = *(const void **)(v91 + 64);
                          if (v120) {
                            _Block_release(v120);
                          }
                        }

    v61 = v117;
    if (v75) {
      free(v75);
    }
    v27 = 0LL;
    goto LABEL_62;
  }

  __nwlog_obj();
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_connection_group_send_message_internal";
  v42 = (char *)_os_log_send_and_compose_impl();

  v154[0] = 16;
  v152[0] = 0;
  if (__nwlog_fault(v42, v154, v152))
  {
    if (v154[0] == 17)
    {
      __nwlog_obj();
      v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v99 = v154[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v154[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_connection_group_send_message_internal";
        _os_log_impl(&dword_181A5C000, v43, v99, "%{public}s called with null endpoint", buf, 0xCu);
      }

      if (v46) {
        free(v46);
      }
      goto LABEL_23;
    }

    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v94 = "__nw_protocol_input_available";
    v42 = (char *)_os_log_send_and_compose_impl();

    v91[0] = OS_LOG_TYPE_ERROR;
    v88[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v42, v91, v88))
    {
      if (v91[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v44 = v91[0];
        if (os_log_type_enabled(v43, v91[0]))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "__nw_protocol_input_available";
          _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if (v88[0])
      {
        v65 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v66 = v91[0];
        v67 = os_log_type_enabled(v43, v91[0]);
        if (v65)
        {
          if (v67)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "__nw_protocol_input_available";
            v95 = 2082;
            v96 = v65;
            _os_log_impl( &dword_181A5C000,  v43,  v66,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v65);
          goto LABEL_161;
        }

        if (v67)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "__nw_protocol_input_available";
          _os_log_impl(&dword_181A5C000, v43, v66, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v82 = v91[0];
        if (os_log_type_enabled(v43, v91[0]))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "__nw_protocol_input_available";
          _os_log_impl( &dword_181A5C000,  v43,  v82,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v55) {
    free(v55);
  }
  return 0LL;
}

        if (v101) {
          free(v101);
        }
        v3 = v580;
        *(_DWORD *)(v580 + 340) = 0;
        v4 = v98;
        goto LABEL_169;
      }
    }

    if ((*(_BYTE *)(v3 + 158) & 1) == 0)
    {
      if (*((_BYTE *)v4 + 1537))
      {
        v381 = v6;
        v382 = v4;
        v383 = (os_log_s *)__nwlog_obj();
        v384 = os_log_type_enabled(v383, OS_LOG_TYPE_DEBUG);
        v4 = v382;
        v6 = v381;
        v3 = v580;
        if (v384)
        {
          v385 = *(_DWORD *)(v580 + 372);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_http1_get_next_idle_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v580 + 74;
          *(_WORD *)&buf[22] = 2080;
          v608 = (uint64_t)" ";
          *(_WORD *)v609 = 1024;
          *(_DWORD *)&v609[2] = v385;
          _os_log_impl( &dword_181A5C000,  v383,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> no idle connections",  buf,  0x26u);
          v4 = v382;
          v6 = v381;
          v3 = v580;
        }
      }
    }

    if (*(void *)(v5 + 256))
    {
      if ((*(_BYTE *)(v5 + 158) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = gLogObj;
        v20 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
        v3 = v580;
        if (v20)
        {
          v21 = *(void *)(v5 + 256);
          v22 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
          if (v21) {
            LODWORD(v21) = *(_DWORD *)(v21 + 860);
          }
          v23 = *(_DWORD *)(v5 + 424);
          *(_DWORD *)buf = 136447490;
          *(void *)&buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v5 + 74;
          *(_WORD *)&buf[22] = 2080;
          v608 = (uint64_t)" ";
          *(_WORD *)v609 = 1024;
          *(_DWORD *)&v609[2] = v22;
          *(_WORD *)&v609[6] = 1024;
          *(_DWORD *)&v609[8] = v21;
          *(_WORD *)&v609[12] = 1024;
          *(_DWORD *)&v609[14] = v23;
          v24 = "%{public}s %{public}s%s<i%u:c%u:s%u> stream already has current connection, ignoring";
          v25 = (os_log_s *)v19;
          v26 = 50;
LABEL_33:
          _os_log_impl(&dword_181A5C000, v25, OS_LOG_TYPE_DEBUG, v24, buf, v26);
          v3 = v580;
          goto LABEL_34;
        }
      }

      goto LABEL_34;
    }

    v578 = v6;
    if ((*(_WORD *)(v5 + 428) & 8) == 0)
    {
      if (*(_DWORD *)(v3 + 336) + *(_DWORD *)(v3 + 352) >= (*(_DWORD *)(v3 + 368) + *(_DWORD *)(v3 + 364)))
      {
        if ((*(_BYTE *)(v5 + 158) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v106 = gLogObj;
          v107 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
          v3 = v580;
          if (v107)
          {
            v108 = *(void *)(v5 + 256);
            v109 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
            if (v108) {
              LODWORD(v108) = *(_DWORD *)(v108 + 860);
            }
            v110 = *(_DWORD *)(v5 + 424);
            v111 = *(_DWORD *)(v580 + 364);
            *(_DWORD *)buf = 136447746;
            *(void *)&buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v5 + 74;
            *(_WORD *)&buf[22] = 2080;
            v608 = (uint64_t)" ";
            *(_WORD *)v609 = 1024;
            *(_DWORD *)&v609[2] = v109;
            *(_WORD *)&v609[6] = 1024;
            *(_DWORD *)&v609[8] = v108;
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = v110;
            *(_WORD *)&v609[18] = 1024;
            *(_DWORD *)&v609[20] = v111;
            v24 = "%{public}s %{public}s%s<i%u:c%u:s%u> already at max connection width %u, cannot create new connection";
            v25 = (os_log_s *)v106;
            v26 = 56;
            goto LABEL_33;
          }
        }

            if (*(_DWORD *)(a2 + 144))
            {
              if (*(void *)(a2 + 80)) {
                __assert_rtn("header_out_begin_static_nameref", "lsqpack.c", 3088, "!read_ctx->hbrc_out.xhdr");
              }
              if (v19 > 0x62)
              {
                v161 = 3602;
                goto LABEL_348;
              }

              v167 = v9;
              v107 = v8;
              v108 = *(_DWORD *)(a2 + 148);
              v109 = 4LL * (*(_DWORD *)a1 & 1);
              v110 = &(&static_table)[3 * v19];
              v111 = *((unsigned int *)v110 + 4);
              v112 = (*(uint64_t (**)(void, void, size_t))(*(void *)(a1 + 40) + 8LL))( *(void *)(a2 + 32),  0LL,  v109 + v111);
              *(void *)(a2 + 80) = v112;
              if (!v112)
              {
                v161 = 3602;
                v10 = v7;
                v4 = __src;
                goto LABEL_349;
              }

              v113 = (_DWORD *)v112;
              *(_BYTE *)(v112 + 35) = v109;
              *(_BYTE *)(v112 + 31) = v19;
              v114 = *(_BYTE *)(v112 + 33);
              *(_BYTE *)(v112 + 33) = v114 | 0xA;
              *(_DWORD *)(v112 + 8) = name_hashes[v19];
              if (v108) {
                *(_BYTE *)(v112 + 33) = v114 | 0x4A;
              }
              *(_WORD *)(v112 + 24) = v111;
              v115 = (char *)(*(void *)v112 + *(int *)(v112 + 16));
              memcpy(v115, *v110, v111);
              v116 = &v115[v111];
              if ((_DWORD)v109)
              {
                *(_WORD *)v116 = 8250;
                LOWORD(v116) = (_WORD)v116 + 2;
              }

              v8 = v107;
              v4 = __src;
              v9 = v167;
              v113[5] = (unsigned __int16)((_WORD)v116 - *v113);
              *(void *)(a2 + 88) = 1LL;
            }

            else
            {
              v117 = *(_DWORD *)(a1 + 20);
              if (v117)
              {
                v118 = 2 * v117;
                v117 = (v118 - v19 + *(_DWORD *)(a2 + 68)) % v118;
                v119 = (v118 - v117 + *(_DWORD *)(a1 + 32)) % v118;
              }

              else
              {
                v119 = 0;
              }

              v120 = *(_DWORD *)(a1 + 56);
              if (!v120
                || ((v121 = *(_DWORD *)(a1 + 60),
                     v122 = *(_DWORD *)(a1 + 64),
                     v57 = v121 >= v122,
                     v123 = v121 - v122,
                     v57)
                  ? (v124 = 0)
                  : (v124 = *(_DWORD *)(a1 + 56)),
                    v123 + v124 <= v119
                 || (v125 = *(unsigned int **)(*(void *)(a1 + 72) + 8LL * ((v120 + ~v119 + v121) % v120))) == 0LL))
              {
                v161 = 3609;
                goto LABEL_348;
              }

              v126 = *(_DWORD *)(a2 + 104);
              if ((v126 & 2) != 0) {
                v127 = v126 | (32 * (*(_DWORD *)(a2 + 64) == v117));
              }
              else {
                v127 = v126 | 0x40;
              }
              *(_DWORD *)(a2 + 104) = v127;
              if (header_out_begin_dynamic_nameref( (unsigned int *)a1,  (void *)a2,  v125,  *(_DWORD *)(a2 + 148)))
              {
                v161 = 3613;
                goto LABEL_348;
              }
            }

            goto LABEL_190;
          }

          if ((v11 & 0x20) != 0)
          {
            *(_DWORD *)(a2 + 148) = v11 & 0x10;
            *(_DWORD *)(a2 + 152) = *v10 & 8;
            *(_DWORD *)(a2 + 160) = 0;
            *(_DWORD *)(a2 + 136) = 8;
            v9 = 3LL;
LABEL_105:
            v7 = v10 + 1;
            v68 = *v10;
            v69 = ~(-1 << v9);
            v16 = v68 & v69;
            if ((v68 & v69) >= v69)
            {
              v17 = 0;
              v36 = 1;
              do
              {
                if (v7 >= v8)
                {
                  if ((v36 & 1) != 0) {
                    v143 = 0;
                  }
                  else {
                    v143 = *(_DWORD *)(a2 + 168);
                  }
                  v160 = v143 + (_DWORD)v7 - (_DWORD)v10;
                  if (v160 >= 0xB)
                  {
                    v161 = 3731;
                    goto LABEL_349;
                  }

LABEL_238:
                        free((void *)v91);
LABEL_239:
                        v97 = a1;
                        goto LABEL_197;
                      }
                    }

                    v154 = (const char **)v74;
                    __nwlog_obj();
                    v155 = v154[2];
                    LODWORD(buf[0]) = 136446722;
                    *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                    if (!v155) {
                      v155 = "invalid";
                    }
                    WORD2(buf[1]) = 2082;
                    *(void *)((char *)&buf[1] + 6) = v155;
                    HIWORD(buf[2]) = 2048;
                    v261 = (unint64_t)v154;
                    v156 = (char *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    LOBYTE(v258[0]) = 0;
                    if (__nwlog_fault(v156, type, v258))
                    {
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        v157 = (os_log_s *)__nwlog_obj();
                        v158 = type[0];
                        if (!os_log_type_enabled(v157, type[0])) {
                          goto LABEL_485;
                        }
                        v159 = (const char *)a1[2];
                        if (!v159) {
                          v159 = "invalid";
                        }
                        LODWORD(buf[0]) = 136446722;
                        *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = v159;
                        HIWORD(buf[2]) = 2048;
                        v261 = (unint64_t)a1;
                        v160 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
                        goto LABEL_484;
                      }

                      if (!LOBYTE(v258[0]))
                      {
                        v157 = (os_log_s *)__nwlog_obj();
                        v158 = type[0];
                        if (!os_log_type_enabled(v157, type[0])) {
                          goto LABEL_485;
                        }
                        v198 = (const char *)a1[2];
                        if (!v198) {
                          v198 = "invalid";
                        }
                        LODWORD(buf[0]) = 136446722;
                        *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = v198;
                        HIWORD(buf[2]) = 2048;
                        v261 = (unint64_t)a1;
                        v160 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
                        goto LABEL_484;
                      }

                      v183 = (char *)__nw_create_backtrace_string();
                      v157 = (os_log_s *)__nwlog_obj();
                      v158 = type[0];
                      v184 = os_log_type_enabled(v157, type[0]);
                      if (v183)
                      {
                        if (v184)
                        {
                          v185 = (const char *)a1[2];
                          if (!v185) {
                            v185 = "invalid";
                          }
                          LODWORD(buf[0]) = 136446978;
                          *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                          WORD2(buf[1]) = 2082;
                          *(void *)((char *)&buf[1] + 6) = v185;
                          HIWORD(buf[2]) = 2048;
                          v261 = (unint64_t)a1;
                          LOWORD(v262[0]) = 2082;
                          *(void *)((char *)v262 + 2) = v183;
                          _os_log_impl( &dword_181A5C000,  v157,  v158,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x2Au);
                        }

                        free(v183);
                        goto LABEL_485;
                      }

                      if (v184)
                      {
                        v207 = (const char *)a1[2];
                        if (!v207) {
                          v207 = "invalid";
                        }
                        LODWORD(buf[0]) = 136446722;
                        *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = v207;
                        HIWORD(buf[2]) = 2048;
                        v261 = (unint64_t)a1;
                        v160 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_484:
                        _os_log_impl(&dword_181A5C000, v157, v158, v160, (uint8_t *)buf, 0x20u);
                      }
                    }

              if (v64) {
                free(v64);
              }
LABEL_28:
              if (v13 == &nw_protocol_ref_counted_handle) {
                goto LABEL_36;
              }
              goto LABEL_37;
            }

            __nwlog_obj();
            v82 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v133 = "__nw_protocol_finalize_output_frames";
            v83 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v128[0] = OS_LOG_TYPE_DEFAULT;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v85 = type[0];
              if (os_log_type_enabled(v84, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v133 = "__nw_protocol_finalize_output_frames";
                _os_log_impl(&dword_181A5C000, v84, v85, "%{public}s called with null protocol", buf, 0xCu);
              }
            }

            else if (v128[0])
            {
              v105 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v106 = type[0];
              v107 = os_log_type_enabled(v84, type[0]);
              if (v105)
              {
                if (v107)
                {
                  *(_DWORD *)buf = 136446466;
                  v133 = "__nw_protocol_finalize_output_frames";
                  v134 = 2082;
                  v135 = v105;
                  _os_log_impl( &dword_181A5C000,  v84,  v106,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v105);
LABEL_271:
                if (!v83) {
                  goto LABEL_37;
                }
LABEL_272:
                free(v83);
                goto LABEL_37;
              }

              if (v107)
              {
                *(_DWORD *)buf = 136446210;
                v133 = "__nw_protocol_finalize_output_frames";
                _os_log_impl( &dword_181A5C000,  v84,  v106,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v120 = type[0];
              if (os_log_type_enabled(v84, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v133 = "__nw_protocol_finalize_output_frames";
                _os_log_impl( &dword_181A5C000,  v84,  v120,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
              }
            }

    if (v80) {
      free(v80);
    }
    goto LABEL_59;
  }

  __nwlog_obj();
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v109 = "nw_protocol_implementation_output_finished";
  v53 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v104) = 0;
  if (__nwlog_fault(v53, type, &v104))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v55 = type[0];
      if (os_log_type_enabled(v54, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "nw_protocol_implementation_output_finished";
        _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)v104)
    {
      v65 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v66 = type[0];
      v67 = os_log_type_enabled(v54, type[0]);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446466;
          v109 = "nw_protocol_implementation_output_finished";
          v110 = 2082;
          v111 = v65;
          _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v65);
        goto LABEL_209;
      }

      if (v67)
      {
        *(_DWORD *)buf = 136446210;
        v109 = "nw_protocol_implementation_output_finished";
        _os_log_impl(&dword_181A5C000, v54, v66, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v91 = type[0];
      if (os_log_type_enabled(v54, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "nw_protocol_implementation_output_finished";
        _os_log_impl( &dword_181A5C000,  v54,  v91,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

          if ((*(_BYTE *)(v8 + 376) & 1) == 0) {
            goto LABEL_240;
          }
          v127 = *(void ***)(v8 + 328);
          if (!v127) {
            goto LABEL_265;
          }
          v128 = (unsigned __int16 *)(v11 + 872);
          v129 = *v127;
          if (v129 && *v129)
          {
            v130 = *(nw_parameters **)(v8 + 264);
            if (v130)
            {
              v131 = nw_parameters_copy(v130);
              *(void *)(v8 + 224) = v11;
              if ((***(unsigned int (****)(void, void, nw_parameters_t))(v8 + 328))( *(void *)(v8 + 328),  *(void *)(v8 + 280),  v131)
                && *(void *)(v11 + 488)
                && !*(void *)(v8 + 224))
              {
                if ((*(_BYTE *)(v8 + 158) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    v302 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v302, OS_LOG_TYPE_DEBUG))
                    {
                      v303 = *(_DWORD *)(v8 + 372);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&buf[4] = "nw_http1_attempt_trigger_new_flow";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v8 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      *(void *)&buf[24] = " ";
                      *(_WORD *)&buf[32] = 1024;
                      *(_DWORD *)&buf[34] = v303;
                      _os_log_impl( &dword_181A5C000,  v302,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> sucessfully associated new flow stream with connection, awaiting connected",  buf,  0x26u);
                    }
                  }
                }

                v163 = *v128;
                v164 = (v163 | (*((unsigned __int8 *)v128 + 2) << 16)) & 0xFFFDFFFF;
                *v128 = v163;
                *((_BYTE *)v128 + 2) = BYTE2(v164);
                goto LABEL_351;
              }

              if ((*(_BYTE *)(v8 + 158) & 1) == 0)
              {
                v132 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
                {
                  v133 = *(_DWORD *)(v8 + 372);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&buf[4] = "nw_http1_attempt_trigger_new_flow";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v8 + 74;
                  *(_WORD *)&buf[22] = 2080;
                  *(void *)&buf[24] = " ";
                  *(_WORD *)&buf[32] = 1024;
                  *(_DWORD *)&buf[34] = v133;
                  *(_WORD *)&buf[38] = 2048;
                  *(void *)&buf[40] = v11;
                  _os_log_impl( &dword_181A5C000,  v132,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> listen handler didn't accept the new flow, closing connection %p",  buf,  0x30u);
                }
              }

              v134 = *v128;
              v135 = v134 | (*(unsigned __int8 *)(v11 + 874) << 16);
              if ((v134 & 0x100) != 0)
              {
                if ((*(_BYTE *)(v11 + 158) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    v152 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v152, OS_LOG_TYPE_DEBUG))
                    {
                      v153 = *(void *)(v11 + 488);
                      v154 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
                      v155 = *(_DWORD *)(v11 + 860);
                      if (v153) {
                        LODWORD(v153) = *(_DWORD *)(v153 + 424);
                      }
                      *(_DWORD *)buf = 136447490;
                      *(void *)&buf[4] = "nw_http1_connection_close";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v11 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      *(void *)&buf[24] = " ";
                      *(_WORD *)&buf[32] = 1024;
                      *(_DWORD *)&buf[34] = v154;
                      *(_WORD *)&buf[38] = 1024;
                      *(_DWORD *)&buf[40] = v155;
                      *(_WORD *)&buf[44] = 1024;
                      *(_DWORD *)&buf[46] = v153;
                      _os_log_impl( &dword_181A5C000,  v152,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> already closed",  buf,  0x32u);
                    }
                  }
                }

                goto LABEL_351;
              }

              *(_BYTE *)(v11 + 874) = BYTE2(v135);
              *v128 = v135 | 0x100;
              if ((*(_BYTE *)(v11 + 158) & 1) == 0)
              {
                if (gLogDatapath)
                {
                  v272 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v272, OS_LOG_TYPE_DEBUG))
                  {
                    v273 = *(void *)(v11 + 488);
                    v274 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
                    v275 = *(_DWORD *)(v11 + 860);
                    if (v273) {
                      LODWORD(v273) = *(_DWORD *)(v273 + 424);
                    }
                    *(_DWORD *)buf = 136447490;
                    *(void *)&buf[4] = "nw_http1_connection_close";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v11 + 74;
                    *(_WORD *)&buf[22] = 2080;
                    *(void *)&buf[24] = " ";
                    *(_WORD *)&buf[32] = 1024;
                    *(_DWORD *)&buf[34] = v274;
                    *(_WORD *)&buf[38] = 1024;
                    *(_DWORD *)&buf[40] = v275;
                    *(_WORD *)&buf[44] = 1024;
                    *(_DWORD *)&buf[46] = v273;
                    _os_log_impl( &dword_181A5C000,  v272,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http connection closed, increasing pool width",  buf,  0x32u);
                  }
                }
              }

              v136 = *(void *)(v11 + 480);
              if (!v136)
              {
                __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
                v268 = (char *)_os_log_send_and_compose_impl();
                v398[0] = 16;
                v394[0] = OS_LOG_TYPE_DEFAULT;
                if (v398[0] == 17)
                {
                  v269 = (os_log_s *)__nwlog_obj();
                  v270 = v398[0];
                  if (!os_log_type_enabled(v269, (os_log_type_t)v398[0])) {
                    goto LABEL_652;
                  }
                  *(_DWORD *)buf = 136446210;
                  *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
                  v271 = "%{public}s called with null http1";
                }

                else if (v394[0])
                {
                  v288 = (char *)__nw_create_backtrace_string();
                  v269 = (os_log_s *)__nwlog_obj();
                  v270 = v398[0];
                  v289 = os_log_type_enabled(v269, (os_log_type_t)v398[0]);
                  if (v288)
                  {
                    if (v289)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v288;
                      _os_log_impl( &dword_181A5C000,  v269,  v270,  "%{public}s called with null http1, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v288);
                    goto LABEL_652;
                  }

                  if (!v289) {
                    goto LABEL_652;
                  }
                  *(_DWORD *)buf = 136446210;
                  *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
                  v271 = "%{public}s called with null http1, no backtrace";
                }

                else
                {
                  v269 = (os_log_s *)__nwlog_obj();
                  v270 = v398[0];
                  if (!os_log_type_enabled(v269, (os_log_type_t)v398[0])) {
                    goto LABEL_652;
                  }
                  *(_DWORD *)buf = 136446210;
                  *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
                  v271 = "%{public}s called with null http1, backtrace limit exceeded";
                }

                v331 = buf;
LABEL_651:
                _os_log_impl(&dword_181A5C000, v269, v270, v271, v331, 0xCu);
                goto LABEL_652;
              }

              v137 = *v128;
              v138 = v137 | (*(unsigned __int8 *)(v11 + 874) << 16);
              if ((v137 & 0x800) != 0)
              {
                if ((*(_BYTE *)(v11 + 158) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    v159 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v159, OS_LOG_TYPE_DEBUG))
                    {
                      v160 = *(void *)(v11 + 488);
                      v161 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
                      v162 = *(_DWORD *)(v11 + 860);
                      if (v160) {
                        LODWORD(v160) = *(_DWORD *)(v160 + 424);
                      }
                      *(_DWORD *)buf = 136447490;
                      *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v11 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      *(void *)&buf[24] = " ";
                      *(_WORD *)&buf[32] = 1024;
                      *(_DWORD *)&buf[34] = v161;
                      *(_WORD *)&buf[38] = 1024;
                      *(_DWORD *)&buf[40] = v162;
                      *(_WORD *)&buf[44] = 1024;
                      *(_DWORD *)&buf[46] = v160;
                      _os_log_impl( &dword_181A5C000,  v159,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> Connection already marked as not-reusable, ignoring",  buf,  0x32u);
                    }
                  }
                }

                goto LABEL_342;
              }

              *(_BYTE *)(v11 + 874) = BYTE2(v138);
              *v128 = v138 | 0x800;
              v139 = *(unsigned int *)(v136 + 368) + 1LL;
              v140 = v139 << 31 >> 31;
              *(_DWORD *)(v136 + 368) = v139;
              if (v140 == v139 && (v140 & 0x8000000000000000LL) == 0)
              {
LABEL_337:
                if ((*(_BYTE *)(v11 + 158) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    v290 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v290, OS_LOG_TYPE_DEBUG))
                    {
                      v291 = *(void *)(v11 + 488);
                      v292 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
                      v293 = *(_DWORD *)(v11 + 860);
                      if (v291) {
                        LODWORD(v291) = *(_DWORD *)(v291 + 424);
                      }
                      v294 = *(_DWORD *)(v136 + 368) + *(_DWORD *)(v136 + 364);
                      *(_DWORD *)buf = 136447746;
                      *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v11 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      *(void *)&buf[24] = " ";
                      *(_WORD *)&buf[32] = 1024;
                      *(_DWORD *)&buf[34] = v292;
                      *(_WORD *)&buf[38] = 1024;
                      *(_DWORD *)&buf[40] = v293;
                      *(_WORD *)&buf[44] = 1024;
                      *(_DWORD *)&buf[46] = v291;
                      *(_WORD *)&buf[50] = 1024;
                      *(_DWORD *)&buf[52] = v294;
                      _os_log_impl( &dword_181A5C000,  v290,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> connection marked as not-reusable, increased pool width to %u",  buf,  0x38u);
                    }
                  }
                }

                v175 = *(void **)(v11 + 496);
                if (!v175)
                {
                  __nwlog_obj();
                  *(_DWORD *)v398 = 136446210;
                  *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                  v268 = (char *)_os_log_send_and_compose_impl();
                  v394[0] = OS_LOG_TYPE_ERROR;
                  type = OS_LOG_TYPE_DEFAULT;
                  if (v394[0] == OS_LOG_TYPE_FAULT)
                  {
                    v269 = (os_log_s *)__nwlog_obj();
                    v270 = v394[0];
                    if (!os_log_type_enabled(v269, v394[0])) {
                      goto LABEL_652;
                    }
                    *(_DWORD *)v398 = 136446210;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    v271 = "%{public}s called with null http1_connection->context";
LABEL_650:
                    v331 = v398;
                    goto LABEL_651;
                  }

                  if (type == OS_LOG_TYPE_DEFAULT)
                  {
                    v269 = (os_log_s *)__nwlog_obj();
                    v270 = v394[0];
                    if (!os_log_type_enabled(v269, v394[0])) {
                      goto LABEL_652;
                    }
                    *(_DWORD *)v398 = 136446210;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    v271 = "%{public}s called with null http1_connection->context, backtrace limit exceeded";
                    goto LABEL_650;
                  }

                  v304 = (char *)__nw_create_backtrace_string();
                  v269 = (os_log_s *)__nwlog_obj();
                  v270 = v394[0];
                  v305 = os_log_type_enabled(v269, v394[0]);
                  if (!v304)
                  {
                    if (!v305) {
                      goto LABEL_652;
                    }
                    *(_DWORD *)v398 = 136446210;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    v271 = "%{public}s called with null http1_connection->context, no backtrace";
                    goto LABEL_650;
                  }

                  if (v305)
                  {
                    *(_DWORD *)v398 = 136446466;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    *(_WORD *)&v398[12] = 2082;
                    *(void *)&v398[14] = v304;
                    v306 = "%{public}s called with null http1_connection->context, dumping backtrace:%{public}s";
LABEL_578:
                    _os_log_impl(&dword_181A5C000, v269, v270, v306, v398, 0x16u);
                  }

            if (v171) {
              free(v171);
            }
            goto LABEL_240;
          }

          __nwlog_obj();
          v218 = 0LL;
          v201 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nwsc_save_remote_pub_key";
          v196 = (void *)_os_log_send_and_compose_impl();

          applier[0] = 16;
          LOBYTE(buffer) = 0;
          if (!__nwlog_fault((const char *)v196, applier, &buffer))
          {
LABEL_321:
            if (!v196)
            {
LABEL_323:
              v36 = v218;
              goto LABEL_201;
            }

  if (v76) {
    free(v76);
  }
LABEL_56:
  *((void *)handle + 20) = 0LL;
  *((void *)handle + 21) = 0LL;
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  v147 = a3;
  nw_protocol_set_input_handler((uint64_t)a1, 0LL);
  if (gLogDatapath)
  {
    v105 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v105, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v38 = MEMORY[0x1895F87A8];
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60412;
  v151 = (uint64_t)&__block_descriptor_tmp_26_60413;
  *(void *)&v152 = handle + 216;
  BYTE8(v152) = 0;
  v39 = *((void *)handle + 27);
  do
  {
    if (!v39) {
      break;
    }
    v40 = *(void *)(v39 + 32);
    v41 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v39 = v40;
  }

  while ((v41 & 1) != 0);
  v42 = *((void *)handle + 22);
  while (v42)
  {
    v43 = (_DWORD *)v42;
    v42 = *(void *)(v42 + 32);
    if (gLogDatapath)
    {
      log = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        v44 = nw_frame_unclaimed_length(v43);
        *(_DWORD *)buf = 136446722;
        *(void *)&buf[4] = "nw_http3_framer_cleanup_block_invoke";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v43;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v151) = v44;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s input frames unprocessed still has frames in it: frame %p (%u bytes)",  buf,  0x1Cu);
      }
    }
  }

  if (gLogDatapath)
  {
    v106 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v106, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  *(void *)buf = v38;
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60412;
  v151 = (uint64_t)&__block_descriptor_tmp_26_60413;
  *(void *)&v152 = handle + 176;
  BYTE8(v152) = 0;
  v45 = *((void *)handle + 22);
  do
  {
    if (!v45) {
      break;
    }
    v46 = *(void *)(v45 + 32);
    v47 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v45 = v46;
  }

  while ((v47 & 1) != 0);
  *((_DWORD *)handle + 48) = 0;
  v48 = *((void *)handle + 47);
  v49 = v147;
  if (v48)
  {
    nw_frame_finalize(v48);
    *((void *)handle + 47) = 0LL;
  }

  if (*((void *)handle + 66) || handle[634] || handle[635])
  {
    v50 = *((void *)handle + 42);
    if ((*(_WORD *)(v50 + 1373) & 8) == 0 && (*v11 & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = (os_log_s *)gLogObj;
      v52 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      v50 = *((void *)handle + 42);
      if (v52)
      {
        v53 = *(_DWORD *)(v50 + 1280);
        v54 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        *(void *)&buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 636;
        *(_WORD *)&buf[22] = 2080;
        v151 = (uint64_t)" ";
        LOWORD(v152) = 1024;
        *(_DWORD *)((char *)&v152 + 2) = v53;
        WORD3(v152) = 2048;
        *((void *)&v152 + 1) = v54;
        _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%llu> cancelled while sending data on uni streams",  buf,  0x30u);
        v50 = *((void *)handle + 42);
      }
    }

    nw_http3_fail_all_streams(v50, 258LL);
  }

  output_handler = a1->output_handler;
  if (!output_handler
    || (callbacks = output_handler->callbacks) == 0LL
    || (remove_input_handler = (void (*)(nw_protocol *, nw_protocol *))callbacks->remove_input_handler) == 0LL)
  {
    __nwlog_obj();
    v58 = a1->output_handler;
    v59 = "invalid";
    if (v58)
    {
      identifier = v58->identifier;
      if (identifier) {
        v59 = (const char *)identifier;
      }
    }

    *(_DWORD *)buf = 136446466;
    *(void *)&buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v59;
    v61 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v148 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v62 = (os_log_s *)__nwlog_obj();
      v63 = type;
      if (os_log_type_enabled(v62, type))
      {
        v64 = a1->output_handler;
        v65 = "invalid";
        if (v64)
        {
          v66 = v64->identifier;
          if (v66) {
            v65 = (const char *)v66;
          }
        }

        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v65;
        _os_log_impl( &dword_181A5C000,  v62,  v63,  "%{public}s protocol %{public}s has invalid remove_input_handler callback",  buf,  0x16u);
      }

      goto LABEL_225;
    }

    if (v148)
    {
      v82 = (char *)__nw_create_backtrace_string();
      v83 = (os_log_s *)__nwlog_obj();
      v84 = type;
      v85 = os_log_type_enabled(v83, type);
      if (v82)
      {
        if (v85)
        {
          v86 = a1->output_handler;
          v87 = "invalid";
          if (v86)
          {
            v88 = v86->identifier;
            if (v88) {
              v87 = (const char *)v88;
            }
          }

          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_protocol_http3_stream_remove_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v87;
          *(_WORD *)&buf[22] = 2082;
          v151 = (uint64_t)v82;
          _os_log_impl( &dword_181A5C000,  v83,  v84,  "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x20u);
          v49 = v147;
        }

        free(v82);
        goto LABEL_225;
      }

      if (!v85)
      {
LABEL_225:
        if (v61) {
          free(v61);
        }
        goto LABEL_85;
      }

      v133 = a1->output_handler;
      v134 = "invalid";
      if (v133)
      {
        v135 = v133->identifier;
        if (v135) {
          v134 = (const char *)v135;
        }
      }

      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v134;
      v130 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
    }

    else
    {
      v83 = (os_log_s *)__nwlog_obj();
      v84 = type;
      if (!os_log_type_enabled(v83, type)) {
        goto LABEL_225;
      }
      v127 = a1->output_handler;
      v128 = "invalid";
      if (v127)
      {
        v129 = v127->identifier;
        if (v129) {
          v128 = (const char *)v129;
        }
      }

      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v128;
      v130 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v83, v84, v130, buf, 0x16u);
    v49 = v147;
    goto LABEL_225;
  }

  remove_input_handler(output_handler, a1);
LABEL_85:
  nw_protocol_set_output_handler((uint64_t)a1, 0LL);
  if (v49)
  {
    a1->handle = 0LL;
    nw_protocol_http3_stream_destroy((uint64_t)handle);
  }

  return 1LL;
}

          goto LABEL_328;
        }

        if (!v369)
        {
          __nwlog_obj();
          v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v131 = type;
          if (os_log_type_enabled(v102, type))
          {
            v132 = *(const char **)(v10 + 16);
            if (!v132) {
              v132 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            v379 = 2082;
            v380 = (char *)v132;
            v381 = 2048;
            v382 = (const char *)v10;
            _os_log_impl( &dword_181A5C000,  v102,  v131,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded",  buf,  0x20u);
          }

          goto LABEL_238;
        }

        v115 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v353 = type;
        v117 = os_log_type_enabled(v116, type);
        if (v115)
        {
          if (v117)
          {
            v118 = *(const char **)(v10 + 16);
            if (!v118) {
              v118 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            v378 = "__nw_protocol_replace_input_handler";
            v379 = 2082;
            v380 = (char *)v118;
            v381 = 2048;
            v382 = (const char *)v10;
            v383 = 2082;
            v384 = v115;
            _os_log_impl( &dword_181A5C000,  v116,  v353,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v115);
        }

        else
        {
          if (v117)
          {
            v149 = *(const char **)(v10 + 16);
            if (!v149) {
              v149 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            v379 = 2082;
            v380 = (char *)v149;
            v381 = 2048;
            v382 = (const char *)v10;
            _os_log_impl( &dword_181A5C000,  v116,  v353,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace",  buf,  0x20u);
          }
        }

LABEL_485:
                    if (v156) {
                      free(v156);
                    }
                    goto LABEL_195;
                  }

                  __nwlog_obj();
                  LODWORD(buf[0]) = 136446210;
                  *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                  v91 = _os_log_send_and_compose_impl();
                  type[0] = OS_LOG_TYPE_ERROR;
                  LOBYTE(v258[0]) = 0;
                  if (__nwlog_fault((const char *)v91, type, v258))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v180 = (os_log_s *)__nwlog_obj();
                      v181 = type[0];
                      if (!os_log_type_enabled(v180, type[0])) {
                        goto LABEL_520;
                      }
                      LODWORD(buf[0]) = 136446210;
                      *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                      v182 = "%{public}s called with null other_protocol";
                      goto LABEL_519;
                    }

                    if (!LOBYTE(v258[0]))
                    {
                      v180 = (os_log_s *)__nwlog_obj();
                      v181 = type[0];
                      if (!os_log_type_enabled(v180, type[0])) {
                        goto LABEL_520;
                      }
                      LODWORD(buf[0]) = 136446210;
                      *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                      v182 = "%{public}s called with null other_protocol, backtrace limit exceeded";
                      goto LABEL_519;
                    }

                    v195 = (char *)__nw_create_backtrace_string();
                    v180 = (os_log_s *)__nwlog_obj();
                    v181 = type[0];
                    v196 = os_log_type_enabled(v180, type[0]);
                    if (v195)
                    {
                      if (v196)
                      {
                        LODWORD(buf[0]) = 136446466;
                        *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = v195;
                        _os_log_impl( &dword_181A5C000,  v180,  v181,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
                      }

                      free(v195);
                      if (!v91) {
                        goto LABEL_239;
                      }
                      goto LABEL_238;
                    }

                    if (v196)
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(void *)((char *)buf + 4) = "__nw_protocol_disconnected";
                      v182 = "%{public}s called with null other_protocol, no backtrace";
LABEL_519:
                      _os_log_impl(&dword_181A5C000, v180, v181, v182, (uint8_t *)buf, 0xCu);
                    }
                  }

                free(v236);
                if (!v231) {
                  goto LABEL_366;
                }
LABEL_525:
                free(v231);
LABEL_366:
                *(void *)(a1 + 144) = 0LL;
                if ((*(_BYTE *)(a1 + 348) & 1) != 0) {
                  goto LABEL_370;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v184 = (os_log_s *)gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_370;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&buf[4] = "nw_protocol_ohttp_process_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 349;
                *(_WORD *)&buf[22] = 2080;
                v285 = (uint64_t)" ";
                v185 = "%{public}s %{public}s%sFailed to process response";
                goto LABEL_369;
              }

              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
              v231 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v278) = 16;
              LOBYTE(__size[0]) = 0;
              if (v278 == 17)
              {
                v232 = (os_log_s *)__nwlog_obj();
                v233 = v278;
                if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                  goto LABEL_524;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
                v234 = "%{public}s called with null request_context_length";
                goto LABEL_523;
              }

              if (!LOBYTE(__size[0]))
              {
                v232 = (os_log_s *)__nwlog_obj();
                v233 = v278;
                if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                  goto LABEL_524;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
                v234 = "%{public}s called with null request_context_length, backtrace limit exceeded";
                goto LABEL_523;
              }

              v236 = (char *)__nw_create_backtrace_string();
              v232 = (os_log_s *)__nwlog_obj();
              v233 = v278;
              v241 = os_log_type_enabled(v232, (os_log_type_t)v278);
              if (!v236)
              {
                if (!v241) {
                  goto LABEL_524;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
                v234 = "%{public}s called with null request_context_length, no backtrace";
                goto LABEL_523;
              }

              if (!v241) {
                goto LABEL_485;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v236;
              v238 = "%{public}s called with null request_context_length, dumping backtrace:%{public}s";
LABEL_484:
              _os_log_impl(&dword_181A5C000, v232, v233, v238, buf, 0x16u);
              goto LABEL_485;
            }

            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
            v231 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v278) = 16;
            LOBYTE(__size[0]) = 0;
            if (v278 != 17)
            {
              if (!LOBYTE(__size[0]))
              {
                v232 = (os_log_s *)__nwlog_obj();
                v233 = v278;
                if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                  goto LABEL_524;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
                v234 = "%{public}s called with null request_context, backtrace limit exceeded";
                goto LABEL_523;
              }

              v236 = (char *)__nw_create_backtrace_string();
              v232 = (os_log_s *)__nwlog_obj();
              v233 = v278;
              v240 = os_log_type_enabled(v232, (os_log_type_t)v278);
              if (!v236)
              {
                if (!v240) {
                  goto LABEL_524;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
                v234 = "%{public}s called with null request_context, no backtrace";
                goto LABEL_523;
              }

              if (!v240) {
                goto LABEL_485;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v236;
              v238 = "%{public}s called with null request_context, dumping backtrace:%{public}s";
              goto LABEL_484;
            }

            v232 = (os_log_s *)__nwlog_obj();
            v233 = v278;
            if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
              goto LABEL_524;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
            v234 = "%{public}s called with null request_context";
          }

          else
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
            v231 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v278) = 16;
            LOBYTE(__size[0]) = 0;
            if (v278 != 17)
            {
              if (!LOBYTE(__size[0]))
              {
                v232 = (os_log_s *)__nwlog_obj();
                v233 = v278;
                if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                  goto LABEL_524;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
                v234 = "%{public}s called with null response_length, backtrace limit exceeded";
                goto LABEL_523;
              }

              v236 = (char *)__nw_create_backtrace_string();
              v232 = (os_log_s *)__nwlog_obj();
              v233 = v278;
              v239 = os_log_type_enabled(v232, (os_log_type_t)v278);
              if (!v236)
              {
                if (!v239) {
                  goto LABEL_524;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
                v234 = "%{public}s called with null response_length, no backtrace";
                goto LABEL_523;
              }

              if (!v239) {
                goto LABEL_485;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v236;
              v238 = "%{public}s called with null response_length, dumping backtrace:%{public}s";
              goto LABEL_484;
            }

            v232 = (os_log_s *)__nwlog_obj();
            v233 = v278;
            if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
              goto LABEL_524;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
            v234 = "%{public}s called with null response_length";
          }
        }

        else
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
          v231 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v278) = 16;
          LOBYTE(__size[0]) = 0;
          if (v278 != 17)
          {
            if (!LOBYTE(__size[0]))
            {
              v232 = (os_log_s *)__nwlog_obj();
              v233 = v278;
              if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                goto LABEL_524;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
              v234 = "%{public}s called with null response_buffer, backtrace limit exceeded";
              goto LABEL_523;
            }

            v236 = (char *)__nw_create_backtrace_string();
            v232 = (os_log_s *)__nwlog_obj();
            v233 = v278;
            v237 = os_log_type_enabled(v232, (os_log_type_t)v278);
            if (!v236)
            {
              if (!v237) {
                goto LABEL_524;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
              v234 = "%{public}s called with null response_buffer, no backtrace";
              goto LABEL_523;
            }

            if (!v237) {
              goto LABEL_485;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v236;
            v238 = "%{public}s called with null response_buffer, dumping backtrace:%{public}s";
            goto LABEL_484;
          }

          v232 = (os_log_s *)__nwlog_obj();
          v233 = v278;
          if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
            goto LABEL_524;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_http_create_message_from_oblivious_response";
          v234 = "%{public}s called with null response_buffer";
        }

    v330 = (v331 + 1);
  }

  while ((_DWORD)v336 != -1);

  v382->connection_reuse_count = v331;
  if ((*((_BYTE *)v380 + 108) & 0x20) != 0)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[2] = buf;
    buf[6] = 0;
    *(void *)&buf[4] = 0x2020000000LL;
    activities = (unsigned __int8 *)v329->activities;
    v383[0] = MEMORY[0x1895F87A8];
    v383[1] = 3221225472LL;
    v383[2] = ___ZL49nw_connection_stats_fill_in_nw_report_on_nw_queueP24NWConcrete_nw_connectionP22nw_connection_report_s_block_invoke_51;
    v383[3] = &unk_189BC7338;
    v385 = buf;
    v350 = v329;
    v384 = v350;
    v386 = v382;
    nw_array_apply(activities, (uint64_t)v383);
    v351 = v380->parameters;
    if (v351 && !nw_path_parameters_get_logging_disabled(*((void *)v351 + 13)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v352 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v352, OS_LOG_TYPE_INFO))
      {
        v353 = v350->top_id;
        v354 = *(_DWORD *)(*(void *)&buf[2] + 24LL);
        *(_DWORD *)v425 = 136446722;
        *(void *)&v425[4] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
        *(_WORD *)&v425[12] = 1024;
        *(_DWORD *)&v425[14] = v353;
        *(_WORD *)&v425[18] = 1024;
        *(_DWORD *)&v425[20] = v354;
        _os_log_impl( &dword_181A5C000,  v352,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Copied %u activities to connection report",  v425,  0x18u);
      }
    }

    _Block_object_dispose(buf, 8);
  }

  quic_enabled = nw_settings_get_quic_enabled();
  v356 = 0x200000000LL;
  if (!quic_enabled) {
    v356 = 0LL;
  }
  v357 = (*v292 | ((unint64_t)*((unsigned __int16 *)v292 + 2) << 32)) & 0xFFFFFFFDFFFFFFFFLL | v356;
  *((_WORD *)v292 + 2) = WORD2(v357);
  buf[0] = 0;
  *(_DWORD *)v425 = 0;
  if (v379)
  {
    nw_establishment_report_get_accurate_ecn_state(v379, buf, v425);
    v358 = v382;
    v382->client_accurate_ecn_state = buf[0];
    v382->server_accurate_ecn_state = *(_DWORD *)v425;
    l4s_enabled = nw_establishment_report_get_l4s_enabled(v379);
    v357 = *v292 | ((unint64_t)*((unsigned __int16 *)v292 + 2) << 32);
  }

  else
  {
    l4s_enabled = 0;
    v358 = v382;
    *(void *)&v382->client_accurate_ecn_state = 0LL;
  }

  v360 = v357 & 0xFFFFFBFFFFFFFFFFLL | ((unint64_t)l4s_enabled << 42);
  *v292 = v357;
  *((_WORD *)v292 + 2) = WORD2(v360);
  v358->failure_reason = 0;
  errors = (uint64_t)v329->errors;
  if (!errors) {
    goto LABEL_533;
  }
  if (*(void *)(errors + 24) == *(void *)(errors + 16)) {
    goto LABEL_532;
  }
  nw_array_get_object_at_index(errors, 0LL);
  v362 = (void *)objc_claimAutoreleasedReturnValue();
  v363 = v362;
  if (v362)
  {
    v364 = v362;
    v365 = v364[2];

    if (v365 == 2) {
      goto LABEL_530;
    }
    if (v365 == 3)
    {
      v365 = 4;
      goto LABEL_530;
    }

    if ((*v292 & 0x4000) == 0 && v365 == 1)
    {
      v365 = 3;
LABEL_530:
      v382->failure_reason = v365;
    }
  }

  if (!v382->failure_reason)
  {
LABEL_532:
    LODWORD(v360) = *v292;
LABEL_533:
    if ((v360 & 0x4000) == 0)
    {
      v366 = v329;
      v367 = v366;
      if (v309->used_timestamps)
      {
        v368 = 0LL;
        v369 = v309->timestamps;
        v370 = &v369->var1.event;
        while (*v370 != 6 || *(v370 - 1) != 1)
        {
          ++v368;
          v370 += 8;
          if (v368 >= v309->used_timestamps) {
            goto LABEL_541;
          }
        }

        v371 = (nw_delta_nanos(v309->start_time, *(&v369->var0 + 2 * v368)) / 0xF4240uLL) == -1;

        if (!v371) {
          v382->failure_reason = 1;
        }
      }

      else
      {
LABEL_541:
      }
    }
  }

LABEL_543:
}

LABEL_520:
                  if (!v91) {
                    goto LABEL_239;
                  }
                  goto LABEL_238;
                }
              }

              v200 = (const char **)v74;
              __nwlog_obj();
              v201 = v200[2];
              LODWORD(buf[0]) = 136446722;
              *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
              if (!v201) {
                v201 = "invalid";
              }
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v201;
              HIWORD(buf[2]) = 2048;
              v261 = (unint64_t)v200;
              v202 = (char *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v258[0]) = 0;
              if (__nwlog_fault(v202, type, v258))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  v203 = (os_log_s *)__nwlog_obj();
                  v204 = type[0];
                  if (!os_log_type_enabled(v203, type[0])) {
                    goto LABEL_536;
                  }
                  v205 = (const char *)a1[2];
                  if (!v205) {
                    v205 = "invalid";
                  }
                  LODWORD(buf[0]) = 136446722;
                  *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v205;
                  HIWORD(buf[2]) = 2048;
                  v261 = (unint64_t)a1;
                  v206 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback";
                  goto LABEL_535;
                }

                if (!LOBYTE(v258[0]))
                {
                  v203 = (os_log_s *)__nwlog_obj();
                  v204 = type[0];
                  if (!os_log_type_enabled(v203, type[0])) {
                    goto LABEL_536;
                  }
                  v219 = (const char *)a1[2];
                  if (!v219) {
                    v219 = "invalid";
                  }
                  LODWORD(buf[0]) = 136446722;
                  *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v219;
                  HIWORD(buf[2]) = 2048;
                  v261 = (unint64_t)a1;
                  v206 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded";
                  goto LABEL_535;
                }

                v214 = (char *)__nw_create_backtrace_string();
                v203 = (os_log_s *)__nwlog_obj();
                v204 = type[0];
                v215 = os_log_type_enabled(v203, type[0]);
                if (v214)
                {
                  if (v215)
                  {
                    v216 = (const char *)a1[2];
                    if (!v216) {
                      v216 = "invalid";
                    }
                    LODWORD(buf[0]) = 136446978;
                    *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                    WORD2(buf[1]) = 2082;
                    *(void *)((char *)&buf[1] + 6) = v216;
                    HIWORD(buf[2]) = 2048;
                    v261 = (unint64_t)a1;
                    LOWORD(v262[0]) = 2082;
                    *(void *)((char *)v262 + 2) = v214;
                    _os_log_impl( &dword_181A5C000,  v203,  v204,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x2Au);
                  }

                  free(v214);
                  goto LABEL_536;
                }

                if (v215)
                {
                  v220 = (const char *)a1[2];
                  if (!v220) {
                    v220 = "invalid";
                  }
                  LODWORD(buf[0]) = 136446722;
                  *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v220;
                  HIWORD(buf[2]) = 2048;
                  v261 = (unint64_t)a1;
                  v206 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace";
LABEL_535:
                  _os_log_impl(&dword_181A5C000, v203, v204, v206, (uint8_t *)buf, 0x20u);
                }
              }

    if (v208) {
      free(v208);
    }
    v4 = v256;
    v13 = v257;
    goto LABEL_157;
  }

  if (*((void *)v16 + 61))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v84 = *((void *)v16 + 61);
    *(_DWORD *)buf = 136446722;
    *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v16;
    *(_WORD *)&buf[22] = 2048;
    v268 = v84;
    v85 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(aBlock[0]) = 0;
    if (__nwlog_fault(v85, type, aBlock))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v86 = (os_log_s *)gLogObj;
        v87 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          v88 = *((void *)v16 + 61);
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v16;
          *(_WORD *)&buf[22] = 2048;
          v268 = v88;
          v89 = "%{public}s Connection %p already has a stream (%p)";
LABEL_153:
          _os_log_impl(&dword_181A5C000, v86, v87, v89, buf, 0x20u);
        }
      }

      else if (LOBYTE(aBlock[0]))
      {
        v102 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v86 = (os_log_s *)gLogObj;
        v87 = type[0];
        v103 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v102)
        {
          if (v103)
          {
            v104 = *((void *)v16 + 61);
            *(_DWORD *)buf = 136446978;
            *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v16;
            *(_WORD *)&buf[22] = 2048;
            v268 = v104;
            v269 = 2082;
            *(void *)v270 = v102;
            _os_log_impl( &dword_181A5C000,  v86,  v87,  "%{public}s Connection %p already has a stream (%p), dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v102);
          goto LABEL_154;
        }

        if (v103)
        {
          v106 = *((void *)v16 + 61);
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v16;
          *(_WORD *)&buf[22] = 2048;
          v268 = v106;
          v89 = "%{public}s Connection %p already has a stream (%p), no backtrace";
          goto LABEL_153;
        }
      }

      else
      {
        v86 = (os_log_s *)__nwlog_obj();
        v87 = type[0];
        if (os_log_type_enabled(v86, type[0]))
        {
          v105 = *((void *)v16 + 61);
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_http1_stream_associate_with_connection";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v16;
          *(_WORD *)&buf[22] = 2048;
          v268 = v105;
          v89 = "%{public}s Connection %p already has a stream (%p), backtrace limit exceeded";
          goto LABEL_153;
        }
      }
    }
    }
  }

  if (v315) {
    free(v315);
  }
  v387 = -[NWURLLoaderHTTP errorForErrorCode:]((id *)a1, -1LL);
  objc_storeStrong((id *)(a1 + 88), v387);

  *(_BYTE *)(a1 + 11) = 1;
LABEL_647:
}

LABEL_536:
              if (v202) {
                free(v202);
              }
              goto LABEL_179;
            }

            __nwlog_obj();
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
            v210 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v258[0]) = 0;
            if (__nwlog_fault(v210, type, v258))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                v211 = (os_log_s *)__nwlog_obj();
                v212 = type[0];
                if (!os_log_type_enabled(v211, type[0])) {
                  goto LABEL_543;
                }
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                v213 = "%{public}s called with null other_protocol";
                goto LABEL_542;
              }

              if (!LOBYTE(v258[0]))
              {
                v211 = (os_log_s *)__nwlog_obj();
                v212 = type[0];
                if (!os_log_type_enabled(v211, type[0])) {
                  goto LABEL_543;
                }
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                v213 = "%{public}s called with null other_protocol, backtrace limit exceeded";
                goto LABEL_542;
              }

              v217 = (char *)__nw_create_backtrace_string();
              v211 = (os_log_s *)__nwlog_obj();
              v212 = type[0];
              v218 = os_log_type_enabled(v211, type[0]);
              if (v217)
              {
                if (v218)
                {
                  LODWORD(buf[0]) = 136446466;
                  *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v217;
                  _os_log_impl( &dword_181A5C000,  v211,  v212,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
                }

                free(v217);
                goto LABEL_543;
              }

              if (v218)
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "__nw_protocol_input_finished";
                v213 = "%{public}s called with null other_protocol, no backtrace";
LABEL_542:
                _os_log_impl(&dword_181A5C000, v211, v212, v213, (uint8_t *)buf, 0xCu);
              }
            }

    v248 = (char *)v327;
    goto LABEL_537;
  }

  v17 = *((_DWORD *)v15 + 33);
LABEL_15:

  if ((handle[137] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v19 = handle[115];
      *(_DWORD *)buf = 136447490;
      *(void *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 116;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v19;
      *(_WORD *)&v345[6] = 1024;
      *(_DWORD *)&v345[8] = v19;
      *(_WORD *)&v345[12] = 1024;
      *(_DWORD *)&v345[14] = v17;
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> created WebTransport session and assigned instance ID: %u from C%u",  buf,  0x32u);
    }
  }

  if (v16)
  {
    v20 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v13);
    v21 = nw_protocol_options_copy(v16);
    if (nw_protocol_copy_webtransport_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_60063);
    }
    v22 = (id)nw_protocol_copy_webtransport_definition::definition;
    nw_parameters_set_protocol_instance(v21, v23, (uint64_t)handle);
    if (v22) {
      os_release(v22);
    }
    nw_protocol_stack_replace_protocol_with_handle(v20, (uint64_t)handle, v21);
    if (v21) {
      os_release(v21);
    }
    if (v20) {
      os_release(v20);
    }
  }

  else if ((handle[137] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v25 = handle[115];
      *(_DWORD *)buf = 136447490;
      *(void *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 116;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v25;
      *(_WORD *)&v345[6] = 2048;
      *(void *)&v345[8] = v13;
      *(_WORD *)&v345[16] = 2048;
      *(void *)&v345[18] = v12;
      _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> failed to find webtransport options in new parameters %p, copy of %p",  buf,  0x3Au);
    }
  }

  v26 = *((_BYTE *)handle + 352);
  if ((v26 & 1) != 0)
  {
    v27 = (void *)*((void *)handle + 43);
    if (v27)
    {
      os_release(v27);
      v26 = *((_BYTE *)handle + 352);
    }
  }

  *((void *)handle + 43) = v13;
  *((_BYTE *)handle + 352) = v26 | 1;
  if (v16) {
    os_release(v16);
  }
LABEL_35:
  identifier = a1->identifier;
  v29 = nw_parameters_copy_protocol_options_legacy(v9, (nw_protocol *)handle);
  if (!v29)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_webtransport_stream_add_input_handler";
    v54 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v54, &aBlock, v339))
    {
      if (aBlock == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = (os_log_s *)gLogObj;
        v56 = aBlock;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_webtransport_stream_add_input_handler";
          v57 = "%{public}s called with null webtransport_stream";
LABEL_92:
          _os_log_impl(&dword_181A5C000, v55, v56, v57, buf, 0xCu);
        }
      }

      else if (v339[0])
      {
        v61 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = (os_log_s *)gLogObj;
        v56 = aBlock;
        v62 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock);
        if (v61)
        {
          if (v62)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = "nw_webtransport_stream_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v61;
            _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v61);
          goto LABEL_93;
        }

        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_webtransport_stream_add_input_handler";
          v57 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_92;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = (os_log_s *)gLogObj;
        v56 = aBlock;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_webtransport_stream_add_input_handler";
          v57 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_92;
        }
      }
    }

      if (!v228) {
        goto LABEL_538;
      }
      goto LABEL_537;
    }

    __nwlog_obj();
    v125 = *(unsigned int *)(v120 + 368);
    *(_DWORD *)buf = 136446978;
    *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "http1->nonresuable_connections";
    *(_WORD *)&buf[22] = 2048;
    *(void *)&buf[24] = 1LL;
    *(_WORD *)&buf[32] = 2048;
    *(void *)&buf[34] = v125;
    v126 = (char *)_os_log_send_and_compose_impl();
    v265[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v126, v265, &type))
    {
      if (v265[0] == 17)
      {
        v127 = (os_log_s *)__nwlog_obj();
        v128 = v265[0];
        if (os_log_type_enabled(v127, (os_log_type_t)v265[0]))
        {
          v129 = *(unsigned int *)(v120 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = 1LL;
          *(_WORD *)&buf[32] = 2048;
          *(void *)&buf[34] = v129;
          v130 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_285:
          _os_log_impl(&dword_181A5C000, v127, v128, v130, buf, 0x2Au);
        }
      }

      else if (type)
      {
        v151 = (char *)__nw_create_backtrace_string();
        v127 = (os_log_s *)__nwlog_obj();
        v128 = v265[0];
        v152 = os_log_type_enabled(v127, (os_log_type_t)v265[0]);
        if (v151)
        {
          if (v152)
          {
            v153 = *(unsigned int *)(v120 + 368);
            *(_DWORD *)buf = 136447234;
            *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&buf[22] = 2048;
            *(void *)&buf[24] = 1LL;
            *(_WORD *)&buf[32] = 2048;
            *(void *)&buf[34] = v153;
            *(_WORD *)&buf[42] = 2082;
            *(void *)&v262 = v151;
            _os_log_impl( &dword_181A5C000,  v127,  v128,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v151);
          goto LABEL_286;
        }

        if (v152)
        {
          v176 = *(unsigned int *)(v120 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = 1LL;
          *(_WORD *)&buf[32] = 2048;
          *(void *)&buf[34] = v176;
          v130 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_285;
        }
      }

      else
      {
        v127 = (os_log_s *)__nwlog_obj();
        v128 = v265[0];
        if (os_log_type_enabled(v127, (os_log_type_t)v265[0]))
        {
          v167 = *(unsigned int *)(v120 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = 1LL;
          *(_WORD *)&buf[32] = 2048;
          *(void *)&buf[34] = v167;
          v130 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_285;
        }
      }
    }

            if (v252) {
              free(v252);
            }
            v6 = (unsigned __int16 *)(a1 + 736);
            v17 = v369;
            if (!v64) {
              goto LABEL_312;
            }
            goto LABEL_311;
          }

          v369 = v17;
        }

        else
        {
          v369 = v17;
          os_release(v59);
        }

        v64 = 0LL;
        goto LABEL_111;
      }

      if ((*v6 & 0x800) == 0)
      {
        v76 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          v77 = *(_DWORD *)(*(void *)(a1 + 336) + 1280LL);
          v78 = *(void **)(a1 + 240);
          v79 = *(void *)(a1 + 384);
          *(_DWORD *)buf = 136447490;
          *(void *)&buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 636;
          *(_WORD *)&buf[22] = 2080;
          v427 = (__n128 (*)(uint64_t, uint64_t))" ";
          LOWORD(v428) = 1024;
          *(_DWORD *)((char *)&v428 + 2) = v77;
          HIWORD(v428) = 2048;
          v429 = v78;
          *(_WORD *)v430 = 2048;
          *(void *)&v430[2] = v79;
          _os_log_impl( &dword_181A5C000,  v76,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%llu> No response found in frame %p",  buf,  0x3Au);
        }
      }

      v80 = *(void *)(a1 + 48);
      if (v80)
      {
        v81 = *(void *)(v80 + 24);
        if (v81)
        {
          v82 = *(void (**)(void))(v81 + 56);
          if (v82)
          {
            v82();
            v44 = *(void *)(a1 + 48);
            if (!v44) {
              goto LABEL_580;
            }
LABEL_89:
            v83 = *(void *)(v44 + 24);
            if (v83)
            {
              v46 = *(void (**)(uint64_t, uint64_t))(v83 + 48);
              if (v46) {
                goto LABEL_91;
              }
            }

LABEL_543:
            if (v210) {
              free(v210);
            }
            goto LABEL_272;
          }

          v106 = *(void (***)(void))(v75 + 64);
          if (v106)
          {
            *(void *)(v75 + 64) = 0LL;
            v106[2](v106);
            _Block_release(v106);
          }

          if ((*(_BYTE *)(v75 + 72) & 1) != 0)
          {
            v107 = *(const void **)(v75 + 64);
            if (v107) {
              _Block_release(v107);
            }
          }

      if (v251) {
        free(v251);
      }
      goto LABEL_256;
    }

    if (v29)
    {
      if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v264 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v264, OS_LOG_TYPE_DEBUG))
          {
            v265 = v30[11];
            if (v265) {
              v266 = *(_DWORD *)(v265 + 460);
            }
            else {
              v266 = -1;
            }
            v296 = v30[8];
            *(_DWORD *)buf = 136447490;
            *(void *)&buf[4] = "nw_webtransport_session_add_pending_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v30 + 24;
            *(_WORD *)&buf[22] = 2080;
            v344 = (uint64_t)" ";
            *(_WORD *)v345 = 1024;
            *(_DWORD *)&v345[2] = v266;
            *(_WORD *)&v345[6] = 2048;
            *(void *)&v345[8] = v296;
            *(_WORD *)&v345[16] = 2048;
            *(void *)&v345[18] = v30;
            _os_log_impl( &dword_181A5C000,  v264,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called for stream (%p)",  buf,  0x3Au);
          }
        }
      }

      if ((*((_BYTE *)v30 + 276) & 0x20) == 0)
      {
        v30[14] = 0LL;
        v84 = (void *)*((void *)handle + 42);
        v30[15] = v84;
        *v84 = v30;
        *((void *)handle + 42) = v30 + 14;
        v85 = handle[114] + 1LL;
        v86 = v85 << 31 >> 31;
        handle[114] = v85;
        if (v86 == v85 && (v86 & 0x8000000000000000LL) == 0)
        {
LABEL_240:
          v153 = *((_BYTE *)v30 + 276);
          *((_BYTE *)v30 + 276) = v153 | 0x20;
          if ((v153 & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v280 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v280, OS_LOG_TYPE_DEBUG))
              {
                v281 = v30[11];
                if (v281) {
                  v282 = *(_DWORD *)(v281 + 460);
                }
                else {
                  v282 = -1;
                }
                v305 = v30[8];
                v306 = handle[114];
                *(_DWORD *)buf = 136447746;
                *(void *)&buf[4] = "nw_webtransport_session_add_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v30 + 24;
                *(_WORD *)&buf[22] = 2080;
                v344 = (uint64_t)" ";
                *(_WORD *)v345 = 1024;
                *(_DWORD *)&v345[2] = v282;
                *(_WORD *)&v345[6] = 2048;
                *(void *)&v345[8] = v305;
                *(_WORD *)&v345[16] = 2048;
                *(void *)&v345[18] = v30;
                *(_WORD *)&v345[26] = 1024;
                LODWORD(v346) = v306;
                _os_log_impl( &dword_181A5C000,  v280,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> added stream (%p), now have %u pending streams",  buf,  0x40u);
              }
            }
          }

          goto LABEL_242;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v87 = handle[114];
        *(_DWORD *)buf = 136446978;
        *(void *)&buf[4] = "nw_webtransport_session_add_pending_stream";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "webtransport_session->pending_stream_count";
        *(_WORD *)&buf[22] = 2048;
        v344 = 1LL;
        *(_WORD *)v345 = 2048;
        *(void *)&v345[2] = v87;
        v88 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(aBlock) = 16;
        v339[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v88, &aBlock, v339))
        {
          if (aBlock == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v89 = (os_log_s *)gLogObj;
            v90 = aBlock;
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock))
            {
              v91 = handle[114];
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_webtransport_session_add_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v344 = 1LL;
              *(_WORD *)v345 = 2048;
              *(void *)&v345[2] = v91;
              v92 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_236:
              _os_log_impl(&dword_181A5C000, v89, v90, v92, buf, 0x2Au);
            }
          }

          else if (v339[0])
          {
            v124 = (char *)__nw_create_backtrace_string();
            v89 = (os_log_s *)__nwlog_obj();
            v90 = aBlock;
            v125 = os_log_type_enabled(v89, (os_log_type_t)aBlock);
            if (v124)
            {
              if (v125)
              {
                v126 = handle[114];
                *(_DWORD *)buf = 136447234;
                *(void *)&buf[4] = "nw_webtransport_session_add_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                v344 = 1LL;
                *(_WORD *)v345 = 2048;
                *(void *)&v345[2] = v126;
                *(_WORD *)&v345[10] = 2082;
                *(void *)&v345[12] = v124;
                _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v124);
              goto LABEL_237;
            }

            if (v125)
            {
              v152 = handle[114];
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_webtransport_session_add_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v344 = 1LL;
              *(_WORD *)v345 = 2048;
              *(void *)&v345[2] = v152;
              v92 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_236;
            }
          }

          else
          {
            v89 = (os_log_s *)__nwlog_obj();
            v90 = aBlock;
            if (os_log_type_enabled(v89, (os_log_type_t)aBlock))
            {
              v137 = handle[114];
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_webtransport_session_add_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v344 = 1LL;
              *(_WORD *)v345 = 2048;
              *(void *)&v345[2] = v137;
              v92 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_236;
            }
          }
        }

LABEL_498:
    if (!v75) {
      goto LABEL_217;
    }
    goto LABEL_216;
  }

  return v15;
}

      if (v61) {
        free(v61);
      }
      return 0LL;
    }

    v84 = (char *)__nw_create_backtrace_string();
    v62 = (os_log_s *)__nwlog_obj();
    v63 = aBlock[0];
    v85 = os_log_type_enabled(v62, (os_log_type_t)aBlock[0]);
    if (!v84)
    {
      if (v85)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_http1_add_input_handler";
        v64 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_497;
      }

      goto LABEL_498;
    }

    if (v85)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_http1_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v84;
      v86 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_491:
      _os_log_impl(&dword_181A5C000, v62, v63, v86, buf, 0x16u);
      goto LABEL_492;
    }

    goto LABEL_492;
  }

  v9 = &qword_18C45F000;
  if ((*(_BYTE *)(v8 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v69 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
      {
        v70 = *(_DWORD *)(v8 + 372);
        *(_DWORD *)buf = 136447234;
        *(void *)&buf[4] = "nw_protocol_http1_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v8 + 74;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v70;
        *(_WORD *)&buf[38] = 2048;
        *(void *)&buf[40] = v4;
        _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called with input_protocol %p",  buf,  0x30u);
      }
    }
  }

  parameters = (uint64_t *)nw_protocol_get_parameters((uint64_t)v4);
  v11 = *(void *)(v8 + 264);
  v12 = MEMORY[0x1895F87A8];
  v13 = (void *)&unk_182665000;
  v271 = v4;
  if (!v11)
  {
    nw_protocol_set_input_handler(v8, (uint64_t)v4);
    *(_OWORD *)v8 = *(_OWORD *)v4->flow_id;
    nw_protocol_plugin_name_set_name(v8 + 64, (uint64_t)a1, parameters);
    v14 = parameters;
    v15 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v14,  0,  1);

    v16 = nw_parameters_copy_protocol_options_legacy((void *)v15, (nw_protocol *)v8);
    v17 = v16;
    if (v16)
    {
      *(_DWORD *)(v8 + 364) = nw_http1_get_connection_pool_width(v16);
      *(void *)(v8 + 192) = 1000LL * nw_http1_get_idle_timeout(v17);
      *(_DWORD *)(v8 + 372) = nw_protocol_get_next_instance_id();
      v18 = v17;
      v19 = *((_DWORD *)v18 + 33);

      if ((*(_BYTE *)(v8 + 158) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v21 = *(_DWORD *)(v8 + 372);
          *(_DWORD *)buf = 136447490;
          *(void *)&buf[4] = "nw_protocol_http1_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v8 + 74;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v21;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v21;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v19;
          _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> created HTTP/1 and assigned instance ID: %u from C%u",  buf,  0x32u);
        }
      }

      v22 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v15);
      v23 = nw_protocol_options_copy(v18);
      if (nw_protocol_copy_http1_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http1_definition_onceToken, &__block_literal_global_72463);
      }
      v24 = (id)nw_protocol_copy_http1_definition_http1_definition;
      nw_parameters_set_protocol_instance(v23, v25, v8);
      if (v24) {
        os_release(v24);
      }
      nw_protocol_stack_replace_protocol_with_handle(v22, v8, v23);
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      buf[24] = 0;
      iterate_block[0] = MEMORY[0x1895F87A8];
      iterate_block[1] = 0x40000000LL;
      iterate_block[2] = ___ZL35nw_protocol_http1_add_input_handlerP11nw_protocolS0__block_invoke;
      iterate_block[3] = &unk_189BBD840;
      iterate_block[4] = buf;
      iterate_block[5] = v8;
      nw_protocol_stack_iterate_application_protocols(v22, iterate_block);
      _Block_object_dispose(buf, 8);
      v9 = &qword_18C45F000;
      if (v23) {
        os_release(v23);
      }
      if (v22) {
        os_release(v22);
      }
    }

    else if ((*(_BYTE *)(v8 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v27 = *(_DWORD *)(v8 + 372);
        *(_DWORD *)buf = 136447490;
        *(void *)&buf[4] = "nw_protocol_http1_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v8 + 74;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v27;
        *(_WORD *)&buf[38] = 2048;
        *(void *)&buf[40] = v15;
        *(_WORD *)&buf[48] = 2048;
        *(void *)&buf[50] = v14;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> failed to find http1 options in new parameters %p, copy of %p",  buf,  0x3Au);
      }
    }

    v28 = *(_BYTE *)(v8 + 272);
    if ((v28 & 1) != 0)
    {
      v29 = *(void **)(v8 + 264);
      v4 = v271;
      v12 = MEMORY[0x1895F87A8];
      v13 = &unk_182665000;
      if (v29)
      {
        os_release(v29);
        v28 = *(_BYTE *)(v8 + 272);
      }
    }

    else
    {
      v4 = v271;
      v12 = MEMORY[0x1895F87A8];
      v13 = (void *)&unk_182665000;
    }

    *(void *)(v8 + 264) = v15;
    *(_BYTE *)(v8 + 272) = v28 | 1;
    if (v17) {
      os_release(v17);
    }
  }

  v30 = 296LL;
  if (!v11) {
    v30 = 280LL;
  }
  v31 = *(void **)(v8 + v30);
  if (!v31)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http1_stream_create";
    v65 = (char *)_os_log_send_and_compose_impl();
    aBlock[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (aBlock[0] == 17)
    {
      v66 = (os_log_s *)__nwlog_obj();
      v67 = aBlock[0];
      if (!os_log_type_enabled(v66, (os_log_type_t)aBlock[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http1_stream_create";
      v68 = "%{public}s called with null endpoint";
      goto LABEL_193;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v66 = (os_log_s *)__nwlog_obj();
      v67 = aBlock[0];
      if (!os_log_type_enabled(v66, (os_log_type_t)aBlock[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http1_stream_create";
      v68 = "%{public}s called with null endpoint, backtrace limit exceeded";
      goto LABEL_193;
    }

    v87 = (char *)__nw_create_backtrace_string();
    v66 = (os_log_s *)__nwlog_obj();
    v67 = aBlock[0];
    v88 = os_log_type_enabled(v66, (os_log_type_t)aBlock[0]);
    if (!v87)
    {
      if (!v88) {
        goto LABEL_194;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http1_stream_create";
      v68 = "%{public}s called with null endpoint, no backtrace";
      goto LABEL_193;
    }

    if (v88)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_http1_stream_create";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v87;
      _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v87);
LABEL_194:
    if (!v65) {
      goto LABEL_196;
    }
    goto LABEL_195;
  }

  if (!parameters)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http1_stream_create";
    v65 = (char *)_os_log_send_and_compose_impl();
    aBlock[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (aBlock[0] == 17)
    {
      v66 = (os_log_s *)__nwlog_obj();
      v67 = aBlock[0];
      if (!os_log_type_enabled(v66, (os_log_type_t)aBlock[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http1_stream_create";
      v68 = "%{public}s called with null parameters";
      goto LABEL_193;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v66 = (os_log_s *)__nwlog_obj();
      v67 = aBlock[0];
      if (!os_log_type_enabled(v66, (os_log_type_t)aBlock[0])) {
        goto LABEL_194;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http1_stream_create";
      v68 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_193;
    }

    v93 = (char *)__nw_create_backtrace_string();
    v66 = (os_log_s *)__nwlog_obj();
    v67 = aBlock[0];
    v94 = os_log_type_enabled(v66, (os_log_type_t)aBlock[0]);
    if (v93)
    {
      if (v94)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_http1_stream_create";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v93;
        _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v93);
      if (!v65)
      {
LABEL_196:
        v32 = 0LL;
        v45 = (uint64_t)v271;
        v52 = a1->handle;
        if (v52) {
          goto LABEL_69;
        }
LABEL_197:
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http1_get_handle_type_for_protocol";
        v109 = (char *)_os_log_send_and_compose_impl();
        aBlock[0] = 16;
        type = OS_LOG_TYPE_DEFAULT;
        if (aBlock[0] == 17)
        {
          v110 = (os_log_s *)__nwlog_obj();
          v111 = aBlock[0];
          if (!os_log_type_enabled(v110, (os_log_type_t)aBlock[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_http1_get_handle_type_for_protocol";
          v112 = "%{public}s called with null handle";
        }

        else if (type)
        {
          v113 = (char *)__nw_create_backtrace_string();
          v110 = (os_log_s *)__nwlog_obj();
          v111 = aBlock[0];
          v114 = os_log_type_enabled(v110, (os_log_type_t)aBlock[0]);
          if (v113)
          {
            if (v114)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_http1_get_handle_type_for_protocol";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v113;
              _os_log_impl( &dword_181A5C000,  v110,  v111,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v113);
            goto LABEL_211;
          }

          if (!v114)
          {
LABEL_211:
            v45 = (uint64_t)v271;
            if (v109) {
              free(v109);
            }
LABEL_213:
            if (v32) {
              goto LABEL_214;
            }
LABEL_453:
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http1_stream_add_input_handler";
            v264 = (char *)_os_log_send_and_compose_impl();
            aBlock[0] = 16;
            type = OS_LOG_TYPE_DEFAULT;
            if (aBlock[0] == 17)
            {
              v265 = (os_log_s *)__nwlog_obj();
              v266 = aBlock[0];
              if (!os_log_type_enabled(v265, (os_log_type_t)aBlock[0])) {
                goto LABEL_467;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_http1_stream_add_input_handler";
              v267 = "%{public}s called with null http1_stream";
            }

            else if (type)
            {
              v268 = (char *)__nw_create_backtrace_string();
              v265 = (os_log_s *)__nwlog_obj();
              v266 = aBlock[0];
              v269 = os_log_type_enabled(v265, (os_log_type_t)aBlock[0]);
              if (v268)
              {
                if (v269)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "nw_http1_stream_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v268;
                  _os_log_impl( &dword_181A5C000,  v265,  v266,  "%{public}s called with null http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v268);
LABEL_467:
                if (v264) {
                  free(v264);
                }
                v169 = 1;
                v170 = *(void *)(v8 + 224);
                if (!v170) {
                  return 1LL;
                }
                goto LABEL_292;
              }

              if (!v269) {
                goto LABEL_467;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_http1_stream_add_input_handler";
              v267 = "%{public}s called with null http1_stream, no backtrace";
            }

            else
            {
              v265 = (os_log_s *)__nwlog_obj();
              v266 = aBlock[0];
              if (!os_log_type_enabled(v265, (os_log_type_t)aBlock[0])) {
                goto LABEL_467;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_http1_stream_add_input_handler";
              v267 = "%{public}s called with null http1_stream, backtrace limit exceeded";
            }

            _os_log_impl(&dword_181A5C000, v265, v266, v267, buf, 0xCu);
            goto LABEL_467;
          }

          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_http1_get_handle_type_for_protocol";
          v112 = "%{public}s called with null handle, no backtrace";
        }

        else
        {
          v110 = (os_log_s *)__nwlog_obj();
          v111 = aBlock[0];
          if (!os_log_type_enabled(v110, (os_log_type_t)aBlock[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_http1_get_handle_type_for_protocol";
          v112 = "%{public}s called with null handle, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v110, v111, v112, buf, 0xCu);
        goto LABEL_211;
      }

uint64_t nw_protocol_plugin_retry_set_getting_input_frames(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
    v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
      v13 = "%{public}s called with null retry_plugin";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
          __int16 v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null retry_plugin, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_31;
      }

      if (!v15)
      {
LABEL_31:
        if (v10) {
          free(v10);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
      v13 = "%{public}s called with null retry_plugin, no backtrace";
    }

    else
    {
      v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
      v13 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_31;
  }

  char v4 = *(_BYTE *)(a1 + 212);
  if (((((v4 & 1) == 0) ^ a3) & 1) != 0) {
    return 0LL;
  }
  if (a3)
  {
    char v6 = v4 | 1;
  }

  else
  {
    if ((*(_BYTE *)(a1 + 212) & 4) != 0)
    {
      *(_BYTE *)(a1 + 212) = v4 & 0xFB;
      v8 = *(uint64_t (**)(uint64_t, void, BOOL))(a1 + 152);
      if (!v8 || (v8(a2, *(void *)(a2 + 32), *(_DWORD *)(a1 + 208) != 0) & 1) == 0) {
        nw_protocol_common_input_finished(a2, *(void *)(a2 + 32));
      }
    }

    if ((*(_BYTE *)(a1 + 212) & 2) != 0)
    {
      *(_BYTE *)(a1 + 212) &= ~2u;
      v9 = *(uint64_t (**)(uint64_t, void, BOOL))(a1 + 152);
      if (!v9 || (v9(a2, *(void *)(a2 + 32), *(_DWORD *)(a1 + 208) != 0) & 1) == 0) {
        nw_protocol_common_disconnected(a2, *(void *)(a2 + 32));
      }
    }

    char v6 = *(_BYTE *)(a1 + 212) & 0xFE;
  }

  *(_BYTE *)(a1 + 212) = v6;
  return 1LL;
}

BOOL nw_protocol_plugin_metadata_handle_eof(uint64_t a1, void *a2)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  char v3 = *(_BYTE *)(a1 + 142);
  if (*(_BYTE *)(a1 + 140) == 3 || (v3 & 0x10) != 0) {
    return (v3 & 1) == 0 || *(_BYTE *)(a1 + 140) != 2;
  }
  int v35 = -1;
  int v36 = 0;
  unsigned int v33 = 0;
  int v34 = -1;
  int v32 = 0;
  uint64_t v30 = 0LL;
  v31 = &v30;
  if (*(void *)a1)
  {
    if (gLogDatapath)
    {
      BOOL v15 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_handle_eof";
        _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, "%{public}s resuming saved input frames", buf, 0xCu);
      }
    }

    uint64_t v6 = a2[6];
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 96);
      if (v7)
      {
        *(void *)os_log_type_t type = 0LL;
        v38 = type;
        int v40 = 0;
        uint64_t v39 = 0x2000000000LL;
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
        v43 = &unk_189BB63E8;
        uint64_t v46 = a1;
        v47 = &v35;
        char v55 = 1;
        uint64_t v48 = a1;
        v49 = &v30;
        v50 = &v36;
        v51 = &v32;
        v44 = type;
        v45 = &v34;
        v52 = a2;
        uint64_t v53 = v7;
        uint64_t v54 = v6;
        uint64_t v8 = *(void *)a1;
        do
        {
          if (!v8) {
            break;
          }
          uint64_t v9 = *(void *)(v8 + 32);
          char v10 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          uint64_t v8 = v9;
        }

        while ((v10 & 1) != 0);
        unsigned int v11 = *((_DWORD *)v38 + 6);
        _Block_object_dispose(type, 8);
LABEL_14:
        unsigned int v33 = v11;
        if (v30)
        {
          **(void **)(a1 + 24) = v30;
          os_log_type_t v12 = v31;
          *(void *)(v30 + 40) = *(void *)(a1 + 24);
          *(void *)(a1 + 24) = v12;
        }

        goto LABEL_16;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
      char v16 = (const char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v41 = 0;
      if (__nwlog_fault(v16, type, &v41))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v17 = (os_log_s *)__nwlog_obj();
          os_log_type_t v18 = type[0];
          if (!os_log_type_enabled(v17, type[0])) {
            goto LABEL_48;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
          v19 = "%{public}s called with null processor";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
          goto LABEL_48;
        }

        if (!v41)
        {
          v17 = (os_log_s *)__nwlog_obj();
          os_log_type_t v18 = type[0];
          if (!os_log_type_enabled(v17, type[0])) {
            goto LABEL_48;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
          v19 = "%{public}s called with null processor, backtrace limit exceeded";
          goto LABEL_47;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        v17 = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type[0];
        BOOL v26 = os_log_type_enabled(v17, type[0]);
        if (!backtrace_string)
        {
          if (!v26) {
            goto LABEL_48;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
          v19 = "%{public}s called with null processor, no backtrace";
          goto LABEL_47;
        }

        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null processor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
      }

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3309( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  char v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    char v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v3;
  }

  *char v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

void nw_protocol_plugin_metadata_deep_copy_input_frame_array(nw_frame_array_s *a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)v24 = 0LL;
    *(void *)&v24[8] = v24;
    *(void *)&v24[16] = 0x3802000000LL;
    v25 = __Block_byref_object_copy__3159;
    BOOL v26 = __Block_byref_object_dispose__3160;
    v27[0] = 0LL;
    v27[1] = v27;
    uint64_t v2 = MEMORY[0x1895F87A8];
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 0x40000000LL;
    __int16 v20 = ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke;
    v21 = &unk_189BB6450;
    uint64_t v22 = v24;
    tqh_first = a1->tqh_first;
    do
    {
      if (!tqh_first) {
        break;
      }
      char v4 = (nw_frame *)*((void *)tqh_first + 4);
      char v5 = ((uint64_t (*)(void *))v20)(v19);
      tqh_first = v4;
    }

    while ((v5 & 1) != 0);
    if (gLogDatapath)
    {
      char v16 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&buf, 0xCu);
      }
    }

    *(void *)&__int128 buf = v2;
    *((void *)&buf + 1) = 0x40000000LL;
    v29 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3309;
    uint64_t v30 = &__block_descriptor_tmp_34_3310;
    v31 = a1;
    char v32 = 1;
    uint64_t v6 = a1->tqh_first;
    do
    {
      if (!v6) {
        break;
      }
      uint64_t v7 = (nw_frame *)*((void *)v6 + 4);
      char v8 = ((uint64_t (*)(__int128 *))v29)(&buf);
      uint64_t v6 = v7;
    }

    while ((v8 & 1) != 0);
    uint64_t v9 = *(void *)&v24[8];
    uint64_t v10 = *(void *)&v24[8] + 40LL;
    unsigned int v11 = *(nw_frame **)(*(void *)&v24[8] + 40LL);
    if (v11)
    {
      *a1->tqh_last = v11;
      *(void *)(*(void *)(v9 + 40) + 40LL) = a1->tqh_last;
      a1->tqh_last = *(nw_frame ***)(v9 + 48);
      *(void *)(v9 + 40) = 0LL;
      *(void *)(v9 + 48) = v10;
    }

    _Block_object_dispose(v24, 8);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)v24 = 136446210;
  *(void *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(buf) = 16;
  char v23 = 0;
  if (__nwlog_fault(v12, &buf, &v23))
  {
    if (buf == 17)
    {
      v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = buf;
      if (!os_log_type_enabled(v13, (os_log_type_t)buf)) {
        goto LABEL_29;
      }
      *(_DWORD *)v24 = 136446210;
      *(void *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
      BOOL v15 = "%{public}s called with null frame_array";
      goto LABEL_28;
    }

    if (!v23)
    {
      v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = buf;
      if (!os_log_type_enabled(v13, (os_log_type_t)buf)) {
        goto LABEL_29;
      }
      *(_DWORD *)v24 = 136446210;
      *(void *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
      BOOL v15 = "%{public}s called with null frame_array, backtrace limit exceeded";
      goto LABEL_28;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = (os_log_s *)__nwlog_obj();
    os_log_type_t v14 = buf;
    BOOL v18 = os_log_type_enabled(v13, (os_log_type_t)buf);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)v24 = 136446466;
        *(void *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
        *(_WORD *)&v24[12] = 2082;
        *(void *)&v24[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null frame_array, dumping backtrace:%{public}s",  v24,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_29;
    }

    if (v18)
    {
      *(_DWORD *)v24 = 136446210;
      *(void *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
      BOOL v15 = "%{public}s called with null frame_array, no backtrace";
LABEL_28:
      _os_log_impl(&dword_181A5C000, v13, v14, v15, v24, 0xCu);
    }
  }

BOOL ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  LODWORD(__size) = 0;
  uint64_t v4 = nw_frame_unclaimed_bytes(a2, &__size);
  size_t v5 = __size;
  if (!(_DWORD)__size)
  {
    uint64_t v7 = 0LL;
    goto LABEL_5;
  }

  uint64_t v6 = (const void *)v4;
  uint64_t v7 = malloc(__size);
  if (v7)
  {
LABEL_3:
    memcpy(v7, v6, v5);
LABEL_5:
    uint64_t v8 = nw_frame_create(0, (uint64_t)v7, v5, (uint64_t)nw_protocol_plugin_metadata_input_frame_finalizer, 0LL);
    nw_frame_set_buffer_used_malloc(v8, 1);
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 0x40000000LL;
    v14[2] = ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke_2;
    v14[3] = &__block_descriptor_tmp_36_3314;
    v14[4] = v8;
    v14[5] = a2;
    nw_frame_foreach_protocol_metadata(a2, 0, (uint64_t)v14);
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
    *(void *)(v8 + 32) = 0LL;
    uint64_t v10 = *(uint64_t **)(v9 + 48);
    *(void *)(v8 + 40) = v10;
    uint64_t *v10 = v8;
    *(void *)(v9 + 48) = v8 + 32;
    return 1LL;
  }

  os_log_type_t v12 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  HIDWORD(__size) = 136446466;
  char v16 = "strict_malloc";
  __int16 v17 = 2048;
  size_t v18 = v5;
  v13 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    size_t v5 = __size;
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

void nw_protocol_plugin_metadata_input_frame_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_frame_free_buffer((uint64_t)a1);
    nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
    os_release(a1);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
      uint64_t v7 = "%{public}s called with null frame";
      goto LABEL_16;
    }

    if (!v10)
    {
      size_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
      uint64_t v7 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_16;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446466;
        v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
        __int16 v14 = 2082;
        BOOL v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_17;
    }

    if (v9)
    {
      *(_DWORD *)__int128 buf = 136446210;
      v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
      uint64_t v7 = "%{public}s called with null frame, no backtrace";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

uint64_t ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke_2( uint64_t a1, nw_protocol_metadata *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int is_metadata_complete = nw_frame_is_metadata_complete(*(void *)(a1 + 40));
  nw_frame_set_metadata(v3, a2, 0, is_metadata_complete);
  return 1LL;
}

uint64_t nw_protocol_plugin_metadata_finalize_output_frames(uint64_t a1, void *a2)
{
  uint64_t v77 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    char v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v57[0]) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v57[0]))
      {
        unsigned int v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      BOOL v20 = os_log_type_enabled(v11, type[0]);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      if (!v20) {
        goto LABEL_54;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_53;
    }

    unsigned int v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type[0];
    if (!os_log_type_enabled(v11, type[0])) {
      goto LABEL_77;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v13 = "%{public}s called with null protocol";
LABEL_76:
    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_77;
  }

  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    char v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v57[0]) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v57[0]))
      {
        unsigned int v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      BOOL v22 = os_log_type_enabled(v11, type[0]);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      if (!v22) {
        goto LABEL_54;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      v21 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_53;
    }

    unsigned int v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type[0];
    if (!os_log_type_enabled(v11, type[0])) {
      goto LABEL_77;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v13 = "%{public}s called with null protocol->handle";
    goto LABEL_76;
  }

  uint64_t v4 = *(void *)(v3 + 72);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    char v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v57[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      if (!os_log_type_enabled(v11, type[0])) {
        goto LABEL_77;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      v13 = "%{public}s called with null metadata_plugin";
      goto LABEL_76;
    }

    if (!LOBYTE(v57[0]))
    {
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type[0];
    BOOL v23 = os_log_type_enabled(v11, type[0]);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null metadata_plugin, no backtrace";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    if (!v23) {
      goto LABEL_54;
    }
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    v21 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
LABEL_53:
    _os_log_impl(&dword_181A5C000, v11, v12, v21, buf, 0x16u);
    goto LABEL_54;
  }

  if (a2)
  {
    unsigned int v58 = 0;
    v57[0] = 0LL;
    v57[1] = v57;
    if (*a2)
    {
      **(void **)(v4 + 40) = *a2;
      *(void *)(*a2 + 40LL) = *(void *)(v4 + 40);
      *(void *)(v4 + 40) = a2[1];
      *a2 = 0LL;
      a2[1] = a2;
    }

    if (!*(void *)(v4 + 32))
    {
LABEL_87:
      int v9 = 0;
      if (!v57[0])
      {
LABEL_98:
        nw_protocol_plugin_metadata_report_transfer(v4, a1, *(void *)(v4 + 64), v58, 0LL);
        return 1LL;
      }

void nw_protocol_plugin_metadata_output_available(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v47 = "nw_protocol_plugin_metadata_output_available";
    uint64_t v5 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null protocol";
      goto LABEL_129;
    }

    if (v45 == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_129;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v31 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v31) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_129;
    }

    if (!v31) {
      goto LABEL_102;
    }
    *(_DWORD *)__int128 buf = 136446466;
    v47 = "nw_protocol_plugin_metadata_output_available";
    __int16 v48 = 2082;
    v49 = backtrace_string;
    char v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_101:
    _os_log_impl(&dword_181A5C000, v20, v21, v32, buf, 0x16u);
    goto LABEL_102;
  }

  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v47 = "nw_protocol_plugin_metadata_output_available";
    uint64_t v5 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null protocol->handle";
      goto LABEL_129;
    }

    if (v45 == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_129;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v33 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v33) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null protocol->handle, no backtrace";
      goto LABEL_129;
    }

    if (!v33) {
      goto LABEL_102;
    }
    *(_DWORD *)__int128 buf = 136446466;
    v47 = "nw_protocol_plugin_metadata_output_available";
    __int16 v48 = 2082;
    v49 = backtrace_string;
    char v32 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
    goto LABEL_101;
  }

  uint64_t v3 = *(void *)(v2 + 72);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v47 = "nw_protocol_plugin_metadata_output_available";
    uint64_t v5 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null metadata_plugin";
      goto LABEL_129;
    }

    if (v45 == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_129;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v34 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v34) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null metadata_plugin, no backtrace";
      goto LABEL_129;
    }

    if (!v34) {
      goto LABEL_102;
    }
    *(_DWORD *)__int128 buf = 136446466;
    v47 = "nw_protocol_plugin_metadata_output_available";
    __int16 v48 = 2082;
    v49 = backtrace_string;
    char v32 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
    goto LABEL_101;
  }

  if (gLogDatapath)
  {
    BOOL v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  *(void *)os_log_type_t type = 0LL;
  v43 = type;
  nw_protocol_plugin_metadata_finalize_output_frames(a1, type);
  if (*(void *)(v3 + 32)) {
    return;
  }
  uint64_t v4 = *(void *)(v3 + 128);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v47 = "nw_protocol_plugin_metadata_output_available";
    uint64_t v5 = _os_log_send_and_compose_impl();
    os_log_type_t v45 = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (v45 == OS_LOG_TYPE_FAULT)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = v45;
      if (!os_log_type_enabled(v20, v45)) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null metadata_plugin->protocol";
      goto LABEL_129;
    }

    if (!v44)
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = v45;
      if (!os_log_type_enabled(v20, v45)) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null metadata_plugin->protocol, backtrace limit exceeded";
      goto LABEL_129;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = v45;
    BOOL v38 = os_log_type_enabled(v20, v45);
    if (!backtrace_string)
    {
      if (!v38) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v47 = "nw_protocol_plugin_metadata_output_available";
      BOOL v22 = "%{public}s called with null metadata_plugin->protocol, no backtrace";
      goto LABEL_129;
    }

    if (v38)
    {
      *(_DWORD *)__int128 buf = 136446466;
      v47 = "nw_protocol_plugin_metadata_output_available";
      __int16 v48 = 2082;
      v49 = backtrace_string;
      char v32 = "%{public}s called with null metadata_plugin->protocol, dumping backtrace:%{public}s";
      goto LABEL_101;
    }

void nw_protocol_plugin_metadata_resume_input(uint64_t a1, int a2)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v45 = "nw_protocol_plugin_metadata_resume_input";
    uint64_t v6 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin";
      goto LABEL_104;
    }

    if (!v42)
    {
      os_log_type_t v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v36 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_105;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin, no backtrace";
      goto LABEL_104;
    }

    if (v36)
    {
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v45 = "nw_protocol_plugin_metadata_resume_input";
      __int16 v46 = 2082;
      v47 = backtrace_string;
      v37 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
LABEL_78:
      _os_log_impl(&dword_181A5C000, v27, v28, v37, buf, 0x16u);
    }

void nw_protocol_plugin_metadata_prepare_for_reissue(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (gLogDatapath)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s discarding pending input and output",  buf,  0xCu);
      }
    }

    char v2 = *(_BYTE *)(a1 + 142);
    *(_DWORD *)(a1 + 136) = 0;
    *(_BYTE *)(a1 + 142) = v2 & 0xE2;
    *(_BYTE *)(a1 + 141) = 3;
    if (gLogDatapath)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }

    *(void *)__int128 buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3309;
    uint64_t v17 = &__block_descriptor_tmp_34_3310;
    uint64_t v18 = a1 + 16;
    char v19 = 0;
    uint64_t v3 = *(void *)(a1 + 16);
    do
    {
      if (!v3) {
        break;
      }
      uint64_t v4 = *(void *)(v3 + 32);
      char v5 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      uint64_t v3 = v4;
    }

    while ((v5 & 1) != 0);
    nw_protocol_plugin_metadata_resume_input(a1, 3);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v6, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
      uint64_t v9 = "%{public}s called with null metadata_plugin";
      goto LABEL_26;
    }

    if (!v14)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
      uint64_t v9 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_26;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_27;
    }

    if (v13)
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
      uint64_t v9 = "%{public}s called with null metadata_plugin, no backtrace";
LABEL_26:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

void nw_protocol_plugin_metadata_reset(uint64_t *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v17 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v21) = 136446210;
      *(void *)((char *)&v21 + 4) = "nw_protocol_plugin_metadata_reset";
      _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v21, 0xCu);
    }

    if (gLogDatapath)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v27 = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }
  }

  uint64_t v2 = MEMORY[0x1895F87A8];
  *(void *)&__int128 v21 = MEMORY[0x1895F87A8];
  *((void *)&v21 + 1) = 0x40000000LL;
  BOOL v22 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3309;
  BOOL v23 = &__block_descriptor_tmp_34_3310;
  os_log_type_t v24 = a1;
  char v25 = 0;
  uint64_t v3 = *a1;
  do
  {
    if (!v3) {
      break;
    }
    uint64_t v4 = *(void *)(v3 + 32);
    char v5 = ((uint64_t (*)(__int128 *))v22)(&v21);
    uint64_t v3 = v4;
  }

  while ((v5 & 1) != 0);
  if (gLogDatapath)
  {
    char v19 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v21) = 136446210;
      *(void *)((char *)&v21 + 4) = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v21, 0xCu);
    }
  }

  *(void *)&__int128 v21 = v2;
  *((void *)&v21 + 1) = 0x40000000LL;
  BOOL v22 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3309;
  BOOL v23 = &__block_descriptor_tmp_34_3310;
  os_log_type_t v24 = a1 + 2;
  char v25 = 0;
  uint64_t v6 = a1[2];
  do
  {
    if (!v6) {
      break;
    }
    uint64_t v7 = *(void *)(v6 + 32);
    char v8 = ((uint64_t (*)(__int128 *))v22)(&v21);
    uint64_t v6 = v7;
  }

  while ((v8 & 1) != 0);
  if (gLogDatapath)
  {
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v21) = 136446210;
      *(void *)((char *)&v21 + 4) = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v21, 0xCu);
    }
  }

  *(void *)&__int128 v21 = v2;
  *((void *)&v21 + 1) = 0x40000000LL;
  BOOL v22 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3309;
  BOOL v23 = &__block_descriptor_tmp_34_3310;
  os_log_type_t v24 = a1 + 4;
  char v25 = 0;
  uint64_t v9 = a1[4];
  do
  {
    if (!v9) {
      break;
    }
    uint64_t v10 = *(void *)(v9 + 32);
    char v11 = ((uint64_t (*)(__int128 *))v22)(&v21);
    uint64_t v9 = v10;
  }

  while ((v11 & 1) != 0);
  char v12 = *((_BYTE *)a1 + 56);
  if ((v12 & 1) != 0)
  {
    BOOL v13 = (void *)a1[6];
    if (v13)
    {
      os_release(v13);
      char v12 = *((_BYTE *)a1 + 56);
    }
  }

  a1[6] = 0LL;
  *((_BYTE *)a1 + 56) = v12 | 1;
  char v14 = *((_BYTE *)a1 + 72);
  if ((v14 & 1) != 0)
  {
    BOOL v15 = (void *)a1[8];
    if (v15)
    {
      os_release(v15);
      char v14 = *((_BYTE *)a1 + 72);
    }
  }

  a1[8] = 0LL;
  *((_BYTE *)a1 + 72) = v14 | 1;
  char v16 = *((_BYTE *)a1 + 142);
  *((_DWORD *)a1 + 34) = 0;
  *((_BYTE *)a1 + 142) = v16 & 0xE2;
  *((_WORD *)a1 + 70) = 2;
}

void nw_protocol_plugin_metadata_set_callbacks(uint64_t a1, void *object, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        char v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_91;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (!v18) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_91;
      }

      if (v18)
      {
        *(_DWORD *)__int128 buf = 136446466;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        __int16 v30 = 2082;
        BOOL v31 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_92:
      if (v13) {
        goto LABEL_93;
      }
      return;
    }

    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    char v16 = "%{public}s called with null protocol";
    goto LABEL_91;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        char v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_91;
      }

      char v19 = (char *)__nw_create_backtrace_string();
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v20 = os_log_type_enabled(v14, type);
      if (!v19)
      {
        if (!v20) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_91;
      }

      if (!v20) {
        goto LABEL_65;
      }
      *(_DWORD *)__int128 buf = 136446466;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      __int16 v30 = 2082;
      BOOL v31 = v19;
      __int128 v21 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_64;
    }

    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    char v16 = "%{public}s called with null protocol->handle";
LABEL_91:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_92;
  }

  uint64_t v6 = *(void *)(v5 + 72);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        char v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
        goto LABEL_91;
      }

      char v19 = (char *)__nw_create_backtrace_string();
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (!v19)
      {
        if (!v22) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null metadata_plugin, no backtrace";
        goto LABEL_91;
      }

      if (!v22) {
        goto LABEL_65;
      }
      *(_DWORD *)__int128 buf = 136446466;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      __int16 v30 = 2082;
      BOOL v31 = v19;
      __int128 v21 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
      goto LABEL_64;
    }

    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    char v16 = "%{public}s called with null metadata_plugin";
    goto LABEL_91;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        char v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null input_processor, backtrace limit exceeded";
        goto LABEL_91;
      }

      char v19 = (char *)__nw_create_backtrace_string();
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v23 = os_log_type_enabled(v14, type);
      if (!v19)
      {
        if (!v23) {
          goto LABEL_92;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        char v16 = "%{public}s called with null input_processor, no backtrace";
        goto LABEL_91;
      }

      if (!v23) {
        goto LABEL_65;
      }
      *(_DWORD *)__int128 buf = 136446466;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      __int16 v30 = 2082;
      BOOL v31 = v19;
      __int128 v21 = "%{public}s called with null input_processor, dumping backtrace:%{public}s";
      goto LABEL_64;
    }

    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    char v16 = "%{public}s called with null input_processor";
    goto LABEL_91;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      char v16 = "%{public}s called with null output_processor";
      goto LABEL_91;
    }

    if (!v26)
    {
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      char v16 = "%{public}s called with null output_processor, backtrace limit exceeded";
      goto LABEL_91;
    }

    char v19 = (char *)__nw_create_backtrace_string();
    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v24 = os_log_type_enabled(v14, type);
    if (!v19)
    {
      if (!v24) {
        goto LABEL_92;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      char v16 = "%{public}s called with null output_processor, no backtrace";
      goto LABEL_91;
    }

    if (!v24) {
      goto LABEL_65;
    }
    *(_DWORD *)__int128 buf = 136446466;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    __int16 v30 = 2082;
    BOOL v31 = v19;
    __int128 v21 = "%{public}s called with null output_processor, dumping backtrace:%{public}s";
LABEL_64:
    _os_log_impl(&dword_181A5C000, v14, v15, v21, buf, 0x16u);
    goto LABEL_65;
  }

  uint64_t v9 = *(void **)(a1 + 24);
  if (v9)
  {
    if (object)
    {
      uint64_t v10 = os_retain(object);
      char v11 = *(_BYTE *)(v6 + 88);
      if ((v11 & 1) == 0) {
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v10 = 0LL;
      char v11 = *(_BYTE *)(v6 + 88);
      if ((v11 & 1) == 0)
      {
LABEL_13:
        *(void *)(v6 + 80) = v10;
        *(_BYTE *)(v6 + 88) = v11 | 1;
        *(void *)(v6 + 96) = a3;
        *(void *)(v6 + 104) = a4;
        *(void *)(v6 + 128) = a1;
        v9[12] = nw_protocol_plugin_metadata_finalize_output_frames;
        v9[9] = nw_protocol_plugin_metadata_output_available;
        v9[10] = nw_protocol_plugin_metadata_get_input_frames;
        v9[4] = nw_protocol_plugins_disconnect;
        v9[5] = nw_protocol_plugins_connected;
        v9[23] = nw_protocol_plugins_input_finished;
        v9[6] = nw_protocol_plugins_disconnected;
        v9[7] = nw_protocol_plugins_error;
        v9[20] = nw_protocol_plugins_notify;
        v9[32] = nw_protocol_plugins_reset;
        return;
      }
    }

    char v12 = *(void **)(v6 + 80);
    if (v12)
    {
      os_release(v12);
      char v11 = *(_BYTE *)(v6 + 88);
    }

    goto LABEL_13;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  v29 = "nw_protocol_plugin_metadata_set_callbacks";
  BOOL v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    char v16 = "%{public}s called with null callbacks";
    goto LABEL_91;
  }

  if (!v26)
  {
    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    char v16 = "%{public}s called with null callbacks, backtrace limit exceeded";
    goto LABEL_91;
  }

  char v19 = (char *)__nw_create_backtrace_string();
  char v14 = (os_log_s *)__nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v25 = os_log_type_enabled(v14, type);
  if (!v19)
  {
    if (!v25) {
      goto LABEL_92;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    char v16 = "%{public}s called with null callbacks, no backtrace";
    goto LABEL_91;
  }

  if (v25)
  {
    *(_DWORD *)__int128 buf = 136446466;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    __int16 v30 = 2082;
    BOOL v31 = v19;
    __int128 v21 = "%{public}s called with null callbacks, dumping backtrace:%{public}s";
    goto LABEL_64;
  }

void nw_protocol_plugins_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v136 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v129 = "nw_protocol_plugins_disconnect";
    v71 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v126 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v72 = (os_log_s *)__nwlog_obj();
      os_log_type_t v73 = type;
      if (!os_log_type_enabled(v72, type)) {
        goto LABEL_265;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v129 = "nw_protocol_plugins_disconnect";
      uint64_t v74 = "%{public}s called with null protocol";
    }

    else if (v126)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v72 = (os_log_s *)__nwlog_obj();
      os_log_type_t v73 = type;
      BOOL v85 = os_log_type_enabled(v72, type);
      if (backtrace_string)
      {
        if (v85)
        {
          *(_DWORD *)__int128 buf = 136446466;
          v129 = "nw_protocol_plugins_disconnect";
          __int16 v130 = 2082;
          v131 = (nw_protocol *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_265:
        if (!v71) {
          return;
        }
        goto LABEL_266;
      }

      if (!v85) {
        goto LABEL_265;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v129 = "nw_protocol_plugins_disconnect";
      uint64_t v74 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      v72 = (os_log_s *)__nwlog_obj();
      os_log_type_t v73 = type;
      if (!os_log_type_enabled(v72, type)) {
        goto LABEL_265;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v129 = "nw_protocol_plugins_disconnect";
      uint64_t v74 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_264;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v129 = "nw_protocol_plugins_disconnect";
    v71 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v126 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v126)
      {
        v72 = (os_log_s *)__nwlog_obj();
        os_log_type_t v73 = type;
        if (!os_log_type_enabled(v72, type)) {
          goto LABEL_265;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v129 = "nw_protocol_plugins_disconnect";
        uint64_t v74 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_264;
      }

      v86 = (char *)__nw_create_backtrace_string();
      v72 = (os_log_s *)__nwlog_obj();
      os_log_type_t v73 = type;
      BOOL v87 = os_log_type_enabled(v72, type);
      if (!v86)
      {
        if (!v87) {
          goto LABEL_265;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v129 = "nw_protocol_plugins_disconnect";
        uint64_t v74 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_264;
      }

      if (v87)
      {
        *(_DWORD *)__int128 buf = 136446466;
        v129 = "nw_protocol_plugins_disconnect";
        __int16 v130 = 2082;
        v131 = (nw_protocol *)v86;
        v88 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
LABEL_185:
        _os_log_impl(&dword_181A5C000, v72, v73, v88, buf, 0x16u);
      }

LABEL_313:
      if (!output_handler) {
        goto LABEL_27;
      }
      goto LABEL_145;
    }
  }

    if (v122) {
      free(v122);
    }
    if (*(void *)type) {
      goto LABEL_316;
    }
    goto LABEL_318;
  }

          os_release(v19);
          goto LABEL_314;
        }

        if (type[0] == 17)
        {
          v206 = (os_log_s *)__nwlog_obj();
          v207 = type[0];
          if (os_log_type_enabled(v206, (os_log_type_t)type[0]))
          {
            v208 = *(void *)(a1 + 48);
            v209 = "invalid";
            if (v208)
            {
              v210 = *(const char **)(v208 + 16);
              if (v210) {
                v209 = v210;
              }
            }

            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v209;
            _os_log_impl( &dword_181A5C000,  v206,  v207,  "%{public}s protocol %{public}s has invalid disconnected callback",  buf,  0x16u);
          }

          goto LABEL_440;
        }

        v372 = v17;
        if ((_BYTE)v413)
        {
          v218 = (char *)__nw_create_backtrace_string();
          v219 = (os_log_s *)__nwlog_obj();
          v220 = type[0];
          v221 = os_log_type_enabled(v219, (os_log_type_t)type[0]);
          if (v218)
          {
            if (v221)
            {
              v222 = *(void *)(a1 + 48);
              v223 = "invalid";
              if (v222)
              {
                v224 = *(const char **)(v222 + 16);
                if (v224) {
                  v223 = v224;
                }
              }

              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v223;
              *(_WORD *)&buf[22] = 2082;
              v427 = (__n128 (*)(uint64_t, uint64_t))v218;
              _os_log_impl( &dword_181A5C000,  v219,  v220,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v218);
            goto LABEL_439;
          }

          uint64_t v17 = v372;
          if (!v221) {
            goto LABEL_440;
          }
          v285 = *(void *)(a1 + 48);
          v286 = "invalid";
          if (v285)
          {
            v287 = *(const char **)(v285 + 16);
            if (v287) {
              v286 = v287;
            }
          }

          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v286;
          v241 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
        }

        else
        {
          v219 = (os_log_s *)__nwlog_obj();
          v220 = type[0];
          if (!os_log_type_enabled(v219, (os_log_type_t)type[0])) {
            goto LABEL_440;
          }
          v238 = *(void *)(a1 + 48);
          v239 = "invalid";
          if (v238)
          {
            v240 = *(const char **)(v238 + 16);
            if (v240) {
              v239 = v240;
            }
          }

          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v239;
          v241 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v219, v220, v241, buf, 0x16u);
LABEL_439:
        uint64_t v17 = v372;
        goto LABEL_440;
      }

      if (type[0] == 17)
      {
        v197 = (os_log_s *)__nwlog_obj();
        v198 = type[0];
        if (os_log_type_enabled(v197, (os_log_type_t)type[0]))
        {
          v199 = *(void *)(a1 + 48);
          v200 = "invalid";
          if (v199)
          {
            v201 = *(const char **)(v199 + 16);
            if (v201) {
              v200 = v201;
            }
          }

          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v200;
          _os_log_impl( &dword_181A5C000,  v197,  v198,  "%{public}s protocol %{public}s has invalid error callback",  buf,  0x16u);
        }

        goto LABEL_431;
      }

      v371 = v17;
      if ((_BYTE)v413)
      {
        v211 = (char *)__nw_create_backtrace_string();
        v212 = (os_log_s *)__nwlog_obj();
        v213 = type[0];
        v214 = os_log_type_enabled(v212, (os_log_type_t)type[0]);
        if (v211)
        {
          if (v214)
          {
            v215 = *(void *)(a1 + 48);
            v216 = "invalid";
            if (v215)
            {
              v217 = *(const char **)(v215 + 16);
              if (v217) {
                v216 = v217;
              }
            }

            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v216;
            *(_WORD *)&buf[22] = 2082;
            v427 = (__n128 (*)(uint64_t, uint64_t))v211;
            _os_log_impl( &dword_181A5C000,  v212,  v213,  "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v211);
          goto LABEL_430;
        }

        uint64_t v17 = v371;
        if (!v214) {
          goto LABEL_431;
        }
        v282 = *(void *)(a1 + 48);
        v283 = "invalid";
        if (v282)
        {
          v284 = *(const char **)(v282 + 16);
          if (v284) {
            v283 = v284;
          }
        }

        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v283;
        v237 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
      }

      else
      {
        v212 = (os_log_s *)__nwlog_obj();
        v213 = type[0];
        if (!os_log_type_enabled(v212, (os_log_type_t)type[0])) {
          goto LABEL_431;
        }
        v234 = *(void *)(a1 + 48);
        v235 = "invalid";
        if (v234)
        {
          v236 = *(const char **)(v234 + 16);
          if (v236) {
            v235 = v236;
          }
        }

        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v235;
        v237 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v212, v213, v237, buf, 0x16u);
LABEL_430:
      uint64_t v17 = v371;
      goto LABEL_431;
    }

    if ((*(_WORD *)(*(void *)(a1 + 336) + 1373LL) & 1) == 0)
    {
      BOOL v20 = nw_http_metadata_copy_request(v18);
      if (!v20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
        __int128 v21 = (char *)_os_log_send_and_compose_impl();
        type[0] = 16;
        LOBYTE(v413) = 0;
        if (type[0] == 17)
        {
          BOOL v22 = (os_log_s *)__nwlog_obj();
          BOOL v23 = type[0];
          if (!os_log_type_enabled(v22, (os_log_type_t)type[0])) {
            goto LABEL_190;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          BOOL v24 = "%{public}s did not find request on frame";
        }

        else if ((_BYTE)v413)
        {
          v370 = v17;
          BOOL v87 = (char *)__nw_create_backtrace_string();
          BOOL v22 = (os_log_s *)__nwlog_obj();
          BOOL v23 = type[0];
          v88 = os_log_type_enabled(v22, (os_log_type_t)type[0]);
          if (v87)
          {
            if (v88)
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v87;
              _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s did not find request on frame, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v87);
            uint64_t v17 = v370;
            goto LABEL_190;
          }

          uint64_t v17 = v370;
          if (!v88)
          {
LABEL_190:
            if (v21) {
              free(v21);
            }
            goto LABEL_198;
          }

          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          BOOL v24 = "%{public}s did not find request on frame, no backtrace";
        }

        else
        {
          BOOL v22 = (os_log_s *)__nwlog_obj();
          BOOL v23 = type[0];
          if (!os_log_type_enabled(v22, (os_log_type_t)type[0])) {
            goto LABEL_190;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
          BOOL v24 = "%{public}s did not find request on frame, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
        goto LABEL_190;
      }

    if (v145) {
      free(v145);
    }
    goto LABEL_349;
  }

  v142 = v402[3];
  if (!v142)
  {
    __nwlog_obj();
    v152 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v413 = 136446210;
    v414 = "nw_agent_get_error_for_message";
    v153 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v405 = 0;
    if (__nwlog_fault(v153, &type, &v405))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v154 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v155 = type;
        if (os_log_type_enabled(v154, type))
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_get_error_for_message";
          _os_log_impl(&dword_181A5C000, v154, v155, "%{public}s called with null message", v413, 0xCu);
        }
      }

      else
      {
        if (v405)
        {
          v156 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v157 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v158 = type;
          v159 = os_log_type_enabled(v157, type);
          if (v156)
          {
            if (v159)
            {
              *(_DWORD *)v413 = 136446466;
              v414 = "nw_agent_get_error_for_message";
              v415 = 2082;
              v416 = v156;
              _os_log_impl( &dword_181A5C000,  v157,  v158,  "%{public}s called with null message, dumping backtrace:%{public}s",  v413,  0x16u);
            }

            free(v156);
          }

          else
          {
            if (v159)
            {
              *(_DWORD *)v413 = 136446210;
              v414 = "nw_agent_get_error_for_message";
              _os_log_impl( &dword_181A5C000,  v157,  v158,  "%{public}s called with null message, no backtrace",  v413,  0xCu);
            }
          }

          goto LABEL_345;
        }

        __nwlog_obj();
        v154 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v164 = type;
        if (os_log_type_enabled(v154, type))
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_get_error_for_message";
          _os_log_impl( &dword_181A5C000,  v154,  v164,  "%{public}s called with null message, backtrace limit exceeded",  v413,  0xCu);
        }
      }
    }

void nw_protocol_plugins_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_protocol_plugins_connected";
    char v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_plugins_connected";
      char v11 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v25 = "nw_protocol_plugins_connected";
          __int16 v26 = 2082;
          os_log_type_t v27 = (nw_protocol *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_63:
        if (!v8) {
          return;
        }
        goto LABEL_64;
      }

      if (!v17) {
        goto LABEL_63;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_plugins_connected";
      char v11 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_protocol_plugins_connected";
      char v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_62;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_protocol_plugins_connected";
    char v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_63;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v25 = "nw_protocol_plugins_connected";
        char v11 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_62;
      }

      BOOL v18 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v19 = os_log_type_enabled(v9, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_63;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v25 = "nw_protocol_plugins_connected";
        char v11 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_62;
      }

      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v25 = "nw_protocol_plugins_connected";
        __int16 v26 = 2082;
        os_log_type_t v27 = (nw_protocol *)v18;
        BOOL v20 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
LABEL_47:
        _os_log_impl(&dword_181A5C000, v9, v10, v20, buf, 0x16u);
      }

void nw_protocol_plugins_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v34 = "nw_protocol_plugins_input_finished";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_input_finished";
      char v16 = "%{public}s called with null protocol";
      goto LABEL_77;
    }

    if (!v31)
    {
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_input_finished";
      char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v24) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_input_finished";
      char v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_77;
    }

    if (v24)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v34 = "nw_protocol_plugins_input_finished";
      __int16 v35 = 2082;
      BOOL v36 = (nw_protocol_identifier *)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_78:
    if (!v13) {
      return;
    }
    goto LABEL_79;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v34 = "nw_protocol_plugins_input_finished";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_input_finished";
      char v16 = "%{public}s called with null protocol->handle";
      goto LABEL_77;
    }

    if (!v31)
    {
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_input_finished";
      char v16 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_77;
    }

    BOOL v25 = (char *)__nw_create_backtrace_string();
    char v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v26 = os_log_type_enabled(v14, type);
    if (v25)
    {
      if (v26)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v34 = "nw_protocol_plugins_input_finished";
        __int16 v35 = 2082;
        BOOL v36 = (nw_protocol_identifier *)v25;
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null protocol->handle, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v25);
      if (!v13) {
        return;
      }
LABEL_79:
      free(v13);
      return;
    }

    if (v26)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_input_finished";
      char v16 = "%{public}s called with null protocol->handle, no backtrace";
LABEL_77:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      goto LABEL_78;
    }

    goto LABEL_78;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v34 = "nw_protocol_plugins_handle_input_finished";
    BOOL v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_handle_input_finished";
      BOOL v20 = "%{public}s called with null other_protocol";
    }

    else if (v31)
    {
      os_log_type_t v27 = (char *)__nw_create_backtrace_string();
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v28 = os_log_type_enabled(v18, type);
      if (v27)
      {
        if (v28)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v34 = "nw_protocol_plugins_handle_input_finished";
          __int16 v35 = 2082;
          BOOL v36 = (nw_protocol_identifier *)v27;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v27);
        goto LABEL_83;
      }

      if (!v28)
      {
LABEL_83:
        if (v17) {
          free(v17);
        }
        goto LABEL_16;
      }

      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_handle_input_finished";
      BOOL v20 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      BOOL v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugins_handle_input_finished";
      BOOL v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
    goto LABEL_83;
  }

  if (gLogDatapath)
  {
    BOOL v21 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      identifier = a1->identifier;
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v34 = "nw_protocol_plugins_handle_input_finished";
      __int16 v35 = 2080;
      BOOL v36 = identifier;
      __int16 v37 = 2048;
      os_log_type_t v38 = a1;
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
    }
  }

  uint64_t v5 = handle[11];
  if (v5 && (*(_BYTE *)(v5 + 212) & 0x20) != 0) {
    return;
  }
  uint64_t v6 = handle[9];
  if (!v6) {
    goto LABEL_11;
  }
  char v7 = *(_BYTE *)(v6 + 142);
  if ((v7 & 2) != 0)
  {
LABEL_21:
    *(_BYTE *)(v6 + 142) = v7 | 4;
    if (gLogDatapath)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v29 = (nw_protocol_identifier *)"invalid";
        if (a1->identifier) {
          v29 = a1->identifier;
        }
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v34 = "nw_protocol_plugins_handle_input_finished";
        __int16 v35 = 2080;
        BOOL v36 = v29;
        char v12 = "%{public}s metadata plugin for %s caused input_finished to defer input_finished";
        goto LABEL_66;
      }
    }

    return;
  }

  if (!nw_protocol_plugin_metadata_handle_eof(handle[9], a1))
  {
    char v7 = *(_BYTE *)(v6 + 142);
    goto LABEL_21;
  }

  uint64_t v5 = handle[11];
LABEL_11:
  if (!v5)
  {
LABEL_16:
    nw_protocol_common_input_finished((uint64_t)a1, (uint64_t)a2);
    return;
  }

  if ((*(_BYTE *)(v5 + 212) & 0x10) != 0)
  {
    if (!gLogDatapath) {
      return;
    }
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v34 = "nw_protocol_plugin_retry_input_finished";
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s holding onto input_finished because reissuing",  buf,  0xCu);
    }
  }

  else if ((*(_BYTE *)(v5 + 212) & 1) != 0)
  {
    if (gLogDatapath)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v34 = "nw_protocol_plugin_retry_input_finished";
        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s holding onto input_finished because getting input frames",  buf,  0xCu);
      }
    }

    *(_BYTE *)(v5 + 212) |= 4u;
  }

  else
  {
    char v8 = *(unsigned int (**)(nw_protocol *, nw_protocol *, BOOL))(v5 + 152);
    if (!v8 || !v8(a1, a2, *(_DWORD *)(v5 + 208) != 0)) {
      goto LABEL_16;
    }
  }

  if (gLogDatapath)
  {
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      char v11 = (nw_protocol_identifier *)"invalid";
      if (a1->identifier) {
        char v11 = a1->identifier;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v34 = "nw_protocol_plugins_handle_input_finished";
      __int16 v35 = 2080;
      BOOL v36 = v11;
      char v12 = "%{public}s retry plugin for %s caused input_finished to defer input_finished";
LABEL_66:
      _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, v12, buf, 0x16u);
    }
  }

void nw_protocol_plugins_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugins_disconnected";
    BOOL v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugins_disconnected";
      BOOL v23 = "%{public}s called with null protocol";
    }

    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v31 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugins_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_89:
        if (!v20) {
          return;
        }
LABEL_90:
        free(v20);
        return;
      }

      if (!v31) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugins_disconnected";
      BOOL v23 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugins_disconnected";
      BOOL v23 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_plugins_error(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v31 = "nw_protocol_plugins_error";
    char v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_error";
      char v14 = "%{public}s called with null protocol";
      goto LABEL_60;
    }

    if (!v28)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_error";
      char v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_60;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v22) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_error";
      char v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_60;
    }

    if (v22)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v31 = "nw_protocol_plugins_error";
      __int16 v32 = 2082;
      BOOL v33 = (nw_protocol_identifier *)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_61:
    if (!v11) {
      return;
    }
    goto LABEL_62;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v31 = "nw_protocol_plugins_error";
    char v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_error";
      char v14 = "%{public}s called with null protocol->handle";
      goto LABEL_60;
    }

    if (!v28)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_error";
      char v14 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_60;
    }

    BOOL v23 = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v24 = os_log_type_enabled(v12, type);
    if (v23)
    {
      if (v24)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v31 = "nw_protocol_plugins_error";
        __int16 v32 = 2082;
        BOOL v33 = (nw_protocol_identifier *)v23;
        _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null protocol->handle, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v23);
      if (!v11) {
        return;
      }
LABEL_62:
      free(v11);
      return;
    }

    if (v24)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_error";
      char v14 = "%{public}s called with null protocol->handle, no backtrace";
LABEL_60:
      _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      goto LABEL_61;
    }

    goto LABEL_61;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v31 = "nw_protocol_plugins_handle_error";
    char v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_handle_error";
      BOOL v18 = "%{public}s called with null other_protocol";
    }

    else if (v28)
    {
      BOOL v25 = (char *)__nw_create_backtrace_string();
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v26 = os_log_type_enabled(v16, type);
      if (v25)
      {
        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v31 = "nw_protocol_plugins_handle_error";
          __int16 v32 = 2082;
          BOOL v33 = (nw_protocol_identifier *)v25;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v25);
        goto LABEL_66;
      }

      if (!v26)
      {
LABEL_66:
        if (v15) {
          free(v15);
        }
        goto LABEL_14;
      }

      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_handle_error";
      BOOL v18 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v31 = "nw_protocol_plugins_handle_error";
      BOOL v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
    goto LABEL_66;
  }

  if (gLogDatapath)
  {
    char v19 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      identifier = a1->identifier;
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v31 = "nw_protocol_plugins_handle_error";
      __int16 v32 = 2080;
      BOOL v33 = identifier;
      __int16 v34 = 2048;
      BOOL v35 = a1;
      _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
    }
  }

  uint64_t v7 = handle[11];
  if (!v7
    || (*(_BYTE *)(v7 + 212) & 0x20) == 0
    && (*(unsigned int (**)(nw_protocol *, nw_protocol *, uint64_t))(v7 + 144))(a1, a2, a3))
  {
    uint64_t v8 = handle[9];
    if (v8 && (*(_BYTE *)(v8 + 142) & 2) != 0)
    {
      *(_DWORD *)(v8 + 136) = a3;
    }

    else
    {
      uint64_t v9 = handle[11];
      if (!v9)
      {
LABEL_14:
        nw_protocol_common_error((uint64_t)a1, (uint64_t)a2);
        return;
      }

      *(_DWORD *)(v9 + 176) = a3;
      if ((*(_BYTE *)(v9 + 212) & 0x10) != 0)
      {
        if (gLogDatapath)
        {
          os_log_type_t v27 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446210;
            BOOL v31 = "nw_protocol_plugin_retry_error";
            _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s holding onto error because reissuing",  buf,  0xCu);
          }
        }
      }

      else
      {
        int v10 = *(uint64_t (**)(nw_protocol *, nw_protocol *, BOOL))(v9 + 152);
        if (!v10 || (v10(a1, a2, *(_DWORD *)(v9 + 208) != 0) & 1) == 0) {
          goto LABEL_14;
        }
      }
    }
  }

void nw_protocol_plugins_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v17 = "nw_protocol_plugins_notify";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_protocol_plugins_notify";
      uint64_t v9 = "%{public}s called with null protocol";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v17 = "nw_protocol_plugins_notify";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v6) {
          return;
        }
        goto LABEL_35;
      }

      if (!v11) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_protocol_plugins_notify";
      uint64_t v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_protocol_plugins_notify";
      uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_plugins_reset(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      nw_protocol_plugins_handle_reset((uint64_t)handle + 64, (uint64_t)a1, (uint64_t)a2);
      return nw_protocol_common_reset((uint64_t)a1, (uint64_t)a2);
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v17 = "nw_protocol_plugins_reset";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_protocol_plugins_reset";
        uint64_t v9 = "%{public}s called with null protocol->handle";
        goto LABEL_31;
      }

      if (!v14)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_protocol_plugins_reset";
        uint64_t v9 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_31;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v17 = "nw_protocol_plugins_reset";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol->handle, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v6) {
          return 0LL;
        }
        goto LABEL_33;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_protocol_plugins_reset";
        uint64_t v9 = "%{public}s called with null protocol->handle, no backtrace";
LABEL_31:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v17 = "nw_protocol_plugins_reset";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_protocol_plugins_reset";
      uint64_t v9 = "%{public}s called with null protocol";
      goto LABEL_31;
    }

    if (!v14)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_protocol_plugins_reset";
      uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }

    int v10 = (char *)__nw_create_backtrace_string();
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (!v10)
    {
      if (!v11) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_protocol_plugins_reset";
      uint64_t v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_31;
    }

    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v17 = "nw_protocol_plugins_reset";
      __int16 v18 = 2082;
      char v19 = v10;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v10);
  }

void nw_protocol_plugins_handle_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v22 = "nw_protocol_plugins_handle_reset";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v22 = "nw_protocol_plugins_handle_reset";
      uint64_t v12 = "%{public}s called with null plugins";
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v22 = "nw_protocol_plugins_handle_reset";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null plugins, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v9) {
          return;
        }
LABEL_44:
        free(v9);
        return;
      }

      if (!v16) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v22 = "nw_protocol_plugins_handle_reset";
      uint64_t v12 = "%{public}s called with null plugins, no backtrace";
    }

    else
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v22 = "nw_protocol_plugins_handle_reset";
      uint64_t v12 = "%{public}s called with null plugins, backtrace limit exceeded";
    }

void nw_protocol_plugin_retry_connected(nw_protocol_plugin_retry *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v171 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v77 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_retry_connected";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = a2;
      _os_log_impl(&dword_181A5C000, v77, OS_LOG_TYPE_DEBUG, "%{public}s called %p", buf, 0x16u);
    }
  }

  uint64_t default_input_handler = (uint64_t)a2->default_input_handler;
  if (default_input_handler)
  {
    uint64_t v7 = *(void **)(default_input_handler + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *(void *)(default_input_handler + 88);
      if (v8) {
        *(void *)(default_input_handler + 88) = v8 + 1;
      }
    }

    if (a3)
    {
      handle = a3->handle;
      if (handle == &nw_protocol_ref_counted_handle)
      {
        callbacks = a3[1].callbacks;
        if (callbacks) {
          a3[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
      }

      uint64_t v11 = *(void *)(default_input_handler + 24);
      if (v11)
      {
        uint64_t v12 = *(void (**)(uint64_t, nw_protocol *))(v11 + 40);
        if (v12)
        {
          v12(default_input_handler, a3);
LABEL_13:
          if (handle != &nw_protocol_ref_counted_handle
            || a3->handle != &nw_protocol_ref_counted_handle
            || (v47 = a3[1].callbacks) == 0LL
            || (char v48 = (nw_protocol_callbacks *)((char *)v47 - 1), (a3[1].callbacks = v48) != 0LL))
          {
LABEL_15:
            if (v7 == &nw_protocol_ref_counted_handle
              && *(_UNKNOWN **)(default_input_handler + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v43 = *(void *)(default_input_handler + 88);
              if (v43)
              {
                uint64_t v44 = v43 - 1;
                *(void *)(default_input_handler + 88) = v44;
                if (!v44)
                {
                  os_log_type_t v45 = *(void (***)(void))(default_input_handler + 64);
                  if (v45)
                  {
                    *(void *)(default_input_handler + 64) = 0LL;
                    v45[2](v45);
                    _Block_release(v45);
                  }

                  if ((*(_BYTE *)(default_input_handler + 72) & 1) != 0)
                  {
                    BOOL v46 = *(const void **)(default_input_handler + 64);
                    if (v46) {
                      _Block_release(v46);
                    }
                  }

                  goto LABEL_85;
                }
              }
            }

            goto LABEL_17;
          }

          uint64_t v49 = *(void (***)(void))a3[1].flow_id;
          if (v49)
          {
            *(void *)a3[1].flow_id = 0LL;
            v49[2](v49);
            _Block_release(v49);
          }

          if ((a3[1].flow_id[8] & 1) != 0)
          {
            __int16 v50 = *(const void **)a3[1].flow_id;
            if (v50) {
              _Block_release(v50);
            }
          }

          uint64_t v51 = a3;
LABEL_94:
          free(v51);
          goto LABEL_15;
        }
      }

      __nwlog_obj();
      v72 = *(const char **)(default_input_handler + 16);
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_connected";
      if (!v72) {
        v72 = "invalid";
      }
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v72;
      *(_WORD *)&buf[22] = 2048;
      v167 = (void *)default_input_handler;
      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v165 = OS_LOG_TYPE_DEFAULT;
      v161 = (char *)_os_log_send_and_compose_impl();
      if (__nwlog_fault(v161, type, &v165))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v73 = (os_log_s *)__nwlog_obj();
          os_log_type_t v74 = type[0];
          if (!os_log_type_enabled(v73, type[0])) {
            goto LABEL_196;
          }
          uint64_t v75 = *(const char **)(default_input_handler + 16);
          if (!v75) {
            uint64_t v75 = "invalid";
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_connected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v75;
          *(_WORD *)&buf[22] = 2048;
          v167 = (void *)default_input_handler;
          char v76 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
LABEL_194:
          v110 = v73;
LABEL_195:
          _os_log_impl(&dword_181A5C000, v110, v74, v76, buf, 0x20u);
          goto LABEL_196;
        }

        if (v165 == OS_LOG_TYPE_DEFAULT)
        {
          os_log_type_t v73 = (os_log_s *)__nwlog_obj();
          os_log_type_t v74 = type[0];
          if (!os_log_type_enabled(v73, type[0])) {
            goto LABEL_196;
          }
          v109 = *(const char **)(default_input_handler + 16);
          if (!v109) {
            v109 = "invalid";
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_connected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v109;
          *(_WORD *)&buf[22] = 2048;
          v167 = (void *)default_input_handler;
          char v76 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
          goto LABEL_194;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        v86 = (os_log_s *)__nwlog_obj();
        os_log_type_t v74 = type[0];
        log = v86;
        BOOL v87 = os_log_type_enabled(v86, type[0]);
        if (backtrace_string)
        {
          if (v87)
          {
            v88 = *(const char **)(default_input_handler + 16);
            if (!v88) {
              v88 = "invalid";
            }
            *(_DWORD *)__int128 buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_protocol_connected";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v88;
            *(_WORD *)&buf[22] = 2048;
            v167 = (void *)default_input_handler;
            *(_WORD *)v168 = 2082;
            *(void *)&v168[2] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  log,  v74,  "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_196;
        }

        if (v87)
        {
          v117 = *(const char **)(default_input_handler + 16);
          if (!v117) {
            v117 = "invalid";
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_connected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v117;
          *(_WORD *)&buf[22] = 2048;
          v167 = (void *)default_input_handler;
          char v76 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
          v110 = log;
          goto LABEL_195;
        }
      }

LABEL_291:
      if (v112) {
        free(v112);
      }
      int v33 = 0;
      if (v29 != &nw_protocol_ref_counted_handle)
      {
LABEL_56:
        if (v27 == &nw_protocol_ref_counted_handle && v24->handle == &nw_protocol_ref_counted_handle)
        {
          uint64_t v68 = v24[1].callbacks;
          if (v68)
          {
            uint64_t v69 = (nw_protocol_callbacks *)((char *)v68 - 1);
            v24[1].callbacks = v69;
            if (!v69)
            {
              v70 = *(void (***)(void))v24[1].flow_id;
              if (v70)
              {
                *(void *)v24[1].flow_id = 0LL;
                v70[2](v70);
                _Block_release(v70);
              }

              if ((v24[1].flow_id[8] & 1) != 0)
              {
                v71 = *(const void **)v24[1].flow_id;
                if (v71) {
                  _Block_release(v71);
                }
              }

              free(v24);
            }
          }
        }

        if (*(void *)type)
        {
          if (v33)
          {
LABEL_60:
            if (!(*(unsigned int (**)(void, os_log_type_t *))(*((void *)a1 + 14) + 16LL))( *((void *)a1 + 14),  type))
            {
              if (gLogDatapath)
              {
                v142 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v142, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
                  _os_log_impl(&dword_181A5C000, v142, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                }
              }

              *(void *)__int128 buf = MEMORY[0x1895F87A8];
              *(void *)&buf[8] = 0x40000000LL;
              *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3309;
              v167 = &__block_descriptor_tmp_34_3310;
              *(void *)v168 = type;
              v168[8] = 0;
              uint64_t v52 = *(void *)type;
              do
              {
                if (!v52) {
                  break;
                }
                uint64_t v53 = *(void *)(v52 + 32);
                char v54 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                uint64_t v52 = v53;
              }

              while ((v54 & 1) != 0);
              goto LABEL_29;
            }

            uint64_t v34 = (uint64_t)a2->output_handler;
            if (v34)
            {
              BOOL v35 = *(void **)(v34 + 40);
              if (v35 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v36 = *(void *)(v34 + 88);
                if (v36) {
                  *(void *)(v34 + 88) = v36 + 1;
                }
              }

              uint64_t v37 = *(void *)(v34 + 24);
              if (v37)
              {
                os_log_type_t v38 = *(void (**)(uint64_t, os_log_type_t *))(v37 + 96);
                if (v38)
                {
                  v38(v34, type);
LABEL_68:
                  if (v35 != &nw_protocol_ref_counted_handle) {
                    goto LABEL_29;
                  }
                  if (*(_UNKNOWN **)(v34 + 40) != &nw_protocol_ref_counted_handle) {
                    goto LABEL_29;
                  }
                  uint64_t v39 = *(void *)(v34 + 88);
                  if (!v39) {
                    goto LABEL_29;
                  }
                  uint64_t v40 = v39 - 1;
                  *(void *)(v34 + 88) = v40;
                  if (v40) {
                    goto LABEL_29;
                  }
                  char v41 = *(void (***)(void))(v34 + 64);
                  if (v41)
                  {
                    *(void *)(v34 + 64) = 0LL;
                    v41[2](v41);
                    _Block_release(v41);
                  }

                  if ((*(_BYTE *)(v34 + 72) & 1) != 0)
                  {
                    BOOL v42 = *(const void **)(v34 + 64);
                    if (v42) {
                      _Block_release(v42);
                    }
                  }

    free(v180);
    if (!v145) {
      goto LABEL_401;
    }
    goto LABEL_400;
  }

  uint64_t v6 = (uint64_t *)(v8 + 248);
LABEL_10:
  uint64_t v9 = *v6;
  if (!*v6) {
    goto LABEL_401;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
    BOOL v149 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(aBlock[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v150 = (os_log_s *)__nwlog_obj();
      v151 = type[0];
      if (!os_log_type_enabled(v150, type[0])) {
        goto LABEL_440;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
      v152 = "%{public}s called with null other_protocol";
    }

    else if (LOBYTE(aBlock[0]))
    {
      v161 = (char *)__nw_create_backtrace_string();
      v150 = (os_log_s *)__nwlog_obj();
      v151 = type[0];
      v162 = os_log_type_enabled(v150, type[0]);
      if (v161)
      {
        if (!v162) {
          goto LABEL_433;
        }
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v161;
        v163 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_432;
      }

      if (!v162) {
        goto LABEL_440;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
      v152 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      v150 = (os_log_s *)__nwlog_obj();
      v151 = type[0];
      if (!os_log_type_enabled(v150, type[0])) {
        goto LABEL_440;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
      v152 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }

    free(v166);
    if (!v157) {
      goto LABEL_411;
    }
    goto LABEL_410;
  }

  uint64_t v6 = *((void *)handle + 1);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v157 = (char *)_os_log_send_and_compose_impl();
    v268[0] = 16;
    v260[0] = OS_LOG_TYPE_DEFAULT;
    if (v268[0] == 17)
    {
      v158 = (os_log_s *)__nwlog_obj();
      v159 = v268[0];
      if (!os_log_type_enabled(v158, (os_log_type_t)v268[0])) {
        goto LABEL_409;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v160 = "%{public}s called with null handle->http1_stream";
      goto LABEL_408;
    }

    if (v260[0] == OS_LOG_TYPE_DEFAULT)
    {
      v158 = (os_log_s *)__nwlog_obj();
      v159 = v268[0];
      if (!os_log_type_enabled(v158, (os_log_type_t)v268[0])) {
        goto LABEL_409;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v160 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_408;
    }

    v166 = (char *)__nw_create_backtrace_string();
    v158 = (os_log_s *)__nwlog_obj();
    v159 = v268[0];
    v182 = os_log_type_enabled(v158, (os_log_type_t)v268[0]);
    if (!v166)
    {
      if (!v182) {
        goto LABEL_409;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v160 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_408;
    }

    if (!v182) {
      goto LABEL_291;
    }
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v166;
    v168 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
LABEL_290:
    _os_log_impl(&dword_181A5C000, v158, v159, v168, buf, 0x16u);
    goto LABEL_291;
  }

  uint64_t v4 = (void *)(v6 + 248);
LABEL_10:
  if (!*v4) {
    goto LABEL_411;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();
    v268[0] = 16;
    v260[0] = OS_LOG_TYPE_DEFAULT;
    if (v268[0] == 17)
    {
      uint64_t v53 = (os_log_s *)__nwlog_obj();
      char v54 = v268[0];
      if (!os_log_type_enabled(v53, (os_log_type_t)v268[0])) {
        goto LABEL_425;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
      int v55 = "%{public}s called with null other_protocol";
      goto LABEL_424;
    }

    if (v260[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v53 = (os_log_s *)__nwlog_obj();
      char v54 = v268[0];
      if (!os_log_type_enabled(v53, (os_log_type_t)v268[0])) {
        goto LABEL_425;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
      int v55 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_424;
    }

    uint64_t v61 = (char *)__nw_create_backtrace_string();
    uint64_t v53 = (os_log_s *)__nwlog_obj();
    char v54 = v268[0];
    __int16 v169 = os_log_type_enabled(v53, (os_log_type_t)v268[0]);
    if (!v61)
    {
      if (!v169) {
        goto LABEL_425;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
      int v55 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_424;
    }

    if (!v169) {
      goto LABEL_103;
    }
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v61;
    char v63 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_102;
  }

  if (v3 != 3)
  {
    if (v3 == 2)
    {
      uint64_t v7 = *((void *)handle + 1);
      if (v7)
      {
        if ((*(_BYTE *)(v7 + 158) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v8 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v9 = *(void *)(v7 + 256);
            int v10 = *(_DWORD *)(*(void *)(v7 + 248) + 372LL);
            if (v9) {
              LODWORD(v9) = *(_DWORD *)(v9 + 860);
            }
            uint64_t v11 = *(_DWORD *)(v7 + 424);
            *(_DWORD *)__int128 buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v7 + 74;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&_BYTE buf[24] = " ";
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v10;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v9;
            LOWORD(v265) = 1024;
            *(_DWORD *)((char *)&v265 + 2) = v11;
            _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:c%u:s%u> initial stream disconnected",  buf,  0x32u);
          }
        }

        nw_protocol_disconnected(*(void **)(v7 + 48), v7);
        return;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
      uint64_t v52 = (char *)_os_log_send_and_compose_impl();
      v268[0] = 16;
      v260[0] = OS_LOG_TYPE_DEFAULT;
      if (v268[0] == 17)
      {
        uint64_t v53 = (os_log_s *)__nwlog_obj();
        char v54 = v268[0];
        if (os_log_type_enabled(v53, (os_log_type_t)v268[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
          int v55 = "%{public}s called with null http1_stream";
LABEL_424:
          _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
          goto LABEL_425;
        }

        goto LABEL_425;
      }

      if (v260[0] == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v53 = (os_log_s *)__nwlog_obj();
        char v54 = v268[0];
        if (os_log_type_enabled(v53, (os_log_type_t)v268[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
          int v55 = "%{public}s called with null http1_stream, backtrace limit exceeded";
          goto LABEL_424;
        }

    v29 = v77 - v107;
    if (v27 > v29)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      goto LABEL_404;
    }

    v125 = &v106[v107];
    int v33 = v29 >= v27;
    char v126 = v29 - v27;
    if (!v33)
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446978;
      v204 = "nw_http_copy_metadata_from_binary_message";
      v205 = 2082;
      v206 = "remaining";
      v207 = 2048;
      v208 = v27;
      v209 = 2048;
      v210 = v126;
      v127 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v201 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v128 = (os_log_s *)__nwlog_obj();
        v129 = type;
        if (!os_log_type_enabled(v128, type)) {
          goto LABEL_503;
        }
        *(_DWORD *)__int128 buf = 136446978;
        v204 = "nw_http_copy_metadata_from_binary_message";
        v205 = 2082;
        v206 = "remaining";
        v207 = 2048;
        v208 = v27;
        v209 = 2048;
        v210 = v126;
        __int16 v130 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
      }

      else if (v201)
      {
        int v155 = (char *)__nw_create_backtrace_string();
        BOOL v128 = (os_log_s *)__nwlog_obj();
        v129 = type;
        int v156 = os_log_type_enabled(v128, type);
        if (v155)
        {
          if (v156)
          {
            *(_DWORD *)__int128 buf = 136447234;
            v204 = "nw_http_copy_metadata_from_binary_message";
            v205 = 2082;
            v206 = "remaining";
            v207 = 2048;
            v208 = v27;
            v209 = 2048;
            v210 = v126;
            v211 = 2082;
            v212 = v155;
            _os_log_impl( &dword_181A5C000,  v128,  v129,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v155);
          goto LABEL_503;
        }

        if (!v156)
        {
LABEL_503:
          if (v127) {
            free(v127);
          }
          goto LABEL_505;
        }

        *(_DWORD *)__int128 buf = 136446978;
        v204 = "nw_http_copy_metadata_from_binary_message";
        v205 = 2082;
        v206 = "remaining";
        v207 = 2048;
        v208 = v27;
        v209 = 2048;
        v210 = v126;
        __int16 v130 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
      }

      else
      {
        BOOL v128 = (os_log_s *)__nwlog_obj();
        v129 = type;
        if (!os_log_type_enabled(v128, type)) {
          goto LABEL_503;
        }
        *(_DWORD *)__int128 buf = 136446978;
        v204 = "nw_http_copy_metadata_from_binary_message";
        v205 = 2082;
        v206 = "remaining";
        v207 = 2048;
        v208 = v27;
        v209 = 2048;
        v210 = v126;
        __int16 v130 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v128, v129, v130, buf, 0x2Au);
      goto LABEL_503;
    }

    if (!v126) {
      goto LABEL_505;
    }
    uint64_t v136 = &v125[v27];
    uint64_t v27 = v125[v27];
    if (v27 <= 0x3F)
    {
      v137 = 1LL;
      goto LABEL_402;
    }

    if (v27 >> 6 == 2)
    {
      if (v126 < 4) {
        goto LABEL_505;
      }
      uint64_t v27 = bswap32(*(_DWORD *)v136 & 0xFFFFFF7F);
      v137 = 4LL;
    }

    else
    {
      if (v27 >> 6 == 1)
      {
        if (v126 >= 2)
        {
          uint64_t v27 = bswap32(*(_WORD *)v136 & 0xFFBF) >> 16;
          v137 = 2LL;
          goto LABEL_402;
        }

LABEL_325:
              if (v131) {
                free(v131);
              }
              goto LABEL_68;
            }

            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            uint64_t v34 = _os_log_send_and_compose_impl();
            os_log_type_t v165 = OS_LOG_TYPE_ERROR;
            char v164 = 0;
            if (__nwlog_fault((const char *)v34, &v165, &v164))
            {
              if (v165 == OS_LOG_TYPE_FAULT)
              {
                v139 = (os_log_s *)__nwlog_obj();
                os_log_type_t v140 = v165;
                if (!os_log_type_enabled(v139, v165)) {
                  goto LABEL_332;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                v141 = "%{public}s called with null protocol";
LABEL_331:
                _os_log_impl(&dword_181A5C000, v139, v140, v141, buf, 0xCu);
                goto LABEL_332;
              }

              if (!v164)
              {
                v139 = (os_log_s *)__nwlog_obj();
                os_log_type_t v140 = v165;
                if (!os_log_type_enabled(v139, v165)) {
                  goto LABEL_332;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                v141 = "%{public}s called with null protocol, backtrace limit exceeded";
                goto LABEL_331;
              }

              v148 = (char *)__nw_create_backtrace_string();
              v139 = (os_log_s *)__nwlog_obj();
              os_log_type_t v140 = v165;
              BOOL v149 = os_log_type_enabled(v139, v165);
              if (!v148)
              {
                if (!v149) {
                  goto LABEL_332;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                v141 = "%{public}s called with null protocol, no backtrace";
                goto LABEL_331;
              }

              if (v149)
              {
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v148;
                _os_log_impl( &dword_181A5C000,  v139,  v140,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v148);
            }

                if (v156) {
                  free(v156);
                }
                goto LABEL_213;
              }

              if ((v110 & 0x80000000) == 0) {
                goto LABEL_191;
              }
              goto LABEL_194;
            }

            if (v136) {
              free(v136);
            }
            v116 = 0;
            if (v111 != &nw_protocol_ref_counted_handle)
            {
LABEL_226:
              if (v104 == &nw_protocol_ref_counted_handle)
              {
                nw::release_if_needed<nw_protocol *>((uint64_t *)v170);
                if ((v116 & 1) != 0) {
                  goto LABEL_250;
                }
              }

              else if ((v116 & 1) != 0)
              {
LABEL_250:
                v125 = a1->output_handler;
                if (v125)
                {
                  if (v125->handle == &nw_protocol_ref_counted_handle)
                  {
                    char v126 = v125[1].callbacks;
                    if (v126)
                    {
                      v127 = (nw_protocol_callbacks *)((char *)v126 - 1);
                      v125[1].callbacks = v127;
                      if (!v127)
                      {
                        BOOL v128 = *(void (***)(void))v125[1].flow_id;
                        if (v128)
                        {
                          *(void *)v125[1].flow_id = 0LL;
                          v128[2](v128);
                          _Block_release(v128);
                        }

                        if ((v125[1].flow_id[8] & 1) != 0)
                        {
                          v129 = *(const void **)v125[1].flow_id;
                          if (v129) {
                            _Block_release(v129);
                          }
                        }

                        free(v125);
                      }
                    }
                  }

                  a1->uint64_t output_handler = 0LL;
                }

                goto LABEL_253;
              }

              if (v9[405] < 0) {
                goto LABEL_250;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v117 = (id)gLogObj;
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v9 + 407;
              *(_WORD *)&buf[22] = 2080;
              v166 = " ";
              v118 = (void *)_os_log_send_and_compose_impl();

              v170[0] = 16;
              LOBYTE(v163) = 0;
              if (__nwlog_fault((const char *)v118, v170, &v163))
              {
                if (v170[0] == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v119 = (os_log_s *)(id)gLogObj;
                  BOOL v120 = v170[0];
                  if (os_log_type_enabled(v119, (os_log_type_t)v170[0]))
                  {
                    *(_DWORD *)__int128 buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v9 + 407;
                    *(_WORD *)&buf[22] = 2080;
                    v166 = " ";
                    _os_log_impl( &dword_181A5C000,  v119,  v120,  "%{public}s %{public}s%sUnable to remove output handler",  buf,  0x20u);
                  }
                }

                else if ((_BYTE)v163)
                {
                  v121 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v119 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v122 = v170[0];
                  v123 = os_log_type_enabled(v119, (os_log_type_t)v170[0]);
                  if (v121)
                  {
                    if (v123)
                    {
                      *(_DWORD *)__int128 buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v9 + 407;
                      *(_WORD *)&buf[22] = 2080;
                      v166 = " ";
                      *(_WORD *)v167 = 2082;
                      *(void *)&v167[2] = v121;
                      _os_log_impl( &dword_181A5C000,  v119,  v122,  "%{public}s %{public}s%sUnable to remove output handler, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    free(v121);
                    if (!v118) {
                      goto LABEL_250;
                    }
LABEL_249:
                    free(v118);
                    goto LABEL_250;
                  }

                  if (v123)
                  {
                    *(_DWORD *)__int128 buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v9 + 407;
                    *(_WORD *)&buf[22] = 2080;
                    v166 = " ";
                    _os_log_impl( &dword_181A5C000,  v119,  v122,  "%{public}s %{public}s%sUnable to remove output handler, no backtrace",  buf,  0x20u);
                  }
                }

                else
                {
                  __nwlog_obj();
                  v119 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v124 = v170[0];
                  if (os_log_type_enabled(v119, (os_log_type_t)v170[0]))
                  {
                    *(_DWORD *)__int128 buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v9 + 407;
                    *(_WORD *)&buf[22] = 2080;
                    v166 = " ";
                    _os_log_impl( &dword_181A5C000,  v119,  v124,  "%{public}s %{public}s%sUnable to remove output handler, backtrace limit exceeded",  buf,  0x20u);
                  }
                }
              }

              if (!v118) {
                goto LABEL_250;
              }
              goto LABEL_249;
            }

  if (!v30[4]) {
    goto LABEL_580;
  }
  v206 = v30[22];
  v207 = *(void **)(v80 + 392);
  *(void *)__int128 buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
  v344 = (uint64_t)&unk_189BBC5E0;
  *(void *)v345 = v206;
  nw_queue_context_async(v207, buf);
LABEL_588:
  os_release(v107);
LABEL_589:
  if ((handle[137] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v321 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v322 = handle[115];
      *(_DWORD *)__int128 buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 116;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v322;
      *(_WORD *)&v345[6] = 2048;
      *(void *)&v345[8] = v329;
      *(_WORD *)&v345[16] = 2082;
      *(void *)&v345[18] = v30 + 24;
      _os_log_impl( &dword_181A5C000,  v321,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%s<i%u> Added input handler %p from %{public}s",  buf,  0x3Au);
    }
  }

  return 1LL;
}

    if (v134) {
      free(v134);
    }
    char v19 = 0LL;
    BOOL v18 = v174;
    uint64_t v36 = v175;
    goto LABEL_139;
  }

  uint64_t v67 = (v66 + 1);
  if (v19 >= v36)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136447234;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(void *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(void *)v182 = v36;
    *(_WORD *)&v182[8] = 1024;
    *(_DWORD *)&v182[10] = 11;
    *(_WORD *)&v182[14] = 1024;
    *(_DWORD *)&v182[16] = v67;
    uint64_t v68 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v142 = (os_log_s *)__nwlog_obj();
      v143 = type;
      if (!os_log_type_enabled(v142, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)__int128 buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 11;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v67;
      v71 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }

    else
    {
      if (v176)
      {
        int v156 = (char *)__nw_create_backtrace_string();
        v157 = (os_log_s *)__nwlog_obj();
        v158 = type;
        v159 = os_log_type_enabled(v157, type);
        if (v156)
        {
          if (v159)
          {
            *(_DWORD *)__int128 buf = 136447490;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(void *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(void *)v182 = v175;
            *(_WORD *)&v182[8] = 1024;
            *(_DWORD *)&v182[10] = 11;
            *(_WORD *)&v182[14] = 1024;
            *(_DWORD *)&v182[16] = v67;
            *(_WORD *)&v182[20] = 2082;
            *(void *)&v182[22] = v156;
            _os_log_impl( &dword_181A5C000,  v157,  v158,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
          }

          free(v156);
          goto LABEL_136;
        }

        if (!v159) {
          goto LABEL_136;
        }
        *(_DWORD *)__int128 buf = 136447234;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(void *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(void *)v182 = v175;
        *(_WORD *)&v182[8] = 1024;
        *(_DWORD *)&v182[10] = 11;
        *(_WORD *)&v182[14] = 1024;
        *(_DWORD *)&v182[16] = v67;
        v71 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
        char v76 = v157;
        uint64_t v77 = v158;
LABEL_299:
        v78 = 44;
        goto LABEL_135;
      }

      v142 = (os_log_s *)__nwlog_obj();
      v143 = type;
      if (!os_log_type_enabled(v142, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)__int128 buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 11;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v67;
      v71 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }

    char v76 = v142;
    uint64_t v77 = v143;
    goto LABEL_299;
  }

  if (v36 - v19 < v67 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136447490;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(void *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(void *)v182 = v67 + 5;
    *(_WORD *)&v182[8] = 2048;
    *(void *)&v182[10] = v36;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = 11;
    *(_WORD *)&v182[24] = 1024;
    *(_DWORD *)&v182[26] = v67;
    uint64_t v68 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v69 = gLogObj;
      v70 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)__int128 buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v67 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(void *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 11;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v67;
      v71 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
LABEL_133:
      char v76 = (os_log_s *)v69;
      uint64_t v77 = v70;
LABEL_134:
      v78 = 54;
LABEL_135:
      _os_log_impl(&dword_181A5C000, v76, v77, v71, buf, v78);
      goto LABEL_136;
    }

    if (!v176)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v69 = gLogObj;
      v70 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_136;
      }
      *(_DWORD *)__int128 buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v67 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(void *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 11;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v67;
      v71 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_133;
    }

    v72 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v73 = (os_log_s *)gLogObj;
    os_log_type_t v74 = type;
    uint64_t v75 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v72)
    {
      if (v75)
      {
        *(_DWORD *)__int128 buf = 136447746;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(void *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(void *)v182 = v67 + 5;
        *(_WORD *)&v182[8] = 2048;
        *(void *)&v182[10] = v175;
        *(_WORD *)&v182[18] = 1024;
        *(_DWORD *)&v182[20] = 11;
        *(_WORD *)&v182[24] = 1024;
        *(_DWORD *)&v182[26] = v67;
        *(_WORD *)&v182[30] = 2082;
        *(void *)&v182[32] = v72;
        _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
      }

      free(v72);
      if (!v68) {
        goto LABEL_138;
      }
      goto LABEL_137;
    }

    if (v75)
    {
      *(_DWORD *)__int128 buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v67 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(void *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 11;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v67;
      v71 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
      char v76 = v73;
      uint64_t v77 = v74;
      goto LABEL_134;
    }

                                      goto LABEL_326;
                                    }

                                    goto LABEL_326;
                                  }

                                  __nwlog_obj();
                                  v203 = (void *)objc_claimAutoreleasedReturnValue();
                                  *(_DWORD *)__int128 buf = 136446466;
                                  v355 = "nw_protocol_utilities_add_input_handler";
                                  v356 = 2048;
                                  v357 = (char *)v49;
                                  v204 = (char *)_os_log_send_and_compose_impl();

                                  type[0] = OS_LOG_TYPE_ERROR;
                                  LOBYTE(v350) = 0;
                                  if (__nwlog_fault(v204, type, &v350))
                                  {
                                    if (type[0] == OS_LOG_TYPE_FAULT)
                                    {
                                      __nwlog_obj();
                                      v205 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                      v206 = type[0];
                                      if (os_log_type_enabled(v205, type[0]))
                                      {
                                        *(_DWORD *)__int128 buf = 136446466;
                                        v355 = "nw_protocol_utilities_add_input_handler";
                                        v356 = 2048;
                                        v357 = (char *)v49;
                                        _os_log_impl( &dword_181A5C000,  v205,  v206,  "%{public}s Cannot add input handler %p to itself",  buf,  0x16u);
                                      }
                                    }

                                    else
                                    {
                                      if ((_BYTE)v350)
                                      {
                                        v218 = (char *)__nw_create_backtrace_string();
                                        __nwlog_obj();
                                        v219 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                        v220 = type[0];
                                        v221 = os_log_type_enabled(v219, type[0]);
                                        if (v218)
                                        {
                                          if (v221)
                                          {
                                            *(_DWORD *)__int128 buf = 136446722;
                                            v355 = "nw_protocol_utilities_add_input_handler";
                                            v356 = 2048;
                                            v357 = (char *)v49;
                                            v358 = 2082;
                                            v359 = v218;
                                            _os_log_impl( &dword_181A5C000,  v219,  v220,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
                                          }

                                          free(v218);
                                        }

                                        else
                                        {
                                          if (v221)
                                          {
                                            *(_DWORD *)__int128 buf = 136446466;
                                            v355 = "nw_protocol_utilities_add_input_handler";
                                            v356 = 2048;
                                            v357 = (char *)v49;
                                            _os_log_impl( &dword_181A5C000,  v219,  v220,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
                                          }
                                        }

                                        goto LABEL_297;
                                      }

                                      __nwlog_obj();
                                      v205 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                      v242 = type[0];
                                      if (os_log_type_enabled(v205, type[0]))
                                      {
                                        *(_DWORD *)__int128 buf = 136446466;
                                        v355 = "nw_protocol_utilities_add_input_handler";
                                        v356 = 2048;
                                        v357 = (char *)v49;
                                        _os_log_impl( &dword_181A5C000,  v205,  v242,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
                                      }
                                    }
                                  }

            v158 = *(_DWORD *)(v113 + 368);
            *(_DWORD *)__int128 buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = v114;
            v259 = 2080;
            v260 = (size_t)v115;
            v261 = 1024;
            *(_DWORD *)v262 = v158;
            *(_WORD *)&v262[4] = 2082;
            *(void *)&v262[6] = v111;
            _os_log_impl( &dword_181A5C000,  v95,  v96,  "%{public}s %{public}s%s<i%u> unexpected NULL in source frame, dumping backtrace:%{public}s",  buf,  0x30u);
            goto LABEL_326;
          }

          goto LABEL_326;
        }

        if (!v112) {
          goto LABEL_343;
        }
        v121 = *(void *)(a1 + 104);
        v122 = (const char *)(v121 + 390);
        v123 = v121 == 0;
        if (!v121) {
          v122 = "";
        }
        os_log_type_t v124 = *(_DWORD *)(v121 + 368);
        if (v123) {
          v125 = "";
        }
        else {
          v125 = " ";
        }
        goto LABEL_341;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v95 = (os_log_s *)gconnectionLogObj;
      BOOL v96 = v253;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253)) {
        goto LABEL_343;
      }
      v116 = *(void *)(a1 + 104);
      v117 = (const char *)(v116 + 390);
      v118 = v116 == 0;
      if (!v116) {
        v117 = "";
      }
      v119 = *(_DWORD *)(v116 + 368);
      if (v118) {
        BOOL v120 = "";
      }
      else {
        BOOL v120 = " ";
      }
      goto LABEL_245;
    }

    return 0LL;
  }

  BOOL v13 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  char v14 = *(unsigned __int8 *)(a1 + 204) - (_DWORD)v13;
  else {
    char v15 = v14;
  }
  if (!(_DWORD)v15) {
    goto LABEL_73;
  }
  memcpy(&v6[v8], (const void *)(a1 + v13 + 136), v15);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v15;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v15;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) += v15;
  BOOL v16 = v12 >= v15;
  uint64_t v12 = (v12 - v15);
  if (!v16)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    v257 = 2082;
    v258 = "bodyCopySize";
    v259 = 2048;
    v260 = v15;
    v261 = 2048;
    *(void *)v262 = v12;
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v17, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v18 = (os_log_s *)__nwlog_obj();
        char v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v15;
          v261 = 2048;
          *(void *)v262 = v12;
          uint64_t v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_65:
          _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0x2Au);
        }
      }

      else if (v253)
      {
        v29 = (char *)__nw_create_backtrace_string();
        BOOL v18 = (os_log_s *)__nwlog_obj();
        char v19 = type[0];
        uint64_t v30 = os_log_type_enabled(v18, type[0]);
        if (v29)
        {
          if (v30)
          {
            *(_DWORD *)__int128 buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v15;
            v261 = 2048;
            *(void *)v262 = v12;
            *(_WORD *)&v262[8] = 2082;
            *(void *)&v262[10] = v29;
            _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v29);
          goto LABEL_66;
        }

        if (v30)
        {
          *(_DWORD *)__int128 buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v15;
          v261 = 2048;
          *(void *)v262 = v12;
          uint64_t v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_65;
        }
      }

      else
      {
        BOOL v18 = (os_log_s *)__nwlog_obj();
        char v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v15;
          v261 = 2048;
          *(void *)v262 = v12;
          uint64_t v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_65;
        }
      }
    }

LABEL_332:
            if (!v34) {
              goto LABEL_29;
            }
            goto LABEL_77;
          }

                __nwlog_obj();
                os_log_type_t v165 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                v166 = (char *)_os_log_send_and_compose_impl();

                type[0] = 16;
                LOBYTE(v279) = 0;
                if (type[0] == 17)
                {
                  __nwlog_obj();
                  v167 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v168 = type[0];
                  if (os_log_type_enabled(v167, (os_log_type_t)type[0]))
                  {
                    *(_DWORD *)__int128 buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                    _os_log_impl(&dword_181A5C000, v167, v168, "%{public}s called with null protocol", buf, 0xCu);
                  }
                }

                else if ((_BYTE)v279)
                {
                  v180 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v167 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v181 = type[0];
                  v182 = os_log_type_enabled(v167, (os_log_type_t)type[0]);
                  if (v180)
                  {
                    if (v182)
                    {
                      *(_DWORD *)__int128 buf = 136446466;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v180;
                      _os_log_impl( &dword_181A5C000,  v167,  v181,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v180);
LABEL_385:
                    if (v166) {
                      free(v166);
                    }
                    __nwlog_obj();
                    v185 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)__int128 buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                    v186 = (char *)_os_log_send_and_compose_impl();

                    type[0] = 16;
                    LOBYTE(v279) = 0;
                    if (type[0] == 17)
                    {
                      __nwlog_obj();
                      v187 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      v188 = type[0];
                      if (os_log_type_enabled(v187, (os_log_type_t)type[0]))
                      {
                        *(_DWORD *)__int128 buf = 136446210;
                        *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                        _os_log_impl(&dword_181A5C000, v187, v188, "%{public}s called with null protocol", buf, 0xCu);
                      }
                    }

                    else if ((_BYTE)v279)
                    {
                      v189 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      v187 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      v190 = type[0];
                      v191 = os_log_type_enabled(v187, (os_log_type_t)type[0]);
                      if (v189)
                      {
                        if (v191)
                        {
                          *(_DWORD *)__int128 buf = 136446466;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v189;
                          _os_log_impl( &dword_181A5C000,  v187,  v190,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v189);
                        goto LABEL_403;
                      }

                      if (v191)
                      {
                        *(_DWORD *)__int128 buf = 136446210;
                        *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                        _os_log_impl( &dword_181A5C000,  v187,  v190,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
                      }
                    }

                    else
                    {
                      __nwlog_obj();
                      v187 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      v192 = type[0];
                      if (os_log_type_enabled(v187, (os_log_type_t)type[0]))
                      {
                        *(_DWORD *)__int128 buf = 136446210;
                        *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                        _os_log_impl( &dword_181A5C000,  v187,  v192,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
                      }
                    }

LABEL_403:
                    if (v186) {
                      free(v186);
                    }
LABEL_434:
                    v207 = nw_protocol_instance_copy_path(v7, -1LL);
                    v208 = (void *)*((void *)v7 + 36);
                    *((void *)v7 + 36) = v207;

                    objc_storeStrong((id *)v7 + 7, v92);
                    if ((*(_BYTE *)(*((void *)v7 + 1) + 184LL) & 0x20) != 0 && a2 != 0LL)
                    {
                      v210 = a2->callbacks;
                      if (v210)
                      {
                        v211 = (uint64_t (*)(nw_protocol *))v210->supports_external_data;
                        if (v211)
                        {
                          v212 = a2->handle;
                          if (v212 == &nw_protocol_ref_counted_handle)
                          {
                            v214 = a2[1].callbacks;
                            if (v214) {
                              a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v214->add_input_handler + 1);
                            }
                            *(void *)__int128 buf = a2;
                            v213 = buf[8] | 1;
                          }

                          else
                          {
                            *(void *)__int128 buf = a2;
                            v213 = buf[8] & 0xFE;
                          }

                          buf[8] = v213;
                          v215 = v211(a2);
                          if (v212 == &nw_protocol_ref_counted_handle) {
                            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                          }
                          if (v215) {
                            v216 = 2;
                          }
                          else {
                            v216 = 0;
                          }
                          v7[403] = v7[403] & 0xFD | v216;
                        }
                      }
                    }

                    if ((v101 & 1) != 0)
                    {
                      v217 = 0LL;
LABEL_456:
                      if ((v7[402] & 2) == 0 && *(void *)(*(void *)(*((void *)v7 + 1) + 80LL) + 40LL))
                      {
                        *(_OWORD *)__int128 buf = *(_OWORD *)a1->flow_id;
                        v220 = nw_path_copy_flow_registration(*((void **)v7 + 15), (uint64_t)buf);
                        v221 = (void *)*((void *)v7 + 35);
                        *((void *)v7 + 35) = v220;

                        (*(void (**)(char *, uint64_t))(*(void *)(*((void *)v7 + 1) + 80LL) + 40LL))( v7,  v217);
                        v7[402] |= 2u;
                      }

                      goto LABEL_459;
                    }

                    v218 = v88;
                    v219 = v218;
                    if (v218)
                    {
                      v217 = *((unsigned __int8 *)v218 + 97) >> 7;
LABEL_455:

                      goto LABEL_456;
                    }

                    __nwlog_obj();
                    v240 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)__int128 buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                    v241 = (char *)_os_log_send_and_compose_impl();

                    type[0] = 16;
                    LOBYTE(v279) = 0;
                    if (__nwlog_fault(v241, type, &v279))
                    {
                      if (type[0] == 17)
                      {
                        __nwlog_obj();
                        v242 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        v243 = type[0];
                        if (os_log_type_enabled(v242, (os_log_type_t)type[0]))
                        {
                          *(_DWORD *)__int128 buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                          _os_log_impl( &dword_181A5C000,  v242,  v243,  "%{public}s called with null parameters",  buf,  0xCu);
                        }
                      }

                      else if ((_BYTE)v279)
                      {
                        v248 = (char *)__nw_create_backtrace_string();
                        __nwlog_obj();
                        v242 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        v249 = type[0];
                        v250 = os_log_type_enabled(v242, (os_log_type_t)type[0]);
                        if (v248)
                        {
                          if (v250)
                          {
                            *(_DWORD *)__int128 buf = 136446466;
                            *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&buf[14] = v248;
                            _os_log_impl( &dword_181A5C000,  v242,  v249,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                          }

                          free(v248);
                          goto LABEL_566;
                        }

                        if (v250)
                        {
                          *(_DWORD *)__int128 buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                          _os_log_impl( &dword_181A5C000,  v242,  v249,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
                        }
                      }

                      else
                      {
                        __nwlog_obj();
                        v242 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        v268 = type[0];
                        if (os_log_type_enabled(v242, (os_log_type_t)type[0]))
                        {
                          *(_DWORD *)__int128 buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                          _os_log_impl( &dword_181A5C000,  v242,  v268,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
                        }
                      }
                    }

    v91 = v62;
    os_log_type_t v92 = v63;
    v93 = 12;
    goto LABEL_333;
  }

  if ((*(_WORD *)(v19 + 428) & 0x100) != 0)
  {
    if (!(_DWORD)a3) {
      goto LABEL_158;
    }
    BOOL v46 = 0;
    if ((_DWORD)a4)
    {
      v47 = a4;
      do
      {
        ++v46;
        char v48 = v47 > 0xF;
        v47 >>= 4;
      }

      while (v48);
    }

    uint64_t v49 = __CFADD__((_DWORD)a3, v46 + 9);
    a3 = (a3 + v46 + 9);
    if (!v49)
    {
LABEL_158:
      if (!(_DWORD)a4) {
        goto LABEL_179;
      }
      v97 = -1;
      v98 = a4;
      do
      {
        ++v97;
        char v48 = v98 > 0xF;
        v98 >>= 4;
      }

      while (v48);
      BOOL v99 = (v97 + 10);
      uint64_t v49 = __CFADD__((_DWORD)a4, (_DWORD)v99);
      a4 = (a4 + v99);
      if (!v49) {
        goto LABEL_179;
      }
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446978;
      v178 = "nw_protocol_http1_get_output_frames";
      v179 = 2082;
      *(void *)v180 = "maximum_bytes";
      *(_WORD *)&v180[8] = 2048;
      *(void *)&v180[10] = v99;
      v181 = 2048;
      *(void *)v182 = a4;
      v100 = (const char *)_os_log_send_and_compose_impl();
      v176 = OS_LOG_TYPE_ERROR;
      v175 = 0;
      v172 = (char *)v100;
      if (__nwlog_fault(v100, &v176, &v175))
      {
        if (v176 == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v165 = (os_log_s *)__nwlog_obj();
          v162 = v176;
          if (os_log_type_enabled(v165, v176))
          {
            *(_DWORD *)__int128 buf = 136446978;
            v178 = "nw_protocol_http1_get_output_frames";
            v179 = 2082;
            *(void *)v180 = "maximum_bytes";
            *(_WORD *)&v180[8] = 2048;
            *(void *)&v180[10] = v99;
            v181 = 2048;
            *(void *)v182 = a4;
            int v101 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_174:
            os_log_type_t v104 = v165;
            v105 = v162;
LABEL_175:
            _os_log_impl(&dword_181A5C000, v104, v105, v101, buf, 0x2Au);
          }
        }

        else if (v175)
        {
          v166 = __nw_create_backtrace_string();
          v163 = (os_log_s *)__nwlog_obj();
          typeb = v176;
          v102 = os_log_type_enabled(v163, v176);
          v103 = (char *)v166;
          if (v166)
          {
            if (v102)
            {
              *(_DWORD *)__int128 buf = 136447234;
              v178 = "nw_protocol_http1_get_output_frames";
              v179 = 2082;
              *(void *)v180 = "maximum_bytes";
              *(_WORD *)&v180[8] = 2048;
              *(void *)&v180[10] = v99;
              v181 = 2048;
              *(void *)v182 = a4;
              *(_WORD *)&v182[8] = 2082;
              v183 = (uint64_t)v166;
              _os_log_impl( &dword_181A5C000,  v163,  typeb,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              v103 = (char *)v166;
            }

            free(v103);
            goto LABEL_176;
          }

          if (v102)
          {
            *(_DWORD *)__int128 buf = 136446978;
            v178 = "nw_protocol_http1_get_output_frames";
            v179 = 2082;
            *(void *)v180 = "maximum_bytes";
            *(_WORD *)&v180[8] = 2048;
            *(void *)&v180[10] = v99;
            v181 = 2048;
            *(void *)v182 = a4;
            int v101 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            os_log_type_t v104 = v163;
            v105 = typeb;
            goto LABEL_175;
          }
        }

        else
        {
          os_log_type_t v165 = (os_log_s *)__nwlog_obj();
          v162 = v176;
          if (os_log_type_enabled(v165, v176))
          {
            *(_DWORD *)__int128 buf = 136446978;
            v178 = "nw_protocol_http1_get_output_frames";
            v179 = 2082;
            *(void *)v180 = "maximum_bytes";
            *(_WORD *)&v180[8] = 2048;
            *(void *)&v180[10] = v99;
            v181 = 2048;
            *(void *)v182 = a4;
            int v101 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_174;
          }
        }
      }

    if (v138) {
      free(v138);
    }
    BOOL v18 = v174;
    goto LABEL_186;
  }

  if (v36 - v19 < v93 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136447490;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(void *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(void *)v182 = v93 + 5;
    *(_WORD *)&v182[8] = 2048;
    *(void *)&v182[10] = v36;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = 12;
    *(_WORD *)&v182[24] = 1024;
    *(_DWORD *)&v182[26] = v93;
    v94 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v95 = gLogObj;
      BOOL v96 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)__int128 buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v93 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(void *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 12;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v93;
      v97 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
    }

    else
    {
      if (v176)
      {
        v98 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v99 = (os_log_s *)gLogObj;
        v100 = type;
        int v101 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v98)
        {
          if (v101)
          {
            *(_DWORD *)__int128 buf = 136447746;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(void *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(void *)v182 = v93 + 5;
            *(_WORD *)&v182[8] = 2048;
            *(void *)&v182[10] = v175;
            *(_WORD *)&v182[18] = 1024;
            *(_DWORD *)&v182[20] = 12;
            *(_WORD *)&v182[24] = 1024;
            *(_DWORD *)&v182[26] = v93;
            *(_WORD *)&v182[30] = 2082;
            *(void *)&v182[32] = v98;
            _os_log_impl( &dword_181A5C000,  v99,  v100,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
          }

          free(v98);
          goto LABEL_184;
        }

        if (!v101)
        {
LABEL_184:
          BOOL v18 = v174;
          if (v94) {
            free(v94);
          }
          goto LABEL_186;
        }

        *(_DWORD *)__int128 buf = 136447490;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(void *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(void *)v182 = v93 + 5;
        *(_WORD *)&v182[8] = 2048;
        *(void *)&v182[10] = v175;
        *(_WORD *)&v182[18] = 1024;
        *(_DWORD *)&v182[20] = 12;
        *(_WORD *)&v182[24] = 1024;
        *(_DWORD *)&v182[26] = v93;
        v97 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
        v102 = v99;
        v103 = v100;
LABEL_183:
        _os_log_impl(&dword_181A5C000, v102, v103, v97, buf, 0x36u);
        goto LABEL_184;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v95 = gLogObj;
      BOOL v96 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)__int128 buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v93 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(void *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 12;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v93;
      v97 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
    }

    v102 = (os_log_s *)v95;
    v103 = v96;
    goto LABEL_183;
  }

  nw_protocol_callbacks *v19 = 12;
  *(_DWORD *)(v19 + 1) = v93;
  if (v92 != -1) {
    memcpy(v19 + 5, v15, v93);
  }
LABEL_186:
  if ((setsockopt(*(_DWORD *)(v171 + 172), 0xFFFF, 4361, v18, v8) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG) || gLogFDOverride != -1)
    {
      os_log_type_t v104 = nw_parameters_copy_description_internal(v170, 1);
      if ((*(_WORD *)(v171 + 301) & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v105 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v106 = *(_DWORD *)(v171 + 172);
          logging_description = nw_endpoint_get_logging_description(v167);
          if (v167)
          {
            os_log_type_t v108 = v167[11];
            v109 = v167[12];
          }

          else
          {
            os_log_type_t v108 = 0LL;
            v109 = 0LL;
          }

          *(_DWORD *)__int128 buf = 136448258;
          v179 = "nw_protocol_socket_set_necp_attributes";
          v180 = 2082;
          *(void *)v181 = v171 + 308;
          *(_WORD *)&v181[8] = 1024;
          *(_DWORD *)v182 = v106;
          *(_WORD *)&v182[4] = 2082;
          *(void *)&v182[6] = v104;
          *(_WORD *)&v182[14] = 2082;
          *(void *)&v182[16] = logging_description;
          *(_WORD *)&v182[24] = 2080;
          *(void *)&v182[26] = v108;
          *(_WORD *)&v182[34] = 2080;
          *(void *)&v182[36] = v109;
          v183 = 1040;
          v184 = v8;
          v185 = 2096;
          v186 = v174;
          _os_log_impl( &dword_181A5C000,  v105,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s setsockopt %d SO_NECP_ATTRIBUTES\n parameters: %{public}s, endpoint: %{public}s %s %s\n %{network:data}.*P",  buf,  0x54u);
        }
      }

      BOOL v18 = v174;
      if (v104) {
        free(v104);
      }
    }

LABEL_316:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v152 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_retry_send_output_frames";
            _os_log_impl( &dword_181A5C000,  v152,  OS_LOG_TYPE_ERROR,  "%{public}s Output frames is not empty but returned frame count is 0",  buf,  0xCu);
          }

          goto LABEL_29;
        }

      free(v110);
      goto LABEL_317;
    }

    if (v141)
    {
      *(_DWORD *)__int128 buf = 136446210;
      v163 = "nw_parameters_create_secure_http_messaging";
      _os_log_impl( &dword_181A5C000,  v128,  v140,  "%{public}s called with null (configure_http_messaging != (_nw_parameters_configure_protocol_disable)), no backtrace",  buf,  0xCu);
    }

    if (v135) {
      free(v135);
    }
    *(_DWORD *)(v129 + 368) = -1;
    BOOL v13 = (unsigned __int16 *)(v12 + 872);
    goto LABEL_319;
  }

    if (v129) {
      free(v129);
    }
LABEL_318:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    v178 = "nw_protocol_http1_get_output_frames";
    uint64_t v61 = (char *)_os_log_send_and_compose_impl();
    v176 = OS_LOG_TYPE_ERROR;
    v175 = 0;
    if (v176 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v62 = (os_log_s *)gLogObj;
      char v63 = v176;
      if (!os_log_type_enabled((os_log_t)gLogObj, v176)) {
        goto LABEL_334;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v178 = "nw_protocol_http1_get_output_frames";
      v64 = "%{public}s called with null http1_stream";
      goto LABEL_332;
    }

    if (!v175)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v62 = (os_log_s *)gLogObj;
      char v63 = v176;
      if (!os_log_type_enabled((os_log_t)gLogObj, v176)) {
        goto LABEL_334;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v178 = "nw_protocol_http1_get_output_frames";
      v64 = "%{public}s called with null http1_stream, backtrace limit exceeded";
      goto LABEL_332;
    }

    uint64_t v69 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v62 = (os_log_s *)gLogObj;
    char v63 = v176;
    v143 = os_log_type_enabled((os_log_t)gLogObj, v176);
    if (!v69)
    {
      if (!v143) {
        goto LABEL_334;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v178 = "nw_protocol_http1_get_output_frames";
      v64 = "%{public}s called with null http1_stream, no backtrace";
      goto LABEL_332;
    }

    if (v143)
    {
      *(_DWORD *)__int128 buf = 136446466;
      v178 = "nw_protocol_http1_get_output_frames";
      v179 = 2082;
      *(void *)v180 = v69;
      v71 = "%{public}s called with null http1_stream, dumping backtrace:%{public}s";
      goto LABEL_326;
    }

    goto LABEL_327;
  }

  BOOL v18 = (uint64_t *)(handle + 8);
LABEL_18:
  char v19 = *v18;
  if (!*v18) {
    goto LABEL_318;
  }
  if ((*(_BYTE *)(v19 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v123 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v124 = *(void *)(v19 + 256);
        v125 = *(_DWORD *)(*(void *)(v19 + 248) + 372LL);
        if (v124) {
          LODWORD(v124) = *(_DWORD *)(v124 + 860);
        }
        char v126 = *(_DWORD *)(v19 + 424);
        *(_DWORD *)__int128 buf = 136448258;
        v178 = "nw_protocol_http1_get_output_frames";
        v179 = 2082;
        *(void *)v180 = v19 + 74;
        *(_WORD *)&v180[8] = 2080;
        *(void *)&v180[10] = " ";
        v181 = 1024;
        *(_DWORD *)v182 = v125;
        *(_WORD *)&v182[4] = 1024;
        *(_DWORD *)&v182[6] = v124;
        LOWORD(v183) = 1024;
        *(_DWORD *)((char *)&v183 + 2) = v126;
        HIWORD(v183) = 1024;
        v184 = a3;
        v185 = 1024;
        v186 = a4;
        v187 = 1024;
        v188 = a5;
        _os_log_impl( &dword_181A5C000,  v123,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> called with min bytes %u, max bytes %u, max frames %u",  buf,  0x44u);
      }
    }
  }

  uint64_t v20 = *(uint64_t **)(v19 + 256);
  if (!v20)
  {
    if ((*(_BYTE *)(v19 + 158) & 1) != 0) {
      return 0LL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v21 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      return 0LL;
    }
    uint64_t v26 = *(void *)(v19 + 256);
    uint64_t v27 = *(_DWORD *)(*(void *)(v19 + 248) + 372LL);
    if (v26) {
      LODWORD(v26) = *(_DWORD *)(v26 + 860);
    }
    char v28 = *(_DWORD *)(v19 + 424);
    *(_DWORD *)__int128 buf = 136447490;
    v178 = "nw_protocol_http1_get_output_frames";
    v179 = 2082;
    *(void *)v180 = v19 + 74;
    *(_WORD *)&v180[8] = 2080;
    *(void *)&v180[10] = " ";
    v181 = 1024;
    *(_DWORD *)v182 = v27;
    *(_WORD *)&v182[4] = 1024;
    *(_DWORD *)&v182[6] = v26;
    LOWORD(v183) = 1024;
    *(_DWORD *)((char *)&v183 + 2) = v28;
    uint64_t v25 = "%{public}s %{public}s%s<i%u:c%u:s%u> no connection, returning 0 frames";
    goto LABEL_33;
  }

  if (v20[81])
  {
    if ((*(_BYTE *)(v19 + 158) & 1) != 0) {
      return 0LL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v21 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      return 0LL;
    }
    BOOL v22 = *(void *)(v19 + 256);
    __int16 v23 = *(_DWORD *)(*(void *)(v19 + 248) + 372LL);
    if (v22) {
      LODWORD(v22) = *(_DWORD *)(v22 + 860);
    }
    BOOL v24 = *(_DWORD *)(v19 + 424);
    *(_DWORD *)__int128 buf = 136447490;
    v178 = "nw_protocol_http1_get_output_frames";
    v179 = 2082;
    *(void *)v180 = v19 + 74;
    *(_WORD *)&v180[8] = 2080;
    *(void *)&v180[10] = " ";
    v181 = 1024;
    *(_DWORD *)v182 = v23;
    *(_WORD *)&v182[4] = 1024;
    *(_DWORD *)&v182[6] = v22;
    LOWORD(v183) = 1024;
    *(_DWORD *)((char *)&v183 + 2) = v24;
    uint64_t v25 = "%{public}s %{public}s%s<i%u:c%u:s%u> still sending the initial frame, returning 0 frames";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, v25, buf, 0x32u);
    return 0LL;
  }

  v29 = *(_WORD *)(v19 + 428);
  if ((v29 & 2) == 0)
  {
    if ((v29 & 0x80) != 0)
    {
      if (*(_BYTE *)(v19 + 158) & 1 | (gLogDatapath == 0)) {
        return 0LL;
      }
      BOOL v21 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        return 0LL;
      }
      char v41 = *(void *)(v19 + 256);
      BOOL v42 = *(_DWORD *)(*(void *)(v19 + 248) + 372LL);
      if (v41) {
        LODWORD(v41) = *(_DWORD *)(v41 + 860);
      }
      uint64_t v43 = *(_DWORD *)(v19 + 424);
      *(_DWORD *)__int128 buf = 136447490;
      v178 = "nw_protocol_http1_get_output_frames";
      v179 = 2082;
      *(void *)v180 = v19 + 74;
      *(_WORD *)&v180[8] = 2080;
      *(void *)&v180[10] = " ";
      v181 = 1024;
      *(_DWORD *)v182 = v42;
      *(_WORD *)&v182[4] = 1024;
      *(_DWORD *)&v182[6] = v41;
      LOWORD(v183) = 1024;
      *(_DWORD *)((char *)&v183 + 2) = v43;
      uint64_t v25 = "%{public}s %{public}s%s<i%u:c%u:s%u> already vended initial outbound frame, cannot send more";
      goto LABEL_33;
    }

    if (!(*(_BYTE *)(v19 + 158) & 1 | (gLogDatapath == 0)))
    {
      BOOL v138 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
      {
        v139 = *(void *)(v19 + 256);
        os_log_type_t v140 = *(_DWORD *)(*(void *)(v19 + 248) + 372LL);
        if (v139) {
          LODWORD(v139) = *(_DWORD *)(v139 + 860);
        }
        v141 = *(_DWORD *)(v19 + 424);
        *(_DWORD *)__int128 buf = 136447490;
        v178 = "nw_protocol_http1_get_output_frames";
        v179 = 2082;
        *(void *)v180 = v19 + 74;
        *(_WORD *)&v180[8] = 2080;
        *(void *)&v180[10] = " ";
        v181 = 1024;
        *(_DWORD *)v182 = v140;
        *(_WORD *)&v182[4] = 1024;
        *(_DWORD *)&v182[6] = v139;
        LOWORD(v183) = 1024;
        *(_DWORD *)((char *)&v183 + 2) = v141;
        _os_log_impl( &dword_181A5C000,  v138,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> outbound headers not yet complete, creating frame",  buf,  0x32u);
      }
    }

    a6->tqh_first = 0LL;
    a6->tqh_last = &a6->tqh_first;
    else {
      uint64_t v30 = a4;
    }
    if (a4 > 0x20000 && (*(_BYTE *)(v16 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v153 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEBUG))
        {
          int v154 = *(_DWORD *)(v16 + 372);
          *(_DWORD *)__int128 buf = 136447490;
          v178 = "nw_protocol_http1_get_output_frames";
          v179 = 2082;
          *(void *)v180 = v16 + 74;
          *(_WORD *)&v180[8] = 2080;
          *(void *)&v180[10] = " ";
          v181 = 1024;
          *(_DWORD *)v182 = v154;
          *(_WORD *)&v182[4] = 1024;
          *(_DWORD *)&v182[6] = v30;
          LOWORD(v183) = 1024;
          *(_DWORD *)((char *)&v183 + 2) = a4;
          _os_log_impl( &dword_181A5C000,  v153,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> capping output frame size to %u, original request was %u",  buf,  0x32u);
        }
      }
    }

    if (v30)
    {
      BOOL v31 = (v30 + 17);
      __int16 v32 = 7;
      v170 = 10;
      if ((*(_BYTE *)(v16 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          int v33 = (os_log_s *)__nwlog_obj();
          v170 = 10;
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v34 = *(_DWORD *)(v16 + 372);
            *(_DWORD *)__int128 buf = 136447746;
            v178 = "nw_protocol_http1_get_output_frames";
            v179 = 2082;
            *(void *)v180 = v16 + 74;
            *(_WORD *)&v180[8] = 2080;
            *(void *)&v180[10] = " ";
            v181 = 1024;
            *(_DWORD *)v182 = v34;
            *(_WORD *)&v182[4] = 1024;
            *(_DWORD *)&v182[6] = v30 + 17;
            v183 = 0x4000000000A0400LL;
            v184 = 7;
            _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> adjusted output frame size is %u (start: %u, end: %u)",  buf,  0x38u);
          }
        }
      }
    }

    else
    {
      v170 = 0;
      __int16 v32 = 0;
      BOOL v31 = 0LL;
    }

    frame = nw_frame_cache_create_frame(v20 + 87, v31);
    if (frame)
    {
      int v56 = frame;
      if ((*(_WORD *)(frame + 204) & 4) != 0)
      {
        uint64_t v68 = *(_BYTE *)(frame + 216);
        *(void *)(frame + 208) = v20;
        *(_BYTE *)(frame + 216) = v68 & 0xFC;
LABEL_136:
        if ((_DWORD)v31)
        {
          nw_frame_claim(v56, v55, v170, v32);
          if ((*(_BYTE *)(v16 + 158) & 1) == 0)
          {
            if (gLogDatapath)
            {
              int v155 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG))
              {
                int v156 = *(_DWORD *)(v16 + 372);
                *(_DWORD *)__int128 buf = 136447746;
                v178 = "nw_protocol_http1_get_output_frames";
                v179 = 2082;
                *(void *)v180 = v16 + 74;
                *(_WORD *)&v180[8] = 2080;
                *(void *)&v180[10] = " ";
                v181 = 1024;
                *(_DWORD *)v182 = v156;
                *(_WORD *)&v182[4] = 1024;
                *(_DWORD *)&v182[6] = v170;
                LOWORD(v183) = 1024;
                *(_DWORD *)((char *)&v183 + 2) = v32;
                HIWORD(v183) = 1024;
                v184 = v31;
                _os_log_impl( &dword_181A5C000,  v155,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> claiming chunked encoding size (start: %u, end: %u) from frame of %u bytes",  buf,  0x38u);
              }
            }
          }
        }

        *(void *)(v56 + 16) = 0LL;
        BOOL v89 = (uint64_t *)v20[86];
        *(void *)(v56 + 24) = v89;
        *BOOL v89 = v56;
        v20[86] = v56 + 16;
        *(void *)(v56 + 80) = nw_http1_connection_output_frame_finalizer;
        *(void *)(v56 + 88) = v16;
        if ((*(_BYTE *)(v19 + 158) & 1) == 0)
        {
          if (gLogDatapath)
          {
            BOOL v149 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
            {
              v150 = *(void *)(v19 + 256);
              v151 = *(_DWORD *)(*(void *)(v19 + 248) + 372LL);
              if (v150) {
                LODWORD(v150) = *(_DWORD *)(v150 + 860);
              }
              v152 = *(_DWORD *)(v19 + 424);
              *(_DWORD *)__int128 buf = 136447746;
              v178 = "nw_protocol_http1_get_output_frames";
              v179 = 2082;
              *(void *)v180 = v19 + 74;
              *(_WORD *)&v180[8] = 2080;
              *(void *)&v180[10] = " ";
              v181 = 1024;
              *(_DWORD *)v182 = v151;
              *(_WORD *)&v182[4] = 1024;
              *(_DWORD *)&v182[6] = v150;
              LOWORD(v183) = 1024;
              *(_DWORD *)((char *)&v183 + 2) = v152;
              HIWORD(v183) = 1024;
              v184 = v31;
              _os_log_impl( &dword_181A5C000,  v149,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> returning 1 frame of %u bytes",  buf,  0x38u);
            }
          }
        }

        *(void *)(v56 + 32) = 0LL;
        tqh_last = a6->tqh_last;
        *(void *)(v56 + 40) = tqh_last;
        *tqh_last = (nw_frame *)v56;
        a6->tqh_last = (nw_frame **)(v56 + 32);
        *(_WORD *)(v19 + 428) |= 0x80u;
        return 1LL;
      }

      char v164 = v32;
      loga = v31;
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446466;
      v178 = "nw_http1_frame_metadata_reset";
      v179 = 2048;
      *(void *)v180 = v56;
      v57 = (char *)_os_log_send_and_compose_impl();
      v176 = OS_LOG_TYPE_ERROR;
      v175 = 0;
      if (__nwlog_fault(v57, &v176, &v175))
      {
        if (v176 == OS_LOG_TYPE_FAULT)
        {
          unsigned int v58 = (os_log_s *)__nwlog_obj();
          v59 = v176;
          if (os_log_type_enabled(v58, v176))
          {
            *(_DWORD *)__int128 buf = 136446466;
            v178 = "nw_http1_frame_metadata_reset";
            v179 = 2048;
            *(void *)v180 = v56;
            v60 = "%{public}s frame %p has no metadata";
LABEL_131:
            BOOL v87 = v58;
            v88 = v59;
LABEL_132:
            _os_log_impl(&dword_181A5C000, v87, v88, v60, buf, 0x16u);
          }
        }

        else if (v175)
        {
          v78 = (char *)__nw_create_backtrace_string();
          os_log_type_t v79 = (os_log_s *)__nwlog_obj();
          os_log_type_t type = v176;
          os_log_type_t v80 = os_log_type_enabled(v79, v176);
          if (v78)
          {
            if (v80)
            {
              *(_DWORD *)__int128 buf = 136446722;
              v178 = "nw_http1_frame_metadata_reset";
              v179 = 2048;
              *(void *)v180 = v56;
              *(_WORD *)&v180[8] = 2082;
              *(void *)&v180[10] = v78;
              _os_log_impl( &dword_181A5C000,  v79,  type,  "%{public}s frame %p has no metadata, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v78);
            goto LABEL_133;
          }

          if (v80)
          {
            *(_DWORD *)__int128 buf = 136446466;
            v178 = "nw_http1_frame_metadata_reset";
            v179 = 2048;
            *(void *)v180 = v56;
            v60 = "%{public}s frame %p has no metadata, no backtrace";
            BOOL v87 = v79;
            v88 = type;
            goto LABEL_132;
          }
        }

        else
        {
          unsigned int v58 = (os_log_s *)__nwlog_obj();
          v59 = v176;
          if (os_log_type_enabled(v58, v176))
          {
            *(_DWORD *)__int128 buf = 136446466;
            v178 = "nw_http1_frame_metadata_reset";
            v179 = 2048;
            *(void *)v180 = v56;
            v60 = "%{public}s frame %p has no metadata, backtrace limit exceeded";
            goto LABEL_131;
          }
        }
      }

                              free(v194);
                              goto LABEL_327;
                            }

                            goto LABEL_327;
                          }

                          __nwlog_obj();
                          v203 = (void *)objc_claimAutoreleasedReturnValue();
                          *(_DWORD *)__int128 buf = 136446466;
                          v358 = "nw_protocol_utilities_add_input_handler";
                          v359 = 2048;
                          v360 = (char *)v51;
                          v204 = (char *)_os_log_send_and_compose_impl();

                          type[0] = OS_LOG_TYPE_ERROR;
                          LOBYTE(v353) = 0;
                          if (__nwlog_fault(v204, type, &v353))
                          {
                            if (type[0] == OS_LOG_TYPE_FAULT)
                            {
                              __nwlog_obj();
                              v205 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              v206 = type[0];
                              if (os_log_type_enabled(v205, type[0]))
                              {
                                *(_DWORD *)__int128 buf = 136446466;
                                v358 = "nw_protocol_utilities_add_input_handler";
                                v359 = 2048;
                                v360 = (char *)v51;
                                _os_log_impl( &dword_181A5C000,  v205,  v206,  "%{public}s Cannot add input handler %p to itself",  buf,  0x16u);
                              }
                            }

                            else if ((_BYTE)v353)
                            {
                              v212 = (char *)__nw_create_backtrace_string();
                              __nwlog_obj();
                              v205 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              v213 = type[0];
                              v214 = os_log_type_enabled(v205, type[0]);
                              if (v212)
                              {
                                if (v214)
                                {
                                  *(_DWORD *)__int128 buf = 136446722;
                                  v358 = "nw_protocol_utilities_add_input_handler";
                                  v359 = 2048;
                                  v360 = (char *)v51;
                                  v361 = 2082;
                                  v362 = v212;
                                  _os_log_impl( &dword_181A5C000,  v205,  v213,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
                                }

                                free(v212);
                                goto LABEL_298;
                              }

                              if (v214)
                              {
                                *(_DWORD *)__int128 buf = 136446466;
                                v358 = "nw_protocol_utilities_add_input_handler";
                                v359 = 2048;
                                v360 = (char *)v51;
                                _os_log_impl( &dword_181A5C000,  v205,  v213,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
                              }
                            }

                            else
                            {
                              __nwlog_obj();
                              v205 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              v243 = type[0];
                              if (os_log_type_enabled(v205, type[0]))
                              {
                                *(_DWORD *)__int128 buf = 136446466;
                                v358 = "nw_protocol_utilities_add_input_handler";
                                v359 = 2048;
                                v360 = (char *)v51;
                                _os_log_impl( &dword_181A5C000,  v205,  v243,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
                              }
                            }
                          }

void nw_protocol_plugin_name_set_name(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v49 = "nw_protocol_plugin_name_set_name";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v49 = "nw_protocol_plugin_name_set_name";
      char v28 = "%{public}s called with null name_plugin";
    }

    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v36 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v49 = "nw_protocol_plugin_name_set_name";
          __int16 v50 = 2082;
          uint64_t v51 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s called with null name_plugin, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_89:
        if (!v25) {
          return;
        }
        goto LABEL_90;
      }

      if (!v36) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v49 = "nw_protocol_plugin_name_set_name";
      char v28 = "%{public}s called with null name_plugin, no backtrace";
    }

    else
    {
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v49 = "nw_protocol_plugin_name_set_name";
      char v28 = "%{public}s called with null name_plugin, backtrace limit exceeded";
    }

    goto LABEL_88;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v49 = "nw_protocol_plugin_name_set_name";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        uint64_t v26 = (os_log_s *)__nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_89;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v49 = "nw_protocol_plugin_name_set_name";
        char v28 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_88;
      }

      uint64_t v37 = (char *)__nw_create_backtrace_string();
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v38 = os_log_type_enabled(v26, type);
      if (!v37)
      {
        if (!v38) {
          goto LABEL_89;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v49 = "nw_protocol_plugin_name_set_name";
        char v28 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_88;
      }

      if (v38)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v49 = "nw_protocol_plugin_name_set_name";
        __int16 v50 = 2082;
        uint64_t v51 = v37;
        uint64_t v39 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_62:
        _os_log_impl(&dword_181A5C000, v26, v27, v39, buf, 0x16u);
      }

uint64_t nw_protocol_plugin_name_add_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
          uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
          uint64_t v11 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      if (!v13) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      uint64_t v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_61;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
    uint64_t v11 = "%{public}s called with null protocol";
LABEL_60:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_61;
  }

  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
          uint64_t v11 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
          uint64_t v11 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      if (!v15) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      uint64_t v14 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_61;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
    uint64_t v11 = "%{public}s called with null protocol->handle";
    goto LABEL_60;
  }

  uint64_t v4 = *(unsigned int (***)(uint64_t, uint64_t))(v3 + 64);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
      uint64_t v11 = "%{public}s called with null name_plugin";
      goto LABEL_60;
    }

    if (!v18)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
        uint64_t v11 = "%{public}s called with null name_plugin, backtrace limit exceeded";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v16 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
        uint64_t v11 = "%{public}s called with null name_plugin, no backtrace";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    if (!v16) {
      goto LABEL_43;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
    __int16 v22 = 2082;
    __int16 v23 = backtrace_string;
    uint64_t v14 = "%{public}s called with null name_plugin, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_181A5C000, v9, v10, v14, buf, 0x16u);
    goto LABEL_43;
  }

  if (a2)
  {
    if ((*v4)(a1, a2)) {
      uint64_t v6 = nw_protocol_common_add_input_handler(a1, a2);
    }
    else {
      uint64_t v6 = 0LL;
    }
    nw_protocol_plugin_name_set_name((uint64_t)v4, a1, 0LL);
    return v6;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v18)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
        uint64_t v11 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
        uint64_t v11 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    if (v17)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v21 = "nw_protocol_plugin_name_add_input_handler";
      __int16 v22 = 2082;
      __int16 v23 = backtrace_string;
      uint64_t v14 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

void nw_protocol_plugin_name_set_callbacks(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_73;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
        uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_72;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v10) {
          goto LABEL_73;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
        uint64_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_72;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
        __int16 v21 = 2082;
        __int16 v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_73:
      if (v5) {
        goto LABEL_74;
      }
      return;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v8 = "%{public}s called with null protocol";
    goto LABEL_72;
  }

  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_73;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
        uint64_t v8 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_72;
      }

      uint64_t v11 = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (!v11)
      {
        if (!v12) {
          goto LABEL_73;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
        uint64_t v8 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_72;
      }

      if (!v12) {
        goto LABEL_50;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
      __int16 v21 = 2082;
      __int16 v22 = v11;
      BOOL v13 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_49;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v8 = "%{public}s called with null protocol->handle";
LABEL_72:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_73;
  }

  uint64_t v3 = *(void **)(v2 + 64);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_73;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
        uint64_t v8 = "%{public}s called with null name_plugin, backtrace limit exceeded";
        goto LABEL_72;
      }

      uint64_t v11 = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v14 = os_log_type_enabled(v6, type);
      if (!v11)
      {
        if (!v14) {
          goto LABEL_73;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
        uint64_t v8 = "%{public}s called with null name_plugin, no backtrace";
        goto LABEL_72;
      }

      if (!v14) {
        goto LABEL_50;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
      __int16 v21 = 2082;
      __int16 v22 = v11;
      BOOL v13 = "%{public}s called with null name_plugin, dumping backtrace:%{public}s";
      goto LABEL_49;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v8 = "%{public}s called with null name_plugin";
    goto LABEL_72;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
      uint64_t v8 = "%{public}s called with null add_input_handler_processor";
      goto LABEL_72;
    }

    if (!v17)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
      uint64_t v8 = "%{public}s called with null add_input_handler_processor, backtrace limit exceeded";
      goto LABEL_72;
    }

    uint64_t v11 = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v15 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v15) {
        goto LABEL_73;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
      uint64_t v8 = "%{public}s called with null add_input_handler_processor, no backtrace";
      goto LABEL_72;
    }

    if (!v15) {
      goto LABEL_50;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    __int16 v21 = 2082;
    __int16 v22 = v11;
    BOOL v13 = "%{public}s called with null add_input_handler_processor, dumping backtrace:%{public}s";
LABEL_49:
    _os_log_impl(&dword_181A5C000, v6, v7, v13, buf, 0x16u);
    goto LABEL_50;
  }

  *uint64_t v3 = a2;
  uint64_t v4 = *(uint64_t (***)(uint64_t, uint64_t))(a1 + 24);
  if (v4)
  {
    *uint64_t v4 = nw_protocol_plugin_name_add_input_handler;
    v4[4] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_disconnect;
    v4[5] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_connected;
    v4[23] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_input_finished;
    v4[6] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_disconnected;
    v4[7] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_error;
    v4[20] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_notify;
    v4[32] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_reset;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v8 = "%{public}s called with null callbacks";
    goto LABEL_72;
  }

  if (!v17)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v8 = "%{public}s called with null callbacks, backtrace limit exceeded";
    goto LABEL_72;
  }

  uint64_t v11 = (char *)__nw_create_backtrace_string();
  uint64_t v6 = (os_log_s *)__nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v16 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v16) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    uint64_t v8 = "%{public}s called with null callbacks, no backtrace";
    goto LABEL_72;
  }

  if (v16)
  {
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v20 = "nw_protocol_plugin_name_set_callbacks";
    __int16 v21 = 2082;
    __int16 v22 = v11;
    BOOL v13 = "%{public}s called with null callbacks, dumping backtrace:%{public}s";
    goto LABEL_49;
  }

void nw_protocol_plugin_retry_begin_async(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = *(unsigned int *)(a1 + 208) + 1LL;
    uint64_t v3 = v2 << 31 >> 31;
    *(_DWORD *)(a1 + 208) = v2;
    if (v3 == v2 && (v3 & 0x8000000000000000LL) == 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = *(unsigned int *)(a1 + 208);
    *(_DWORD *)__int128 buf = 136446978;
    uint64_t v24 = "nw_protocol_plugin_retry_begin_async";
    __int16 v25 = 2082;
    uint64_t v26 = "retry->async_count";
    __int16 v27 = 2048;
    uint64_t v28 = 1LL;
    __int16 v29 = 2048;
    uint64_t v30 = v4;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        uint64_t v8 = *(unsigned int *)(a1 + 208);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v24 = "nw_protocol_plugin_retry_begin_async";
        __int16 v25 = 2082;
        uint64_t v26 = "retry->async_count";
        __int16 v27 = 2048;
        uint64_t v28 = 1LL;
        __int16 v29 = 2048;
        uint64_t v30 = v8;
        uint64_t v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v9, buf, 0x2Au);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v11)
        {
          uint64_t v12 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)__int128 buf = 136447234;
          uint64_t v24 = "nw_protocol_plugin_retry_begin_async";
          __int16 v25 = 2082;
          uint64_t v26 = "retry->async_count";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v12;
          __int16 v31 = 2082;
          os_log_type_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v11)
      {
        uint64_t v14 = *(unsigned int *)(a1 + 208);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v24 = "nw_protocol_plugin_retry_begin_async";
        __int16 v25 = 2082;
        uint64_t v26 = "retry->async_count";
        __int16 v27 = 2048;
        uint64_t v28 = 1LL;
        __int16 v29 = 2048;
        uint64_t v30 = v14;
        uint64_t v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        uint64_t v13 = *(unsigned int *)(a1 + 208);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v24 = "nw_protocol_plugin_retry_begin_async";
        __int16 v25 = 2082;
        uint64_t v26 = "retry->async_count";
        __int16 v27 = 2048;
        uint64_t v28 = 1LL;
        __int16 v29 = 2048;
        uint64_t v30 = v13;
        uint64_t v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

BOOL nw_protocol_plugin_retry_end_async(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 208);
    *(_DWORD *)(a1 + 208) = v2 - 1;
    if (v2) {
      return (*(_BYTE *)(a1 + 212) & 0x40) == 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = *(unsigned int *)(a1 + 208);
    *(_DWORD *)__int128 buf = 136446978;
    uint64_t v24 = "nw_protocol_plugin_retry_end_async";
    __int16 v25 = 2082;
    uint64_t v26 = "retry->async_count";
    __int16 v27 = 2048;
    uint64_t v28 = 1LL;
    __int16 v29 = 2048;
    uint64_t v30 = v3;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v4, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (os_log_s *)gLogObj;
        os_log_type_t v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v7 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)__int128 buf = 136446978;
          uint64_t v24 = "nw_protocol_plugin_retry_end_async";
          __int16 v25 = 2082;
          uint64_t v26 = "retry->async_count";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v7;
          uint64_t v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_16:
          _os_log_impl(&dword_181A5C000, v5, v6, v8, buf, 0x2Au);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (os_log_s *)gLogObj;
        os_log_type_t v6 = type;
        BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v10)
          {
            uint64_t v11 = *(unsigned int *)(a1 + 208);
            *(_DWORD *)__int128 buf = 136447234;
            uint64_t v24 = "nw_protocol_plugin_retry_end_async";
            __int16 v25 = 2082;
            uint64_t v26 = "retry->async_count";
            __int16 v27 = 2048;
            uint64_t v28 = 1LL;
            __int16 v29 = 2048;
            uint64_t v30 = v11;
            __int16 v31 = 2082;
            os_log_type_t v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(backtrace_string);
          goto LABEL_17;
        }

        if (v10)
        {
          uint64_t v13 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)__int128 buf = 136446978;
          uint64_t v24 = "nw_protocol_plugin_retry_end_async";
          __int16 v25 = 2082;
          uint64_t v26 = "retry->async_count";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v13;
          uint64_t v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_16;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (os_log_s *)gLogObj;
        os_log_type_t v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v12 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)__int128 buf = 136446978;
          uint64_t v24 = "nw_protocol_plugin_retry_end_async";
          __int16 v25 = 2082;
          uint64_t v26 = "retry->async_count";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v12;
          uint64_t v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_16;
        }
      }
    }

void nw_protocol_plugin_retry_reissue_output_frames( uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, int a6, int a7, const void *a8, const void *a9, uint64_t a10)
{
  uint64_t v101 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v92 = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = v92;
        BOOL v53 = os_log_type_enabled(v33, v92);
        if (backtrace_string)
        {
          if (v53)
          {
            *(_DWORD *)__int128 buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            __int16 v95 = 2082;
            BOOL v96 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s called with null retry, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v53)
        {
          *(_DWORD *)__int128 buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          BOOL v35 = "%{public}s called with null retry, no backtrace";
          goto LABEL_63;
        }
      }

      else
      {
        uint64_t v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)__int128 buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          BOOL v35 = "%{public}s called with null retry, backtrace limit exceeded";
          goto LABEL_63;
        }
      }

      goto LABEL_64;
    }

    uint64_t v33 = (os_log_s *)__nwlog_obj();
    os_log_type_t v34 = v92;
    if (!os_log_type_enabled(v33, v92)) {
      goto LABEL_64;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    BOOL v35 = "%{public}s called with null retry";
LABEL_63:
    _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0xCu);
    goto LABEL_64;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v92 = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        BOOL v36 = (char *)__nw_create_backtrace_string();
        uint64_t v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = v92;
        BOOL v54 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v54)
          {
            *(_DWORD *)__int128 buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            __int16 v95 = 2082;
            BOOL v96 = v36;
            BOOL v38 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_41;
          }

void sub_181D56810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_plugin_retry_reissue_output_frames_block_invoke(uint64_t a1)
{
  uint64_t v120 = *MEMORY[0x1895F89C0];
  if (!nw_protocol_plugin_retry_end_async(*(void *)(a1 + 40)))
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    return;
  }

  *(_BYTE *)(*(void *)(a1 + 40) + 212LL) &= ~0x20u;
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 != 2)
  {
    if (v2 != 1) {
      return;
    }
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = *(void *)(v3 + 32);
    if (v4)
    {
      uint64_t v5 = *(void **)(v4 + 40);
      if (v5 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v6 = *(void *)(v4 + 88);
        if (v6) {
          *(void *)(v4 + 88) = v6 + 1;
        }
      }

      uint64_t v7 = *(void **)(v3 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(v3 + 88);
        if (v8) {
          *(void *)(v3 + 88) = v8 + 1;
        }
      }

      uint64_t v9 = *(void *)(v4 + 24);
      if (v9)
      {
        BOOL v10 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v9 + 160);
        if (v10)
        {
          v10(v4, v3, 15LL, 0LL, 0LL);
          goto LABEL_14;
        }
      }

      __nwlog_obj();
      BOOL v55 = *(const char **)(v4 + 16);
      int buf = 136446722;
      v113 = "__nw_protocol_notify";
      if (!v55) {
        BOOL v55 = "invalid";
      }
      __int16 v114 = 2082;
      v115 = (void *)v55;
      __int16 v116 = 2048;
      uint64_t v117 = v4;
      BOOL v56 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v110 = 0;
      if (__nwlog_fault(v56, type, &v110))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          BOOL v57 = (os_log_s *)__nwlog_obj();
          os_log_type_t v58 = type[0];
          if (!os_log_type_enabled(v57, type[0])) {
            goto LABEL_182;
          }
          v59 = *(const char **)(v4 + 16);
          if (!v59) {
            v59 = "invalid";
          }
          int buf = 136446722;
          v113 = "__nw_protocol_notify";
          __int16 v114 = 2082;
          v115 = (void *)v59;
          __int16 v116 = 2048;
          uint64_t v117 = v4;
          v60 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
LABEL_180:
          uint64_t v101 = v57;
LABEL_181:
          _os_log_impl(&dword_181A5C000, v101, v58, v60, (uint8_t *)&buf, 0x20u);
          goto LABEL_182;
        }

        if (!v110)
        {
          BOOL v57 = (os_log_s *)__nwlog_obj();
          os_log_type_t v58 = type[0];
          if (!os_log_type_enabled(v57, type[0])) {
            goto LABEL_182;
          }
          v100 = *(const char **)(v4 + 16);
          if (!v100) {
            v100 = "invalid";
          }
          int buf = 136446722;
          v113 = "__nw_protocol_notify";
          __int16 v114 = 2082;
          v115 = (void *)v100;
          __int16 v116 = 2048;
          uint64_t v117 = v4;
          v60 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
          goto LABEL_180;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v84 = (os_log_s *)__nwlog_obj();
        os_log_type_t v58 = type[0];
        log = v84;
        BOOL v85 = os_log_type_enabled(v84, type[0]);
        if (backtrace_string)
        {
          if (v85)
          {
            v86 = *(const char **)(v4 + 16);
            if (!v86) {
              v86 = "invalid";
            }
            int buf = 136446978;
            v113 = "__nw_protocol_notify";
            __int16 v114 = 2082;
            v115 = (void *)v86;
            __int16 v116 = 2048;
            uint64_t v117 = v4;
            __int16 v118 = 2082;
            v119 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  log,  v58,  "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_182;
        }

        if (v85)
        {
          v105 = *(const char **)(v4 + 16);
          if (!v105) {
            v105 = "invalid";
          }
          int buf = 136446722;
          v113 = "__nw_protocol_notify";
          __int16 v114 = 2082;
          v115 = (void *)v105;
          __int16 v116 = 2048;
          uint64_t v117 = v4;
          v60 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
          uint64_t v101 = log;
          goto LABEL_181;
        }
      }

void nw_protocol_plugin_retry_set_callbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_111;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v13) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_111;
      }

      if (v13)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        __int16 v27 = 2082;
        uint64_t v28 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_112:
      if (v8) {
        goto LABEL_113;
      }
      return;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null protocol";
    goto LABEL_111;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_111;
      }

      uint64_t v14 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v15) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_111;
      }

      if (!v15) {
        goto LABEL_77;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      __int16 v27 = 2082;
      uint64_t v28 = v14;
      uint64_t v16 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_76;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null protocol->handle";
LABEL_111:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_112;
  }

  uint64_t v6 = *(void **)(v5 + 88);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
        goto LABEL_111;
      }

      uint64_t v14 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v17) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null retry_plugin, no backtrace";
        goto LABEL_111;
      }

      if (!v17) {
        goto LABEL_77;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      __int16 v27 = 2082;
      uint64_t v28 = v14;
      uint64_t v16 = "%{public}s called with null retry_plugin, dumping backtrace:%{public}s";
      goto LABEL_76;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null retry_plugin";
    goto LABEL_111;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null retry_processor, backtrace limit exceeded";
        goto LABEL_111;
      }

      uint64_t v14 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v18 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v18) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null retry_processor, no backtrace";
        goto LABEL_111;
      }

      if (!v18) {
        goto LABEL_77;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      __int16 v27 = 2082;
      uint64_t v28 = v14;
      uint64_t v16 = "%{public}s called with null retry_processor, dumping backtrace:%{public}s";
      goto LABEL_76;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null retry_processor";
    goto LABEL_111;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null connect_processor, backtrace limit exceeded";
        goto LABEL_111;
      }

      uint64_t v14 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v19 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v19) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null connect_processor, no backtrace";
        goto LABEL_111;
      }

      if (!v19) {
        goto LABEL_77;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      __int16 v27 = 2082;
      uint64_t v28 = v14;
      uint64_t v16 = "%{public}s called with null connect_processor, dumping backtrace:%{public}s";
      goto LABEL_76;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null connect_processor";
    goto LABEL_111;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null disconnect_processor, backtrace limit exceeded";
        goto LABEL_111;
      }

      uint64_t v14 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v20 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v20) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
        uint64_t v11 = "%{public}s called with null disconnect_processor, no backtrace";
        goto LABEL_111;
      }

      if (!v20) {
        goto LABEL_77;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      __int16 v27 = 2082;
      uint64_t v28 = v14;
      uint64_t v16 = "%{public}s called with null disconnect_processor, dumping backtrace:%{public}s";
      goto LABEL_76;
    }

    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null disconnect_processor";
    goto LABEL_111;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_112;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      uint64_t v11 = "%{public}s called with null error_processor";
      goto LABEL_111;
    }

    if (!v23)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_112;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      uint64_t v11 = "%{public}s called with null error_processor, backtrace limit exceeded";
      goto LABEL_111;
    }

    uint64_t v14 = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v21 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v21) {
        goto LABEL_112;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
      uint64_t v11 = "%{public}s called with null error_processor, no backtrace";
      goto LABEL_111;
    }

    if (!v21) {
      goto LABEL_77;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    __int16 v27 = 2082;
    uint64_t v28 = v14;
    uint64_t v16 = "%{public}s called with null error_processor, dumping backtrace:%{public}s";
LABEL_76:
    _os_log_impl(&dword_181A5C000, v9, v10, v16, buf, 0x16u);
    goto LABEL_77;
  }

  v6[16] = a3;
  v6[17] = a4;
  v6[18] = a5;
  v6[19] = a2;
  uint64_t v7 = *(void **)(a1 + 24);
  if (v7)
  {
    v7[14] = nw_protocol_plugin_retry_get_parameters;
    v7[17] = nw_protocol_plugin_retry_get_remote_endpoint;
    v7[3] = nw_protocol_plugin_retry_connect;
    v7[4] = nw_protocol_plugins_disconnect;
    v7[23] = nw_protocol_plugins_input_finished;
    v7[5] = nw_protocol_plugins_connected;
    v7[6] = nw_protocol_plugins_disconnected;
    v7[7] = nw_protocol_plugins_error;
    v7[20] = nw_protocol_plugins_notify;
    v7[32] = nw_protocol_plugins_reset;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null callbacks";
    goto LABEL_111;
  }

  if (!v23)
  {
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null callbacks, backtrace limit exceeded";
    goto LABEL_111;
  }

  uint64_t v14 = (char *)__nw_create_backtrace_string();
  uint64_t v9 = (os_log_s *)__nwlog_obj();
  os_log_type_t v10 = type;
  BOOL v22 = os_log_type_enabled(v9, type);
  if (!v14)
  {
    if (!v22) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    uint64_t v11 = "%{public}s called with null callbacks, no backtrace";
    goto LABEL_111;
  }

  if (v22)
  {
    *(_DWORD *)int buf = 136446466;
    uint64_t v26 = "nw_protocol_plugin_retry_set_callbacks";
    __int16 v27 = 2082;
    uint64_t v28 = v14;
    uint64_t v16 = "%{public}s called with null callbacks, dumping backtrace:%{public}s";
    goto LABEL_76;
  }

uint64_t nw_protocol_plugin_retry_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v109 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    v102 = "nw_protocol_plugin_retry_connect";
    v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v99)
      {
        os_log_type_t v61 = (os_log_s *)__nwlog_obj();
        os_log_type_t v62 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)int buf = 136446210;
          v102 = "nw_protocol_plugin_retry_connect";
          char v63 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_207;
        }

        goto LABEL_208;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      BOOL v75 = os_log_type_enabled(v61, type);
      if (!backtrace_string)
      {
        if (v75)
        {
          *(_DWORD *)int buf = 136446210;
          v102 = "nw_protocol_plugin_retry_connect";
          char v63 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_207;
        }

        goto LABEL_208;
      }

      if (!v75) {
        goto LABEL_157;
      }
      *(_DWORD *)int buf = 136446466;
      v102 = "nw_protocol_plugin_retry_connect";
      __int16 v103 = 2082;
      os_log_type_t v104 = (nw_protocol *)backtrace_string;
      char v76 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_156;
    }

    os_log_type_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    if (!os_log_type_enabled(v61, type)) {
      goto LABEL_208;
    }
    *(_DWORD *)int buf = 136446210;
    v102 = "nw_protocol_plugin_retry_connect";
    char v63 = "%{public}s called with null protocol";
LABEL_207:
    _os_log_impl(&dword_181A5C000, v61, v62, v63, buf, 0xCu);
    goto LABEL_208;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    v102 = "nw_protocol_plugin_retry_connect";
    v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v99)
      {
        os_log_type_t v61 = (os_log_s *)__nwlog_obj();
        os_log_type_t v62 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)int buf = 136446210;
          v102 = "nw_protocol_plugin_retry_connect";
          char v63 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_207;
        }

        goto LABEL_208;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      BOOL v77 = os_log_type_enabled(v61, type);
      if (!backtrace_string)
      {
        if (v77)
        {
          *(_DWORD *)int buf = 136446210;
          v102 = "nw_protocol_plugin_retry_connect";
          char v63 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_207;
        }

        goto LABEL_208;
      }

      if (!v77) {
        goto LABEL_157;
      }
      *(_DWORD *)int buf = 136446466;
      v102 = "nw_protocol_plugin_retry_connect";
      __int16 v103 = 2082;
      os_log_type_t v104 = (nw_protocol *)backtrace_string;
      char v76 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_156;
    }

    os_log_type_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    if (!os_log_type_enabled(v61, type)) {
      goto LABEL_208;
    }
    *(_DWORD *)int buf = 136446210;
    v102 = "nw_protocol_plugin_retry_connect";
    char v63 = "%{public}s called with null protocol->handle";
    goto LABEL_207;
  }

  uint64_t v4 = handle[11];
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    v102 = "nw_protocol_plugin_retry_connect";
    v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_208;
      }
      *(_DWORD *)int buf = 136446210;
      v102 = "nw_protocol_plugin_retry_connect";
      char v63 = "%{public}s called with null retry_plugin";
      goto LABEL_207;
    }

    if (!v99)
    {
      os_log_type_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (os_log_type_enabled(v61, type))
      {
        *(_DWORD *)int buf = 136446210;
        v102 = "nw_protocol_plugin_retry_connect";
        char v63 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
        goto LABEL_207;
      }

      goto LABEL_208;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v78 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (v78)
      {
        *(_DWORD *)int buf = 136446210;
        v102 = "nw_protocol_plugin_retry_connect";
        char v63 = "%{public}s called with null retry_plugin, no backtrace";
        goto LABEL_207;
      }

      goto LABEL_208;
    }

    if (!v78) {
      goto LABEL_157;
    }
    *(_DWORD *)int buf = 136446466;
    v102 = "nw_protocol_plugin_retry_connect";
    __int16 v103 = 2082;
    os_log_type_t v104 = (nw_protocol *)backtrace_string;
    char v76 = "%{public}s called with null retry_plugin, dumping backtrace:%{public}s";
LABEL_156:
    _os_log_impl(&dword_181A5C000, v61, v62, v76, buf, 0x16u);
    goto LABEL_157;
  }

  if (a2)
  {
    if (gLogDatapath)
    {
      os_log_type_t v64 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446466;
        v102 = "nw_protocol_plugin_retry_connect";
        __int16 v103 = 2048;
        os_log_type_t v104 = a1;
        _os_log_impl(&dword_181A5C000, v64, OS_LOG_TYPE_DEBUG, "%{public}s called %p", buf, 0x16u);
      }
    }

    if (!*(void *)(v4 + 160))
    {
LABEL_23:
      uint64_t output_handler = a1->output_handler;
      if (output_handler)
      {
        uint64_t v16 = output_handler->handle;
        if (v16 == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
        }

        BOOL v18 = a1->handle;
        if (v18 == &nw_protocol_ref_counted_handle)
        {
          BOOL v19 = a1[1].callbacks;
          if (v19) {
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v19->add_input_handler + 1);
          }
        }

        BOOL v20 = output_handler->callbacks;
        if (v20)
        {
          connect = (uint64_t (*)(nw_protocol *, nw_protocol *))v20->connect;
          if (connect)
          {
            uint64_t v22 = connect(output_handler, a1);
            if (v18 != &nw_protocol_ref_counted_handle)
            {
LABEL_34:
              if (v16 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
              {
                char v23 = output_handler[1].callbacks;
                if (v23)
                {
                  uint64_t v24 = (nw_protocol_callbacks *)((char *)v23 - 1);
                  output_handler[1].callbacks = v24;
                  if (!v24)
                  {
                    __int16 v25 = *(void (***)(void))output_handler[1].flow_id;
                    if (v25)
                    {
                      *(void *)output_handler[1].flow_id = 0LL;
                      v25[2](v25);
                      _Block_release(v25);
                    }

                    if ((output_handler[1].flow_id[8] & 1) != 0)
                    {
                      uint64_t v26 = *(const void **)output_handler[1].flow_id;
                      if (v26) {
                        _Block_release(v26);
                      }
                    }

                    free(output_handler);
                  }
                }
              }

              return v22;
            }

uint64_t nw_protocol_plugin_retry_get_parameters(nw_protocol *a1)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
          BOOL v17 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v25 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
          BOOL v17 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      if (!v25) {
        goto LABEL_76;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
      __int16 v39 = 2082;
      uint64_t v40 = backtrace_string;
      uint64_t v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_101;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
    BOOL v17 = "%{public}s called with null protocol";
LABEL_100:
    _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
    goto LABEL_101;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
          BOOL v17 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v27 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
          BOOL v17 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      if (!v27) {
        goto LABEL_76;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
      __int16 v39 = 2082;
      uint64_t v40 = backtrace_string;
      uint64_t v26 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_101;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
    BOOL v17 = "%{public}s called with null protocol->handle";
    goto LABEL_100;
  }

  uint64_t v2 = handle[11];
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
      BOOL v17 = "%{public}s called with null retry_plugin";
      goto LABEL_100;
    }

    if (!v35)
    {
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
        BOOL v17 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v28 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
        BOOL v17 = "%{public}s called with null retry_plugin, no backtrace";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    if (!v28) {
      goto LABEL_76;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_protocol_plugin_retry_get_parameters";
    __int16 v39 = 2082;
    uint64_t v40 = backtrace_string;
    uint64_t v26 = "%{public}s called with null retry_plugin, dumping backtrace:%{public}s";
LABEL_75:
    _os_log_impl(&dword_181A5C000, v15, v16, v26, buf, 0x16u);
    goto LABEL_76;
  }

  uint64_t v3 = *(void *)(v2 + 48);
  if (v3) {
    return v3;
  }
  uint64_t default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "__nw_protocol_get_parameters";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v38 = "__nw_protocol_get_parameters";
        BOOL v17 = "%{public}s called with null protocol";
        goto LABEL_100;
      }

uint64_t nw_protocol_plugin_retry_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
          BOOL v17 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v25 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
          BOOL v17 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      if (!v25) {
        goto LABEL_76;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
      __int16 v39 = 2082;
      uint64_t v40 = backtrace_string;
      uint64_t v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_101;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
    BOOL v17 = "%{public}s called with null protocol";
LABEL_100:
    _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
    goto LABEL_101;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
          BOOL v17 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v27 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
          BOOL v17 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_100;
        }

        goto LABEL_101;
      }

      if (!v27) {
        goto LABEL_76;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
      __int16 v39 = 2082;
      uint64_t v40 = backtrace_string;
      uint64_t v26 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_101;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
    BOOL v17 = "%{public}s called with null protocol->handle";
    goto LABEL_100;
  }

  uint64_t v2 = handle[11];
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
      BOOL v17 = "%{public}s called with null retry_plugin";
      goto LABEL_100;
    }

    if (!v35)
    {
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
        BOOL v17 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v28 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
        BOOL v17 = "%{public}s called with null retry_plugin, no backtrace";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    if (!v28) {
      goto LABEL_76;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_protocol_plugin_retry_get_remote_endpoint";
    __int16 v39 = 2082;
    uint64_t v40 = backtrace_string;
    uint64_t v26 = "%{public}s called with null retry_plugin, dumping backtrace:%{public}s";
LABEL_75:
    _os_log_impl(&dword_181A5C000, v15, v16, v26, buf, 0x16u);
    goto LABEL_76;
  }

  uint64_t v3 = *(void *)(v2 + 80);
  if (v3) {
    return v3;
  }
  uint64_t default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v38 = "__nw_protocol_get_remote_endpoint";
    char v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v38 = "__nw_protocol_get_remote_endpoint";
        BOOL v17 = "%{public}s called with null protocol";
        goto LABEL_100;
      }

void nw_protocol_plugin_reset_set_callbacks(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
      uint64_t v7 = "%{public}s called with null protocol";
LABEL_58:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      goto LABEL_59;
    }

    if (!v15)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
      uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_58;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
      uint64_t v7 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_58;
    }

    if (!v9) {
      goto LABEL_35;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
    __int16 v19 = 2082;
    BOOL v20 = backtrace_string;
    os_log_type_t v10 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
    _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    goto LABEL_35;
  }

  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
      uint64_t v7 = "%{public}s called with null protocol->handle";
      goto LABEL_58;
    }

    if (!v15)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
      uint64_t v7 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_58;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v11) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
      uint64_t v7 = "%{public}s called with null protocol->handle, no backtrace";
      goto LABEL_58;
    }

    if (!v11) {
      goto LABEL_35;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
    __int16 v19 = 2082;
    BOOL v20 = backtrace_string;
    os_log_type_t v10 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
    goto LABEL_34;
  }

  uint64_t v3 = *(void **)(v2 + 80);
  if (v3)
  {
    *uint64_t v3 = a2;
    if (*(void *)(a1 + 24)) {
      return;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v4, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v5 = (os_log_s *)__nwlog_obj();
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
        uint64_t v7 = "%{public}s called with null callbacks";
        goto LABEL_58;
      }

      if (!v15)
      {
        uint64_t v5 = (os_log_s *)__nwlog_obj();
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
        uint64_t v7 = "%{public}s called with null callbacks, backtrace limit exceeded";
        goto LABEL_58;
      }

      char v13 = (char *)__nw_create_backtrace_string();
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v14 = os_log_type_enabled(v5, type);
      if (!v13)
      {
        if (!v14) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
        uint64_t v7 = "%{public}s called with null callbacks, no backtrace";
        goto LABEL_58;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v18 = "nw_protocol_plugin_reset_set_callbacks";
        __int16 v19 = 2082;
        BOOL v20 = v13;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v13);
    }

nw_protocol_definition_t nw_protocol_copy_ws_definition(void)
{
  if (nw_protocol_copy_ws_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3592);
  }
  return (nw_protocol_definition_t)(id)nw_protocol_copy_ws_definition::definition;
}

void __nw_protocol_copy_ws_definition_block_invoke()
{
  nw_protocol_definition_t definition = nw_framer_create_definition("WebSocket", 0, &__block_literal_global_5);
  v1 = (void *)nw_protocol_copy_ws_definition::definition;
  nw_protocol_copy_ws_definition::nw_protocol_definition_t definition = (uint64_t)definition;

  nw_protocol_definition_set_options_allocator( (void *)nw_protocol_copy_ws_definition::definition,  (uint64_t)nw_ws_allocate_options,  (uint64_t)nw_ws_copy_options,  (uint64_t)nw_ws_deallocate_options);
  nw_protocol_definition_set_options_equality_check( (void *)nw_protocol_copy_ws_definition::definition,  (uint64_t)nw_ws_option_is_equal);
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  uint64_t v48 = 0LL;
  uint64_t v49 = &v48;
  uint64_t v50 = 0x16812000000LL;
  uint64_t v51 = __Block_byref_object_copy__3595;
  uint64_t v52 = __Block_byref_object_dispose__3596;
  BOOL v53 = "!0!2/\x130";
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  memset(v68, 0, 87);
  uint64_t v2 = a2;
  uint64_t v3 = MEMORY[0x1895F87A8];
  if (v2)
  {
    BOOL v4 = nw_array_create();
    uint64_t v5 = (void *)*((void *)&v57 + 1);
    *((void *)&v57 + 1) = v4;

    nw_protocol_options_t v6 = nw_framer_copy_options(v2);
    nw_protocol_options_get_log_id_str(v6, &v68[3], 84LL);
    HIWORD(v67) = 0;
    v68[0] = 0;
    uint64_t async_block = 0LL;
    p_uint64_t async_block = (uint64_t)&async_block;
    uint64_t v44 = 0x2020000000LL;
    LOBYTE(v45) = 0;
    *(void *)applier = v3;
    *(void *)&applier[8] = 3221225472LL;
    *(void *)&applier[16] = ___ZL18nw_ws_create_stateP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObject_block_invoke;
    os_log_type_t v70 = &unk_189BC65E0;
    os_log_type_t v73 = &v54;
    v71 = v2;
    BOOL v72 = &async_block;
    nw_protocol_options_access_handle(v6, applier);
    BOOL v7 = *(_BYTE *)(p_async_block + 24) == 0;

    _Block_object_dispose(&async_block, 8);
    if (v7) {
      uint64_t v8 = 2LL;
    }
    else {
      uint64_t v8 = 1LL;
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)applier = 136446210;
  *(void *)&applier[4] = "nw_ws_create_state";
  BOOL v18 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(async_block) = 16;
  char v47 = 0;
  if (__nwlog_fault(v18, &async_block, &v47))
  {
    if (async_block == 17)
    {
      __nwlog_obj();
      __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = async_block;
      if (os_log_type_enabled(v19, (os_log_type_t)async_block))
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_ws_create_state";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null framer", applier, 0xCu);
      }
    }

    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = async_block;
      BOOL v27 = os_log_type_enabled(v19, (os_log_type_t)async_block);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_ws_create_state";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v26,  "%{public}s called with null framer, dumping backtrace:%{public}s",  applier,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (v27)
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_ws_create_state";
        _os_log_impl(&dword_181A5C000, v19, v26, "%{public}s called with null framer, no backtrace", applier, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = async_block;
      if (os_log_type_enabled(v19, (os_log_type_t)async_block))
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_ws_create_state";
        _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null framer, backtrace limit exceeded",  applier,  0xCu);
      }
    }
  }

void sub_181D5BE68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, void *a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, void *a44, uint64_t a45, char a46)
{
  _Block_object_dispose(&a46, 8);
  nw_ws_state_t::~nw_ws_state_t(v46);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__3595(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a1 + 64) = v2;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  __int128 v3 = *(_OWORD *)(a2 + 88);
  *(void *)(a2 + 88) = 0LL;
  *(void *)(a2 + 96) = 0LL;
  *(_OWORD *)(a1 + 88) = v3;
  uint64_t v4 = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = 0LL;
  *(void *)(a1 + 104) = v4;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  __int128 v5 = *(_OWORD *)(a2 + 128);
  __int128 v6 = *(_OWORD *)(a2 + 144);
  __int128 v7 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 176) = v7;
  *(_OWORD *)(a1 + 128) = v5;
  *(_OWORD *)(a1 + 144) = v6;
  __int128 v8 = *(_OWORD *)(a2 + 192);
  __int128 v9 = *(_OWORD *)(a2 + 208);
  __int128 v10 = *(_OWORD *)(a2 + 224);
  *(_DWORD *)(a1 + 240) = *(_DWORD *)(a2 + 240);
  *(_OWORD *)(a1 + 208) = v9;
  *(_OWORD *)(a1 + 224) = v10;
  *(_OWORD *)(a1 + 192) = v8;
  uint64_t v11 = *(void *)(a2 + 244);
  *(void *)(a2 + 244) = 0LL;
  *(void *)(a1 + 244) = v11;
  __int128 v12 = *(_OWORD *)(a2 + 252);
  __int128 v13 = *(_OWORD *)(a2 + 268);
  *(_OWORD *)(a1 + 284) = *(_OWORD *)(a2 + 284);
  *(_OWORD *)(a1 + 268) = v13;
  *(_OWORD *)(a1 + 252) = v12;
  __n128 result = *(__n128 *)(a2 + 300);
  __int128 v15 = *(_OWORD *)(a2 + 316);
  __int128 v16 = *(_OWORD *)(a2 + 332);
  *(_OWORD *)(a1 + 343) = *(_OWORD *)(a2 + 343);
  *(_OWORD *)(a1 + 316) = v15;
  *(_OWORD *)(a1 + 332) = v16;
  *(__n128 *)(a1 + 300) = result;
  return result;
}

void __Block_byref_object_dispose__3596(id *a1)
{
}

uint64_t ___ZL18nw_ws_create_stateP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObject_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(v4 + 96) = *(void *)(a2 + 32);
  *(_WORD *)(v4 + 225) = *(_WORD *)(v4 + 225) & 0xFFFE | ((*(_BYTE *)(a2 + 70) & 4) != 0);
  nw_parameters_t v5 = nw_framer_copy_parameters(*(nw_framer_t *)(a1 + 32));
  else {
    __int16 v6 = 0;
  }
  *(_WORD *)(*(void *)(a1 + 48) + 225LL) = *(_WORD *)(*(void *)(a1 + 48) + 225LL) & 0xFFFB | v6;

  uint64_t v7 = *(void *)(a1 + 48);
  *(_DWORD *)(v7 + 176) = -1;
  *(void *)(v7 + 168) = -1LL;
  *(_WORD *)(v7 + 225) = *(_WORD *)(v7 + 225) & 0xFFBF | (8 * *(unsigned __int8 *)(a2 + 70)) & 0x40;
  *(_WORD *)(*(void *)(a1 + 48) + 225LL) = *(_WORD *)(*(void *)(a1 + 48) + 225LL) & 0xFF7F | (8
                                                                                                * *(unsigned __int8 *)(a2 + 70)) & 0x80;
  *(_WORD *)(*(void *)(a1 + 48) + 225LL) = *(_WORD *)(*(void *)(a1 + 48) + 225LL) & 0xFEFF | (((*(_BYTE *)(a2 + 70) & 0x20) != 0) << 8);
  uint64_t v8 = *(void *)(a1 + 48);
  *(_WORD *)(v8 + 220) = *(_WORD *)(a2 + 68);
  *(void *)(v8 + 152) = *(unsigned int *)(a2 + 64);
  *(void *)(v8 + 72) = 0LL;
  *(void *)(*(void *)(a1 + 48) + 80LL) = 0LL;
  *(void *)(*(void *)(a1 + 48) + 64LL) = 0LL;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(v9 + 144) = *(unsigned int *)(a2 + 60);
  *(_WORD *)(v9 + 225) &= ~0x200u;
  *(_WORD *)(*(void *)(a1 + 48) + 225LL) &= ~0x400u;
  *(_WORD *)(*(void *)(a1 + 48) + 225LL) &= ~0x800u;
  uint64_t v10 = *(void *)(a1 + 48);
  *(_DWORD *)(v10 + 212) = 0;
  if ((*(_BYTE *)(a2 + 70) & 2) == 0)
  {
    *(_DWORD *)(v10 + 180) = 1;
    *(_DWORD *)(v10 + 188) = 1;
    if (gLogDatapath)
    {
      __nwlog_obj();
      __int16 v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v40 = *(void *)(a1 + 48);
        if (v40) {
          __int16 v41 = (const char *)(v40 + 227);
        }
        else {
          __int16 v41 = "";
        }
        *(_DWORD *)url = 136446466;
        *(void *)&url[4] = "nw_ws_create_state_block_invoke";
        __int16 v48 = 2082;
        uint64_t v49 = v41;
        _os_log_impl(&dword_181A5C000, v39, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s don't skip handshake", url, 0x16u);
      }
    }

    uint64_t v11 = nw_framer_copy_parameters(*(nw_framer_t *)(a1 + 32));
    __int128 v12 = nw_parameters_copy_url_endpoint(v11);
    uint64_t v13 = *(void *)(a1 + 48);
    if ((*(_WORD *)(v13 + 225) & 4) != 0) {
      goto LABEL_10;
    }
    if (!v12)
    {
      nw_endpoint_t v23 = nw_framer_copy_remote_endpoint(*(nw_framer_t *)(a1 + 32));
      if (!v23) {
        goto LABEL_25;
      }
      os_log_type_t v24 = 0LL;
      do
      {
        BOOL v25 = v23;
        int v26 = -[nw_endpoint type](v25, "type");

        if (v26 == 2)
        {
          BOOL v27 = v25;

          os_log_type_t v24 = v27;
        }

        BOOL v28 = v25;
        nw_endpoint_t v23 = (nw_endpoint_t)v28[14];
      }

      while (v23);
      if (!v24) {
        goto LABEL_25;
      }
      *(void *)url = 0LL;
      os_log_type_t v29 = v24;
      BOOL v30 = (const char *)-[nw_endpoint hostname](v29, "hostname");

      os_log_type_t v31 = v29;
      unsigned int v32 = -[nw_endpoint port](v31, "port");

      asprintf((char **)url, "ws://%s:%d", v30, __rev16(v32));
      __int128 v12 = nw_endpoint_create_url(*(const char **)url);
      if (*(void *)url) {
        free(*(void **)url);
      }

      if (!v12)
      {
LABEL_25:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          uint64_t v34 = *(void *)(a1 + 48);
          if (v34) {
            char v35 = (const char *)(v34 + 227);
          }
          else {
            char v35 = "";
          }
          *(_DWORD *)url = 136446466;
          *(void *)&url[4] = "nw_ws_create_state_block_invoke";
          __int16 v48 = 2082;
          uint64_t v49 = v35;
          _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s unable to create url endpoint",  url,  0x16u);
        }

        nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 53);
        __int128 v12 = 0LL;
        goto LABEL_37;
      }

      uint64_t v13 = *(void *)(a1 + 48);
    }

    client_request = nw_ws_create_client_request(v13, *(void **)(a1 + 32), v12);
    __int128 v15 = client_request;
    if (client_request)
    {
      __int128 v16 = *(nw_framer **)(a1 + 32);
      BytePtr = CFDataGetBytePtr(client_request);
      CFIndex Length = CFDataGetLength(v15);
      nw_framer_write_output(v16, BytePtr, Length);
      CFRelease(v15);
      if (gLogDatapath)
      {
        __nwlog_obj();
        uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v45 = *(void *)(a1 + 48);
          if (v45) {
            char v46 = (const char *)(v45 + 227);
          }
          else {
            char v46 = "";
          }
          *(_DWORD *)url = 136446466;
          *(void *)&url[4] = "nw_ws_create_state_block_invoke";
          __int16 v48 = 2082;
          uint64_t v49 = v46;
          _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s sent handshake request",  url,  0x16u);
        }
      }

void sub_181D5C600(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_protocol_copy_ws_definition_block_invoke_6(uint64_t a1, void *a2)
{
  uint64_t v160 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(v5 + 8);
  __int16 v7 = *(_WORD *)(v6 + 273);
  if ((v7 & 0x10) != 0)
  {
    id v117 = v3;
    __nwlog_obj();
    __int16 v118 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
    v119 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v151[0] = 0;
    if (__nwlog_fault(v119, type, v151))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v120 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v121 = type[0];
        if (os_log_type_enabled(v120, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
          _os_log_impl( &dword_181A5C000,  v120,  v121,  "%{public}s ws.input: the websocket state has been destroyed, not handling input",  buf,  0xCu);
        }
      }

      else
      {
        if (v151[0])
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v124 = type[0];
          BOOL v125 = os_log_type_enabled(v123, type[0]);
          if (backtrace_string)
          {
            if (v125)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v123,  v124,  "%{public}s ws.input: the websocket state has been destroyed, not handling input, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
          }

          else
          {
            if (v125)
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
              _os_log_impl( &dword_181A5C000,  v123,  v124,  "%{public}s ws.input: the websocket state has been destroyed, not handling input, no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_169;
        }

        __nwlog_obj();
        uint64_t v120 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v126 = type[0];
        if (os_log_type_enabled(v120, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
          _os_log_impl( &dword_181A5C000,  v120,  v126,  "%{public}s ws.input: the websocket state has been destroyed, not handling input, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D5DD90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_copy_ws_definition_block_invoke_26(uint64_t a1, uint64_t a2, void *a3, size_t a4, int a5)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  int v8 = a3;
  if (gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v26 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
      *(_DWORD *)parse = 136446466;
      *(void *)&void parse[4] = "nw_protocol_copy_ws_definition_block_invoke";
      *(_WORD *)&parse[12] = 2082;
      *(void *)&parse[14] = v26;
      _os_log_impl(&dword_181A5C000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s output", parse, 0x16u);
    }
  }

  if (v8)
  {
    nw_ws_opcode_t opcode = nw_ws_metadata_get_opcode(v8);
    int v10 = opcode;
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8LL);
    int v12 = *(_DWORD *)(v11 + 224);
    if (v12 == -1)
    {
      if ((a5 & 1) == 0)
      {
LABEL_10:
        *(_DWORD *)(v11 + 224) = v10;
        uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8LL);
        int v10 = opcode;
        goto LABEL_11;
      }

void sub_181D5E40C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_29(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(unsigned __int8 **)(*(void *)(v1 + 8) + 104LL);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_protocol_copy_ws_definition_block_invoke_2_30;
  v4[3] = &unk_189BC50D0;
  v4[4] = v1;
  nw_array_apply(v2, (uint64_t)v4);
  return 1LL;
}

void __nw_protocol_copy_ws_definition_block_invoke_33(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      int v16 = 136446466;
      id v17 = "nw_ws_destroy_state";
      __int16 v18 = 2082;
      uint64_t v19 = v1 + 275;
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s destroying websocket state",  (uint8_t *)&v16,  0x16u);
    }
  }

  uint64_t v2 = *(const void **)(v1 + 72);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(v1 + 72) = 0LL;
  }

  id v3 = *(const void **)(v1 + 56);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(v1 + 56) = 0LL;
  }

  uint64_t v4 = *(void **)(v1 + 136);
  if (v4)
  {
    free(v4);
    *(void *)(v1 + 136) = 0LL;
  }

  uint64_t v5 = *(z_stream **)(v1 + 112);
  if (v5)
  {
    inflateEnd(v5);
    uint64_t v6 = *(void **)(v1 + 112);
    if (v6)
    {
      free(v6);
      *(void *)(v1 + 112) = 0LL;
    }
  }

  __int16 v7 = *(void **)(v1 + 128);
  if (v7)
  {
    free(v7);
    *(void *)(v1 + 128) = 0LL;
  }

  int v8 = *(z_stream **)(v1 + 120);
  if (v8)
  {
    deflateEnd(v8);
    uint64_t v9 = *(void **)(v1 + 120);
    if (v9)
    {
      free(v9);
      *(void *)(v1 + 120) = 0LL;
    }
  }

  int v10 = *(void **)(v1 + 64);
  *(void *)(v1 + 64) = 0LL;

  uint64_t v11 = *(void **)(v1 + 88);
  *(void *)(v1 + 88) = 0LL;

  int v12 = *(void **)(v1 + 96);
  *(void *)(v1 + 96) = 0LL;

  uint64_t v13 = *(void **)(v1 + 104);
  *(void *)(v1 + 104) = 0LL;

  BOOL v14 = *(void **)(v1 + 244);
  *(void *)(v1 + 244) = 0LL;

  *(_WORD *)(v1 + 273) |= 0x10u;
}

nw_protocol_metadata_t __nw_protocol_copy_ws_definition_block_invoke_2_35(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t metadata = nw_ws_create_metadata(nw_ws_opcode_invalid);
  nw_protocol_metadata_t v3 = metadata;
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v5 = *(void **)(v4 + 96);
  if (v5)
  {
    uint64_t v6 = metadata;
    id v7 = v5;
    if (nw_protocol_metadata_is_ws(v6))
    {
      nw_framer_message_set_value(v6, "server_response", v7, &__block_literal_global_24_50698);
LABEL_4:

      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
      goto LABEL_5;
    }

    __nwlog_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "nw_ws_metadata_set_server_response";
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if ((__nwlog_fault(v10, &type, &v17) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v20 = "nw_ws_metadata_set_server_response";
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v20 = "nw_ws_metadata_set_server_response";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }

        if (v15)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v20 = "nw_ws_metadata_set_server_response";
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v20 = "nw_ws_metadata_set_server_response";
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D5E974(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_state_t::~nw_ws_state_t(id *this)
{
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_2_30(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  unint64_t v5 = (unint64_t)nw_ws_ping_request_copy_pong_handler(v4);
  id v6 = nw_ws_ping_request_copy_client_queue(v4);
  id v7 = (dispatch_queue_s *)v6;
  if (v5 && v6)
  {
    int v8 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 53);
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_protocol_copy_ws_definition_block_invoke_3;
    v12[3] = &unk_189BC91E8;
    id v13 = v8;
    id v14 = (id)v5;
    uint64_t v9 = v8;
    dispatch_async(v7, v12);

LABEL_7:
    goto LABEL_8;
  }

  if (v5 | (unint64_t)v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8LL) + 275LL;
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v16 = "nw_protocol_copy_ws_definition_block_invoke_2";
      __int16 v17 = 2082;
      uint64_t v18 = v10;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v9,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s pong handler and client queue should both be nil",  buf,  0x16u);
    }

    goto LABEL_7;
  }

void sub_181D5EB90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

size_t __nw_protocol_copy_ws_definition_block_invoke_27( uint64_t a1, uint8_t *output_buffer, size_t output_length, unsigned int a4)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 236LL);
  if (v8 != 2)
  {
LABEL_10:
    if (v8 != 5) {
      return output_length;
    }
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v26 = *(void *)(*(void *)(a1 + 48) + 8LL) + 275LL;
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v26;
        *(_WORD *)&buf[22] = 2048;
        __int128 v57 = (void *)output_length;
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s output parsed %zu bytes",  buf,  0x20u);
      }
    }

    if (!*(_BYTE *)(a1 + 68) || *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 240LL) != 9) {
      goto LABEL_72;
    }
    dispatch_data_t v48 = (dispatch_data_t)MEMORY[0x1895F8AA8];
    id v16 = MEMORY[0x1895F8AA8];
    if (output_buffer && output_length)
    {
      dispatch_data_t v48 = dispatch_data_create(output_buffer, output_length, 0LL, 0LL);
    }

    __int16 v17 = (nw_protocol_metadata *)*(id *)(a1 + 32);
    if (nw_protocol_metadata_is_ws(v17))
    {
      *(void *)int buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000LL;
      __int128 v57 = __Block_byref_object_copy__21;
      id v58 = __Block_byref_object_dispose__22;
      id v59 = 0LL;
      uint64_t v18 = MEMORY[0x1895F87A8];
      uint64_t access_value = MEMORY[0x1895F87A8];
      uint64_t v50 = 3221225472LL;
      uint64_t v51 = __nw_ws_metadata_copy_client_queue_block_invoke;
      int v52 = &unk_189BC0970;
      char v53 = buf;
      nw_framer_message_access_value(v17, "client_queue", &access_value);
      unint64_t v19 = (unint64_t)*(id *)(*(void *)&buf[8] + 40LL);
      _Block_object_dispose(buf, 8);

      goto LABEL_19;
    }

    uint64_t v18 = MEMORY[0x1895F87A8];
    __nwlog_obj();
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_client_queue";
    __int128 v47 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(access_value) = 16;
    os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v47, &access_value, &v55) & 1) != 0)
    {
      if (access_value == 17)
      {
        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t type = access_value;
        if (os_log_type_enabled(v28, (os_log_type_t)access_value))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_client_queue";
          _os_log_impl( &dword_181A5C000,  v28,  type,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
        }
      }

      else
      {
        if (v55)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          typea = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v42 = access_value;
          BOOL v34 = os_log_type_enabled(typea, (os_log_type_t)access_value);
          if (backtrace_string)
          {
            if (v34)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_client_queue";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  typea,  v42,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
          }

          else
          {
            if (v34)
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_client_queue";
              _os_log_impl( &dword_181A5C000,  typea,  v42,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_58;
        }

        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t typeb = access_value;
        if (os_log_type_enabled(v28, (os_log_type_t)access_value))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_client_queue";
          _os_log_impl( &dword_181A5C000,  v28,  typeb,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D5F5FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL18nw_ws_parse_outputPU23objcproto12OS_nw_framer8NSObjectPU34objcproto23OS_nw_protocol_metadataS_P13nw_ws_state_t14nw_ws_opcode_tbPmPhU13block_pointerFmS8_mbbE_block_invoke( uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  if (!a2
    || !a3
    || (*(_WORD *)(*(void *)(a1 + 56) + 225LL) & 0x40) == 0
    || !nw_ws_metadata_get_permessage_deflate(*(void **)(a1 + 32))
    || *(_DWORD *)(a1 + 72) > 2u)
  {
    return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 48) + 16LL))(*(void *)(a1 + 48), a2);
  }

  *(_WORD *)(*(void *)(a1 + 56) + 225LL) |= 0x400u;
  uint64_t v6 = *(void *)(a1 + 56);
  id v7 = *(void **)(v6 + 72);
  if (!v7)
  {
    os_log_type_t v46 = malloc(0x70uLL);
    if (!v46)
    {
      __nwlog_obj();
      char v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int buf = 136446466;
      __int128 v65 = "strict_malloc";
      __int16 v66 = 2048;
      uint64_t v67 = 112LL;
      os_log_type_t v55 = (void *)_os_log_send_and_compose_impl();

      uint64_t result = __nwlog_abort((uint64_t)v55);
      if ((_DWORD)result)
      {
        __break(1u);
        return result;
      }

      free(v55);
      uint64_t v6 = *(void *)(a1 + 56);
    }

    *(void *)(v6 + 72) = v46;
    *(void *)(*(void *)(*(void *)(a1 + 56) + 72LL) + 64LL) = 0LL;
    *(void *)(*(void *)(*(void *)(a1 + 56) + 72LL) + 72LL) = 0LL;
    *(void *)(*(void *)(*(void *)(a1 + 56) + 72LL) + 80LL) = 0LL;
    uint64_t v47 = *(void *)(a1 + 56);
    uint64_t v48 = 220LL;
    if ((*(_WORD *)(v47 + 225) & 4) == 0) {
      uint64_t v48 = 221LL;
    }
    int v49 = deflateInit2_(*(z_streamp *)(v47 + 72), -1, 8, -*(unsigned __int8 *)(v47 + v48), 8, 0, "1.2.12", 112);
    if (v49)
    {
      __nwlog_obj();
      uint64_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        uint64_t v51 = *(void *)(a1 + 56);
        int v52 = zError(v49);
        char v53 = (const char *)(v51 + 227);
        __int128 v65 = "nw_ws_parse_output_block_invoke";
        *(_DWORD *)int buf = 136446722;
        if (!v51) {
          char v53 = "";
        }
        __int16 v66 = 2082;
        uint64_t v67 = (uint64_t)v53;
        __int16 v68 = 2080;
        uint64_t v69 = v52;
        _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s deflateInit2 returned %s",  buf,  0x20u);
      }

      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 40), 100);
      return 0LL;
    }

    id v7 = *(void **)(*(void *)(a1 + 56) + 72LL);
  }

  *id v7 = a2;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 72LL) + 8LL) = (_DWORD)a3;
  alloc = (dispatch_data_s *)dispatch_data_create_alloc();
  uint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(v9 + 152);
  uint64_t v11 = *(void *)(v9 + 72);
  *(_DWORD *)(v11 + 32) = v10;
  *(void *)(v11 + 24) = v63;
  while (1)
  {
    int v12 = deflate(*(z_streamp *)(*(void *)(a1 + 56) + 72LL), 2);
    int v13 = v12;
    if (v12) {
      break;
    }
    uint64_t v14 = *(void *)(a1 + 56);
    uint64_t v15 = *(unsigned int *)(*(void *)(v14 + 72) + 32LL);
    if (gLogDatapath)
    {
      uint64_t v60 = *(void *)(v14 + 152);
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = *(void *)(a1 + 56);
        uint64_t v20 = (const char *)(v19 + 227);
        BOOL v21 = v19 == 0;
        *(_DWORD *)int buf = 136446722;
        uint64_t v22 = "";
        if (!v21) {
          uint64_t v22 = v20;
        }
        __int128 v65 = "nw_ws_parse_output_block_invoke";
        __int16 v66 = 2082;
        uint64_t v67 = (uint64_t)v22;
        __int16 v68 = 2048;
        uint64_t v69 = (const char *)(v60 - v15);
        _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s writing %zu bytes of compressed data",  buf,  0x20u);
      }

      uint64_t v23 = *(void *)(*(void *)(a1 + 56) + 72LL);
      uint64_t v15 = *(unsigned int *)(v23 + 32);
      if (*(_DWORD *)(v23 + 32))
      {
LABEL_11:
        size_t size = dispatch_data_get_size(alloc);
        dispatch_data_t subrange = dispatch_data_create_subrange(alloc, 0LL, size - v15);
        goto LABEL_18;
      }
    }

    else if (*(_DWORD *)(*(void *)(v14 + 72) + 32LL))
    {
      goto LABEL_11;
    }

    uint64_t v24 = (dispatch_data_s *)dispatch_data_create_alloc();
    uint64_t v25 = *(void *)(a1 + 56);
    uint64_t v26 = *(void *)(v25 + 152);
    uint64_t v27 = *(void *)(v25 + 72);
    *(_DWORD *)(v27 + 32) = v26;
    *(void *)(v27 + 24) = v63;
    dispatch_data_t subrange = dispatch_data_create_concat(alloc, v24);

    alloc = v24;
LABEL_18:

    alloc = subrange;
  }

  if (v12 == -5)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v29 = *(void *)(a1 + 56);
        os_log_type_t v30 = (const char *)(v29 + 227);
        BOOL v21 = v29 == 0;
        uint64_t v31 = "";
        if (!v21) {
          uint64_t v31 = v30;
        }
        *(_DWORD *)int buf = 136446722;
        __int128 v65 = "nw_ws_parse_output_block_invoke";
        __int16 v66 = 2082;
        uint64_t v67 = (uint64_t)v31;
        __int16 v68 = 2048;
        uint64_t v69 = a3;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s compressed %zu bytes of data",  buf,  0x20u);
      }
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v32 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = *(void *)(a1 + 56);
      BOOL v34 = zError(v13);
      uint64_t v35 = (const char *)(v33 + 227);
      *(_DWORD *)int buf = 136446722;
      if (!v33) {
        uint64_t v35 = "";
      }
      __int128 v65 = "nw_ws_parse_output_block_invoke";
      __int16 v66 = 2082;
      uint64_t v67 = (uint64_t)v35;
      __int16 v68 = 2080;
      uint64_t v69 = v34;
      _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_ERROR, "%{public}s %{public}s deflate returned %s", buf, 0x20u);
    }

    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 40), 100);
  }

  if (*(_BYTE *)(a1 + 76))
  {
    size_t v36 = dispatch_data_get_size(alloc);
    os_log_type_t v37 = dispatch_data_create_subrange(alloc, 0LL, v36 - 4);

    size_t v38 = dispatch_data_get_size(v37);
    if ((*(_DWORD *)(a1 + 72) - 1) <= 1)
    {
      size_t v39 = v38;
      if (v38 >= **(void **)(a1 + 64))
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          unint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v57 = *(void *)(a1 + 56);
            BOOL v21 = v57 == 0;
            id v58 = (const char *)(v57 + 227);
            if (v21) {
              id v58 = "";
            }
            uint64_t v59 = **(void **)(a1 + 64);
            *(_DWORD *)int buf = 136446978;
            __int128 v65 = "nw_ws_parse_output_block_invoke";
            __int16 v66 = 2082;
            uint64_t v67 = (uint64_t)v58;
            __int16 v68 = 2048;
            uint64_t v69 = (const char *)v39;
            __int16 v70 = 2048;
            uint64_t v71 = v59;
            _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Not compressing frame because compressed (%zu bytes) is no better than uncompressed (%zu bytes)",  buf,  0x2Au);
          }
        }

        deflateReset(*(z_streamp *)(*(void *)(a1 + 56) + 72LL));

        os_log_type_t v37 = 0LL;
      }
    }

    uint64_t v40 = *(void *)(a1 + 56);
    __int16 v41 = *(_WORD *)(v40 + 225);
    if ((v41 & 0x84) == 4 || (*(_WORD *)(v40 + 225) & 0x104) == 0)
    {
      deflateReset(*(z_streamp *)(v40 + 72));
      uint64_t v40 = *(void *)(a1 + 56);
      __int16 v41 = *(_WORD *)(v40 + 225);
    }

    *(_WORD *)(v40 + 225) = v41 & 0xFBFF;
    if (v37)
    {
LABEL_40:
      size_t v42 = dispatch_data_get_size(v37);
      uint64_t v43 = MEMORY[0x1895F87A8];
      **(void **)(a1 + 64) = v42;
      applier[0] = v43;
      applier[1] = 3221225472LL;
      applier[2] = ___ZL18nw_ws_parse_outputPU23objcproto12OS_nw_framer8NSObjectPU34objcproto23OS_nw_protocol_metadataS_P13nw_ws_state_t14nw_ws_opcode_tbPmPhU13block_pointerFmS8_mbbE_block_invoke_50;
      applier[3] = &unk_189BB6680;
      id v62 = *(id *)(a1 + 48);
      BOOL v44 = dispatch_data_apply(v37, applier);

      return v44;
    }
  }

  else
  {
    os_log_type_t v37 = alloc;
    if (alloc) {
      goto LABEL_40;
    }
  }

  return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 48) + 16LL))(*(void *)(a1 + 48), a2);
}

void sub_181D5FDC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL18nw_ws_parse_outputPU23objcproto12OS_nw_framer8NSObjectPU34objcproto23OS_nw_protocol_metadataS_P13nw_ws_state_t14nw_ws_opcode_tbPmPhU13block_pointerFmS8_mbbE_block_invoke_50( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))() != 0;
}

uint64_t nw_ws_validate_frame( nw_ws_state_t *a1, int a2, int a3, unsigned int a4, int a5, unsigned int a6, int a7)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v43 = "nw_ws_validate_frame";
    uint64_t v29 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v43 = "nw_ws_validate_frame";
        os_log_type_t v32 = "%{public}s called with null state";
LABEL_106:
        _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0xCu);
      }
    }

    else
    {
      if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v39 = os_log_type_enabled(v30, type);
        if (backtrace_string)
        {
          if (v39)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v43 = "nw_ws_validate_frame";
            __int16 v44 = 2082;
            uint64_t v45 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s called with null state, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_108;
        }

        if (!v39) {
          goto LABEL_107;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v43 = "nw_ws_validate_frame";
        os_log_type_t v32 = "%{public}s called with null state, no backtrace";
        goto LABEL_106;
      }

      __nwlog_obj();
      os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v43 = "nw_ws_validate_frame";
        os_log_type_t v32 = "%{public}s called with null state, backtrace limit exceeded";
        goto LABEL_106;
      }
    }

uint64_t nw_ws_write_header( uint64_t a1, void *a2, int a3, unsigned int a4, unint64_t a5, unsigned __int8 a6, int a7)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  int v13 = a2;
  __int16 v14 = v13;
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v52 = "nw_ws_write_header";
    uint64_t v29 = (char *)_os_log_send_and_compose_impl();

    v49[0] = 16;
    output_buffer[0] = 0;
    if (v49[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = v49[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v49[0]))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v52 = "nw_ws_write_header";
        _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s called with null state", buf, 0xCu);
      }

      goto LABEL_101;
    }

    if (!output_buffer[0])
    {
      __nwlog_obj();
      os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = v49[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v49[0]))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v52 = "nw_ws_write_header";
        _os_log_impl( &dword_181A5C000,  v30,  v46,  "%{public}s called with null state, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_101;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v36 = v49[0];
    BOOL v37 = os_log_type_enabled(v30, (os_log_type_t)v49[0]);
    if (!backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v52 = "nw_ws_write_header";
        _os_log_impl(&dword_181A5C000, v30, v36, "%{public}s called with null state, no backtrace", buf, 0xCu);
      }

      goto LABEL_101;
    }

    if (v37)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v52 = "nw_ws_write_header";
      __int16 v53 = 2082;
      __int16 v54 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v30,  v36,  "%{public}s called with null state, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_66;
  }

  if (!v13)
  {
    __nwlog_obj();
    os_log_type_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v52 = "nw_ws_write_header";
    uint64_t v29 = (char *)_os_log_send_and_compose_impl();

    v49[0] = 16;
    output_buffer[0] = 0;
    if (v49[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = v49[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v49[0]))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v52 = "nw_ws_write_header";
        _os_log_impl(&dword_181A5C000, v30, v33, "%{public}s called with null framer", buf, 0xCu);
      }

void sub_181D612E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_7( uint64_t a1, const UInt8 *a2, unint64_t numBytes)
{
  unint64_t v3 = 0LL;
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a2 || !numBytes) {
    return v3;
  }
  if (CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 72LL), a2, numBytes))
  {
    if (!CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 72LL)))
    {
      unint64_t v3 = numBytes;
LABEL_32:
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 80LL) += v3;
      if (gLogDatapath)
      {
        __nwlog_obj();
        int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v28 = *(void *)(*(void *)(a1 + 40) + 8LL);
          unint64_t v29 = v28 + 275;
          uint64_t v30 = *(void *)(v28 + 80);
          *(_DWORD *)int buf = 136446722;
          __int16 v34 = "nw_protocol_copy_ws_definition_block_invoke";
          __int16 v35 = 2082;
          unint64_t v36 = v29;
          __int16 v37 = 2048;
          uint64_t v38 = v30;
          _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Appended %zu bytes to http_message",  buf,  0x20u);
        }
      }

      return v3;
    }

    CFIndex Length = CFHTTPMessageCopyBody(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 72LL));
    id v7 = Length;
    if (Length) {
      CFIndex Length = (const __CFData *)CFDataGetLength(Length);
    }
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = Length;
    unint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    unint64_t v3 = numBytes - v8;
    if (numBytes >= v8)
    {
LABEL_29:
      if (v7) {
        CFRelease(v7);
      }
      *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
      goto LABEL_32;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    *(_DWORD *)int buf = 136446722;
    __int16 v34 = "nw_protocol_copy_ws_definition_block_invoke";
    __int16 v35 = 2048;
    unint64_t v36 = v3;
    __int16 v37 = 2048;
    uint64_t v38 = v10;
    uint64_t v11 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault((const char *)v11, &type, &v31))
    {
LABEL_26:
      if (v11) {
        free(v11);
      }
      unint64_t v3 = 0LL;
      goto LABEL_29;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        *(_DWORD *)int buf = 136446722;
        __int16 v34 = "nw_protocol_copy_ws_definition_block_invoke";
        __int16 v35 = 2048;
        unint64_t v36 = v3;
        __int16 v37 = 2048;
        uint64_t v38 = v14;
        int v15 = "%{public}s UNDERFLOW: buffer length = %zu, body length = %zu";
LABEL_23:
        __int16 v23 = v12;
        os_log_type_t v24 = v13;
LABEL_24:
        _os_log_impl(&dword_181A5C000, v23, v24, v15, buf, 0x20u);
      }
    }

    else
    {
      if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v20)
          {
            uint64_t v21 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
            *(_DWORD *)int buf = 136446978;
            __int16 v34 = "nw_protocol_copy_ws_definition_block_invoke";
            __int16 v35 = 2048;
            unint64_t v36 = v3;
            __int16 v37 = 2048;
            uint64_t v38 = v21;
            __int16 v39 = 2082;
            char v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s UNDERFLOW: buffer length = %zu, body length = %zu, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (!v20) {
          goto LABEL_25;
        }
        uint64_t v26 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        *(_DWORD *)int buf = 136446722;
        __int16 v34 = "nw_protocol_copy_ws_definition_block_invoke";
        __int16 v35 = 2048;
        unint64_t v36 = v3;
        __int16 v37 = 2048;
        uint64_t v38 = v26;
        int v15 = "%{public}s UNDERFLOW: buffer length = %zu, body length = %zu, no backtrace";
        __int16 v23 = v12;
        os_log_type_t v24 = v19;
        goto LABEL_24;
      }

      __nwlog_obj();
      int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        *(_DWORD *)int buf = 136446722;
        __int16 v34 = "nw_protocol_copy_ws_definition_block_invoke";
        __int16 v35 = 2048;
        unint64_t v36 = v3;
        __int16 v37 = 2048;
        uint64_t v38 = v22;
        int v15 = "%{public}s UNDERFLOW: buffer length = %zu, body length = %zu, backtrace limit exceeded";
        goto LABEL_23;
      }
    }

BOOL __nw_protocol_copy_ws_definition_block_invoke_20( uint64_t a1, const uint8_t *a2, unint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = a2;
  uint64_t v120 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    int v65 = a5;
    __nwlog_obj();
    __int16 v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v67 = *(void *)(*(void *)(a1 + 48) + 8LL) + 275LL;
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v67;
      *(_WORD *)&buf[22] = 2048;
      *(void *)uint64_t v108 = a3;
      _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s input parse_input got %zu bytes",  buf,  0x20u);
    }

    a5 = v65;
    if (!v6) {
      goto LABEL_8;
    }
  }

  else if (!a2)
  {
    goto LABEL_8;
  }

  if (a3)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8LL);
    int v9 = *(_DWORD *)(v8 + 232);
    if (v9 == 1 || !v9 && *(_BYTE *)(v8 + 272))
    {
      int v10 = a5;
      char v11 = nw_utf8_validator_parse((char *)(v8 + 270), (uint64_t)v6, a3, a5);
      a5 = v10;
      if ((v11 & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8LL) + 275LL;
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v19;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s received invalid utf-8 sequence",  buf,  0x16u);
        }

        a3 = 0LL;
        *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
        return a3;
      }
    }
  }

void sub_181D6284C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL17nw_ws_parse_inputPU23objcproto12OS_nw_framer8NSObjectP13nw_ws_state_tmmPhU13block_pointerFmS4_mbbE_block_invoke( uint64_t a1, uint64_t a2, const char *a3)
{
  unint64_t v3 = a3;
  uint64_t v76 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 48);
  if ((*(_WORD *)(v6 + 216) & 0x80) != 0)
  {
    if (!a3) {
      goto LABEL_14;
    }
  }

  else
  {
    if (*(void *)(v6 + 88)) {
      BOOL v7 = a3 == 0LL;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7) {
      goto LABEL_14;
    }
  }

  uint64_t v8 = 0LL;
  do
  {
    char v9 = *(_BYTE *)(*(void *)(a1 + 48)
    v8[a2] = v9;
    uint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(v10 + 88);
    if (v11) {
      v8[v11 + *(void *)(v10 + 120)] = v9;
    }
    ++v8;
  }

  while (a3 != v8);
  uint64_t v6 = *(void *)(a1 + 48);
LABEL_14:
  uint64_t v12 = &a3[*(void *)(v6 + 120)];
  *(void *)(v6 + 120) = v12;
  __int16 v13 = *(_WORD *)(v6 + 225);
  BOOL v14 = (v13 & 8) != 0 && v12 == *(const char **)(v6 + 112);
  if (gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v55 = *(void *)(a1 + 48);
      uint64_t v56 = (const char *)(v55 + 227);
      int v57 = *(const char **)(v55 + 120);
      if (!v55) {
        uint64_t v56 = "";
      }
      int v58 = (*(unsigned __int16 *)(v55 + 225) >> 11) & 1;
      *(_DWORD *)int buf = 136447234;
      uint64_t v67 = "nw_ws_parse_input_block_invoke";
      __int16 v68 = 2082;
      uint64_t v69 = (uint64_t)v56;
      __int16 v70 = 2048;
      uint64_t v71 = v57;
      __int16 v72 = 1024;
      int v73 = v58;
      __int16 v74 = 1024;
      BOOL v75 = v14;
      _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s input input_itr=%zu, inflating = %d, is_final = %d",  buf,  0x2Cu);
    }

    uint64_t v6 = *(void *)(a1 + 48);
    __int16 v13 = *(_WORD *)(v6 + 225);
  }

  int v15 = *(void **)(v6 + 196);
  if ((v13 & 0xA00) == 0)
  {
    if (v15) {
      nw_ws_metadata_set_permessage_deflate(v15, 0);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
    return (BOOL)v3;
  }

  nw_ws_metadata_set_permessage_deflate(v15, 1u);
  *(_WORD *)(*(void *)(a1 + 48) + 225LL) |= 0x800u;
  uint64_t v16 = *(void *)(a1 + 48);
  uint64_t v17 = *(void *)(v16 + 64);
  if (v17)
  {
LABEL_20:
    *(_DWORD *)(v17 + 8) = (_DWORD)v3;
    *(void *)uint64_t v17 = a2;
    BOOL v18 = v14;
    while (1)
    {
      unsigned int v31 = inflate(*(z_streamp *)(*(void *)(a1 + 48) + 64LL), 2);
      int v32 = v31;
      if (v31 > 1)
      {
        if (v31 != -5)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v27 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            uint64_t v50 = *(void *)(a1 + 48);
            int v51 = zError(v32);
            size_t v52 = (const char *)(v50 + 227);
            *(_DWORD *)int buf = 136446722;
            if (!v50) {
              size_t v52 = "";
            }
            uint64_t v67 = "nw_ws_parse_input_block_invoke";
            __int16 v68 = 2082;
            uint64_t v69 = (uint64_t)v52;
            __int16 v70 = 2080;
            uint64_t v71 = v51;
            _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s inflate returned %s",  buf,  0x20u);
          }

          goto LABEL_69;
        }

        if (gLogDatapath)
        {
          __nwlog_obj();
          uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v44 = *(void *)(a1 + 48);
            id v45 = (const char *)(v44 + 227);
            BOOL v7 = v44 == 0;
            os_log_type_t v46 = "";
            if (!v7) {
              os_log_type_t v46 = v45;
            }
            *(_DWORD *)int buf = 136446722;
            uint64_t v67 = "nw_ws_parse_input_block_invoke";
            __int16 v68 = 2082;
            uint64_t v69 = (uint64_t)v46;
            __int16 v70 = 2048;
            uint64_t v71 = v3;
            _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s finished processing %zu bytes of compressed data",  buf,  0x20u);
          }
        }

        if (!v14) {
          return (BOOL)v3;
        }
        if (!v18)
        {
          (*(void (**)(void, void))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40), 0LL);
          *(_WORD *)(*(void *)(a1 + 48) + 225LL) &= ~0x800u;
          return (BOOL)v3;
        }

        if (gLogDatapath)
        {
          __nwlog_obj();
          BOOL v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v40 = *(void *)(a1 + 48);
            uint64_t v41 = (const char *)(v40 + 227);
            BOOL v7 = v40 == 0;
            size_t v42 = "";
            if (!v7) {
              size_t v42 = v41;
            }
            *(_DWORD *)int buf = 136446466;
            uint64_t v67 = "nw_ws_parse_input_block_invoke";
            __int16 v68 = 2082;
            uint64_t v69 = (uint64_t)v42;
            _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s adding trailer to last compressed payload in message",  buf,  0x16u);
          }
        }

        BOOL v18 = 0;
        uint64_t v30 = *(void *)(*(void *)(a1 + 48) + 64LL);
        *(_DWORD *)(v30 + 8) = 4;
        *(void *)uint64_t v30 = &inflate_final_payload_trailer;
      }

      else
      {
        if (v31 == 1) {
          inflateReset(*(z_streamp *)(*(void *)(a1 + 48) + 64LL));
        }
        nw_ws_close_code_t v33 = *(void **)(a1 + 48);
        uint64_t v34 = v33[18];
        uint64_t v35 = *(unsigned int *)(v33[8] + 32LL);
        id v36 = (const char *)(v34 - v35);
        if (v34 != v35)
        {
          if (gLogDatapath)
          {
            __nwlog_obj();
            log = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v47 = *(void *)(a1 + 48);
              uint64_t v48 = (const char *)(v47 + 227);
              BOOL v7 = v47 == 0;
              size_t v49 = "";
              if (!v7) {
                size_t v49 = v48;
              }
              *(_DWORD *)int buf = 136446722;
              uint64_t v67 = "nw_ws_parse_input_block_invoke";
              __int16 v68 = 2082;
              uint64_t v69 = (uint64_t)v49;
              __int16 v70 = 2048;
              uint64_t v71 = v36;
              _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s delivering %zu bytes of uncompressed data",  buf,  0x20u);
            }

            nw_ws_close_code_t v33 = *(void **)(a1 + 48);
          }

          (*(void (**)(void, void))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40), v33[10]);
          __int16 v37 = *(void **)(a1 + 48);
          uint64_t v38 = v37[8];
          *(_DWORD *)(v38 + 32) = v37[18];
          *(void *)(v38 + 24) = v37[10];
        }
      }

      if (v32 == 1) {
        return (BOOL)v3;
      }
    }
  }

  uint64_t v19 = malloc(0x70uLL);
  if (!v19)
  {
    __nwlog_obj();
    int v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446466;
    uint64_t v67 = "strict_malloc";
    __int16 v68 = 2048;
    uint64_t v69 = 112LL;
    size_t v60 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v60);
    if (result) {
      goto LABEL_83;
    }
    free(v60);
    uint64_t v16 = *(void *)(a1 + 48);
  }

  *(void *)(v16 + 64) = v19;
  size_t v20 = *(void *)(*(void *)(a1 + 48) + 144LL);
  if (!v20)
  {
    __nwlog_obj();
    unsigned int v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    uint64_t v67 = "strict_malloc";
    uint64_t v62 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v62);
    if (result) {
      goto LABEL_83;
    }
    free(v62);
  }

  uint64_t v21 = malloc(v20);
  if (v21)
  {
LABEL_27:
    *(void *)(*(void *)(a1 + 48) + 80LL) = v21;
    uint64_t v22 = *(void **)(a1 + 48);
    uint64_t v23 = v22[8];
    *(_DWORD *)(v23 + 32) = v22[18];
    *(void *)(v23 + 24) = v22[10];
    *(void *)(*(void *)(*(void *)(a1 + 48) + 64LL) + 64LL) = 0LL;
    *(void *)(*(void *)(*(void *)(a1 + 48) + 64LL) + 72LL) = 0LL;
    *(void *)(*(void *)(*(void *)(a1 + 48) + 64LL) + 80LL) = 0LL;
    uint64_t v24 = *(void *)(a1 + 48);
    uint64_t v25 = 220LL;
    if ((*(_WORD *)(v24 + 225) & 4) != 0) {
      uint64_t v25 = 221LL;
    }
    int v26 = inflateInit2_(*(z_streamp *)(v24 + 64), -*(unsigned __int8 *)(v24 + v25), "1.2.12", 112);
    if (!v26)
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 48) + 64LL);
      goto LABEL_20;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = *(void *)(a1 + 48);
      *(_DWORD *)int buf = 136446722;
      uint64_t v67 = "nw_ws_parse_input_block_invoke";
      if (v28) {
        unint64_t v29 = (const char *)(v28 + 227);
      }
      else {
        unint64_t v29 = "";
      }
      __int16 v68 = 2082;
      uint64_t v69 = (uint64_t)v29;
      __int16 v70 = 1024;
      LODWORD(v71) = v26;
      _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s inflateInit2 returned %d",  buf,  0x1Cu);
    }

void sub_181D63198(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL24nw_ws_process_ping_frameP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObject_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a2 + 70) & 1) != 0)
  {
    nw_ws_write_control_frame( *(void *)(a1 + 40),  *(void **)(a1 + 32),  10,  0x3EDu,  *(void *)(*(void *)(a1 + 40) + 88LL),  *(void *)(*(void *)(a1 + 40) + 112LL));
    if (gLogDatapath)
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v5 = *(void *)(a1 + 40);
        uint64_t v6 = (const char *)(v5 + 227);
        if (!v5) {
          uint64_t v6 = "";
        }
        uint64_t v7 = *(void *)(v5 + 112);
        uint64_t v8 = *(void *)(v5 + 88);
        int v9 = 136446978;
        uint64_t v10 = "nw_ws_process_ping_frame_block_invoke";
        __int16 v11 = 2082;
        uint64_t v12 = v6;
        __int16 v13 = 1040;
        int v14 = v7;
        __int16 v15 = 2096;
        uint64_t v16 = v8;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s replying to ping frame '%{network:data}.*P'",  (uint8_t *)&v9,  0x26u);
      }
    }
  }

  return 1LL;
}

BOOL ___ZL24nw_ws_process_pong_frameP13nw_ws_state_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3;
  uint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = (dispatch_data_s *)v5[1];
    goto LABEL_3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v10 = (id)gLogObj;
  *(_DWORD *)int buf = 136446210;
  uint64_t v21 = "nw_ws_ping_request_copy_contents";
  __int16 v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_ws_ping_request_copy_contents";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null ping_request", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v21 = "nw_ws_ping_request_copy_contents";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null ping_request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_ws_ping_request_copy_contents";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null ping_request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_ws_ping_request_copy_contents";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null ping_request, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t ___ZL24nw_ws_process_pong_frameP13nw_ws_state_t_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void nw_ws_write_control_frame( uint64_t a1, void *a2, int a3, unsigned int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v11 = a2;
  if (!a1)
  {
    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_ws_write_control_frame";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v16, type, &v26))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type[0];
        if (os_log_type_enabled(v17, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v28 = "nw_ws_write_control_frame";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null state", buf, 0xCu);
        }
      }

      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type[0];
        BOOL v23 = os_log_type_enabled(v17, type[0]);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v28 = "nw_ws_write_control_frame";
            __int16 v29 = 2082;
            unint64_t v30 = (unint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null state, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (v23)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v28 = "nw_ws_write_control_frame";
          _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s called with null state, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type[0];
        if (os_log_type_enabled(v17, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v28 = "nw_ws_write_control_frame";
          _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null state, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D639D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_copy_ws_definition_block_invoke_23(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
      int v4 = *(_DWORD *)(a1 + 48);
      int v5 = 136446722;
      uint64_t v6 = "nw_protocol_copy_ws_definition_block_invoke";
      __int16 v7 = 2082;
      uint64_t v8 = v3;
      __int16 v9 = 1024;
      int v10 = v4;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s marking failed with error code %d",  (uint8_t *)&v5,  0x1Cu);
    }
  }

  nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), *(_DWORD *)(a1 + 48));
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_18(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 4 || a2 == 0) {
    return 0LL;
  }
  else {
    return 4LL;
  }
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_16(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 2 || a2 == 0) {
    return 0LL;
  }
  else {
    return 2LL;
  }
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_14(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 8 || a2 == 0) {
    return 0LL;
  }
  else {
    return 8LL;
  }
}

uint64_t __nw_protocol_copy_ws_definition_block_invoke_11(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 2 || a2 == 0) {
    return 0LL;
  }
  else {
    return 2LL;
  }
}

uint64_t __Block_byref_object_copy__3860(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__3861(uint64_t a1)
{
}

BOOL ___ZL61nw_protocol_instance_registrar_copy_tls_metadata_for_protocolP41NWConcrete_nw_protocol_instance_registrarP11nw_protocol_block_invoke( void *a1, uint64_t a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v5 = a3;
  BOOL is_tls = nw_protocol_metadata_is_tls(v5);
  if (is_tls)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = a1[4];
        uint64_t v10 = a1[6];
        int v11 = 136446978;
        uint64_t v12 = "nw_protocol_instance_registrar_copy_tls_metadata_for_protocol_block_invoke";
        __int16 v13 = 2112;
        uint64_t v14 = v9;
        __int16 v15 = 2112;
        BOOL v16 = v5;
        __int16 v17 = 2048;
        uint64_t v18 = v10;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ found TLS metadata %@ for protocol %p",  (uint8_t *)&v11,  0x2Au);
      }
    }

    objc_storeStrong((id *)(*(void *)(a1[5] + 8LL) + 40LL), a3);
  }

  return !is_tls;
}

void sub_181D63DA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL62nw_protocol_instance_registrar_copy_san_list_from_tls_metadataP41NWConcrete_nw_protocol_instance_registrarP11nw_protocolPU34objcproto23OS_nw_protocol_metadata8NSObjectt_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a2;
  if (gLogDatapath)
  {
    __nwlog_obj();
    size_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = *(void *)(a1 + 56);
      os_log_type_t v22 = *(char **)(a1 + 32);
      uint64_t v23 = *(void *)(a1 + 40);
      int buf = 136447234;
      id v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
      __int16 v37 = 2112;
      uint64_t v38 = v22;
      __int16 v39 = 2048;
      uint64_t v40 = v21;
      __int16 v41 = 2112;
      uint64_t v42 = v23;
      __int16 v43 = 2112;
      uint64_t v44 = v3;
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ protocol %p, tls metdata %@ found certificate: %@",  (uint8_t *)&buf,  0x34u);
    }
  }

  SecCertificateRef cf = sec_certificate_copy_ref(v3);
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  id obj = (id)SecCertificateCopyDNSNames();
  uint64_t v4 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v31;
    do
    {
      for (uint64_t i = 0LL; i != v4; ++i)
      {
        if (*(void *)v31 != v5) {
          objc_enumerationMutation(obj);
        }
        __int16 v7 = *(char **)(*((void *)&v30 + 1) + 8 * i);
        if (gLogDatapath)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v19 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            int buf = 136446466;
            id v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
            __int16 v37 = 2112;
            uint64_t v38 = v7;
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s \tgot dns name: %@",  (uint8_t *)&buf,  0x16u);
          }
        }

        uint64_t v8 = (const char *)objc_msgSend(v7, "UTF8String", p_buf, v25);
        if (v8)
        {
          BOOL host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(v8, *(unsigned __int16 *)(a1 + 64));
          nw_array_append(*(void *)(a1 + 48), (void *)host_with_numeric_port);

          continue;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          int buf = 136446466;
          id v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
          __int16 v37 = 2112;
          uint64_t v38 = v7;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s failed to get UTF8 string from name %@",  (uint8_t *)&buf,  0x16u);
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        int buf = 136446210;
        id v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
        LODWORD(v25) = 12;
        p_int buf = &buf;
        uint64_t v12 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v28 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v13 = (os_log_s *)(id)gLogObj;
          os_log_type_t v14 = type;
          if (os_log_type_enabled(v13, type))
          {
            int buf = 136446210;
            id v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s failed to get UTF8 string from DNS name",  (uint8_t *)&buf,  0xCu);
          }

void sub_181D64364( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL62nw_protocol_instance_registrar_copy_san_list_from_tls_metadataP41NWConcrete_nw_protocol_instance_registrarP11nw_protocolPU34objcproto23OS_nw_protocol_metadata8NSObjectt_block_invoke_70( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  id v5 = *(id *)(a1 + 32);
  id v6 = v4;
  __int16 v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    id v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null array", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v12) {
          goto LABEL_41;
        }
        goto LABEL_40;
      }

      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
        _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null array, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_38;
  }

  if (!v6)
  {
    __nwlog_obj();
    __int16 v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v28)
    {
      size_t v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v13, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_array_contains_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v20;
          _os_log_impl( &dword_181A5C000,  v13,  v21,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v20);
LABEL_39:
        if (!v12)
        {
LABEL_41:

          goto LABEL_4;
        }

_BYTE *nw_protocol_instance_registrar_copy_next_registered_endpoint(void *a1, int a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v38 = "nw_endpoint_is_registered";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v19, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        size_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        size_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v38 = "nw_endpoint_is_registered";
            __int16 v39 = 2082;
            uint64_t v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_37;
        }

        if (v24)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        size_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v38 = "nw_endpoint_is_registered";
          _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D64FB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_instance_registrar_add_edges_for_instance_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v101 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  char v5 = *(void **)(a1 + 40);
  id v6 = *(void **)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  id v8 = (char *)*(id *)(a1 + 32);
  id v9 = v5;
  id v10 = v4;
  id v11 = v6;
  uint64_t v12 = v11;
  if (!v8)
  {
    __nwlog_obj();
    id v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    char v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null registrar", buf, 0xCu);
      }
    }

    else if (v83)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = type;
      BOOL v43 = os_log_type_enabled(v29, type);
      if (backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          __int16 v87 = 2082;
          BOOL v88 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v42,  "%{public}s called with null registrar, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_153:
        if (!v28) {
          goto LABEL_26;
        }
LABEL_154:
        free(v28);
        goto LABEL_26;
      }

      if (v43)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v42, "%{public}s called with null registrar, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v74 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl( &dword_181A5C000,  v29,  v74,  "%{public}s called with null registrar, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D6647C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL54nw_protocol_instance_registrar_array_contains_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  int is_equal = nw_endpoint_is_equal(*(void **)(a1 + 32), a3, 31LL);
  if (is_equal) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  return is_equal ^ 1u;
}

void nw_protocol_instance_registrar_add_wildcard_edge_for_instance(void *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v116 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  id v8 = a2;
  id v97 = a4;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
    __int16 v37 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl(&dword_181A5C000, v38, v39, "%{public}s called with null registrar", buf, 0xCu);
      }
    }

    else if (v98)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v45 = type;
      BOOL v46 = os_log_type_enabled(v38, type);
      if (backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
          __int16 v102 = 2082;
          uint64_t v103 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v38,  v45,  "%{public}s called with null registrar, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_131:
        if (!v37) {
          goto LABEL_42;
        }
LABEL_132:
        free(v37);
        goto LABEL_42;
      }

      if (v46)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl(&dword_181A5C000, v38, v45, "%{public}s called with null registrar, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v78 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl( &dword_181A5C000,  v38,  v78,  "%{public}s called with null registrar, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D67B10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_protocol_instance_registrar_add_instance(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  if (!v3)
  {
    __nwlog_obj();
    char v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_instance";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_instance";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null registrar", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_instance";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v14,  "%{public}s called with null registrar, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v6) {
          goto LABEL_5;
        }
LABEL_43:
        free(v6);
        goto LABEL_5;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_instance";
        _os_log_impl(&dword_181A5C000, v7, v14, "%{public}s called with null registrar, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_instance";
        _os_log_impl( &dword_181A5C000,  v7,  v19,  "%{public}s called with null registrar, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D68160( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_registrar_add_instance_block_invoke(void *a1, __n128 a2)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void **)(a1[4] + 16LL);
  if (!v3) {
    goto LABEL_15;
  }
  char v4 = 0;
  a2.n128_u64[0] = 136447234LL;
  do
  {
    char v5 = v3;
    uint64_t v3 = (void *)*v3;
    if (v5[2] == a1[6])
    {
      *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = v5;
      if (gLogDatapath)
      {
        __n128 v35 = a2;
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v7 = a1[4];
          uint64_t v8 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
          uint64_t v9 = a1[6];
          os_log_type_t v10 = *(char **)(v9 + 16);
          *(_DWORD *)int buf = v35.n128_u32[0];
          os_log_type_t v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
          __int16 v40 = 2112;
          uint64_t v41 = v7;
          __int16 v42 = 2048;
          uint64_t v43 = v8;
          __int16 v44 = 2048;
          uint64_t v45 = v9;
          __int16 v46 = 2080;
          os_log_type_t v47 = v10;
          _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ had existing entry %p for instance %p (%s)",  buf,  0x34u);
        }

        char v4 = 1;
        a2 = v35;
      }

      else
      {
        char v4 = 1;
      }
    }
  }

  while (v3);
  if ((v4 & 1) == 0)
  {
LABEL_15:
    os_log_type_t v14 = calloc(1uLL, 0x20uLL);
    if (!v14)
    {
      __nwlog_obj();
      uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int buf = 136446722;
      os_log_type_t v39 = "strict_calloc";
      __int16 v40 = 2048;
      uint64_t v41 = 1LL;
      __int16 v42 = 2048;
      uint64_t v43 = 32LL;
      os_log_type_t v34 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v34))
      {
        __break(1u);
        return;
      }

      free(v34);
    }

    v14[2] = a1[6];
    uint64_t v15 = *(void *)(a1[4] + 16LL);
    *os_log_type_t v14 = v15;
    if (v15) {
      *(void *)(*(void *)(a1[4] + 16LL) + 8LL) = v14;
    }
    *(void *)(a1[4] + 16LL) = v14;
    uint64_t v16 = a1[4];
    v14[1] = v16 + 16;
    uint64_t v17 = *(void *)(v16 + 64);
    uint64_t v18 = v17 + 1;
    uint64_t v19 = v17 == -1;
    uint64_t v20 = v19 << 63 >> 63;
    *(void *)(v16 + 64) = v18;
    if (v20 == v19 && (v20 & 0x8000000000000000LL) == 0) {
      goto LABEL_32;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v21 = (id)gLogObj;
    uint64_t v22 = *(void *)(a1[4] + 64LL);
    *(_DWORD *)int buf = 136446978;
    os_log_type_t v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
    __int16 v40 = 2082;
    uint64_t v41 = (uint64_t)"registrar->instance_count";
    __int16 v42 = 2048;
    uint64_t v43 = 1LL;
    __int16 v44 = 2048;
    uint64_t v45 = v22;
    id v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v23, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (os_log_s *)(id)gLogObj;
        os_log_type_t v25 = type;
        if (!os_log_type_enabled(v24, type)) {
          goto LABEL_39;
        }
        uint64_t v26 = *(void *)(a1[4] + 64LL);
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        __int16 v40 = 2082;
        uint64_t v41 = (uint64_t)"registrar->instance_count";
        __int16 v42 = 2048;
        uint64_t v43 = 1LL;
        __int16 v44 = 2048;
        uint64_t v45 = v26;
        id v27 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
        goto LABEL_38;
      }

      if (!v36)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (os_log_s *)(id)gLogObj;
        os_log_type_t v25 = type;
        if (!os_log_type_enabled(v24, type)) {
          goto LABEL_39;
        }
        uint64_t v31 = *(void *)(a1[4] + 64LL);
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        __int16 v40 = 2082;
        uint64_t v41 = (uint64_t)"registrar->instance_count";
        __int16 v42 = 2048;
        uint64_t v43 = 1LL;
        __int16 v44 = 2048;
        uint64_t v45 = v31;
        id v27 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = (os_log_s *)(id)gLogObj;
      os_log_type_t v25 = type;
      BOOL v29 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (!v29) {
          goto LABEL_39;
        }
        uint64_t v32 = *(void *)(a1[4] + 64LL);
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        __int16 v40 = 2082;
        uint64_t v41 = (uint64_t)"registrar->instance_count";
        __int16 v42 = 2048;
        uint64_t v43 = 1LL;
        __int16 v44 = 2048;
        uint64_t v45 = v32;
        id v27 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
LABEL_38:
        _os_log_impl(&dword_181A5C000, v24, v25, v27, buf, 0x2Au);
LABEL_39:

        if (!v23) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }

      if (v29)
      {
        uint64_t v30 = *(void *)(a1[4] + 64LL);
        *(_DWORD *)int buf = 136447234;
        os_log_type_t v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        __int16 v40 = 2082;
        uint64_t v41 = (uint64_t)"registrar->instance_count";
        __int16 v42 = 2048;
        uint64_t v43 = 1LL;
        __int16 v44 = 2048;
        uint64_t v45 = v30;
        __int16 v46 = 2082;
        os_log_type_t v47 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
      }

      free(backtrace_string);
    }

    if (!v23)
    {
LABEL_31:
      *(void *)(a1[4] + 64LL) = -1LL;
LABEL_32:
      *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = v14;
      return;
    }

void nw_protocol_instance_registrar_remove_instance(void *a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    char v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v27 = "nw_protocol_instance_registrar_remove_instance";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          id v27 = "nw_protocol_instance_registrar_remove_instance";
          __int16 v28 = 2082;
          BOOL v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v14,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v6) {
          goto LABEL_5;
        }
LABEL_43:
        free(v6);
        goto LABEL_5;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_181A5C000, v7, v14, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl( &dword_181A5C000,  v7,  v19,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D68D6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_registrar_remove_instance_block_invoke(uint64_t a1)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 16LL);
  if (v1)
  {
    uint64_t v3 = &qword_18C45F000;
    char v4 = &nwlog_legacy_init(void)::init_once;
    while (1)
    {
      char v5 = (void *)*v1;
      if (v1[2] != *(void *)(a1 + 40)) {
        goto LABEL_5;
      }
      if (*((_BYTE *)v3 + 1537))
      {
        __nwlog_obj();
        __int16 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v31 = *(const char **)(a1 + 32);
          uint64_t v32 = *(void *)(a1 + 40);
          uint64_t v33 = *(void *)(v32 + 16);
          *(_DWORD *)int buf = 136446978;
          __int16 v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
          __int16 v38 = 2112;
          os_log_type_t v39 = v31;
          __int16 v40 = 2048;
          uint64_t v41 = v32;
          __int16 v42 = 2080;
          uint64_t v43 = v33;
          _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ found instance %p of %s, removing",  buf,  0x2Au);
        }
      }

      id v6 = (void *)v1[3];
      v1[3] = 0LL;

      uint64_t v7 = (void *)*v1;
      if (*v1) {
        v7[1] = v1[1];
      }
      *(void *)v1[1] = v7;
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(v8 + 64);
      *(void *)(v8 + 64) = v9 - 1;
      if (!v9) {
        break;
      }
LABEL_4:
      free(v1);
LABEL_5:
      uint64_t v1 = v5;
      if (!v5) {
        return;
      }
    }

    pthread_once(v4, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 64LL);
    *(_DWORD *)int buf = 136446978;
    __int16 v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
    __int16 v38 = 2082;
    os_log_type_t v39 = "registrar->instance_count";
    __int16 v40 = 2048;
    uint64_t v41 = 1LL;
    __int16 v42 = 2048;
    uint64_t v43 = v11;
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v12, &type, &v34))
    {
LABEL_24:
      if (!v12) {
        goto LABEL_3;
      }
      goto LABEL_30;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(v4, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled((os_log_t)v13, type))
      {
LABEL_23:

        goto LABEL_24;
      }

      uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 64LL);
      *(_DWORD *)int buf = 136446978;
      __int16 v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
      __int16 v38 = 2082;
      os_log_type_t v39 = "registrar->instance_count";
      __int16 v40 = 2048;
      uint64_t v41 = 1LL;
      __int16 v42 = 2048;
      uint64_t v43 = v15;
      uint64_t v16 = (os_log_s *)v13;
      os_log_type_t v17 = v14;
      BOOL v18 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
    }

    else
    {
      if (v34)
      {
        backtrace_string = __nw_create_backtrace_string();
        os_log_type_t v20 = v4;
        id v21 = (char *)backtrace_string;
        uint64_t v22 = v20;
        pthread_once(v20, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v23, type);
        if (v21)
        {
          if (v25)
          {
            uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 64LL);
            *(_DWORD *)int buf = 136447234;
            __int16 v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
            __int16 v38 = 2082;
            os_log_type_t v39 = "registrar->instance_count";
            __int16 v40 = 2048;
            uint64_t v41 = 1LL;
            __int16 v42 = 2048;
            uint64_t v43 = v26;
            __int16 v44 = 2082;
            uint64_t v45 = v21;
            _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v21);
        }

        else
        {
          if (v25)
          {
            uint64_t v29 = *(void *)(*(void *)(a1 + 32) + 64LL);
            *(_DWORD *)int buf = 136446978;
            __int16 v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
            __int16 v38 = 2082;
            os_log_type_t v39 = "registrar->instance_count";
            __int16 v40 = 2048;
            uint64_t v41 = 1LL;
            __int16 v42 = 2048;
            uint64_t v43 = v29;
            _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace",  buf,  0x2Au);
          }
        }

        char v4 = v22;
        uint64_t v3 = &qword_18C45F000;
        if (!v12) {
          goto LABEL_3;
        }
LABEL_30:
        free(v12);
LABEL_3:
        *(void *)(*(void *)(a1 + 32) + 64LL) = 0LL;
        goto LABEL_4;
      }

      pthread_once(v4, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v27 = type;
      if (!os_log_type_enabled((os_log_t)v13, type)) {
        goto LABEL_23;
      }
      uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 64LL);
      *(_DWORD *)int buf = 136446978;
      __int16 v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
      __int16 v38 = 2082;
      os_log_type_t v39 = "registrar->instance_count";
      __int16 v40 = 2048;
      uint64_t v41 = 1LL;
      __int16 v42 = 2048;
      uint64_t v43 = v28;
      uint64_t v16 = (os_log_s *)v13;
      os_log_type_t v17 = v27;
      BOOL v18 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0x2Au);
    goto LABEL_23;
  }

uint64_t nw_protocol_instance_registrar_get_instance_count(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)int buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v20 = 0LL;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_protocol_instance_registrar_get_instance_count_block_invoke;
    aBlock[3] = &unk_189BC9210;
    uint64_t v16 = buf;
    uint64_t v15 = v1;
    uint64_t v3 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 2);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 2);

    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null registrar", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null registrar, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null registrar, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null registrar, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D695C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_instance_registrar_get_instance_count_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(void *)(*(void *)(result + 32) + 64LL);
  return result;
}

uint64_t nw_protocol_instance_registrar_find_quic_instance_by_id(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v4)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v3;
        *(_WORD *)&buf[22] = 2112;
        id v32 = v4;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ finding instance of quic to join for CID %@",  buf,  0x20u);
      }
    }

    if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
    }
    id v5 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
    identifier = nw_protocol_definition_get_identifier(v5);
    *(void *)int buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    id v32 = 0LL;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke;
    aBlock[3] = &unk_189BBEC90;
    uint64_t v7 = v3;
    uint64_t v22 = v7;
    BOOL v25 = identifier;
    id v23 = v4;
    os_log_type_t v24 = buf;
    uint64_t v8 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 2);
    v8[2](v8);
    os_unfair_lock_unlock(v3 + 2);

    uint64_t v9 = *(void *)(*(void *)&buf[8] + 24LL);
    if (!v9)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          uint64_t v28 = "nw_protocol_instance_registrar_find_quic_instance_by_id";
          __int16 v29 = 2112;
          __int16 v30 = v7;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ could not find protocol",  (uint8_t *)type,  0x16u);
        }

        uint64_t v9 = *(void *)(*(void *)&buf[8] + 24LL);
      }

      else
      {
        uint64_t v9 = 0LL;
      }
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_9;
  }

  __nwlog_obj();
  os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v12, type, &v26))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null connection_id", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type[0];
      BOOL v18 = os_log_type_enabled(v13, type[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v17,  "%{public}s called with null connection_id, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id";
        _os_log_impl(&dword_181A5C000, v13, v17, "%{public}s called with null connection_id, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id";
        _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null connection_id, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D69A98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Block_object_dispose((const void *)(v23 - 128), 8);
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke(uint64_t a1)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 16LL);
  if (v1)
  {
    uint64_t v3 = MEMORY[0x1895F87A8];
    while (1)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v22 = *(void *)(a1 + 32);
          uint64_t v23 = v1[2];
          uint64_t v24 = *(void *)(v23 + 16);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v22;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v42 = v23;
          __int16 v43 = 2080;
          uint64_t v44 = v24;
          _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ checking instance %p (%s) for joining by quic",  buf,  0x2Au);
        }
      }

      uint64_t v4 = v1[2];
      if (v4) {
        break;
      }
      if (gLogDatapath)
      {
        __nwlog_obj();
        id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v27 = *(void *)(a1 + 32);
          uint64_t v28 = v1[2];
          uint64_t v29 = *(void *)(a1 + 56);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v27;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v42 = v28;
          __int16 v43 = 2080;
          uint64_t v44 = v29;
          os_log_type_t v14 = v10;
          uint64_t v15 = "%{public}s %@ instance %p of %s not eligible, missing protocol handle";
LABEL_35:
          uint32_t v16 = 42;
LABEL_36:
          _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, v15, buf, v16);
        }

BOOL __nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke_8( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3;
  BOOL is_equal = nw_dispatch_data_is_equal(*(dispatch_data_t *)(a1 + 32), v4);
  if (is_equal)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *(void *)(a1 + 32);
        int v9 = 136446722;
        id v10 = "nw_protocol_instance_registrar_find_quic_instance_by_id_block_invoke";
        __int16 v11 = 2112;
        uint64_t v12 = v8;
        __int16 v13 = 2112;
        os_log_type_t v14 = v4;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s Comparing CID %@ with %@",  (uint8_t *)&v9,  0x20u);
      }
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  return !is_equal;
}

uint64_t __nw_protocol_instance_registrar_enumerate_instances_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void **)(*(void *)(result + 32) + 16LL);
  if (v1)
  {
    uint64_t v2 = result;
    do
    {
      uint64_t v3 = v1[2];
      if (v3)
      {
        BOOL result = nw_protocols_are_equal(*(void **)(v2 + 48), *(void **)(v3 + 16));
        if ((_DWORD)result) {
          BOOL result = (*(uint64_t (**)(void))(*(void *)(v2 + 40) + 16LL))();
        }
      }

      uint64_t v1 = (void *)*v1;
    }

    while (v1);
  }

  return result;
}

uint64_t nw_protocol_instance_registrar_find_instance_to_join( void *a1, void *a2, uint64_t a3, int a4, char a5, char a6, void *a7, void *a8, void *a9, uint64_t a10)
{
  uint64_t v89 = *MEMORY[0x1895F89C0];
  uint32_t v16 = a1;
  id v17 = a7;
  id v18 = a8;
  id v19 = a9;
  uint64_t v20 = v19;
  os_log_type_t v56 = v17;
  os_log_type_t v57 = v18;
  if (!a2)
  {
    id v32 = v19;
    __nwlog_obj();
    id v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
    char v34 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __n128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s called with null identifier", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (!v74)
    {
      __nwlog_obj();
      __n128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v51 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        _os_log_impl( &dword_181A5C000,  v35,  v51,  "%{public}s called with null identifier, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_73;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __n128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v44 = type[0];
    BOOL v45 = os_log_type_enabled(v35, type[0]);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        _os_log_impl(&dword_181A5C000, v35, v44, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v45)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
      __int16 v77 = 2082;
      os_log_type_t v78 = (os_unfair_lock_s *)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v35,  v44,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_48;
  }

  if (!v18)
  {
    id v32 = v19;
    __nwlog_obj();
    __int16 v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
    char v34 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __n128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        _os_log_impl(&dword_181A5C000, v35, v38, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (!v74)
    {
      __nwlog_obj();
      __n128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        _os_log_impl( &dword_181A5C000,  v35,  v52,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_73;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __n128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v46 = type[0];
    BOOL v47 = os_log_type_enabled(v35, type[0]);
    if (!backtrace_string)
    {
      if (v47)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        _os_log_impl(&dword_181A5C000, v35, v46, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_73;
    }

    if (v47)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
      __int16 v77 = 2082;
      os_log_type_t v78 = (os_unfair_lock_s *)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v35,  v46,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_48;
  }

  if (!v19)
  {
    id v32 = 0LL;
    __nwlog_obj();
    __int16 v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
    char v34 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __n128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        _os_log_impl(&dword_181A5C000, v35, v40, "%{public}s called with null parameters", buf, 0xCu);
      }

void sub_181D6AC70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, void *a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_registrar_find_instance_to_join_block_invoke(uint64_t a1)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (void *)(*(void *)(a1 + 32) + 16LL);
  do
  {
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      break;
    }
    if (gLogDatapath)
    {
      __nwlog_obj();
      id v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v42 = *(void *)(a1 + 32);
        uint64_t v43 = v2[2];
        uint64_t v44 = *(void *)(v43 + 16);
        BOOL v45 = *(os_log_s **)(a1 + 72);
        *(_DWORD *)int buf = 136447234;
        id v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
        __int16 v61 = 2112;
        uint64_t v62 = v42;
        __int16 v63 = 2048;
        uint64_t v64 = v43;
        __int16 v65 = 2080;
        uint64_t v66 = v44;
        __int16 v67 = 2080;
        char v68 = v45;
        _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ checking instance %p (%s) for joining by %s",  buf,  0x34u);
      }
    }

    uint64_t v4 = v2[2];
    if (v4)
    {
      if (nw_protocols_are_equal(*(void **)(a1 + 72), *(void **)(v4 + 16)))
      {
        uint64_t v5 = *(void *)(v4 + 24);
        if (v5)
        {
          id v6 = *(void (**)(uint64_t))(v5 + 136);
          if (v6)
          {
            if (*(void *)(v5 + 112))
            {
              v6(v4);
              uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              (*(void (**)(uint64_t))(*(void *)(v4 + 24) + 112LL))(v4);
              uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
              if (*(_BYTE *)(a1 + 96)) {
                uint64_t v9 = 1LL;
              }
              else {
                uint64_t v9 = 3LL;
              }
              if (*(_BYTE *)(a1 + 97))
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v10 = (os_log_s *)(id)gLogObj;
                if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v11 = *(void *)(a1 + 72);
                  uint64_t v12 = *(void *)(a1 + 32);
                  uint64_t v13 = *(void *)(a1 + 40);
                  *(_DWORD *)int buf = 136447490;
                  id v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                  __int16 v61 = 2112;
                  uint64_t v62 = v12;
                  __int16 v63 = 2048;
                  uint64_t v64 = v4;
                  __int16 v65 = 2080;
                  uint64_t v66 = v11;
                  __int16 v67 = 2112;
                  char v68 = v7;
                  __int16 v69 = 2112;
                  uint64_t v70 = v13;
                  _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s skipping endpoint comparison (candidate %@, endpoint %@)",  buf,  0x3Eu);
                }

void sub_181D6B61C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL70nw_protocol_instance_registrar_search_edges_for_instance_to_join_innerPK22nw_protocol_identifiermPU25objcproto14OS_nw_endpoint8NSObjectS4_S4_PU27objcproto16OS_nw_parametersS2_bb_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  uint64_t v5 = v4;
  if (v4)
  {
    int v6 = *((_BYTE *)v4 + 64) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v28 = "nw_endpoint_edge_is_wildcard";
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v14, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_endpoint_edge_is_wildcard";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null edge", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v28 = "nw_endpoint_edge_is_wildcard";
          __int16 v29 = 2082;
          uint64_t v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null edge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_33;
      }

      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_endpoint_edge_is_wildcard";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null edge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_endpoint_edge_is_wildcard";
        _os_log_impl( &dword_181A5C000,  v15,  v24,  "%{public}s called with null edge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D6BA4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_registrar_search_for_instance_to_join( uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, int a7)
{
  uint64_t v92 = *MEMORY[0x1895F89C0];
  id v75 = a3;
  id v74 = a4;
  id v76 = a5;
  id v77 = a6;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
    uint64_t v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v78 = 0;
    if (__nwlog_fault(v44, type, &v78))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v47 = "%{public}s called with null identifier";
LABEL_64:
          _os_log_impl(&dword_181A5C000, v45, v46, v47, buf, 0xCu);
        }
      }

      else if (v78)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type[0];
        BOOL v50 = os_log_type_enabled(v45, type[0]);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v50)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v47 = "%{public}s called with null identifier, no backtrace";
          goto LABEL_64;
        }
      }

      else
      {
        BOOL v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v47 = "%{public}s called with null identifier, backtrace limit exceeded";
          goto LABEL_64;
        }
      }
    }

    if (v44) {
      free(v44);
    }
LABEL_25:
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = a1;
        *(_WORD *)&buf[22] = 2048;
        id v84 = (void *)a1;
        _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s protocol %s (%p) does not have accept function, cannot search for protocol to join",  buf,  0x20u);
      }
    }

    goto LABEL_26;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  uint64_t v13 = &g_registration_list;
  do
  {
    uint64_t v13 = (uint64_t *)*v13;
    if (!v13)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      goto LABEL_25;
    }
  }

  while (*(void *)a1 != v13[4]
       || *(void *)(a1 + 8) != v13[5]
       || *(void *)(a1 + 16) != v13[6]
       || *(void *)(a1 + 24) != v13[7]
       || *(void *)(a1 + 32) != v13[8]);
  uint64_t v18 = v13[13];
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  if (!v18) {
    goto LABEL_25;
  }
  BOOL v19 = v74;
  if (!v19)
  {
    __nwlog_obj();
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v78 = 0;
    if (__nwlog_fault(v52, type, &v78))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v54 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_181A5C000, v53, v54, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v78)
      {
        uint64_t v56 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v57 = type[0];
        BOOL v58 = os_log_type_enabled(v53, type[0]);
        if (v56)
        {
          if (v58)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v56;
            _os_log_impl( &dword_181A5C000,  v53,  v57,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v56);
          goto LABEL_79;
        }

        if (v58)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_181A5C000, v53, v57, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v61 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_registered";
          _os_log_impl( &dword_181A5C000,  v53,  v61,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D6C634( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, void *a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, id a31, id a32, id a33)
{
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_registrar_copy_shared_connection_state_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  for (uint64_t i = *(void **)(*(void *)(a1 + 32) + 16LL); i; uint64_t i = (void *)*i)
  {
    if (i[2] == *(void *)(a1 + 64))
    {
      if (i[3]
        || *(_BYTE *)(a1 + 72) && (int v6 = nw_dictionary_create(), v7 = (void *)i[3], i[3] = v6, v7, i[3]))
      {
        *(_OWORD *)__str = 0u;
        memset(v9, 0, sizeof(v9));
        snprintf(__str, 0x2AuLL, "%p%p", *(const void **)(a1 + 40), *(const void **)(a1 + 48));
        int v3 = nw_dictionary_copy_value(i[3], (uint64_t)__str);
        uint64_t v4 = *(void *)(*(void *)(a1 + 56) + 8LL);
        uint64_t v5 = *(void **)(v4 + 40);
        *(void *)(v4 + 40) = v3;
      }
    }
  }

BOOL nw_framer_parse_input( nw_framer_t framer, size_t minimum_incomplete_length, size_t maximum_length, uint8_t *temp_buffer, nw_framer_parse_completion_t parse)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  nw_framer_t v9 = framer;
  nw_framer_parse_completion_t v10 = parse;
  if (v9)
  {
    nw_context_assert_queue(*((void **)v9 + 46));
    if (*((void *)v9 + 63))
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446466;
          id v25 = "nw_framer_parse_input";
          __int16 v26 = 2080;
          id v27 = (char *)v9 + 609;
          _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Cannot start a new parse with an outstanding parse",  buf,  0x16u);
        }
      }

      (*((void (**)(nw_framer_parse_completion_t, void, void, void))v10 + 2))(v10, 0LL, 0LL, 0LL);
      char v11 = 0;
    }

    else
    {
      char v11 = nw_framer_parse_array( v9,  (void *)v9 + 64,  1,  (*((_BYTE *)v9 + 606) & 2) != 0,  minimum_incomplete_length,  maximum_length,  (uint64_t)temp_buffer,  v10);
    }

    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  id v25 = "nw_framer_parse_input";
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v14, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_framer_parse_input";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          id v25 = "nw_framer_parse_input";
          __int16 v26 = 2082;
          id v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v19,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_framer_parse_input";
        _os_log_impl(&dword_181A5C000, v15, v19, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v25 = "nw_framer_parse_input";
        _os_log_impl( &dword_181A5C000,  v15,  v21,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D6CF18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_parse_array( void *a1, void *a2, char a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  uint64_t v15 = a1;
  id v16 = a8;
  id v17 = (void (**)(void, void, void, void))v16;
  unsigned int v18 = 0;
  uint64_t v19 = *a2;
  while (v19)
  {
    int v23 = *(_DWORD *)(v19 + 52);
    if (v23) {
      v23 -= *(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60);
    }
    uint64_t v19 = *(void *)(v19 + 32);
    BOOL v20 = __CFADD__(v18, v23);
    unsigned int v21 = v18 + v23;
    v18 += v23;
    if (v20) {
      unsigned int v22 = -1;
    }
    else {
      unsigned int v22 = v21;
    }
  }

  if (v18 >= a5)
  {
LABEL_12:
    *(void *)int buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    LOBYTE(v80) = 0;
    uint64_t v73 = 0LL;
    id v74 = &v73;
    uint64_t v75 = 0x2020000000LL;
    uint64_t v76 = 0LL;
    uint64_t v69 = 0LL;
    id v70 = &v69;
    uint64_t v71 = 0x2020000000LL;
    uint64_t v72 = a7;
    uint64_t v65 = 0LL;
    uint64_t v66 = &v65;
    uint64_t v67 = 0x2020000000LL;
    uint64_t v68 = 0LL;
    v63[0] = 0LL;
    v63[1] = v63;
    v63[2] = 0x2020000000LL;
    char v64 = 0;
    v47[0] = MEMORY[0x1895F87A8];
    v47[1] = 3221225472LL;
    uint64_t v48 = ___ZL21nw_framer_parse_arrayP20NWConcrete_nw_framerP16nw_frame_array_sbbmmPhU13block_pointerFmS3_mbE_block_invoke;
    uint64_t v49 = &unk_189BB67E8;
    char v61 = a3;
    uint64_t v58 = a6;
    uint64_t v59 = a5;
    uint64_t v52 = &v65;
    uint64_t v53 = &v69;
    os_log_type_t v57 = a2;
    os_log_type_t v54 = &v73;
    char v62 = a4;
    id v25 = v16;
    id v51 = v25;
    __int16 v26 = v15;
    BOOL v50 = v26;
    os_log_type_t v55 = buf;
    uint64_t v56 = v63;
    uint64_t v60 = a7;
    uint64_t v27 = *a2;
    do
    {
      if (!v27) {
        break;
      }
      uint64_t v28 = *(void *)(v27 + 32);
      char v29 = ((uint64_t (*)(void *))v48)(v47);
      uint64_t v27 = v28;
    }

    while ((v29 & 1) != 0);
    if (!*(_BYTE *)(*(void *)&buf[8] + 24LL) && v66[3])
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v39 = v66[3];
          *(_DWORD *)id v77 = 136446722;
          *(void *)&v77[4] = "nw_framer_parse_array";
          *(_WORD *)&v77[12] = 2080;
          *(void *)&v77[14] = v26 + 609;
          *(_WORD *)&v77[22] = 2048;
          uint64_t v78 = v39;
          _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Reconstructed buffer of %zu bytes",  v77,  0x20u);
        }
      }

      unint64_t v32 = (*((uint64_t (**)(id, uint64_t))v25 + 2))(v25, v70[3]);
      if (v32)
      {
        unint64_t v33 = v66[3];
        if (v32 < v33) {
          LODWORD(v33) = v32;
        }
        *(void *)id v77 = 0LL;
        *(void *)&v77[8] = v77;
        *(void *)&v77[16] = 0x2020000000LL;
        LODWORD(v78) = v33;
        v40[0] = MEMORY[0x1895F87A8];
        v40[1] = 3221225472LL;
        id v41 = ___ZL21nw_framer_parse_arrayP20NWConcrete_nw_framerP16nw_frame_array_sbbmmPhU13block_pointerFmS3_mbE_block_invoke_132;
        uint64_t v42 = &unk_189BB6810;
        uint64_t v44 = v77;
        char v46 = a3;
        uint64_t v43 = v26;
        BOOL v45 = a2;
        uint64_t v34 = *a2;
        do
        {
          if (!v34) {
            break;
          }
          uint64_t v35 = *(void *)(v34 + 32);
          char v36 = ((uint64_t (*)(void *))v41)(v40);
          uint64_t v34 = v35;
        }

        while ((v36 & 1) != 0);

        _Block_object_dispose(v77, 8);
      }
    }

    id v30 = (void *)v74[3];
    if (v30)
    {
      free(v30);
      v74[3] = 0LL;
    }

    _Block_object_dispose(v63, 8);
    _Block_object_dispose(&v65, 8);
    _Block_object_dispose(&v69, 8);
    _Block_object_dispose(&v73, 8);
    _Block_object_dispose(buf, 8);
    uint64_t v24 = 1LL;
    goto LABEL_19;
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_framer_parse_array";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v15 + 609;
      *(_WORD *)&buf[22] = 2048;
      uint64_t v80 = a5;
      _os_log_impl(&dword_181A5C000, v37, OS_LOG_TYPE_DEBUG, "%{public}s %s Not enough bytes to parse %zu", buf, 0x20u);
    }
  }

  v17[2](v17, 0LL, 0LL, 0LL);
  uint64_t v24 = 0LL;
LABEL_19:

  return v24;
}

void sub_181D6D374( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41)
{
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose((const void *)(v43 - 224), 8);
  _Block_object_dispose((const void *)(v43 - 160), 8);

  _Unwind_Resume(a1);
}

BOOL ___ZL21nw_framer_parse_arrayP20NWConcrete_nw_framerP16nw_frame_array_sbbmmPhU13block_pointerFmS3_mbE_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v84 = *MEMORY[0x1895F89C0];
  int v3 = a2;
  if (!nw_frame_uses_external_data((uint64_t)v3))
  {
    HIDWORD(__n) = 0;
    uint64_t v12 = (const void *)nw_frame_unclaimed_bytes((uint64_t)v3, (_DWORD *)&__n + 1);
    size_t v13 = HIDWORD(__n);
    if (HIDWORD(__n))
    {
      uint64_t v14 = v12;
      uint64_t v15 = *(void *)(a1 + 48);
      uint64_t v16 = *(void *)(*(void *)(v15 + 8) + 24LL);
      else {
        size_t v17 = *(void *)(a1 + 96) - v16;
      }
      if (!v16 && v17 >= *(void *)(a1 + 104))
      {
        if (*(void *)(a1 + 112)) {
          memcpy(*(void **)(a1 + 112), v12, v17);
        }
        unint64_t v35 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
        if (v35)
        {
          if (v35 >= v17) {
            int v37 = v17;
          }
          else {
            int v37 = v35;
          }
          nw_frame_claim((uint64_t)v3, v36, v37, 0);
        }

        if (*(_BYTE *)(a1 + 120) && !nw_frame_unclaimed_length(v3))
        {
          uint64_t v38 = *((void *)v3 + 4);
          uint64_t v39 = (void *)*((void *)v3 + 5);
          if (v38)
          {
            *(void *)(v38 + 40) = v39;
            uint64_t v39 = (void *)*((void *)v3 + 5);
          }

          else
          {
            *(void *)(*(void *)(a1 + 88) + 8LL) = v39;
          }

          *uint64_t v39 = v38;
          *((void *)v3 + 4) = 0LL;
          *((void *)v3 + 5) = 0LL;
          nw_frame_finalize((uint64_t)v3);
        }

        uint64_t v23 = 0LL;
        *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 1;
        goto LABEL_88;
      }

      if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL))
      {
        size_t v18 = *(void *)(a1 + 104);
        if (!v18)
        {
          __nwlog_obj();
          uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int buf = 136446210;
          uint64_t v75 = "strict_malloc";
          uint64_t v66 = (void *)_os_log_send_and_compose_impl();

          BOOL result = __nwlog_abort((uint64_t)v66);
          if (result) {
            goto LABEL_128;
          }
          free(v66);
        }

        uint64_t v19 = malloc(v18);
        if (!v19)
        {
          __nwlog_obj();
          uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int buf = 136446466;
          uint64_t v75 = "strict_malloc";
          __int16 v76 = 2048;
          size_t v77 = v18;
          uint64_t v68 = (void *)_os_log_send_and_compose_impl();

          BOOL result = __nwlog_abort((uint64_t)v68);
          if (result) {
            goto LABEL_128;
          }
          free(v68);
          uint64_t v19 = 0LL;
        }

        *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v19;
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL)
                                                                                + 24LL);
        uint64_t v15 = *(void *)(a1 + 48);
        uint64_t v16 = *(void *)(*(void *)(v15 + 8) + 24LL);
        size_t v13 = HIDWORD(__n);
      }

      size_t v20 = *(void *)(a1 + 104) - v16;
      if (v20 <= v13)
      {
        if (*(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL)) {
          size_t v17 = v20;
        }
        if (v17 == v13)
        {
          if (*(_BYTE *)(a1 + 121)) {
            BOOL v27 = 1;
          }
          else {
            BOOL v27 = *((char *)v3 + 186) < 0;
          }
          *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = v27;
        }

        if (gLogDatapath)
        {
          __nwlog_obj();
          uint64_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v57 = *(void *)(a1 + 32);
            if (v57) {
              uint64_t v58 = (const char *)(v57 + 609);
            }
            else {
              uint64_t v58 = "";
            }
            uint64_t v59 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
            uint64_t v60 = *(void *)(a1 + 104);
            *(_DWORD *)int buf = 136447234;
            uint64_t v75 = "nw_framer_parse_array_block_invoke";
            __int16 v76 = 2080;
            size_t v77 = (size_t)v58;
            __int16 v78 = 2048;
            uint64_t v79 = v59;
            __int16 v80 = 2048;
            size_t v81 = v59 + v17;
            __int16 v82 = 2048;
            uint64_t v83 = v60;
            _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Reading from %zu-%zu of %zu (complete)",  buf,  0x34u);
          }
        }

        memcpy( (void *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL)
                 + *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)),
          v14,
          v17);
        uint64_t v23 = 0LL;
        *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) += v17;
        goto LABEL_88;
      }

      if (gLogDatapath)
      {
        __nwlog_obj();
        char v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v47 = *(void *)(a1 + 32);
          if (v47) {
            uint64_t v48 = (const char *)(v47 + 609);
          }
          else {
            uint64_t v48 = "";
          }
          uint64_t v49 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
          uint64_t v50 = *(void *)(a1 + 104);
          *(_DWORD *)int buf = 136447234;
          uint64_t v75 = "nw_framer_parse_array_block_invoke";
          __int16 v76 = 2080;
          size_t v77 = (size_t)v48;
          __int16 v78 = 2048;
          uint64_t v79 = v49;
          __int16 v80 = 2048;
          size_t v81 = v49 + HIDWORD(__n);
          __int16 v82 = 2048;
          uint64_t v83 = v50;
          _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Reading from %zu-%zu of %zu (partial)",  buf,  0x34u);
        }

        uint64_t v15 = *(void *)(a1 + 48);
        LODWORD(v13) = HIDWORD(__n);
      }

      memcpy( (void *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) + *(void *)(*(void *)(v15 + 8) + 24LL)),  v14,  v13);
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) += HIDWORD(__n);
    }

    else if (*(_BYTE *)(a1 + 120))
    {
      uint64_t v24 = *((void *)v3 + 4);
      id v25 = (void *)*((void *)v3 + 5);
      if (v24)
      {
        *(void *)(v24 + 40) = v25;
        id v25 = (void *)*((void *)v3 + 5);
      }

      else
      {
        *(void *)(*(void *)(a1 + 88) + 8LL) = v25;
      }

      void *v25 = v24;
      *((void *)v3 + 4) = 0LL;
      *((void *)v3 + 5) = 0LL;
      uint64_t v23 = 1LL;
      nw_frame_finalize((uint64_t)v3);
      goto LABEL_88;
    }

    uint64_t v23 = 1LL;
LABEL_88:

    return v23;
  }

  size_t __n = 0LL;
  uint64_t v4 = (dispatch_data_s *)nw_frame_copy_external_data((uint64_t)v3, &__n, (_DWORD *)&__n + 1);
  size_t v5 = HIDWORD(__n);
  if (!HIDWORD(__n))
  {
    if (*(_BYTE *)(a1 + 120))
    {
      uint64_t v21 = *((void *)v3 + 4);
      unsigned int v22 = (void *)*((void *)v3 + 5);
      if (v21)
      {
        *(void *)(v21 + 40) = v22;
        unsigned int v22 = (void *)*((void *)v3 + 5);
      }

      else
      {
        *(void *)(*(void *)(a1 + 88) + 8LL) = v22;
      }

      *unsigned int v22 = v21;
      *((void *)v3 + 4) = 0LL;
      *((void *)v3 + 5) = 0LL;
      uint64_t v23 = 1LL;
      nw_frame_finalize((uint64_t)v3);
      goto LABEL_87;
    }

void sub_181D6E05C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL21nw_framer_parse_arrayP20NWConcrete_nw_framerP16nw_frame_array_sbbmmPhU13block_pointerFmS3_mbE_block_invoke_132( uint64_t a1, void *a2)
{
  int v3 = a2;
  unsigned int v4 = nw_frame_unclaimed_length(v3);
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) >= v4) {
    int v6 = v4;
  }
  else {
    int v6 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  }
  nw_frame_claim((uint64_t)v3, v5, v6, 0);
  if (*(_BYTE *)(a1 + 56) && !nw_frame_unclaimed_length(v3))
  {
    uint64_t v7 = *((void *)v3 + 4);
    size_t v8 = (void *)*((void *)v3 + 5);
    if (v7)
    {
      *(void *)(v7 + 40) = v8;
      size_t v8 = (void *)*((void *)v3 + 5);
    }

    else
    {
      *(void *)(*(void *)(a1 + 48) + 8LL) = v8;
    }

    *size_t v8 = v7;
    *((void *)v3 + 4) = 0LL;
    *((void *)v3 + 5) = 0LL;
    nw_frame_finalize((uint64_t)v3);
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) -= v6;
  BOOL v9 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) != 0;

  return v9;
}

void nw_framer_deliver_input( nw_framer_t framer, const uint8_t *input_buffer, size_t input_length, nw_framer_message_t message, BOOL is_complete)
{
  BOOL v5 = is_complete;
  uint64_t v53 = *MEMORY[0x1895F89C0];
  nw_framer_t v9 = framer;
  nw_framer_parse_completion_t v10 = message;
  size_t v11 = v10;
  if (!v9)
  {
    __nwlog_obj();
    size_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v50 = "nw_framer_deliver_input";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v50 = "nw_framer_deliver_input";
          __int16 v51 = 2082;
          uint64_t v52 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v31,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_89:
        if (!v19) {
          goto LABEL_7;
        }
LABEL_90:
        free(v19);
        goto LABEL_7;
      }

      if (v32)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v31, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v50 = "nw_framer_deliver_input";
        _os_log_impl( &dword_181A5C000,  v20,  v42,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D6EC88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t metadata)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v1 = metadata;
  uint64_t v2 = v1;
  if (v1)
  {
    int v3 = v1;
    id v4 = v3[1];

    char is_framer = nw_protocol_definition_is_framer(v4);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  size_t v18 = "nw_protocol_metadata_is_framer_message";
  size_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_framer_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v18 = "nw_protocol_metadata_is_framer_message";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_framer_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          size_t v18 = "nw_protocol_metadata_is_framer_message";
          __int16 v19 = 2082;
          size_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        size_t v18 = "nw_protocol_metadata_is_framer_message";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_framer_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v18 = "nw_protocol_metadata_is_framer_message";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_framer_protocol_inbound_data_finalizer(void *a1, int a2, char *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  if (a2)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = "";
        if (a3) {
          uint64_t v7 = a3 + 609;
        }
        int v10 = 136446466;
        size_t v11 = "nw_framer_protocol_inbound_data_finalizer";
        __int16 v12 = 2080;
        BOOL v13 = v7;
        size_t v8 = "%{public}s %s Finalizing inbound frame (success)";
LABEL_13:
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, v8, (uint8_t *)&v10, 0x16u);
        goto LABEL_14;
      }

      goto LABEL_14;
    }
  }

  else if (gLogDatapath)
  {
    __nwlog_obj();
    int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      nw_framer_t v9 = "";
      if (a3) {
        nw_framer_t v9 = a3 + 609;
      }
      int v10 = 136446466;
      size_t v11 = "nw_framer_protocol_inbound_data_finalizer";
      __int16 v12 = 2080;
      BOOL v13 = v9;
      size_t v8 = "%{public}s %s Finalizing inbound frame (drop)";
      goto LABEL_13;
    }

BOOL nw_framer_protocol_create_frame(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v9 = a1;
  int v10 = v9;
  if (!v9)
  {
    __nwlog_obj();
    size_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v38 = "nw_framer_protocol_create_frame";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v21, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unsigned int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v38 = "nw_framer_protocol_create_frame";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null framer", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (!v35)
      {
        __nwlog_obj();
        unsigned int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v38 = "nw_framer_protocol_create_frame";
          _os_log_impl( &dword_181A5C000,  v22,  v33,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_52;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v38 = "nw_framer_protocol_create_frame";
          _os_log_impl(&dword_181A5C000, v22, v27, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (v28)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v38 = "nw_framer_protocol_create_frame";
        __int16 v39 = 2082;
        os_log_type_t v40 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

void nw_framer_signal_input_available(NWConcrete_nw_framer *a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  char v3 = *((_BYTE *)v1 + 607);
  if ((v3 & 1) == 0 && (*((char *)v1 + 606) & 0x80000000) == 0)
  {
    uint64_t default_input_handler = v1->protocol.default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        if (callbacks->input_available)
        {
          *((_BYTE *)v2 + 607) = v3 | 1;
          if (v2->pending_input_frames.tqh_first) {
            *((_BYTE *)v2 + 608) |= 0x20u;
          }
          int v6 = default_input_handler->callbacks;
          if (v6)
          {
            input_available = (void (*)(void))v6->input_available;
            if (input_available)
            {
              input_available();
LABEL_11:
              *((_BYTE *)v2 + 607) &= ~1u;
              goto LABEL_12;
            }
          }

          __nwlog_obj();
          size_t v8 = (void *)objc_claimAutoreleasedReturnValue();
          id v9 = v2->protocol.default_input_handler;
          int v10 = "invalid";
          if (v9)
          {
            name = v9->identifier->name;
            if (name) {
              int v10 = name;
            }
          }

          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_framer_signal_input_available";
          __int16 v35 = 2082;
          os_log_type_t v36 = v10;
          __int16 v12 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v31 = 0;
          if (__nwlog_fault(v12, &type, &v31))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v14 = type;
              if (os_log_type_enabled(v13, type))
              {
                BOOL v15 = v2->protocol.default_input_handler;
                uint64_t v16 = "invalid";
                if (v15)
                {
                  uint64_t v17 = v15->identifier->name;
                  if (v17) {
                    uint64_t v16 = v17;
                  }
                }

                *(_DWORD *)int buf = 136446466;
                os_log_type_t v34 = "nw_framer_signal_input_available";
                __int16 v35 = 2082;
                os_log_type_t v36 = v16;
                _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s protocol %{public}s has invalid input_available callback",  buf,  0x16u);
              }
            }

            else if (v31)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v19 = type;
              BOOL v20 = os_log_type_enabled(v13, type);
              if (backtrace_string)
              {
                if (v20)
                {
                  uint64_t v21 = v2->protocol.default_input_handler;
                  unsigned int v22 = "invalid";
                  if (v21)
                  {
                    os_log_type_t v23 = v21->identifier->name;
                    if (v23) {
                      unsigned int v22 = v23;
                    }
                  }

                  *(_DWORD *)int buf = 136446722;
                  os_log_type_t v34 = "nw_framer_signal_input_available";
                  __int16 v35 = 2082;
                  os_log_type_t v36 = v22;
                  __int16 v37 = 2082;
                  os_log_type_t v38 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(backtrace_string);
                goto LABEL_44;
              }

              if (v20)
              {
                BOOL v28 = v2->protocol.default_input_handler;
                os_log_type_t v29 = "invalid";
                if (v28)
                {
                  BOOL v30 = v28->identifier->name;
                  if (v30) {
                    os_log_type_t v29 = v30;
                  }
                }

                *(_DWORD *)int buf = 136446466;
                os_log_type_t v34 = "nw_framer_signal_input_available";
                __int16 v35 = 2082;
                os_log_type_t v36 = v29;
                _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s protocol %{public}s has invalid input_available callback, no backtrace",  buf,  0x16u);
              }
            }

            else
            {
              __nwlog_obj();
              BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v24 = type;
              if (os_log_type_enabled(v13, type))
              {
                os_log_type_t v25 = v2->protocol.default_input_handler;
                BOOL v26 = "invalid";
                if (v25)
                {
                  os_log_type_t v27 = v25->identifier->name;
                  if (v27) {
                    BOOL v26 = v27;
                  }
                }

                *(_DWORD *)int buf = 136446466;
                os_log_type_t v34 = "nw_framer_signal_input_available";
                __int16 v35 = 2082;
                os_log_type_t v36 = v26;
                _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded",  buf,  0x16u);
              }
            }
          }

void sub_181D6FA8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_finalizer(void *a1, uint64_t a2)
{
  size_t v8 = a1;
  if (nw_frame_buffer_used_malloc((uint64_t)v8))
  {
    buffer = (void *)nw_frame_get_buffer((uint64_t)v8, 0LL);
    if (buffer) {
      free(buffer);
    }
  }

  else if (nw_frame_buffer_used_manager((uint64_t)v8))
  {
    uint64_t manager = nw_frame_buffer_get_manager((uint64_t)v8);
    unint64_t v5 = nw_frame_get_buffer((uint64_t)v8, 0LL);
    nw_mem_buffer_free(manager, v5);
  }

  else if (nw_frame_uses_external_data((uint64_t)v8))
  {
    nw_frame_set_external_data((uint64_t)v8, 0LL, 0LL);
  }

  nw_frame_reset((uint64_t)v8, 0LL, 0, 0LL, 0LL);
  uint64_t v6 = v8[2];
  uint64_t v7 = (void *)v8[3];
  if (v6)
  {
    *(void *)(v6 + 24) = v7;
    uint64_t v7 = (void *)v8[3];
  }

  else
  {
    *(void *)(a2 + 8) = v7;
  }

  *uint64_t v7 = v6;
  v8[2] = 0LL;
  v8[3] = 0LL;
}

BOOL nw_framer_deliver_input_no_copy( nw_framer_t framer, size_t input_length, nw_framer_message_t message, BOOL is_complete)
{
  BOOL v4 = is_complete;
  uint64_t v51 = *MEMORY[0x1895F89C0];
  nw_framer_t v7 = framer;
  size_t v8 = message;
  id v9 = v8;
  if (!v7)
  {
    __nwlog_obj();
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
    unsigned int v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null framer", buf, 0xCu);
      }

      goto LABEL_68;
    }

    if (!v47)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        _os_log_impl( &dword_181A5C000,  v23,  v37,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_68;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v31 = type;
    BOOL v32 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        _os_log_impl(&dword_181A5C000, v23, v31, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }

      goto LABEL_68;
    }

    if (v32)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v31,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_50;
  }

  if (!v8)
  {
    __nwlog_obj();
    os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
    unsigned int v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        _os_log_impl(&dword_181A5C000, v23, v26, "%{public}s called with null message", buf, 0xCu);
      }

      goto LABEL_68;
    }

    if (!v47)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        _os_log_impl( &dword_181A5C000,  v23,  v38,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_68;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v33 = type;
    BOOL v34 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        _os_log_impl(&dword_181A5C000, v23, v33, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }

      goto LABEL_68;
    }

    if (v34)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v33,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_50;
  }

  int v10 = v8;
  id v11 = v10[1];

  char is_framer = nw_protocol_definition_is_framer(v11);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    os_log_type_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
    unsigned int v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message)",  buf,  0xCu);
      }

void sub_181D70404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_framer_deliver_input_no_copy_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  char v3 = a2;
  BOOL v4 = v3;
  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)) {
    goto LABEL_10;
  }
  unsigned int v50 = 0;
  uint64_t v5 = nw_frame_unclaimed_bytes((uint64_t)v3, &v50);
  unint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  if (v6 == v50)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      BOOL v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v33 = *(void *)(a1 + 32);
        if (v33) {
          BOOL v34 = (const char *)(v33 + 609);
        }
        else {
          BOOL v34 = "";
        }
        uint64_t v35 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        *(_DWORD *)int buf = 136446978;
        uint64_t v52 = "nw_framer_deliver_input_no_copy_block_invoke";
        __int16 v53 = 2080;
        uint64_t v54 = v34;
        __int16 v55 = 1024;
        unsigned int v56 = v50;
        __int16 v57 = 2048;
        uint64_t v58 = v35;
        _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %s Parsing exact body (%u/%zu)", buf, 0x26u);
      }
    }

    nw_frame_set_metadata((uint64_t)v4, *(nw_protocol_metadata **)(a1 + 40), 1, *(unsigned __int8 *)(a1 + 56));
    uint64_t v8 = v4[4];
    id v9 = (void *)v4[5];
    nw_framer_t v7 = v4 + 4;
    if (v8)
    {
      *(void *)(v8 + 40) = v9;
      id v9 = (void *)v4[5];
    }

    else
    {
      *(void *)(*(void *)(a1 + 32) + 520LL) = v9;
    }

    *id v9 = v8;
    *nw_framer_t v7 = 0LL;
    void v4[5] = 0LL;
    uint64_t v23 = *(void *)(a1 + 32);
    uint64_t v22 = a1 + 32;
    os_log_type_t v24 = *(void **)(v23 + 536);
    void v4[5] = v24;
    void *v24 = v4;
    *(void *)(v23 + 536) = v7;
    ++*(_DWORD *)(*(void *)v22 + 544LL);
    os_log_type_t v25 = *(void **)(*(void *)v22 + 384LL);
    *(void *)(*(void *)v22 + 384LL) = 0LL;

    uint64_t v18 = 0LL;
    *(void *)(*(void *)v22 + 504LL) = 0LL;
    goto LABEL_25;
  }

  if (v6 >= v50)
  {
    if (v50)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        os_log_type_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v43 = *(void *)(a1 + 32);
          if (v43) {
            os_log_type_t v44 = (const char *)(v43 + 609);
          }
          else {
            os_log_type_t v44 = "";
          }
          uint64_t v45 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
          *(_DWORD *)int buf = 136446978;
          uint64_t v52 = "nw_framer_deliver_input_no_copy_block_invoke";
          __int16 v53 = 2080;
          uint64_t v54 = v44;
          __int16 v55 = 1024;
          unsigned int v56 = v50;
          __int16 v57 = 2048;
          uint64_t v58 = v45;
          _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Parsing partial body (%u/%zu)",  buf,  0x26u);
        }
      }

      nw_frame_set_metadata((uint64_t)v4, *(nw_protocol_metadata **)(a1 + 40), 1, 0);
      uint64_t v20 = v4[4];
      uint64_t v21 = (void *)v4[5];
      os_log_type_t v19 = v4 + 4;
      if (v20)
      {
        *(void *)(v20 + 40) = v21;
        uint64_t v21 = (void *)v4[5];
      }

      else
      {
        *(void *)(*(void *)(a1 + 32) + 520LL) = v21;
      }

      void *v21 = v20;
      void *v19 = 0LL;
      void v4[5] = 0LL;
      uint64_t v29 = *(void *)(a1 + 32);
      BOOL v30 = *(void **)(v29 + 536);
      void v4[5] = v30;
      *BOOL v30 = v4;
      *(void *)(v29 + 536) = v19;
      ++*(_DWORD *)(*(void *)(a1 + 32) + 544LL);
      *(void *)(*(void *)(a1 + 32) + 504LL) = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) - v50;
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = *(void *)(*(void *)(a1 + 32) + 504LL);
    }

    else
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        BOOL v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v47 = *(void *)(a1 + 32);
          if (v47) {
            uint64_t v48 = (const char *)(v47 + 609);
          }
          else {
            uint64_t v48 = "";
          }
          uint64_t v49 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
          *(_DWORD *)int buf = 136446978;
          uint64_t v52 = "nw_framer_deliver_input_no_copy_block_invoke";
          __int16 v53 = 2080;
          uint64_t v54 = v48;
          __int16 v55 = 1024;
          unsigned int v56 = v50;
          __int16 v57 = 2048;
          uint64_t v58 = v49;
          _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Not enough bytes to parse body (%u/%zu)",  buf,  0x26u);
        }

        unint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        BOOL v26 = v50 == 0;
      }

      else
      {
        BOOL v26 = 1;
      }

      *(void *)(*(void *)(a1 + 32) + 504LL) = v6;
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = *(void *)(*(void *)(a1 + 32) + 504LL);
      if (v26)
      {
        uint64_t v27 = v4[4];
        os_log_type_t v28 = (void *)v4[5];
        if (v27)
        {
          *(void *)(v27 + 40) = v28;
          os_log_type_t v28 = (void *)v4[5];
        }

        else
        {
          *(void *)(*(void *)(a1 + 32) + 520LL) = v28;
        }

        *os_log_type_t v28 = v27;
        v4[4] = 0LL;
        void v4[5] = 0LL;
        uint64_t v18 = 1LL;
        nw_frame_finalize((uint64_t)v4);
        goto LABEL_25;
      }
    }

    uint64_t v18 = 1LL;
LABEL_25:

    return v18;
  }

  int v10 = (const void *)v5;
  if (gLogDatapath)
  {
    __nwlog_obj();
    BOOL v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v37 = *(void *)(a1 + 32);
      if (v37) {
        os_log_type_t v38 = (const char *)(v37 + 609);
      }
      else {
        os_log_type_t v38 = "";
      }
      uint64_t v39 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
      *(_DWORD *)int buf = 136446978;
      uint64_t v52 = "nw_framer_deliver_input_no_copy_block_invoke";
      __int16 v53 = 2080;
      uint64_t v54 = v38;
      __int16 v55 = 1024;
      unsigned int v56 = v50;
      __int16 v57 = 2048;
      uint64_t v58 = v39;
      _os_log_impl(&dword_181A5C000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %s Parsing full body (%u/%zu)", buf, 0x26u);
    }

    unint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  }

  uint64_t frame = nw_framer_protocol_create_frame( *(void **)(a1 + 32),  v6,  (uint64_t)nw_framer_protocol_inbound_data_finalizer,  *(void *)(a1 + 32) + 464LL,  0);
  __int16 v12 = (void *)nw_frame_unclaimed_bytes(frame, 0LL);
  nw_frame_set_metadata(frame, *(nw_protocol_metadata **)(a1 + 40), 1, *(unsigned __int8 *)(a1 + 56));
  memcpy(v12, v10, *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
  nw_frame_claim((uint64_t)v4, v13, *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL), 0);
  if (nw_frame_unclaimed_length(v4))
  {
LABEL_9:
    uint64_t v15 = *(void *)(a1 + 32);
    uint64_t v14 = a1 + 32;
    *(void *)(frame + 32) = 0LL;
    uint64_t v16 = *(uint64_t **)(v15 + 536);
    *(void *)(frame + 40) = v16;
    *uint64_t v16 = frame;
    *(void *)(v15 + 536) = frame + 32;
    ++*(_DWORD *)(*(void *)v14 + 544LL);
    char v17 = *(void **)(*(void *)v14 + 384LL);
    *(void *)(*(void *)v14 + 384LL) = 0LL;

    *(void *)(*(void *)v14 + 504LL) = 0LL;
LABEL_10:
    uint64_t v18 = 0LL;
    goto LABEL_25;
  }

  __nwlog_obj();
  os_log_type_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446210;
  uint64_t v52 = "nw_framer_deliver_input_no_copy_block_invoke";
  uint64_t v41 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v41);
  if (!result)
  {
    free(v41);
    goto LABEL_9;
  }

  __break(1u);
  return result;
}

BOOL nw_framer_parse_output( nw_framer_t framer, size_t minimum_incomplete_length, size_t maximum_length, uint8_t *temp_buffer, nw_framer_parse_completion_t parse)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  nw_framer_t v9 = framer;
  nw_framer_parse_completion_t v10 = parse;
  if (!v9)
  {
    __nwlog_obj();
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v25 = "nw_framer_parse_output";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v15, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v25 = "nw_framer_parse_output";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null framer", buf, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v25 = "nw_framer_parse_output";
            __int16 v26 = 2082;
            uint64_t v27 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v16,  v19,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v20)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v25 = "nw_framer_parse_output";
          _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v25 = "nw_framer_parse_output";
          _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D70DEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_write_output_data(nw_framer_t framer, dispatch_data_t output_data)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  BOOL v4 = output_data;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v30 = "nw_framer_write_output_data";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v30 = "nw_framer_write_output_data";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v30 = "nw_framer_write_output_data";
          __int16 v31 = 2082;
          BOOL v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_48:
        if (!v14) {
          goto LABEL_14;
        }
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v30 = "nw_framer_write_output_data";
        _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v30 = "nw_framer_write_output_data";
        _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D7135C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_flush_output(void *a1, void *a2)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = a1;
  id v65 = a2;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int16 v87 = 136446210;
    *(void *)&v87[4] = "nw_framer_flush_output";
    BOOL v34 = (char *)_os_log_send_and_compose_impl();

    v77[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (__nwlog_fault(v34, v77, buf))
    {
      if (v77[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = v77[0];
        if (os_log_type_enabled(v35, v77[0]))
        {
          *(_DWORD *)__int16 v87 = 136446210;
          *(void *)&v87[4] = "nw_framer_flush_output";
          _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s called with null framer", v87, 0xCu);
        }

        goto LABEL_123;
      }

      if (!buf[0])
      {
        __nwlog_obj();
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v54 = v77[0];
        if (os_log_type_enabled(v35, v77[0]))
        {
          *(_DWORD *)__int16 v87 = 136446210;
          *(void *)&v87[4] = "nw_framer_flush_output";
          _os_log_impl( &dword_181A5C000,  v35,  v54,  "%{public}s called with null framer, backtrace limit exceeded",  v87,  0xCu);
        }

        goto LABEL_123;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = v77[0];
      BOOL v47 = os_log_type_enabled(v35, v77[0]);
      if (!backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)__int16 v87 = 136446210;
          *(void *)&v87[4] = "nw_framer_flush_output";
          _os_log_impl(&dword_181A5C000, v35, v46, "%{public}s called with null framer, no backtrace", v87, 0xCu);
        }

        goto LABEL_123;
      }

      if (v47)
      {
        *(_DWORD *)__int16 v87 = 136446466;
        *(void *)&v87[4] = "nw_framer_flush_output";
        *(_WORD *)&v87[12] = 2082;
        *(void *)&v87[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v35,  v46,  "%{public}s called with null framer, dumping backtrace:%{public}s",  v87,  0x16u);
      }

void sub_181D72108( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4444(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__4445(uint64_t a1)
{
}

uint64_t ___ZL22nw_framer_flush_outputP20NWConcrete_nw_framerPU22objcproto11OS_nw_frame8NSObject_block_invoke( void *a1, void *a2)
{
  v97[2] = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v4 = (uint64_t)v3;
  if (!*(void *)(*(void *)(a1[6] + 8LL) + 40LL))
  {
    nw_frame_finalize((uint64_t)v3);
    uint64_t v12 = *(void *)(v4 + 32);
    char v13 = *(void **)(v4 + 40);
    if (v12)
    {
      *(void *)(v12 + 40) = v13;
      char v13 = *(void **)(v4 + 40);
    }

    else
    {
      *(void *)(a1[8] + 8LL) = v13;
    }

    void *v13 = v12;
    *(void *)(v4 + 32) = 0LL;
    *(void *)(v4 + 40) = 0LL;
    if (gLogDatapath)
    {
      __nwlog_obj();
      char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v23 = a1[4];
        if (v23) {
          BOOL v24 = (const char *)(v23 + 609);
        }
        else {
          BOOL v24 = "";
        }
        *(_DWORD *)int buf = 136446466;
        __int16 v93 = "nw_framer_flush_output_block_invoke";
        __int16 v94 = 2080;
        __int16 v95 = (void *)v24;
        _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s %s No output data, dropping output frame",  buf,  0x16u);
      }
    }

    goto LABEL_55;
  }

  if (!nw_frame_uses_external_data((uint64_t)v3))
  {
    unsigned int offset = 0;
    uint64_t v14 = nw_frame_unclaimed_bytes(v4, &offset);
    if (v14)
    {
      uint64_t v15 = v14;
      uint64_t v16 = offset;
      unint64_t v17 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
      if (offset)
      {
        if (v17 > offset)
        {
          if (gLogDatapath)
          {
            uint64_t v84 = v14;
            __nwlog_obj();
            __int16 v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v86 = a1[4];
              if (v86) {
                __int16 v87 = (const char *)(v86 + 609);
              }
              else {
                __int16 v87 = "";
              }
              uint64_t v88 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
              *(_DWORD *)int buf = 136446978;
              __int16 v93 = "nw_framer_flush_output_block_invoke";
              __int16 v94 = 2080;
              __int16 v95 = (void *)v87;
              __int16 v96 = 1024;
              LODWORD(v97[0]) = offset;
              WORD2(v97[0]) = 2048;
              *(void *)((char *)v97 + 6) = v88;
              _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Set partial frame output_length %u < %zu bytes",  buf,  0x26u);
            }

            uint64_t v16 = offset;
            uint64_t v15 = v84;
          }

          nw_dispatch_data_copyout_from_offset(*(dispatch_data_s **)(*(void *)(a1[6] + 8LL) + 40LL), v15, v16, 0LL);
          dispatch_data_t subrange = dispatch_data_create_subrange( *(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL),  offset,  *(void *)(*(void *)(a1[7] + 8LL) + 24LL) - offset);
          uint64_t v19 = *(void *)(a1[6] + 8LL);
          os_log_type_t v20 = *(void **)(v19 + 40);
          *(void *)(v19 + 40) = subrange;

          size_t size = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL));
          goto LABEL_60;
        }

void nw_framer_write_output(nw_framer_t framer, const uint8_t *output_buffer, size_t output_length)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  unsigned int v5 = framer;
  unint64_t v6 = (nw_framer *)v5;
  if (v5)
  {
    nw_context_assert_queue(v5[46]);
    size_t v7 = dispatch_data_create(output_buffer, output_length, 0LL, 0LL);
    nw_framer_write_output_data(v6, v7);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v19 = "nw_framer_write_output";
  dispatch_data_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v19 = "nw_framer_write_output";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v19 = "nw_framer_write_output";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v19 = "nw_framer_write_output";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v19 = "nw_framer_write_output";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D73124(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_framer_write_output_no_copy(nw_framer_t framer, size_t output_length)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  id v3 = framer;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_write_output_no_copy";
    char v27 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v44[0] = 0;
    if (__nwlog_fault(v27, type, v44))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_write_output_no_copy";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null framer", buf, 0xCu);
        }
      }

      else if (v44[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type[0];
        BOOL v32 = os_log_type_enabled(v28, type[0]);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_framer_write_output_no_copy";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_46;
        }

        if (v32)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_write_output_no_copy";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_write_output_no_copy";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D7371C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Unwind_Resume(a1);
}

BOOL __nw_framer_write_output_no_copy_block_invoke(void *a1, void *a2)
{
  uint64_t v138 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (nw_frame_uses_external_data((uint64_t)v3))
  {
    size_t size = 0LL;
    uint64_t v4 = (dispatch_data_s *)nw_frame_copy_external_data((uint64_t)v3, (_DWORD *)&size + 1, &size);
    if (gLogDatapath)
    {
      __nwlog_obj();
      __int16 v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v100 = a1[4];
        if (v100) {
          uint64_t v101 = (const char *)(v100 + 609);
        }
        else {
          uint64_t v101 = "";
        }
        *(_DWORD *)int buf = 136446978;
        uint64_t v132 = "nw_framer_write_output_no_copy_block_invoke";
        __int16 v133 = 2080;
        __int16 v134 = v101;
        __int16 v135 = 1024;
        *(_DWORD *)uint64_t v136 = size;
        *(_WORD *)&v136[4] = 1024;
        *(_DWORD *)&v136[6] = HIDWORD(size);
        _os_log_impl( &dword_181A5C000,  v99,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Writing %u external data bytes from offset %u",  buf,  0x22u);
      }
    }

    if (HIDWORD(size))
    {
      size_t v5 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
      goto LABEL_22;
    }

    size_t v5 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
    if (v5 < size)
    {
LABEL_22:
      if (v5 < size)
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(v4, HIDWORD(size), v5);
        uint64_t v38 = *(void *)(a1[6] + 8LL);
        uint64_t v41 = *(dispatch_data_s **)(v38 + 40);
        uint64_t v39 = (id *)(v38 + 40);
        uint64_t v40 = v41;
        if (v41)
        {
          dispatch_data_t concat = dispatch_data_create_concat(v40, subrange);
          uint64_t v43 = *(void *)(a1[6] + 8LL);
          uint64_t v44 = *(void **)(v43 + 40);
          *(void *)(v43 + 40) = concat;

          if (!gLogDatapath) {
            goto LABEL_57;
          }
          __nwlog_obj();
          __int16 v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_121;
          }
          uint64_t v47 = a1[4];
          if (v47) {
            __int16 v48 = (const char *)(v47 + 609);
          }
          else {
            __int16 v48 = "";
          }
          size_t v49 = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL));
          uint64_t v50 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
          *(_DWORD *)int buf = 136447234;
          uint64_t v132 = "nw_framer_write_output_no_copy_block_invoke";
          __int16 v133 = 2080;
          __int16 v134 = v48;
          __int16 v135 = 2048;
          *(void *)uint64_t v136 = v49;
          *(_WORD *)&v136[8] = 2048;
          *(void *)&v136[10] = v50;
          *(_WORD *)&v136[18] = 1024;
          int v137 = HIDWORD(size);
          os_log_type_t v51 = "%{public}s %s Appending subrange data to output data, now %zu bytes from length %zu offset %u";
        }

        else
        {
          objc_storeStrong(v39, subrange);
          if (!gLogDatapath) {
            goto LABEL_57;
          }
          __nwlog_obj();
          __int16 v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
LABEL_121:

LABEL_57:
            nw_frame_claim((uint64_t)v3, v45, *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL), 0);
            *(_DWORD *)(a1[4] + 600LL) += *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
            *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = 0LL;
            if (gLogDatapath)
            {
              __nwlog_obj();
              __int16 v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v83 = a1[4];
                uint64_t v84 = (const char *)(v83 + 609);
                if (!v83) {
                  uint64_t v84 = "";
                }
                int v85 = *(_DWORD *)(v83 + 600);
                uint64_t v86 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
                *(_DWORD *)int buf = 136446978;
                uint64_t v132 = "nw_framer_write_output_no_copy_block_invoke";
                __int16 v133 = 2080;
                __int16 v134 = v84;
                __int16 v135 = 1024;
                *(_DWORD *)uint64_t v136 = v85;
                *(_WORD *)&v136[4] = 2048;
                *(void *)&v136[6] = v86;
                _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Pending output cursor %u, remaining output %zu",  buf,  0x26u);
              }

void nw_framer_resume_input(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[46]);
    if (((_BYTE)v2[76] & 1) == 0)
    {
      *((_BYTE *)v2 + 608) &= ~4u;
      nw_framer_input_loop((NWConcrete_nw_framer *)v2);
      nw_framer_signal_input_available((NWConcrete_nw_framer *)v2);
    }

    goto LABEL_4;
  }

  __nwlog_obj();
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_framer_resume_input";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_resume_input";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_framer_resume_input";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_resume_input";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_resume_input";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D74978(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_input_loop(NWConcrete_nw_framer *a1)
{
  uint64_t v1 = a1;
  do
  {
    if (v1->received_input_frames.tqh_first)
    {
      int v2 = 0;
      nw_frame_array_get_frame_count((uint64_t *)&v1->received_input_frames, 1, &v2);
    }

    nw_framer_get_input_from_below(v1);
    if ((*((_BYTE *)v1 + 607) & 2) == 0) {
      break;
    }
    nw_framer_process_input_callout(v1);
    if (v1->protocol.default_input_handler) {
      break;
    }
  }

  while ((*((_BYTE *)v1 + 608) & 4) == 0);
}

void sub_181D74A2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_get_input_from_below(NWConcrete_nw_framer *a1)
{
  uint64_t v1 = a1;
  uint64_t v6 = 0LL;
  size_t v7 = (nw_frame **)&v6;
  uint64_t output_handler = v1->protocol.output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      get_input_frames = (void (*)(void))callbacks->get_input_frames;
      if (get_input_frames)
      {
        get_input_frames();
        if (v6)
        {
          *v1->received_input_frames.tqh_last = (nw_frame *)v6;
          size_t v5 = v7;
          *(void *)(v6 + 40) = v1->received_input_frames.tqh_last;
          v1->received_input_frames.tqh_last = v5;
          *((_BYTE *)v1 + 607) |= 2u;
        }
      }
    }
  }
}

void sub_181D74ADC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_process_input_callout(NWConcrete_nw_framer *a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v25 = "nw_framer_process_input_callout";
    dispatch_data_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v25 = "nw_framer_process_input_callout";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null framer", buf, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v25 = "nw_framer_process_input_callout";
            __int16 v26 = 2082;
            log_str = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }

        if (v18)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v25 = "nw_framer_process_input_callout";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v25 = "nw_framer_process_input_callout";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D74F74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_process_body_input(NWConcrete_nw_framer *a1)
{
  framer = a1;
  if (framer->input_body_remaining && framer->received_input_frames.tqh_first)
  {
    uint64_t v1 = framer;
    do
    {
      size_t input_body_remaining = v1->input_body_remaining;
      if (!input_body_remaining) {
        break;
      }
      v1->size_t input_body_remaining = 0LL;
      BOOL v3 = nw_framer_deliver_input_no_copy( (nw_framer_t)v1,  input_body_remaining,  v1->pending_inbound_message,  (*((_BYTE *)v1 + 607) & 8) != 0);
      uint64_t v1 = framer;
    }

    while (v3);
    if (v1->pending_input_frames.tqh_first) {
      nw_framer_signal_input_available(framer);
    }
  }
}

void sub_181D75010( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_framer_suspend_input(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(*((void **)v1 + 46));
    if ((v2[608] & 1) == 0) {
      v2[608] |= 4u;
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_framer_suspend_input";
  int v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_suspend_input";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_framer_suspend_input";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_suspend_input";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_suspend_input";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D752C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_pass_through_input(nw_framer_t framer)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = framer;
  int v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[46]);
    *((_BYTE *)v2 + 608) |= 1u;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_framer_pass_through_input";
  int v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_pass_through_input";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_framer_pass_through_input";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_pass_through_input";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_pass_through_input";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D75570(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_pass_through_output(nw_framer_t framer)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = framer;
  int v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[46]);
    nw_framer_flush_output(v2, 0LL);
    *((_BYTE *)v2 + 608) |= 2u;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_framer_pass_through_output";
  int v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_pass_through_output";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_framer_pass_through_output";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_pass_through_output";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_framer_pass_through_output";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D7582C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_set_input_handler(nw_framer_t framer, nw_framer_input_handler_t input_handler)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  nw_framer_input_handler_t v4 = input_handler;
  size_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_framer_set_input_handler";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_input_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_framer_set_input_handler";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_input_handler";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_input_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_framer_set_output_handler(nw_framer_t framer, nw_framer_output_handler_t output_handler)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  nw_framer_output_handler_t v4 = output_handler;
  size_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_framer_set_output_handler";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_output_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_framer_set_output_handler";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_output_handler";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_output_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_framer_set_wakeup_handler(nw_framer_t framer, nw_framer_wakeup_handler_t wakeup_handler)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  nw_framer_wakeup_handler_t v4 = wakeup_handler;
  size_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_framer_set_wakeup_handler";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_framer_set_wakeup_handler";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_framer_set_stop_handler(nw_framer_t framer, nw_framer_stop_handler_t stop_handler)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  nw_framer_stop_handler_t v4 = stop_handler;
  size_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_framer_set_stop_handler";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_stop_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_framer_set_stop_handler";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_stop_handler";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_stop_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_framer_set_cleanup_handler(nw_framer_t framer, nw_framer_cleanup_handler_t cleanup_handler)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  nw_framer_cleanup_handler_t v4 = cleanup_handler;
  size_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_framer_set_cleanup_handler";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_framer_set_cleanup_handler";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_framer_set_copy_metadata(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = a1;
  id v4 = a2;
  size_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_framer_set_copy_metadata";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_copy_metadata";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_framer_set_copy_metadata";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_copy_metadata";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_framer_set_copy_metadata";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_framer_schedule_wakeup(nw_framer_t framer, uint64_t milliseconds)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  uint64_t v4 = (uint64_t)v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_framer_schedule_wakeup";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_framer_schedule_wakeup";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", location, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)location = 136446466;
          *(void *)&location[4] = "nw_framer_schedule_wakeup";
          __int16 v27 = 2082;
          __int16 v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null framer, dumping backtrace:%{public}s",  location,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9) {
          goto LABEL_6;
        }
LABEL_41:
        free(v9);
        goto LABEL_6;
      }

      if (v16)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_framer_schedule_wakeup";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer, no backtrace", location, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_framer_schedule_wakeup";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null framer, backtrace limit exceeded",  location,  0xCu);
      }
    }

void sub_181D7863C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_framer_schedule_wakeup_block_invoke(uint64_t a1)
{
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v1 = WeakRetained[52];
    if (v1) {
      (*(void (**)(uint64_t, void *))(v1 + 16))(v1, WeakRetained);
    }
  }
}

void sub_181D786A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_framer_async(nw_framer_t framer, nw_framer_block_t async_block)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  nw_framer_t v3 = framer;
  nw_framer_block_t v4 = async_block;
  size_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    int v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v29 = "nw_framer_async";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v29 = "nw_framer_async";
          __int16 v30 = 2082;
          __int16 v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D78D70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_framer_copy_remote_endpoint(nw_framer_t framer)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v1 = framer;
  int v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[46]);
    nw_framer_t v3 = v2[42];
    if (v3 && (uint64_t v4 = v3[3]) != 0 && (v5 = *(void (**)(void))(v4 + 136)) != 0LL)
    {
      v5();
      os_log_type_t v6 = (nw_endpoint *)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      os_log_type_t v6 = v2[44];
    }

    int v7 = v6;
    goto LABEL_7;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v20 = "nw_framer_copy_remote_endpoint";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v20 = "nw_framer_copy_remote_endpoint";
          __int16 v21 = 2082;
          BOOL v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_remote_endpoint";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D7904C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_framer_copy_local_endpoint(nw_framer_t framer)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v1 = framer;
  int v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[46]);
    nw_framer_t v3 = v2[42];
    if (v3 && (uint64_t v4 = v3[3]) != 0 && (v5 = *(void (**)(void))(v4 + 128)) != 0LL)
    {
      uint64_t v6 = v5();
    }

    else
    {
      uint64_t v6 = (uint64_t)nw_parameters_copy_local_endpoint((nw_parameters_t)v2[45]);
    }

    int v7 = (nw_endpoint *)v6;
    goto LABEL_7;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v20 = "nw_framer_copy_local_endpoint";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_local_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v20 = "nw_framer_copy_local_endpoint";
          __int16 v21 = 2082;
          BOOL v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_local_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_local_endpoint";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D79328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_parameters_t nw_framer_copy_parameters(nw_framer_t framer)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v1 = framer;
  int v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[46]);
    nw_framer_t v3 = v2[42];
    if (v3 && (uint64_t v4 = v3[3]) != 0 && (v5 = *(void (**)(void))(v4 + 112)) != 0LL)
    {
      v5();
      uint64_t v6 = (nw_parameters *)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      uint64_t v6 = v2[45];
    }

    int v7 = v6;
    goto LABEL_7;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v20 = "nw_framer_copy_parameters";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_parameters";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v20 = "nw_framer_copy_parameters";
          __int16 v21 = 2082;
          BOOL v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_parameters";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_copy_parameters";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D79604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_options_t nw_framer_copy_options(nw_framer_t framer)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v1 = framer;
  int v2 = v1;
  if (v1)
  {
    nw_parameters_t v3 = nw_framer_copy_parameters(v1);
    nw_parameters_t v4 = v3;
    if (v3)
    {
      size_t v5 = nw_parameters_copy_protocol_options_legacy(v3, (nw_protocol *)((char *)v2 + 288));
LABEL_4:

      goto LABEL_5;
    }

    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    char v26 = "nw_framer_copy_options";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v12, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v26 = "nw_framer_copy_options";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)int buf = 136446466;
            char v26 = "nw_framer_copy_options";
            __int16 v27 = 2082;
            __int16 v28 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }

        if (v20)
        {
          *(_DWORD *)int buf = 136446210;
          char v26 = "nw_framer_copy_options";
          _os_log_impl(&dword_181A5C000, v13, v19, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v26 = "nw_framer_copy_options";
          _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D79AD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_prepend_application_protocol_unsafe(void *a1, void *a2)
{
  return nw_framer_prepend_application_protocol_inner(a1, a2, 1);
}

uint64_t nw_framer_prepend_application_protocol_inner(void *a1, void *a2, int a3)
{
  uint64_t v175 = *MEMORY[0x1895F89C0];
  size_t v5 = a1;
  id v6 = a2;
  uint64_t v154 = v6;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
    BOOL v90 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v167) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v92 = type[0];
      if (os_log_type_enabled(v91, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
        _os_log_impl(&dword_181A5C000, v91, v92, "%{public}s called with null framer", buf, 0xCu);
      }

      goto LABEL_195;
    }

    if (!(_BYTE)v167)
    {
      __nwlog_obj();
      uint64_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v135 = type[0];
      if (os_log_type_enabled(v91, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
        _os_log_impl( &dword_181A5C000,  v91,  v135,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_195;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v105 = type[0];
    BOOL v106 = os_log_type_enabled(v104, type[0]);
    if (backtrace_string)
    {
      if (v106)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      if (!v90) {
        goto LABEL_210;
      }
      goto LABEL_209;
    }

    if (v106)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
      _os_log_impl(&dword_181A5C000, v104, v105, "%{public}s called with null framer, no backtrace", buf, 0xCu);
    }

    goto LABEL_207;
  }

  int v7 = v6;
  if (!v6)
  {
    __nwlog_obj();
    __int16 v93 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
    BOOL v90 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v167) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v94 = type[0];
      if (os_log_type_enabled(v91, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
        _os_log_impl(&dword_181A5C000, v91, v94, "%{public}s called with null orig_protocol_options", buf, 0xCu);
      }

LABEL_209:
      free(v90);
      goto LABEL_210;
    }

    if (v109)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
      _os_log_impl( &dword_181A5C000,  v104,  v108,  "%{public}s called with null orig_protocol_options, no backtrace",  buf,  0xCu);
    }

              goto LABEL_210;
            }

            if (!type[0])
            {
              __nwlog_obj();
              uint64_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v119 = buf[0];
              if (os_log_type_enabled(v89, (os_log_type_t)buf[0]))
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v89,  v119,  "%{public}s called with null workloop, backtrace limit exceeded",  handler,  0xCu);
              }

              goto LABEL_209;
            }

            __int16 v104 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v105 = buf[0];
            BOOL v106 = os_log_type_enabled(v89, (os_log_type_t)buf[0]);
            if (!v104)
            {
              if (v106)
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v89,  v105,  "%{public}s called with null workloop, no backtrace",  handler,  0xCu);
              }

              goto LABEL_209;
            }

            if (v106)
            {
              *(_DWORD *)handler = 136446466;
              *(void *)&handler[4] = "nw_connection_group_copy_workloop";
              *(_WORD *)&handler[12] = 2082;
              *(void *)&handler[14] = v104;
              _os_log_impl( &dword_181A5C000,  v89,  v105,  "%{public}s called with null workloop, dumping backtrace:%{public}s",  handler,  0x16u);
            }

            free(v104);
          }

  if (v53) {
    free(v53);
  }
}

        if (v43) {
          free(v43);
        }
        BOOL v17 = 0LL;
        goto LABEL_23;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v44 = (os_log_s *)__nwlog_obj();
        uint64_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v83 = "_http_safe_append";
          __int16 v46 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      uint64_t v67 = (char *)__nw_create_backtrace_string();
      BOOL v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = __src;
      uint64_t v68 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v68)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v83 = "_http_safe_append";
          __int16 v46 = "%{public}s called with null data, no backtrace";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (v68)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v83 = "_http_safe_append";
        uint64_t v84 = 2082;
        os_log_type_t v85 = v67;
        uint64_t v69 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_143:
        _os_log_impl(&dword_181A5C000, v44, v45, v69, buf, 0x16u);
      }
    }

    free(v67);
    goto LABEL_209;
  }

        if (v43) {
          free(v43);
        }
        BOOL v17 = 0LL;
        goto LABEL_23;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v44 = (os_log_s *)__nwlog_obj();
        uint64_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v83 = "_http_safe_append";
          __int16 v46 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      uint64_t v67 = (char *)__nw_create_backtrace_string();
      BOOL v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = __src;
      uint64_t v68 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v68)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v83 = "_http_safe_append";
          __int16 v46 = "%{public}s called with null data, no backtrace";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (v68)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v83 = "_http_safe_append";
        uint64_t v84 = 2082;
        os_log_type_t v85 = v67;
        uint64_t v69 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_143:
        _os_log_impl(&dword_181A5C000, v44, v45, v69, buf, 0x16u);
      }
    }

    free(v67);
    goto LABEL_209;
  }

        if (v43) {
          free(v43);
        }
        BOOL v17 = 0LL;
        goto LABEL_23;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v44 = (os_log_s *)__nwlog_obj();
        uint64_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v83 = "_http_safe_append";
          __int16 v46 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      uint64_t v67 = (char *)__nw_create_backtrace_string();
      BOOL v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = __src;
      uint64_t v68 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v68)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v83 = "_http_safe_append";
          __int16 v46 = "%{public}s called with null data, no backtrace";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (v68)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v83 = "_http_safe_append";
        uint64_t v84 = 2082;
        os_log_type_t v85 = v67;
        uint64_t v69 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_143:
        _os_log_impl(&dword_181A5C000, v44, v45, v69, buf, 0x16u);
      }
    }

    free(v67);
    goto LABEL_209;
  }

    os_log_type_t v65 = dataa;
    if (v105) {
      free(v105);
    }
    goto LABEL_211;
  }

  if (v16 < 1) {
    goto LABEL_82;
  }
  uint64_t v33 = nw_endpoint_create_address(v7);
  size_t v34 = nw_interface_create_with_index(v293);
  int v35 = nw_endpoint_create_address((const sockaddr *)address);
  v263 = v14;
  v260 = v35;
  id v36 = v33;
  data = v34;
  v268 = v36;
  if (!(_WORD)v16)
  {
    __nwlog_obj();
    v194 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_listener_inbox_socket_handle_new_packet";
    v195 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v283.sa_len = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v196 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v197 = type[0];
      if (os_log_type_enabled(v196, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A5C000, v196, v197, "%{public}s called with null packet_length", buf, 0xCu);
      }
    }

    else if (v283.sa_len)
    {
      v227 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v196 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v228 = type[0];
      v229 = os_log_type_enabled(v196, type[0]);
      if (v227)
      {
        if (v229)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_socket_handle_new_packet";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v227;
          _os_log_impl( &dword_181A5C000,  v196,  v228,  "%{public}s called with null packet_length, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v227);
LABEL_549:
        if (!v195) {
          goto LABEL_124;
        }
        goto LABEL_550;
      }

      if (v229)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl(&dword_181A5C000, v196, v228, "%{public}s called with null packet_length, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v196 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v237 = type[0];
      if (os_log_type_enabled(v196, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_socket_handle_new_packet";
        _os_log_impl( &dword_181A5C000,  v196,  v237,  "%{public}s called with null packet_length, backtrace limit exceeded",  buf,  0xCu);
      }
    }

  if (v57) {
    free(v57);
  }
  id v16 = 0LL;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_29:
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      __int16 v27 = a2[1].callbacks;
      if (v27)
      {
        __int16 v28 = (nw_protocol_callbacks *)((char *)v27 - 1);
        a2[1].callbacks = v28;
        if (!v28)
        {
          uint64_t v29 = *(void (***)(void))a2[1].flow_id;
          if (v29)
          {
            *(void *)a2[1].flow_id = 0LL;
            v29[2](v29);
            _Block_release(v29);
          }

          if ((a2[1].flow_id[8] & 1) != 0)
          {
            uint64_t v30 = *(const void **)a2[1].flow_id;
            if (v30) {
              _Block_release(v30);
            }
          }

          free(a2);
        }
      }
    }
  }

void sub_181D7BA38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, void *a25)
{
  _Unwind_Resume(a1);
}

BOOL nw_framer_prepend_application_protocol(nw_framer_t framer, nw_protocol_options_t protocol_options)
{
  return nw_framer_prepend_application_protocol_inner(framer, protocol_options, 0);
}

void nw_framer_mark_ready(nw_framer_t framer)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v1 = framer;
  int v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[46]);
    if ((*((_BYTE *)v2 + 606) & 0x10) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v20 = "nw_framer_mark_ready";
        __int16 v21 = 2080;
        os_log_type_t v22 = (char *)v2 + 609;
        _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s %s Already in the ready state", buf, 0x16u);
      }
    }

    else
    {
      *((_BYTE *)v2 + 606) |= 0x10u;
      nw_parameters_t v3 = v2[42];
      if (v3)
      {
        uint64_t v4 = v3[3];
        if (v4)
        {
          size_t v5 = *(void (**)(void))(v4 + 40);
          if (!v5 || (v5(), (v6 = v2[42]) != 0LL) && (uint64_t v4 = v6[3]) != 0)
          {
            int v7 = *(void (**)(void))(v4 + 72);
            if (v7) {
              v7();
            }
          }
        }
      }
    }

    goto LABEL_13;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v20 = "nw_framer_mark_ready";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_mark_ready";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v20 = "nw_framer_mark_ready";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_mark_ready";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v20 = "nw_framer_mark_ready";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D7BE18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_mark_failed_with_error(nw_framer_t framer, int error_code)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  int v2 = framer;
  nw_parameters_t v3 = v2;
  if (v2)
  {
    nw_context_assert_queue(v2[46]);
    *((_BYTE *)v3 + 607) |= 0x80u;
    uint64_t v4 = v3[42];
    if (v4)
    {
      uint64_t v5 = v4[3];
      if (v5)
      {
        id v6 = *(void (**)(void))(v5 + 56);
        if (!v6 || (v6(), (int v7 = v3[42]) != 0LL) && (v5 = v7[3]) != 0)
        {
          os_log_type_t v8 = *(void (**)(void))(v5 + 48);
          if (v8) {
            v8();
          }
        }
      }
    }

    BOOL v9 = v3[40];
    if (v9)
    {
      uint64_t v10 = v9[3];
      if (v10)
      {
        os_log_type_t v11 = *(void (**)(void))(v10 + 32);
        if (v11) {
          v11();
        }
      }
    }

    goto LABEL_13;
  }

  __nwlog_obj();
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v23 = "nw_framer_mark_failed_with_error";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v23 = "nw_framer_mark_failed_with_error";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v23 = "nw_framer_mark_failed_with_error";
          __int16 v24 = 2082;
          int v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v23 = "nw_framer_mark_failed_with_error";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v23 = "nw_framer_mark_failed_with_error";
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D7C134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_connection_state_set_object_value(void *a1, const char *a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a3;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v35 = "nw_framer_connection_state_set_object_value";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v35 = "nw_framer_connection_state_set_object_value";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          int v35 = "nw_framer_connection_state_set_object_value";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11) {
          goto LABEL_8;
        }
LABEL_56:
        free(v11);
        goto LABEL_8;
      }

      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        int v35 = "nw_framer_connection_state_set_object_value";
        _os_log_impl(&dword_181A5C000, v12, v21, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v35 = "nw_framer_connection_state_set_object_value";
        _os_log_impl( &dword_181A5C000,  v12,  v29,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D7C87C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_framer_connection_state_copy_object_value(void *a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  nw_parameters_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (!v21)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (v16)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
      __int16 v25 = 2082;
      uint64_t v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_26;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null key", buf, 0xCu);
      }

void sub_181D7CD78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_definition_t nw_framer_create_definition( const char *identifier, uint32_t flags, nw_framer_start_handler_t start_handler)
{
  char v3 = flags;
  uint64_t v35 = *MEMORY[0x1895F89C0];
  nw_framer_start_handler_t v5 = start_handler;
  id v6 = v5;
  if (identifier)
  {
    if (v5)
    {
      id v7 = v5;
      named = nw_protocol_definition_create_named(v3 & 2 | 1u, (unsigned __int8 *)identifier);
      BOOL v9 = named;
      if (named)
      {
        nw_protocol_definition_initialize_common_state(named);
        if ((v3 & 1) != 0) {
          char v10 = 3;
        }
        else {
          char v10 = 1;
        }
        *((_BYTE *)v9 + 184) = v10 | *((_BYTE *)v9 + 184) & 0xFC;
        v9->common_state->var9 = nw_framer_protocol_create;
        os_log_type_t v11 = _Block_copy(v7);
        common_state = v9->common_state;
        id var10 = common_state->var10;
        common_state->id var10 = v11;

        os_log_type_t v14 = v9;
      }

      nw_protocol_definition_set_metadata_allocator( v9,  (uint64_t)nw_framer_allocate_metadata,  (uint64_t)nw_framer_deallocate_metadata);
      nw_protocol_definition_set_metadata_copy_reply( v9,  nw_framer_message_create_reply,  nw_framer_metadata_copy_original,  nw_framer_metadata_set_original);
      nw_protocol_definition_set_options_allocator( v9,  (uint64_t)nw_framer_allocate_options,  (uint64_t)nw_framer_duplicate_options,  (uint64_t)nw_framer_deallocate_options);
      nw_protocol_definition_set_options_equality_check(v9, (uint64_t)nw_framer_options_are_equal);
      goto LABEL_9;
    }

    __nwlog_obj();
    os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    char v32 = "nw_framer_create_definition";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v17, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v32 = "nw_framer_create_definition";
          _os_log_impl(&dword_181A5C000, v18, v21, "%{public}s called with null start", buf, 0xCu);
        }

void sub_181D7D308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol *nw_framer_protocol_create(nw_protocol_identifier *a1, void *a2, void *a3, void *a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  os_log_type_t v11 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_framer);
  os_log_type_t v12 = v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v17 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    char v29 = "nw_framer_protocol_create";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v19 = (os_log_s *)(id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v29 = "nw_framer_protocol_create";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s [nw_framer init] failed", buf, 0xCu);
        }
      }

      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v19 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)int buf = 136446466;
            char v29 = "nw_framer_protocol_create";
            __int16 v30 = 2082;
            os_log_type_t v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s [nw_framer init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v18) {
            goto LABEL_10;
          }
          goto LABEL_9;
        }

        if (v24)
        {
          *(_DWORD *)int buf = 136446210;
          char v29 = "nw_framer_protocol_create";
          _os_log_impl(&dword_181A5C000, v19, v23, "%{public}s [nw_framer init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v19 = (os_log_s *)(id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v29 = "nw_framer_protocol_create";
          _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s [nw_framer init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v18)
    {
LABEL_10:
      p_protocol = 0LL;
      goto LABEL_11;
    }

void sub_181D7D83C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_framer_allocate_metadata(void *a1)
{
  id v1 = a1;
  int v2 = calloc(1uLL, 0x20uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  nw_framer_start_handler_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_181D7D97C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_deallocate_metadata(uint64_t a1, void **a2)
{
  char v3 = *a2;
  if (*a2)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = ___ZL29nw_framer_deallocate_metadataPU36objcproto25OS_nw_protocol_definition8NSObjectPv_block_invoke;
    applier[3] = &__block_descriptor_40_e37_B24__0r_8__NSObject_OS_xpc_object__16l;
    void applier[4] = a2;
    xpc_dictionary_apply(v3, applier);
    uint64_t v4 = *a2;
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *a2 = 0LL;

  nw_framer_start_handler_t v5 = a2[1];
  a2[1] = 0LL;

  id v6 = a2[2];
  a2[2] = 0LL;

  id v7 = a2[3];
  a2[3] = 0LL;

  free(a2);
}

nw_framer_message_t nw_framer_message_create_reply(void *a1)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v33 = "nw_framer_message_create_reply";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_framer_message_create_reply";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null original_message", buf, 0xCu);
      }

      goto LABEL_46;
    }

    if (!v30)
    {
      __nwlog_obj();
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_framer_message_create_reply";
        _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s called with null original_message, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_46;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_framer_message_create_reply";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null original_message, no backtrace",  buf,  0xCu);
      }

      goto LABEL_46;
    }

    if (v23)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v33 = "nw_framer_message_create_reply";
      __int16 v34 = 2082;
      uint64_t v35 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null original_message, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_34;
  }

  char v3 = (id *)v1;
  id v4 = v3[1];

  char is_framer = nw_protocol_definition_is_framer(v4);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v33 = "nw_framer_message_create_reply";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_framer_message_create_reply";
        _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null nw_protocol_metadata_is_framer_message(original_message)",  buf,  0xCu);
      }

void sub_181D7E000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_framer_metadata_copy_original(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)(a2 + 24);
  if (v2) {
    id v3 = v2;
  }
  return v2;
}

void nw_framer_metadata_set_original(void *a1, void *a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  nw_framer_start_handler_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v35 = "nw_framer_metadata_set_original";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v35 = "nw_framer_metadata_set_original";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v35 = "nw_framer_metadata_set_original";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v13) {
          goto LABEL_11;
        }
LABEL_62:
        free(v13);
        goto LABEL_11;
      }

      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v35 = "nw_framer_metadata_set_original";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v35 = "nw_framer_metadata_set_original";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }

BOOL nw_framer_allocate_options(void *a1)
{
  id v1 = a1;
  int v2 = calloc(1uLL, 0x10uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  nw_framer_start_handler_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_181D7E920(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_framer_duplicate_options(void *a1, uint64_t *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    id v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v22 = "nw_framer_duplicate_options";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v22 = "nw_framer_duplicate_options";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v22 = "nw_framer_duplicate_options";
            __int16 v23 = 2082;
            uint64_t v24 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v17)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v22 = "nw_framer_duplicate_options";
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null existing_handle, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v22 = "nw_framer_duplicate_options";
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D7ECA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_deallocate_options(uint64_t a1, void **a2)
{
  id v3 = *a2;
  *a2 = 0LL;

  id v4 = a2[1];
  a2[1] = 0LL;

  free(a2);
}

BOOL nw_framer_options_are_equal(void *a1, uint64_t *a2, uint64_t *a3)
{
  id v5 = a1;
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  if (*a2) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    BOOL v9 = v6 == v7;
  }

  else
  {
    size_t count = nw_dictionary_get_count(v6);
    if (count == nw_dictionary_get_count(*a3))
    {
      uint64_t v14 = 0LL;
      os_log_type_t v15 = &v14;
      uint64_t v16 = 0x2020000000LL;
      char v17 = 1;
      uint64_t v11 = *a2;
      v13[0] = MEMORY[0x1895F87A8];
      v13[1] = 3221225472LL;
      v13[2] = ___ZL27nw_framer_options_are_equalPU36objcproto25OS_nw_protocol_definition8NSObjectPvS2__block_invoke;
      v13[3] = &unk_189BB8468;
      v13[4] = &v14;
      v13[5] = a3;
      nw_dictionary_apply(v11, (uint64_t)v13);
      BOOL v9 = *((_BYTE *)v15 + 24) != 0;
      _Block_object_dispose(&v14, 8);
    }

    else
    {
      BOOL v9 = 0LL;
    }
  }

  return v9;
}

uint64_t ___ZL27nw_framer_options_are_equalPU36objcproto25OS_nw_protocol_definition8NSObjectPvS2__block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = nw_dictionary_copy_value(**(void **)(a1 + 40), a2);
  uint64_t v7 = v6;
  if (v6 && (v6 == v5 || ([v5 isEqual:v6] & 1) != 0))
  {
    uint64_t v8 = 1LL;
  }

  else
  {
    uint64_t v8 = 0LL;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }

  return v8;
}

void sub_181D7EE6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_framer_metadata_set_originalPU34objcproto23OS_nw_protocol_metadata8NSObjectS1__block_invoke( uint64_t a1, uint64_t a2)
{
  return 1LL;
}

nw_framer_message_t nw_framer_protocol_create_message(nw_protocol_definition_t definition)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = definition;
  int v2 = v1;
  if (v1)
  {
    singleton = nw_protocol_metadata_create_singleton(v1);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v16 = "nw_framer_protocol_create_message";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_framer_protocol_create_message";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v16 = "nw_framer_protocol_create_message";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_framer_protocol_create_message";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_framer_protocol_create_message";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D7F13C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_framer_message_create_reply_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t ___ZL29nw_framer_deallocate_metadataPU36objcproto25OS_nw_protocol_definition8NSObjectPv_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t value = xpc_pointer_get_value();
  if (value)
  {
    uint64_t v5 = value;
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    if (v6)
    {
      uint64_t v7 = nw_dictionary_copy_value(v6, a2);
      os_log_type_t v8 = v7;
      if (v7) {
        (*((void (**)(void *, uint64_t))v7 + 2))(v7, v5);
      }
    }
  }

  return 1LL;
}

void sub_181D7F1E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_protocol_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v4 = a1->handle;
    uint64_t v5 = v4;
    if (v4)
    {
      if (v4[1])
      {
        if (a1->default_input_handler)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v6 = (id)gLogObj;
          *(_DWORD *)int buf = 136446466;
          uint64_t v69 = "nw_framer_protocol_add_input_handler";
          __int16 v70 = 2080;
          uint64_t v71 = (char *)v5 + 609;
          uint64_t v7 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v66 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v8 = (os_log_s *)(id)gLogObj;
            os_log_type_t v9 = type;
            if (os_log_type_enabled(v8, type))
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v69 = "nw_framer_protocol_add_input_handler";
              __int16 v70 = 2080;
              uint64_t v71 = (char *)v5 + 609;
              _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s %s Protocol instance already has default input handler",  buf,  0x16u);
            }
          }

          else if (v66)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v8 = (os_log_s *)(id)gLogObj;
            os_log_type_t v12 = type;
            BOOL v13 = os_log_type_enabled(v8, type);
            if (backtrace_string)
            {
              if (v13)
              {
                *(_DWORD *)int buf = 136446722;
                uint64_t v69 = "nw_framer_protocol_add_input_handler";
                __int16 v70 = 2080;
                uint64_t v71 = (char *)v5 + 609;
                __int16 v72 = 2082;
                dispatch_data_t v73 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s %s Protocol instance already has default input handler, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(backtrace_string);
              if (!v7) {
                goto LABEL_52;
              }
              goto LABEL_51;
            }

            if (v13)
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v69 = "nw_framer_protocol_add_input_handler";
              __int16 v70 = 2080;
              uint64_t v71 = (char *)v5 + 609;
              _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s %s Protocol instance already has default input handler, no backtrace",  buf,  0x16u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v8 = (os_log_s *)(id)gLogObj;
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v8, type))
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v69 = "nw_framer_protocol_add_input_handler";
              __int16 v70 = 2080;
              uint64_t v71 = (char *)v5 + 609;
              _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s %s Protocol instance already has default input handler, backtrace limit exceeded",  buf,  0x16u);
            }
          }

          goto LABEL_49;
        }

        if (gLogDatapath)
        {
          __nwlog_obj();
          size_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v69 = "nw_framer_protocol_add_input_handler";
            __int16 v70 = 2080;
            uint64_t v71 = (char *)v5 + 609;
            _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Protocol add input handler",  buf,  0x16u);
          }
        }

        nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
        if (a2)
        {
          *(_OWORD *)a1->flow_id = *(_OWORD *)a2->flow_id;
          if (!a2->output_handler) {
            nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
          }
          os_log_type_t v10 = (void *)v5[45];
          if (!v10)
          {
LABEL_40:
            callbacks = a2->callbacks;
            if (callbacks)
            {
              supports_external_data = (uint64_t (*)(nw_protocol *))callbacks->supports_external_data;
              if (supports_external_data) {
                *((_BYTE *)v5 + 606) = *((_BYTE *)v5 + 606) & 0xFE | supports_external_data(a2);
              }
            }

            goto LABEL_43;
          }
        }

        else
        {
          os_log_type_t v10 = (void *)v5[45];
          if (!v10) {
            goto LABEL_43;
          }
        }

        uint64_t v14 = nw_parameters_copy_protocol_options_legacy(v10, (nw_protocol *)(v5 + 36));
        os_log_type_t v15 = v14;
        if (v14)
        {
          uint64_t v16 = v14;
          id v17 = v16[1];
        }

        else
        {
          id v17 = (id)v5[1];
        }

        id v19 = v17;
        os_log_type_t v20 = v19;
        if (v19)
        {
          uint64_t v21 = *((void *)v19 + 9);
          if (v21)
          {
            BOOL v22 = _Block_copy(*(const void **)(v21 + 80));
            goto LABEL_32;
          }

          __nwlog_obj();
          uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)int buf = 136446210;
          uint64_t v69 = "nw_protocol_definition_copy_framer_start";
          os_log_type_t v51 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v66 = 0;
          if (__nwlog_fault(v51, &type, &v66))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v55 = type;
              if (os_log_type_enabled(v52, type))
              {
                *(_DWORD *)int buf = 136446210;
                uint64_t v69 = "nw_protocol_definition_copy_framer_start";
                _os_log_impl( &dword_181A5C000,  v52,  v55,  "%{public}s called with null definition->common_state",  buf,  0xCu);
              }

void sub_181D8017C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_protocol_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v6 = a1->handle;
    uint64_t v7 = (char *)v6;
    if (v6)
    {
      if (v6[1])
      {
        if (a2)
        {
          if (a3)
          {
            if (a1->default_input_handler == a2)
            {
              nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a3);
              *(_OWORD *)a1->flow_id = *(_OWORD *)a3->flow_id;
              if (!a3->output_handler) {
                nw_protocol_set_output_handler((uint64_t)a3, (uint64_t)a1);
              }
              callbacks = a3->callbacks;
              if (callbacks
                && (supports_external_data = (uint64_t (*)(nw_protocol *))callbacks->supports_external_data) != 0LL)
              {
                char v16 = v7[606] & 0xFE | supports_external_data(a3);
              }

              else
              {
                char v16 = v7[606] & 0xFE;
              }

              v7[606] = v16;
              uint64_t v17 = 1LL;
              goto LABEL_33;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v8 = (id)gLogObj;
            uint64_t default_input_handler = a1->default_input_handler;
            *(_DWORD *)int buf = 136446978;
            uint64_t v59 = "nw_framer_protocol_replace_input_handler";
            __int16 v60 = 2080;
            BOOL v61 = v7 + 609;
            __int16 v62 = 2048;
            BOOL v63 = default_input_handler;
            __int16 v64 = 2048;
            os_log_type_t v65 = a2;
            os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v56 = 0;
            if (__nwlog_fault(v10, &type, &v56))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v11 = (os_log_s *)(id)gLogObj;
                os_log_type_t v12 = type;
                if (os_log_type_enabled(v11, type))
                {
                  BOOL v13 = a1->default_input_handler;
                  *(_DWORD *)int buf = 136446978;
                  uint64_t v59 = "nw_framer_protocol_replace_input_handler";
                  __int16 v60 = 2080;
                  BOOL v61 = v7 + 609;
                  __int16 v62 = 2048;
                  BOOL v63 = v13;
                  __int16 v64 = 2048;
                  os_log_type_t v65 = a2;
                  _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %s Old input handler does not match (%p != %p)",  buf,  0x2Au);
                }
              }

              else if (v56)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v11 = (os_log_s *)(id)gLogObj;
                os_log_type_t v19 = type;
                BOOL v20 = os_log_type_enabled(v11, type);
                if (backtrace_string)
                {
                  if (v20)
                  {
                    uint64_t v21 = a1->default_input_handler;
                    *(_DWORD *)int buf = 136447234;
                    uint64_t v59 = "nw_framer_protocol_replace_input_handler";
                    __int16 v60 = 2080;
                    BOOL v61 = v7 + 609;
                    __int16 v62 = 2048;
                    BOOL v63 = v21;
                    __int16 v64 = 2048;
                    os_log_type_t v65 = a2;
                    __int16 v66 = 2082;
                    uint64_t v67 = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v11,  v19,  "%{public}s %s Old input handler does not match (%p != %p), dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(backtrace_string);
                  if (!v10) {
                    goto LABEL_32;
                  }
                  goto LABEL_31;
                }

                if (v20)
                {
                  uint64_t v24 = a1->default_input_handler;
                  *(_DWORD *)int buf = 136446978;
                  uint64_t v59 = "nw_framer_protocol_replace_input_handler";
                  __int16 v60 = 2080;
                  BOOL v61 = v7 + 609;
                  __int16 v62 = 2048;
                  BOOL v63 = v24;
                  __int16 v64 = 2048;
                  os_log_type_t v65 = a2;
                  _os_log_impl( &dword_181A5C000,  v11,  v19,  "%{public}s %s Old input handler does not match (%p != %p), no backtrace",  buf,  0x2Au);
                }
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v11 = (os_log_s *)(id)gLogObj;
                os_log_type_t v22 = type;
                if (os_log_type_enabled(v11, type))
                {
                  __int16 v23 = a1->default_input_handler;
                  *(_DWORD *)int buf = 136446978;
                  uint64_t v59 = "nw_framer_protocol_replace_input_handler";
                  __int16 v60 = 2080;
                  BOOL v61 = v7 + 609;
                  __int16 v62 = 2048;
                  BOOL v63 = v23;
                  __int16 v64 = 2048;
                  os_log_type_t v65 = a2;
                  _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s %s Old input handler does not match (%p != %p), backtrace limit exceeded",  buf,  0x2Au);
                }
              }
            }

void sub_181D80FB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_framer_protocol_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    BOOL v48 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_protocol_remove_input_handler";
    os_log_type_t v49 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (__nwlog_fault(v49, &type, &v74))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v50, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_protocol_remove_input_handler";
          _os_log_impl(&dword_181A5C000, v50, v51, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if (v74)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v60 = type;
        BOOL v61 = os_log_type_enabled(v50, type);
        if (backtrace_string)
        {
          if (v61)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_framer_protocol_remove_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v50,  v60,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_111;
        }

        if (v61)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_protocol_remove_input_handler";
          _os_log_impl(&dword_181A5C000, v50, v60, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v70 = type;
        if (os_log_type_enabled(v50, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_protocol_remove_input_handler";
          _os_log_impl( &dword_181A5C000,  v50,  v70,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D81D4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_protocol_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v3 = a1->handle;
    id v4 = v3;
    if (v3)
    {
      if (v3[1])
      {
        uint64_t output_handler = a1->output_handler;
        if (output_handler)
        {
          callbacks = output_handler->callbacks;
          if (callbacks)
          {
            if (callbacks->connect)
            {
              uint64_t v7 = nw_protocol_connect((uint64_t)output_handler, (uint64_t)a1);
LABEL_8:

              return v7;
            }
          }
        }

        uint64_t v9 = (void *)v4[45];
        if (v9 && nw_parameters_is_custom_protocols_only(v9))
        {
          nw_framer_protocol_connected(a1, 0LL);
          uint64_t v7 = 1LL;
          goto LABEL_8;
        }

void sub_181D82478(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v4 = a1->handle;
    uint64_t v5 = v4;
    if (v4)
    {
      if (v4[1])
      {
        uint64_t default_input_handler = a1->default_input_handler;
        if (default_input_handler)
        {
          callbacks = default_input_handler->callbacks;
          if (callbacks)
          {
            connected = (void (*)(void))callbacks->connected;
            if (connected) {
              connected();
            }
          }
        }

        if (a1->output_handler == a2)
        {
          char v9 = *((_BYTE *)v5 + 606);
          if ((v9 & 8) != 0)
          {
            if ((*((_BYTE *)v5 + 606) & 0x10) != 0)
            {
              uint64_t v12 = a1->default_input_handler;
              if (v12)
              {
                os_log_type_t v13 = v12->callbacks;
                if (v13)
                {
                  uint64_t v14 = (void (*)(void))v13->connected;
                  if (v14) {
                    v14();
                  }
                }
              }
            }
          }

          else
          {
            *(void *)os_log_type_t type = 0LL;
            if (a2)
            {
              os_log_type_t v10 = a2->callbacks;
              if (v10)
              {
                os_log_type_t v10 = (nw_protocol_callbacks *)v10->get_message_properties;
                if (v10)
                {
                  ((void (*)(nw_protocol *, nw_protocol *, os_log_type_t *))v10)(a2, a1, type);
                  LOBYTE(v10) = type[4];
                  char v9 = *((_BYTE *)v5 + 606);
                }
              }
            }

            else
            {
              LOBYTE(v10) = 0;
            }

            *((_BYTE *)v5 + 606) = (2 * (v10 & 1)) | v9 & 0xFD;
            if ((v10 & 1) != 0 && gLogDatapath)
            {
              __nwlog_obj();
              uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)int buf = 136446466;
                BOOL v41 = "nw_framer_protocol_connected";
                __int16 v42 = 2080;
                os_log_type_t v43 = (char *)v5 + 609;
                _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Output frames will be treated as separate messages",  buf,  0x16u);
              }
            }

            uint64_t v11 = v5[49];
            if (v11)
            {
              *((_BYTE *)v5 + 606) |= 0xCu;
              *((_BYTE *)v5 + 606) &= ~4u;
              nw_framer_input_loop((NWConcrete_nw_framer *)v5);
            }

            else
            {
              nw_framer_mark_failed_with_error((nw_framer_t)v5, 22);
            }
          }
        }

        goto LABEL_9;
      }

      __nwlog_obj();
      __int16 v23 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      BOOL v41 = "nw_framer_protocol_connected";
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v20, type, &v39))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v24 = type[0];
          if (os_log_type_enabled(v21, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            BOOL v41 = "nw_framer_protocol_connected";
            _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }
        }

        else if (v39)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v32 = type[0];
          BOOL v33 = os_log_type_enabled(v21, type[0]);
          if (backtrace_string)
          {
            if (v33)
            {
              *(_DWORD *)int buf = 136446466;
              BOOL v41 = "nw_framer_protocol_connected";
              __int16 v42 = 2082;
              os_log_type_t v43 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v21,  v32,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v20) {
              goto LABEL_9;
            }
            goto LABEL_81;
          }

          if (v33)
          {
            *(_DWORD *)int buf = 136446210;
            BOOL v41 = "nw_framer_protocol_connected";
            _os_log_impl( &dword_181A5C000,  v21,  v32,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v36 = type[0];
          if (os_log_type_enabled(v21, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            BOOL v41 = "nw_framer_protocol_connected";
            _os_log_impl( &dword_181A5C000,  v21,  v36,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_79;
      }

void sub_181D82CB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v4 = a1->handle;
    uint64_t v5 = v4;
    if (v4)
    {
      if (v4[1])
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446466;
            id v38 = "nw_framer_protocol_disconnect";
            __int16 v39 = 2080;
            os_log_type_t v40 = (char *)v5 + 609;
            _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Disconnect from input handler",  buf,  0x16u);
          }
        }

        uint64_t v6 = v5[53];
        if (!v6 || (*(unsigned int (**)(uint64_t, void *))(v6 + 16))(v6, v5))
        {
          *((_BYTE *)v5 + 607) |= 0x80u;
          if (a2)
          {
            callbacks = a2->callbacks;
            if (callbacks)
            {
              disconnected = (void (*)(nw_protocol *, nw_protocol *))callbacks->disconnected;
              if (disconnected) {
                disconnected(a2, a1);
              }
            }
          }

          uint64_t v9 = v5[40];
          if (v9)
          {
            uint64_t v10 = *(void *)(v9 + 24);
            if (v10)
            {
              uint64_t v11 = *(void (**)(void))(v10 + 32);
              if (v11) {
                v11();
              }
            }
          }
        }

        goto LABEL_15;
      }

      __nwlog_obj();
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      id v38 = "nw_framer_protocol_disconnect";
      os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v35 = 0;
      if (__nwlog_fault(v17, &type, &v35))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v21 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)int buf = 136446210;
            id v38 = "nw_framer_protocol_disconnect";
            _os_log_impl(&dword_181A5C000, v18, v21, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }
        }

        else if (v35)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v30 = type;
          BOOL v31 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v31)
            {
              *(_DWORD *)int buf = 136446466;
              id v38 = "nw_framer_protocol_disconnect";
              __int16 v39 = 2082;
              os_log_type_t v40 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v18,  v30,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v17) {
              goto LABEL_15;
            }
            goto LABEL_72;
          }

          if (v31)
          {
            *(_DWORD *)int buf = 136446210;
            id v38 = "nw_framer_protocol_disconnect";
            _os_log_impl( &dword_181A5C000,  v18,  v30,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)int buf = 136446210;
            id v38 = "nw_framer_protocol_disconnect";
            _os_log_impl( &dword_181A5C000,  v18,  v34,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_70;
      }

void sub_181D83464(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v3 = a1->handle;
    id v4 = v3;
    if (v3)
    {
      if (v3[1])
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v37 = "nw_framer_protocol_disconnected";
            __int16 v38 = 2080;
            __int16 v39 = (char *)v4 + 609;
            _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Disconnected from output handler",  buf,  0x16u);
          }
        }

        nw_protocol_remove_instance((uint64_t)a1);
        int v5 = *((char *)v4 + 607);
        if (v5 < 0)
        {
          if (gLogDatapath)
          {
            __nwlog_obj();
            os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v37 = "nw_framer_protocol_disconnected";
              __int16 v38 = 2080;
              __int16 v39 = (char *)v4 + 609;
              _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Framer is already failed, not calling stop",  buf,  0x16u);
            }
          }
        }

        else
        {
          *((_BYTE *)v4 + 607) = v5 | 0x80;
          uint64_t v6 = v4[53];
          if (v6) {
            (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v4);
          }
          uint64_t v7 = v4[42];
          if (v7)
          {
            uint64_t v8 = *(void *)(v7 + 24);
            if (v8)
            {
              uint64_t v9 = *(void (**)(void))(v8 + 48);
              if (v9) {
                v9();
              }
            }
          }
        }

        goto LABEL_13;
      }

      __nwlog_obj();
      os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      uint64_t v37 = "nw_framer_protocol_disconnected";
      os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (__nwlog_fault(v15, &type, &v34))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v16, type))
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v37 = "nw_framer_protocol_disconnected";
            _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }
        }

        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v28 = type;
          BOOL v29 = os_log_type_enabled(v16, type);
          if (backtrace_string)
          {
            if (v29)
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v37 = "nw_framer_protocol_disconnected";
              __int16 v38 = 2082;
              __int16 v39 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v15) {
              goto LABEL_13;
            }
            goto LABEL_73;
          }

          if (v29)
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v37 = "nw_framer_protocol_disconnected";
            _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v16, type))
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v37 = "nw_framer_protocol_disconnected";
            _os_log_impl( &dword_181A5C000,  v16,  v33,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_71;
      }

void sub_181D83C68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_link_state(nw_protocol *a1, nw_protocol *a2, void *a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v43 = "nw_framer_protocol_link_state";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v43 = "nw_framer_protocol_link_state";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null link_info", buf, 0xCu);
      }
    }

    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v43 = "nw_framer_protocol_link_state";
          __int16 v44 = 2082;
          os_log_type_t v45 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s called with null link_info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_73:
        if (!v13) {
          goto LABEL_12;
        }
LABEL_74:
        free(v13);
        goto LABEL_12;
      }

      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v43 = "nw_framer_protocol_link_state";
        _os_log_impl(&dword_181A5C000, v14, v25, "%{public}s called with null link_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v43 = "nw_framer_protocol_link_state";
        _os_log_impl( &dword_181A5C000,  v14,  v36,  "%{public}s called with null link_info, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D84594(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v5 = (unsigned __int8 *)*(id *)(a1 + 40);
    uint64_t v6 = v5;
    if (v5)
    {
      if (*((void *)v5 + 1))
      {
        if (!a3)
        {
LABEL_11:

          return;
        }

        if ((~v5[608] & 3) != 0)
        {
          unsigned int v10 = a3[1] & 0xFFFFFFFC;
          *a3 = -1;
          a3[1] = v10;
          goto LABEL_11;
        }

        uint64_t v7 = *(void *)(a1 + 32);
        if (v7)
        {
          uint64_t v8 = *(void *)(v7 + 24);
          if (v8)
          {
            int v9 = *(void (**)(void))(v8 + 248);
            if (v9)
            {
              v9();
              goto LABEL_11;
            }
          }
        }

        __nwlog_obj();
        os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v22 = *(void *)(a1 + 32);
        os_log_type_t v23 = "invalid";
        if (v22)
        {
          os_log_type_t v24 = *(const char **)(v22 + 16);
          if (v24) {
            os_log_type_t v23 = v24;
          }
        }

        *(_DWORD *)int buf = 136446466;
        os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
        __int16 v59 = 2082;
        os_log_type_t v60 = (void *)v23;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v55 = 0;
        if (__nwlog_fault(v16, &type, &v55))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v26 = type;
            if (os_log_type_enabled(v25, type))
            {
              uint64_t v27 = *(void *)(a1 + 32);
              os_log_type_t v28 = "invalid";
              if (v27)
              {
                BOOL v29 = *(const char **)(v27 + 16);
                if (v29) {
                  os_log_type_t v28 = v29;
                }
              }

              *(_DWORD *)int buf = 136446466;
              os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
              __int16 v59 = 2082;
              os_log_type_t v60 = (void *)v28;
              _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s protocol %{public}s has invalid get_message_properties callback",  buf,  0x16u);
            }
          }

          else if (v55)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v40 = type;
            BOOL v41 = os_log_type_enabled(v25, type);
            if (backtrace_string)
            {
              if (v41)
              {
                uint64_t v42 = *(void *)(a1 + 32);
                os_log_type_t v43 = "invalid";
                if (v42)
                {
                  __int16 v44 = *(const char **)(v42 + 16);
                  if (v44) {
                    os_log_type_t v43 = v44;
                  }
                }

                *(_DWORD *)int buf = 136446722;
                os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
                __int16 v59 = 2082;
                os_log_type_t v60 = (void *)v43;
                __int16 v61 = 2082;
                __int16 v62 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v25,  v40,  "%{public}s protocol %{public}s has invalid get_message_properties callback, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(backtrace_string);
              if (!v16) {
                goto LABEL_11;
              }
              goto LABEL_97;
            }

            if (v41)
            {
              uint64_t v52 = *(void *)(a1 + 32);
              os_log_type_t v53 = "invalid";
              if (v52)
              {
                os_log_type_t v54 = *(const char **)(v52 + 16);
                if (v54) {
                  os_log_type_t v53 = v54;
                }
              }

              *(_DWORD *)int buf = 136446466;
              os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
              __int16 v59 = 2082;
              os_log_type_t v60 = (void *)v53;
              _os_log_impl( &dword_181A5C000,  v25,  v40,  "%{public}s protocol %{public}s has invalid get_message_properties callback, no backtrace",  buf,  0x16u);
            }
          }

          else
          {
            __nwlog_obj();
            os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v48 = type;
            if (os_log_type_enabled(v25, type))
            {
              uint64_t v49 = *(void *)(a1 + 32);
              BOOL v50 = "invalid";
              if (v49)
              {
                os_log_type_t v51 = *(const char **)(v49 + 16);
                if (v51) {
                  BOOL v50 = v51;
                }
              }

              *(_DWORD *)int buf = 136446466;
              os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
              __int16 v59 = 2082;
              os_log_type_t v60 = (void *)v50;
              _os_log_impl( &dword_181A5C000,  v25,  v48,  "%{public}s protocol %{public}s has invalid get_message_properties callback, backtrace limit exceeded",  buf,  0x16u);
            }
          }
        }

        goto LABEL_96;
      }

      __nwlog_obj();
      os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v55 = 0;
      if (__nwlog_fault(v16, &type, &v55))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)int buf = 136446210;
            os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
            _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }
        }

        else if (v55)
        {
          os_log_type_t v36 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v37 = type;
          BOOL v38 = os_log_type_enabled(v17, type);
          if (v36)
          {
            if (v38)
            {
              *(_DWORD *)int buf = 136446466;
              os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
              __int16 v59 = 2082;
              os_log_type_t v60 = v36;
              _os_log_impl( &dword_181A5C000,  v17,  v37,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v36);
            if (!v16) {
              goto LABEL_11;
            }
            goto LABEL_97;
          }

          if (v38)
          {
            *(_DWORD *)int buf = 136446210;
            os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v17,  v37,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v47 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)int buf = 136446210;
            os_log_type_t v58 = "nw_framer_protocol_get_message_properties";
            _os_log_impl( &dword_181A5C000,  v17,  v47,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_89;
      }

void sub_181D84F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_protocol_supports_external_data(nw_protocol *a1)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v1 = a1->handle;
    int v2 = v1;
    if (v1)
    {
      if (*((void *)v1 + 1))
      {
        uint64_t v3 = *((_BYTE *)v1 + 606) & 1;
LABEL_5:

        return v3;
      }

      __nwlog_obj();
      os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      BOOL v29 = "nw_framer_protocol_supports_external_data";
      unsigned int v10 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (__nwlog_fault(v10, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v14 = type;
          if (os_log_type_enabled(v11, type))
          {
            *(_DWORD *)int buf = 136446210;
            BOOL v29 = "nw_framer_protocol_supports_external_data";
            _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }

uint64_t nw_framer_protocol_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = a1->handle;
    uint64_t v3 = v2;
    if (v2)
    {
      if (*((void *)v2 + 1))
      {
        uint64_t v4 = (v2[608] >> 3) & 1;
LABEL_5:

        return v4;
      }

      __nwlog_obj();
      os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_framer_protocol_waiting_for_output";
      char v11 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v27 = 0;
      if (__nwlog_fault(v11, &type, &v27))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v15 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)int buf = 136446210;
            __int16 v30 = "nw_framer_protocol_waiting_for_output";
            _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }

uint64_t nw_framer_protocol_get_output_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    char v11 = a1->handle;
    os_log_type_t v12 = v11;
    if (v11)
    {
      if (*((void *)v11 + 1))
      {
        if (((v11[606] & 0x10) != 0 || (v11[608] & 8) != 0) && (v11[607] & 0x80000000) == 0)
        {
          if ((v11[608] & 2) != 0)
          {
            uint64_t output_handler = a1->output_handler;
            if (output_handler)
            {
              callbacks = output_handler->callbacks;
              if (callbacks)
              {
                get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))callbacks->get_output_frames;
                if (get_output_frames)
                {
                  uint64_t v15 = get_output_frames(a1->output_handler, a1, a3, a4, a5, a6);
LABEL_19:

                  return v15;
                }
              }
            }

            __nwlog_obj();
            __int16 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446722;
              os_log_type_t v47 = "nw_framer_protocol_get_output_frames";
              __int16 v48 = 2080;
              uint64_t v49 = v12 + 609;
              __int16 v50 = 2048;
              os_log_type_t v51 = output_handler;
              _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_ERROR,  "%{public}s %s Unable to call get_output_frames with output_handler %p",  buf,  0x20u);
            }
          }

          else
          {
            if ((v11[608] & 0x40) == 0)
            {
              uint64_t frame = nw_framer_protocol_create_frame( v11,  a4,  (uint64_t)nw_framer_protocol_outbound_data_finalizer,  (uint64_t)(v11 + 480),  v11[606] & 1);
              *(void *)(frame + 32) = 0LL;
              tqh_last = a6->tqh_last;
              *(void *)(frame + 40) = tqh_last;
              *tqh_last = (nw_frame *)frame;
              a6->tqh_last = (nw_frame **)(frame + 32);
              if (gLogDatapath)
              {
                uint64_t v42 = frame;
                __nwlog_obj();
                os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)int buf = 136446722;
                  os_log_type_t v47 = "nw_framer_protocol_get_output_frames";
                  __int16 v48 = 2080;
                  uint64_t v49 = v12 + 609;
                  __int16 v50 = 1024;
                  LODWORD(v51) = a4;
                  _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Created 1 outbound frame with total of %u bytes",  buf,  0x1Cu);
                }

                uint64_t frame = v42;
              }

              uint64_t v15 = 1LL;
              goto LABEL_19;
            }

            if (!gLogDatapath) {
              goto LABEL_18;
            }
            __nwlog_obj();
            __int16 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446466;
              os_log_type_t v47 = "nw_framer_protocol_get_output_frames";
              __int16 v48 = 2080;
              uint64_t v49 = v12 + 609;
              _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Output is blocked, returning 0 frames",  buf,  0x16u);
            }
          }
        }

void sub_181D865AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_protocol_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = a1->handle;
    id v5 = (char *)v4;
    if (v4)
    {
      if (*((void *)v4 + 1))
      {
        if ((v4[152] & 2) == 0)
        {
          v4[150] = 0;
          uint64_t v6 = (void *)*((void *)v4 + 73);
          *((void *)v4 + 73) = 0LL;

          v5[607] &= ~0x10u;
          uint64_t v7 = MEMORY[0x1895F87A8];
          *((void *)v5 + 74) = 0LL;
          v61[0] = v7;
          v61[1] = 3221225472LL;
          __int16 v62 = ___ZL41nw_framer_protocol_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
          uint64_t v63 = &unk_189BB6838;
          os_log_type_t v65 = a2;
          os_log_type_t v8 = v5;
          BOOL v64 = v8;
          tqh_first = a2->tqh_first;
          do
          {
            if (!tqh_first) {
              break;
            }
            unsigned int v10 = (nw_frame *)*((void *)tqh_first + 4);
            char v11 = ((uint64_t (*)(void *))v62)(v61);
            tqh_first = v10;
          }

          while ((v11 & 1) != 0);
          if (*((void *)v8 + 51))
          {
            v5[607] |= 4u;
            v57[0] = v7;
            v57[1] = 3221225472LL;
            os_log_type_t v58 = ___ZL41nw_framer_protocol_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_2;
            __int16 v59 = &unk_189BC7910;
            os_log_type_t v12 = v8;
            os_log_type_t v60 = v12;
            uint64_t v13 = *((void *)v8 + 71);
            do
            {
              if (!v13) {
                break;
              }
              uint64_t v14 = *(void *)(v13 + 32);
              char v15 = ((uint64_t (*)(void *))v58)(v57);
              uint64_t v13 = v14;
            }

            while ((v15 & 1) != 0);
            if (*((void *)v5 + 73) || *((_DWORD *)v5 + 148))
            {
              if (gLogDatapath)
              {
                __nwlog_obj();
                os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
                {
                  int v47 = *((_DWORD *)v5 + 149);
                  __int16 v48 = "s";
                  int v49 = *((_DWORD *)v5 + 148);
                  uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
                  *(_DWORD *)int buf = 136447234;
                  if (v47 == 1) {
                    __int16 v48 = "";
                  }
                  __int16 v70 = 2080;
                  os_log_type_t v71 = v12 + 609;
                  __int16 v72 = 1024;
                  *(_DWORD *)os_log_type_t v73 = v47;
                  *(_WORD *)&v73[4] = 2080;
                  *(void *)&v73[6] = v48;
                  __int16 v74 = 1024;
                  int v75 = v49;
                  _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Asking to write %u outbound frame%s with %u bytes",  buf,  0x2Cu);
                }
              }

              (*(void (**)(void))(*((void *)v8 + 51) + 16LL))();
            }

            v5[607] &= ~4u;
          }

          *((_DWORD *)v5 + 150) = 0;
          os_log_type_t v16 = (void *)*((void *)v5 + 73);
          *((void *)v5 + 73) = 0LL;

          v5[607] &= ~0x10u;
          *((void *)v5 + 74) = 0LL;
          v53[0] = v7;
          v53[1] = 3221225472LL;
          os_log_type_t v54 = ___ZL41nw_framer_protocol_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_136;
          char v55 = &unk_189BC7910;
          os_log_type_t v17 = v8;
          char v56 = v17;
          uint64_t v18 = *((void *)v8 + 71);
          do
          {
            if (!v18) {
              break;
            }
            uint64_t v19 = *(void *)(v18 + 32);
            char v20 = ((uint64_t (*)(void *))v54)(v53);
            uint64_t v18 = v19;
          }

          while ((v20 & 1) != 0);
          nw_framer_flush_output(v17, 0LL);

          uint64_t v21 = 1LL;
          goto LABEL_25;
        }

        uint64_t output_handler = a1->output_handler;
        if (output_handler)
        {
          callbacks = output_handler->callbacks;
          if (callbacks)
          {
            finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))callbacks->finalize_output_frames;
            if (finalize_output_frames)
            {
              uint64_t v21 = finalize_output_frames(output_handler, a2);
LABEL_25:

              return v21;
            }
          }
        }

        __nwlog_obj();
        os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446722;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          __int16 v70 = 2080;
          os_log_type_t v71 = v5 + 609;
          __int16 v72 = 2048;
          *(void *)os_log_type_t v73 = output_handler;
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %s Unable to call finalize_output_frames with output_handler %p",  buf,  0x20u);
        }

LABEL_89:
        uint64_t v21 = 0LL;
        goto LABEL_25;
      }

      __nwlog_obj();
      os_log_type_t v35 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
      os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v67 = OS_LOG_TYPE_ERROR;
      char v66 = 0;
      if (v67 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = v67;
        if (os_log_type_enabled(v33, v67))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v33, v36, "%{public}s called with null framer->parent_definition", buf, 0xCu);
        }
      }

      else if (v66)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = v67;
        BOOL v45 = os_log_type_enabled(v33, v67);
        if (backtrace_string)
        {
          if (v45)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
            __int16 v70 = 2082;
            os_log_type_t v71 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v33,  v44,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v32) {
            goto LABEL_89;
          }
          goto LABEL_88;
        }

        if (v45)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          _os_log_impl( &dword_181A5C000,  v33,  v44,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v52 = v67;
        if (os_log_type_enabled(v33, v67))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          _os_log_impl( &dword_181A5C000,  v33,  v52,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v31 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
      os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v67 = OS_LOG_TYPE_ERROR;
      char v66 = 0;
      if (v67 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = v67;
        if (os_log_type_enabled(v33, v67))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s called with null framer", buf, 0xCu);
        }
      }

      else if (v66)
      {
        os_log_type_t v40 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v41 = v67;
        BOOL v42 = os_log_type_enabled(v33, v67);
        if (v40)
        {
          if (v42)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
            __int16 v70 = 2082;
            os_log_type_t v71 = v40;
            _os_log_impl( &dword_181A5C000,  v33,  v41,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v40);
LABEL_87:
          if (!v32) {
            goto LABEL_89;
          }
LABEL_88:
          free(v32);
          goto LABEL_89;
        }

        if (v42)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v33, v41, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v51 = v67;
        if (os_log_type_enabled(v33, v67))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          _os_log_impl( &dword_181A5C000,  v33,  v51,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_87;
  }

  __nwlog_obj();
  os_log_type_t v27 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
  os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v67 = OS_LOG_TYPE_ERROR;
  char v66 = 0;
  if (__nwlog_fault(v28, &v67, &v66))
  {
    if (v67 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = v67;
      if (os_log_type_enabled(v29, v67))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v66)
    {
      os_log_type_t v37 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = v67;
      BOOL v39 = os_log_type_enabled(v29, v67);
      if (v37)
      {
        if (v39)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
          __int16 v70 = 2082;
          os_log_type_t v71 = v37;
          _os_log_impl( &dword_181A5C000,  v29,  v38,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v37);
        goto LABEL_78;
      }

      if (v39)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
        _os_log_impl(&dword_181A5C000, v29, v38, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v50 = v67;
      if (os_log_type_enabled(v29, v67))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v69 = "nw_framer_protocol_finalize_output_frames";
        _os_log_impl( &dword_181A5C000,  v29,  v50,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D86F8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = a1->handle;
    uint64_t v3 = v2;
    if (v2)
    {
      if (v2->parent_definition)
      {
        char v4 = *((_BYTE *)v2 + 608);
        if ((v4 & 1) == 0)
        {
          if ((*((_BYTE *)v2 + 606) & 0x10) != 0)
          {
            nw_framer_signal_input_available(v2);
            char v4 = *((_BYTE *)v3 + 608);
          }

          if ((v4 & 0x20) != 0)
          {
            if (gLogDatapath)
            {
              __nwlog_obj();
              BOOL v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)int buf = 136446466;
                char v55 = "nw_framer_protocol_input_available";
                __int16 v56 = 2080;
                log_str = v3->log_str;
                _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Input is unacknowledged, not processing input",  buf,  0x16u);
              }
            }
          }

          else
          {
            nw_framer_input_loop(v3);
          }

          goto LABEL_14;
        }

        uint64_t default_input_handler = v2->protocol.default_input_handler;
        if (default_input_handler)
        {
          callbacks = default_input_handler->callbacks;
          if (callbacks)
          {
            input_available = (void (*)(void))callbacks->input_available;
            if (input_available)
            {
              input_available();
LABEL_14:

              return;
            }
          }
        }

        __nwlog_obj();
        os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = v3->protocol.default_input_handler;
        unsigned int v10 = "invalid";
        if (v9)
        {
          name = v9->identifier->name;
          if (name) {
            unsigned int v10 = name;
          }
        }

        *(_DWORD *)int buf = 136446466;
        char v55 = "nw_framer_protocol_input_available";
        __int16 v56 = 2082;
        log_str = (void *)v10;
        os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v52 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v14 = type;
          if (os_log_type_enabled(v13, type))
          {
            char v15 = v3->protocol.default_input_handler;
            os_log_type_t v16 = "invalid";
            if (v15)
            {
              os_log_type_t v17 = v15->identifier->name;
              if (v17) {
                os_log_type_t v16 = v17;
              }
            }

            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_input_available";
            __int16 v56 = 2082;
            log_str = (void *)v16;
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s protocol %{public}s has invalid input_available callback",  buf,  0x16u);
          }
        }

        else if (v52)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v27 = type;
          BOOL v28 = os_log_type_enabled(v13, type);
          if (backtrace_string)
          {
            if (v28)
            {
              os_log_type_t v29 = v3->protocol.default_input_handler;
              os_log_type_t v30 = "invalid";
              if (v29)
              {
                __int16 v31 = v29->identifier->name;
                if (v31) {
                  os_log_type_t v30 = v31;
                }
              }

              *(_DWORD *)int buf = 136446722;
              char v55 = "nw_framer_protocol_input_available";
              __int16 v56 = 2082;
              log_str = (void *)v30;
              __int16 v58 = 2082;
              __int16 v59 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v13,  v27,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
            if (!v12) {
              goto LABEL_14;
            }
            goto LABEL_103;
          }

          if (v28)
          {
            int v49 = v3->protocol.default_input_handler;
            os_log_type_t v50 = "invalid";
            if (v49)
            {
              os_log_type_t v51 = v49->identifier->name;
              if (v51) {
                os_log_type_t v50 = v51;
              }
            }

            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_input_available";
            __int16 v56 = 2082;
            log_str = (void *)v50;
            _os_log_impl( &dword_181A5C000,  v13,  v27,  "%{public}s protocol %{public}s has invalid input_available callback, no backtrace",  buf,  0x16u);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v41 = type;
          if (os_log_type_enabled(v13, type))
          {
            BOOL v42 = v3->protocol.default_input_handler;
            os_log_type_t v43 = "invalid";
            if (v42)
            {
              os_log_type_t v44 = v42->identifier->name;
              if (v44) {
                os_log_type_t v43 = v44;
              }
            }

            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_input_available";
            __int16 v56 = 2082;
            log_str = (void *)v43;
            _os_log_impl( &dword_181A5C000,  v13,  v41,  "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded",  buf,  0x16u);
          }
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_input_available";
        os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v52 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)int buf = 136446210;
            char v55 = "nw_framer_protocol_input_available";
            _os_log_impl(&dword_181A5C000, v13, v25, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }
        }

        else if (v52)
        {
          os_log_type_t v38 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v39 = type;
          BOOL v40 = os_log_type_enabled(v13, type);
          if (v38)
          {
            if (v40)
            {
              *(_DWORD *)int buf = 136446466;
              char v55 = "nw_framer_protocol_input_available";
              __int16 v56 = 2082;
              log_str = v38;
              _os_log_impl( &dword_181A5C000,  v13,  v39,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v38);
            if (!v12) {
              goto LABEL_14;
            }
            goto LABEL_103;
          }

          if (v40)
          {
            *(_DWORD *)int buf = 136446210;
            char v55 = "nw_framer_protocol_input_available";
            _os_log_impl( &dword_181A5C000,  v13,  v39,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v48 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)int buf = 136446210;
            char v55 = "nw_framer_protocol_input_available";
            _os_log_impl( &dword_181A5C000,  v13,  v48,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      char v55 = "nw_framer_protocol_input_available";
      os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v52 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v55 = "nw_framer_protocol_input_available";
          _os_log_impl(&dword_181A5C000, v13, v23, "%{public}s called with null framer", buf, 0xCu);
        }
      }

      else if (v52)
      {
        os_log_type_t v35 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        BOOL v37 = os_log_type_enabled(v13, type);
        if (v35)
        {
          if (v37)
          {
            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_input_available";
            __int16 v56 = 2082;
            log_str = v35;
            _os_log_impl( &dword_181A5C000,  v13,  v36,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v35);
LABEL_102:
          if (!v12) {
            goto LABEL_14;
          }
LABEL_103:
          free(v12);
          goto LABEL_14;
        }

        if (v37)
        {
          *(_DWORD *)int buf = 136446210;
          char v55 = "nw_framer_protocol_input_available";
          _os_log_impl(&dword_181A5C000, v13, v36, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v55 = "nw_framer_protocol_input_available";
          _os_log_impl( &dword_181A5C000,  v13,  v47,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_102;
  }

  __nwlog_obj();
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v55 = "nw_framer_protocol_input_available";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v52 = 0;
  if (__nwlog_fault(v19, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_input_available";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v52)
    {
      os_log_type_t v32 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type;
      BOOL v34 = os_log_type_enabled(v20, type);
      if (v32)
      {
        if (v34)
        {
          *(_DWORD *)int buf = 136446466;
          char v55 = "nw_framer_protocol_input_available";
          __int16 v56 = 2082;
          log_str = v32;
          _os_log_impl( &dword_181A5C000,  v20,  v33,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v32);
        goto LABEL_94;
      }

      if (v34)
      {
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_input_available";
        _os_log_impl(&dword_181A5C000, v20, v33, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_input_available";
        _os_log_impl( &dword_181A5C000,  v20,  v46,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D879DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_protocol_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    os_log_type_t v8 = a1->handle;
    os_log_type_t v9 = v8;
    if (v8)
    {
      if (v8->parent_definition)
      {
        if ((*((_BYTE *)v8 + 606) & 0x10) == 0) {
          goto LABEL_5;
        }
        *((_BYTE *)v8 + 608) &= ~0x20u;
        pending_input_frame_size_t count = v8->pending_input_frame_count;
        if (!pending_input_frame_count)
        {
          nw_framer_process_body_input(v8);
          pending_input_frame_size_t count = v9->pending_input_frame_count;
          if (!pending_input_frame_count)
          {
            if ((*((_BYTE *)v9 + 608) & 1) != 0)
            {
              uint64_t output_handler = a1->output_handler;
              if (output_handler)
              {
                callbacks = output_handler->callbacks;
                if (callbacks)
                {
                  get_input_frames = (uint64_t (*)(void))callbacks->get_input_frames;
                  if (get_input_frames)
                  {
                    uint64_t v10 = get_input_frames();
                    goto LABEL_12;
                  }
                }
              }

              BOOL v42 = a1->output_handler;
              __nwlog_obj();
              os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int buf = 136446722;
                os_log_type_t v47 = "nw_framer_protocol_get_input_frames";
                __int16 v48 = 2080;
                log_str = v9->log_str;
                __int16 v50 = 2048;
                os_log_type_t v51 = v42;
                _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s %s Unable to call get_input_frames with output_handler %p",  buf,  0x20u);
              }

LABEL_5:
              uint64_t v10 = 0LL;
LABEL_12:

              return v10;
            }

            nw_framer_get_input_from_below(v9);
            nw_framer_process_input_callout(v9);
            pending_input_frame_size_t count = v9->pending_input_frame_count;
            if (!pending_input_frame_count) {
              goto LABEL_5;
            }
          }
        }

        v9->pending_input_frame_size_t count = pending_input_frame_count - 1;
        os_log_type_t v12 = v9->pending_input_frames.tqh_first;
        uint64_t v13 = (nw_frame **)((char *)v12 + 32);
        uint64_t v14 = *((void *)v12 + 4);
        char v15 = (nw_frame **)*((void *)v12 + 5);
        if (v14)
        {
          *(void *)(v14 + 40) = v15;
          char v15 = (nw_frame **)*((void *)v12 + 5);
        }

        else
        {
          v9->pending_input_frames.tqh_last = v15;
        }

        *char v15 = (nw_frame *)v14;
        os_log_s *v13 = 0LL;
        *((void *)v12 + 5) = 0LL;
        tqh_last = a6->tqh_last;
        *((void *)v12 + 5) = tqh_last;
        *tqh_last = v12;
        a6->tqh_last = v13;

        uint64_t v10 = 1LL;
        goto LABEL_12;
      }

      __nwlog_obj();
      os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v47 = "nw_framer_protocol_get_input_frames";
      os_log_type_t v26 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v44 = 0;
      if (!__nwlog_fault((const char *)v26, &type, &v44))
      {
LABEL_72:
        if (v26) {
          free(v26);
        }
        goto LABEL_5;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v47 = "nw_framer_protocol_get_input_frames";
          _os_log_impl(&dword_181A5C000, v27, v30, "%{public}s called with null framer->parent_definition", buf, 0xCu);
        }

void sub_181D881F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_input_flush(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = a1->handle;
    uint64_t v3 = v2;
    if (v2)
    {
      if (v2[1])
      {
LABEL_4:

        return;
      }

      __nwlog_obj();
      os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_framer_protocol_input_flush";
      os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v29 = "nw_framer_protocol_input_flush";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null framer->parent_definition", buf, 0xCu);
        }
      }

      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v29 = "nw_framer_protocol_input_flush";
            __int16 v30 = 2082;
            __int16 v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_57:
          if (!v9) {
            goto LABEL_4;
          }
LABEL_58:
          free(v9);
          goto LABEL_4;
        }

        if (v22)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v29 = "nw_framer_protocol_input_flush";
          _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v29 = "nw_framer_protocol_input_flush";
          _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_framer_protocol_input_flush";
      os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v29 = "nw_framer_protocol_input_flush";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null framer", buf, 0xCu);
        }
      }

      else if (v26)
      {
        os_log_type_t v17 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v10, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v29 = "nw_framer_protocol_input_flush";
            __int16 v30 = 2082;
            __int16 v31 = v17;
            _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v17);
          if (!v9) {
            goto LABEL_4;
          }
          goto LABEL_58;
        }

        if (v19)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v29 = "nw_framer_protocol_input_flush";
          _os_log_impl(&dword_181A5C000, v10, v18, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v29 = "nw_framer_protocol_input_flush";
          _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_57;
  }

  __nwlog_obj();
  char v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v29 = "nw_framer_protocol_input_flush";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v5, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v29 = "nw_framer_protocol_input_flush";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v26)
    {
      uint64_t v14 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v6, type);
      if (v14)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v29 = "nw_framer_protocol_input_flush";
          __int16 v30 = 2082;
          __int16 v31 = v14;
          _os_log_impl( &dword_181A5C000,  v6,  v15,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v14);
        goto LABEL_49;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v29 = "nw_framer_protocol_input_flush";
        _os_log_impl(&dword_181A5C000, v6, v15, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v29 = "nw_framer_protocol_input_flush";
        _os_log_impl( &dword_181A5C000,  v6,  v23,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_framer_protocol_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = a1->handle;
    uint64_t v3 = v2;
    if (v2)
    {
      if (v2[1])
      {
        if ((v2[76] & 2) == 0)
        {
          *((_BYTE *)v2 + 608) &= ~0x40u;
          uint64_t v4 = v3[42];
          if (!v4) {
            goto LABEL_14;
          }
          uint64_t v5 = *(void *)(v4 + 24);
          if (!v5) {
            goto LABEL_14;
          }
          uint64_t v6 = *(void (**)(void))(v5 + 72);
          if (!v6) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        uint64_t v7 = v2[42];
        if (v7)
        {
          uint64_t v8 = *(void *)(v7 + 24);
          if (v8)
          {
            uint64_t v6 = *(void (**)(void))(v8 + 72);
            if (v6)
            {
LABEL_13:
              v6();
LABEL_14:

              return;
            }
          }
        }

        __nwlog_obj();
        os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v10 = v3[42];
        os_log_type_t v11 = "invalid";
        if (v10)
        {
          os_log_type_t v12 = *(const char **)(v10 + 16);
          if (v12) {
            os_log_type_t v11 = v12;
          }
        }

        *(_DWORD *)int buf = 136446466;
        char v55 = "nw_framer_protocol_output_available";
        __int16 v56 = 2082;
        os_log_type_t v57 = (void *)v11;
        os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v52 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            uint64_t v16 = v3[42];
            os_log_type_t v17 = "invalid";
            if (v16)
            {
              os_log_type_t v18 = *(const char **)(v16 + 16);
              if (v18) {
                os_log_type_t v17 = v18;
              }
            }

            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_output_available";
            __int16 v56 = 2082;
            os_log_type_t v57 = (void *)v17;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s protocol %{public}s has invalid output_available callback",  buf,  0x16u);
          }
        }

        else if (v52)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v28 = type;
          BOOL v29 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v29)
            {
              uint64_t v30 = v3[42];
              __int16 v31 = "invalid";
              if (v30)
              {
                uint64_t v32 = *(const char **)(v30 + 16);
                if (v32) {
                  __int16 v31 = v32;
                }
              }

              *(_DWORD *)int buf = 136446722;
              char v55 = "nw_framer_protocol_output_available";
              __int16 v56 = 2082;
              os_log_type_t v57 = (void *)v31;
              __int16 v58 = 2082;
              __int16 v59 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
            if (!v13) {
              goto LABEL_14;
            }
            goto LABEL_100;
          }

          if (v29)
          {
            uint64_t v49 = v3[42];
            __int16 v50 = "invalid";
            if (v49)
            {
              os_log_type_t v51 = *(const char **)(v49 + 16);
              if (v51) {
                __int16 v50 = v51;
              }
            }

            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_output_available";
            __int16 v56 = 2082;
            os_log_type_t v57 = (void *)v50;
            _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s protocol %{public}s has invalid output_available callback, no backtrace",  buf,  0x16u);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v42 = type;
          if (os_log_type_enabled(v14, type))
          {
            uint64_t v43 = v3[42];
            char v44 = "invalid";
            if (v43)
            {
              BOOL v45 = *(const char **)(v43 + 16);
              if (v45) {
                char v44 = v45;
              }
            }

            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_output_available";
            __int16 v56 = 2082;
            os_log_type_t v57 = (void *)v44;
            _os_log_impl( &dword_181A5C000,  v14,  v42,  "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded",  buf,  0x16u);
          }
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_output_available";
        os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v52 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v26 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)int buf = 136446210;
            char v55 = "nw_framer_protocol_output_available";
            _os_log_impl(&dword_181A5C000, v14, v26, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }
        }

        else if (v52)
        {
          os_log_type_t v39 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v40 = type;
          BOOL v41 = os_log_type_enabled(v14, type);
          if (v39)
          {
            if (v41)
            {
              *(_DWORD *)int buf = 136446466;
              char v55 = "nw_framer_protocol_output_available";
              __int16 v56 = 2082;
              os_log_type_t v57 = v39;
              _os_log_impl( &dword_181A5C000,  v14,  v40,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v39);
            if (!v13) {
              goto LABEL_14;
            }
            goto LABEL_100;
          }

          if (v41)
          {
            *(_DWORD *)int buf = 136446210;
            char v55 = "nw_framer_protocol_output_available";
            _os_log_impl( &dword_181A5C000,  v14,  v40,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v48 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)int buf = 136446210;
            char v55 = "nw_framer_protocol_output_available";
            _os_log_impl( &dword_181A5C000,  v14,  v48,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      char v55 = "nw_framer_protocol_output_available";
      os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v52 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v55 = "nw_framer_protocol_output_available";
          _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null framer", buf, 0xCu);
        }
      }

      else if (v52)
      {
        BOOL v36 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled(v14, type);
        if (v36)
        {
          if (v38)
          {
            *(_DWORD *)int buf = 136446466;
            char v55 = "nw_framer_protocol_output_available";
            __int16 v56 = 2082;
            os_log_type_t v57 = v36;
            _os_log_impl( &dword_181A5C000,  v14,  v37,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v36);
LABEL_99:
          if (!v13) {
            goto LABEL_14;
          }
LABEL_100:
          free(v13);
          goto LABEL_14;
        }

        if (v38)
        {
          *(_DWORD *)int buf = 136446210;
          char v55 = "nw_framer_protocol_output_available";
          _os_log_impl(&dword_181A5C000, v14, v37, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v55 = "nw_framer_protocol_output_available";
          _os_log_impl( &dword_181A5C000,  v14,  v47,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_99;
  }

  __nwlog_obj();
  BOOL v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v55 = "nw_framer_protocol_output_available";
  char v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v52 = 0;
  if (__nwlog_fault(v20, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_output_available";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v52)
    {
      BOOL v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = type;
      BOOL v35 = os_log_type_enabled(v21, type);
      if (v33)
      {
        if (v35)
        {
          *(_DWORD *)int buf = 136446466;
          char v55 = "nw_framer_protocol_output_available";
          __int16 v56 = 2082;
          os_log_type_t v57 = v33;
          _os_log_impl( &dword_181A5C000,  v21,  v34,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v33);
        goto LABEL_91;
      }

      if (v35)
      {
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_output_available";
        _os_log_impl(&dword_181A5C000, v21, v34, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v55 = "nw_framer_protocol_output_available";
        _os_log_impl( &dword_181A5C000,  v21,  v46,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D89270(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_framer_protocol_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = a1->handle;
    uint64_t v3 = (char *)v2;
    if (v2)
    {
      if (v2[1])
      {
        uint64_t v4 = v2[69];
        if (v4 && *(void *)(v4 + 16) != *(void *)(v4 + 24))
        {
          *((_BYTE *)v2 + 607) |= 0x40u;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v5 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v54 = "nw_framer_protocol_output_finished";
            __int16 v55 = 2080;
            __int16 v56 = v3 + 609;
            _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s %s Data pending in output_data_array, delaying output_finished",  buf,  0x16u);
          }

          goto LABEL_13;
        }

        uint64_t v6 = v2[40];
        if (v6)
        {
          uint64_t v7 = *(void *)(v6 + 24);
          if (v7)
          {
            uint64_t v8 = *(void (**)(void))(v7 + 192);
            if (v8)
            {
              v8();
LABEL_13:

              return;
            }
          }
        }

        __nwlog_obj();
        os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v10 = *((void *)v3 + 40);
        os_log_type_t v11 = "invalid";
        if (v10)
        {
          os_log_type_t v12 = *(const char **)(v10 + 16);
          if (v12) {
            os_log_type_t v11 = v12;
          }
        }

        *(_DWORD *)int buf = 136446466;
        os_log_type_t v54 = "nw_framer_protocol_output_finished";
        __int16 v55 = 2082;
        __int16 v56 = (char *)v11;
        os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v51 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            uint64_t v16 = *((void *)v3 + 40);
            os_log_type_t v17 = "invalid";
            if (v16)
            {
              os_log_type_t v18 = *(const char **)(v16 + 16);
              if (v18) {
                os_log_type_t v17 = v18;
              }
            }

            *(_DWORD *)int buf = 136446466;
            os_log_type_t v54 = "nw_framer_protocol_output_finished";
            __int16 v55 = 2082;
            __int16 v56 = (char *)v17;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s protocol %{public}s has invalid output_finished callback",  buf,  0x16u);
          }
        }

        else if (v51)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v28 = type;
          BOOL v29 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v29)
            {
              uint64_t v30 = *((void *)v3 + 40);
              __int16 v31 = "invalid";
              if (v30)
              {
                uint64_t v32 = *(const char **)(v30 + 16);
                if (v32) {
                  __int16 v31 = v32;
                }
              }

              *(_DWORD *)int buf = 136446722;
              os_log_type_t v54 = "nw_framer_protocol_output_finished";
              __int16 v55 = 2082;
              __int16 v56 = (char *)v31;
              __int16 v57 = 2082;
              __int16 v58 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s protocol %{public}s has invalid output_finished callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
LABEL_97:
            if (!v13) {
              goto LABEL_13;
            }
LABEL_98:
            free(v13);
            goto LABEL_13;
          }

          if (v29)
          {
            uint64_t v45 = *((void *)v3 + 40);
            os_log_type_t v46 = "invalid";
            if (v45)
            {
              os_log_type_t v47 = *(const char **)(v45 + 16);
              if (v47) {
                os_log_type_t v46 = v47;
              }
            }

            *(_DWORD *)int buf = 136446466;
            os_log_type_t v54 = "nw_framer_protocol_output_finished";
            __int16 v55 = 2082;
            __int16 v56 = (char *)v46;
            _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s protocol %{public}s has invalid output_finished callback, no backtrace",  buf,  0x16u);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v41 = type;
          if (os_log_type_enabled(v14, type))
          {
            uint64_t v42 = *((void *)v3 + 40);
            uint64_t v43 = "invalid";
            if (v42)
            {
              char v44 = *(const char **)(v42 + 16);
              if (v44) {
                uint64_t v43 = v44;
              }
            }

            *(_DWORD *)int buf = 136446466;
            os_log_type_t v54 = "nw_framer_protocol_output_finished";
            __int16 v55 = 2082;
            __int16 v56 = (char *)v43;
            _os_log_impl( &dword_181A5C000,  v14,  v41,  "%{public}s protocol %{public}s has invalid output_finished callback, backtrace limit exceeded",  buf,  0x16u);
          }
        }

void sub_181D89C98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_framer_protocol_copy_info(uint64_t a1, int a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(id *)(a1 + 40);
    id v5 = v4;
    if (v4)
    {
      if (v4[1])
      {
        if (a2 == 254)
        {
          if (v4[56] && v4[57])
          {
            uint64_t v11 = *(void *)(a1 + 32);
            if (!v11
              || (uint64_t v12 = *(void *)(v11 + 24)) == 0
              || (os_log_type_t v13 = *(uint64_t (**)(void))(v12 + 224)) == 0LL
              || (uint64_t v9 = v13()) == 0)
            {
              uint64_t v9 = nw_array_create();
            }

            uint64_t v14 = nw_protocol_establishment_report_create( *((void **)v5 + 1),  *((void *)v5 + 56),  *((void *)v5 + 57));
            goto LABEL_28;
          }
        }

        else if (a2 == 255)
        {
          if ((v4[76] & 0x10) == 0)
          {
            uint64_t v6 = *(void *)(a1 + 32);
            if (v6)
            {
              uint64_t v7 = *(void *)(v6 + 24);
              if (v7)
              {
                uint64_t v8 = *(uint64_t (**)(void))(v7 + 224);
                if (v8)
                {
                  uint64_t v9 = v8();
                  uint64_t v10 = *((void *)v5 + 55);
                  if (!v10) {
                    goto LABEL_30;
                  }
                  goto LABEL_25;
                }
              }
            }
          }

          uint64_t v9 = 0LL;
          uint64_t v10 = *((void *)v5 + 55);
          if (v10)
          {
LABEL_25:
            (*(void (**)(uint64_t, id))(v10 + 16))(v10, v5);
            uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
            if (!v14)
            {
LABEL_29:

              goto LABEL_30;
            }

            if (!v9) {
              uint64_t v9 = nw_array_create();
            }
LABEL_28:
            nw_array_append(v9, v14);
            goto LABEL_29;
          }

void sub_181D8A474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_framer_protocol_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = a1->handle;
    uint64_t v3 = (char *)v2;
    if (v2)
    {
      if (v2[1])
      {
        uint64_t default_input_handler = a1->default_input_handler;
        if (default_input_handler
          && (callbacks = default_input_handler->callbacks) != 0LL
          && (get_remote_endpoint = (void (*)(void))callbacks->get_remote_endpoint) != 0LL)
        {
          get_remote_endpoint();
          uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          uint64_t v7 = 0LL;
        }

        if (gLogDatapath)
        {
          __nwlog_obj();
          BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446722;
            BOOL v34 = "nw_framer_protocol_get_remote_endpoint";
            __int16 v35 = 2080;
            BOOL v36 = v3 + 609;
            __int16 v37 = 2112;
            os_log_type_t v38 = v7;
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %s returning remote endpoint: %@",  buf,  0x20u);
          }
        }

void sub_181D8AC04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_framer_protocol_get_parameters(nw_protocol *a1)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v1 = a1->handle;
    int v2 = v1;
    if (v1)
    {
      if (v1[1])
      {
        nw_context_assert_queue(v1[46]);
        uint64_t v3 = v2[42];
        if (v3 && (uint64_t v4 = v3[3]) != 0 && (v5 = *(void (**)(void))(v4 + 112)) != 0LL)
        {
          v5();
          id v6 = (id)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          id v6 = v2[45];
        }

        uint64_t v7 = v6;
LABEL_9:

        return v7;
      }

      __nwlog_obj();
      os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v33 = "nw_framer_protocol_get_parameters";
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v30 = 0;
      if (__nwlog_fault(v14, &type, &v30))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)int buf = 136446210;
            os_log_type_t v33 = "nw_framer_protocol_get_parameters";
            _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null framer->parent_definition", buf, 0xCu);
          }

void sub_181D8B2FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_framer_protocol_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = v3 + 4;
  uint64_t v5 = v3[4];
  id v6 = (void *)v3[5];
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    id v6 = (void *)v3[5];
  }

  else
  {
    *(void *)(*(void *)(a1 + 40) + 8LL) = v6;
  }

  *id v6 = v5;
  *uint64_t v4 = 0LL;
  v3[5] = 0LL;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void **)(v7 + 576);
  v3[5] = v8;
  *uint64_t v8 = v3;
  *(void *)(v7 + 576) = v4;

  return 1LL;
}

uint64_t ___ZL41nw_framer_protocol_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_2( uint64_t a1, void *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a2;
  uint64_t v4 = nw_frame_copy_metadata_for_protocol((uint64_t)v3, *(void *)(*(void *)(a1 + 32) + 8LL));
  int is_metadata_complete = nw_frame_is_metadata_complete((uint64_t)v3);
  int v6 = nw_frame_unclaimed_length(v3);
  *(_BYTE *)(*(void *)(a1 + 32) + 607LL) = *(_BYTE *)(*(void *)(a1 + 32) + 607LL) & 0xDF | (v3[186] >> 2) & 0x20;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void **)(v7 + 584);
  if (v8) {
    BOOL v9 = v4 == v8;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = *(void *)(a1 + 32);
        BOOL v19 = (const char *)(v18 + 609);
        os_log_type_t v20 = "";
        int v21 = *(_DWORD *)(v18 + 596);
        if (!v18) {
          BOOL v19 = "";
        }
        int v22 = *(_DWORD *)(v18 + 592);
        __int16 v34 = "nw_framer_protocol_finalize_output_frames_block_invoke_2";
        int v33 = 136447234;
        if (v21 != 1) {
          os_log_type_t v20 = "s";
        }
        __int16 v35 = 2080;
        uint64_t v36 = v19;
        __int16 v37 = 1024;
        int v38 = v21;
        __int16 v39 = 2080;
        char v40 = v20;
        __int16 v41 = 1024;
        int v42 = v22;
        _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Asking to write %u outbound frame%s with %u bytes",  (uint8_t *)&v33,  0x2Cu);
      }

      uint64_t v7 = *(void *)(a1 + 32);
    }

    (*(void (**)(void, uint64_t))(*(void *)(v7 + 408) + 16LL))(*(void *)(v7 + 408), v7);
    uint64_t v10 = a1 + 32;
    *(_DWORD *)(*(void *)(a1 + 32) + 600LL) = 0;
    uint64_t v11 = *(void *)(a1 + 32);
    os_log_type_t v12 = *(void **)(v11 + 584);
    *(void *)(v11 + 584) = 0LL;

    *(_DWORD *)(*(void *)v10 + 592LL) = 0;
    *(_BYTE *)(*(void *)v10 + 607LL) &= ~0x10u;
    *(_DWORD *)(*(void *)v10 + 596LL) = 0;
    uint64_t v7 = *(void *)(a1 + 32);
  }

  objc_storeStrong((id *)(v7 + 584), v4);
  *(_DWORD *)(*(void *)(a1 + 32) + 592LL) += v6;
  if (is_metadata_complete) {
    char v13 = 16;
  }
  else {
    char v13 = 0;
  }
  *(_BYTE *)(*(void *)(a1 + 32) + 607LL) = *(_BYTE *)(*(void *)(a1 + 32) + 607LL) & 0xEF | v13;
  ++*(_DWORD *)(*(void *)(a1 + 32) + 596LL);
  uint64_t v14 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v14 + 607) & 0x10) != 0)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v24 = *(void *)(a1 + 32);
        os_log_type_t v25 = (const char *)(v24 + 609);
        BOOL v26 = "";
        int v27 = *(_DWORD *)(v24 + 596);
        if (!v24) {
          os_log_type_t v25 = "";
        }
        int v28 = *(_DWORD *)(v24 + 592);
        __int16 v34 = "nw_framer_protocol_finalize_output_frames_block_invoke";
        int v33 = 136447234;
        if (v27 != 1) {
          BOOL v26 = "s";
        }
        __int16 v35 = 2080;
        uint64_t v36 = v25;
        __int16 v37 = 1024;
        int v38 = v27;
        __int16 v39 = 2080;
        char v40 = v26;
        __int16 v41 = 1024;
        int v42 = v28;
        _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Asking to write complete %u outbound frame%s with %u bytes",  (uint8_t *)&v33,  0x2Cu);
      }

      uint64_t v14 = *(void *)(a1 + 32);
      uint64_t v15 = *(void *)(v14 + 552);
      if (v15) {
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v15 = *(void *)(v14 + 552);
      if (v15)
      {
LABEL_13:
        BOOL v16 = *(void *)(v15 + 16) != *(void *)(v15 + 24);
        goto LABEL_29;
      }
    }

    BOOL v16 = 0;
LABEL_29:
    (*(void (**)(void, uint64_t))(*(void *)(v14 + 408) + 16LL))(*(void *)(v14 + 408), v14);
    if (!v16
      && (*(_BYTE *)(*(void *)(a1 + 32) + 606LL) & 2) != 0
      && (*((_DWORD *)v3 + 44)
       || nw_frame_get_ecn_flag((uint64_t)v3)
       || nw_frame_get_expire_time((uint64_t)v3)
       || nw_frame_get_packet_id((uint64_t)v3)))
    {
      nw_framer_flush_output(*(void **)(a1 + 32), v3);
    }

    uint64_t v30 = *(void *)(a1 + 32);
    uint64_t v29 = a1 + 32;
    *(_DWORD *)(v30 + 600) = 0;
    char v31 = *(void **)(*(void *)v29 + 584LL);
    *(void *)(*(void *)v29 + 584LL) = 0LL;

    *(_DWORD *)(*(void *)v29 + 592LL) = 0;
    *(_BYTE *)(*(void *)v29 + 607LL) &= ~0x10u;
    *(_DWORD *)(*(void *)v29 + 596LL) = 0;
  }

  return 1LL;
}

void sub_181D8B73C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_framer_protocol_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_136( uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)v3 + 4);
  int v6 = (void *)*((void *)v3 + 5);
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    int v6 = (void *)*((void *)v3 + 5);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 576LL) = v6;
  }

  *int v6 = v5;
  *((void *)v3 + 4) = 0LL;
  *((void *)v3 + 5) = 0LL;
  nw_frame_finalize((uint64_t)v3);
  if (gLogDatapath)
  {
    __nwlog_obj();
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      if (v9) {
        uint64_t v10 = (const char *)(v9 + 609);
      }
      else {
        uint64_t v10 = "";
      }
      int v11 = 136446466;
      os_log_type_t v12 = "nw_framer_protocol_finalize_output_frames_block_invoke";
      __int16 v13 = 2080;
      uint64_t v14 = v10;
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Dropping unused output frame",  (uint8_t *)&v11,  0x16u);
    }
  }

  return 1LL;
}

void nw_framer_protocol_outbound_data_finalizer(void *a1, int a2, char *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  if (a2)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = "";
        if (a3) {
          uint64_t v7 = a3 + 609;
        }
        int v10 = 136446466;
        int v11 = "nw_framer_protocol_outbound_data_finalizer";
        __int16 v12 = 2080;
        __int16 v13 = v7;
        uint64_t v8 = "%{public}s %s Finalizing outbound frame (success)";
LABEL_13:
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, v8, (uint8_t *)&v10, 0x16u);
        goto LABEL_14;
      }

      goto LABEL_14;
    }
  }

  else if (gLogDatapath)
  {
    __nwlog_obj();
    int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = "";
      if (a3) {
        uint64_t v9 = a3 + 609;
      }
      int v10 = 136446466;
      int v11 = "nw_framer_protocol_outbound_data_finalizer";
      __int16 v12 = 2080;
      __int16 v13 = v9;
      uint64_t v8 = "%{public}s %s Finalizing outbound frame (drop)";
      goto LABEL_13;
    }

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_5194( uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)v3 + 4);
  int v6 = (void *)*((void *)v3 + 5);
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    int v6 = (void *)*((void *)v3 + 5);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v6;
  }

  *int v6 = v5;
  *((void *)v3 + 4) = 0LL;
  *((void *)v3 + 5) = 0LL;
  nw_frame_finalize((uint64_t)v3);

  return 1LL;
}

uint64_t __nw_framer_trigger_input_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  uint64_t frame = nw_framer_protocol_create_frame( *(void **)(a1 + 32),  a5,  (uint64_t)nw_framer_protocol_inbound_data_finalizer,  *(void *)(a1 + 32) + 464LL,  0);
  buffer = (void *)nw_frame_get_buffer(frame, 0LL);
  memcpy(buffer, a4, a5);
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(frame + 32) = 0LL;
  int v11 = *(uint64_t **)(v10 + 520);
  *(void *)(frame + 40) = v11;
  uint64_t *v11 = frame;
  *(void *)(v10 + 520) = frame + 32;

  return 1LL;
}

void __nw_framer_trigger_input_block_invoke_2(uint64_t a1)
{
}

nw_protocol_options_t nw_framer_create_options(nw_protocol_definition_t framer_definition)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v1 = framer_definition;
  int v2 = v1;
  if (v1)
  {
    id v3 = v1;
    char v4 = *((_BYTE *)v3 + 184);

    if ((v4 & 1) != 0)
    {
      options = nw_protocol_create_options(v3);
      goto LABEL_4;
    }

    __nwlog_obj();
    int v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_framer_create_options";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v23 = "nw_framer_create_options";
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null nw_protocol_definition_is_framer(definition)",  buf,  0xCu);
        }

void sub_181D8BFA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_options_is_framer(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    id v3 = (id *)v1;
    id v4 = v3[1];

    uint64_t is_framer = nw_protocol_definition_is_framer(v4);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v18 = "nw_protocol_options_is_framer";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v18 = "nw_protocol_options_is_framer";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v18 = "nw_protocol_options_is_framer";
          __int16 v19 = 2082;
          char v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v18 = "nw_protocol_options_is_framer";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v18 = "nw_protocol_options_is_framer";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_framer_options_set_object_value(nw_protocol_options_t options, const char *key, id value)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t v5 = options;
  id v6 = value;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v32 = "nw_framer_options_set_object_value";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v30 = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v30;
      if (os_log_type_enabled(v9, v30))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = v30;
      BOOL v17 = os_log_type_enabled(v9, v30);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v32 = "nw_framer_options_set_object_value";
          __int16 v33 = 2082;
          __int16 v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = v30;
      if (os_log_type_enabled(v9, v30))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D8C974( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_has_standard_framer_options(void *a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    id v3 = v1[1];
    goto LABEL_3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v8 = (id)gLogObj;
  *(_DWORD *)int buf = 136446210;
  id v27 = "nw_protocol_options_copy_definition";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v9, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_options_copy_definition";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          id v27 = "nw_protocol_options_copy_definition";
          __int16 v28 = 2082;
          char v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_options_copy_definition";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_options_copy_definition";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_framer_options_set_object_value_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (!*a2)
  {
    uint64_t v5 = nw_dictionary_create();
    BOOL v6 = (void *)*a2;
    *a2 = (uint64_t)v5;

    uint64_t v3 = *a2;
  }

  nw_dictionary_set_value(v3, *(const char **)(a1 + 40), *(void **)(a1 + 32));
  return 1LL;
}

id nw_framer_options_copy_object_value(nw_protocol_options_t options, const char *key)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v3 = options;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v17)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!nw_protocol_options_has_standard_framer_options(v3))
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options)",  buf,  0xCu);
      }
    }

    else if (v27)
    {
      BOOL v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v9, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v18;
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v18);
LABEL_55:
        if (!v8)
        {
LABEL_57:
          id v5 = 0LL;
          goto LABEL_5;
        }

void sub_181D8D6E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, id a26)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_framer_options_copy_object_value_block_invoke(uint64_t a1, uint64_t *a2)
{
  if (*a2)
  {
    uint64_t v3 = nw_dictionary_copy_value(*a2, *(void *)(a1 + 40));
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
    id v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;
  }

  return 1LL;
}

void nw_framer_options_set_peer_protocol_definition(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    char v29 = "nw_framer_options_set_peer_protocol_definition";
    BOOL v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          char v29 = "nw_framer_options_set_peer_protocol_definition";
          __int16 v30 = 2082;
          char v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v6) {
          goto LABEL_5;
        }
LABEL_56:
        free(v6);
        goto LABEL_5;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        char v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl(&dword_181A5C000, v7, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v21,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D8DE5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_framer_options_set_peer_protocol_definition_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

id nw_framer_options_copy_peer_protocol_definition(void *a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v8) {
          goto LABEL_40;
        }
        goto LABEL_39;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_37;
  }

  id v3 = (id *)v1;
  id v4 = v3[1];

  char is_framer = nw_protocol_definition_is_framer(v4);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null nw_protocol_options_is_framer(options)",  buf,  0xCu);
      }
    }

    else if (v23)
    {
      os_log_type_t v16 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v9, type);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v16;
          _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null nw_protocol_options_is_framer(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v16);
LABEL_38:
        if (!v8) {
          goto LABEL_40;
        }
LABEL_39:
        free(v8);
        goto LABEL_40;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null nw_protocol_options_is_framer(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null nw_protocol_options_is_framer(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D8E408( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id a24)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_framer_options_copy_peer_protocol_definition_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

nw_framer_message_t nw_framer_message_create(nw_framer_t framer)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (framer) {
    return nw_framer_protocol_create_message(*((nw_protocol_definition_t *)framer + 1));
  }
  __nwlog_obj();
  int v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v13 = "nw_framer_message_create";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v13 = "nw_framer_message_create";
        _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v13 = "nw_framer_message_create";
          __int16 v14 = 2082;
          BOOL v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v13 = "nw_framer_message_create";
        _os_log_impl(&dword_181A5C000, v4, v7, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v13 = "nw_framer_message_create";
        _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_framer_message_copy_original_message(void *a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null reply", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (!v25)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
        _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null reply, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null reply, no backtrace", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (v19)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null reply, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_32;
  }

  id v3 = v1;
  id v4 = *((id *)v3 + 1);

  char is_framer = nw_protocol_definition_is_framer(v4);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_original_message";
        _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null nw_protocol_metadata_is_framer_message(reply)",  buf,  0xCu);
      }

uint64_t __nw_framer_message_copy_original_message_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

void nw_framer_message_set_value( nw_framer_message_t message, const char *key, void *value, nw_framer_message_dispose_value_t dispose_value)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  os_log_type_t v7 = message;
  nw_framer_message_dispose_value_t v8 = dispose_value;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v37 = "nw_framer_message_set_value";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v37 = "nw_framer_message_set_value";
        _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null message", buf, 0xCu);
      }
    }

    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v37 = "nw_framer_message_set_value";
          __int16 v38 = 2082;
          __int16 v39 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v15) {
          goto LABEL_7;
        }
LABEL_58:
        free(v15);
        goto LABEL_7;
      }

      if (v24)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v37 = "nw_framer_message_set_value";
        _os_log_impl(&dword_181A5C000, v16, v23, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v37 = "nw_framer_message_set_value";
        _os_log_impl( &dword_181A5C000,  v16,  v30,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181D8F420(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_framer_message_set_value_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    if (*(void *)(a2 + 8)) {
      goto LABEL_3;
    }
  }

  else
  {
    xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
    uint64_t v13 = *(void **)a2;
    *(void *)a2 = v12;

    if (*(void *)(a2 + 8)) {
      goto LABEL_3;
    }
  }

  os_log_type_t v14 = nw_dictionary_create();
  BOOL v15 = *(void **)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v14;

LABEL_3:
  uint64_t pointer = xpc_dictionary_get_pointer();
  if (pointer)
  {
    uint64_t v5 = pointer;
    uint64_t v6 = nw_dictionary_copy_value(*(void *)(a2 + 8), *(void *)(a1 + 40));
    os_log_type_t v7 = v6;
    if (v6) {
      (*((void (**)(void *, uint64_t))v6 + 2))(v6, v5);
    }
  }

  uint64_t v8 = *(void *)(a2 + 8);
  id v9 = *(const char **)(a1 + 40);
  id v10 = _Block_copy(*(const void **)(a1 + 32));
  nw_dictionary_set_value(v8, v9, v10);

  xpc_dictionary_set_pointer();
  return 1LL;
}

void sub_181D8F528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_framer_message_access_value(nw_framer_message_t message, const char *key, void *access_value)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  uint64_t v5 = message;
  uint64_t v6 = access_value;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v41 = "nw_framer_message_access_value";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v39 = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (v39 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = v39;
      if (os_log_type_enabled(v16, v39))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v41 = "nw_framer_message_access_value";
        _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null message", buf, 0xCu);
      }

      goto LABEL_76;
    }

    if (!v38)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = v39;
      if (os_log_type_enabled(v16, v39))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v41 = "nw_framer_message_access_value";
        _os_log_impl( &dword_181A5C000,  v16,  v33,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_76;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = v39;
    BOOL v26 = os_log_type_enabled(v16, v39);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v41 = "nw_framer_message_access_value";
        _os_log_impl(&dword_181A5C000, v16, v25, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }

      goto LABEL_76;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v41 = "nw_framer_message_access_value";
      __int16 v42 = 2082;
      uint64_t v43 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v16,  v25,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181D8FE78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_framer_message_access_value_block_invoke(uint64_t a1, void *a2)
{
  if (*a2)
  {
    xpc_dictionary_get_pointer();
    id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
  }

  else
  {
    id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
  }

  return v3();
}

void nw_framer_message_set_object_value(nw_framer_message_t message, const char *key, id value)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v5 = message;
  id v6 = value;
  if (!v5)
  {
    __nwlog_obj();
    char v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v35 = "nw_framer_message_set_object_value";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v33 = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (v33 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v33;
      if (os_log_type_enabled(v14, v33))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v35 = "nw_framer_message_set_object_value";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null message", buf, 0xCu);
      }
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v33;
      BOOL v22 = os_log_type_enabled(v14, v33);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v35 = "nw_framer_message_set_object_value";
          __int16 v36 = 2082;
          __int16 v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v13) {
          goto LABEL_7;
        }
LABEL_58:
        free(v13);
        goto LABEL_7;
      }

      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v35 = "nw_framer_message_set_object_value";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = v33;
      if (os_log_type_enabled(v14, v33))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v35 = "nw_framer_message_set_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_framer_message_set_object_value_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (!v3)
  {
    uint64_t v5 = nw_dictionary_create();
    id v6 = *(void **)(a2 + 16);
    *(void *)(a2 + 16) = v5;

    uint64_t v3 = *(void *)(a2 + 16);
  }

  nw_dictionary_set_value(v3, *(const char **)(a1 + 40), *(void **)(a1 + 32));
  return 1LL;
}

id nw_framer_message_copy_object_value(nw_framer_message_t message, const char *key)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = message;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null message", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v27,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
    }

uint64_t __nw_framer_message_copy_object_value_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3)
  {
    id v4 = nw_dictionary_copy_value(v3, *(void *)(a1 + 40));
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
    id v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }

  return 1LL;
}

BOOL NWPBEndpointReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  uint64_t v4 = (int)*MEMORY[0x189611CF0];
  unint64_t v5 = *(void *)(a2 + v4);
  id v6 = (int *)MEMORY[0x189611CE8];
  unint64_t v7 = *(void *)(a2 + (int)*MEMORY[0x189611CE8]);
  uint64_t v8 = (int *)MEMORY[0x189611CE0];
  if (v5 < v7)
  {
    id v10 = (int *)MEMORY[0x189611CD8];
    while (1)
    {
      uint64_t v11 = (_BYTE *)(a2 + *v8);
      if (*v11) {
        return *(_BYTE *)(a2 + *v8) == 0;
      }
      if (v5 >= v7) {
        break;
      }
      char v12 = *(_BYTE *)(*(void *)(a2 + *v10) + v5);
      *(void *)(a2 + (int)v4) = v5 + 1;
      unint64_t v13 = v12 & 0x7F;
      if ((v12 & 0x80) == 0) {
        goto LABEL_37;
      }
      uint64_t v14 = *v3;
      unint64_t v15 = *(void *)(a2 + v14);
      if (v15 == -1LL || v15 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v16 = v15 + 1;
      int v17 = *(char *)(*(void *)(a2 + *v10) + v15);
      *(void *)(a2 + v14) = v16;
      v13 |= (unint64_t)(v17 & 0x7F) << 7;
      if ((v17 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v18 = *v3;
      unint64_t v19 = *(void *)(a2 + v18);
      if (v19 == -1LL || v19 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v20 = v19 + 1;
      int v21 = *(char *)(*(void *)(a2 + *v10) + v19);
      *(void *)(a2 + v1_Block_object_dispose(va, 8) = v20;
      v13 |= (unint64_t)(v21 & 0x7F) << 14;
      if ((v21 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v22 = *v3;
      unint64_t v23 = *(void *)(a2 + v22);
      if (v23 == -1LL || v23 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v24 = v23 + 1;
      int v25 = *(char *)(*(void *)(a2 + *v10) + v23);
      *(void *)(a2 + v22) = v24;
      v13 |= (unint64_t)(v25 & 0x7F) << 21;
      if ((v25 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v26 = *v3;
      unint64_t v27 = *(void *)(a2 + v26);
      if (v27 == -1LL || v27 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v28 = v27 + 1;
      int v29 = *(char *)(*(void *)(a2 + *v10) + v27);
      *(void *)(a2 + v26) = v28;
      v13 |= (unint64_t)(v29 & 0x7F) << 28;
      if ((v29 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v30 = *v3;
      unint64_t v31 = *(void *)(a2 + v30);
      if (v31 == -1LL || v31 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v32 = v31 + 1;
      int v33 = *(char *)(*(void *)(a2 + *v10) + v31);
      *(void *)(a2 + v30) = v32;
      if ((v33 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v34 = *v3;
      unint64_t v35 = *(void *)(a2 + v34);
      if (v35 == -1LL || v35 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v36 = v35 + 1;
      int v37 = *(char *)(*(void *)(a2 + *v10) + v35);
      *(void *)(a2 + v34) = v36;
      if ((v37 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v38 = *v3;
      unint64_t v39 = *(void *)(a2 + v38);
      if (v39 == -1LL || v39 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v40 = v39 + 1;
      int v41 = *(char *)(*(void *)(a2 + *v10) + v39);
      *(void *)(a2 + v3_Block_object_dispose(va, 8) = v40;
      if ((v41 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v42 = *v3;
      unint64_t v43 = *(void *)(a2 + v42);
      if (v43 == -1LL || v43 >= *(void *)(a2 + *v6)) {
        goto LABEL_35;
      }
      unint64_t v44 = v43 + 1;
      int v45 = *(char *)(*(void *)(a2 + *v10) + v43);
      *(void *)(a2 + v42) = v44;
      if ((v45 & 0x80000000) == 0) {
        goto LABEL_37;
      }
      uint64_t v46 = *v3;
      unint64_t v47 = *(void *)(a2 + v46);
      if (v47 == -1LL || v47 >= *(void *)(a2 + *v6))
      {
LABEL_35:
        uint64_t v11 = (_BYTE *)(a2 + *v8);
        goto LABEL_36;
      }

      unint64_t v48 = v47 + 1;
      int v49 = *(char *)(*(void *)(a2 + *v10) + v47);
      *(void *)(a2 + v46) = v48;
      if (v49 < 0)
      {
        unint64_t v13 = 0LL;
        int v50 = *(unsigned __int8 *)(a2 + *v8);
        goto LABEL_39;
      }

void sub_181D91908(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5627(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__5628(uint64_t a1)
{
}

uint64_t nw_resolver_get_next_log_id(void)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  do
  {
    unsigned int v0 = __ldaxr(nw_resolver_get_next_log_id(void)::s_last_id);
    uint64_t result = v0 + 1;
  }

  while (__stlxr(result, nw_resolver_get_next_log_id(void)::s_last_id));
  if (v0 == -2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v2 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446466;
      uint64_t v4 = "nw_resolver_get_next_log_id";
      __int16 v5 = 1024;
      int v6 = -1;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s reached %u resolver logging ids, wrapping",  (uint8_t *)&v3,  0x12u);
    }

    return nw_resolver_get_next_log_id();
  }

  return result;
}

nw_endpoint_t *nw_resolver_create_with_endpoint(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    __int16 v5 = -[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_resolver),  v3,  v4,  0LL,  0LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v18 = "nw_resolver_create_with_endpoint";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_resolver_create_with_endpoint";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v18 = "nw_resolver_create_with_endpoint";
          __int16 v19 = 2082;
          unint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_resolver_create_with_endpoint";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_resolver_create_with_endpoint";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D91D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t *nw_resolver_create_with_path(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    int v2 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_resolver);
    id v3 = (id *)v1;
    id v4 = v3[3];

    BOOL v5 = nw_path_copy_derived_parameters(v3);
    int v6 = -[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:](v2, v4, (void *)v5, v3, 0LL);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  __int16 v19 = "nw_resolver_create_with_path";
  id v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v19 = "nw_resolver_create_with_path";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v19 = "nw_resolver_create_with_path";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v19 = "nw_resolver_create_with_path";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v19 = "nw_resolver_create_with_path";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D9209C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_create_srv_weighted_variant(void *a1)
{
  id v1 = a1;
  int v2 = v1;
  if (v1 && (uint64_t v3 = v1[3] - v1[2], (unint64_t)v3 > 0xF))
  {
    unint64_t v6 = v3 >> 3;
    uint64_t v4 = nw_array_create();
    unint64_t v7 = 0LL;
    unint64_t v29 = v6;
    do
    {
      unint64_t v8 = v7;
      nw_array_get_object_at_index((uint64_t)v2, v7);
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
      int priority = nw_endpoint_get_priority(v31);
      unsigned int weight = nw_endpoint_get_weight(v31);
      unint64_t v11 = v7 + 1;
      if (v7 + 1 >= v6)
      {
        unint64_t v13 = v7++;
      }

      else
      {
        while (1)
        {
          unint64_t v7 = v11;
          nw_array_get_object_at_index((uint64_t)v2, v11);
          os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();

          unint64_t v31 = v12;
          weight += nw_endpoint_get_weight(v12);
          unint64_t v11 = v7 + 1;
          if (v6 == v7 + 1)
          {
            unint64_t v13 = v7;
            unint64_t v7 = v6;
            goto LABEL_13;
          }
        }

        unint64_t v13 = v7 - 1;
      }

void sub_181D923A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_can_use_dns_xpc_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  nw_resolver_can_use_dns_xpc::can_use_dns_xpc = 1;
  if (!MEMORY[0x189615048])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v0 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v3 = "nw_resolver_can_use_dns_xpc_block_invoke";
      _os_log_impl(&dword_181A5C000, v0, OS_LOG_TYPE_ERROR, "%{public}s libdns_services is not available", buf, 0xCu);
    }
  }

  getpid();
  if (sandbox_check())
  {
    nw_resolver_can_use_dns_xpc::can_use_dns_xpc = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v1 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v3 = "nw_resolver_can_use_dns_xpc_block_invoke";
      _os_log_impl( &dword_181A5C000,  v1,  OS_LOG_TYPE_ERROR,  "%{public}s Sandbox does not allow access to com.apple.dnssd.service",  buf,  0xCu);
    }
  }

void ___ZL40nw_resolver_start_custom_resolver_lockedP22NWConcrete_nw_resolver_block_invoke( uint64_t a1, void *a2, int a3)
{
  object = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12LL));
  uint64_t v5 = *(void *)(a1 + 32);
  unint64_t v6 = *(void **)(v5 + 144);
  *(void *)(v5 + 144) = 0LL;

  if (object)
  {
    if (a3)
    {
      v11[0] = MEMORY[0x1895F87A8];
      v11[1] = 3221225472LL;
      v11[2] = ___ZL40nw_resolver_start_custom_resolver_lockedP22NWConcrete_nw_resolver_block_invoke_2;
      v11[3] = &unk_189BC85B0;
      id v12 = *(id *)(a1 + 32);
      nw_array_apply(object, (uint64_t)v11);
      unint64_t v7 = v12;
    }

    else
    {
      uint64_t v8 = *(void *)(a1 + 32);
      id v9 = object;
      unint64_t v7 = *(void **)(v8 + 144);
      *(void *)(v8 + 144) = v9;
    }
  }

  nw_resolver_update_status_locked(*(void **)(a1 + 32), 0LL);
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12LL));
}

void sub_181D92640( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
}

void __nw_resolver_set_update_handler_block_invoke_73(uint64_t a1, void *a2)
{
  id object = a2;
  if (nw_endpoint_get_type((nw_endpoint_t)object) == nw_endpoint_type_address)
  {
    int address_family = nw_endpoint_get_address_family(object);
    if (address_family == 30)
    {
      if (*(_BYTE *)(a1 + 64) != 30 && *(_BYTE *)(a1 + 64)) {
        goto LABEL_12;
      }
      uint64_t v4 = *(void *)(a1 + 56);
    }

    else
    {
      uint64_t v4 = *(void *)(a1 + 40);
    }

    *(_BYTE *)(*(void *)(v4 + 8) + 24LL) = 1;
    if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL))
    {
      BOOL v5 = nw_array_create();
      uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8LL);
      unint64_t v7 = *(void **)(v6 + 40);
      *(void *)(v6 + 40) = v5;
    }

    nw_endpoint_set_parent_endpoint(object, *(void **)(*(void *)(a1 + 32) + 24LL), 0);
    nw_array_append(*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), object);
  }

void sub_181D92730( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t nw_resolver_get_scoped_interface_index(NWConcrete_nw_resolver *a1, unsigned int *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    unint64_t v32 = "nw_resolver_get_scoped_interface_index";
    unint64_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v17, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint32_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)int buf = 136446210;
          unint64_t v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null resolver", buf, 0xCu);
        }

        goto LABEL_67;
      }

      if (!v29)
      {
        __nwlog_obj();
        uint32_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)int buf = 136446210;
          unint64_t v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl( &dword_181A5C000,  v18,  v27,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_67;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint32_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)int buf = 136446210;
          unint64_t v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_181A5C000, v18, v23, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }

        goto LABEL_67;
      }

      if (v24)
      {
        *(_DWORD *)int buf = 136446466;
        unint64_t v32 = "nw_resolver_get_scoped_interface_index";
        __int16 v33 = 2082;
        *(void *)uint64_t v34 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
      }

void nw_resolver_update_status_locked(void *a1, void *a2)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (*((_DWORD *)v3 + 21) || (v3[346] & 2) != 0) {
    goto LABEL_47;
  }
  if (nw_endpoint_get_type(*((nw_endpoint_t *)v3 + 3)) != nw_endpoint_type_host)
  {
    if (nw_endpoint_get_type(*((nw_endpoint_t *)v3 + 3)) == nw_endpoint_type_bonjour_service)
    {
      uint64_t v10 = *((void *)v3 + 18);
      if (v10
        && *(void *)(v10 + 24) != *(void *)(v10 + 16)
        && (nw_parameters_get_indefinite(*((void **)v3 + 2)) & 1) == 0
        && (*((_WORD *)v3 + 44) & 0x10) == 0)
      {
        *((_DWORD *)v3 + 2) = 1;
        nw_resolver_start_query_timer((NWConcrete_nw_resolver *)v3);
        goto LABEL_155;
      }

      goto LABEL_27;
    }

    if (nw_endpoint_get_type(*((nw_endpoint_t *)v3 + 3)) == 5)
    {
      if ((*((_WORD *)v3 + 44) & 0x10) != 0)
      {
LABEL_27:
        char v11 = 0;
        int v12 = 1;
LABEL_48:
        *((_DWORD *)v3 + 2) = v12;
        goto LABEL_49;
      }
    }

    else if (nw_endpoint_get_type(*((nw_endpoint_t *)v3 + 3)) == nw_endpoint_type_address {
           && nw_parameters_get_resolve_ptr(*((void **)v3 + 2))
    }
           && (*((_WORD *)v3 + 44) & 5) == 0)
    {
      goto LABEL_27;
    }

void sub_181D93B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_resolver_set_update_handler_block_invoke_76(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  uint64_t v6 = nw_array_get_object_at_index(*(void *)(*(void *)(a1 + 40) + 16LL), a2);
  if (v6 == MEMORY[0x1895F8AA8])
  {

LABEL_11:
    uint64_t v8 = *(_BYTE **)(a1 + 32);
    if (v8)
    {
      if ((v8[346] & 0x20) != 0)
      {
        unint64_t v7 = 0LL;
        goto LABEL_30;
      }

      if (v8[256])
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint32_t v9 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_INFO)) {
          goto LABEL_25;
        }
        uint64_t v14 = *(void *)(a1 + 32);
        int v21 = 136446722;
        uint64_t v22 = "nw_resolver_set_update_handler_block_invoke";
        __int16 v23 = 2082;
        *(void *)uint32_t v24 = v14 + 256;
        *(_WORD *)&v24[8] = 2082;
        *(void *)&v24[10] = nw_endpoint_get_logging_description(v5);
        uint64_t v15 = "%{public}s [C%{public}s] found cached alternative %{public}s";
        char v16 = v9;
        uint32_t v17 = 32;
        goto LABEL_24;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        int v18 = *(_DWORD *)(*(void *)(a1 + 32) + 340LL);
        int v21 = 136446722;
        uint64_t v22 = "nw_resolver_set_update_handler_block_invoke";
        __int16 v23 = 1024;
        *(_DWORD *)uint32_t v24 = v18;
        *(_WORD *)&void v24[4] = 2082;
        *(void *)&v24[6] = nw_endpoint_get_logging_description(v5);
        uint64_t v15 = "%{public}s [R%u] found cached alternative %{public}s";
        char v16 = v9;
        uint32_t v17 = 28;
        goto LABEL_24;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        int v21 = 136446466;
        uint64_t v22 = "nw_resolver_set_update_handler_block_invoke";
        __int16 v23 = 2082;
        *(void *)uint32_t v24 = nw_endpoint_get_logging_description(v5);
        uint64_t v15 = "%{public}s found cached alternative %{public}s";
        char v16 = v9;
        uint32_t v17 = 22;
LABEL_24:
        _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_INFO, v15, (uint8_t *)&v21, v17);
      }
    }

void sub_181D9403C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_resolver_set_update_handler_block_invoke_78(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (nw_endpoint_get_type((nw_endpoint_t)v4) == nw_endpoint_type_address)
  {
    int address_family = nw_endpoint_get_address_family(v4);
    if (address_family == 30)
    {
      uint64_t v6 = a1 + 40;
      goto LABEL_6;
    }

    if (address_family == 2)
    {
      uint64_t v6 = a1 + 32;
LABEL_6:
      *(_BYTE *)(*(void *)(*(void *)v6 + 8LL) + 24LL) = 1;
    }
  }

  return 1LL;
}

void sub_181D940FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_resolver_create_dns_getaddrinfo_locked( NWConcrete_nw_resolver *a1, NWConcrete_nw_resolver_service *a2)
{
  uint64_t v169 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  os_log_type_t v136 = v4;
  if (v3)
  {
    id v5 = v4;
    uint64_t v6 = (void *)dnssd_getaddrinfo_create();
    BOOL v134 = v6 != 0LL;
    if (v6)
    {
      if (v5)
      {
        unint64_t v7 = v5->service_host;
      }

      else
      {
        unint64_t v7 = (OS_nw_endpoint *)*((id *)v3 + 3);
      }

      endpoint = v7;
      unsigned int v153 = nw_resolver_derive_service_flags(v3, v7, *((void **)v3 + 2));
      nw_resolver_get_scoped_interface_index(v3, &v153);
      BOOL v8 = nw_context_copy_workloop(*((void **)v3 + 4));
      dnssd_getaddrinfo_set_queue();

      dnssd_getaddrinfo_set_flags();
      dnssd_getaddrinfo_set_interface_index();
      nw_endpoint_get_hostname(v7);
      dnssd_getaddrinfo_set_hostname();
      dnssd_getaddrinfo_set_protocols();
      uint32_t v9 = *((id *)v3 + 2);
      if (v9)
      {
        BOOL v10 = (v9[12] & 0x100000000LL) == 0;

        if (!v10) {
          dnssd_getaddrinfo_prohibit_encrypted_dns();
        }
        goto LABEL_11;
      }

      __nwlog_obj();
      uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
      os_log_type_t v117 = (char *)_os_log_send_and_compose_impl();

      v155[0] = 16;
      LOBYTE(v147) = 0;
      if (__nwlog_fault(v117, v155, &v147))
      {
        if (v155[0] == 17)
        {
          __nwlog_obj();
          size_t v118 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v119 = v155[0];
          if (os_log_type_enabled(v118, (os_log_type_t)v155[0]))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
            _os_log_impl(&dword_181A5C000, v118, v119, "%{public}s called with null parameters", buf, 0xCu);
          }
        }

        else
        {
          if ((_BYTE)v147)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v129 = v155[0];
            BOOL v130 = os_log_type_enabled(v128, (os_log_type_t)v155[0]);
            if (backtrace_string)
            {
              if (v130)
              {
                *(_DWORD *)int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v128,  v129,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
            }

            else
            {
              if (v130)
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
                _os_log_impl( &dword_181A5C000,  v128,  v129,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
              }
            }

            goto LABEL_234;
          }

          __nwlog_obj();
          size_t v118 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v133 = v155[0];
          if (os_log_type_enabled(v118, (os_log_type_t)v155[0]))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
            _os_log_impl( &dword_181A5C000,  v118,  v133,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

LABEL_229:
    if (v113) {
      free(v113);
    }
    goto LABEL_179;
  }

  __nwlog_obj();
  os_log_type_t v108 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
  BOOL v109 = (char *)_os_log_send_and_compose_impl();

  v155[0] = 16;
  LOBYTE(v147) = 0;
  if (__nwlog_fault(v109, v155, &v147))
  {
    if (v155[0] == 17)
    {
      __nwlog_obj();
      uint64_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v111 = v155[0];
      if (os_log_type_enabled(v110, (os_log_type_t)v155[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
        _os_log_impl(&dword_181A5C000, v110, v111, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if ((_BYTE)v147)
    {
      uint64_t v120 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v121 = v155[0];
      BOOL v122 = os_log_type_enabled(v110, (os_log_type_t)v155[0]);
      if (v120)
      {
        if (v122)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v120;
          _os_log_impl( &dword_181A5C000,  v110,  v121,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v120);
        goto LABEL_223;
      }

      if (v122)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
        _os_log_impl(&dword_181A5C000, v110, v121, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v131 = v155[0];
      if (os_log_type_enabled(v110, (os_log_type_t)v155[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
        _os_log_impl( &dword_181A5C000,  v110,  v131,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      v203 = 0;
      v204 = 0;
      goto LABEL_230;
    }

    v181 = v471;
    v182 = (*((_BYTE *)v471 + 268) & 0x20) == 0;

    uint32_t v9 = v474;
    if (v182)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v183 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v183, OS_LOG_TYPE_DEBUG))
      {
        v184 = nw_endpoint_handler_get_id_string(v181);
        v185 = nw_endpoint_handler_dry_run_string(v181);
        v186 = nw_endpoint_handler_copy_endpoint(v181);
        v187 = nw_endpoint_get_logging_description(v186);
        v188 = nw_endpoint_handler_state_string(v181);
        v189 = nw_endpoint_handler_mode_string(v181);
        v190 = nw_endpoint_handler_copy_current_path(v181);
        *(_DWORD *)int buf = 136447746;
        v481 = "nw_endpoint_proxy_receive_report";
        v482 = 2082;
        v483 = (uint64_t)v184;
        v484 = 2082;
        v485 = (uint64_t)v185;
        v486 = 2082;
        v487 = v187;
        v488 = 2082;
        v489 = v188;
        v490 = 2082;
        v491 = v189;
        v492 = 2114;
        v493 = v190;
        _os_log_impl( &dword_181A5C000,  v183,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Passing up other child report",  buf,  0x48u);
      }

      uint32_t v9 = v474;
    }

      free(v122);
      if (!v112)
      {
LABEL_427:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_available";
        uint64_t v116 = (char *)_os_log_send_and_compose_impl();
        v398[0] = 16;
        v394[0] = OS_LOG_TYPE_DEFAULT;
        if (v398[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v117 = (os_log_s *)gLogObj;
          size_t v118 = v398[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v398[0])) {
            goto LABEL_487;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_available";
          os_log_type_t v119 = "%{public}s called with null http1";
        }

        else if (v394[0])
        {
          v228 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v117 = (os_log_s *)gLogObj;
          size_t v118 = v398[0];
          v229 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v398[0]);
          if (v228)
          {
            if (v229)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_available";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v228;
              _os_log_impl( &dword_181A5C000,  v117,  v118,  "%{public}s called with null http1, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v228);
LABEL_487:
            if (!v116) {
              return;
            }
            goto LABEL_488;
          }

          if (!v229) {
            goto LABEL_487;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_available";
          os_log_type_t v119 = "%{public}s called with null http1, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v117 = (os_log_s *)gLogObj;
          size_t v118 = v398[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v398[0])) {
            goto LABEL_487;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_available";
          os_log_type_t v119 = "%{public}s called with null http1, backtrace limit exceeded";
        }

        goto LABEL_486;
      }

          if (v77) {
            free(v77);
          }
          goto LABEL_231;
        }

        if ((*v2 & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v17 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_handle_socket_event";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v1 + 308;
            _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Socket received CONNECTED event",  buf,  0x16u);
          }
        }

        int v18 = *(_WORD *)(v1 + 301);
        int v19 = v18 & 0x7FFF | (*(unsigned __int8 *)(v1 + 303) << 16);
        *int v2 = *v2 & 0x7FFB | 4;
        *(_BYTE *)(v1 + 303) = BYTE2(v19);
        uint64_t v98 = v18;
        if (_nw_signposts_once == -1)
        {
          if (!_nw_signposts_enabled) {
            goto LABEL_52;
          }
        }

        else
        {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
          if (!_nw_signposts_enabled) {
            goto LABEL_52;
          }
        }

            if (v103) {
              free(v103);
            }
            goto LABEL_62;
          }
        }

        else
        {
          if (v20 != 2) {
            goto LABEL_39;
          }
          if (setsockopt(*(_DWORD *)(v19 + 172), 0, 3, &v146, 4u) < 0)
          {
            int v21 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v22 = (os_log_s *)gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_39;
            }
            *(_DWORD *)applier = 136446466;
            *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
            *(_WORD *)&applier[12] = 1024;
            *(_DWORD *)&applier[14] = v21;
            __int16 v23 = "%{public}s setsockopt IP_TOS %{darwin.errno}d";
            goto LABEL_38;
          }
        }

        *(_BYTE *)(*(void *)(a1 + 40) + 300LL) = v18;
        goto LABEL_39;
      }

      if (!v108) {
        goto LABEL_213;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&void applier[4] = "__nw_frame_get_ecn_flag";
      int v30 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      BOOL v28 = (os_log_s *)__nwlog_obj();
      char v29 = v146;
      if (!os_log_type_enabled(v28, (os_log_type_t)v146)) {
        goto LABEL_213;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&void applier[4] = "__nw_frame_get_ecn_flag";
      int v30 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v28, v29, v30, applier, 0xCu);
    goto LABEL_213;
  }

  uint32_t v24 = __size[0];
  if (!__size[0])
  {
    os_log_type_t v127 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v127, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446210;
    *(void *)&void applier[4] = "strict_malloc";
    BOOL v128 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v128);
    if (result) {
      goto LABEL_256;
    }
    free(v128);
  }

  uint64_t v15 = malloc(v24);
  if (v15)
  {
    uint64_t v25 = *(void *)(a1 + 40);
    if (!v25) {
      goto LABEL_29;
    }
LABEL_28:
    if ((*(_WORD *)(v25 + 301) & 0x80) != 0)
    {
LABEL_30:
      *(void *)&__size[1] = v15;
      __int128 v146 = 0LL;
      __int128 v147 = &v146;
      __int128 v148 = 0x2000000000LL;
      nw_protocol_stack_t v149 = 0LL;
      *(void *)&v143 = 0LL;
      *((void *)&v143 + 1) = &v143;
      os_log_type_t v144 = 0x2000000000LL;
      __int128 v145 = v137;
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_from_offset_block_invoke;
      *(void *)&_BYTE applier[24] = &unk_189BBF5C0;
      *(void *)&applier[32] = &v143;
      *(void *)&applier[40] = &v146;
      *(void *)&applier[48] = __size[0];
      BOOL v142 = v15;
      dispatch_data_apply(v6, applier);
      uint32_t v26 = v147[3];
      _Block_object_dispose(&v143, 8);
      _Block_object_dispose(&v146, 8);
      uint64_t v140 = v26;
LABEL_31:
      buffer = 0LL;
      v138.msg_iov = (iovec *)&__size[1];
      v138.msg_iovlen = 1;
      if (a2) {
        goto LABEL_15;
      }
      goto LABEL_32;
    }

      if (v108) {
        free(v108);
      }
      goto LABEL_191;
    }

    id v33 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_override_info);
    if (!v33)
    {
      int v36 = 0LL;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v37 = (id)gLogObj;
      LODWORD(length[0]) = 136446210;
      *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
      v196 = length;
      uint64_t v38 = (void *)_os_log_send_and_compose_impl();

      LOBYTE(type) = 16;
      LOBYTE(v236) = 0;
      if (__nwlog_fault((const char *)v38, &type, &v236))
      {
        if (type == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v39 = (os_log_s *)(id)gLogObj;
          int v40 = type;
          if (os_log_type_enabled(v39, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed",  (uint8_t *)length,  0xCu);
          }
        }

        else if ((_BYTE)v236)
        {
          os_log_type_t v83 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v39 = (os_log_s *)(id)gLogObj;
          uint64_t v84 = type;
          os_log_type_t v85 = os_log_type_enabled(v39, (os_log_type_t)type);
          if (v83)
          {
            if (v85)
            {
              LODWORD(length[0]) = 136446466;
              *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
              WORD2(length[1]) = 2082;
              *(size_t *)((char *)&length[1] + 6) = (size_t)v83;
              _os_log_impl( &dword_181A5C000,  v39,  v84,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, dumping backtrace:%{public}s",  (uint8_t *)length,  0x16u);
            }

            free(v83);
            if (!v38) {
              goto LABEL_190;
            }
LABEL_177:
            free(v38);
            goto LABEL_190;
          }

          if (v85)
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            _os_log_impl( &dword_181A5C000,  v39,  v84,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, no backtrace",  (uint8_t *)length,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v39 = (os_log_s *)(id)gLogObj;
          os_log_type_t v92 = type;
          if (os_log_type_enabled(v39, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            _os_log_impl( &dword_181A5C000,  v39,  v92,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, backtrace limit exceeded",  (uint8_t *)length,  0xCu);
          }
        }
      }

      if (!v38) {
        goto LABEL_190;
      }
      goto LABEL_177;
    }

    if (v32 < 5)
    {
      uint64_t v34 = v33;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v35 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        LODWORD(length[0]) = 136446722;
        *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
        WORD2(length[1]) = 2048;
        *(size_t *)((char *)&length[1] + 6) = v32;
        HIWORD(length[2]) = 2048;
        length[3] = 5LL;
        _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s invalid length for override info %zu != %zu",  (uint8_t *)length,  0x20u);
      }

      int v36 = v34;
      goto LABEL_190;
    }

    v201 = v33;
    v207 = v32;
    int v41 = v32 - 5;
    if (v32 == 5)
    {
LABEL_139:
      int v80 = v201;
      override_flags = v201->override_flags;
      if ((override_flags & 1) != 0)
      {
        *((_BYTE *)v11 + 475) |= 0x40u;
        override_flags = v201->override_flags;
        if ((override_flags & 2) == 0)
        {
LABEL_141:
          if ((override_flags & 4) == 0) {
            goto LABEL_142;
          }
          goto LABEL_154;
        }
      }

      else if ((override_flags & 2) == 0)
      {
        goto LABEL_141;
      }

      *((_BYTE *)v11 + 475) |= 0x80u;
      override_flags = v201->override_flags;
      if ((override_flags & 4) == 0)
      {
LABEL_142:
        if ((override_flags & 0x10) == 0) {
          goto LABEL_143;
        }
        goto LABEL_155;
      }

      if (v123) {
        free(v123);
      }
LABEL_43:

LABEL_44:
      uint64_t v38 = nw_connection_copy_connected_path(*(void **)(a1 + 32));
      if (!v38) {
        goto LABEL_52;
      }
      unint64_t v39 = v21;
      int v40 = v38;
      int v41 = v39;
      int v42 = v21[1];

      if (nw_protocol_copy_http_connection_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_connection_definition_onceToken, &__block_literal_global_62);
      }
      unint64_t v43 = nw_protocol_definition_is_equal_unsafe((uint64_t)v42, nw_protocol_copy_http_connection_definition_definition);

      if (v43)
      {
        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = __nw_http_connection_metadata_set_path_block_invoke;
        *(void *)&_BYTE buf[24] = &unk_189BC6260;
        unint64_t v44 = v40;
        *(void *)&buf[32] = v44;
        if (v41[4])
        {
          (*(void (**)(_BYTE *))&buf[16])(buf);
          unint64_t v44 = *(id *)&buf[32];
        }

        goto LABEL_51;
      }

      __nwlog_obj();
      uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_path";
      LODWORD(v159) = 12;
      __int128 v158 = buf;
      os_log_type_t v111 = (char *)_os_log_send_and_compose_impl();

      __int128 v163 = OS_LOG_TYPE_ERROR;
      __int128 v162 = 0;
      if (v163 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v112 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v113 = v163;
        if (os_log_type_enabled(v112, v163))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_path";
          _os_log_impl(&dword_181A5C000, v112, v113, "%{public}s metadata must be http_connection", buf, 0xCu);
        }

LABEL_223:
  BOOL v106 = v136;
  if (v109) {
    free(v109);
  }
  BOOL v134 = 0;
LABEL_180:

  return v134;
}

      if (v83) {
        free(v83);
      }
      BOOL v8 = &handle[8].flow_id[15];
      id v5 = &qword_18C593000;
      goto LABEL_40;
    }
  }

            nw_http_transaction_metadata_increment_outbound_header_size( *(void **)(a1 + 392),  *((unsigned int *)v414 + 6));
            os_log_type_t v144 = *v6;
            __int128 v145 = (v144 | (*((unsigned __int8 *)v6 + 2) << 16)) & 0xFFFBFFFF;
            *uint64_t v6 = v144;
            *((_BYTE *)v6 + 2) = BYTE2(v145);
            _Block_object_dispose(&v413, 8);
            _Block_object_dispose(buf, 8);
LABEL_224:
            __int128 v146 = *(dispatch_data_s **)(a1 + 520);
            if (v146)
            {
              *(void *)os_log_type_t type = 0LL;
              *(void *)&os_log_type_t type[8] = type;
              *(void *)&type[16] = 0x3802000000LL;
              v418 = __Block_byref_object_copy__60284;
              v419 = __Block_byref_object_dispose__60285;
              v420[0] = 0LL;
              v420[1] = v420;
              v413 = 0LL;
              v414 = &v413;
              v415 = 0x2000000000LL;
              LODWORD(v416) = dispatch_data_get_size(v146);
              if (!nw_http3_framer_get_output_frames_for_single_http3_frame(a1 + 128, 1uLL, v416, v420))
              {
LABEL_289:
                _Block_object_dispose(&v413, 8);
                BOOL v11 = type;
                goto LABEL_290;
              }

              v374[0] = MEMORY[0x1895F87A8];
              v374[1] = 0x40000000LL;
              v375 = (uint64_t (*)(void *))___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_101;
              v376 = &unk_189BC4460;
              v378 = type;
              v379 = a1;
              v377 = &v413;
              __int128 v147 = *(void *)(*(void *)&type[8] + 40LL);
              do
              {
                if (!v147) {
                  break;
                }
                __int128 v148 = *(void *)(v147 + 32);
                nw_protocol_stack_t v149 = v375(v374);
                __int128 v147 = v148;
              }

              while ((v149 & 1) != 0);
              uint64_t v150 = v6;
              if (*(void *)(a1 + 520))
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                v151 = (char *)_os_log_send_and_compose_impl();
                v409[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v408[0]) = 0;
                if (v409[0] == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v152 = (os_log_s *)gLogObj;
                  unsigned int v153 = v409[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, v409[0])) {
                    goto LABEL_287;
                  }
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                  uint64_t v154 = "%{public}s Not enough space in fields frame";
                }

                else if (LOBYTE(v408[0]))
                {
                  v176 = (char *)__nw_create_backtrace_string();
                  v152 = (os_log_s *)__nwlog_obj();
                  unsigned int v153 = v409[0];
                  v177 = os_log_type_enabled(v152, v409[0]);
                  if (v176)
                  {
                    if (v177)
                    {
                      *(_DWORD *)int buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v176;
                      _os_log_impl( &dword_181A5C000,  v152,  v153,  "%{public}s Not enough space in fields frame, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v176);
                    goto LABEL_287;
                  }

                  if (!v177)
                  {
LABEL_287:
                    if (v151) {
                      free(v151);
                    }
                    goto LABEL_289;
                  }

                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                  uint64_t v154 = "%{public}s Not enough space in fields frame, no backtrace";
                }

                else
                {
                  v152 = (os_log_s *)__nwlog_obj();
                  unsigned int v153 = v409[0];
                  if (!os_log_type_enabled(v152, v409[0])) {
                    goto LABEL_287;
                  }
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                  uint64_t v154 = "%{public}s Not enough space in fields frame, backtrace limit exceeded";
                }

                _os_log_impl(&dword_181A5C000, v152, v153, v154, buf, 0xCu);
                goto LABEL_287;
              }

              __int16 v155 = *v6 | (*((unsigned __int8 *)v6 + 2) << 16);
              int v156 = *(void *)&type[8];
              if (a2 && (v155 & 0x14000) == 0)
              {
                __int128 v157 = **(void **)(*(void *)(*(void *)&type[8] + 48LL) + 8LL);
                *(_BYTE *)(v157 + 186) |= 0x80u;
                __int16 v155 = *v6 | (*((unsigned __int8 *)v6 + 2) << 16);
              }

              *uint64_t v6 = v155;
              *((_BYTE *)v6 + 2) = (v155 | 0x40000u) >> 16;
              __int128 v158 = *(void *)(a1 + 160);
              if (v158 && (__int128 v159 = *(void *)(v158 + 24)) != 0 && *(void *)(v159 + 96))
              {
                __int128 v160 = *((_DWORD *)v414 + 6);
                __int128 v161 = (uint64_t *)(v156 + 40);
                if (v160 >> 30) {
                  __int128 v162 = 8;
                }
                else {
                  __int128 v162 = 4;
                }
                if (v160 >= 0x4000) {
                  __int128 v163 = v162;
                }
                else {
                  __int128 v163 = 2;
                }
                if (v160 >= 0x40) {
                  __int128 v164 = v163;
                }
                else {
                  __int128 v164 = 1;
                }
                __int128 v165 = nw_http3_framer_write_http3_frame_header(a1 + 128, 1uLL, *((_DWORD *)v414 + 6), v164 + 1, *v161)
                     + v160;
                (*(void (**)(uint64_t, uint64_t *))(*(void *)(v158 + 24) + 96LL))(v158, v161);
              }

              else
              {
                __int128 v165 = 0;
              }

              nw_http_transaction_metadata_increment_outbound_header_size(*(void **)(a1 + 392), v165);
              __int128 v166 = *v6;
              __int128 v167 = (v166 | (*((unsigned __int8 *)v6 + 2) << 16)) & 0xFFFBFFFF;
              *uint64_t v6 = v166;
              *((_BYTE *)v6 + 2) = BYTE2(v167);
              if (a2)
              {
                nw_http_transaction_metadata_mark_outbound_message_end(*(void **)(a1 + 392));
                if (*(_BYTE *)(a1 + 280))
                {
                  if (*(void *)(a1 + 272) != *(void *)(a1 + 288))
                  {
                    if ((*v6 & 0x800) == 0)
                    {
                      v184 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v184, OS_LOG_TYPE_ERROR))
                      {
                        v185 = *(_DWORD *)(*(void *)(a1 + 336) + 1280LL);
                        v186 = *(void **)(a1 + 240);
                        if (*(_BYTE *)(a1 + 280)) {
                          v187 = *(void *)(a1 + 272);
                        }
                        else {
                          v187 = -1LL;
                        }
                        v188 = *(void *)(a1 + 288);
                        *(_DWORD *)int buf = 136447746;
                        *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = a1 + 636;
                        *(_WORD *)&buf[22] = 2080;
                        v427 = (__n128 (*)(uint64_t, uint64_t))" ";
                        LOWORD(v42_Block_object_dispose(va, 8) = 1024;
                        *(_DWORD *)((char *)&v428 + 2) = v185;
                        HIWORD(v42_Block_object_dispose(va, 8) = 2048;
                        v429 = v186;
                        *(_WORD *)v430 = 2048;
                        *(void *)&v430[2] = v187;
                        *(_WORD *)&v430[10] = 2048;
                        *(void *)&v430[12] = v188;
                        _os_log_impl( &dword_181A5C000,  v184,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%llu> Content length header %llu does not equal body size %llu",  buf,  0x44u);
                      }
                    }

                    *(void *)(a1 + 264) = 270LL;
                    nw_protocol_http3_stream_error((nw_protocol *)a1, (nw_protocol *)a1, 22);
                    nw_protocol_http3_stream_disconnect((nw_protocol *)a1, (nw_protocol *)a1);
                    goto LABEL_289;
                  }
                }
              }

              _Block_object_dispose(&v413, 8);
              _Block_object_dispose(type, 8);
              __int128 v168 = *v6 | (*((unsigned __int8 *)v6 + 2) << 16);
              if ((v168 & 0x10000) != 0)
              {
                nw_frame_reset(*(void *)(a1 + 384), 0LL, 0, 0LL, 0LL);
                v178 = *(void **)(a1 + 384);
                if (v178)
                {
                  os_release(v178);
                  *(void *)(a1 + 384) = 0LL;
                }

                *(void *)(a1 + 384) = nw_frame_create(0, 0LL, 0, 0LL, 0LL);
                *(_DWORD *)(a1 + 36_Block_object_dispose(va, 8) = 1;
              }

              else
              {
                if ((*v6 & 0x30) != 0) {
                  uint64_t v169 = 5;
                }
                else {
                  uint64_t v169 = 3;
                }
                *(_DWORD *)(a1 + 36_Block_object_dispose(va, 8) = v169;
                if ((v168 & 1) == 0)
                {
                  char v170 = *(void *)(a1 + 32);
                  if (v170)
                  {
                    uint64_t v171 = *(void *)(v170 + 24);
                    if (v171)
                    {
                      v172 = *(void (**)(uint64_t, uint64_t))(v171 + 160);
                      if (v172)
                      {
                        v172(v170, a1);
                        LOWORD(v16_Block_object_dispose(va, 8) = *v6;
                      }
                    }
                  }

                  if ((v168 & 0x10) != 0)
                  {
                    __int128 v173 = *(void *)(a1 + 32);
                    if (v173)
                    {
                      v174 = *(void *)(v173 + 24);
                      if (v174)
                      {
                        uint64_t v175 = *(void (**)(uint64_t, uint64_t))(v174 + 160);
                        if (v175) {
                          v175(v173, a1 + 64);
                        }
                      }
                    }
                  }
                }
              }

              if ((*v6 & 0x200) == 0) {
                return 1LL;
              }
              v179 = *(void *)(a1 + 32);
              if (v179)
              {
                v180 = *(void *)(v179 + 24);
                if (v180)
                {
                  v181 = *(void (**)(uint64_t, uint64_t))(v180 + 192);
                  if (v181)
                  {
                    v181(v179, a1);
LABEL_280:
                    v182 = *v150;
                    v183 = v182 & 0xFFFFFDFF | (*((unsigned __int8 *)v150 + 2) << 16);
                    NWConcrete_nw_resolver *v150 = v182 & 0xFDFF;
                    *((_BYTE *)v150 + 2) = BYTE2(v183);
                    return 1LL;
                  }
                }
              }

              __nwlog_obj();
              v242 = *(void *)(a1 + 32);
              v243 = "invalid";
              if (v242)
              {
                v244 = *(const char **)(v242 + 16);
                if (v244) {
                  v243 = v244;
                }
              }

              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v243;
              v245 = (char *)_os_log_send_and_compose_impl();
              type[0] = 16;
              LOBYTE(v413) = 0;
              if (__nwlog_fault(v245, type, &v413))
              {
                if (type[0] == 17)
                {
                  v246 = (os_log_s *)__nwlog_obj();
                  v247 = type[0];
                  if (os_log_type_enabled(v246, (os_log_type_t)type[0]))
                  {
                    v248 = *(void *)(a1 + 32);
                    v249 = "invalid";
                    if (v248)
                    {
                      v250 = *(const char **)(v248 + 16);
                      if (v250) {
                        v249 = v250;
                      }
                    }

                    *(_DWORD *)int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v249;
                    v251 = "%{public}s protocol %{public}s has invalid output_finished callback";
LABEL_529:
                    _os_log_impl(&dword_181A5C000, v246, v247, v251, buf, 0x16u);
                  }
                }

                else if ((_BYTE)v413)
                {
                  v289 = (char *)__nw_create_backtrace_string();
                  v246 = (os_log_s *)__nwlog_obj();
                  v247 = type[0];
                  v290 = os_log_type_enabled(v246, (os_log_type_t)type[0]);
                  if (v289)
                  {
                    if (v290)
                    {
                      v291 = *(void *)(a1 + 32);
                      v292 = "invalid";
                      if (v291)
                      {
                        v293 = *(const char **)(v291 + 16);
                        if (v293) {
                          v292 = v293;
                        }
                      }

                      *(_DWORD *)int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v292;
                      *(_WORD *)&buf[22] = 2082;
                      v427 = (__n128 (*)(uint64_t, uint64_t))v289;
                      _os_log_impl( &dword_181A5C000,  v246,  v247,  "%{public}s protocol %{public}s has invalid output_finished callback, dumping backtrace:%{public}s",  buf,  0x20u);
                    }

                    free(v289);
                    goto LABEL_530;
                  }

                  if (v290)
                  {
                    v327 = *(void *)(a1 + 32);
                    v328 = "invalid";
                    if (v327)
                    {
                      v329 = *(const char **)(v327 + 16);
                      if (v329) {
                        v328 = v329;
                      }
                    }

                    *(_DWORD *)int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v328;
                    v251 = "%{public}s protocol %{public}s has invalid output_finished callback, no backtrace";
                    goto LABEL_529;
                  }
                }

                else
                {
                  v246 = (os_log_s *)__nwlog_obj();
                  v247 = type[0];
                  if (os_log_type_enabled(v246, (os_log_type_t)type[0]))
                  {
                    v312 = *(void *)(a1 + 32);
                    v313 = "invalid";
                    if (v312)
                    {
                      v314 = *(const char **)(v312 + 16);
                      if (v314) {
                        v313 = v314;
                      }
                    }

                    *(_DWORD *)int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v313;
                    v251 = "%{public}s protocol %{public}s has invalid output_finished callback, backtrace limit exceeded";
                    goto LABEL_529;
                  }
                }
              }

        if (v89)
        {
          free((void *)v89);
          return 0LL;
        }

        return 0LL;
      }

      BOOL v10 = (nw_frame_array_s *)v90;
      if ((*(_WORD *)v13 & 0x100) != 0)
      {
        v190 = 0uLL;
        nw_protocol_get_flow_id(a1, &v190);
        if ((*(_WORD *)v13 & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v95 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t output_handler = a1[1].output_handler;
            int v97 = ((_DWORD)v10 - 1);
            if (!v10) {
              int v97 = 0LL;
            }
            *(_DWORD *)v177 = 136447234;
            *(void *)&v177[4] = "nw_socket_get_input_frames";
            *(_WORD *)&v177[12] = 2082;
            *(void *)&v177[14] = (char *)a1 + 404;
            *(_WORD *)&v177[22] = 1024;
            *(_DWORD *)&v177[24] = (_DWORD)v10;
            *(_WORD *)&v177[28] = 2048;
            *(void *)&v177[30] = output_handler;
            *(_WORD *)&v177[38] = 2048;
            *(void *)&v177[40] = (char *)output_handler + v97;
            _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Received %u bytes (overall bytes %llu -> %llu)",  v177,  0x30u);
          }
        }

        pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
        uint64_t v98 = (os_log_s *)gMpklLogObj;
        if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v99 = a1[1].output_handler;
          uint64_t v100 = ((_DWORD)v10 - 1);
          if (!v10) {
            uint64_t v100 = 0LL;
          }
          uint32_t v101 = BYTE2(a1[6].identifier);
          *(_DWORD *)v177 = 67110658;
          *(_DWORD *)&v177[4] = 100;
          *(_WORD *)&v177[8] = 1024;
          *(_DWORD *)&v177[10] = 150;
          *(_WORD *)&v177[14] = 1042;
          *(_DWORD *)&v177[16] = 16;
          *(_WORD *)&v177[20] = 2098;
          *(void *)&v177[22] = &v190;
          *(_WORD *)&v177[30] = 2048;
          *(void *)&v177[32] = v99;
          *(_WORD *)&v177[40] = 2048;
          *(void *)&v177[42] = (char *)v99 + v100;
          *(_WORD *)&v177[50] = 1024;
          *(_DWORD *)&v177[52] = v101;
          _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_DEFAULT,  "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %llu, logSeqn: %hhu}",  v177,  0x38u);
        }

        ++BYTE2(a1[6].identifier);
      }

      else if ((*(_WORD *)v13 & 0x80) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v92 = (os_log_s *)gconnectionLogObj;
        uint32_t v9 = (char *)v165;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v177 = 136446722;
          *(void *)&v177[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v177[12] = 2082;
          *(void *)&v177[14] = (char *)a1 + 404;
          *(_WORD *)&v177[22] = 1024;
          *(_DWORD *)&v177[24] = (_DWORD)v10;
          _os_log_impl(&dword_181A5C000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Received %u bytes", v177, 0x1Cu);
        }
      }

      *p_uint64_t output_handler = (nw_protocol *)((char *)*p_output_handler + v10);
      if (!v10)
      {
        if (v89) {
          free((void *)v89);
        }
        nw_socket_input_finished(a1, v91);
        nw_socket_cancel_input_source((uint64_t)p_output_handler, v105);
        return 0LL;
      }

      callbacks = (uint64_t)a1[5].callbacks;
      if (callbacks)
      {
        uint64_t v103 = *(void *)(callbacks + 16);
        int v104 = *(nw_protocol **)(callbacks + 24);
        if (v103)
        {
          *(void *)(v103 + 24) = v104;
          int v104 = *(nw_protocol **)(callbacks + 24);
        }

        else
        {
          a1[5].uint64_t output_handler = v104;
        }

        *(void *)v104->flow_id = v103;
        *(void *)(callbacks + 16) = 0LL;
        *(void *)(callbacks + 24) = 0LL;
        nw_frame_reset(callbacks, v89, (int)v10, (uint64_t)nw_socket_frame_input_finalizer, (uint64_t)p_output_handler);
        goto LABEL_232;
      }

      callbacks = nw_frame_create(0, v89, (int)v10, (uint64_t)nw_socket_frame_input_finalizer, (uint64_t)p_output_handler);
      if (callbacks)
      {
LABEL_232:
        if (a1[2].callbacks)
        {
          BOOL v113 = v88 > v10 || (_DWORD)type == (_DWORD)v10 && v74;
          if ((*(_WORD *)v13 & 0x80) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            __int128 v158 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              __int128 v159 = "Did not drain";
              *(void *)&v177[4] = "nw_socket_get_input_frames";
              *(_DWORD *)v177 = 136446722;
              if (v113) {
                __int128 v159 = "Drained";
              }
              *(_WORD *)&v177[12] = 2082;
              *(void *)&v177[14] = (char *)a1 + 404;
              *(_WORD *)&v177[22] = 2080;
              *(void *)&v177[24] = v159;
              _os_log_impl(&dword_181A5C000, v158, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s %s all data", v177, 0x20u);
            }
          }

          nw_frame_set_metadata( callbacks,  (nw_protocol_metadata *)a1[2].callbacks,  1,  v113 & (*(unsigned __int16 *)v13 >> 4));
          uint32_t v9 = (char *)v165;
        }

        int v20 = 1LL;
        nw_frame_set_buffer_used_malloc(callbacks, 1);
        *(void *)(callbacks + 16) = 0LL;
        uint64_t default_input_handler = a1[5].default_input_handler;
        *(void *)(callbacks + 24) = default_input_handler;
        *(void *)default_input_handler->flow_id = callbacks;
        a1[5].uint64_t default_input_handler = (nw_protocol *)(callbacks + 16);
        *(void *)(callbacks + 32) = 0LL;
        tqh_last = (uint64_t *)v167->tqh_last;
        *(void *)(callbacks + 40) = tqh_last;
        *tqh_last = callbacks;
        v167->tqh_last = (nw_frame **)(callbacks + 32);
        goto LABEL_242;
      }

      __nwlog_obj();
      *(_DWORD *)v177 = 136446210;
      *(void *)&v177[4] = "nw_socket_get_input_frames";
      BOOL v109 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v190) = 16;
      uint64_t v169 = 0;
      if (__nwlog_fault(v109, &v190, &v169))
      {
        if (v190 == 17)
        {
          uint64_t v110 = (os_log_s *)__nwlog_obj();
          os_log_type_t v111 = v190;
          if (!os_log_type_enabled(v110, (os_log_type_t)v190)) {
            goto LABEL_339;
          }
          *(_DWORD *)v177 = 136446210;
          *(void *)&v177[4] = "nw_socket_get_input_frames";
          os_log_type_t v112 = "%{public}s nw_frame_create failed";
          goto LABEL_338;
        }

        if (!v169)
        {
          uint64_t v110 = (os_log_s *)__nwlog_obj();
          os_log_type_t v111 = v190;
          if (!os_log_type_enabled(v110, (os_log_type_t)v190)) {
            goto LABEL_339;
          }
          *(_DWORD *)v177 = 136446210;
          *(void *)&v177[4] = "nw_socket_get_input_frames";
          os_log_type_t v112 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
          goto LABEL_338;
        }

        v152 = (char *)__nw_create_backtrace_string();
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = v190;
        unsigned int v153 = os_log_type_enabled(v110, (os_log_type_t)v190);
        if (v152)
        {
          if (v153)
          {
            *(_DWORD *)v177 = 136446466;
            *(void *)&v177[4] = "nw_socket_get_input_frames";
            *(_WORD *)&v177[12] = 2082;
            *(void *)&v177[14] = v152;
            _os_log_impl( &dword_181A5C000,  v110,  v111,  "%{public}s nw_frame_create failed, dumping backtrace:%{public}s",  v177,  0x16u);
          }

          free(v152);
          goto LABEL_339;
        }

        if (v153)
        {
          *(_DWORD *)v177 = 136446210;
          *(void *)&v177[4] = "nw_socket_get_input_frames";
          os_log_type_t v112 = "%{public}s nw_frame_create failed, no backtrace";
LABEL_338:
          _os_log_impl(&dword_181A5C000, v110, v111, v112, v177, 0xCu);
        }
      }

  os_log_type_t v88 = a2->callbacks;
  if (v88)
  {
    get_remote_endpoint = (uint64_t (*)(nw_protocol *))v88->get_remote_endpoint;
    if (get_remote_endpoint)
    {
      __int16 v55 = (nw_endpoint *)get_remote_endpoint(a2);
      if (!v23) {
        goto LABEL_227;
      }
      goto LABEL_226;
    }
  }

  __nwlog_obj();
  BOOL v128 = a2->identifier;
  if (!v128) {
    BOOL v128 = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)int buf = 136446722;
  __int128 v157 = "__nw_protocol_get_remote_endpoint";
  __int128 v158 = 2082;
  __int128 v159 = v128;
  __int128 v160 = 2048;
  __int128 v161 = a2;
  os_log_type_t v129 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  uint64_t v154 = OS_LOG_TYPE_DEFAULT;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    BOOL v130 = (os_log_s *)__nwlog_obj();
    os_log_type_t v131 = type[0];
    if (!os_log_type_enabled(v130, type[0])) {
      goto LABEL_344;
    }
    os_log_type_t v132 = a2->identifier;
    if (!v132) {
      os_log_type_t v132 = (nw_protocol_identifier *)"invalid";
    }
    *(_DWORD *)int buf = 136446722;
    __int128 v157 = "__nw_protocol_get_remote_endpoint";
    __int128 v158 = 2082;
    __int128 v159 = v132;
    __int128 v160 = 2048;
    __int128 v161 = a2;
    os_log_type_t v133 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback";
LABEL_342:
    uint64_t v150 = v130;
LABEL_343:
    _os_log_impl(&dword_181A5C000, v150, v131, v133, buf, 0x20u);
    goto LABEL_344;
  }

  if (v154 == OS_LOG_TYPE_DEFAULT)
  {
    BOOL v130 = (os_log_s *)__nwlog_obj();
    os_log_type_t v131 = type[0];
    if (!os_log_type_enabled(v130, type[0])) {
      goto LABEL_344;
    }
    nw_protocol_stack_t v149 = a2->identifier;
    if (!v149) {
      nw_protocol_stack_t v149 = (nw_protocol_identifier *)"invalid";
    }
    *(_DWORD *)int buf = 136446722;
    __int128 v157 = "__nw_protocol_get_remote_endpoint";
    __int128 v158 = 2082;
    __int128 v159 = v149;
    __int128 v160 = 2048;
    __int128 v161 = a2;
    os_log_type_t v133 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded";
    goto LABEL_342;
  }

  os_log_type_t v141 = (char *)__nw_create_backtrace_string();
  BOOL v142 = (os_log_s *)__nwlog_obj();
  os_log_type_t v131 = type[0];
  log = v142;
  v143 = os_log_type_enabled(v142, type[0]);
  if (v141)
  {
    if (v143)
    {
      os_log_type_t v144 = a2->identifier;
      if (!v144) {
        os_log_type_t v144 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)int buf = 136446978;
      __int128 v157 = "__nw_protocol_get_remote_endpoint";
      __int128 v158 = 2082;
      __int128 v159 = v144;
      __int128 v160 = 2048;
      __int128 v161 = a2;
      __int128 v162 = 2082;
      __int128 v163 = v141;
      _os_log_impl( &dword_181A5C000,  log,  v131,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v141);
  }

  else if (v143)
  {
    v151 = a2->identifier;
    if (!v151) {
      v151 = (nw_protocol_identifier *)"invalid";
    }
    *(_DWORD *)int buf = 136446722;
    __int128 v157 = "__nw_protocol_get_remote_endpoint";
    __int128 v158 = 2082;
    __int128 v159 = v151;
    __int128 v160 = 2048;
    __int128 v161 = a2;
    os_log_type_t v133 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace";
    uint64_t v150 = log;
    goto LABEL_343;
  }

void sub_181D95BA4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,id location)
{
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_create_dns_service_locked(NWConcrete_nw_resolver *a1)
{
  v249[1] = *(id *)MEMORY[0x1895F89C0];
  id v1 = a1;
  *((_WORD *)v1 + 44) = 0;
  if (nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3)) == 6)
  {
    if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
    {
      if (*((_BYTE *)v1 + 256))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v2 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
        {
          logging_description = nw_endpoint_get_logging_description(*((void **)v1 + 3));
          int v4 = *((_DWORD *)v1 + 20);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = (char *)v1 + 256;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&_BYTE buf[24] = logging_description;
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v4;
          _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s] Starting application service resolution %{public}s, proto %u",  buf,  0x26u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v2 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
        {
          int v147 = *((_DWORD *)v1 + 85);
          __int128 v148 = nw_endpoint_get_logging_description(*((void **)v1 + 3));
          int v149 = *((_DWORD *)v1 + 20);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v147;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v148;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v149;
          _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s [R%u] Starting application service resolution %{public}s, proto %u",  buf,  0x22u);
        }
      }
    }

LABEL_295:
    goto LABEL_296;
  }

                        if (*(void *)(*(void *)(*((void *)v7 + 1) + 80LL) + 40LL))
                        {
                          objc_storeStrong((id *)v119 + 7, v92);
                          v279 = 0uLL;
                          nw_protocol_get_flow_id(a2, &v279);
                          int v141 = nw_path_copy_flow_registration(*((void **)v119 + 15), (uint64_t)&v279);
                          BOOL v142 = (void *)*((void *)v119 + 35);
                          *((void *)v119 + 35) = v141;

                          (*(void (**)(char *, uint64_t))(*(void *)(*((void *)v7 + 1) + 80LL) + 40LL))( v119,  v127);
                          v119[402] |= 2u;
                          if ((_DWORD)v127)
                          {
                            uint64_t v143 = nw_parameters_copy_local_endpoint(*((nw_parameters_t *)v119 + 6));
                            unsigned int port = nw_endpoint_get_port(v143);
                            *(_OWORD *)&os_log_type_t type[4] = 0uLL;
                            v278 = 0LL;
                            *(_WORD *)&type[2] = __rev16(port);
                            *(_WORD *)nw_endpoint_type_t type = 7708;
                            v273 = nw_endpoint_create_address((const sockaddr *)type);
                            BOOL v145 = nw_context_copy_registered_endpoint(*((void **)v119 + 15), v273);
                            int v146 = nw_endpoint_copy_registrar_for_identifier(v145, (__int128 *)a1->identifier->name, 1);
                            int v147 = (void *)*((void *)v119 + 49);
                            *((void *)v119 + 49) = v146;

                            __int128 v148 = (void *)*((void *)v119 + 49);
                            if (v148)
                            {
                              if ((v119[405] & 0x80000000) == 0)
                              {
                                __nwlog_obj();
                                int v149 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
                                {
                                  *(_DWORD *)int buf = 136446722;
                                  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
                                  *(_WORD *)&buf[12] = 2082;
                                  *(void *)&buf[14] = v119 + 407;
                                  v281 = 2080;
                                  v282 = (nw_protocol *)" ";
                                  _os_log_impl( &dword_181A5C000,  v149,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAdded server protocol to the registrar",  buf,  0x20u);
                                }

                                __int128 v148 = (void *)*((void *)v119 + 49);
                              }

                              nw_protocol_instance_registrar_add_instance(v148, (uint64_t)a1);
                            }
                          }

                          BOOL v122 = v274;
                        }

                        goto LABEL_305;
                      }
                    }

                    else if (a2)
                    {
                      goto LABEL_253;
                    }

                    __nwlog_obj();
                    v196 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)int buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler_context";
                    v197 = (char *)_os_log_send_and_compose_impl();

                    type[0] = 16;
                    LOBYTE(v279) = 0;
                    if (__nwlog_fault(v197, type, &v279))
                    {
                      if (type[0] == 17)
                      {
                        __nwlog_obj();
                        v198 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        v199 = type[0];
                        if (os_log_type_enabled(v198, (os_log_type_t)type[0]))
                        {
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler_context";
                          _os_log_impl(&dword_181A5C000, v198, v199, "%{public}s called with null protocol", buf, 0xCu);
                        }

LABEL_296:
  *((_DWORD *)v10 + 21) = v5;
  nw_resolver_cancel_query_locked(v10, 0);
  uint64_t v150 = 0LL;
LABEL_297:

  return v150;
}

            if (v188) {
              free(v188);
            }
            uint64_t v87 = 0;
            goto LABEL_103;
          }

          __nwlog_obj();
          os_log_type_t v135 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
          uint32_t v136 = (char *)_os_log_send_and_compose_impl();

          v244[0] = 16;
          v235[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v136, v244, v235))
          {
            if (v244[0] == 17)
            {
              __nwlog_obj();
              id v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v138 = v244[0];
              if (os_log_type_enabled(v137, (os_log_type_t)v244[0]))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                _os_log_impl(&dword_181A5C000, v137, v138, "%{public}s called with null protocol", buf, 0xCu);
              }
            }

            else
            {
              if (v235[0])
              {
                int v146 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                int v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                __int128 v148 = v244[0];
                int v149 = os_log_type_enabled(v147, (os_log_type_t)v244[0]);
                if (v146)
                {
                  if (v149)
                  {
                    *(_DWORD *)int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v146;
                    _os_log_impl( &dword_181A5C000,  v147,  v148,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v146);
                }

                else
                {
                  if (v149)
                  {
                    *(_DWORD *)int buf = 136446210;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                    _os_log_impl( &dword_181A5C000,  v147,  v148,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
                  }
                }

                goto LABEL_282;
              }

              __nwlog_obj();
              id v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              nw_endpoint_type_t v171 = v244[0];
              if (os_log_type_enabled(v137, (os_log_type_t)v244[0]))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                _os_log_impl( &dword_181A5C000,  v137,  v171,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

      goto LABEL_315;
    }

    if (!v160)
    {
      __nwlog_obj();
      os_log_type_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v151 = type;
      if (os_log_type_enabled(v111, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int128 v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl( &dword_181A5C000,  v111,  v151,  "%{public}s called with null (configure_http_messaging != (_nw_parameters_configure_protocol_disable)), backtra ce limit exceeded",  buf,  0xCu);
      }

      goto LABEL_296;
    }

    v139 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint32_t v140 = type;
    int v141 = os_log_type_enabled(v128, type);
    if (v139)
    {
      if (v141)
      {
        *(_DWORD *)int buf = 136446466;
        __int128 v163 = "nw_parameters_create_secure_http_messaging";
        __int128 v164 = 2082;
        __int128 v165 = v139;
        _os_log_impl( &dword_181A5C000,  v128,  v140,  "%{public}s called with null (configure_http_messaging != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v139);
LABEL_315:
      if (!v110)
      {
LABEL_317:
        uint64_t v69 = 0LL;
        goto LABEL_207;
      }

    goto LABEL_325;
  }

  if (!v410)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v231 = (os_log_s *)(id)gLogObj;
    v248 = v425[0];
    if (os_log_type_enabled(v231, (os_log_type_t)v425[0]))
    {
      buf[0] = 136446722;
      *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
      LOWORD(buf[3]) = 1024;
      *(_DWORD *)((char *)&buf[3] + 2) = v228;
      HIWORD(buf[4]) = 1024;
      buf[5] = v225;
      _os_log_impl( &dword_181A5C000,  v231,  v248,  "%{public}s flow_disconnect %u < flow_finish %u, backtrace limit exceeded",  (uint8_t *)buf,  0x18u);
    }

    goto LABEL_296;
  }

  v244 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v245 = (os_log_s *)(id)gLogObj;
  v246 = v425[0];
  v247 = os_log_type_enabled(v245, (os_log_type_t)v425[0]);
  if (!v244)
  {
    if (v247)
    {
      buf[0] = 136446722;
      *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
      LOWORD(buf[3]) = 1024;
      *(_DWORD *)((char *)&buf[3] + 2) = v228;
      HIWORD(buf[4]) = 1024;
      buf[5] = v225;
      _os_log_impl( &dword_181A5C000,  v245,  v246,  "%{public}s flow_disconnect %u < flow_finish %u, no backtrace",  (uint8_t *)buf,  0x18u);
    }

    goto LABEL_325;
  }

  if (v247)
  {
    buf[0] = 136446978;
    *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
    LOWORD(buf[3]) = 1024;
    *(_DWORD *)((char *)&buf[3] + 2) = v228;
    HIWORD(buf[4]) = 1024;
    buf[5] = v225;
    LOWORD(buf[6]) = 2082;
    *(void *)((char *)&buf[6] + 2) = v244;
    _os_log_impl( &dword_181A5C000,  v245,  v246,  "%{public}s flow_disconnect %u < flow_finish %u, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x22u);
  }

  free(v244);
  os_log_type_t v131 = v382;
  if (v230) {
LABEL_326:
  }
    free(v230);
LABEL_327:
  if ((*((_BYTE *)v378 + 109) & 0x40) != 0)
  {
LABEL_414:
    v250 = v379;
    tls = nw_endpoint_handler_stack_uses_tls(v126->parent_endpoint_handler);
    if (v381) {
      v291 = tls;
    }
    else {
      v291 = 1;
    }
    if ((v291 & 1) != 0)
    {
LABEL_419:
      v249 = 1024LL;
      if (!tls) {
        v249 = 0LL;
      }
      goto LABEL_421;
    }

void sub_181D982D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id *location, id *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, void *a40, uint64_t a41, uint64_t a42, uint64_t a43, id a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
  _Unwind_Resume(a1);
}

BOOL __nw_resolver_set_update_handler_block_invoke_79(uint64_t a1)
{
  return nw_resolver_cancel(*(void **)(a1 + 32));
}

void nw_resolver_cancel_delayed_reporting_timer(NWConcrete_nw_resolver *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  int v2 = a1;
  uint64_t v3 = *((void *)v2 + 17);
  if (!v3) {
    goto LABEL_13;
  }
  if ((*((_BYTE *)v2 + 346) & 0x20) != 0)
  {
LABEL_12:
    nw_queue_cancel_source(v3, v1);
    *((void *)v2 + 17) = 0LL;
    goto LABEL_13;
  }

  if (!*((_BYTE *)v2 + 256))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v4 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_11;
    }
    int v9 = *((_DWORD *)v2 + 85);
    logging_description = nw_endpoint_get_logging_description(*((void **)v2 + 3));
    int v11 = 136446722;
    pid_t v12 = "nw_resolver_cancel_delayed_reporting_timer";
    __int16 v13 = 1024;
    *(_DWORD *)BOOL v14 = v9;
    *(_WORD *)&v14[4] = 2082;
    *(void *)&void v14[6] = logging_description;
    char v6 = "%{public}s [R%u] Cancelling delayed reporting timer for %{public}s";
    unint64_t v7 = v4;
    uint32_t v8 = 28;
    goto LABEL_10;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  int v4 = (os_log_s *)(id)gconnectionLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    DNSServiceErrorType v5 = nw_endpoint_get_logging_description(*((void **)v2 + 3));
    int v11 = 136446722;
    pid_t v12 = "nw_resolver_cancel_delayed_reporting_timer";
    __int16 v13 = 2082;
    *(void *)BOOL v14 = (char *)v2 + 256;
    *(_WORD *)&v14[8] = 2082;
    *(void *)&v14[10] = v5;
    char v6 = "%{public}s [C%{public}s] Cancelling delayed reporting timer for %{public}s";
    unint64_t v7 = v4;
    uint32_t v8 = 32;
LABEL_10:
    _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, v6, (uint8_t *)&v11, v8);
  }

void sub_181D98628(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_cancel_query_locked(NWConcrete_nw_resolver *a1, char a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  if (*((void *)v3 + 6))
  {
    dnssd_getaddrinfo_invalidate();
    int v4 = (void *)*((void *)v3 + 6);
    *((void *)v3 + 6) = 0LL;
  }

  nw_array_apply(*((unsigned __int8 **)v3 + 22), (uint64_t)&__block_literal_global_252);
  if (*((void *)v3 + 8))
  {
    *((void *)v3 + _Block_object_dispose(va, 8) = 0LL;
    *((void *)v3 + 9) = 0LL;
    dispatch_group_leave(*((dispatch_group_t *)v3 + 5));
  }

  if ((a2 & 1) == 0)
  {
    DNSServiceErrorType v5 = (nw_browser *)*((void *)v3 + 15);
    if (v5)
    {
      if ((*((_BYTE *)v3 + 346) & 0x20) != 0)
      {
LABEL_17:
        nw_browser_cancel(v5);
        int v11 = (void *)*((void *)v3 + 15);
        *((void *)v3 + 15) = 0LL;

        goto LABEL_18;
      }

      if (*((_BYTE *)v3 + 256))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v6 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO)) {
          goto LABEL_16;
        }
        int v12 = 136446466;
        __int16 v13 = "nw_resolver_cancel_query_locked";
        __int16 v14 = 2082;
        uint64_t v15 = (char *)v3 + 256;
        unint64_t v7 = "%{public}s [C%{public}s] Stopping AWDL trigger browser";
        uint32_t v8 = v6;
        uint32_t v9 = 22;
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v6 = (os_log_s *)(id)gLogObj;
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
LABEL_16:

          DNSServiceErrorType v5 = (nw_browser *)*((void *)v3 + 15);
          goto LABEL_17;
        }

        int v10 = *((_DWORD *)v3 + 85);
        int v12 = 136446466;
        __int16 v13 = "nw_resolver_cancel_query_locked";
        __int16 v14 = 1024;
        LODWORD(v15) = v10;
        unint64_t v7 = "%{public}s [R%u] Stopping AWDL trigger browser";
        uint32_t v8 = v6;
        uint32_t v9 = 18;
      }

      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_INFO, v7, (uint8_t *)&v12, v9);
      goto LABEL_16;
    }
  }

void sub_181D98830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_resolver_cancel_query_lockedP22NWConcrete_nw_resolverb_block_invoke( uint64_t a1, uint64_t a2, NWConcrete_nw_resolver_service *a3)
{
  return 1LL;
}

void nw_resolver_service_cancel_query(NWConcrete_nw_resolver_service *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  int v2 = v1;
  if (v1)
  {
    if (v1->gai)
    {
      dnssd_getaddrinfo_invalidate();
      gauint64_t i = v2->gai;
      v2->gauint64_t i = 0LL;
    }

    goto LABEL_4;
  }

  __nwlog_obj();
  int v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v15 = "nw_resolver_service_cancel_query";
  DNSServiceErrorType v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v15 = "nw_resolver_service_cancel_query";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null service", buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v15 = "nw_resolver_service_cancel_query";
          __int16 v16 = 2082;
          uint32_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v15 = "nw_resolver_service_cancel_query";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null service, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v15 = "nw_resolver_service_cancel_query";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null service, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D98B00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_resolver_create_dns_service_lockedP22NWConcrete_nw_resolver_block_invoke(uint64_t a1)
{
}

void nw_resolver_host_resolve_callback( _DNSServiceRef_t *a1, int a2, unsigned int a3, int a4, const char *a5, const sockaddr *a6, int a7, void *a8)
{
  v70[2] = *MEMORY[0x1895F89C0];
  __int16 v14 = a8;
  uint64_t v15 = v14;
  if (v14)
  {
    if (nw_parameters_get_sensitive_redacted(v14[2]))
    {
      if (!a6) {
        goto LABEL_16;
      }
      int sa_family = a6->sa_family;
      if (sa_family != 30)
      {
        if (sa_family == 2)
        {
          if (*(_DWORD *)&a6->sa_data[2])
          {
            uint32_t v17 = (const char *)v70;
            __nwlog_salted_hash(&a6->sa_data[2], 4LL, (char *)v70);
            uint64_t v18 = "IPv4#";
            if ((*((_BYTE *)v15 + 346) & 0x20) != 0) {
              goto LABEL_43;
            }
LABEL_27:
            if (*((_BYTE *)v15 + 256))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              int v19 = (os_log_s *)(id)gconnectionLogObj;
              if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO)) {
                goto LABEL_42;
              }
              *(_DWORD *)int buf = 136448514;
              uint64_t v66 = "nw_resolver_host_resolve_callback";
              __int16 v67 = 2082;
              *(void *)size_t v68 = v15 + 32;
              *(_WORD *)&v68[8] = 1024;
              *(_DWORD *)&v68[10] = a2;
              *(_WORD *)&v68[14] = 1024;
              *(_DWORD *)&v68[16] = a3;
              *(_WORD *)&v68[20] = 2082;
              *(void *)&v68[22] = nwlog_get_string_for_dns_service_error(a4);
              *(_WORD *)&v68[30] = 1024;
              *(_DWORD *)&v68[32] = a4;
              *(_WORD *)&v68[36] = 2080;
              *(void *)&v68[38] = a5;
              *(_WORD *)&v68[46] = 2082;
              *(void *)&v68[48] = v18;
              *(_WORD *)&v68[56] = 2082;
              *(void *)&v68[58] = v17;
              *(_WORD *)&v68[66] = 1024;
              int v69 = a7;
              uint64_t v25 = "%{public}s [C%{public}s] flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%s addr=%{public}s%{public}s ttl=%d";
              uint32_t v26 = v19;
              uint32_t v27 = 86;
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v19 = (os_log_s *)(id)gLogObj;
              if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
              {
LABEL_42:

                goto LABEL_43;
              }

              int v56 = a7;
              int v28 = a2;
              int v29 = *((_DWORD *)v15 + 85);
              *(_DWORD *)int buf = 136448514;
              uint64_t v66 = "nw_resolver_host_resolve_callback";
              __int16 v67 = 1024;
              *(_DWORD *)size_t v68 = v29;
              a2 = v28;
              *(_WORD *)&v68[4] = 1024;
              *(_DWORD *)&v68[6] = v28;
              *(_WORD *)&v68[10] = 1024;
              *(_DWORD *)&v68[12] = a3;
              *(_WORD *)&v68[16] = 2082;
              *(void *)&v68[18] = nwlog_get_string_for_dns_service_error(a4);
              *(_WORD *)&v68[26] = 1024;
              *(_DWORD *)&v68[28] = a4;
              *(_WORD *)&v68[32] = 2080;
              *(void *)&v68[34] = a5;
              *(_WORD *)&v68[42] = 2082;
              *(void *)&v68[44] = v18;
              *(_WORD *)&v68[52] = 2082;
              *(void *)&v68[54] = v17;
              *(_WORD *)&v68[62] = 1024;
              *(_DWORD *)&v68[64] = v56;
              uint64_t v25 = "%{public}s [R%u] flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%s addr=%{public}s%{public}s ttl=%d";
              uint32_t v26 = v19;
              uint32_t v27 = 82;
            }

            _os_log_impl(&dword_181A5C000, v26, OS_LOG_TYPE_INFO, v25, buf, v27);
            goto LABEL_42;
          }

          uint32_t v17 = "INADDR_ANY";
LABEL_17:
          uint64_t v18 = "";
          if ((*((_BYTE *)v15 + 346) & 0x20) != 0) {
            goto LABEL_43;
          }
          goto LABEL_27;
        }

void sub_181D99708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL38nw_resolver_get_awdl_trigger_heuristicP22NWConcrete_nw_resolver_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F92F0] && xpc_uint64_get_value(v4) == 1002)
  {
    uint64_t v5 = 0LL;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 2;
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

void sub_181D997AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke( uint64_t a1, int a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) || a2 != 4 && a2 != 2) {
    goto LABEL_2;
  }
  WeakRetained = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained) {
    goto LABEL_2;
  }
  os_log_type_t v7 = WeakRetained;
  if ((WeakRetained[86]._os_unfair_lock_opaque & 0x200000) == 0)
  {
    if (LOBYTE(WeakRetained[64]._os_unfair_lock_opaque))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint32_t v8 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
        goto LABEL_15;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v18 = "nw_resolver_should_wait_for_awdl_trigger_block_invoke";
      __int16 v19 = 2082;
      int v20 = v7 + 64;
      os_log_type_t v9 = "%{public}s [C%{public}s] AWDL trigger browse did not find service";
      BOOL v10 = v8;
      uint32_t v11 = 22;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v8 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
LABEL_15:

        goto LABEL_16;
      }

      uint32_t os_unfair_lock_opaque = v7[85]._os_unfair_lock_opaque;
      *(_DWORD *)int buf = 136446466;
      uint64_t v18 = "nw_resolver_should_wait_for_awdl_trigger_block_invoke";
      __int16 v19 = 1024;
      LODWORD(v20) = os_unfair_lock_opaque;
      os_log_type_t v9 = "%{public}s [R%u] AWDL trigger browse did not find service";
      BOOL v10 = v8;
      uint32_t v11 = 18;
    }

    _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_INFO, v9, buf, v11);
    goto LABEL_15;
  }

void sub_181D99A0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke_245( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
    id v6 = WeakRetained;
    if (v4 && WeakRetained)
    {
      os_log_type_t v7 = (id *)v4;
      uint32_t v8 = (nw_endpoint *)v7[1];

      if (v8)
      {
        bonjour_service_name = nw_endpoint_get_bonjour_service_name(v8);
        BOOL v10 = nw_endpoint_get_bonjour_service_name(*((nw_endpoint_t *)v6 + 3));
        if (!strcasecmp(bonjour_service_name, v10))
        {
          *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
          *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
          aBlock[0] = MEMORY[0x1895F87A8];
          aBlock[1] = 3221225472LL;
          aBlock[2] = ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke_2;
          aBlock[3] = &unk_189BC93A0;
          id v13 = v6;
          uint32_t v11 = (void (**)(void))_Block_copy(aBlock);
          os_unfair_lock_lock((os_unfair_lock_t)v6 + 3);
          v11[2](v11);
          os_unfair_lock_unlock((os_unfair_lock_t)v6 + 3);
        }
      }
    }
  }
}

void sub_181D99B68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_resolver_bonjour_resolve_callback( _DNSServiceRef_t *a1, int a2, unsigned int a3, int a4, const char *a5, const char *a6, unsigned int a7, unsigned int a8, const unsigned __int8 *a9, void *a10)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  uint64_t v18 = a10;
  __int16 v19 = v18;
  if (v18)
  {
    unsigned int v20 = __rev16(a7);
    if ((v18[346] & 0x20) != 0) {
      goto LABEL_12;
    }
    if (v18[256])
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v21 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_11;
      }
      *(_DWORD *)int buf = 136448002;
      size_t v86 = "nw_resolver_bonjour_resolve_callback";
      __int16 v87 = 2082;
      *(void *)unsigned int v88 = v19 + 256;
      *(_WORD *)&v88[8] = 1024;
      *(_DWORD *)&v88[10] = a2;
      *(_WORD *)&v88[14] = 1024;
      *(_DWORD *)&v88[16] = a3;
      *(_WORD *)&v88[20] = 1024;
      *(_DWORD *)&v88[22] = a4;
      *(_WORD *)&v88[26] = 2082;
      *(void *)&v88[28] = a5;
      *(_WORD *)&v88[36] = 2082;
      *(void *)&v88[38] = a6;
      *(_WORD *)&v88[46] = 1024;
      unsigned int v89 = v20;
      int v22 = "%{public}s [C%{public}s] flags=0x%x ifindex=%u errorCode=%d name=%{public}s target=%{public}s port=%u";
      uint32_t v23 = v21;
      uint32_t v24 = 66;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v21 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
LABEL_11:

LABEL_12:
        os_unfair_lock_lock((os_unfair_lock_t)v19 + 3);
        if (!a1 || *((_DNSServiceRef_t **)v19 + 9) != a1)
        {
          if ((v19[346] & 0x20) != 0)
          {
LABEL_24:
            os_unfair_lock_unlock((os_unfair_lock_t)v19 + 3);
            goto LABEL_25;
          }

          if (v19[256])
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint32_t v26 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_23;
            }
            uint64_t v27 = *((void *)v19 + 9);
            *(_DWORD *)int buf = 136447234;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 2082;
            *(void *)unsigned int v88 = v19 + 256;
            *(_WORD *)&v88[8] = 2048;
            *(void *)&v88[10] = a1;
            *(_WORD *)&v88[18] = 2048;
            *(void *)&v88[20] = v19;
            *(_WORD *)&v88[28] = 2048;
            *(void *)&v88[30] = v27;
            int v28 = "%{public}s [C%{public}s] Skipped, service %p, resolver %p -> %p";
            int v29 = v26;
            uint32_t v30 = 52;
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint32_t v26 = (os_log_s *)(id)gLogObj;
            if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
LABEL_23:

              goto LABEL_24;
            }

            int v31 = *((_DWORD *)v19 + 85);
            uint64_t v32 = *((void *)v19 + 9);
            *(_DWORD *)int buf = 136447234;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 1024;
            *(_DWORD *)unsigned int v88 = v31;
            *(_WORD *)&v88[4] = 2048;
            *(void *)&v88[6] = a1;
            *(_WORD *)&v88[14] = 2048;
            *(void *)&v88[16] = v19;
            *(_WORD *)&v88[24] = 2048;
            *(void *)&v88[26] = v32;
            int v28 = "%{public}s [R%u] Skipped, service %p, resolver %p -> %p";
            int v29 = v26;
            uint32_t v30 = 48;
          }

          _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_DEBUG, v28, buf, v30);
          goto LABEL_23;
        }

        if (a4)
        {
          if (a4 != -65569 || *((_DWORD *)v19 + 2) == 2)
          {
            *((_DWORD *)v19 + 21) = a4;
            goto LABEL_74;
          }

          if ((v19[346] & 0x20) != 0)
          {
LABEL_50:
            nw_resolver_restart_dns_service_locked((NWConcrete_nw_resolver *)v19);
            goto LABEL_24;
          }

          if (v19[256])
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            int v42 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v42, OS_LOG_TYPE_INFO)) {
              goto LABEL_49;
            }
            *(_DWORD *)int buf = 136446722;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 2082;
            *(void *)unsigned int v88 = v19 + 256;
            *(_WORD *)&v88[8] = 2048;
            *(void *)&v88[10] = v19;
            size_t v43 = "%{public}s [C%{public}s] restarting resolver %p, defunct connection";
            int v44 = v42;
            uint32_t v45 = 32;
          }

          else
          {
            __nwlog_obj();
            int v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
            {
LABEL_49:

              goto LABEL_50;
            }

            int v46 = *((_DWORD *)v19 + 85);
            *(_DWORD *)int buf = 136446722;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 1024;
            *(_DWORD *)unsigned int v88 = v46;
            *(_WORD *)&v88[4] = 2048;
            *(void *)&v88[6] = v19;
            size_t v43 = "%{public}s [R%u] restarting resolver %p, defunct connection";
            int v44 = v42;
            uint32_t v45 = 28;
          }

          _os_log_impl(&dword_181A5C000, v44, OS_LOG_TYPE_INFO, v43, buf, v45);
          goto LABEL_49;
        }

        BOOL host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(a6, v20);
        uint32_t v34 = (void *)host_with_numeric_port;
        if (!host_with_numeric_port)
        {
LABEL_73:

LABEL_74:
          if ((a2 & 1) == 0) {
            nw_resolver_update_status_locked(v19, 0LL);
          }
          goto LABEL_24;
        }

        nw_endpoint_set_parent_endpoint((void *)host_with_numeric_port, *((void **)v19 + 3), 0);
        nw_txt_record_t v35 = nw_txt_record_create_with_bytes(a9, a8);
        int v36 = v34;
        int v37 = v35;
        objc_storeStrong(v36 + 23, v35);

        *(void *)os_log_type_t type = 0LL;
        DNSServiceGetValidationData();
        if (!nw_resolver_set_interface_on_endpoint(v19, a3, v36))
        {
LABEL_72:

          goto LABEL_73;
        }

        unsigned int v83 = nw_resolver_derive_service_flags(v19, *((void **)v19 + 3), *((void **)v19 + 2));
        if (nw_resolver_get_scoped_interface_index((NWConcrete_nw_resolver *)v19, &v83))
        {
          if ((v19[346] & 0x20) != 0) {
            goto LABEL_61;
          }
          if (v19[256])
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v38 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_60;
            }
            *(_DWORD *)int buf = 136446466;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 2082;
            *(void *)unsigned int v88 = v19 + 256;
            unint64_t v39 = "%{public}s [C%{public}s] Not preferring endpoints for scoped resolution";
            uint32_t v40 = v38;
            uint32_t v41 = 22;
          }

          else
          {
            __nwlog_obj();
            uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
LABEL_60:

              goto LABEL_61;
            }

            int v54 = *((_DWORD *)v19 + 85);
            *(_DWORD *)int buf = 136446466;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 1024;
            *(_DWORD *)unsigned int v88 = v54;
            unint64_t v39 = "%{public}s [R%u] Not preferring endpoints for scoped resolution";
            uint32_t v40 = v38;
            uint32_t v41 = 18;
          }

          _os_log_impl(&dword_181A5C000, v40, OS_LOG_TYPE_DEBUG, v39, buf, v41);
          goto LABEL_60;
        }

        id v47 = nw_parameters_copy_preferred_interface_subtypes(*((void **)v19 + 2));
        unint64_t v48 = v47;
        if (v47 && xpc_array_get_count(v47))
        {
          size_t v80 = nw_interface_create_with_index(a3);
          subos_log_type_t type = nw_interface_get_subtype(v80);
          size_t v50 = 0LL;
          do
          {
            size_t count = xpc_array_get_count(v48);
            BOOL v52 = v50 < count;
            if (v50 >= count) {
              break;
            }
            int uint64 = xpc_array_get_uint64(v48, v50++);
          }

          while (subtype != uint64);
        }

        else
        {

          BOOL v52 = 0;
        }

        if (v52 || (v19[348] & 1) != 0)
        {
LABEL_61:
          if ((v19[346] & 0x20) != 0)
          {
LABEL_71:
            nw_resolver_insert_endpoint_locked(v19, v36, &__block_literal_global_259);
            goto LABEL_72;
          }

          if (v19[256])
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v55 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_INFO)) {
              goto LABEL_70;
            }
            *(_DWORD *)int buf = 136446722;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 2082;
            *(void *)unsigned int v88 = v19 + 256;
            *(_WORD *)&v88[8] = 2112;
            *(void *)&v88[10] = v36;
            int v56 = "%{public}s [C%{public}s] Inserting host endpoint %@ directly";
            __int16 v57 = v55;
            uint32_t v58 = 32;
          }

          else
          {
            __nwlog_obj();
            os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
            {
LABEL_70:

              goto LABEL_71;
            }

            int v59 = *((_DWORD *)v19 + 85);
            *(_DWORD *)int buf = 136446722;
            size_t v86 = "nw_resolver_bonjour_resolve_callback";
            __int16 v87 = 1024;
            *(_DWORD *)unsigned int v88 = v59;
            *(_WORD *)&v88[4] = 2112;
            *(void *)&v88[6] = v36;
            int v56 = "%{public}s [R%u] Inserting host endpoint %@ directly";
            __int16 v57 = v55;
            uint32_t v58 = 28;
          }

          _os_log_impl(&dword_181A5C000, v57, OS_LOG_TYPE_INFO, v56, buf, v58);
          goto LABEL_70;
        }

        if (!*((void *)v19 + 20))
        {
          char v60 = (void *)*((void *)v19 + 4);
          v81[0] = MEMORY[0x1895F87A8];
          v81[1] = 3221225472LL;
          v81[2] = ___ZL36nw_resolver_bonjour_resolve_callbackP16_DNSServiceRef_tjjiPKcS2_ttPKhPv_block_invoke;
          v81[3] = &unk_189BC93A0;
          unsigned int v82 = v19;
          BOOL source = nw_queue_context_create_source(v60, 2, 3, 0, v81, 0LL);
          *((void *)v19 + 20) = source;
          dispatch_time_t v62 = dispatch_time(0x8000000000000000LL, 1000000000LL);
          nw_queue_set_timer_values(source, v62, 0xFFFFFFFFFFFFFFFFLL, 0x2FAF080uLL);
          nw_queue_activate_source(*((void *)v19 + 20), v63);
        }

        if ((v19[346] & 0x20) != 0)
        {
LABEL_91:
          uint64_t v69 = *((void *)v19 + 19);
          if (!v69)
          {
            BOOL v70 = nw_array_create();
            size_t v71 = (void *)*((void *)v19 + 19);
            *((void *)v19 + 19) = v70;

            uint64_t v69 = *((void *)v19 + 19);
          }

          nw_array_append(v69, v36);
          goto LABEL_72;
        }

        if (v19[256])
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v64 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_90;
          }
          *(_DWORD *)int buf = 136446722;
          size_t v86 = "nw_resolver_bonjour_resolve_callback";
          __int16 v87 = 2082;
          *(void *)unsigned int v88 = v19 + 256;
          *(_WORD *)&v88[8] = 2112;
          *(void *)&v88[10] = v36;
          size_t v65 = "%{public}s [C%{public}s] Appending non-preferred host endpoint (%@) to array";
          uint64_t v66 = v64;
          uint32_t v67 = 32;
        }

        else
        {
          __nwlog_obj();
          char v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
          {
LABEL_90:

            goto LABEL_91;
          }

          int v68 = *((_DWORD *)v19 + 85);
          *(_DWORD *)int buf = 136446722;
          size_t v86 = "nw_resolver_bonjour_resolve_callback";
          __int16 v87 = 1024;
          *(_DWORD *)unsigned int v88 = v68;
          *(_WORD *)&v88[4] = 2112;
          *(void *)&v88[6] = v36;
          size_t v65 = "%{public}s [R%u] Appending non-preferred host endpoint (%@) to array";
          uint64_t v66 = v64;
          uint32_t v67 = 28;
        }

        _os_log_impl(&dword_181A5C000, v66, OS_LOG_TYPE_DEBUG, v65, buf, v67);
        goto LABEL_90;
      }

      int v25 = *((_DWORD *)v19 + 85);
      *(_DWORD *)int buf = 136448002;
      size_t v86 = "nw_resolver_bonjour_resolve_callback";
      __int16 v87 = 1024;
      *(_DWORD *)unsigned int v88 = v25;
      *(_WORD *)&v88[4] = 1024;
      *(_DWORD *)&v88[6] = a2;
      *(_WORD *)&v88[10] = 1024;
      *(_DWORD *)&v88[12] = a3;
      *(_WORD *)&v88[16] = 1024;
      *(_DWORD *)&v88[18] = a4;
      *(_WORD *)&v88[22] = 2082;
      *(void *)&v88[24] = a5;
      *(_WORD *)&v88[32] = 2082;
      *(void *)&v88[34] = a6;
      *(_WORD *)&v88[42] = 1024;
      *(_DWORD *)&v88[44] = v20;
      int v22 = "%{public}s [R%u] flags=0x%x ifindex=%u errorCode=%d name=%{public}s target=%{public}s port=%u";
      uint32_t v23 = v21;
      uint32_t v24 = 62;
    }

    _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, v22, buf, v24);
    goto LABEL_11;
  }

  __nwlog_obj();
  uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  size_t v86 = "nw_resolver_bonjour_resolve_callback";
  unsigned int v73 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v83) = 0;
  if (__nwlog_fault(v73, type, &v83))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v75 = type[0];
      if (os_log_type_enabled(v74, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v86 = "nw_resolver_bonjour_resolve_callback";
        _os_log_impl(&dword_181A5C000, v74, v75, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if ((_BYTE)v83)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v77 = type[0];
      BOOL v78 = os_log_type_enabled(v74, type[0]);
      if (backtrace_string)
      {
        if (v78)
        {
          *(_DWORD *)int buf = 136446466;
          size_t v86 = "nw_resolver_bonjour_resolve_callback";
          __int16 v87 = 2082;
          *(void *)unsigned int v88 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v74,  v77,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_110;
      }

      if (v78)
      {
        *(_DWORD *)int buf = 136446210;
        size_t v86 = "nw_resolver_bonjour_resolve_callback";
        _os_log_impl(&dword_181A5C000, v74, v77, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v79 = type[0];
      if (os_log_type_enabled(v74, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v86 = "nw_resolver_bonjour_resolve_callback";
        _os_log_impl( &dword_181A5C000,  v74,  v79,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181D9A830( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void nw_resolver_ptr_resolve_callback( _DNSServiceRef_t *a1, int a2, unsigned int a3, int a4, const char *a5, int a6, unsigned __int16 a7, unsigned __int16 a8, const char *a9, unsigned int a10, void *a11)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  uint64_t v15 = a11;
  if (!v15)
  {
    __nwlog_obj();
    int v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (__nwlog_fault(v16, &type, &v73))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint32_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
          _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s called with null resolver", buf, 0xCu);
        }
      }

      else if (v73)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint32_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v58 = type;
        BOOL v59 = os_log_type_enabled(v30, type);
        if (backtrace_string)
        {
          if (v59)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
            __int16 v76 = 2082;
            *(void *)os_log_type_t v77 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v30,  v58,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v16) {
            goto LABEL_76;
          }
          goto LABEL_75;
        }

        if (v59)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
          _os_log_impl(&dword_181A5C000, v30, v58, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint32_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v60 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
          _os_log_impl( &dword_181A5C000,  v30,  v60,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v16) {
      goto LABEL_76;
    }
    goto LABEL_75;
  }

  __int16 v16 = (char *)calloc(1uLL, 0x100uLL);
  if (v16)
  {
    uint32_t v17 = a9;
    if (a9) {
      goto LABEL_4;
    }
    goto LABEL_20;
  }

  __nwlog_obj();
  uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  __int16 v76 = 2048;
  *(void *)os_log_type_t v77 = 1LL;
  *(_WORD *)&os_log_type_t v77[8] = 2048;
  *(void *)&v77[10] = 256LL;
  id v33 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v33))
  {
    free(v33);
    uint32_t v17 = a9;
    if (a9)
    {
LABEL_4:
      dispatch_time_t v62 = v15;
      LODWORD(v1_Block_object_dispose(va, 8) = (_DWORD)v16;
      __int16 v19 = a1;
      int v20 = a4;
      int v21 = a2;
      unsigned int v22 = a3;
      int v23 = *(unsigned __int8 *)v17;
      if (*v17)
      {
        uint64_t v18 = v16;
        uint32_t v24 = v16 + 256;
        while (1)
        {
          unsigned int v25 = snprintf(v18, v24 - v18, "%.*s.", v23, v17 + 1);
          if ((v25 & 0x80000000) != 0 || v24 - v18 <= v25) {
            break;
          }
          v18 += v25;
          uint32_t v26 = (unsigned __int8 *)&v17[*(unsigned __int8 *)v17];
          int v27 = v26[1];
          uint32_t v17 = (const char *)(v26 + 1);
          int v23 = v27;
          if (!v27) {
            goto LABEL_9;
          }
        }

        int v28 = -1;
      }

      else
      {
LABEL_9:
        int v28 = (_DWORD)v18 - (_DWORD)v16;
      }

      a3 = v22;
      a2 = v21;
      a4 = v20;
      a1 = v19;
      uint64_t v15 = v62;
      if ((v62[346] & 0x20) != 0)
      {
LABEL_30:
        os_unfair_lock_lock((os_unfair_lock_t)v15 + 3);
        if (!a1 || !v16 || v28 < 0 || *((_DNSServiceRef_t **)v15 + 9) != a1)
        {
          if ((v15[346] & 0x20) != 0) {
            goto LABEL_44;
          }
          if (v15[256])
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            unint64_t v39 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_43;
            }
            uint64_t v40 = *((void *)v15 + 9);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
            __int16 v76 = 2082;
            *(void *)os_log_type_t v77 = v15 + 256;
            *(_WORD *)&os_log_type_t v77[8] = 2048;
            *(void *)&v77[10] = a1;
            *(_WORD *)&v77[18] = 2048;
            *(void *)&v77[20] = v15;
            *(_WORD *)&v77[28] = 2048;
            *(void *)&v77[30] = v40;
            uint32_t v41 = "%{public}s [C%{public}s] Skipped, service %p, resolver %p -> %p";
            int v42 = v39;
            uint32_t v43 = 52;
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            unint64_t v39 = (os_log_s *)(id)gLogObj;
            if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
            {
LABEL_43:

LABEL_44:
              os_unfair_lock_unlock((os_unfair_lock_t)v15 + 3);
              if (!v16) {
                goto LABEL_76;
              }
              goto LABEL_75;
            }

            int v44 = *((_DWORD *)v15 + 85);
            uint64_t v45 = *((void *)v15 + 9);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
            __int16 v76 = 1024;
            *(_DWORD *)os_log_type_t v77 = v44;
            *(_WORD *)&v77[4] = 2048;
            *(void *)&v77[6] = a1;
            *(_WORD *)&v77[14] = 2048;
            *(void *)&v77[16] = v15;
            *(_WORD *)&_BYTE v77[24] = 2048;
            *(void *)&v77[26] = v45;
            uint32_t v41 = "%{public}s [R%u] Skipped, service %p, resolver %p -> %p";
            int v42 = v39;
            uint32_t v43 = 48;
          }

          _os_log_impl(&dword_181A5C000, v42, OS_LOG_TYPE_DEBUG, v41, buf, v43);
          goto LABEL_43;
        }

        if (a4)
        {
          if (a4 != -65554)
          {
            if (a4 != -65569 || *((_DWORD *)v15 + 2) == 2) {
              goto LABEL_74;
            }
            if ((v15[346] & 0x20) != 0) {
              goto LABEL_73;
            }
            if (v15[256])
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              int v46 = (os_log_s *)(id)gconnectionLogObj;
              if (!os_log_type_enabled(v46, OS_LOG_TYPE_INFO)) {
                goto LABEL_72;
              }
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
              __int16 v76 = 2082;
              *(void *)os_log_type_t v77 = v15 + 256;
              *(_WORD *)&os_log_type_t v77[8] = 2048;
              *(void *)&v77[10] = v15;
              id v47 = "%{public}s [C%{public}s] restarting resolver %p, defunct connection";
              unint64_t v48 = v46;
              uint32_t v49 = 32;
            }

            else
            {
              __nwlog_obj();
              int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
              {
LABEL_72:

LABEL_73:
                nw_resolver_restart_dns_service_locked((NWConcrete_nw_resolver *)v15);
                goto LABEL_74;
              }

              int v56 = *((_DWORD *)v15 + 85);
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_resolver_ptr_resolve_callback";
              __int16 v76 = 1024;
              *(_DWORD *)os_log_type_t v77 = v56;
              *(_WORD *)&v77[4] = 2048;
              *(void *)&v77[6] = v15;
              id v47 = "%{public}s [R%u] restarting resolver %p, defunct connection";
              unint64_t v48 = v46;
              uint32_t v49 = 28;
            }

            _os_log_impl(&dword_181A5C000, v48, OS_LOG_TYPE_INFO, v47, buf, v49);
            goto LABEL_72;
          }

          if ((*((_WORD *)v15 + 44) & 1) == 0)
          {
            *((_WORD *)v15 + 44) = 1;
LABEL_62:
            nw_resolver_update_status_locked(v15, 0LL);
          }
        }

        else if (a6 == 12)
        {
          if ((a2 & 2) != 0)
          {
            *((_WORD *)v15 + 44) = 4;
            unsigned int port = nw_endpoint_get_port(*((nw_endpoint_t *)v15 + 3));
            BOOL host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(v16, port);
            nw_endpoint_set_parent_endpoint((void *)host_with_numeric_port, *((void **)v15 + 3), 0);
            *(void *)int buf = 0LL;
            ValidationData = (const void *)DNSServiceGetValidationData();
            if (ValidationData && *(void *)buf) {
              nw_endpoint_set_signature((void *)host_with_numeric_port, ValidationData, *(size_t *)buf);
            }
            if (!nw_resolver_set_interface_on_endpoint(v15, a3, (void *)host_with_numeric_port))
            {

              goto LABEL_74;
            }

            v68[0] = MEMORY[0x1895F87A8];
            v68[1] = 3221225472LL;
            void v68[2] = ___ZL32nw_resolver_ptr_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke;
            v68[3] = &unk_189BB6D38;
            BOOL v70 = v16;
            uint64_t v69 = v15;
            unsigned int v71 = a3;
            char v72 = (a2 & 2) >> 1;
            BOOL inserted = nw_resolver_insert_endpoint_locked(v69, (void *)host_with_numeric_port, v68);

            if (!inserted) {
              goto LABEL_74;
            }
          }

          else
          {
            uint64_t v50 = MEMORY[0x1895F87A8];
            *((_WORD *)v15 + 44) = 0;
            v63[0] = v50;
            v63[1] = 3221225472LL;
            v63[2] = ___ZL32nw_resolver_ptr_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke_2;
            void v63[3] = &unk_189BB6D38;
            size_t v65 = v16;
            char v64 = v15;
            unsigned int v66 = a3;
            char v67 = 0;
            BOOL v51 = nw_resolver_remove_endpoint_locked(v64, v63);

            if (!v51) {
              goto LABEL_74;
            }
          }

          goto LABEL_62;
        }

void sub_181D9B2C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_resolver_create_dns_service_lockedP22NWConcrete_nw_resolver_block_invoke_238( uint64_t a1, int a2, unsigned int *a3)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12LL));
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = a3;
      os_log_type_t v9 = "%{public}s Received %d NAT64 prefixes [%p]";
      BOOL v10 = v7;
      uint32_t v11 = 28;
LABEL_12:
      _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, v9, buf, v11);
    }

void sub_181D9BB2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_srv_resolve_callback( _DNSServiceRef_t *a1, int a2, unsigned int a3, int a4, const char *a5, int a6, int a7, unsigned int a8, unsigned __int16 *a9, unsigned int a10, void *a11)
{
  uint64_t v88 = *MEMORY[0x1895F89C0];
  nw_endpoint_t v17 = a11;
  nw_endpoint_t v18 = v17;
  if (!v17)
  {
    __nwlog_obj();
    os_log_type_t v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
    int v54 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (__nwlog_fault(v54, type, &v80))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v56 = type[0];
        if (os_log_type_enabled(v55, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
          _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s called with null resolver", buf, 0xCu);
        }
      }

      else if (v80)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v58 = type[0];
        BOOL v59 = os_log_type_enabled(v55, type[0]);
        if (backtrace_string)
        {
          if (v59)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
            __int16 v82 = 2082;
            *(void *)unsigned int v83 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v55,  v58,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_110;
        }

        if (v59)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
          _os_log_impl(&dword_181A5C000, v55, v58, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v60 = type[0];
        if (os_log_type_enabled(v55, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
          _os_log_impl( &dword_181A5C000,  v55,  v60,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181D9C984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_restart_dns_service_locked(NWConcrete_nw_resolver *a1)
{
  uint64_t v3 = a1;
  nw_resolver_cancel_query_locked(v3, 1);
  nw_resolver_cancel_delayed_reporting_timer(v3);
  nw_resolver_cancel_query_timer(v3);
  BOOL v1 = nw_array_create();
  int v2 = (void *)*((void *)v3 + 18);
  *((void *)v3 + 1_Block_object_dispose(va, 8) = v1;

  *((_DWORD *)v3 + 62) = 0;
  nw_resolver_create_dns_service_locked(v3);
}

void sub_181D9CA1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t nw_resolver_parse_rdata(char *__str, uint64_t a2, const unsigned __int8 **a3)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  id v4 = *a3;
  if (!*a3) {
    return 0xFFFFFFFFLL;
  }
  int v5 = (int)__str;
  int v6 = *v4;
  if (*v4)
  {
    os_log_type_t v7 = &__str[a2];
    uint64_t v8 = __str;
    while (1)
    {
      unsigned int v9 = snprintf(v8, v7 - v8, "%.*s.", v6, (const char *)v4 + 1);
      if ((v9 & 0x80000000) != 0 || v7 - v8 <= v9) {
        return 0xFFFFFFFFLL;
      }
      v8 += v9;
      id v4 = &(*a3)[**a3 + 1];
      *a3 = v4;
      int v6 = *v4;
      if (!*v4) {
        goto LABEL_12;
      }
    }
  }

  LODWORD(v_Block_object_dispose(va, 8) = (_DWORD)__str;
LABEL_12:
  *a3 = v4 + 1;
  return ((_DWORD)v8 - v5);
}

BOOL nw_resolver_set_interface_on_endpoint(void *a1, unsigned int a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  id v6 = a3;
  if (a2 - 1 <= 0xFFFFFFFD)
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    }
    id v7 = (id)nw_context_copy_implicit_context::implicit_context;
    uint64_t v8 = nw_path_copy_interface_with_generation(v7, a2, 0);

    BOOL v9 = v8 != 0LL;
    if (v8)
    {
      nw_endpoint_set_interface(v6, v8);
LABEL_20:

      goto LABEL_21;
    }

    if (v5)
    {
      if ((v5[346] & 0x20) != 0) {
        goto LABEL_20;
      }
      if (v5[256])
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v10 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          goto LABEL_19;
        }
        int v16 = 136446978;
        nw_endpoint_t v17 = "nw_resolver_set_interface_on_endpoint";
        __int16 v18 = 2082;
        *(void *)uint64_t v19 = v5 + 256;
        *(_WORD *)&v19[8] = 2082;
        *(void *)&v19[10] = nw_endpoint_get_logging_description(v6);
        *(_WORD *)&v19[18] = 1024;
        unsigned int v20 = a2;
        uint32_t v11 = "%{public}s [C%{public}s] Not adding the endpoint %{public}s on interface %u to array due to invalid interface";
        int v12 = v10;
        uint32_t v13 = 38;
        goto LABEL_18;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        int v14 = *((_DWORD *)v5 + 85);
        int v16 = 136446978;
        nw_endpoint_t v17 = "nw_resolver_set_interface_on_endpoint";
        __int16 v18 = 1024;
        *(_DWORD *)uint64_t v19 = v14;
        *(_WORD *)&v19[4] = 2082;
        *(void *)&v19[6] = nw_endpoint_get_logging_description(v6);
        *(_WORD *)&v19[14] = 1024;
        *(_DWORD *)&v19[16] = a2;
        uint32_t v11 = "%{public}s [R%u] Not adding the endpoint %{public}s on interface %u to array due to invalid interface";
        int v12 = v10;
        uint32_t v13 = 34;
        goto LABEL_18;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        int v16 = 136446722;
        nw_endpoint_t v17 = "nw_resolver_set_interface_on_endpoint";
        __int16 v18 = 2082;
        *(void *)uint64_t v19 = nw_endpoint_get_logging_description(v6);
        *(_WORD *)&v19[8] = 1024;
        *(_DWORD *)&v19[10] = a2;
        uint32_t v11 = "%{public}s Not adding the endpoint %{public}s on interface %u to array due to invalid interface";
        int v12 = v10;
        uint32_t v13 = 28;
LABEL_18:
        _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v16, v13);
      }
    }

void sub_181D9CDF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_resolver_srv_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke( uint64_t a1, void *a2)
{
  return nw_endpoint_host_endpoint_matches_hostname( a2,  *(const char **)(a1 + 32),  bswap32(*(unsigned __int16 *)(a1 + 48)) >> 16,  *(_DWORD *)(a1 + 40),  1);
}

BOOL nw_resolver_insert_endpoint_locked(void *a1, void *a2, void *a3)
{
  int v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v28 = 0LL;
  int v29 = &v28;
  uint64_t v30 = 0x2020000000LL;
  char v31 = 1;
  uint64_t v24 = 0LL;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000LL;
  char v27 = 0;
  BOOL v8 = nw_array_create();
  BOOL v9 = v5 + 18;
  BOOL v10 = (unsigned __int8 *)v5[18];
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3221225472LL;
  v17[2] = ___ZL34nw_resolver_insert_endpoint_lockedP22NWConcrete_nw_resolverPU25objcproto14OS_nw_endpoint8NSObjectU13block_pointerFbS3_S3_E_block_invoke;
  v17[3] = &unk_189BB6960;
  id v11 = v7;
  id v21 = v11;
  id v12 = v6;
  id v18 = v12;
  uint32_t v22 = &v24;
  int v23 = &v28;
  uint32_t v13 = v5;
  uint64_t v19 = v13;
  id v14 = (id)v8;
  id v20 = v14;
  nw_array_apply(v10, (uint64_t)v17);
  int v15 = *((unsigned __int8 *)v29 + 24);
  if (*((_BYTE *)v29 + 24))
  {
    if (!*((_BYTE *)v25 + 24)) {
      nw_array_append((uint64_t)v14, v12);
    }
    objc_storeStrong(v9, (id)v8);
  }

  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);

  return v15 != 0;
}

uint64_t ___ZL32nw_resolver_srv_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke_2( uint64_t a1, void *a2)
{
  return nw_endpoint_host_endpoint_matches_hostname( a2,  *(const char **)(a1 + 32),  bswap32(*(unsigned __int16 *)(a1 + 48)) >> 16,  *(_DWORD *)(a1 + 40),  1);
}

BOOL nw_resolver_remove_endpoint_locked(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v16 = 0LL;
  nw_endpoint_t v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  char v19 = 0;
  BOOL v5 = nw_array_create();
  id v6 = (unsigned __int8 *)v3[18];
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = ___ZL34nw_resolver_remove_endpoint_lockedP22NWConcrete_nw_resolverPU25objcproto14OS_nw_endpoint8NSObjectU13block_pointerFbS3_S3_E_block_invoke;
  v11[3] = &unk_189BB6C18;
  id v7 = v4;
  id v14 = v7;
  int v15 = &v16;
  id v12 = 0LL;
  id v8 = (id)v5;
  id v13 = v8;
  nw_array_apply(v6, (uint64_t)v11);
  int v9 = *((unsigned __int8 *)v17 + 24);
  if (*((_BYTE *)v17 + 24)) {
    objc_storeStrong(v3 + 18, (id)v5);
  }

  _Block_object_dispose(&v16, 8);
  return v9 != 0;
}

uint64_t ___ZL34nw_resolver_remove_endpoint_lockedP22NWConcrete_nw_resolverPU25objcproto14OS_nw_endpoint8NSObjectU13block_pointerFbS3_S3_E_block_invoke( uint64_t *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  else {
    nw_array_append(a1[5], v4);
  }

  return 1LL;
}

void sub_181D9D178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL34nw_resolver_insert_endpoint_lockedP22NWConcrete_nw_resolverPU25objcproto14OS_nw_endpoint8NSObjectU13block_pointerFbS3_S3_E_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  if (!(*(unsigned int (**)(void))(*(void *)(a1 + 56) + 16LL))())
  {
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL))
    {
LABEL_45:
      nw_array_append(*(void *)(a1 + 48), v4);
      goto LABEL_46;
    }

    id v6 = *(void **)(a1 + 32);
    id v7 = (char *)*(id *)(a1 + 40);
    id v8 = v6;
    int v9 = (nw_endpoint *)v4;
    nw_endpoint_type_t type = nw_endpoint_get_type(v8);
    nw_endpoint_type_t v11 = nw_endpoint_get_type(v9);
    if (type == v11)
    {
      unsigned int priority = nw_endpoint_get_priority(v8);
      unsigned int v13 = nw_endpoint_get_priority(v9);
      if (nw_endpoint_get_type(*((nw_endpoint_t *)v7 + 3)) == 5)
      {
        if (priority && v13 && priority != v13)
        {
LABEL_22:

          if (priority >= v13) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }
      }

      else if (priority != v13)
      {
        if (priority)
        {

          goto LABEL_44;
        }

        goto LABEL_36;
      }

      unsigned int priority = nw_endpoint_get_weight(v8);
      unsigned int weight = nw_endpoint_get_weight(v9);
      if (priority)
      {
        unsigned int v13 = weight;
        if (weight)
        {
          if (priority != weight) {
            goto LABEL_22;
          }
        }
      }

      if (type == nw_endpoint_type_address)
      {
        char v19 = nw_endpoint_copy_interface(v8);
        id v20 = nw_endpoint_copy_interface(v9);
        uint64_t v21 = *((void *)v7 + 26);
        if (v21) {
          int required_interface_index = *(_DWORD *)(v21 + 8);
        }
        else {
          int required_interface_index = nw_parameters_get_required_interface_index(*((void **)v7 + 2));
        }
        int v24 = required_interface_index;
        if (v19) {
          int v24 = v19[2];
        }
        int v29 = v19;
        if (v20) {
          int required_interface_index = v20[2];
        }
        nw_endpoint_t address = (sockaddr *)nw_endpoint_get_address(v8);
        uint64_t v26 = (sockaddr *)nw_endpoint_get_address(v9);
        int ignore_resolver_stats = nw_parameters_get_ignore_resolver_stats(*((void **)v7 + 2));
        LODWORD(v26) = sa_dst_compare_internal( &address->sa_len,  v24,  &v26->sa_len,  required_interface_index,  ignore_resolver_stats ^ 1u);

        if ((int)v26 >= 1)
        {

LABEL_44:
          nw_array_append(*(void *)(a1 + 48), *(void **)(a1 + 32));
          *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 1;
          goto LABEL_45;
        }
      }

void sub_181D9D5E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void nw_resolver_cancel_query_timer(NWConcrete_nw_resolver *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  int v2 = a1;
  uint64_t v3 = *((void *)v2 + 16);
  if (!v3) {
    goto LABEL_13;
  }
  if ((*((_BYTE *)v2 + 346) & 0x20) != 0)
  {
LABEL_12:
    nw_queue_cancel_source(v3, v1);
    *((void *)v2 + 16) = 0LL;
    goto LABEL_13;
  }

  if (!*((_BYTE *)v2 + 256))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_11;
    }
    int v9 = *((_DWORD *)v2 + 85);
    logging_description = nw_endpoint_get_logging_description(*((void **)v2 + 3));
    int v11 = 136446722;
    id v12 = "nw_resolver_cancel_query_timer";
    __int16 v13 = 1024;
    *(_DWORD *)id v14 = v9;
    *(_WORD *)&v14[4] = 2082;
    *(void *)&void v14[6] = logging_description;
    id v6 = "%{public}s [R%u] Cancelling query timer for %{public}s";
    id v7 = v4;
    uint32_t v8 = 28;
    goto LABEL_10;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  id v4 = (os_log_s *)(id)gconnectionLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = nw_endpoint_get_logging_description(*((void **)v2 + 3));
    int v11 = 136446722;
    id v12 = "nw_resolver_cancel_query_timer";
    __int16 v13 = 2082;
    *(void *)id v14 = (char *)v2 + 256;
    *(_WORD *)&v14[8] = 2082;
    *(void *)&v14[10] = v5;
    id v6 = "%{public}s [C%{public}s] Cancelling query timer for %{public}s";
    id v7 = v4;
    uint32_t v8 = 32;
LABEL_10:
    _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, v6, (uint8_t *)&v11, v8);
  }

void sub_181D9D7F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_resolver_ptr_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke( uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(const char **)(a1 + 40);
  unsigned int port = nw_endpoint_get_port(*(nw_endpoint_t *)(*(void *)(a1 + 32) + 24LL));
  uint64_t v6 = nw_endpoint_host_endpoint_matches_hostname( v3,  v4,  __rev16(port),  *(_DWORD *)(a1 + 48),  *(unsigned __int8 *)(a1 + 52));

  return v6;
}

void sub_181D9D878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_resolver_ptr_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke_2( uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(const char **)(a1 + 40);
  unsigned int port = nw_endpoint_get_port(*(nw_endpoint_t *)(*(void *)(a1 + 32) + 24LL));
  uint64_t v6 = nw_endpoint_host_endpoint_matches_hostname( v3,  v4,  __rev16(port),  *(_DWORD *)(a1 + 48),  *(unsigned __int8 *)(a1 + 52));

  return v6;
}

void sub_181D9D8E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_resolver_bonjour_resolve_callbackP16_DNSServiceRef_tjjiPKcS2_ttPKhPv_block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 346) & 0x20) != 0) {
      goto LABEL_14;
    }
    if (*(_BYTE *)(v2 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v3 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_13;
      }
      uint64_t v4 = *(void *)(a1 + 32) + 256LL;
      *(_DWORD *)int buf = 136446466;
      uint64_t v25 = "nw_resolver_bonjour_resolve_callback_block_invoke";
      __int16 v26 = 2082;
      uint64_t v27 = v4;
      uint64_t v5 = "%{public}s [C%{public}s] Weighting timer timed out";
      uint64_t v6 = v3;
      uint32_t v7 = 22;
      goto LABEL_12;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *(_DWORD *)(*(void *)(a1 + 32) + 340LL);
      *(_DWORD *)int buf = 136446466;
      uint64_t v25 = "nw_resolver_bonjour_resolve_callback_block_invoke";
      __int16 v26 = 1024;
      LODWORD(v27) = v8;
      uint64_t v5 = "%{public}s [R%u] Weighting timer timed out";
      uint64_t v6 = v3;
      uint32_t v7 = 18;
      goto LABEL_12;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v25 = "nw_resolver_bonjour_resolve_callback_block_invoke";
      uint64_t v5 = "%{public}s Weighting timer timed out";
      uint64_t v6 = v3;
      uint32_t v7 = 12;
LABEL_12:
      _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, v5, buf, v7);
    }
  }

void sub_181D9DD48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

uint64_t ___ZL36nw_resolver_bonjour_resolve_callbackP16_DNSServiceRef_tjjiPKcS2_ttPKhPv_block_invoke_258( uint64_t a1, void *a2, void *a3)
{
  return nw_endpoint_is_equal(a2, a3, 1LL);
}

uint64_t ___ZL36nw_resolver_bonjour_resolve_callbackP16_DNSServiceRef_tjjiPKcS2_ttPKhPv_block_invoke_254( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  uint64_t v5 = *(_BYTE **)(a1 + 32);
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v13 = 136446466;
      id v14 = "nw_resolver_bonjour_resolve_callback_block_invoke";
      __int16 v15 = 2112;
      *(void *)uint64_t v16 = v4;
      int v8 = "%{public}s Inserting non-preferred host endpoint %@";
      int v9 = v6;
      uint32_t v10 = 22;
LABEL_12:
      _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_INFO, v8, (uint8_t *)&v13, v10);
    }

uint64_t ___ZL36nw_resolver_bonjour_resolve_callbackP16_DNSServiceRef_tjjiPKcS2_ttPKhPv_block_invoke_255( uint64_t a1, void *a2, void *a3)
{
  return nw_endpoint_is_equal(a2, a3, 1LL);
}

void ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke_2(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 8) != 2)
  {
    if ((*(_BYTE *)(v2 + 346) & 0x20) != 0)
    {
LABEL_12:
      nw_resolver_restart_dns_service_locked((NWConcrete_nw_resolver *)v2);
      return;
    }

    if (*(_BYTE *)(v2 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v3 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_INFO)) {
        goto LABEL_11;
      }
      uint64_t v4 = *(void *)(a1 + 32);
      int v10 = 136446722;
      int v11 = "nw_resolver_should_wait_for_awdl_trigger_block_invoke";
      __int16 v12 = 2082;
      *(void *)int v13 = v4 + 256;
      *(_WORD *)&v13[8] = 2048;
      *(void *)&v13[10] = v4;
      uint64_t v5 = "%{public}s [C%{public}s] restarting resolver %p, AWDL trigger browse found endpoint";
      uint64_t v6 = v3;
      uint32_t v7 = 32;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
LABEL_11:

        uint64_t v2 = *(void *)(a1 + 32);
        goto LABEL_12;
      }

      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = *(_DWORD *)(v8 + 340);
      int v10 = 136446722;
      int v11 = "nw_resolver_should_wait_for_awdl_trigger_block_invoke";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = v9;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&void v13[6] = v8;
      uint64_t v5 = "%{public}s [R%u] restarting resolver %p, AWDL trigger browse found endpoint";
      uint64_t v6 = v3;
      uint32_t v7 = 28;
    }

    _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_INFO, v5, (uint8_t *)&v10, v7);
    goto LABEL_11;
  }

void ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke_243(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 8) != 2)
  {
    if ((*(_BYTE *)(v2 + 346) & 0x20) != 0)
    {
LABEL_12:
      nw_resolver_restart_dns_service_locked((NWConcrete_nw_resolver *)v2);
      return;
    }

    if (*(_BYTE *)(v2 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v3 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_INFO)) {
        goto LABEL_11;
      }
      uint64_t v4 = *(void *)(a1 + 32);
      int v10 = 136446722;
      int v11 = "nw_resolver_should_wait_for_awdl_trigger_block_invoke";
      __int16 v12 = 2082;
      *(void *)int v13 = v4 + 256;
      *(_WORD *)&v13[8] = 2048;
      *(void *)&v13[10] = v4;
      uint64_t v5 = "%{public}s [C%{public}s] restarting resolver %p, AWDL trigger browse failed";
      uint64_t v6 = v3;
      uint32_t v7 = 32;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
LABEL_11:

        uint64_t v2 = *(void *)(a1 + 32);
        goto LABEL_12;
      }

      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = *(_DWORD *)(v8 + 340);
      int v10 = 136446722;
      int v11 = "nw_resolver_should_wait_for_awdl_trigger_block_invoke";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = v9;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&void v13[6] = v8;
      uint64_t v5 = "%{public}s [R%u] restarting resolver %p, AWDL trigger browse failed";
      uint64_t v6 = v3;
      uint32_t v7 = 28;
    }

    _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_INFO, v5, (uint8_t *)&v10, v7);
    goto LABEL_11;
  }

void nw_resolver_update_flags_locked( NWConcrete_nw_resolver *a1, NWConcrete_nw_resolver_service *a2, int a3, int a4, const sockaddr *a5, int a6, int a7)
{
  int v44 = a1;
  int v13 = a2;
  uint64_t v14 = v44;
  __int16 v15 = *((_WORD *)v44 + 44) & 0xFFEF | (16 * (a3 & 1));
  *((_WORD *)v44 + 44) = v15;
  if ((*((_BYTE *)v44 + 347) & 2) == 0)
  {
    v15 |= 0x80u;
    *((_WORD *)v44 + 44) = v15;
  }

  if (!a5) {
    goto LABEL_32;
  }
  int sa_family = a5->sa_family;
  if ((a3 & 0x40000000) != 0 && sa_family == 2)
  {
    char v17 = 4;
LABEL_10:
    *((_BYTE *)v44 + 346) |= v17;
    int sa_family = a5->sa_family;
    goto LABEL_11;
  }

  if ((a3 & 0x40000000) != 0 && sa_family == 30)
  {
    char v17 = 8;
    goto LABEL_10;
  }

BOOL nw_resolver_should_scope_address(const sockaddr *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v12 = "nw_resolver_should_scope_address";
    id v3 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v12 = "nw_resolver_should_scope_address";
        uint64_t v6 = "%{public}s called with null addr";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v12 = "nw_resolver_should_scope_address";
            __int16 v13 = 2082;
            uint64_t v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null addr, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (!v8) {
          goto LABEL_22;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v12 = "nw_resolver_should_scope_address";
        uint64_t v6 = "%{public}s called with null addr, no backtrace";
        goto LABEL_21;
      }

      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v12 = "nw_resolver_should_scope_address";
        uint64_t v6 = "%{public}s called with null addr, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

uint64_t ___ZL33nw_resolver_host_resolve_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke( uint64_t a1, void *a2)
{
  return nw_endpoint_address_endpoint_matches_address( a2,  *(unsigned __int8 **)(a1 + 32),  *(_DWORD *)(a1 + 40),  *(unsigned __int8 *)(a1 + 44));
}

uint64_t ___ZL33nw_resolver_host_resolve_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke_2( uint64_t a1, void *a2)
{
  return nw_endpoint_address_endpoint_matches_address( a2,  *(unsigned __int8 **)(a1 + 32),  *(_DWORD *)(a1 + 40),  *(unsigned __int8 *)(a1 + 44));
}

uint64_t ___ZL35nw_resolver_remove_sa_family_lockedP22NWConcrete_nw_resolverh_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (nw_endpoint_get_type((nw_endpoint_t)v4) == nw_endpoint_type_address
    && nw_endpoint_get_address_family(v4) == *(unsigned __int8 *)(a1 + 48))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  else
  {
    nw_array_append(*(void *)(a1 + 32), v4);
  }

  return 1LL;
}

void sub_181D9EA60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (nw_endpoint_get_type((nw_endpoint_t)v4) == nw_endpoint_type_address
    && nw_endpoint_get_address_family(v4) == 2)
  {
    os_log_type_t v5 = *(void **)(*(void *)(a1 + 32) + 200LL);
    v10[0] = MEMORY[0x1895F87A8];
    v10[1] = 3221225472LL;
    v10[2] = ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_2;
    v10[3] = &unk_189BB6A48;
    id v6 = v4;
    uint64_t v7 = *(void *)(a1 + 40);
    id v11 = v6;
    uint64_t v12 = v7;
    nw_path_enumerate_resolver_configs(v5, v10);
  }

  BOOL v8 = *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) == 0;

  return v8;
}

void sub_181D9EB38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_189( void *a1, int a2, int a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)(a1[4] + 12LL));
  switch(a2)
  {
    case 3:
      uint64_t v21 = a1[4];
      uint32_t v22 = (NWConcrete_nw_resolver_service *)a1[5];
      if (v22)
      {
        if (v21)
        {
          if ((*(_BYTE *)(v21 + 346) & 0x20) != 0)
          {
LABEL_53:
            nw_resolver_service_cancel_query(v22);
            break;
          }

          if (*(_BYTE *)(v21 + 256))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v23 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v23, OS_LOG_TYPE_INFO)) {
              goto LABEL_52;
            }
            uint64_t v24 = a1[5];
            uint64_t v25 = a1[4] + 256LL;
            int v52 = 136446722;
            os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 2082;
            *(void *)os_log_type_t v55 = v25;
            *(_WORD *)&v55[8] = 2114;
            *(void *)&v55[10] = v24;
            __int16 v26 = "%{public}s [C%{public}s] Invalidating getaddrinfo DNS object for %{public}@";
            int v27 = v23;
            uint32_t v28 = 32;
            goto LABEL_51;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v23 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            uint64_t v39 = a1[5];
            int v40 = *(_DWORD *)(a1[4] + 340LL);
            int v52 = 136446722;
            os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 1024;
            *(_DWORD *)os_log_type_t v55 = v40;
            *(_WORD *)&v55[4] = 2114;
            *(void *)&v55[6] = v39;
            __int16 v26 = "%{public}s [R%u] Invalidating getaddrinfo DNS object for %{public}@";
            int v27 = v23;
            uint32_t v28 = 28;
            goto LABEL_51;
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v23 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = a1[5];
            int v52 = 136446466;
            os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v54 = 2114;
            *(void *)os_log_type_t v55 = v36;
            __int16 v26 = "%{public}s Invalidating getaddrinfo DNS object for %{public}@";
            int v27 = v23;
            uint32_t v28 = 22;
LABEL_51:
            _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_INFO, v26, (uint8_t *)&v52, v28);
          }
        }

void sub_181D9F5B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_191( id *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  if (WeakRetained && v3 && v3[3] - v3[2] == 8LL)
  {
    uint64_t v5 = nw_array_get_object_at_index((uint64_t)v3, 0LL);
    id v6 = (void *)v5;
    if (!v5 || (uint64_t v7 = *(void *)(v5 + 24) - *(void *)(v5 + 16)) == 0)
    {
LABEL_22:

      goto LABEL_23;
    }

    uint64_t v8 = v7 >> 3;
    char v9 = (os_unfair_lock_s *)a1[4];
    if (v9)
    {
      if ((v9[86]._os_unfair_lock_opaque & 0x200000) != 0)
      {
LABEL_19:
        os_unfair_lock_lock(v9 + 3);
        uint64_t v16 = MEMORY[0x1895F87A8];
        v19[0] = MEMORY[0x1895F87A8];
        v19[1] = 3221225472LL;
        void v19[2] = ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_192;
        v19[3] = &unk_189BC5030;
        id v20 = a1[4];
        id v21 = a1[5];
        nw_array_apply((unsigned __int8 *)v6, (uint64_t)v19);
        id v17 = a1[4];
        uint64_t v22 = 0LL;
        id v23 = &v22;
        uint64_t v24 = 0x2020000000LL;
        char v25 = 0;
        char v18 = (unsigned __int8 *)*((void *)v17 + 22);
        *(void *)int buf = v16;
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = ___ZL31nw_resolver_check_svcb_completeP22NWConcrete_nw_resolver_block_invoke;
        *(void *)&_BYTE buf[24] = &unk_189BC50D0;
        int v27 = &v22;
        nw_array_apply(v18, (uint64_t)buf);
        if (!*((_BYTE *)v23 + 24)) {
          *((_WORD *)v17 + 44) |= 0x80u;
        }
        _Block_object_dispose(&v22, 8);

        nw_resolver_update_status_locked(a1[4], 0LL);
        os_unfair_lock_unlock((os_unfair_lock_t)a1[4] + 3);

        goto LABEL_22;
      }

      if (LOBYTE(v9[64]._os_unfair_lock_opaque))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v10 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_INFO)) {
          goto LABEL_18;
        }
        uint64_t v11 = (uint64_t)a1[4] + 256;
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v11;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&_BYTE buf[24] = v8;
        uint64_t v12 = "%{public}s [C%{public}s] Got %zu expired DNS results from storage cache";
        __int16 v13 = v10;
        uint32_t v14 = 32;
        goto LABEL_17;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        int v15 = *((_DWORD *)a1[4] + 85);
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v8;
        uint64_t v12 = "%{public}s [R%u] Got %zu expired DNS results from storage cache";
        __int16 v13 = v10;
        uint32_t v14 = 28;
        goto LABEL_17;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = v8;
        uint64_t v12 = "%{public}s Got %zu expired DNS results from storage cache";
        __int16 v13 = v10;
        uint32_t v14 = 22;
LABEL_17:
        _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_INFO, v12, buf, v14);
      }
    }

void sub_181D9F954( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_2_194( uint64_t a1, id *a2, uint64_t a3)
{
  uint64_t v304 = *MEMORY[0x1895F89C0];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (!WeakRetained) {
    goto LABEL_457;
  }
  id v267 = WeakRetained;
  uint64_t v278 = a1;
  uint64_t v5 = *(void *)(a1 + 32);
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)&buf[0].int sa_len = 136446466;
      *(void *)&buf[0].sa_data[2] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke_2";
      *(_WORD *)&buf[0].sa_data[10] = 2048;
      *(void *)&buf[0].sa_data[12] = a3;
      uint64_t v8 = "%{public}s Got %zu DNS results";
      char v9 = v6;
      uint32_t v10 = 22;
LABEL_13:
      _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_INFO, v8, &buf[0].sa_len, v10);
    }

LABEL_435:
        if (v253) {
          free(v253);
        }
        BOOL v128 = 0LL;
        goto LABEL_308;
      }

      *(void *)v299 = v92;
      *(void *)&v299[8] = &OBJC_CLASS___NWConcrete_nw_resolver_service;
      id object = (unsigned __int16 *)objc_msgSendSuper2((objc_super *)v299, sel_init);
      if (object)
      {
        if (v93)
        {
          id v94 = v93;
          int v95 = [v94 type];

          if (v95 == 2)
          {
            id v96 = v94;
            unsigned int v97 = (const char *)[v96 hostname];

            if (v97)
            {
              object[16] = service_priority;
              char v98 = object[24] & 0xFE | sensitive_redacted;
              *((_BYTE *)object + 4_Block_object_dispose(va, 8) = v98;
              char v99 = v98 & 0xFD | (2 * (strcmp(v97, service_name) == 0));
              *((_BYTE *)object + 4_Block_object_dispose(va, 8) = v99;
              if (service_port)
              {
                id v100 = v96;
                unsigned int v101 = [v100 port];

                uint64_t v102 = (void **)object;
                *((_BYTE *)object + 4_Block_object_dispose(va, 8) = object[24] & 0xFB | (4 * (__rev16(v101) == service_port));
              }

              else
              {
                *((_BYTE *)object + 4_Block_object_dispose(va, 8) = v99 | 4;
                id v116 = v96;
                unsigned int v117 = [v116 port];

                service_int port = __rev16(v117);
                uint64_t v102 = (void **)object;
              }

              *((_WORD *)v102 + 17) = service_port;
              id v118 = v102;
              BOOL host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(service_name, service_port);
              int v120 = v118[1];
              *++id v118 = (void *)host_with_numeric_port;

              os_log_type_t v121 = *v118;
              BOOL v122 = object;
              nw_endpoint_set_priority(v121, object[16]);
              if (!sensitive_redacted) {
                nw_endpoint_set_do_not_redact(*((void **)object + 1));
              }
              if ((object[24] & 4) == 0)
              {
                if (object[16])
                {
                  BOOL v123 = nw_endpoint_create_host_with_numeric_port(v97, object[17]);
                  os_log_type_t v124 = (void *)*((void *)object + 2);
                  *((void *)object + 2) = v123;

                  BOOL v122 = object;
                  nw_endpoint_set_priority(*((void **)object + 2), object[16]);
                  if (!sensitive_redacted) {
                    nw_endpoint_set_do_not_redact(*((void **)object + 2));
                  }
                }
              }

              if (v89 && ech_config && v122[16])
              {
                dispatch_data_t v125 = dispatch_data_create(ech_config, v89, 0LL, 0LL);
                BOOL v126 = (void *)*((void *)v122 + 5);
                *((void *)v122 + 5) = v125;
              }

              if (v270)
              {
                nw_browser_t v127 = v274;
                BOOL v128 = (NWConcrete_nw_resolver_service *)object;
                if (v270[16])
                {
                  if ((v274[346] & 0x20) == 0)
                  {
                    if (v274[256])
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      os_log_type_t v129 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)&buf[0].int sa_len = 136446978;
                        *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                        *(_WORD *)&buf[0].sa_data[10] = 2082;
                        *(void *)&buf[0].sa_data[12] = v274 + 256;
                        *(_WORD *)&buf[1].sa_data[4] = 2114;
                        *(void *)&buf[1].sa_data[6] = object;
                        *(_WORD *)&buf[2].int sa_len = 2114;
                        *(void *)buf[2].sa_data = v270;
                        _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s] Ignoring service %{public}@ with parent %{public}@, should not receiv e nested services for non-alias services",  &buf[0].sa_len,  0x2Au);
                      }
                    }

                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v129 = (os_log_s *)(id)gLogObj;
                      if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
                      {
                        int v145 = *((_DWORD *)v274 + 85);
                        *(_DWORD *)&buf[0].int sa_len = 136446978;
                        *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                        *(_WORD *)&buf[0].sa_data[10] = 1024;
                        *(_DWORD *)&buf[0].sa_data[12] = v145;
                        *(_WORD *)buf[1].sa_data = 2114;
                        *(void *)&buf[1].sa_data[2] = object;
                        *(_WORD *)&buf[1].sa_data[10] = 2114;
                        *(void *)&buf[1].sa_data[12] = v270;
                        _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_ERROR,  "%{public}s [R%u] Ignoring service %{public}@ with parent %{public}@, should not receive nested services for non-alias services",  &buf[0].sa_len,  0x26u);
                      }
                    }

LABEL_451:
                  if (v244) {
                    free(v244);
                  }
                  goto LABEL_194;
                }

                if (v274[256])
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  int v141 = (os_log_s *)(id)gconnectionLogObj;
                  if (!os_log_type_enabled(v141, OS_LOG_TYPE_INFO)) {
                    goto LABEL_187;
                  }
                  *(_DWORD *)&buf[0].int sa_len = 136446722;
                  *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                  *(_WORD *)&buf[0].sa_data[10] = 2082;
                  *(void *)&buf[0].sa_data[12] = v274 + 256;
                  *(_WORD *)&buf[1].sa_data[4] = 2114;
                  *(void *)&buf[1].sa_data[6] = v128;
                  BOOL v142 = v141;
                  uint64_t v143 = "%{public}s [C%{public}s] Received %{public}@";
                  uint32_t v144 = 32;
                }

                else
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  int v141 = (os_log_s *)(id)gLogObj;
                  if (!os_log_type_enabled(v141, OS_LOG_TYPE_INFO))
                  {
LABEL_187:

                    BOOL v128 = (NWConcrete_nw_resolver_service *)object;
                    goto LABEL_188;
                  }

                  int v146 = *((_DWORD *)v274 + 85);
                  *(_DWORD *)&buf[0].int sa_len = 136446722;
                  *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                  *(_WORD *)&buf[0].sa_data[10] = 1024;
                  *(_DWORD *)&buf[0].sa_data[12] = v146;
                  *(_WORD *)buf[1].sa_data = 2114;
                  *(void *)&buf[1].sa_data[2] = v128;
                  BOOL v142 = v141;
                  uint64_t v143 = "%{public}s [R%u] Received %{public}@";
                  uint32_t v144 = 28;
                }

                _os_log_impl(&dword_181A5C000, v142, OS_LOG_TYPE_INFO, v143, &buf[0].sa_len, v144);
                goto LABEL_187;
              }

              BOOL v128 = (NWConcrete_nw_resolver_service *)object;
              nw_browser_t v127 = v274;
              if (object[16]) {
                goto LABEL_170;
              }
              if ((object[24] & 2) != 0)
              {
                if ((v274[346] & 0x20) == 0)
                {
                  if (v274[256])
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    os_log_type_t v129 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v129, OS_LOG_TYPE_INFO))
                    {
                      *(_DWORD *)&buf[0].int sa_len = 136446722;
                      *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                      *(_WORD *)&buf[0].sa_data[10] = 2082;
                      *(void *)&buf[0].sa_data[12] = v274 + 256;
                      *(_WORD *)&buf[1].sa_data[4] = 2114;
                      *(void *)&buf[1].sa_data[6] = object;
                      _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s] Ignoring service %{public}@, alias must not match origin",  &buf[0].sa_len,  0x20u);
                    }
                  }

                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    os_log_type_t v129 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v129, OS_LOG_TYPE_INFO))
                    {
                      int v206 = *((_DWORD *)v274 + 85);
                      *(_DWORD *)&buf[0].int sa_len = 136446722;
                      *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                      *(_WORD *)&buf[0].sa_data[10] = 1024;
                      *(_DWORD *)&buf[0].sa_data[12] = v206;
                      *(_WORD *)buf[1].sa_data = 2114;
                      *(void *)&buf[1].sa_data[2] = object;
                      _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_INFO,  "%{public}s [R%u] Ignoring service %{public}@, alias must not match origin",  &buf[0].sa_len,  0x1Cu);
                    }
                  }

                  goto LABEL_307;
                }

                goto LABEL_308;
              }

              uint64_t v130 = *((void *)v274 + 22);
              if (!v130)
              {
                BOOL v131 = nw_array_create();
                uint64_t v132 = (void *)*((void *)v274 + 22);
                *((void *)v274 + 22) = v131;

                uint64_t v130 = *((void *)v274 + 22);
                nw_browser_t v127 = v274;
                BOOL v128 = (NWConcrete_nw_resolver_service *)object;
              }

              nw_array_append(v130, v128);
              if ((v127[346] & 0x20) != 0)
              {
LABEL_332:
                nw_resolver_create_dns_getaddrinfo_locked((NWConcrete_nw_resolver *)v127, v128);
                goto LABEL_308;
              }

              if (v127[256])
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                os_log_type_t v133 = (os_log_s *)(id)gconnectionLogObj;
                if (!os_log_type_enabled(v133, OS_LOG_TYPE_INFO)) {
                  goto LABEL_331;
                }
                *(_DWORD *)&buf[0].int sa_len = 136446722;
                *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                *(_WORD *)&buf[0].sa_data[10] = 2082;
                *(void *)&buf[0].sa_data[12] = v274 + 256;
                *(_WORD *)&buf[1].sa_data[4] = 2114;
                *(void *)&buf[1].sa_data[6] = v128;
                BOOL v134 = v133;
                os_log_type_t v135 = "%{public}s [C%{public}s] Starting new gai query for %{public}@";
                uint32_t v136 = 32;
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v133 = (os_log_s *)(id)gLogObj;
                if (!os_log_type_enabled(v133, OS_LOG_TYPE_INFO))
                {
LABEL_331:

                  nw_browser_t v127 = v274;
                  BOOL v128 = (NWConcrete_nw_resolver_service *)object;
                  goto LABEL_332;
                }

                int v213 = *((_DWORD *)v274 + 85);
                *(_DWORD *)&buf[0].int sa_len = 136446722;
                *(void *)&buf[0].sa_data[2] = "nw_resolver_process_service_result";
                *(_WORD *)&buf[0].sa_data[10] = 1024;
                *(_DWORD *)&buf[0].sa_data[12] = v213;
                *(_WORD *)buf[1].sa_data = 2114;
                *(void *)&buf[1].sa_data[2] = v128;
                BOOL v134 = v133;
                os_log_type_t v135 = "%{public}s [R%u] Starting new gai query for %{public}@";
                uint32_t v136 = 28;
              }

              _os_log_impl(&dword_181A5C000, v134, OS_LOG_TYPE_INFO, v135, &buf[0].sa_len, v136);
              goto LABEL_331;
            }

            __nwlog_obj();
            v227 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)&buf[0].int sa_len = 136446210;
            *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:port:ec"
                                            "hConfig:echConfigLength:sensitiveRedacted:]";
            v228 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v298[0] = 0;
            if ((__nwlog_fault(v228, type, v298) & 1) == 0) {
              goto LABEL_416;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v229 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v230 = type[0];
              if (os_log_type_enabled(v229, type[0]))
              {
                *(_DWORD *)&buf[0].int sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:por"
                                                "t:echConfig:echConfigLength:sensitiveRedacted:]";
                _os_log_impl( &dword_181A5C000,  v229,  v230,  "%{public}s called with null origin_name",  &buf[0].sa_len,  0xCu);
              }
            }

            else if (v298[0])
            {
              uint64_t v240 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v229 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v241 = type[0];
              BOOL v242 = os_log_type_enabled(v229, type[0]);
              if (v240)
              {
                if (v242)
                {
                  *(_DWORD *)&buf[0].int sa_len = 136446466;
                  *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:p"
                                                  "ort:echConfig:echConfigLength:sensitiveRedacted:]";
                  *(_WORD *)&buf[0].sa_data[10] = 2082;
                  *(void *)&buf[0].sa_data[12] = v240;
                  _os_log_impl( &dword_181A5C000,  v229,  v241,  "%{public}s called with null origin_name, dumping backtrace:%{public}s",  &buf[0].sa_len,  0x16u);
                }

                free(v240);
                goto LABEL_416;
              }

              if (v242)
              {
                *(_DWORD *)&buf[0].int sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:por"
                                                "t:echConfig:echConfigLength:sensitiveRedacted:]";
                _os_log_impl( &dword_181A5C000,  v229,  v241,  "%{public}s called with null origin_name, no backtrace",  &buf[0].sa_len,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v229 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v250 = type[0];
              if (os_log_type_enabled(v229, type[0]))
              {
                *(_DWORD *)&buf[0].int sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:por"
                                                "t:echConfig:echConfigLength:sensitiveRedacted:]";
                _os_log_impl( &dword_181A5C000,  v229,  v250,  "%{public}s called with null origin_name, backtrace limit exceeded",  &buf[0].sa_len,  0xCu);
              }
            }

LABEL_416:
            v251 = object;
            if (v228) {
              free(v228);
            }
LABEL_418:

            goto LABEL_419;
          }

          __nwlog_obj();
          v223 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)&buf[0].int sa_len = 136446210;
          *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:port:echC"
                                          "onfig:echConfigLength:sensitiveRedacted:]";
          v224 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v298[0] = 0;
          if (__nwlog_fault(v224, type, v298))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v225 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v226 = type[0];
              if (os_log_type_enabled(v225, type[0]))
              {
                *(_DWORD *)&buf[0].int sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:por"
                                                "t:echConfig:echConfigLength:sensitiveRedacted:]";
                _os_log_impl( &dword_181A5C000,  v225,  v226,  "%{public}s called with null (nw_endpoint_get_type(_origin) == nw_endpoint_type_host)",  &buf[0].sa_len,  0xCu);
              }
            }

            else if (v298[0])
            {
              BOOL v237 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v225 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v238 = type[0];
              BOOL v239 = os_log_type_enabled(v225, type[0]);
              if (v237)
              {
                if (v239)
                {
                  *(_DWORD *)&buf[0].int sa_len = 136446466;
                  *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:p"
                                                  "ort:echConfig:echConfigLength:sensitiveRedacted:]";
                  *(_WORD *)&buf[0].sa_data[10] = 2082;
                  *(void *)&buf[0].sa_data[12] = v237;
                  _os_log_impl( &dword_181A5C000,  v225,  v238,  "%{public}s called with null (nw_endpoint_get_type(_origin) == nw_endpoint_type_host), dumping backtrace:%{public}s",  &buf[0].sa_len,  0x16u);
                }

                free(v237);
                goto LABEL_410;
              }

              if (v239)
              {
                *(_DWORD *)&buf[0].int sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:por"
                                                "t:echConfig:echConfigLength:sensitiveRedacted:]";
                _os_log_impl( &dword_181A5C000,  v225,  v238,  "%{public}s called with null (nw_endpoint_get_type(_origin) == nw_endpoint_type_host), no backtrace",  &buf[0].sa_len,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v225 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v249 = type[0];
              if (os_log_type_enabled(v225, type[0]))
              {
                *(_DWORD *)&buf[0].int sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:por"
                                                "t:echConfig:echConfigLength:sensitiveRedacted:]";
                _os_log_impl( &dword_181A5C000,  v225,  v249,  "%{public}s called with null (nw_endpoint_get_type(_origin) == nw_endpoint_type_host), backtrace limit exceeded",  &buf[0].sa_len,  0xCu);
              }
            }
          }

          v316 = *(_DWORD *)(v13 + 448);
          if (v316 != 1)
          {
            if (!v316)
            {
              if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
              {
                if (gLogDatapath)
                {
                  v433 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v433, OS_LOG_TYPE_DEBUG))
                  {
                    v434 = *(void *)(v282 + 88);
                    if (v434) {
                      v435 = *(_DWORD *)(v434 + 460);
                    }
                    else {
                      v435 = -1;
                    }
                    v448 = *(void *)(v282 + 64);
                    *(_DWORD *)int buf = 136447746;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v435;
                    *(_WORD *)&v532[6] = 2048;
                    *(void *)&v532[8] = v448;
                    *(_WORD *)&v532[16] = 2048;
                    *(void *)&v532[18] = v282;
                    *(_WORD *)&v532[26] = 1024;
                    *(_DWORD *)&v532[28] = v521;
                    _os_log_impl( &dword_181A5C000,  v433,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u",  buf,  0x40u);
                    well_known = v515;
                  }
                }
              }

              v317 = *(void *)(v282 + 88);
              if (*(void *)(v317 + 416) == v282)
              {
                if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                {
                  if (gLogDatapath)
                  {
                    v437 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v437, OS_LOG_TYPE_DEBUG))
                    {
                      v438 = *(void *)(v282 + 88);
                      if (v438) {
                        v439 = *(_DWORD *)(v438 + 460);
                      }
                      else {
                        v439 = -1;
                      }
                      v469 = *(void *)(v282 + 64);
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v439;
                      *(_WORD *)&v532[6] = 2048;
                      *(void *)&v532[8] = v469;
                      _os_log_impl( &dword_181A5C000,  v437,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream",  buf,  0x30u);
                      well_known = v515;
                    }
                  }
                }

                nw_protocol_connected(*(void **)(v282 + 48), v282);
              }

              else
              {
                if (nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken != -1) {
                  dispatch_once( &nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken,  &__block_literal_global_28);
                }
                *(void *)(v282 + 24) = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
                nw_protocol_set_output_handler(v282, v317);
                v318 = nw_parameters_copy_protocol_options_legacy(*(void **)(v282 + 144), (nw_protocol *)v282);
                if (v318)
                {
                  v319 = v318;
                  if (v521)
                  {
                    if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                    {
                      if (gLogDatapath)
                      {
                        v334 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v334, OS_LOG_TYPE_DEBUG))
                        {
                          v335 = *(void *)(v282 + 88);
                          if (v335) {
                            v336 = *(_DWORD *)(v335 + 460);
                          }
                          else {
                            v336 = -1;
                          }
                          v472 = *(void *)(v282 + 64);
                          *(_DWORD *)int buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v336;
                          *(_WORD *)&v532[6] = 2048;
                          *(void *)&v532[8] = v472;
                          _os_log_impl( &dword_181A5C000,  v334,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment t o setup metadata",  buf,  0x30u);
                          well_known = v515;
                        }
                      }
                    }
                  }

                  else if (nw_protocol_options_is_webtransport(v318))
                  {
                    *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xFC | 1;
                    if (nw_webtransport_options_get_is_datagram(v319)) {
                      v320 = 8;
                    }
                    else {
                      v320 = 0;
                    }
                    *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xF7 | v320;
                    v321 = nw_webtransport_options_get_is_unidirectional(v319);
                    v322 = *(_BYTE *)(v282 + 276);
                    if (v321) {
                      v323 = 4;
                    }
                    else {
                      v323 = 0;
                    }
                    *(_BYTE *)(v282 + 276) = v322 & 0xFB | v323;
                    if ((v322 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v324 = (os_log_s *)gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        v325 = *(void *)(v282 + 88);
                        if (v325) {
                          v326 = *(_DWORD *)(v325 + 460);
                        }
                        else {
                          v326 = -1;
                        }
                        v373 = *(void *)(v282 + 64);
                        v374 = *(unsigned __int8 *)(v282 + 276);
                        *(_DWORD *)int buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v326;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v373;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v374 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v374 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v374 >> 2) & 1;
                        _os_log_impl( &dword_181A5C000,  v324,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagr am: %u, unidirectional: %u",  buf,  0x42u);
                      }
                    }

                    nw_webtransport_metadata_set_is_peer_initiated( *(void **)(v282 + 160),  (*(_BYTE *)(v282 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional( *(void **)(v282 + 160),  (*(_BYTE *)(v282 + 276) & 4) != 0);
                  }

                  else if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v356 = (os_log_s *)gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                    {
                      v357 = *(void *)(v282 + 88);
                      if (v357) {
                        v358 = *(_DWORD *)(v357 + 460);
                      }
                      else {
                        v358 = -1;
                      }
                      v380 = *(void *)(v282 + 64);
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v358;
                      *(_WORD *)&v532[6] = 2048;
                      *(void *)&v532[8] = v380;
                      _os_log_impl( &dword_181A5C000,  v356,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream",  buf,  0x30u);
                    }
                  }

                  os_release(v319);
                }

                else if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v331 = (os_log_s *)gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  {
                    v332 = *(void *)(v282 + 88);
                    if (v332) {
                      v333 = *(_DWORD *)(v332 + 460);
                    }
                    else {
                      v333 = -1;
                    }
                    v363 = *(void *)(v282 + 64);
                    *(_DWORD *)int buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v333;
                    *(_WORD *)&v532[6] = 2048;
                    *(void *)&v532[8] = v363;
                    _os_log_impl( &dword_181A5C000,  v331,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring",  buf,  0x30u);
                  }
                }
              }

              if (v282 != *(void *)(v13 + 416)) {
                nw_protocol_connected((void *)v282, v13);
              }
            }

    v310 = (v311 + 1);
  }

  while ((_DWORD)v316 != -1);

  v382->data_stall_size_t count = v311;
  v329 = v309;
  v330 = 0LL;
  do
  {
    v331 = v330;
    if ((_DWORD)v330 == 255) {
      break;
    }
    v332 = v329;
    if (!v309)
    {
      __nwlog_obj();
      v340 = (void *)objc_claimAutoreleasedReturnValue();
      buf[0] = 136446210;
      *(void *)&buf[1] = "nw_connection_get_event_milliseconds";
      v341 = (char *)_os_log_send_and_compose_impl();

      v425[0] = 16;
      v410 = 0;
      if (__nwlog_fault(v341, v425, &v410))
      {
        if (v425[0] == 17)
        {
          __nwlog_obj();
          v342 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v343 = v425[0];
          if (os_log_type_enabled(v342, (os_log_type_t)v425[0]))
          {
            buf[0] = 136446210;
            *(void *)&buf[1] = "nw_connection_get_event_milliseconds";
            _os_log_impl(&dword_181A5C000, v342, v343, "%{public}s called with null connection", (uint8_t *)buf, 0xCu);
          }
        }

        else
        {
          if (v410)
          {
            v344 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v345 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v346 = v425[0];
            v347 = os_log_type_enabled(v345, (os_log_type_t)v425[0]);
            if (v344)
            {
              if (v347)
              {
                buf[0] = 136446466;
                *(void *)&buf[1] = "nw_connection_get_event_milliseconds";
                LOWORD(buf[3]) = 2082;
                *(void *)((char *)&buf[3] + 2) = v344;
                _os_log_impl( &dword_181A5C000,  v345,  v346,  "%{public}s called with null connection, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
              }

              free(v344);
            }

            else
            {
              if (v347)
              {
                buf[0] = 136446210;
                *(void *)&buf[1] = "nw_connection_get_event_milliseconds";
                _os_log_impl( &dword_181A5C000,  v345,  v346,  "%{public}s called with null connection, no backtrace",  (uint8_t *)buf,  0xCu);
              }
            }

            goto LABEL_503;
          }

          __nwlog_obj();
          v342 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v348 = v425[0];
          if (os_log_type_enabled(v342, (os_log_type_t)v425[0]))
          {
            buf[0] = 136446210;
            *(void *)&buf[1] = "nw_connection_get_event_milliseconds";
            _os_log_impl( &dword_181A5C000,  v342,  v348,  "%{public}s called with null connection, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
          }
        }
      }

LABEL_410:
          v251 = object;
          if (v224) {
            free(v224);
          }
          goto LABEL_418;
        }

        __nwlog_obj();
        v219 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)&buf[0].int sa_len = 136446210;
        *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:port:echCon"
                                        "fig:echConfigLength:sensitiveRedacted:]";
        v220 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v298[0] = 0;
        if (__nwlog_fault(v220, type, v298))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v221 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v222 = type[0];
            if (os_log_type_enabled(v221, type[0]))
            {
              *(_DWORD *)&buf[0].int sa_len = 136446210;
              *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:port:"
                                              "echConfig:echConfigLength:sensitiveRedacted:]";
              _os_log_impl(&dword_181A5C000, v221, v222, "%{public}s called with null _origin", &buf[0].sa_len, 0xCu);
            }
          }

          else if (v298[0])
          {
            uint64_t v234 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v221 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v235 = type[0];
            BOOL v236 = os_log_type_enabled(v221, type[0]);
            if (v234)
            {
              if (v236)
              {
                *(_DWORD *)&buf[0].int sa_len = 136446466;
                *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:por"
                                                "t:echConfig:echConfigLength:sensitiveRedacted:]";
                *(_WORD *)&buf[0].sa_data[10] = 2082;
                *(void *)&buf[0].sa_data[12] = v234;
                _os_log_impl( &dword_181A5C000,  v221,  v235,  "%{public}s called with null _origin, dumping backtrace:%{public}s",  &buf[0].sa_len,  0x16u);
              }

              free(v234);
              goto LABEL_404;
            }

            if (v236)
            {
              *(_DWORD *)&buf[0].int sa_len = 136446210;
              *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:port:"
                                              "echConfig:echConfigLength:sensitiveRedacted:]";
              _os_log_impl( &dword_181A5C000,  v221,  v235,  "%{public}s called with null _origin, no backtrace",  &buf[0].sa_len,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            v221 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v248 = type[0];
            if (os_log_type_enabled(v221, type[0]))
            {
              *(_DWORD *)&buf[0].int sa_len = 136446210;
              *(void *)&buf[0].sa_data[2] = "-[NWConcrete_nw_resolver_service initWithOrigin:priority:serviceName:port:"
                                              "echConfig:echConfigLength:sensitiveRedacted:]";
              _os_log_impl( &dword_181A5C000,  v221,  v248,  "%{public}s called with null _origin, backtrace limit exceeded",  &buf[0].sa_len,  0xCu);
            }
          }
        }

                                *(void *)(v205 + 80) = 0LL;
                                *(void *)(v205 + 8_Block_object_dispose(va, 8) = 0LL;
                                nw_frame_cache_return_frame(v626, v205);
                                int v205 = *v204;
                                if (!*v204) {
                                  goto LABEL_777;
                                }
                                continue;
                              }

                              int v205 = v619;
                              if ((*(_BYTE *)(v6 + 158) & 1) == 0)
                              {
                                v447 = (os_log_s *)__nwlog_obj();
                                if (os_log_type_enabled(v447, OS_LOG_TYPE_DEFAULT))
                                {
                                  v448 = *(void *)(v6 + 488);
                                  v449 = *(_DWORD *)(*(void *)(v6 + 480) + 372LL);
                                  v450 = *(_DWORD *)(v6 + 860);
                                  if (v448) {
                                    LODWORD(v44_Block_object_dispose(va, 8) = *(_DWORD *)(v448 + 424);
                                  }
                                  *(_DWORD *)int buf = 136448002;
                                  *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                                  v638 = 2082;
                                  *(void *)v639 = v629;
                                  *(_WORD *)&v639[8] = 2080;
                                  *(void *)&v639[10] = " ";
                                  *(_WORD *)&v639[18] = 1024;
                                  *(_DWORD *)v640 = v449;
                                  *(_WORD *)&v640[4] = 1024;
                                  *(_DWORD *)&v640[6] = v450;
                                  *(_WORD *)v641 = 1024;
                                  *(_DWORD *)&v641[2] = v448;
                                  *(_WORD *)&v641[6] = 1024;
                                  *(_DWORD *)&v641[8] = __len;
                                  *(_WORD *)&v641[12] = 1024;
                                  *(_DWORD *)&v641[14] = v212;
                                  _os_log_impl( &dword_181A5C000,  v447,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%s<i%u:c%u:s%u> could not send pending output frame of length %u sent %u",  buf,  0x3Eu);
                                }
                              }

                              if (v177) {
                                free(v177);
                              }
                              uint64_t v2 = v305;
                              goto LABEL_102;
                            }
                          }
                        }

                        __nwlog_obj();
                        uint32_t v164 = *(void *)(*(void *)(v2 + 1072) + 32LL);
                        int v165 = "invalid";
                        if (v164)
                        {
                          int v166 = *(const char **)(v164 + 16);
                          if (v166) {
                            int v165 = v166;
                          }
                        }

                        *(_DWORD *)int buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v165;
                        nw_endpoint_type_t v167 = (char *)_os_log_send_and_compose_impl();
                        os_log_type_t type = OS_LOG_TYPE_ERROR;
                        v306 = 0;
                        if (__nwlog_fault(v167, &type, &v306))
                        {
                          if (type == OS_LOG_TYPE_FAULT)
                          {
                            __int128 v168 = (os_log_s *)__nwlog_obj();
                            uint64_t v169 = type;
                            if (os_log_type_enabled(v168, type))
                            {
                              uint32_t v170 = *(void *)(*(void *)(v305 + 1072) + 32LL);
                              int v171 = "invalid";
                              if (v170)
                              {
                                uint64_t v172 = *(const char **)(v170 + 16);
                                if (v172) {
                                  int v171 = v172;
                                }
                              }

                              *(_DWORD *)int buf = 136446466;
                              *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                              *(_WORD *)&_BYTE buf[12] = 2082;
                              *(void *)&buf[14] = v171;
                              int v173 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
LABEL_400:
                              _os_log_impl(&dword_181A5C000, v168, v169, v173, buf, 0x16u);
                            }
                          }

                          else if (v306)
                          {
                            int v216 = (char *)__nw_create_backtrace_string();
                            __int128 v168 = (os_log_s *)__nwlog_obj();
                            uint64_t v169 = type;
                            v217 = os_log_type_enabled(v168, type);
                            if (v216)
                            {
                              if (v217)
                              {
                                os_log_type_t v218 = *(void *)(*(void *)(v305 + 1072) + 32LL);
                                v219 = "invalid";
                                if (v218)
                                {
                                  v220 = *(const char **)(v218 + 16);
                                  if (v220) {
                                    v219 = v220;
                                  }
                                }

                                *(_DWORD *)int buf = 136446722;
                                *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                                *(_WORD *)&_BYTE buf[12] = 2082;
                                *(void *)&buf[14] = v219;
                                *(_WORD *)&buf[22] = 2082;
                                v309 = v216;
                                _os_log_impl( &dword_181A5C000,  v168,  v169,  "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping back trace:%{public}s",  buf,  0x20u);
                              }

                              free(v216);
                              goto LABEL_401;
                            }

                            if (v217)
                            {
                              id v267 = *(void *)(*(void *)(v305 + 1072) + 32LL);
                              char v268 = "invalid";
                              if (v267)
                              {
                                v269 = *(const char **)(v267 + 16);
                                if (v269) {
                                  char v268 = v269;
                                }
                              }

                              *(_DWORD *)int buf = 136446466;
                              *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                              *(_WORD *)&_BYTE buf[12] = 2082;
                              *(void *)&buf[14] = v268;
                              int v173 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
                              goto LABEL_400;
                            }
                          }

                          else
                          {
                            __int128 v168 = (os_log_s *)__nwlog_obj();
                            uint64_t v169 = type;
                            if (os_log_type_enabled(v168, type))
                            {
                              os_log_type_t v249 = *(void *)(*(void *)(v305 + 1072) + 32LL);
                              os_log_type_t v250 = "invalid";
                              if (v249)
                              {
                                v251 = *(const char **)(v249 + 16);
                                if (v251) {
                                  os_log_type_t v250 = v251;
                                }
                              }

                              *(_DWORD *)int buf = 136446466;
                              *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                              *(_WORD *)&_BYTE buf[12] = 2082;
                              *(void *)&buf[14] = v250;
                              int v173 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
                              goto LABEL_400;
                            }
                          }
                        }

    if (v264) {
      free(v264);
    }
    goto LABEL_412;
  }

  v228 = v227;
  if (v227 >= v225)
  {
    v131->flow_duration_milliseconds = v227 - v225;
    if ((*((_BYTE *)v378 + 109) & 0x40) != 0) {
      goto LABEL_414;
    }
    goto LABEL_331;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v229 = (id)gLogObj;
  buf[0] = 136446722;
  *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
  LOWORD(buf[3]) = 1024;
  *(_DWORD *)((char *)&buf[3] + 2) = v228;
  HIWORD(buf[4]) = 1024;
  buf[5] = v225;
  os_log_type_t v230 = (char *)_os_log_send_and_compose_impl();

  v425[0] = 16;
  v410 = 0;
  if (!__nwlog_fault(v230, v425, &v410))
  {
LABEL_325:
    BOOL v131 = v382;
    if (!v230) {
      goto LABEL_327;
    }
    goto LABEL_326;
  }

  if (v425[0] == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v231 = (os_log_s *)(id)gLogObj;
    os_log_type_t v232 = v425[0];
    if (os_log_type_enabled(v231, (os_log_type_t)v425[0]))
    {
      buf[0] = 136446722;
      *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
      LOWORD(buf[3]) = 1024;
      *(_DWORD *)((char *)&buf[3] + 2) = v228;
      HIWORD(buf[4]) = 1024;
      buf[5] = v225;
      _os_log_impl( &dword_181A5C000,  v231,  v232,  "%{public}s flow_disconnect %u < flow_finish %u",  (uint8_t *)buf,  0x18u);
    }

LABEL_338:
LABEL_326:
    unsigned int v75 = v276 + 1;
    --a3;
  }

  while (a3);
  uint64_t v266 = v278;
  if ((v268 & 1) != 0) {
    nw_resolver_update_status_locked(*(void *)(v278 + 32), 0LL);
  }
LABEL_456:
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(v266 + 32) + 12LL));
  id WeakRetained = v267;
LABEL_457:
}

  if (v169)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
    int v195 = (char *)_os_log_send_and_compose_impl();
    aBlock[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    v196 = &qword_18C45F000;
    if (aBlock[0] == 17)
    {
      uint64_t v240 = (os_log_s *)__nwlog_obj();
      os_log_type_t v241 = aBlock[0];
      if (!os_log_type_enabled(v240, (os_log_type_t)aBlock[0])) {
        goto LABEL_368;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
      uint32_t v200 = "%{public}s called with null http1_stream";
    }

    else if (type)
    {
      os_log_type_t v257 = (char *)__nw_create_backtrace_string();
      uint64_t v240 = (os_log_s *)__nwlog_obj();
      os_log_type_t v241 = aBlock[0];
      BOOL v258 = os_log_type_enabled(v240, (os_log_type_t)aBlock[0]);
      if (v257)
      {
        if (v258)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v257;
          _os_log_impl( &dword_181A5C000,  v240,  v241,  "%{public}s called with null http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v257);
        goto LABEL_368;
      }

      if (!v258) {
        goto LABEL_368;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
      uint32_t v200 = "%{public}s called with null http1_stream, no backtrace";
    }

    else
    {
      uint64_t v240 = (os_log_s *)__nwlog_obj();
      os_log_type_t v241 = aBlock[0];
      if (!os_log_type_enabled(v240, (os_log_type_t)aBlock[0])) {
        goto LABEL_368;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
      uint32_t v200 = "%{public}s called with null http1_stream, backtrace limit exceeded";
    }

                        if (v153) {
                          free(v153);
                        }
                        LODWORD(v93) = v628;
                        int v95 = v630;
                      }

                      uint64_t v172 = *(_BYTE *)(v95 + 158);
                      id v6 = v627;
                      size_t v86 = v614;
                      if ((v172 & 1) == 0)
                      {
                        int v173 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
                        {
                          nw_endpoint_type_t v174 = *(void *)(v630 + 488);
                          uint64_t v175 = *(_DWORD *)(*(void *)(v630 + 480) + 372LL);
                          v176 = *(_DWORD *)(v630 + 860);
                          if (v174) {
                            LODWORD(v174) = *(_DWORD *)(v174 + 424);
                          }
                          *(_DWORD *)int buf = 136447746;
                          *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                          v638 = 2082;
                          *(void *)v639 = v621;
                          *(_WORD *)&v639[8] = 2080;
                          *(void *)&v639[10] = " ";
                          *(_WORD *)&v639[18] = 1024;
                          *(_DWORD *)v640 = v175;
                          *(_WORD *)&v640[4] = 1024;
                          *(_DWORD *)&v640[6] = v176;
                          *(_WORD *)v641 = 1024;
                          *(_DWORD *)&v641[2] = v174;
                          *(_WORD *)&v641[6] = 1024;
                          *(_DWORD *)&v641[8] = v93;
                          _os_log_impl( &dword_181A5C000,  v173,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> output handler refused frame request for frames of length %u",  buf,  0x38u);
                        }
                      }

                      LODWORD(v93) = v93 - v97;
LABEL_347:
                      id v93 = v93;
                      uint64_t v8 = &qword_18C45F000;
                      size_t v92 = v616;
                      if (__len == v93)
                      {
LABEL_348:
                        nw_http_transaction_metadata_increment_outbound_header_size(*(void **)(v86 + 352), v93);
                        uint64_t v177 = *(_WORD *)(v86 + 428);
                        if ((v177 & 0x800) != 0)
                        {
                          *(void *)int buf = 0LL;
                          nw::retained_ptr<nw_endpoint *>::operator=(v86 + 384, buf);
                        }

                        else
                        {
                          *(_WORD *)(v86 + 42_Block_object_dispose(va, 8) = v177 | 2;
                          if (v85)
                          {
                            *(_WORD *)(v86 + 42_Block_object_dispose(va, 8) = v177 | 0x402;
                            *(_WORD *)(*(void *)(v86 + 256) + 872LL) |= 0x20u;
                            nw_http_transaction_metadata_mark_outbound_message_end(*(void **)(v86 + 352));
                            if (*(_BYTE *)(v86 + 168))
                            {
                              if (*(void *)(v86 + 160) != *(void *)(v86 + 176))
                              {
                                if ((*(_BYTE *)(v86 + 158) & 1) == 0)
                                {
                                  os_log_type_t v178 = (os_log_s *)__nwlog_obj();
                                  if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
                                  {
                                    nw_endpoint_type_t v179 = *(void *)(v86 + 256);
                                    if (v179) {
                                      LODWORD(v179) = *(_DWORD *)(v179 + 860);
                                    }
                                    uint32_t v180 = *(_DWORD *)(*(void *)(v86 + 248) + 372LL);
                                    os_log_type_t v181 = *(_DWORD *)(v86 + 424);
                                    if (*(_BYTE *)(v86 + 168)) {
                                      uint64_t v182 = *(void *)(v86 + 160);
                                    }
                                    else {
                                      uint64_t v182 = -1LL;
                                    }
                                    BOOL v202 = *(void *)(v86 + 176);
                                    *(_DWORD *)int buf = 136448002;
                                    *(void *)&uint8_t buf[4] = "nw_http1_stream_send_outbound_headers";
                                    v638 = 2082;
                                    *(void *)v639 = v86 + 74;
                                    *(_WORD *)&v639[8] = 2080;
                                    *(void *)&v639[10] = " ";
                                    *(_WORD *)&v639[18] = 1024;
                                    *(_DWORD *)v640 = v180;
                                    *(_WORD *)&v640[4] = 1024;
                                    *(_DWORD *)&v640[6] = v179;
                                    *(_WORD *)v641 = 1024;
                                    *(_DWORD *)&v641[2] = v181;
                                    *(_WORD *)&v641[6] = 2048;
                                    *(void *)&v641[8] = v182;
                                    *(_WORD *)&v641[16] = 2048;
                                    v642 = v202;
                                    _os_log_impl( &dword_181A5C000,  v178,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> Content length header %llu does not equal body size %llu",  buf,  0x46u);
                                  }
                                }

                                nw_protocol_error(*(void **)(v86 + 48), v86);
                                nw_protocol_disconnected(*(void **)(v86 + 48), v86);
                              }
                            }
                          }
                        }
                      }

                      else if ((*(_BYTE *)(v86 + 158) & 1) == 0)
                      {
                        int v183 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
                        {
                          nw_endpoint_type_t v184 = *(void *)(v86 + 256);
                          uint64_t v185 = *(_DWORD *)(*(void *)(v86 + 248) + 372LL);
                          if (v184) {
                            LODWORD(v184) = *(_DWORD *)(v184 + 860);
                          }
                          nw_endpoint_type_t v186 = *(_DWORD *)(v86 + 424);
                          *(_DWORD *)int buf = 136447746;
                          *(void *)&uint8_t buf[4] = "nw_http1_stream_send_outbound_headers";
                          v638 = 2082;
                          *(void *)v639 = v86 + 74;
                          *(_WORD *)&v639[8] = 2080;
                          *(void *)&v639[10] = " ";
                          *(_WORD *)&v639[18] = 1024;
                          *(_DWORD *)v640 = v185;
                          *(_WORD *)&v640[4] = 1024;
                          *(_DWORD *)&v640[6] = v184;
                          *(_WORD *)v641 = 1024;
                          *(_DWORD *)&v641[2] = v186;
                          *(_WORD *)&v641[6] = 2048;
                          *(void *)&v641[8] = __len;
                          _os_log_impl( &dword_181A5C000,  v183,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> failed to send outbound headers of length %zu",  buf,  0x3Cu);
                        }
                      }

                      if (v92) {
                        free(v92);
                      }
                      goto LABEL_400;
                    }

                    while (1)
                    {
                      int v105 = *(void *)(v103 + 32);
                      if (v105 || *(void *)(v103 + 40))
                      {
                        unsigned int v106 = *(void *)(v103 + 112);
                        if (!v106) {
                          goto LABEL_226;
                        }
                      }

                      else
                      {
                        int v105 = 0LL;
                        unsigned int v106 = *(void *)(v103 + 112);
                        if (!v106) {
                          goto LABEL_226;
                        }
                      }

                      if ((*(_WORD *)(v103 + 204) & 0x100) != 0
                        && g_channel_check_validity
                        && !g_channel_check_validity(v103, *(void *)(v103 + 88)))
                      {
                        LODWORD(v106) = 0;
LABEL_226:
                        unsigned int v108 = 0LL;
                        goto LABEL_227;
                      }

                      LODWORD(v106) = *(_DWORD *)(v103 + 52);
                      size_t v107 = *(unsigned int *)(v103 + 56);
                      if ((_DWORD)v106) {
                        LODWORD(v106) = v106 - (v107 + *(_DWORD *)(v103 + 60));
                      }
                      unsigned int v108 = (void *)(*(void *)(v103 + 112) + v107);
LABEL_227:
                      else {
                        uint64_t v109 = v106;
                      }
                      memcpy(v108, v96, v109);
                      v97 -= v109;
                      v96 += v109;
                      if (!nw_frame_claim(v103, v110, v109, 0))
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        *(_DWORD *)int buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                        v638 = 1024;
                        *(_DWORD *)v639 = v109;
                        os_log_type_t v115 = (char *)_os_log_send_and_compose_impl();
                        LOBYTE(v647) = 16;
                        v632 = 0;
                        if (v647 == 17)
                        {
                          id v116 = (os_log_s *)__nwlog_obj();
                          unsigned int v117 = v647;
                          if (os_log_type_enabled(v116, (os_log_type_t)v647))
                          {
                            *(_DWORD *)int buf = 136446466;
                            *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                            v638 = 1024;
                            *(_DWORD *)v639 = v109;
                            id v118 = v116;
                            os_log_type_t v119 = v117;
                            int v120 = "%{public}s claiming frame with %u bytes failed";
                            goto LABEL_251;
                          }

                          goto LABEL_252;
                        }

                        if (!v632)
                        {
                          dispatch_data_t v125 = (os_log_s *)__nwlog_obj();
                          BOOL v126 = v647;
                          if (!os_log_type_enabled(v125, (os_log_type_t)v647)) {
                            goto LABEL_252;
                          }
                          *(_DWORD *)int buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                          v638 = 1024;
                          *(_DWORD *)v639 = v109;
                          id v118 = v125;
                          os_log_type_t v119 = v126;
                          int v120 = "%{public}s claiming frame with %u bytes failed, backtrace limit exceeded";
LABEL_251:
                          _os_log_impl(&dword_181A5C000, v118, v119, v120, buf, 0x12u);
                          goto LABEL_252;
                        }

                        os_log_type_t v121 = (char *)__nw_create_backtrace_string();
                        BOOL v122 = (os_log_s *)__nwlog_obj();
                        BOOL v123 = v647;
                        os_log_type_t v124 = os_log_type_enabled(v122, (os_log_type_t)v647);
                        if (v121)
                        {
                          if (v124)
                          {
                            *(_DWORD *)int buf = 136446722;
                            *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                            v638 = 1024;
                            *(_DWORD *)v639 = v109;
                            *(_WORD *)&v639[4] = 2082;
                            *(void *)&v639[6] = v121;
                            _os_log_impl( &dword_181A5C000,  v122,  v123,  "%{public}s claiming frame with %u bytes failed, dumping backtrace:%{public}s",  buf,  0x1Cu);
                          }

                          free(v121);
                          goto LABEL_252;
                        }

                        if (v124)
                        {
                          *(_DWORD *)int buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                          v638 = 1024;
                          *(_DWORD *)v639 = v109;
                          id v118 = v122;
                          os_log_type_t v119 = v123;
                          int v120 = "%{public}s claiming frame with %u bytes failed, no backtrace";
                          goto LABEL_251;
                        }

void sub_181DA30B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32, void *a33)
{
}

BOOL ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_201( uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  __int128 uu1 = 0uLL;
  nw_resolver_config_get_identifier(v3, &uu1);
  int v4 = uuid_compare((const unsigned __int8 *)&uu1, (const unsigned __int8 *)(*(void *)(a1 + 32) + 232LL));
  if (!v4)
  {
    provider_name = (const char *)nw_resolver_config_get_provider_name(v3);
    uint64_t v7 = provider_name;
    if (provider_name)
    {
      uint64_t v8 = *(const char **)(a1 + 40);
      if (v8)
      {
        if (strcmp(provider_name, v8))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v9 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v10 = *(void *)(a1 + 40);
            int v11 = 136446722;
            uint64_t v12 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            __int16 v13 = 2080;
            id v14 = v7;
            __int16 v15 = 2080;
            uint64_t v16 = v10;
            _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s Provider changed from %s to %s, disabling failover",  (uint8_t *)&v11,  0x20u);
          }

          *(_BYTE *)(*(void *)(a1 + 32) + 347LL) &= ~0x40u;
        }
      }
    }
  }

  return v4 != 0;
}

void sub_181DA33E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL25nw_resolver_apply_serviceP22NWConcrete_nw_resolvertbt_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  if (!nw_endpoint_get_priority(v4)
    && nw_endpoint_get_type((nw_endpoint_t)v4) == nw_endpoint_type_address)
  {
    if (*(_BYTE *)(a1 + 52))
    {
      nw_endpoint_set_priority(v4, *(unsigned __int16 *)(a1 + 48));
      nw_array_append(*(void *)(a1 + 32), v4);
    }

    else
    {
      memset(&v9, 0, 128);
      nw_endpoint_t address = nw_endpoint_get_address((nw_endpoint_t)v4);
      memcpy(&v9, address, address->sa_len);
      *(_WORD *)v9.sa_data = bswap32(*(unsigned __int16 *)(a1 + 50)) >> 16;
      nw_endpoint_t v6 = nw_endpoint_create_address(&v9);
      nw_endpoint_set_priority(v6, *(unsigned __int16 *)(a1 + 48));
      nw_endpoint_set_parent_endpoint(v6, *(void **)(*(void *)(a1 + 40) + 24LL), 0);
      id v7 = nw_endpoint_copy_cname_array(v4);
      if (v7) {
        nw_endpoint_set_cname_array(v6, v7);
      }
      nw_array_append(*(void *)(a1 + 32), v6);
    }
  }

  return 1LL;
}

void sub_181DA3540(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL25nw_resolver_apply_serviceP22NWConcrete_nw_resolvertbt_block_invoke_2( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  unsigned int priority = nw_endpoint_get_priority(v4);
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)
    && (!priority || *(unsigned __int16 *)(a1 + 56) < priority))
  {
    combined_array = nw_array_create_combined_array( *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  *(void **)(a1 + 32));
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = combined_array;

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  if (nw_endpoint_get_priority(v4)
    || nw_endpoint_get_type((nw_endpoint_t)v4) != nw_endpoint_type_address
    || !*(_BYTE *)(a1 + 58))
  {
    nw_array_append(*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), v4);
  }

  return 1LL;
}

void sub_181DA3638(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL34nw_resolver_process_service_resultP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_servicePU38objcproto27OS_dnssd_getaddrinfo_result8NSObject_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  id v4 = *(id *)(a1 + 32);
  uint64_t v5 = v4;
  if (!v4)
  {
    __nwlog_obj();
    int v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_copy_protocol_for_alpn";
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(applier[0]) = 16;
    LOBYTE(v41[0]) = 0;
    if (LOBYTE(applier[0]) == 17)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = applier[0];
      if (os_log_type_enabled(v29, applier[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_copy_protocol_for_alpn";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (LOBYTE(v41[0]))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = applier[0];
      BOOL v35 = os_log_type_enabled(v29, applier[0]);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_copy_protocol_for_alpn";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v28) {
          goto LABEL_70;
        }
        goto LABEL_69;
      }

      if (v35)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_copy_protocol_for_alpn";
        _os_log_impl(&dword_181A5C000, v29, v34, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = applier[0];
      if (os_log_type_enabled(v29, applier[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_copy_protocol_for_alpn";
        _os_log_impl( &dword_181A5C000,  v29,  v39,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_67;
  }

  if (a2)
  {
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    *(void *)&_BYTE buf[24] = __Block_byref_object_copy__5627;
    *(void *)&_BYTE buf[32] = __Block_byref_object_dispose__5628;
    *(void *)&buf[40] = 0LL;
    nw_endpoint_t v6 = (void *)*((void *)v4 + 2);
    uint64_t v7 = (void *)nw_protocol_boringssl_copy_definition();
    uint64_t v8 = nw_parameters_copy_protocol_options_for_definition(v6, v7);

    if (v8)
    {
      sockaddr v9 = v8;
      uint64_t v10 = (void *)sec_protocol_options_copy_transport_specific_application_protocol();
      int v11 = v10;
      if (v10 && object_getClass(v10) == (Class)MEMORY[0x1895F9220])
      {
        applier[0] = MEMORY[0x1895F87A8];
        applier[1] = 3221225472LL;
        applier[2] = ___ZL34nw_resolver_copy_protocol_for_alpnP22NWConcrete_nw_resolverPKc_block_invoke;
        applier[3] = &unk_189BC5538;
        void applier[4] = buf;
        void applier[5] = a2;
        xpc_array_apply(v11, applier);
      }

      uint64_t v12 = *(void **)(*(void *)&buf[8] + 40LL);
      if (v12)
      {
        id v13 = v12;

LABEL_16:
        _Block_object_dispose(buf, 8);

        goto LABEL_17;
      }

      id v14 = (void *)sec_protocol_options_copy_transport_specific_application_protocol();
      __int16 v15 = v14;
      if (v14 && object_getClass(v14) == (Class)MEMORY[0x1895F9220])
      {
        v41[0] = MEMORY[0x1895F87A8];
        v41[1] = 3221225472LL;
        v41[2] = ___ZL34nw_resolver_copy_protocol_for_alpnP22NWConcrete_nw_resolverPKc_block_invoke_2;
        v41[3] = &unk_189BC5538;
        uint8_t v41[4] = buf;
        v41[5] = a2;
        xpc_array_apply(v15, v41);
      }

      uint64_t v16 = *(void **)(*(void *)&buf[8] + 40LL);
      if (v16)
      {
        id v13 = v16;

        goto LABEL_16;
      }
    }

    id v13 = *(id *)(*(void *)&buf[8] + 40LL);
    goto LABEL_16;
  }

  __nwlog_obj();
  unsigned int v31 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_copy_protocol_for_alpn";
  uint64_t v28 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(applier[0]) = 16;
  LOBYTE(v41[0]) = 0;
  if (__nwlog_fault(v28, applier, v41))
  {
    if (LOBYTE(applier[0]) == 17)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = applier[0];
      if (os_log_type_enabled(v29, applier[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_copy_protocol_for_alpn";
        _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null alpn", buf, 0xCu);
      }

void sub_181DA3E94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

void nw_resolver_update_client_alternative(void *a1, void *a2, void *a3)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v39 = "nw_resolver_update_client_alternative";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v39 = "nw_resolver_update_client_alternative";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v39 = "nw_resolver_update_client_alternative";
          __int16 v40 = 2082;
          uint64_t v41 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_50:
        if (!v18) {
          goto LABEL_16;
        }
LABEL_51:
        free(v18);
        goto LABEL_16;
      }

      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v39 = "nw_resolver_update_client_alternative";
        _os_log_impl(&dword_181A5C000, v19, v24, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v39 = "nw_resolver_update_client_alternative";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DA44CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20, void *a21)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL34nw_resolver_process_service_resultP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_servicePU38objcproto27OS_dnssd_getaddrinfo_result8NSObject_block_invoke_216( uint64_t a1, const sockaddr *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  size_t sa_len = a2->sa_len;
  if ((sa_len & 0x80u) == 0LL) {
    size_t v5 = 128 - sa_len;
  }
  else {
    size_t v5 = 0LL;
  }
  bzero(&__dst + sa_len, v5);
  memcpy(&__dst, a2, sa_len);
  __int16 v40 = __rev16(nw_resolver_service_get_port(*(NWConcrete_nw_resolver_service **)(a1 + 32)));
  int v6 = v39;
  if (v39 != 2)
  {
    if (v39 != 30)
    {
      int v9 = 0;
      uint64_t v7 = *(void *)(a1 + 40);
      goto LABEL_15;
    }

    uint64_t v7 = *(void *)(a1 + 40);
    if (*(char *)(v7 + 346) < 0)
    {
      BOOL v8 = *(_DWORD *)(v7 + 80) == 1;
      goto LABEL_12;
    }

void sub_181DA4C04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

OS_dispatch_data *nw_resolver_service_copy_ech_config(NWConcrete_nw_resolver_service *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1->ech_config;
    goto LABEL_3;
  }

  __nwlog_obj();
  size_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v16 = "nw_resolver_service_copy_ech_config";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_copy_ech_config";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null service", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v16 = "nw_resolver_service_copy_ech_config";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_copy_ech_config";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null service, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_copy_ech_config";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null service, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_205( void *a1, uint64_t a2, void *a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  size_t v5 = v4;
  if (!v4)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v41 = "nw_resolver_service_is_alias";
    int v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v41 = "nw_resolver_service_is_alias";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null service", buf, 0xCu);
      }
    }

    else if (v38)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)int buf = 136446466;
          int v41 = "nw_resolver_service_is_alias";
          __int16 v42 = 2082;
          uint64_t v43 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s called with null service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_26:
        if (v23) {
          free(v23);
        }
        __nwlog_obj();
        os_log_type_t v30 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)int buf = 136446210;
        int v41 = "nw_resolver_service_host_matches_origin";
        unsigned int v31 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v38 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v41 = "nw_resolver_service_host_matches_origin";
            _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null service", buf, 0xCu);
          }
        }

        else if (v38)
        {
          id v34 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v35 = type;
          BOOL v36 = os_log_type_enabled(v32, type);
          if (v34)
          {
            if (v36)
            {
              *(_DWORD *)int buf = 136446466;
              int v41 = "nw_resolver_service_host_matches_origin";
              __int16 v42 = 2082;
              uint64_t v43 = v34;
              _os_log_impl( &dword_181A5C000,  v32,  v35,  "%{public}s called with null service, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v34);
            goto LABEL_44;
          }

          if (v36)
          {
            *(_DWORD *)int buf = 136446210;
            int v41 = "nw_resolver_service_host_matches_origin";
            _os_log_impl(&dword_181A5C000, v32, v35, "%{public}s called with null service, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v37 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v41 = "nw_resolver_service_host_matches_origin";
            _os_log_impl( &dword_181A5C000,  v32,  v37,  "%{public}s called with null service, backtrace limit exceeded",  buf,  0xCu);
          }
        }

LABEL_44:
        if (v31) {
          free(v31);
        }
        goto LABEL_9;
      }

      if (v28)
      {
        *(_DWORD *)int buf = 136446210;
        int v41 = "nw_resolver_service_is_alias";
        _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null service, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v41 = "nw_resolver_service_is_alias";
        _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s called with null service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_26;
  }

  int v6 = v4[16];

  if (v6)
  {
    uint64_t v7 = v5;
    char v8 = *((_BYTE *)v7 + 48);

    if ((v8 & 2) != 0)
    {
      int v9 = v7;
      char v10 = *((_BYTE *)v7 + 48);

      if ((v10 & 4) == 0)
      {
        unsigned int port = nw_resolver_service_get_port(v9);
        uint64_t v12 = a1[8];
        *(_WORD *)(v12 + 2) = __rev16(port);
        char v13 = (void *)a1[4];
        id v14 = (void *)a1[5];
        uint64_t priority = nw_resolver_service_get_priority(v9);
        uint64_t v16 = nw_resolver_service_copy_ech_config(v9);
        nw_resolver_insert_address(v13, v14, (const sockaddr *)v12, priority, v16);
LABEL_8:

        goto LABEL_9;
      }

      unsigned int v17 = nw_resolver_service_get_priority(v9);
      uint64_t v18 = *(void *)(a1[6] + 8LL);
      if (v17 <= (unsigned __int16)(*(_WORD *)(v18 + 24) - 1))
      {
        *(_WORD *)(v18 + 24) = v17;
        uint64_t v19 = nw_resolver_service_copy_ech_config(v9);
        uint64_t v20 = *(void *)(a1[7] + 8LL);
        uint64_t v16 = *(OS_dispatch_data **)(v20 + 40);
        *(void *)(v20 + 40) = v19;
        goto LABEL_8;
      }
    }
  }

void sub_181DA5404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_insert_address(void *a1, void *a2, const sockaddr *a3, uint64_t a4, void *a5)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  int v9 = a1;
  id v10 = a2;
  id v11 = a5;
  nw_endpoint_t address = nw_endpoint_create_address(a3);
  __int16 v40 = a3;
  nw_endpoint_set_parent_endpoint(address, v9[3], 0);
  nw_endpoint_set_priority(address, a4);
  if (v11) {
    nw_endpoint_set_ech_config(address, v11);
  }
  if (!v10) {
    goto LABEL_29;
  }
  uint64_t v43 = 0LL;
  dnssd_getaddrinfo_result_get_validation_data();
  dnssd_getaddrinfo_result_get_cnames();
  char v13 = (void *)objc_claimAutoreleasedReturnValue();
  if (v13)
  {
    id v14 = address;
    unsigned __int8 v39 = v13;
    id v15 = v13;
    if (v14)
    {
      uint64_t v16 = (void *)v14[15];
      v14[15] = 0LL;

      uint64_t count = dnssd_cname_array_get_count();
      if (count)
      {
        BOOL v18 = nw_array_create();
        uint64_t v19 = (void *)v14[15];
        v14[15] = v18;

        unsigned int v20 = [v14 type];
        unsigned int v21 = 0;
        if (v20 <= 4 && ((1 << v20) & 0x16) != 0) {
          unsigned int v21 = __rev16([v14 port]);
        }
        for (uint64_t i = 0LL; i != count; ++i)
        {
          cname = (const char *)dnssd_cname_array_get_cname();
          BOOL host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(cname, v21);
          if (host_with_numeric_port) {
            nw_array_append(v14[15], (void *)host_with_numeric_port);
          }
        }
      }

void sub_181DA5968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_2_206( uint64_t a1, void *a2)
{
  return nw_endpoint_address_endpoint_matches_address(a2, *(unsigned __int8 **)(a1 + 32), *(_DWORD *)(a1 + 40), 0);
}

BOOL ___ZL26nw_resolver_insert_addressP22NWConcrete_nw_resolverPU38objcproto27OS_dnssd_getaddrinfo_result8NSObjectPK8sockaddrtPU27objcproto16OS_dispatch_dataS1__block_invoke( uint64_t a1, void *a2)
{
  id v3 = a2;
  else {
    BOOL v4 = 0LL;
  }

  return v4;
}

void sub_181DA5A64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_service_get_priority(NWConcrete_nw_resolver_service *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t port = v1->port;
    goto LABEL_3;
  }

  __nwlog_obj();
  size_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v16 = "nw_resolver_service_get_priority";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_get_priority";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null service", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v16 = "nw_resolver_service_get_priority";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_get_priority";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null service, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_get_priority";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null service, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_resolver_service_get_port(NWConcrete_nw_resolver_service *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t port = v1->port;
    goto LABEL_3;
  }

  __nwlog_obj();
  size_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v16 = "nw_resolver_service_get_port";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_get_port";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null service", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v16 = "nw_resolver_service_get_port";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_get_port";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null service, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_resolver_service_get_port";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null service, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t ___ZL31nw_resolver_check_svcb_completeP22NWConcrete_nw_resolver_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a3 + 24)) {
    return 1LL;
  }
  __int16 v3 = *(_WORD *)(a3 + 36);
  int v4 = v3 & 5;
  int v5 = v3 & 0xA;
  uint64_t v6 = 1LL;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return v6;
}

void ___ZL37nw_resolver_update_client_alternativeP22NWConcrete_nw_resolverPU25objcproto14OS_nw_endpoint8NSObjectPU36objcproto25OS_nw_protocol_definitionS1__block_invoke( uint64_t a1)
{
  uint64_t v2 = *(os_unfair_lock_s **)(a1 + 32);
  __int16 v3 = v2 + 3;
  int v4 = v2;
  os_unfair_lock_lock(v3);
  uint64_t v5 = *(void *)&v4[24]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v3);

  if (v5) {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
  }
}

uint64_t ___ZL34nw_resolver_copy_protocol_for_alpnP22NWConcrete_nw_resolverPKc_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F92E8]
    && (string_ptr = xpc_string_get_string_ptr(v4), !strcmp(string_ptr, *(const char **)(a1 + 40))))
  {
    if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
    }
    objc_storeStrong( (id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  (id)nw_protocol_copy_quic_stream_definition::quic_definition);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  return v6;
}

void sub_181DA60F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL34nw_resolver_copy_protocol_for_alpnP22NWConcrete_nw_resolverPKc_block_invoke_2( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F92E8]
    && (string_ptr = xpc_string_get_string_ptr(v4), !strcmp(string_ptr, *(const char **)(a1 + 40))))
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), (id)g_tcp_definition);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  return v6;
}

void sub_181DA61A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_192( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_endpoint_t address = nw_endpoint_get_address(v4);
  if (address)
  {
    nw_resolver_update_flags_locked( *(NWConcrete_nw_resolver **)(a1 + 32),  *(NWConcrete_nw_resolver_service **)(a1 + 40),  -2147483646,  0,  address,  0,  0);
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t priority = nw_endpoint_get_priority(v4);
    nw_resolver_insert_address(v6, 0LL, address, priority, 0LL);
  }

  return 1LL;
}

void sub_181DA6248(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_2( uint64_t a1, void *a2)
{
  id v3 = a2;
  if (nw_resolver_config_get_protocol(v3) || nw_resolver_config_get_class(v3))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  }

  else
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_3;
    v7[3] = &unk_189BB6A20;
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    id v8 = v5;
    uint64_t v9 = v6;
    nw_resolver_config_enumerate_name_servers(v3, v7);
  }

  return 1LL;
}

void sub_181DA6304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_3( uint64_t a1, char *hostname)
{
  nw_endpoint_t host = nw_endpoint_create_host(hostname, "0");
  BOOL v4 = *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) == 0;

  return v4;
}

void sub_181DA6394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_protocol_copy_resolver_definitionv_block_invoke()
{
  named = nw_protocol_definition_create_named(1, 0LL);
  uint64_t v1 = (void *)nw_protocol_copy_resolver_definition(void)::resolver_definition;
  nw_protocol_copy_resolver_definition(void)::resolver_nw_protocol_definition_t definition = (uint64_t)named;

  nw_protocol_definition_set_cache_entry_deallocator( (void *)nw_protocol_copy_resolver_definition(void)::resolver_definition,  nw_resolver_deallocate_cache_entry);
  nw_protocol_definition_set_should_flush_cache_entry( (void *)nw_protocol_copy_resolver_definition(void)::resolver_definition,  nw_resolver_should_flush_cache_entry);
}

void nw_resolver_deallocate_cache_entry(uint64_t a1, void **a2)
{
  id v3 = *a2;
  *a2 = 0LL;

  BOOL v4 = a2[1];
  a2[1] = 0LL;

  id v5 = a2[2];
  a2[2] = 0LL;

  free(a2);
}

uint64_t nw_resolver_should_flush_cache_entry(uint64_t a1, uint64_t a2, int a3, void *a4, void *a5)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v8 = a4;
  uint64_t v9 = a5;
  os_log_type_t v10 = v9;
  BOOL v11 = v8 == v9;
  if (v8 != v9 && v8 && v9)
  {
    xpc_object_t v12 = v8[28];
    xpc_object_t v13 = v9[28];
    if (v12 && v13)
    {
      if (*((_DWORD *)v8 + 87))
      {
        unint64_t v14 = 0LL;
        while (!uuid_is_null((const unsigned __int8 *)v8[37] + 20 * v14 + 4))
        {
          uuid_unparse((const unsigned __int8 *)v8[37] + 20 * v14 + 4, out);
          xpc_dictionary_get_value(v8[28], out);
          id v15 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v16 = v15;
          if (v15)
          {
            size_t length = 0LL;
            xpc_dictionary_get_data(v15, "data", &length);
            if (is_config_agent_type_dns())
            {
              if (*((_DWORD *)v10 + 87))
              {
                unint64_t v17 = 0LL;
                uint64_t v18 = 4LL;
                while (!uuid_is_null((const unsigned __int8 *)v10[37] + v18))
                {
                  if (!uuid_compare( (const unsigned __int8 *)v8[37] + 20 * v14 + 4,  (const unsigned __int8 *)v10[37] + v18))
                  {
                    BOOL v19 = *((_DWORD *)v8[37] + 5 * v14) == *((_DWORD *)v10[37] + 5 * v17);

                    if (v19) {
                      goto LABEL_18;
                    }
                    goto LABEL_24;
                  }

                  ++v17;
                  v18 += 20LL;
                }
              }

LABEL_24:
              return 1LL;
            }
          }

LABEL_18:
          ++v14;
          BOOL v11 = 1;
        }
      }

      BOOL v11 = 1;
    }

    else
    {
      BOOL v11 = v12 == v13;
    }
  }

void sub_181DA6690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL32nw_resolver_update_status_lockedP22NWConcrete_nw_resolverU13block_pointerFvvE_block_invoke( uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 346) & 0x20) != 0) {
      return;
    }
    if (*(_BYTE *)(v2 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v3 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_INFO)) {
        goto LABEL_13;
      }
      uint64_t v4 = *(void *)(a1 + 40);
      uint64_t v5 = *(void *)(a1 + 32) + 256LL;
      int v12 = 136446722;
      xpc_object_t v13 = "nw_resolver_update_status_locked_block_invoke";
      __int16 v14 = 2082;
      *(void *)id v15 = v5;
      *(_WORD *)&v15[8] = 2048;
      *(void *)&v15[10] = v4;
      uint64_t v6 = "%{public}s [C%{public}s] Stored %zu DNS results to storage cache";
      BOOL v7 = v3;
      uint32_t v8 = 32;
      goto LABEL_12;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = *(void *)(a1 + 40);
      int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 340LL);
      int v12 = 136446722;
      xpc_object_t v13 = "nw_resolver_update_status_locked_block_invoke";
      __int16 v14 = 1024;
      *(_DWORD *)id v15 = v11;
      *(_WORD *)&v15[4] = 2048;
      *(void *)&v15[6] = v10;
      uint64_t v6 = "%{public}s [R%u] Stored %zu DNS results to storage cache";
      BOOL v7 = v3;
      uint32_t v8 = 28;
      goto LABEL_12;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      int v12 = 136446466;
      xpc_object_t v13 = "nw_resolver_update_status_locked_block_invoke";
      __int16 v14 = 2048;
      *(void *)id v15 = v9;
      uint64_t v6 = "%{public}s Stored %zu DNS results to storage cache";
      BOOL v7 = v3;
      uint32_t v8 = 22;
LABEL_12:
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_INFO, v6, (uint8_t *)&v12, v8);
    }
  }

void nw_resolver_start_query_timer(NWConcrete_nw_resolver *a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!*((void *)v1 + 16))
  {
    if ((*((_BYTE *)v1 + 346) & 0x20) != 0) {
      goto LABEL_21;
    }
    if (*((_BYTE *)v1 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint32_t v8 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_20;
      }
      logging_description = nw_endpoint_get_logging_description(*((void **)v2 + 3));
      *(_DWORD *)int buf = 136446978;
      os_log_type_t v38 = "nw_resolver_start_query_timer";
      __int16 v39 = 2082;
      *(void *)__int16 v40 = (char *)v2 + 256;
      *(_WORD *)&v40[8] = 1024;
      *(_DWORD *)&v40[10] = 2;
      *(_WORD *)&v40[14] = 2082;
      *(void *)&v40[16] = logging_description;
      uint64_t v10 = "%{public}s [C%{public}s] Starting %us query timer to receive all answers for %{public}s";
      int v11 = v8;
      uint32_t v12 = 38;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v8 = (os_log_s *)(id)gLogObj;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
LABEL_20:

LABEL_21:
        unint64_t v17 = (void *)*((void *)v2 + 4);
        uint64_t v18 = MEMORY[0x1895F87A8];
        v35[0] = MEMORY[0x1895F87A8];
        v35[1] = 3221225472LL;
        v35[2] = ___ZL29nw_resolver_start_query_timerP22NWConcrete_nw_resolver_block_invoke;
        v35[3] = &unk_189BC93A0;
        BOOL v36 = v2;
        v33[0] = v18;
        v33[1] = 3221225472LL;
        v33[2] = ___ZL29nw_resolver_start_query_timerP22NWConcrete_nw_resolver_block_invoke_172;
        v33[3] = &unk_189BC93A0;
        os_log_type_t v34 = v36;
        uint64_t source = nw_queue_context_create_source(v17, 2, 3, 0, v35, v33);
        *((void *)v2 + 16) = source;
        if (source)
        {
          dispatch_time_t v20 = dispatch_time(0x8000000000000000LL, 2000000000LL);
          if (*(void *)source)
          {
            dispatch_source_set_timer(*(dispatch_source_t *)source, v20, 0xFFFFFFFFFFFFFFFFLL, 0x989680uLL);
          }

          else
          {
            *(void *)(source + 32) = v20;
            *(void *)(source + 40) = -1LL;
            if (*(_BYTE *)(source + 48) && *(_BYTE *)(source + 49)) {
              nw_queue_source_run_timer(source, v20);
            }
          }

          nw_queue_activate_source(*((void *)v2 + 16), v20);
          goto LABEL_32;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = (id)gLogObj;
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v38 = "nw_resolver_start_query_timer";
        uint32_t v22 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v31 = 0;
        if (__nwlog_fault(v22, &type, &v31))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v23 = (os_log_s *)(id)gLogObj;
            os_log_type_t v24 = type;
            if (os_log_type_enabled(v23, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v38 = "nw_resolver_start_query_timer";
              _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s nw_queue_context_create_source failed", buf, 0xCu);
            }
          }

          else if (v31)
          {
            backtrace_string = __nw_create_backtrace_string();
            if (backtrace_string)
            {
              uint64_t v26 = (char *)backtrace_string;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v27 = (os_log_s *)(id)gLogObj;
              os_log_type_t v28 = type;
              if (os_log_type_enabled(v27, type))
              {
                *(_DWORD *)int buf = 136446466;
                os_log_type_t v38 = "nw_resolver_start_query_timer";
                __int16 v39 = 2082;
                *(void *)__int16 v40 = v26;
                _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v26);
              if (!v22) {
                goto LABEL_32;
              }
              goto LABEL_31;
            }

            __nwlog_obj();
            int v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v30 = type;
            if (os_log_type_enabled(v23, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v38 = "nw_resolver_start_query_timer";
              _os_log_impl( &dword_181A5C000,  v23,  v30,  "%{public}s nw_queue_context_create_source failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v23 = (os_log_s *)(id)gLogObj;
            os_log_type_t v29 = type;
            if (os_log_type_enabled(v23, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v38 = "nw_resolver_start_query_timer";
              _os_log_impl( &dword_181A5C000,  v23,  v29,  "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v22)
        {
LABEL_32:

          id v3 = (os_log_s *)v36;
          goto LABEL_33;
        }

void sub_181DA6F74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_resolver_start_delayed_reporting_timerP22NWConcrete_nw_resolverbbb_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12LL));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 346) & 0x20) != 0) {
      goto LABEL_14;
    }
    if (*(_BYTE *)(v2 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v3 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_13;
      }
      uint64_t v4 = *(void *)(a1 + 32);
      logging_description = nw_endpoint_get_logging_description(*(void **)(v4 + 24));
      int v14 = 136446722;
      int v15 = "nw_resolver_start_delayed_reporting_timer_block_invoke";
      __int16 v16 = 2082;
      *(void *)unint64_t v17 = v4 + 256;
      *(_WORD *)&v17[8] = 2082;
      *(void *)&v17[10] = logging_description;
      uint64_t v6 = "%{public}s [C%{public}s] Delayed reporting timer fired: did not receive all results in time, reporting partia"
           "l results for %{public}s";
      uint32_t v7 = v3;
      uint32_t v8 = 32;
      goto LABEL_12;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      int v11 = *(_DWORD *)(v10 + 340);
      uint32_t v12 = nw_endpoint_get_logging_description(*(void **)(v10 + 24));
      int v14 = 136446722;
      int v15 = "nw_resolver_start_delayed_reporting_timer_block_invoke";
      __int16 v16 = 1024;
      *(_DWORD *)unint64_t v17 = v11;
      *(_WORD *)&void v17[4] = 2082;
      *(void *)&v17[6] = v12;
      uint64_t v6 = "%{public}s [R%u] Delayed reporting timer fired: did not receive all results in time, reporting partial result"
           "s for %{public}s";
      uint32_t v7 = v3;
      uint32_t v8 = 28;
      goto LABEL_12;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 32) + 24LL));
      int v14 = 136446466;
      int v15 = "nw_resolver_start_delayed_reporting_timer_block_invoke";
      __int16 v16 = 2082;
      *(void *)unint64_t v17 = v9;
      uint64_t v6 = "%{public}s Delayed reporting timer fired: did not receive all results in time, reporting partial results for %{public}s";
      uint32_t v7 = v3;
      uint32_t v8 = 22;
LABEL_12:
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, v6, (uint8_t *)&v14, v8);
    }
  }

void sub_181DA7238(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_update_client(void *a1, void *a2)
{
  uint64_t v105 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = *((_DWORD *)v3 + 2);
  uint64_t v6 = _Block_copy(*((const void **)v3 + 12));
  uint32_t v7 = (unsigned __int8 *)*((id *)v3 + 18);
  if ((*((_BYTE *)v3 + 346) & 2) == 0
    && nw_endpoint_get_type(*((nw_endpoint_t *)v3 + 3)) == nw_endpoint_type_host
    && *((_DWORD *)v3 + 2) == 2
    && !*((_DWORD *)v3 + 21))
  {
    uint32_t v8 = nw_endpoint_copy_association_with_evaluator(*((void **)v3 + 3), *((void **)v3 + 2), 0LL);
    if (v8)
    {
      if (!v7 || *((void *)v7 + 3) == *((void *)v7 + 2))
      {
        id v20 = nw_protocol_copy_resolver_definition();
        nw_association_set_cached_content_for_protocol(v8, v20, 0LL, 0LL);
      }

      else
      {
        int64_t int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_hostname_cache_seconds,  10LL);
        id v10 = nw_protocol_copy_resolver_definition();
        cached_content_for_int protocol = nw_association_get_cached_content_for_protocol(v8, v10);

        if (!cached_content_for_protocol)
        {
          cached_content_for_int protocol = (uint64_t)calloc(1uLL, 0x20uLL);
          if (!cached_content_for_protocol)
          {
            __nwlog_obj();
            uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int v101 = 136446722;
            *(void *)&v101[4] = "strict_calloc";
            *(_WORD *)&v101[12] = 2048;
            *(void *)&v101[14] = 1LL;
            *(_WORD *)&v101[22] = 2048;
            *(void *)&v101[24] = 32LL;
            int v68 = (void *)_os_log_send_and_compose_impl();

            if (__nwlog_abort((uint64_t)v68))
            {
              __break(1u);
              return;
            }

            free(v68);
            cached_content_for_int protocol = 0LL;
          }
        }

        *(_BYTE *)(cached_content_for_protocol + 24) = *((_BYTE *)v3 + 347) >> 7;
        uint64_t v12 = nw_array_copy((uint64_t)v7);
        uint64_t v13 = *(void **)cached_content_for_protocol;
        *(void *)cached_content_for_int protocol = v12;

        uint64_t v14 = nw_array_copy(*((void *)v3 + 23));
        int v15 = *(void **)(cached_content_for_protocol + 8);
        *(void *)(cached_content_for_protocol + _Block_object_dispose(va, 8) = v14;

        uint64_t v16 = nw_array_copy(*((void *)v3 + 24));
        unint64_t v17 = *(void **)(cached_content_for_protocol + 16);
        *(void *)(cached_content_for_protocol + 16) = v16;

        id v18 = nw_protocol_copy_resolver_definition();
        time_t v19 = time(0LL);
        nw_association_set_cached_content_for_protocol(v8, v18, cached_content_for_protocol, v19 + int64_with_default);
      }
    }
  }

  if (!v7 || *((void *)v7 + 3) == *((void *)v7 + 2))
  {
    srv_weighted_variant = 0LL;
    goto LABEL_70;
  }

  id v21 = v3;
  uint32_t v22 = v7;
  unint64_t v23 = (uint64_t)(*((void *)v7 + 3) - *((void *)v7 + 2)) >> 3;
  int64_t v24 = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_first_address_family_count, 2LL);
  if (v24 <= 0) {
    unint64_t v25 = 2LL;
  }
  else {
    unint64_t v25 = v24;
  }
  if (v23 > v25 + 1)
  {
    nw_array_get_object_at_index((uint64_t)v22, 0LL);
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    if (nw_endpoint_get_type((nw_endpoint_t)v26) != nw_endpoint_type_address)
    {
      os_log_type_t v35 = v22;
LABEL_33:

      goto LABEL_34;
    }

    char address_family = nw_endpoint_get_address_family(v26);
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    _BYTE buf[24] = 0;
    uint64_t v91 = 0LL;
    size_t v92 = &v91;
    uint64_t v93 = 0x2020000000LL;
    uint64_t v94 = 0LL;
    uint64_t v95 = 0LL;
    id v96 = &v95;
    uint64_t v97 = 0x3032000000LL;
    char v98 = __Block_byref_object_copy__5627;
    char v99 = __Block_byref_object_dispose__5628;
    id v100 = 0LL;
    uint64_t v79 = MEMORY[0x1895F87A8];
    uint64_t v80 = 3221225472LL;
    uint64_t v81 = ___ZL41nw_resolver_create_happy_eyeballs_variantP22NWConcrete_nw_resolverPU22objcproto11OS_nw_array8NSObject_block_invoke;
    int v82 = &unk_189BB69B0;
    char v86 = address_family;
    unsigned int v83 = buf;
    uint64_t v84 = &v91;
    unsigned int v85 = &v95;
    nw_array_apply(v22, (uint64_t)&v79);
    if (*(_BYTE *)(*(void *)&buf[8] + 24LL) || v92[3] <= v25)
    {
      os_log_type_t v35 = v22;
LABEL_32:
      _Block_object_dispose(&v95, 8);

      _Block_object_dispose(&v91, 8);
      _Block_object_dispose(buf, 8);
      goto LABEL_33;
    }

    BOOL v71 = nw_array_create();
    if ((*((_BYTE *)v3 + 346) & 0x20) != 0)
    {
LABEL_80:
      *(void *)unsigned int v101 = MEMORY[0x1895F87A8];
      *(void *)&v101[8] = 3221225472LL;
      *(void *)&v101[16] = ___ZL41nw_resolver_create_happy_eyeballs_variantP22NWConcrete_nw_resolverPU22objcproto11OS_nw_array8NSObject_block_invoke_176;
      *(void *)&v101[24] = &unk_189BB69D8;
      *(void *)&v101[40] = buf;
      *(void *)&v101[56] = v25;
      int v65 = (unsigned __int8 *)(id)v71;
      *(void *)&v101[32] = v65;
      *(void *)&v101[48] = &v95;
      nw_array_apply(v22, (uint64_t)v101);
      if (*(_BYTE *)(*(void *)&buf[8] + 24LL)) {
        uint64_t v66 = v22;
      }
      else {
        uint64_t v66 = v65;
      }
      os_log_type_t v35 = v66;

      goto LABEL_32;
    }

    if (*((_BYTE *)v21 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v28 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_79;
      }
      logging_description = nw_endpoint_get_logging_description((void *)v96[5]);
      uint64_t v30 = v92[3];
      *(_DWORD *)unsigned int v101 = 136447490;
      *(void *)&v101[4] = "nw_resolver_create_happy_eyeballs_variant";
      *(_WORD *)&v101[12] = 2082;
      *(void *)&v101[14] = v21 + 64;
      *(_WORD *)&v101[22] = 2082;
      *(void *)&v101[24] = logging_description;
      *(_WORD *)&v101[32] = 2048;
      *(void *)&v101[34] = v30;
      *(_WORD *)&v101[42] = 2048;
      *(void *)&v101[44] = v25;
      *(_WORD *)&v101[52] = 2048;
      *(void *)&v101[54] = v23;
      char v31 = "%{public}s [C%{public}s] Happy Eyeballs: reordering %{public}s from position %llu to %llu of %llu";
      id v32 = v28;
      uint32_t v33 = 62;
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
LABEL_79:

        goto LABEL_80;
      }

      int v70 = v21[85];
      unsigned int v63 = nw_endpoint_get_logging_description((void *)v96[5]);
      uint64_t v64 = v92[3];
      *(_DWORD *)unsigned int v101 = 136447490;
      *(void *)&v101[4] = "nw_resolver_create_happy_eyeballs_variant";
      *(_WORD *)&v101[12] = 1024;
      *(_DWORD *)&v101[14] = v70;
      *(_WORD *)&v101[18] = 2082;
      *(void *)&v101[20] = v63;
      *(_WORD *)&v101[28] = 2048;
      *(void *)&v101[30] = v64;
      *(_WORD *)&v101[38] = 2048;
      *(void *)&v101[40] = v25;
      *(_WORD *)&v101[48] = 2048;
      *(void *)&v101[50] = v23;
      char v31 = "%{public}s [R%u] Happy Eyeballs: reordering %{public}s from position %llu to %llu of %llu";
      id v32 = v28;
      uint32_t v33 = 58;
    }

    _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_DEBUG, v31, v101, v33);
    goto LABEL_79;
  }

  os_log_type_t v35 = v22;
LABEL_34:

  BOOL v36 = (void *)*((void *)v21 + 4);
  os_log_type_t v37 = v21;
  id v38 = v36;
  __int16 v39 = v35;
  __int16 v40 = v39;
  if (v39 && *((void *)v39 + 3) - *((void *)v39 + 2) > 0xFuLL)
  {
    nw_array_get_object_at_index((uint64_t)v39, 0LL);
    __int16 v72 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v95 = 0LL;
    id v96 = &v95;
    uint64_t v97 = 0x3032000000LL;
    char v98 = __Block_byref_object_copy__5627;
    char v99 = __Block_byref_object_dispose__5628;
    id v100 = 0LL;
    uint64_t v91 = 0LL;
    size_t v92 = &v91;
    LODWORD(v94) = 0;
    uint64_t v93 = 0x2020000000LL;
    *(void *)unsigned int v101 = MEMORY[0x1895F87A8];
    *(void *)&v101[8] = 3221225472LL;
    *(void *)&v101[16] = ___ZL43nw_resolver_create_prefer_connected_variantP22NWConcrete_nw_resolverPU24objcproto13OS_nw_context8NSObjectPU22objcproto11OS_nw_arrayS1__block_invoke;
    *(void *)&v101[24] = &unk_189BB8C40;
    *(void *)&v101[40] = &v95;
    *(void *)&v101[48] = &v91;
    uint64_t v41 = v38;
    *(void *)&v101[32] = v41;
    nw_array_apply(v40, (uint64_t)v101);
    uint64_t v87 = 0LL;
    uint64_t v88 = &v87;
    uint64_t v89 = 0x2020000000LL;
    uint64_t v90 = 0LL;
    if (!*((_DWORD *)v92 + 6))
    {
      __int16 v42 = (void *)v96[5];
      v96[5] = 0LL;

      uint64_t v79 = MEMORY[0x1895F87A8];
      uint64_t v80 = 3221225472LL;
      uint64_t v81 = ___ZL43nw_resolver_create_prefer_connected_variantP22NWConcrete_nw_resolverPU24objcproto13OS_nw_context8NSObjectPU22objcproto11OS_nw_arrayS1__block_invoke_2;
      int v82 = &unk_189BB8C40;
      uint64_t v84 = &v95;
      unsigned int v85 = &v87;
      unsigned int v83 = v41;
      nw_array_apply(v40, (uint64_t)&v79);

      if (!*((_DWORD *)v92 + 6) && !v88[3]) {
        goto LABEL_66;
      }
    }

    if ((void *)v96[5] != v72)
    {
      BOOL v43 = nw_array_create();
      if (v41 && v41[31] == 4 || (*((_BYTE *)v3 + 346) & 0x20) != 0) {
        goto LABEL_61;
      }
      if (v37[256])
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unsigned __int8 v44 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_INFO)) {
          goto LABEL_60;
        }
        int v45 = nw_endpoint_get_logging_description((void *)v96[5]);
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_prefer_connected_variant";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v37 + 256;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&_BYTE buf[24] = v45;
        __int16 v46 = "%{public}s [C%{public}s] Prefer Connected: reordering %{public}s to be the first endpoint";
        unsigned int v47 = v44;
        uint32_t v48 = 32;
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned __int8 v44 = (os_log_s *)(id)gLogObj;
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
        {
LABEL_60:

LABEL_61:
          nw_array_append(v43, (void *)v96[5]);
          *(void *)int buf = MEMORY[0x1895F87A8];
          *(void *)&sockaddr buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL43nw_resolver_create_prefer_connected_variantP22NWConcrete_nw_resolverPU24objcproto13OS_nw_context8NSObjectPU22objcproto11OS_nw_arrayS1__block_invoke_177;
          *(void *)&_BYTE buf[24] = &unk_189BC7960;
          int v104 = &v95;
          uint32_t v7 = (unsigned __int8 *)(id)v43;
          unsigned int v103 = v7;
          nw_array_apply(v40, (uint64_t)buf);

LABEL_67:
          _Block_object_dispose(&v87, 8);

          _Block_object_dispose(&v91, 8);
          _Block_object_dispose(&v95, 8);

          goto LABEL_68;
        }

        int v69 = *((_DWORD *)v37 + 85);
        __int16 v54 = nw_endpoint_get_logging_description((void *)v96[5]);
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_prefer_connected_variant";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v69;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v54;
        __int16 v46 = "%{public}s [R%u] Prefer Connected: reordering %{public}s to be the first endpoint";
        unsigned int v47 = v44;
        uint32_t v48 = 28;
      }

      _os_log_impl(&dword_181A5C000, v47, OS_LOG_TYPE_INFO, v46, buf, v48);
      goto LABEL_60;
    }

    if (v41 && v41[31] == 4 || (*((_BYTE *)v3 + 346) & 0x20) != 0)
    {
LABEL_66:
      uint32_t v7 = v40;
      goto LABEL_67;
    }

    if (v37[256])
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v49 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v49, OS_LOG_TYPE_INFO)) {
        goto LABEL_65;
      }
      __int16 v50 = nw_endpoint_get_logging_description((void *)v96[5]);
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_resolver_create_prefer_connected_variant";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v37 + 256;
      *(_WORD *)&buf[22] = 2082;
      *(void *)&_BYTE buf[24] = v50;
      int v51 = "%{public}s [C%{public}s] Prefer Connected: %{public}s is already the first endpoint";
      int v52 = v49;
      uint32_t v53 = 32;
    }

    else
    {
      __nwlog_obj();
      __int16 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
      {
LABEL_65:

        goto LABEL_66;
      }

      int v55 = *((_DWORD *)v37 + 85);
      unsigned int v56 = nw_endpoint_get_logging_description((void *)v96[5]);
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_resolver_create_prefer_connected_variant";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v55;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v56;
      int v51 = "%{public}s [R%u] Prefer Connected: %{public}s is already the first endpoint";
      int v52 = v49;
      uint32_t v53 = 28;
    }

    _os_log_impl(&dword_181A5C000, v52, OS_LOG_TYPE_INFO, v51, buf, v53);
    goto LABEL_65;
  }

  uint32_t v7 = v39;
LABEL_68:

  if (nw_endpoint_get_type(*((nw_endpoint_t *)v37 + 3)) != 5)
  {
    srv_weighted_variant = v7;
    goto LABEL_71;
  }

  srv_weighted_variant = (void *)nw_resolver_create_srv_weighted_variant(v7);
LABEL_70:

LABEL_71:
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZL25nw_resolver_update_clientP22NWConcrete_nw_resolverU13block_pointerFvvE_block_invoke;
  aBlock[3] = &unk_189BB6988;
  id v57 = v3;
  id v74 = v57;
  id v58 = v6;
  id v76 = v58;
  int v78 = v5;
  id v59 = srv_weighted_variant;
  id v75 = v59;
  id v60 = v4;
  id v77 = v60;
  unsigned int v61 = _Block_copy(aBlock);
  int v62 = (dispatch_queue_s *)*((void *)v57 + 14);
  if (v62) {
    dispatch_async(v62, v61);
  }
  else {
    nw_queue_context_async(*((void **)v57 + 4), v61);
  }
}

void sub_181DA7E60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, id a42)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v49 - 176), 8);

  _Unwind_Resume(a1);
}

id nw_protocol_copy_resolver_definition(void)
{
  return (id)nw_protocol_copy_resolver_definition(void)::resolver_definition;
}

uint64_t ___ZL41nw_resolver_create_happy_eyeballs_variantP22NWConcrete_nw_resolverPU22objcproto11OS_nw_array8NSObject_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = a3;
  if (nw_endpoint_get_type((nw_endpoint_t)v6) == nw_endpoint_type_address)
  {
    if (nw_endpoint_get_address_family(v6) == *(unsigned __int8 *)(a1 + 56))
    {
      uint64_t v7 = 1LL;
    }

    else
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), a3);
      uint64_t v7 = 0LL;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  return v7;
}

void sub_181DA8094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL41nw_resolver_create_happy_eyeballs_variantP22NWConcrete_nw_resolverPU22objcproto11OS_nw_array8NSObject_block_invoke_176( void *a1, unint64_t a2, void *a3)
{
  int v5 = a3;
  nw_endpoint_type_t type = nw_endpoint_get_type(v5);
  if (type == nw_endpoint_type_address)
  {
    unint64_t v7 = a1[7];
    if (v7 > a2) {
      goto LABEL_7;
    }
    if (v7 == a2)
    {
      uint64_t v9 = a1[4];
      uint32_t v8 = a1 + 4;
      nw_array_append(v9, *(void **)(*(void *)(v8[2] + 8) + 40LL));
LABEL_8:
      nw_array_append(*v8, v5);
      goto LABEL_9;
    }

    if (*(nw_endpoint **)(*(void *)(a1[6] + 8LL) + 40LL) != v5)
    {
LABEL_7:
      uint32_t v8 = a1 + 4;
      goto LABEL_8;
    }
  }

  else
  {
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
  }

void sub_181DA815C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_resolver_create_prefer_connected_variantP22NWConcrete_nw_resolverPU24objcproto13OS_nw_context8NSObjectPU22objcproto11OS_nw_arrayS1__block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v8 = *(void *)(v6 + 40);
  unint64_t v7 = (id *)(v6 + 40);
  if (!v8)
  {
    objc_storeStrong(v7, a3);
    connected_flow_uint64_t count = nw_context_endpoint_get_connected_flow_count(*(void **)(a1 + 32), v5);
    uint64_t v10 = a1 + 48;
    goto LABEL_5;
  }

  connected_flow_uint64_t count = nw_context_endpoint_get_connected_flow_count(*(void **)(a1 + 32), v5);
  uint64_t v10 = a1 + 48;
  if (connected_flow_count > *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
LABEL_5:
    *(_DWORD *)(*(void *)(*(void *)v10 + 8LL) + 24LL) = connected_flow_count;
  }

  return 1LL;
}

void sub_181DA822C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_resolver_create_prefer_connected_variantP22NWConcrete_nw_resolverPU24objcproto13OS_nw_context8NSObjectPU22objcproto11OS_nw_arrayS1__block_invoke_2( uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v8 = *(void *)(v6 + 40);
  unint64_t v7 = (id *)(v6 + 40);
  if (!v8)
  {
    objc_storeStrong(v7, a3);
    active_instance_uint64_t count = nw_context_endpoint_get_active_instance_count(*(void **)(a1 + 32), v5);
    uint64_t v10 = a1 + 48;
    goto LABEL_5;
  }

  active_instance_uint64_t count = nw_context_endpoint_get_active_instance_count(*(void **)(a1 + 32), v5);
  uint64_t v10 = a1 + 48;
  if (active_instance_count > *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
LABEL_5:
    *(void *)(*(void *)(*(void *)v10 + 8LL) + 24LL) = active_instance_count;
  }

  return 1LL;
}

void sub_181DA8304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_resolver_create_prefer_connected_variantP22NWConcrete_nw_resolverPU24objcproto13OS_nw_context8NSObjectPU22objcproto11OS_nw_arrayS1__block_invoke_177( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (*(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) != v4) {
    nw_array_append(*(void *)(a1 + 32), v4);
  }

  return 1LL;
}

uint64_t ___ZL25nw_resolver_update_clientP22NWConcrete_nw_resolverU13block_pointerFvvE_block_invoke( void *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)a1[4];
  id v3 = v2 + 3;
  id v4 = v2;
  os_unfair_lock_lock(v3);
  uint64_t v5 = *(void *)&v4[24]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v3);

  if (v5) {
    (*(void (**)(void))(a1[6] + 16LL))();
  }
  uint64_t result = a1[7];
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void ___ZL29nw_resolver_start_query_timerP22NWConcrete_nw_resolver_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12LL));
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      logging_description = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 32) + 24LL));
      int v13 = 136446466;
      uint64_t v14 = "nw_resolver_start_query_timer_block_invoke";
      __int16 v15 = 2082;
      *(void *)uint64_t v16 = logging_description;
      uint64_t v6 = "%{public}s Query fired: did not receive all answers in time for %{public}s";
      unint64_t v7 = v3;
      uint32_t v8 = 22;
LABEL_12:
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v13, v8);
    }

void sub_181DA8650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29nw_resolver_start_query_timerP22NWConcrete_nw_resolver_block_invoke_172(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 96))
  {
    nw_resolver_cancel_query_locked((NWConcrete_nw_resolver *)v2, 0);
    uint64_t v2 = *(void *)(a1 + 32);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 12));
}

uint64_t ___ZL40nw_resolver_start_custom_resolver_lockedP22NWConcrete_nw_resolver_block_invoke_2( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_endpoint_set_parent_endpoint(v4, *(void **)(*(void *)(a1 + 32) + 24LL), 0);
  nw_resolver_insert_endpoint_locked(*(void **)(a1 + 32), v4, &__block_literal_global_165);

  return 1LL;
}

uint64_t ___ZL40nw_resolver_start_custom_resolver_lockedP22NWConcrete_nw_resolver_block_invoke_3( uint64_t a1, void *a2, void *a3)
{
  return nw_endpoint_is_equal(a2, a3, 0LL);
}

void nw_resolver_set_cancel_handler(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint32_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    unint64_t v25 = "nw_resolver_set_cancel_handler";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        unint64_t v25 = "nw_resolver_set_cancel_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          unint64_t v25 = "nw_resolver_set_cancel_handler";
          __int16 v26 = 2082;
          os_log_type_t v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        unint64_t v25 = "nw_resolver_set_cancel_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        unint64_t v25 = "nw_resolver_set_cancel_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t nw_resolver_get_status(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    uint64_t os_unfair_lock_opaque = v2[2]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 3);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_resolver_get_status";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_resolver_get_status";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_resolver_get_status";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_resolver_get_status";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_resolver_get_status";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_resolver_get_error(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    uint64_t os_unfair_lock_opaque = v2[21]._os_unfair_lock_opaque;
    if (!(_DWORD)os_unfair_lock_opaque)
    {
      if (v2[2]._os_unfair_lock_opaque == 2
        && nw_endpoint_get_type(*(nw_endpoint_t *)&v2[6]._os_unfair_lock_opaque) == nw_endpoint_type_host
        && ((uint64_t v4 = *(void *)&v2[36]._os_unfair_lock_opaque) == 0 || *(void *)(v4 + 24) == *(void *)(v4 + 16))
        && (v2[86]._os_unfair_lock_opaque & 0x100000) == 0
        && (~LOWORD(v2[22]._os_unfair_lock_opaque) & 0xC00) != 0)
      {
        uint64_t os_unfair_lock_opaque = 4294901742LL;
      }

      else
      {
        uint64_t os_unfair_lock_opaque = 0LL;
      }
    }

    os_unfair_lock_unlock(v2 + 3);
    goto LABEL_11;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  __int16 v17 = "nw_resolver_get_error";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_resolver_get_error";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v17 = "nw_resolver_get_error";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_resolver_get_error";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v17 = "nw_resolver_get_error";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DA9194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_resolver_get_resolution_provider_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  __int128 uu1 = 0uLL;
  nw_resolver_config_get_identifier(v3, &uu1);
  int v4 = uuid_compare((const unsigned __int8 *)&uu1, (const unsigned __int8 *)(*(void *)(a1 + 32) + 232LL));
  if (v4) {
    goto LABEL_6;
  }
  provider_description = (const char *)nw_resolver_config_get_provider_description(v3);
  if (!provider_description)
  {
    provider_description = (const char *)nw_resolver_config_get_provider_name(v3);
    if (!provider_description) {
      goto LABEL_6;
    }
  }

  uint64_t v6 = strdup(provider_description);
  if (v6)
  {
LABEL_5:
    **(void **)(a1 + 40) = v6;
LABEL_6:

    return v4 != 0;
  }

  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  int v11 = 136446210;
  BOOL v12 = "strict_strdup";
  os_log_type_t v9 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v9);
  if (!result)
  {
    free(v9);
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

void sub_181DA9304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_inject_dns_service_error(void *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  int v4 = v3;
  if (v3)
  {
    uint64_t v5 = (void *)v3[4];
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_inject_dns_service_error_block_invoke;
    v14[3] = &unk_189BC76E8;
    os_log_type_t v15 = v3;
    int v16 = a2;
    nw_queue_context_async_if_needed(v5, v14);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v20 = "nw_resolver_inject_dns_service_error";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_resolver_inject_dns_service_error";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v20 = "nw_resolver_inject_dns_service_error";
          __int16 v21 = 2082;
          char v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_resolver_inject_dns_service_error";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v20 = "nw_resolver_inject_dns_service_error";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DA95FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_inject_dns_service_error_block_invoke(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 64))
  {
    id v3 = *(_DNSServiceRef_t **)(v1 + 72);
    nw_endpoint_type_t type = nw_endpoint_get_type(*(nw_endpoint_t *)(v1 + 24));
    uint64_t v5 = *(void *)(a1 + 32);
    if (type == nw_endpoint_type_host)
    {
      if (v5)
      {
        if ((*(_BYTE *)(v5 + 346) & 0x20) != 0)
        {
LABEL_41:
          nw_resolver_host_resolve_callback(v3, 0, 0, *(_DWORD *)(a1 + 40), 0LL, 0LL, 0, (void *)v5);
          return;
        }

        if (*(_BYTE *)(v5 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v6 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO)) {
            goto LABEL_40;
          }
          uint64_t v7 = *(void *)(a1 + 32);
          string_for_dns_service_error = nwlog_get_string_for_dns_service_error(*(_DWORD *)(a1 + 40));
          *(_DWORD *)int buf = 136446722;
          uint32_t v48 = "nw_resolver_inject_dns_service_error_block_invoke";
          __int16 v49 = 2082;
          *(void *)__int16 v50 = v7 + 256;
          *(_WORD *)&v50[8] = 2082;
          *(void *)&v50[10] = string_for_dns_service_error;
          os_log_type_t v9 = "%{public}s [C%{public}s] Injecting error %{public}s";
          os_log_type_t v10 = v6;
          uint32_t v11 = 32;
          goto LABEL_39;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          int v36 = *(_DWORD *)(*(void *)(a1 + 32) + 340LL);
          os_log_type_t v37 = nwlog_get_string_for_dns_service_error(*(_DWORD *)(a1 + 40));
          *(_DWORD *)int buf = 136446722;
          uint32_t v48 = "nw_resolver_inject_dns_service_error_block_invoke";
          __int16 v49 = 1024;
          *(_DWORD *)__int16 v50 = v36;
          *(_WORD *)&v50[4] = 2082;
          *(void *)&v50[6] = v37;
          os_log_type_t v9 = "%{public}s [R%u] Injecting error %{public}s";
          os_log_type_t v10 = v6;
          uint32_t v11 = 28;
          goto LABEL_39;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          uint64_t v28 = nwlog_get_string_for_dns_service_error(*(_DWORD *)(a1 + 40));
          *(_DWORD *)int buf = 136446466;
          uint32_t v48 = "nw_resolver_inject_dns_service_error_block_invoke";
          __int16 v49 = 2082;
          *(void *)__int16 v50 = v28;
          os_log_type_t v9 = "%{public}s Injecting error %{public}s";
          os_log_type_t v10 = v6;
          uint32_t v11 = 22;
LABEL_39:
          _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_INFO, v9, buf, v11);
        }
      }

char *netcore_stats_tcp_report_copy_description(uint64_t a1)
{
  uint64_t v23 = 0LL;
  if (a1)
  {
    uint64_t v2 = netcore_stats_tcp_statistics_report_copy_description((const netcore_stats_tcp_statistics_report *)a1);
    unint64_t v25 = 0LL;
    LODWORD(v3) = *(_DWORD *)(a1 + 1660);
    if ((_DWORD)v3)
    {
      uint64_t v4 = 0LL;
      unint64_t v5 = 0LL;
      uint64_t v6 = 0LL;
      do
      {
        int64_t v24 = 0LL;
        int v7 = *(_DWORD *)(a1 + v4 + 220);
        if (v7)
        {
          if (v6) {
            os_log_type_t v8 = v6;
          }
          else {
            os_log_type_t v8 = "";
          }
          unsigned int v9 = *(_DWORD *)(a1 + v4 + 216) - 1;
          os_log_type_t v10 = "Unknown";
          if (v9 <= 9) {
            os_log_type_t v10 = off_189BB6DD0[v9];
          }
          asprintf( &v24,  "%s\n\t--- Event '%s' at %u ms since start -- bytes in/out: %llu/%llu",  v8,  v10,  v7,  *(void *)(a1 + 8 * v4 + 376),  *(void *)(a1 + 8 * v4 + 384));
        }

        if (v6) {
          free(v6);
        }
        uint64_t v6 = v24;
        ++v5;
        unint64_t v3 = *(unsigned int *)(a1 + 1660);
        v4 += 8LL;
      }

      while (v5 < v3);
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    uint32_t v11 = "<NULL>";
    if (v6) {
      uint32_t v11 = v6;
    }
    asprintf( &v25,  "\n \tFell back:                 %d\n \tPolicy deny reason:        %d\n \tFallback timer:            %u ms\n \tNetwork event count/max:   %u/%d\n \tNetwork events:            %s\n",  *(unsigned __int8 *)(a1 + 1672),  *(_DWORD *)(a1 + 1656),  *(_DWORD *)(a1 + 1668),  v3,  20,  v11);
    if (v6) {
      free(v6);
    }
    nw_endpoint_type_t v12 = v25;
    LODWORD(v13) = *(_DWORD *)(a1 + 3412);
    if ((_DWORD)v13)
    {
      unint64_t v14 = 0LL;
      uint64_t v15 = 0LL;
      int v16 = (const netcore_stats_tcp_statistics_report *)(a1 + 1680);
      do
      {
        char v17 = netcore_stats_tcp_statistics_report_copy_description(v16);
        __int16 v18 = v17;
        unint64_t v25 = 0LL;
        if (v15) {
          uint32_t v19 = v15;
        }
        else {
          uint32_t v19 = "";
        }
        asprintf(&v25, "%s\n\t--- Connection attempt #%u ---\n%s", v19, v14, v17);
        if (v18) {
          free(v18);
        }
        if (v15) {
          free(v15);
        }
        uint64_t v15 = v25;
        ++v14;
        unint64_t v13 = *(unsigned int *)(a1 + 3412);
        ++v16;
      }

      while (v14 < v13);
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    unsigned int v20 = *(_DWORD *)(a1 + 3408) - 1;
    if (v20 > 4) {
      __int16 v21 = "Unknown";
    }
    else {
      __int16 v21 = off_189BB6E20[v20];
    }
    asprintf( &v23,  "\n \tDelegated:                                  %d\n \tReport reason:                              %s\n \tTCP statistics report:                      %s\n \tTCP cellular fallback statistics report:    %s\n \tConnection attempt count:                   %u\n \tConnection attempts:                        %s\n",  *(unsigned __int8 *)(a1 + 3416),  v21,  v2,  v12,  v13,  v15);
    if (v2) {
      free(v2);
    }
    if (v12) {
      free(v12);
    }
    if (v15) {
      free(v15);
    }
  }

  else
  {
    asprintf(&v23, "<NULL>");
  }

  return v23;
}

char *netcore_stats_tcp_statistics_report_copy_description(const netcore_stats_tcp_statistics_report *a1)
{
  v3[0] = 0LL;
  if (a1)
  {
    unsigned int v1 = *((unsigned __int16 *)a1 + 104);
    asprintf( v3,  "\n \tTime to DNS start:                       %u ms\n \tTime to DNS resolved:                    %u ms\n \tDNS resolved time:                       %u ms\n \tDNS answers cached:                      %d\n \tInterface type:                          %d\n \tTime to TCP start:                       %u ms\n \tTime to TCP establishment:               %u ms\n \tConnection establishment:                %u ms\n \tFlow duration:                           %u ms\n \tConnected interface type:                %d\n \tConnected:                               %d\n \tTraffic class:                           %u\n \tCellular fallback:                       %d\n \tCellular RRC connected:                  %d\n \tKernel reported stalls:                  %d\n \tKernel reported connection stalls:       %d\n \tKernel reported read stalls:             %d\n \tKernel reported write stalls:            %d\n \tBytes/Packets in:                        %llu bytes/%llu packets\n \tBytes/Packets out:                       %llu bytes/%llu packets\n \tBytes/Packets duplicate:                 %llu bytes/%llu packets\n \tBytes/Packets ooo:                       %llu bytes/%llu packets\n \tBytes/Packets retransmitted:             %llu bytes/%llu packets\n \tCurrent RTT:                             %u ms\n \tSmoothed RTT:                            %u ms\n \tBest RTT:                                %u ms\n \tVariance of RTT:                         %u\n \tTCP SYN retransmissions:                 %u\n \tTCP Fast Open:                           %d\n \tBetter route count:                      %u\n \tConnection reuse count:                  %u\n \tApp data stall count:                    %u\n \tApp data stall timer:                    %u ms\n",  a1->time_to_dns_start_msecs,  a1->time_to_dns_resolved_msecs,  a1->dns_resolved_time_msecs,  v1 & 1,  a1->interface_type,  a1->time_to_connection_start_msecs,  a1->time_to_connection_establishment_msecs,  a1->connection_establishment_time_msecs,  a1->flow_duration_msecs,  a1->connected_interface_type,  (v1 >> 1) & 1,  a1->traffic_class,  (v1 >> 2) & 1,  (v1 >> 3) & 1,
      (v1 >> 5) & 1,
      (v1 >> 6) & 1,
      (v1 >> 7) & 1,
      (v1 >> 8) & 1,
      a1->bytes_in,
      a1->packets_in,
      a1->bytes_out);
  }

  else
  {
    asprintf(v3, "<NULL>");
  }

  return v3[0];
}

uint64_t network_config_set_opportunistic_blocked(const char *a1, BOOL a2, void *a3, void *a4)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  id v7 = a3;
  id v8 = a4;
  nw_allow_use_of_dispatch_internal();
  if (!a1)
  {
    __nwlog_obj();
    uint32_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null ifname", buf, 0xCu);
      }

      goto LABEL_93;
    }

    if (!v53)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
        _os_log_impl( &dword_181A5C000,  v29,  v49,  "%{public}s called with null ifname, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_93;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v40 = type;
    BOOL v41 = os_log_type_enabled(v29, type);
    if (!backtrace_string)
    {
      if (v41)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
        _os_log_impl(&dword_181A5C000, v29, v40, "%{public}s called with null ifname, no backtrace", buf, 0xCu);
      }

      goto LABEL_93;
    }

    if (v41)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v29,  v40,  "%{public}s called with null ifname, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181DAAF84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void network_config_set_persistent_interface(const char *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v3 = "NULL";
    if (a1) {
      unint64_t v3 = a1;
    }
    else {
      uint64_t v4 = v3;
    }
    *(_DWORD *)int buf = 136446466;
    uint32_t v11 = "network_config_set_persistent_interface";
    __int16 v12 = 2082;
    xpc_object_t v13 = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEFAULT,  "%{public}s Setting persistent interface to %{public}s",  buf,  0x16u);
  }

  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  id v7 = __network_config_set_persistent_interface_block_invoke;
  id v8 = &__block_descriptor_40_e5_v8__0l;
  unsigned int v9 = a1;
  if ((v5 & 1) == 0
  {
    nw_persistent_agent_synchronize(void({block_pointer})(void))::persistent_agent_lock = 0;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_persistent_agent_synchronize(void({block_pointer})(void))::persistent_agent_lock);
  v7((uint64_t)v6);
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_persistent_agent_synchronize(void({block_pointer})(void))::persistent_agent_lock);
}

void __network_config_set_persistent_interface_block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (void *)_ZZZ39network_config_set_persistent_interfaceEUb_E16persistent_agent;
  if (_ZZZ39network_config_set_persistent_interfaceEUb_E16persistent_agent)
  {
    _ZZZ39network_config_set_persistent_interfaceEUb_E16persistent_agent = 0LL;
  }

  unint64_t v3 = *(char **)(a1 + 32);
  if (v3) {
    BOOL v4 = v3 == (char *)kNetworkConfigPersistentInterfaceNoGuidance;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4 && *v3)
  {
    unsigned __int8 v5 = nw_interface_create_with_name(v3);
    if (v5)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      id v6 = (id)nw_context_copy_implicit_context::implicit_context;
      BOOL v7 = nw_context_copy_workloop(v6);
      id v8 = nw_agent_create("Persistent", "Persistent", "Persistent interface guidance", (void *)v7);
      unsigned int v9 = (void *)_ZZZ39network_config_set_persistent_interfaceEUb_E16persistent_agent;
      _ZZZ39network_config_set_persistent_interfaceEUb_E16persistent_agent = (uint64_t)v8;

      nw_agent_change_state((void *)_ZZZ39network_config_set_persistent_interfaceEUb_E16persistent_agent, 1, 0, 0LL);
      LODWORD(v7) = nw_agent_add_to_interface( (void *)_ZZZ39network_config_set_persistent_interfaceEUb_E16persistent_agent,  v5);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint32_t v11 = v10;
      if (v7)
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v23 = "network_config_set_persistent_interface_block_invoke";
          __int16 v24 = 2114;
          uint64_t v25 = v5;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEFAULT,  "%{public}s Added persistent agent to interface %{public}@",  buf,  0x16u);
        }
      }

      else if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v23 = "network_config_set_persistent_interface_block_invoke";
        __int16 v24 = 2114;
        uint64_t v25 = v5;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to add persistent agent to %{public}@",  buf,  0x16u);
      }

LABEL_18:
      return;
    }

    __nwlog_obj();
    __int16 v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v23 = "network_config_set_persistent_interface_block_invoke";
    xpc_object_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v23 = "network_config_set_persistent_interface_block_invoke";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null interface", buf, 0xCu);
        }
      }

      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v23 = "network_config_set_persistent_interface_block_invoke";
            __int16 v24 = 2082;
            uint64_t v25 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (v18)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v23 = "network_config_set_persistent_interface_block_invoke";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v23 = "network_config_set_persistent_interface_block_invoke";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181DAB5A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_set_BOOL_setting(const char *a1, BOOL value)
{
  xpc_object_t v3 = xpc_BOOL_create(value);
  BOOL v4 = networkd_privileged_set_settings(a1, v3, 0LL);

  return v4;
}

void sub_181DAB610(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_set_int64_setting(const char *a1, int64_t value)
{
  xpc_object_t v3 = xpc_int64_create(value);
  BOOL v4 = networkd_privileged_set_settings(a1, v3, 0LL);

  return v4;
}

void sub_181DAB664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_set_int_sysctl_setting(const char *a1, int a2)
{
  xpc_object_t v3 = xpc_int64_create(a2);
  BOOL v4 = networkd_privileged_set_settings(a1, v3, "sysctl");

  return v4;
}

void sub_181DAB6BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_set_BOOL_sysctl_setting(const char *a1, BOOL value)
{
  xpc_object_t v3 = xpc_BOOL_create(value);
  BOOL v4 = networkd_privileged_set_settings(a1, v3, "sysctl");

  return v4;
}

void sub_181DAB714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_setting_exists(const char *a1)
{
  unsigned int v1 = networkd_settings_copy_value_of_type(a1, 0LL);
  BOOL v2 = v1 != 0LL;

  return v2;
}

BOOL network_config_get_BOOL_setting_with_default(const char *a1, BOOL value)
{
  xpc_object_t v3 = networkd_settings_copy_value_of_type(a1, 0LL);
  BOOL v4 = v3;
  if (v3 && object_getClass(v3) == (Class)MEMORY[0x1895F9228]) {
    uint64_t value = xpc_BOOL_get_value(v4);
  }

  return value;
}

void sub_181DAB7AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_get_BOOL_setting(const char *a1)
{
  unsigned int v1 = networkd_settings_copy_value_of_type(a1, 0LL);
  BOOL v2 = v1;
  BOOL v3 = v1 && object_getClass(v1) == (Class)MEMORY[0x1895F9228] && xpc_BOOL_get_value(v2);

  return v3;
}

void sub_181DAB818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int64_t network_config_get_int64_setting_with_default(const char *a1, int64_t value)
{
  BOOL v3 = networkd_settings_copy_value_of_type(a1, 0LL);
  BOOL v4 = v3;
  if (v3 && object_getClass(v3) == (Class)MEMORY[0x1895F9280]) {
    uint64_t value = xpc_int64_get_value(v4);
  }

  return value;
}

void sub_181DAB880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void network_config_get_string_setting(const char *a1, _BYTE *a2, size_t a3)
{
  unsigned __int8 v5 = networkd_settings_copy_value_of_type(a1, 0LL);
  bzero(a2, a3);
  if (!v5 || object_getClass(v5) != (Class)MEMORY[0x1895F92E8])
  {
LABEL_3:

    return;
  }

  string_ptr = xpc_string_get_string_ptr(v5);
  BOOL v7 = string_ptr;
  if (a2)
  {
    if (string_ptr) {
      goto LABEL_6;
    }
  }

  else
  {
    __nwlog_obj();
    uint32_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    __int16 v12 = (void *)_os_log_send_and_compose_impl();

    free(v12);
    if (v7)
    {
LABEL_6:
      if (a3 >= 2) {
        goto LABEL_7;
      }
      goto LABEL_15;
    }
  }

  __nwlog_obj();
  xpc_object_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  uint64_t v14 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v14))
  {
    free(v14);
    if (a3 >= 2)
    {
LABEL_7:
      uint64_t v8 = 1LL;
      size_t v9 = a3;
      while (1)
      {
        int v10 = *(unsigned __int8 *)v7;
        *a2 = v10;
        if (!v10) {
          goto LABEL_3;
        }
        ++a2;
        ++v7;
        if (--v9 <= 1) {
          goto LABEL_16;
        }
      }
    }

void sub_181DABAB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int64_t network_config_get_int64_setting(const char *a1)
{
  unsigned int v1 = networkd_settings_copy_value_of_type(a1, 0LL);
  BOOL v2 = v1;
  if (v1 && object_getClass(v1) == (Class)MEMORY[0x1895F9280]) {
    int64_t value = xpc_int64_get_value(v2);
  }
  else {
    int64_t value = 0LL;
  }

  return value;
}

void sub_181DABB24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t network_config_open_kernel_network_advisory_socket()
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v0 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136446210;
    int v10 = "network_config_open_kernel_network_advisory_socket";
    _os_log_impl( &dword_181A5C000,  v0,  OS_LOG_TYPE_DEFAULT,  "%{public}s Requesting kernel network advisory socket from helper",  (uint8_t *)&v9,  0xCu);
  }

  kernel_socket_uint64_t internal = networkd_privileged_get_kernel_socket_internal(0xDuLL);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v2 = (os_log_s *)(id)gLogObj;
  BOOL v3 = v2;
  if ((kernel_socket_internal & 0x80000000) != 0)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136446210;
      int v10 = "network_config_open_kernel_network_advisory_socket";
      BOOL v4 = "%{public}s Failed to open kernel network advisory socket";
      unsigned __int8 v5 = v3;
      os_log_type_t v6 = OS_LOG_TYPE_ERROR;
      uint32_t v7 = 12;
      goto LABEL_8;
    }
  }

  else if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136446466;
    int v10 = "network_config_open_kernel_network_advisory_socket";
    __int16 v11 = 1024;
    int v12 = kernel_socket_internal;
    BOOL v4 = "%{public}s Received kernel network advisory socket fd=%d";
    unsigned __int8 v5 = v3;
    os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
    uint32_t v7 = 18;
LABEL_8:
    _os_log_impl(&dword_181A5C000, v5, v6, v4, (uint8_t *)&v9, v7);
  }

  return kernel_socket_internal;
}

void network_config_check_interface_settings()
{
}

void network_config_check_mobile_asset()
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v0 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "network_config_check_mobile_asset";
    _os_log_impl(&dword_181A5C000, v0, OS_LOG_TYPE_DEFAULT, "%{public}s Checking mobile asset", buf, 0xCu);
  }

  xpc_object_t v1 = xpc_dictionary_create(0LL, 0LL, 0LL);
  BOOL v2 = v1;
  if (v1)
  {
    xpc_dictionary_set_uint64(v1, (const char *)networkd_privileged_key_type, 0xBuLL);
    networkd_privileged_send_async_inner( (uint64_t)"networkd_privileged_check_mobile_asset",  v2,  (void *)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue,  &__block_literal_global_777);
    goto LABEL_7;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "networkd_privileged_check_mobile_asset";
  BOOL v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "networkd_privileged_check_mobile_asset";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "networkd_privileged_check_mobile_asset";
          __int16 v15 = 2082;
          id v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "networkd_privileged_check_mobile_asset";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "networkd_privileged_check_mobile_asset";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DAC09C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void network_config_run_probes()
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v0 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "network_config_run_probes";
    _os_log_impl(&dword_181A5C000, v0, OS_LOG_TYPE_DEFAULT, "%{public}s Running network probes", buf, 0xCu);
  }

  xpc_object_t v1 = xpc_dictionary_create(0LL, 0LL, 0LL);
  BOOL v2 = v1;
  if (v1)
  {
    xpc_dictionary_set_uint64(v1, (const char *)networkd_privileged_key_type, 0x15uLL);
    networkd_privileged_send_async_inner( (uint64_t)"networkd_privileged_run_probes",  v2,  (void *)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue,  &__block_literal_global_39);
    goto LABEL_7;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "networkd_privileged_run_probes";
  BOOL v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "networkd_privileged_run_probes";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "networkd_privileged_run_probes";
          __int16 v15 = 2082;
          id v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "networkd_privileged_run_probes";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "networkd_privileged_run_probes";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DAC46C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void network_config_set_default_multipath_service_type(int64_t value)
{
  int v1 = value;
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (value < 4)
  {
    id v3 = (const char *)nw_setting_multipath_service_type;
    id v4 = xpc_int64_create(value);
    networkd_privileged_set_settings(v3, v4, 0LL);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v2 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v6 = "network_config_set_default_multipath_service_type";
      __int16 v7 = 1024;
      int v8 = v1;
      _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_ERROR, "%{public}s Invalid Multipath Service Type: %d", buf, 0x12u);
    }
  }

void sub_181DAC5B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

int64_t network_config_get_default_multipath_service_type()
{
  unsigned int v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_multipath_service_type, 0LL);
  int v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1895F9280]) {
    int64_t value = xpc_int64_get_value(v1);
  }
  else {
    int64_t value = 0LL;
  }

  return value;
}

void sub_181DAC62C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void network_config_set_multipath_allow_aggregation(BOOL a1)
{
  id v1 = xpc_BOOL_create(a1);
  networkd_privileged_set_settings("net.inet.mptcp.allow_aggregate", v1, "sysctl");
}

void sub_181DAC680( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

BOOL network_config_get_multipath_allow_aggregation()
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  int v16 = 0;
  size_t v15 = 4LL;
  if (sysctlbyname("net.inet.mptcp.allow_aggregate", &v16, &v15, 0LL, 0LL)) {
    BOOL v0 = 0;
  }
  else {
    BOOL v0 = v15 == 4;
  }
  if (v0) {
    return v16 != 0;
  }
  int v1 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)int buf = 136446722;
  BOOL v18 = "network_config_get_multipath_allow_aggregation";
  __int16 v19 = 2082;
  char v20 = "net.inet.mptcp.allow_aggregate";
  __int16 v21 = 1024;
  int v22 = v1;
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v3, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (os_log_s *)(id)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v18 = "network_config_get_multipath_allow_aggregation";
      __int16 v19 = 2082;
      char v20 = "net.inet.mptcp.allow_aggregate";
      __int16 v21 = 1024;
      int v22 = v1;
      os_log_type_t v6 = "%{public}s Error reading sysctl %{public}s %{darwin.errno}d";
LABEL_20:
      char v11 = v4;
      os_log_type_t v12 = v5;
      goto LABEL_21;
    }

    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (os_log_s *)(id)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v18 = "network_config_get_multipath_allow_aggregation";
      __int16 v19 = 2082;
      char v20 = "net.inet.mptcp.allow_aggregate";
      __int16 v21 = 1024;
      int v22 = v1;
      os_log_type_t v6 = "%{public}s Error reading sysctl %{public}s %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v9 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (!v10)
      {
LABEL_22:

        if (!v3) {
          return 0LL;
        }
        goto LABEL_16;
      }

      *(_DWORD *)int buf = 136446722;
      BOOL v18 = "network_config_get_multipath_allow_aggregation";
      __int16 v19 = 2082;
      char v20 = "net.inet.mptcp.allow_aggregate";
      __int16 v21 = 1024;
      int v22 = v1;
      os_log_type_t v6 = "%{public}s Error reading sysctl %{public}s %{darwin.errno}d, no backtrace";
      char v11 = v4;
      os_log_type_t v12 = v9;
LABEL_21:
      _os_log_impl(&dword_181A5C000, v11, v12, v6, buf, 0x1Cu);
      goto LABEL_22;
    }

    if (v10)
    {
      *(_DWORD *)int buf = 136446978;
      BOOL v18 = "network_config_get_multipath_allow_aggregation";
      __int16 v19 = 2082;
      char v20 = "net.inet.mptcp.allow_aggregate";
      __int16 v21 = 1024;
      int v22 = v1;
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s Error reading sysctl %{public}s %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
    }

    free(backtrace_string);
  }

  if (v3) {
LABEL_16:
  }
    free(v3);
  return 0LL;
}

BOOL network_config_register_boringssl_log_debug_updates(void *a1)
{
  id v1 = a1;
  nw_allow_use_of_dispatch_internal();
  BOOL v2 = nw_settings_register_boringssl_log_debug_updates(v1);

  return v2;
}

BOOL network_config_register_quic_log_debug_updates(void *a1)
{
  id v1 = a1;
  nw_allow_use_of_dispatch_internal();
  BOOL v2 = nw_settings_register_quic_log_debug_updates(v1);

  return v2;
}

void network_config_set_interface_constrained(const char *a1, BOOL a2)
{
}

void network_config_set_interface_ultra_constrained(const char *a1, BOOL a2)
{
}

void network_config_set_interface_expensive(const char *a1, BOOL a2)
{
}

void network_config_set_interface_estimated_throughput( const char *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_allow_use_of_dispatch_internal();
    char v6 = 49 - __clz(a2);
    if (a2 >= 0x10000) {
      char v7 = v6;
    }
    else {
      char v7 = 1;
    }
    if (a2) {
      unsigned __int8 v8 = v7;
    }
    else {
      unsigned __int8 v8 = 0;
    }
    char v9 = 49 - __clz(a3);
    if (a3 >= 0x10000) {
      char v10 = v9;
    }
    else {
      char v10 = 1;
    }
    if (a3) {
      unsigned __int8 v11 = v10;
    }
    else {
      unsigned __int8 v11 = 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = 0x8000LL << v11;
      *(_DWORD *)int buf = 136448002;
      uint64_t v26 = "network_config_set_interface_estimated_throughput";
      __int16 v27 = 2082;
      if (v11 > 0x30u) {
        uint64_t v13 = -1LL;
      }
      uint64_t v28 = (void *)a1;
      __int16 v29 = 2048;
      uint64_t v14 = 0x8000LL << v8;
      if (!v11) {
        uint64_t v13 = 0LL;
      }
      unint64_t v30 = a2;
      __int16 v31 = 1024;
      if (v8 > 0x30u) {
        uint64_t v14 = -1LL;
      }
      int v32 = v8;
      if (!v8) {
        uint64_t v14 = 0LL;
      }
      __int16 v33 = 2048;
      uint64_t v34 = v14;
      __int16 v35 = 2048;
      unint64_t v36 = a3;
      __int16 v37 = 1024;
      int v38 = v11;
      __int16 v39 = 2048;
      uint64_t v40 = v13;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s up: %lluBps -> %u (%lluBps), down: %lluBps -> %u (%lluBps)",  buf,  0x4Au);
    }

    networkd_privileged_set_throughput_estimates(a1, v8, v11);
    return;
  }

  __nwlog_obj();
  size_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v26 = "network_config_set_interface_estimated_throughput";
  int v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "network_config_set_interface_estimated_throughput";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null name", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v26 = "network_config_set_interface_estimated_throughput";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null name, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_42;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "network_config_set_interface_estimated_throughput";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "network_config_set_interface_estimated_throughput";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null name, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void network_config_set_interface_radio_type(const char *a1, unsigned __int8 a2, unsigned int a3)
{
}

void network_config_set_l4s_enabled(BOOL a1)
{
  BOOL v2 = (const char *)nw_setting_enable_l4s;
  id v5 = xpc_BOOL_create(a1);
  networkd_privileged_set_settings(v2, v5, 0LL);

  id v3 = (const char *)nw_setting_enable_accurate_ecn;
  id v6 = xpc_BOOL_create(a1);
  networkd_privileged_set_settings(v3, v6, 0LL);

  id v4 = (const char *)nw_setting_enable_tcp_l4s;
  id v7 = xpc_BOOL_create(a1);
  networkd_privileged_set_settings(v4, v7, 0LL);
}

void sub_181DACF98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t network_config_get_l4s_enabled()
{
  if (network_config_get_quic_l4s_enabled()) {
    return 1LL;
  }
  uint64_t result = network_config_get_tcp_accurate_ecn_enabled();
  if ((_DWORD)result) {
    return network_config_get_tcp_l4s_enabled();
  }
  return result;
}

BOOL network_config_get_quic_l4s_enabled()
{
  BOOL v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_l4s, 0LL);
  id v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1895F9228])
  {
    BOOL value = xpc_BOOL_get_value(v1);

    if (value) {
      return 1LL;
    }
  }

  else
  {
  }

  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_181DAD088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_get_tcp_l4s_enabled()
{
  BOOL v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_tcp_l4s, 0LL);
  id v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1895F9228])
  {
    BOOL value = xpc_BOOL_get_value(v1);

    if (value) {
      return 1LL;
    }
  }

  else
  {
  }

  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_181DAD138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DAD4D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DAD5C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DAD90C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DADC70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DADFDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DAE344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DAE4CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_endpoint_copy(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    id v3 = (void *)[v1 copyEndpoint];
    nw_endpoint_copy_properties(v2, v3);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_endpoint_copy";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_endpoint_copy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_endpoint_copy";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_endpoint_copy";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_endpoint_copy";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DAE79C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_get_accumulated_size(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v1 = a1;
  uint64_t v2 = 0LL;
  uint64_t v3 = [v1 countByEnumeratingWithState:&v14 objects:v26 count:16];
  if (v3)
  {
    uint64_t v5 = *(void *)v15;
    *(void *)&__int128 v4 = 136446978LL;
    __int128 v13 = v4;
    do
    {
      for (uint64_t i = 0LL; i != v3; ++i)
      {
        if (*(void *)v15 != v5) {
          objc_enumerationMutation(v1);
        }
        id v7 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        uint64_t v8 = objc_msgSend(v7, "length", v13, (void)v14);
        BOOL v9 = __CFADD__(v2, v8);
        v2 += v8;
        if (v9)
        {
          if (gLogDatapath)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v10 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v11 = [v7 length];
              *(_DWORD *)int buf = v13;
              uint64_t v19 = "nw_endpoint_get_accumulated_size";
              __int16 v20 = 2082;
              BOOL v21 = "sum";
              __int16 v22 = 2048;
              uint64_t v23 = v11;
              __int16 v24 = 2048;
              uint64_t v25 = v2;
              _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
            }
          }

          uint64_t v2 = -1LL;
        }
      }

      uint64_t v3 = [v1 countByEnumeratingWithState:&v14 objects:v26 count:16];
    }

    while (v3);
  }

  return v2;
}

void sub_181DAE990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6408(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__6409(uint64_t a1)
{
}

uint64_t nw_endpoint_is_registered(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[231] >> 2) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  __int128 v16 = "nw_endpoint_is_registered";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int128 v16 = "nw_endpoint_is_registered";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          __int128 v16 = "nw_endpoint_is_registered";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        __int128 v16 = "nw_endpoint_is_registered";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int128 v16 = "nw_endpoint_is_registered";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

nw_endpoint *nw_endpoint_create_from_dictionary(void *a1)
{
  uint64_t v93 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v77 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_create_from_dictionary";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(length[0]) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v23, length, &type))
    {
      if (LOBYTE(length[0]) == 17)
      {
        __nwlog_obj();
        int v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v79 = length[0];
        if (os_log_type_enabled(v78, length[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_181A5C000, v78, v79, "%{public}s called with null dictionary", buf, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v80 = length[0];
        BOOL v81 = os_log_type_enabled(v78, length[0]);
        if (backtrace_string)
        {
          if (v81)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_create_from_dictionary";
            __int16 v88 = 2082;
            uint64_t v89 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v78,  v80,  "%{public}s called with null dictionary, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          goto LABEL_55;
        }

        if (v81)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_181A5C000, v78, v80, "%{public}s called with null dictionary, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v82 = length[0];
        if (os_log_type_enabled(v78, length[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl( &dword_181A5C000,  v78,  v82,  "%{public}s called with null dictionary, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181DAFD80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_create_from_dictionary_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F9240])
  {
    id v6 = (void *)MEMORY[0x189603F48];
    bytes_ptr = xpc_data_get_bytes_ptr(v4);
    [v6 dataWithBytes:bytes_ptr length:xpc_data_get_length(v4)];
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    if (v5)
    {
      nw_endpoint_append_public_key(*(void **)(a1 + 32), v5);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v10 = 136446210;
        BOOL v11 = "nw_endpoint_create_from_dictionary_block_invoke";
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s failed to create NSData for public key",  (uint8_t *)&v10,  0xCu);
      }

      id v5 = 0LL;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_ERROR))
    {
      int v10 = 136446210;
      BOOL v11 = "nw_endpoint_create_from_dictionary_block_invoke";
      _os_log_impl( &dword_181A5C000,  (os_log_t)v5,  OS_LOG_TYPE_ERROR,  "%{public}s Invalid key type",  (uint8_t *)&v10,  0xCu);
    }
  }

  return 1LL;
}

void sub_181DAFFD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_append_public_key(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_endpoint_append_public_key";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_endpoint_append_public_key";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v24;
      BOOL v16 = os_log_type_enabled(v10, v24);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v26 = "nw_endpoint_append_public_key";
          __int16 v27 = 2082;
          id v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_endpoint_append_public_key";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_endpoint_append_public_key";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void __nw_endpoint_append_public_key_block_invoke(uint64_t a1)
{
  v40[1] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 48LL);
  if (!v2)
  {
    v40[0] = *(void *)(a1 + 40);
    uint64_t v7 = [MEMORY[0x189603F18] arrayWithObjects:v40 count:1];
    uint64_t v8 = *(void *)(a1 + 32);
    BOOL v9 = *(void **)(v8 + 48);
    *(void *)(v8 + 4_Block_object_dispose(va, 8) = v7;

    return;
  }

  if ((unint64_t)[v2 count] < 0x10)
  {
    accumulated_size_t size = nw_endpoint_get_accumulated_size(*(void **)(*(void *)(a1 + 32) + 48LL));
    uint64_t v11 = [*(id *)(a1 + 40) length];
    unint64_t v12 = accumulated_size + v11;
    if (__CFADD__(accumulated_size, v11))
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v29 = [*(id *)(a1 + 40) length];
          *(_DWORD *)int buf = 136446978;
          __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
          __int16 v34 = 2082;
          nw_txt_record_t v35 = "totalSize";
          __int16 v36 = 2048;
          uint64_t v37 = v29;
          __int16 v38 = 2048;
          unint64_t v39 = v12;
          _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
        }
      }

      unint64_t v12 = -1LL;
    }

    else if (v12 < 0x1389)
    {
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      uint64_t v23 = a1 + 32;
      uint64_t v24 = [*(id *)(v22 + 48) arrayByAddingObject:v21];
      os_log_type_t v25 = *(void **)(*(void *)v23 + 48LL);
      *(void *)(*(void *)v23 + 48LL) = v24;

      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v13 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
      __int16 v34 = 2048;
      nw_txt_record_t v35 = (const char *)v12;
      _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_INFO, "%{public}s Accumulated key-size %zu", buf, 0x16u);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
    id v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v4, &type, &v30))
    {
LABEL_45:
      if (!v4) {
        return;
      }
      goto LABEL_46;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
        _os_log_impl(&dword_181A5C000, v5, v15, "%{public}s Accumulated key-size too large", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (!v30)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
        _os_log_impl( &dword_181A5C000,  v5,  v27,  "%{public}s Accumulated key-size too large, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (os_log_s *)(id)gLogObj;
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
        _os_log_impl(&dword_181A5C000, v5, v19, "%{public}s Accumulated key-size too large, no backtrace", buf, 0xCu);
      }

      goto LABEL_44;
    }

    if (v20)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
      __int16 v34 = 2082;
      nw_txt_record_t v35 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v5,  v19,  "%{public}s Accumulated key-size too large, dumping backtrace:%{public}s",  buf,  0x16u);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
    id v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v33 = "nw_endpoint_append_public_key_block_invoke";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s Adding key would exceed maximum count", buf, 0xCu);
      }

void sub_181DB0C04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_txt_record(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 23, a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_endpoint_set_txt_record";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_endpoint_set_txt_record";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_endpoint_set_txt_record";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_endpoint_set_txt_record";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_endpoint_set_txt_record";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_endpoint_is_custom_type(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = [v1 type] > 0x3E7;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_endpoint_is_custom_type";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_endpoint_is_custom_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_endpoint_is_custom_type";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_endpoint_is_custom_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_endpoint_is_custom_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DB115C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *__cdecl nw_endpoint_copy_port_string(nw_endpoint_t endpoint)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = endpoint;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)int buf = 0LL;
    asprintf((char **)buf, "%d", __rev16(-[nw_endpoint port](v1, "port")));
    BOOL v3 = *(char **)buf;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_port_string";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DB1424(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_cname_array(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  BOOL v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 15, a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  __int16 v16 = "nw_endpoint_set_cname_array";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_set_cname_array";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v16 = "nw_endpoint_set_cname_array";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_set_cname_array";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_set_cname_array";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_endpoint_copy_cname_array(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[15];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  __int16 v16 = "nw_endpoint_copy_cname_array";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_copy_cname_array";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v16 = "nw_endpoint_copy_cname_array";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_copy_cname_array";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_copy_cname_array";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_clone_parent_endpoint_properties(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v24 = "nw_endpoint_clone_parent_endpoint_properties";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v24 = "nw_endpoint_clone_parent_endpoint_properties";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v24 = "nw_endpoint_clone_parent_endpoint_properties";
          __int16 v25 = 2082;
          os_log_type_t v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v24 = "nw_endpoint_clone_parent_endpoint_properties";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v24 = "nw_endpoint_clone_parent_endpoint_properties";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_endpoint_set_agent_identifier(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *(_OWORD *)(v3 + 2_Block_object_dispose(va, 8) = *a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  __int16 v16 = "nw_endpoint_set_agent_identifier";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_set_agent_identifier";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v16 = "nw_endpoint_set_agent_identifier";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_set_agent_identifier";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v16 = "nw_endpoint_set_agent_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id *nw_endpoint_copy_without_proxy_parent(void *a1)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v29 = "nw_endpoint_copy_without_proxy_parent";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v19, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v29 = "nw_endpoint_copy_without_proxy_parent";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v29 = "nw_endpoint_copy_without_proxy_parent";
            __int16 v30 = 2082;
            uint64_t v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v24)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v29 = "nw_endpoint_copy_without_proxy_parent";
          _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v29 = "nw_endpoint_copy_without_proxy_parent";
          _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181DB245C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_interface(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 2, a2);
    id v5 = v3;
    int v6 = (os_unfair_lock_s *)v5 + 45;
    *(void *)int buf = MEMORY[0x1895F87A8];
    *(void *)&sockaddr buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_endpoint_clear_description_block_invoke;
    uint64_t v19 = &unk_189BC93A0;
    os_log_type_t v20 = v5;
    uint64_t v7 = v5;
    os_unfair_lock_lock(v6);
    __nw_endpoint_clear_description_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v6);

    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_set_interface";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_set_interface";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_interface";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_set_interface";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_set_interface";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_clear_description(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1 + 45;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_endpoint_clear_description_block_invoke;
  v4[3] = &unk_189BC93A0;
  v4[4] = v1;
  id v3 = v1;
  os_unfair_lock_lock(v2);
  __nw_endpoint_clear_description_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock(v2);
}

void __nw_endpoint_clear_description_block_invoke(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 231LL) &= ~8u;
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 64);
  if (v3)
  {
    free(v3);
    *(void *)(v2 + 64) = 0LL;
  }

  id v4 = *(void **)(v2 + 56);
  *(void *)(v2 + 56) = 0LL;

  *(_BYTE *)(*(void *)(a1 + 32) + 231LL) &= ~0x10u;
  uint64_t v5 = *(void *)(a1 + 32);
  int v6 = *(void **)(v5 + 80);
  if (v6)
  {
    free(v6);
    *(void *)(v5 + 80) = 0LL;
  }

  uint64_t v7 = *(void **)(v5 + 72);
  *(void *)(v5 + 72) = 0LL;
}

void nw_endpoint_set_remote_interface_type(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 6) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_endpoint_set_remote_interface_type";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_remote_interface_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_endpoint_set_remote_interface_type";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_remote_interface_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_remote_interface_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_endpoint_get_remote_interface_type(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[6];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_endpoint_get_remote_interface_type";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_get_remote_interface_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_endpoint_get_remote_interface_type";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_get_remote_interface_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_get_remote_interface_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_set_alternate_port(void *a1, __int16 a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((_WORD *)v3 + 114) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_endpoint_set_alternate_port";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_alternate_port";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_endpoint_set_alternate_port";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_alternate_port";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_alternate_port";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_set_weight(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    [v3 setWeight:a2];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_endpoint_set_weight";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_weight";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_endpoint_set_weight";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_weight";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_set_weight";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DB32DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_custom_metadata_for_key(void *a1, const char *a2, const uint8_t *a3, size_t a4)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v34 = "nw_endpoint_set_custom_metadata_for_key";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v34 = "nw_endpoint_set_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v34 = "nw_endpoint_set_custom_metadata_for_key";
          __int16 v35 = 2082;
          __int16 v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_60:
        if (!v13) {
          goto LABEL_10;
        }
LABEL_61:
        free(v13);
        goto LABEL_10;
      }

      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v34 = "nw_endpoint_set_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v34 = "nw_endpoint_set_custom_metadata_for_key";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DB39F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_access_custom_metadata_for_key(void *a1, const char *a2, void *a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a3;
  id v7 = (uint64_t (**)(void, void, void))v6;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v35 = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (v35 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v35;
      if (os_log_type_enabled(v13, v35))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_60;
    }

    if (!v34)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = v35;
      if (os_log_type_enabled(v13, v35))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_60;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v20 = v35;
    BOOL v21 = os_log_type_enabled(v13, v35);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v13, v20, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_60;
    }

    if (v21)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
      __int16 v38 = 2082;
      unint64_t v39 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_33;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v35 = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (v35 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = v35;
      if (os_log_type_enabled(v13, v35))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null key", buf, 0xCu);
      }

      goto LABEL_60;
    }

    if (!v34)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = v35;
      if (os_log_type_enabled(v13, v35))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v13, v29, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_60;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v22 = v35;
    BOOL v23 = os_log_type_enabled(v13, v35);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v13, v22, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_60;
    }

    if (v23)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v37 = "nw_endpoint_access_custom_metadata_for_key";
      __int16 v38 = 2082;
      unint64_t v39 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181DB419C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_access_custom_metadata_for_key_block_invoke( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a3 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = *(void *)(a1 + 40);
      int v17 = 136446722;
      os_log_type_t v18 = "nw_endpoint_access_custom_metadata_for_key_block_invoke";
      __int16 v19 = 2080;
      uint64_t v20 = v15;
      __int16 v21 = 1024;
      LODWORD(v22) = a3;
      os_log_type_t v10 = "%{public}s did not find %s in custom metadata: %u";
      BOOL v11 = v8;
      os_log_type_t v12 = OS_LOG_TYPE_INFO;
      uint32_t v13 = 28;
      goto LABEL_7;
    }

void nw_endpoint_set_signature(void *a1, const void *a2, size_t a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v30 = "nw_endpoint_set_signature";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v30 = "nw_endpoint_set_signature";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v30 = "nw_endpoint_set_signature";
          __int16 v31 = 2082;
          id v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v30 = "nw_endpoint_set_signature";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v30 = "nw_endpoint_set_signature";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DB4A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_has_signature(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = *((void *)v1 + 24) != 0LL;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_has_signature";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_has_signature";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_has_signature";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_has_signature";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_has_signature";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_set_ech_config(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    [v3 setEchConfig:v4];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_set_ech_config";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_set_ech_config";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_set_ech_config";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_set_ech_config";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_set_ech_config";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DB4F6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_copy_ech_config(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = [v1 echConfig];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_copy_ech_config";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_copy_ech_config";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_copy_ech_config";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_copy_ech_config";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_copy_ech_config";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DB5220(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_do_not_redact(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 231) |= 0x20u;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v14 = "nw_endpoint_set_do_not_redact";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_endpoint_set_do_not_redact";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v14 = "nw_endpoint_set_do_not_redact";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_endpoint_set_do_not_redact";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_endpoint_set_do_not_redact";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_set_known_tracker_name(void *a1, const char *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v19 = "nw_endpoint_set_known_tracker_name";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_endpoint_set_known_tracker_name";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v19 = "nw_endpoint_set_known_tracker_name";
            __int16 v20 = 2082;
            BOOL v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v14)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_endpoint_set_known_tracker_name";
          _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_endpoint_set_known_tracker_name";
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_endpoint_get_known_tracker_name(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

void nw_endpoint_set_tracker_owner(void *a1, const char *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v19 = "nw_endpoint_set_tracker_owner";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_endpoint_set_tracker_owner";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v19 = "nw_endpoint_set_tracker_owner";
            __int16 v20 = 2082;
            BOOL v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v14)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_endpoint_set_tracker_owner";
          _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_endpoint_set_tracker_owner";
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_endpoint_get_tracker_owner(uint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

BOOL nw_endpoint_hostname_matches_tracker(void *a1)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = (const char **)v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v31 = "nw_endpoint_hostname_matches_tracker";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v31 = "nw_endpoint_hostname_matches_tracker";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_50;
    }

    if (!v28)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v31 = "nw_endpoint_hostname_matches_tracker";
        _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_50;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v31 = "nw_endpoint_hostname_matches_tracker";
        _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_50;
    }

    if (v23)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v31 = "nw_endpoint_hostname_matches_tracker";
      __int16 v32 = 2082;
      uint64_t v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_38;
  }

  if (!v1[11])
  {
    __nwlog_obj();
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v31 = "nw_endpoint_hostname_matches_tracker";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v31 = "nw_endpoint_hostname_matches_tracker";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null endpoint->known_tracker_name", buf, 0xCu);
      }

void sub_181DB60C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_is_approved_app_domain(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 64;
    }
    else {
      char v5 = 0;
    }
    *((_BYTE *)v3 + 231) = *((_BYTE *)v3 + 231) & 0xBF | v5;
    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v17 = "nw_endpoint_set_is_approved_app_domain";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_endpoint_set_is_approved_app_domain";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v17 = "nw_endpoint_set_is_approved_app_domain";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_endpoint_set_is_approved_app_domain";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_endpoint_set_is_approved_app_domain";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_set_can_block_request(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 0x80;
    }
    else {
      char v5 = 0;
    }
    *((_BYTE *)v3 + 231) = v5 & 0x80 | *((_BYTE *)v3 + 231) & 0x7F;
    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v17 = "nw_endpoint_set_can_block_request";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_endpoint_set_can_block_request";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v17 = "nw_endpoint_set_can_block_request";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_endpoint_set_can_block_request";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_endpoint_set_can_block_request";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_endpoint_get_can_block_request(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = v1[231] < 0;
    goto LABEL_3;
  }

  __nwlog_obj();
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_endpoint_get_can_block_request";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_get_can_block_request";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_endpoint_get_can_block_request";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_get_can_block_request";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_endpoint_get_can_block_request";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_endpoint_has_associations_block_invoke_34(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 231) & 8) != 0)
  {
    *(_BYTE *)(v2 + 231) &= ~8u;
  }

  else
  {
    BOOL v3 = *(void **)(v2 + 64);
    if (v3)
    {
      free(v3);
      *(void *)(v2 + 64) = 0LL;
    }

    id v4 = *(void **)(v2 + 56);
    *(void *)(v2 + 56) = 0LL;
  }

  uint64_t v5 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v5 + 231) & 0x10) != 0)
  {
    *(_BYTE *)(v5 + 231) &= ~0x10u;
  }

  else
  {
    os_log_type_t v6 = *(void **)(v5 + 80);
    if (v6)
    {
      free(v6);
      *(void *)(v5 + 80) = 0LL;
    }

    id v7 = *(void **)(v5 + 72);
    *(void *)(v5 + 72) = 0LL;
  }

uint64_t __nw_endpoint_get_connected_flow_count_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3 = (id)nw_hash_node_get_object(a2);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += nw_association_get_connected_flow_count(v3);

  return 1LL;
}

void sub_181DB69A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 216LL);
  if (v2)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    v3[2] = ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke_2;
    v3[3] = &unk_189BB6EE8;
    v3[4] = *(void *)(a1 + 40);
    nw_array_remove_objects(v2, (uint64_t)v3);
  }

uint64_t ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    __int16 v18 = "nw_endpoint_edge_is_active";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v18 = "nw_endpoint_edge_is_active";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null edge", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v18 = "nw_endpoint_edge_is_active";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null edge, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v13)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v18 = "nw_endpoint_edge_is_active";
          _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null edge, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v18 = "nw_endpoint_edge_is_active";
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null edge, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181DB6D34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_copy_registrar_for_identifier(void *a1, __int128 *a2, int a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  os_log_type_t v6 = v5;
  if (v5)
  {
    if (a2)
    {
      id v7 = v5[26];
      if (v7) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = a3 == 0;
      }
      if (v8)
      {
        if (v7 || (a3 & 1) != 0 || !gLogDatapath) {
          goto LABEL_17;
        }
        os_log_type_t v9 = a2;
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_42;
        }
        *(_DWORD *)int buf = 136446978;
        BOOL v45 = "nw_endpoint_copy_registrar_for_identifier";
        __int16 v46 = 2080;
        os_log_type_t v47 = (char *)v9;
        __int16 v48 = 2080;
        logging_description = nw_endpoint_get_logging_description(v6);
        __int16 v50 = 2048;
        BOOL v51 = v6;
        BOOL v11 = "%{public}s no %s registrar for endpoint %s (%p), asked not to create a new one, returning nil";
        goto LABEL_41;
      }

      os_log_type_t v12 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_protocol_instance_registrar);
      if (!v12) {
        goto LABEL_76;
      }
      v43.os_log_type_t receiver = v12;
      v43.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_protocol_instance_registrar;
      BOOL v13 = objc_msgSendSuper2(&v43, sel_init);
      os_log_type_t v14 = v13;
      if (v13)
      {
        v13[2] = 0LL;
        nw_protocol_identifier_copy((uint64_t)(v13 + 3), a2);
        v14[8] = 0LL;
LABEL_16:
        id v15 = v6[26];
        v6[26] = v14;

        if (!gLogDatapath)
        {
LABEL_17:
          id v16 = v6[26];
          goto LABEL_18;
        }

        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
LABEL_42:

          goto LABEL_17;
        }

        os_log_type_t v29 = (char *)v6[26];
        os_log_type_t v30 = nw_endpoint_get_logging_description(v6);
        *(_DWORD *)int buf = 136446978;
        BOOL v45 = "nw_endpoint_copy_registrar_for_identifier";
        __int16 v46 = 2112;
        os_log_type_t v47 = v29;
        __int16 v48 = 2080;
        logging_description = v30;
        __int16 v50 = 2048;
        BOOL v51 = v6;
        BOOL v11 = "%{public}s created registrar %@ for endpoint %s (%p)";
LABEL_41:
        _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, v11, buf, 0x2Au);
        goto LABEL_42;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v31 = (id)gLogObj;
      *(_DWORD *)int buf = 136446210;
      BOOL v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
      __int16 v32 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v41 = 0;
      if ((__nwlog_fault(v32, &type, &v41) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v33 = (os_log_s *)(id)gLogObj;
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)int buf = 136446210;
            BOOL v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s [super init] failed", buf, 0xCu);
          }
        }

        else if (v41)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v33 = (os_log_s *)(id)gLogObj;
          os_log_type_t v36 = type;
          BOOL v37 = os_log_type_enabled(v33, type);
          if (backtrace_string)
          {
            if (v37)
            {
              *(_DWORD *)int buf = 136446466;
              BOOL v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
              __int16 v46 = 2082;
              os_log_type_t v47 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v33,  v36,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_74;
          }

          if (v37)
          {
            *(_DWORD *)int buf = 136446210;
            BOOL v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_181A5C000, v33, v36, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v33 = (os_log_s *)(id)gLogObj;
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)int buf = 136446210;
            BOOL v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl( &dword_181A5C000,  v33,  v40,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

void sub_181DB75FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_add_edge(void *a1, void *a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v32 = "nw_endpoint_add_edge";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v8, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v32 = "nw_endpoint_add_edge";
          _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null endpoint", buf, 0xCu);
        }

        goto LABEL_21;
      }

      if (!v29)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v32 = "nw_endpoint_add_edge";
          _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v32 = "nw_endpoint_add_edge";
          _os_log_impl(&dword_181A5C000, v9, v20, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_21;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v32 = "nw_endpoint_add_edge";
        __int16 v33 = 2082;
        os_log_type_t v34 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    goto LABEL_22;
  }

  if (!v4)
  {
    __nwlog_obj();
    __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v32 = "nw_endpoint_add_edge";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v8, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v32 = "nw_endpoint_add_edge";
          _os_log_impl(&dword_181A5C000, v9, v18, "%{public}s called with null edge", buf, 0xCu);
        }

        goto LABEL_21;
      }

      if (!v29)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v32 = "nw_endpoint_add_edge";
          _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null edge, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_21;
      }

      BOOL v11 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v9, type);
      if (!v11)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v32 = "nw_endpoint_add_edge";
          _os_log_impl(&dword_181A5C000, v9, v22, "%{public}s called with null edge, no backtrace", buf, 0xCu);
        }

        goto LABEL_21;
      }

      if (v23)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v32 = "nw_endpoint_add_edge";
        __int16 v33 = 2082;
        os_log_type_t v34 = v11;
        _os_log_impl( &dword_181A5C000,  v9,  v22,  "%{public}s called with null edge, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_14;
    }

void sub_181DB7D90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_add_edge_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2[27]
    || (BOOL v3 = nw_array_create(),
        uint64_t v4 = *(void *)(a1 + 32),
        uint64_t v5 = *(void **)(v4 + 216),
        *(void *)(v4 + 216) = v3,
        v5,
        uint64_t v2 = *(void **)(a1 + 32),
        v2[27]))
  {
    id v6 = *(void **)(a1 + 40);
    id v7 = v2;
    id v8 = v6;
    if (v8)
    {
      os_log_type_t v9 = v8;
      *(void *)char v41 = 0LL;
      id v42 = v41;
      uint64_t v43 = 0x2020000000LL;
      char v44 = 0;
      os_log_type_t v10 = (unsigned __int8 *)v2[27];
      if (v10)
      {
        *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
        uint64_t v36 = 3221225472LL;
        BOOL v37 = ___ZL27nw_endpoint_has_edge_lockedP22NWConcrete_nw_endpointPU30objcproto19OS_nw_endpoint_edge8NSObject_block_invoke;
        os_log_type_t v38 = &unk_189BC7960;
        id v39 = v8;
        os_log_type_t v40 = v41;
        nw_array_apply(v10, (uint64_t)type);
      }

      if (gLogDatapath)
      {
        __nwlog_obj();
        id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          logging_description = nw_endpoint_get_logging_description(v7);
          uint64_t v29 = v2[27];
          if (*((_BYTE *)v42 + 24)) {
            os_log_type_t v30 = "already has";
          }
          else {
            os_log_type_t v30 = "does not already have";
          }
          *(_DWORD *)int buf = 136447234;
          os_log_type_t v47 = "nw_endpoint_has_edge_locked";
          __int16 v48 = 2080;
          int v49 = (void *)logging_description;
          __int16 v50 = 2112;
          uint64_t v51 = v29;
          __int16 v52 = 2080;
          id v53 = v30;
          __int16 v54 = 2112;
          os_log_type_t v55 = v9;
          _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %s edges %@ %s edge %@",  buf,  0x34u);
        }
      }

      BOOL v11 = *((_BYTE *)v42 + 24) == 0;
      _Block_object_dispose(v41, 8);

      if (!v11)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          BOOL v13 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
          uint64_t v14 = *(void *)(a1 + 40);
          *(_DWORD *)int buf = 136446722;
          os_log_type_t v47 = "nw_endpoint_add_edge_block_invoke";
          __int16 v48 = 2080;
          int v49 = (void *)v13;
          __int16 v50 = 2112;
          uint64_t v51 = v14;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %s not adding already present edge %@",  buf,  0x20u);
        }

        return;
      }

void sub_181DB84D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_endpoint_has_edge_lockedP22NWConcrete_nw_endpointPU30objcproto19OS_nw_endpoint_edge8NSObject_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (id *)*(id *)(a1 + 32);
  id v6 = a3;
  id v7 = (id *)v6;
  if (v5) {
    BOOL v8 = v6 == 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {

    if (v5 == v7) {
      goto LABEL_25;
    }
    return 1LL;
  }

  BOOL v13 = v5[1] == (id)v6[1] && v5[2] == (id)v6[2] && v5[3] == (id)v6[3] && v5[4] == (id)v6[4] && v5[5] == (id)v6[5];
  if (!v13
    || (id WeakRetained = objc_loadWeakRetained(v5 + 6),
        id v15 = objc_loadWeakRetained(v7 + 6),
        v15,
        WeakRetained,
        WeakRetained != v15))
  {

    return 1LL;
  }

  char v16 = *((_BYTE *)v7 + 64) ^ *((_BYTE *)v5 + 64);

  if ((v16 & 1) != 0) {
    return 1LL;
  }
LABEL_25:
  uint64_t result = 0LL;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  return result;
}

void nw_endpoint_enumerate_edges(void *a1, uint64_t a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a3;
  if (v6)
  {
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    id v28 = __Block_byref_object_copy__6408;
    uint64_t v29 = __Block_byref_object_dispose__6409;
    uint64_t v7 = MEMORY[0x1895F87A8];
    id v30 = 0LL;
    v22[0] = MEMORY[0x1895F87A8];
    v22[1] = 3221225472LL;
    v22[2] = __nw_endpoint_enumerate_edges_block_invoke;
    v22[3] = &unk_189BC9210;
    os_log_type_t v24 = buf;
    id v8 = v5;
    id v23 = v8;
    nw_endpoint_locked(v8, v22);
    os_log_type_t v9 = *(unsigned __int8 **)(*(void *)&buf[8] + 40LL);
    if (v9)
    {
      v18[0] = v7;
      v18[1] = 3221225472LL;
      v18[2] = __nw_endpoint_enumerate_edges_block_invoke_2;
      v18[3] = &unk_189BB6EC0;
      id v19 = v8;
      uint64_t v21 = a2;
      id v20 = v6;
      nw_array_apply(v9, (uint64_t)v18);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v11, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null enumerator", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null enumerator, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DB8994( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, id a32)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void __nw_endpoint_enumerate_edges_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 216LL);
  uint64_t v3 = nw_array_create();
  uint64_t v4 = v3;
  if (v2)
  {
    if (v3 == v2) {
      uint64_t v4 = v2;
    }
    else {
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v3 + 16,  *(void ***)(v2 + 16),  *(void ***)(v2 + 24),  (uint64_t)(*(void *)(v2 + 24) - *(void *)(v2 + 16)) >> 3);
    }
  }

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

uint64_t __nw_endpoint_enumerate_edges_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3;
  id v6 = v5;
  if (v5)
  {
    uint64_t v7 = v5 + 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v23 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  id v39 = "nw_endpoint_edge_get_identifier";
  os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (__nwlog_fault(v24, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v39 = "nw_endpoint_edge_get_identifier";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null edge", buf, 0xCu);
      }
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v25, type);
      if (backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)int buf = 136446466;
          id v39 = "nw_endpoint_edge_get_identifier";
          __int16 v40 = 2082;
          char v41 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v25,  v32,  "%{public}s called with null edge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_53;
      }

      if (v33)
      {
        *(_DWORD *)int buf = 136446210;
        id v39 = "nw_endpoint_edge_get_identifier";
        _os_log_impl(&dword_181A5C000, v25, v32, "%{public}s called with null edge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v39 = "nw_endpoint_edge_get_identifier";
        _os_log_impl( &dword_181A5C000,  v25,  v34,  "%{public}s called with null edge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DB8F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_add_edges_for_instance(void *a1, unsigned __int8 *a2, int a3)
{
  uint64_t v116 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    id v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
    __int16 v54 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v110 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = type[0];
      if (os_log_type_enabled(v55, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
        _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v110)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v66 = type[0];
      BOOL v67 = os_log_type_enabled(v55, type[0]);
      if (backtrace_string)
      {
        if (v67)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v55,  v66,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_104:
        if (!v54) {
          goto LABEL_55;
        }
LABEL_105:
        free(v54);
        goto LABEL_55;
      }

      if (v67)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
        _os_log_impl(&dword_181A5C000, v55, v66, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v74 = type[0];
      if (os_log_type_enabled(v55, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
        _os_log_impl( &dword_181A5C000,  v55,  v74,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DBA4E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, void *a36, void *a37)
{
  _Unwind_Resume(a1);
}

void sub_181DBA8E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ws_request_enumerate_subprotocols(nw_ws_request_t request, nw_ws_subprotocol_enumerator_t enumerator)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  nw_ws_request_t v3 = request;
  nw_ws_subprotocol_enumerator_t v4 = enumerator;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      id v6 = (void *)*((void *)v3 + 1);
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_ws_request_enumerate_subprotocols_block_invoke;
      applier[3] = &unk_189BC0F80;
      id v23 = v4;
      BOOL v7 = xpc_array_apply(v6, applier);

      goto LABEL_4;
    }

    __nwlog_obj();
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v27 = "nw_ws_request_enumerate_subprotocols";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v10, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v27 = "nw_ws_request_enumerate_subprotocols";
          _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null enumerator", buf, 0xCu);
        }

void sub_181DBAE60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_request_enumerate_subprotocols_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  xpc_string_get_string_ptr(v4);
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();

  return v5;
}

void sub_181DBAEC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ws_request_enumerate_additional_headers( nw_ws_request_t request, nw_ws_additional_header_enumerator_t enumerator)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  nw_ws_request_t v3 = request;
  nw_ws_additional_header_enumerator_t v4 = enumerator;
  uint64_t v5 = (uint64_t (**)(void, void, void))v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v29 = "nw_ws_request_enumerate_additional_headers";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v29 = "nw_ws_request_enumerate_additional_headers";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v29 = "nw_ws_request_enumerate_additional_headers";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v13)
        {
LABEL_6:
          BOOL v8 = 0;
          goto LABEL_7;
        }

void sub_181DBB3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181DBB794( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint32_t nw_establishment_report_get_previous_attempt_count(nw_establishment_report_t report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v1 = report;
  nw_establishment_report_t v2 = v1;
  if (v1)
  {
    uint32_t v3 = *((_DWORD *)v1 + 20);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_establishment_report_get_previous_attempt_count";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_previous_attempt_count";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_establishment_report_get_previous_attempt_count";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_previous_attempt_count";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_previous_attempt_count";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_establishment_report_get_proxy_configured(nw_establishment_report_t report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v1 = report;
  nw_establishment_report_t v2 = v1;
  if (v1)
  {
    BOOL v3 = *((_BYTE *)v1 + 84) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_establishment_report_get_proxy_configured";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_proxy_configured";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_establishment_report_get_proxy_configured";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_proxy_configured";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_proxy_configured";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_establishment_report_get_used_proxy(nw_establishment_report_t report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v1 = report;
  nw_establishment_report_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (v1[84] >> 1) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_establishment_report_get_used_proxy";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_used_proxy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_establishment_report_get_used_proxy";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_used_proxy";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_used_proxy";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_establishment_report_enumerate_proxy_endpoints(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  BOOL v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    char v26 = "nw_establishment_report_enumerate_proxy_endpoints";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v26 = "nw_establishment_report_enumerate_proxy_endpoints";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          char v26 = "nw_establishment_report_enumerate_proxy_endpoints";
          __int16 v27 = 2082;
          __int16 v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        char v26 = "nw_establishment_report_enumerate_proxy_endpoints";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v26 = "nw_establishment_report_enumerate_proxy_endpoints";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_establishment_report_enumerate_proxy_endpoints_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_181DBC928(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_duration_milliseconds(nw_data_transfer_report_t report)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v1 = report;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v17 = "nw_data_transfer_report_get_duration_milliseconds";
    size_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_data_transfer_report_get_duration_milliseconds";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
        }
      }

      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v17 = "nw_data_transfer_report_get_duration_milliseconds";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v11,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (v12)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_data_transfer_report_get_duration_milliseconds";
          _os_log_impl(&dword_181A5C000, v7, v11, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v17 = "nw_data_transfer_report_get_duration_milliseconds";
          _os_log_impl( &dword_181A5C000,  v7,  v13,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181DBCC94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_interface_t nw_data_transfer_report_copy_path_interface( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
          __int16 v35 = 2082;
          *(void *)char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
        _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_48;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_51;
  }

  if (path_index == -1) {
    uint32_t v5 = 0;
  }
  else {
    uint32_t v5 = path_index;
  }
  if (v5 >= *((_DWORD *)v4 + 11))
  {
    __nwlog_obj();
    BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
    int v16 = *((_DWORD *)v4 + 11);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
    __int16 v35 = 1024;
    *(_DWORD *)char v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = v16;
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v18 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }

    else if (v31)
    {
      uint32_t v22 = v5;
      char v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          int v26 = *((_DWORD *)v4 + 11);
          *(_DWORD *)int buf = 136446978;
          os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
          __int16 v35 = 1024;
          *(_DWORD *)char v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          __int16 v37 = 2082;
          unsigned int v38 = v23;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v23);
        goto LABEL_49;
      }

      if (v25)
      {
        int v30 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), no backtrace",  buf,  0x18u);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v29 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_copy_path_interface";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded",  buf,  0x18u);
      }
    }

void sub_181DBD278(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_application_byte_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 28);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 168);
        v11 += *(void *)(v13 + 528);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 192);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DBD870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_received_application_byte_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 27);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 160);
        v11 += *(void *)(v13 + 520);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 200);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DBDE68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_transport_byte_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 15);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 64);
        v11 += *(void *)(v13 + 424);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 296);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DBE460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_transport_retransmitted_byte_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 16);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 72);
        v11 += *(void *)(v13 + 432);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 288);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DBEA58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_received_transport_byte_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 12);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 40);
        v11 += *(void *)(v13 + 400);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 320);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DBF050(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_received_transport_duplicate_byte_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 13);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 48);
        v11 += *(void *)(v13 + 408);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 312);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DBF648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_received_transport_out_of_order_byte_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 14);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 56);
        v11 += *(void *)(v13 + 416);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 304);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    uint32_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DBFC40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
          __int16 v35 = 2082;
          *(void *)char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
        _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_48;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_51;
  }

  if (path_index == -1) {
    uint32_t v5 = 0;
  }
  else {
    uint32_t v5 = path_index;
  }
  if (v5 >= *((_DWORD *)v4 + 11))
  {
    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    int v16 = *((_DWORD *)v4 + 11);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
    __int16 v35 = 1024;
    *(_DWORD *)char v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = v16;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v18 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }

    else if (v31)
    {
      uint32_t v22 = v5;
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          int v26 = *((_DWORD *)v4 + 11);
          *(_DWORD *)int buf = 136446978;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
          __int16 v35 = 1024;
          *(_DWORD *)char v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          __int16 v37 = 2082;
          unsigned int v38 = v23;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v23);
        goto LABEL_49;
      }

      if (v25)
      {
        int v30 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), no backtrace",  buf,  0x18u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v29 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded",  buf,  0x18u);
      }
    }

void sub_181DC021C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_transport_minimum_rtt_milliseconds( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
          __int16 v35 = 2082;
          *(void *)char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
        _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_48;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_51;
  }

  if (path_index == -1) {
    uint32_t v5 = 0;
  }
  else {
    uint32_t v5 = path_index;
  }
  if (v5 >= *((_DWORD *)v4 + 11))
  {
    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    int v16 = *((_DWORD *)v4 + 11);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
    __int16 v35 = 1024;
    *(_DWORD *)char v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = v16;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v18 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }

    else if (v31)
    {
      uint32_t v22 = v5;
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          int v26 = *((_DWORD *)v4 + 11);
          *(_DWORD *)int buf = 136446978;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
          __int16 v35 = 1024;
          *(_DWORD *)char v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          __int16 v37 = 2082;
          unsigned int v38 = v23;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v23);
        goto LABEL_49;
      }

      if (v25)
      {
        int v30 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), no backtrace",  buf,  0x18u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v29 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded",  buf,  0x18u);
      }
    }

void sub_181DC07F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_transport_rtt_variance( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
          __int16 v35 = 2082;
          *(void *)char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
        _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_48;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_51;
  }

  if (path_index == -1) {
    uint32_t v5 = 0;
  }
  else {
    uint32_t v5 = path_index;
  }
  if (v5 >= *((_DWORD *)v4 + 11))
  {
    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    int v16 = *((_DWORD *)v4 + 11);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
    __int16 v35 = 1024;
    *(_DWORD *)char v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = v16;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v18 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }

    else if (v31)
    {
      uint32_t v22 = v5;
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          int v26 = *((_DWORD *)v4 + 11);
          *(_DWORD *)int buf = 136446978;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
          __int16 v35 = 1024;
          *(_DWORD *)char v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          __int16 v37 = 2082;
          unsigned int v38 = v23;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v23);
        goto LABEL_49;
      }

      if (v25)
      {
        int v30 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), no backtrace",  buf,  0x18u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v29 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_rtt_variance";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded",  buf,  0x18u);
      }
    }

void sub_181DC0DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_transport_congestion_window(void *a1, unsigned int a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
          __int16 v35 = 2082;
          *(void *)char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
        _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_48;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_51;
  }

  if (a2 == -1) {
    unsigned int v5 = 0;
  }
  else {
    unsigned int v5 = a2;
  }
  if (v5 >= *((_DWORD *)v4 + 11))
  {
    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    int v16 = *((_DWORD *)v4 + 11);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
    __int16 v35 = 1024;
    *(_DWORD *)char v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = v16;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v18 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }

    else if (v31)
    {
      unsigned int v22 = v5;
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          int v26 = *((_DWORD *)v4 + 11);
          *(_DWORD *)int buf = 136446978;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
          __int16 v35 = 1024;
          *(_DWORD *)char v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          __int16 v37 = 2082;
          unsigned int v38 = v23;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v23);
        goto LABEL_49;
      }

      if (v25)
      {
        int v30 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), no backtrace",  buf,  0x18u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v29 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_congestion_window";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded",  buf,  0x18u);
      }
    }

void sub_181DC13B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_transport_slow_start_threshold(void *a1, unsigned int a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
          __int16 v35 = 2082;
          *(void *)char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
        _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_48;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_51;
  }

  if (a2 == -1) {
    unsigned int v5 = 0;
  }
  else {
    unsigned int v5 = a2;
  }
  if (v5 >= *((_DWORD *)v4 + 11))
  {
    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    int v16 = *((_DWORD *)v4 + 11);
    *(_DWORD *)int buf = 136446722;
    os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
    __int16 v35 = 1024;
    *(_DWORD *)char v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = v16;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v18 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }

    else if (v31)
    {
      unsigned int v22 = v5;
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          int v26 = *((_DWORD *)v4 + 11);
          *(_DWORD *)int buf = 136446978;
          os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
          __int16 v35 = 1024;
          *(_DWORD *)char v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          __int16 v37 = 2082;
          unsigned int v38 = v23;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v23);
        goto LABEL_49;
      }

      if (v25)
      {
        int v30 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s path_index (%u) >= report->path_count (%u), no backtrace",  buf,  0x18u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        int v29 = *((_DWORD *)v4 + 11);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v34 = "nw_data_transfer_report_get_transport_slow_start_threshold";
        __int16 v35 = 1024;
        *(_DWORD *)char v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded",  buf,  0x18u);
      }
    }

void sub_181DC198C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_ip_packet_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 11);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 32);
        v11 += *(void *)(v13 + 392);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 328);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DC1F84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_received_ip_packet_count( nw_data_transfer_report_t report, uint32_t path_index)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = report;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
      __int16 v35 = 2082;
      char v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (path_index == -1)
  {
    uint64_t v7 = *((void *)v4 + 7);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = (void *)*((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *v13;
        v11 += v13[45];
        v13 += 90;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    int v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 360);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= path_index)
  {
    __nwlog_obj();
    unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
    int v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v34 = "nw_data_transfer_report_get_received_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DC257C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_report_resolution_source_t nw_resolution_report_get_source(nw_resolution_report_t resolution_report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_resolution_report_t v1 = resolution_report;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    nw_report_resolution_source_t v3 = *((_DWORD *)v1 + 15);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_get_source";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_source";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_get_source";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_source";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_source";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint32_t nw_resolution_report_get_endpoint_count(nw_resolution_report_t resolution_report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_resolution_report_t v1 = resolution_report;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint32_t v3 = *((_DWORD *)v1 + 14);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_get_endpoint_count";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_endpoint_count";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_get_endpoint_count";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_endpoint_count";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_endpoint_count";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

nw_endpoint_t nw_resolution_report_copy_successful_endpoint(nw_resolution_report_t resolution_report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_resolution_report_t v1 = resolution_report;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint32_t v3 = (nw_endpoint *)v1[4];
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_copy_successful_endpoint";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_copy_successful_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_copy_successful_endpoint";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_copy_successful_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_copy_successful_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

nw_endpoint_t nw_resolution_report_copy_preferred_endpoint(nw_resolution_report_t resolution_report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_resolution_report_t v1 = resolution_report;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint32_t v3 = (nw_endpoint *)v1[5];
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_copy_preferred_endpoint";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_copy_preferred_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_copy_preferred_endpoint";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_copy_preferred_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_copy_preferred_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_resolution_report_enumerate_endpoints(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint32_t v3 = a1;
  id v4 = a2;
  unsigned int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v26 = "nw_resolution_report_enumerate_endpoints";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v26 = "nw_resolution_report_enumerate_endpoints";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v26 = "nw_resolution_report_enumerate_endpoints";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v26 = "nw_resolution_report_enumerate_endpoints";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v26 = "nw_resolution_report_enumerate_endpoints";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_resolution_report_enumerate_endpoints_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

nw_report_resolution_protocol_t nw_resolution_report_get_protocol(nw_resolution_report_t resolution_report)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_resolution_report_t v1 = resolution_report;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    nw_report_resolution_protocol_t v3 = *((_DWORD *)v1 + 16);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_get_protocol";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_protocol";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_get_protocol";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_protocol";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_protocol";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_resolution_report_received_svcb(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((_BYTE *)v1 + 70) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_received_svcb";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_received_svcb";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_received_svcb";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_received_svcb";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_received_svcb";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_resolution_report_get_dns_failure_reason(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = 1LL;
    switch(*((_WORD *)v1 + 34))
    {
      case 4:
      case 0xF:
        goto LABEL_24;
      case 0x10:
        uint64_t v3 = 2LL;
        break;
      case 0x11:
        uint64_t v3 = 3LL;
        break;
      default:
        goto LABEL_23;
    }

    goto LABEL_24;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_get_dns_failure_reason";
  unsigned int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_dns_failure_reason";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_get_dns_failure_reason";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_dns_failure_reason";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null resolution_report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_dns_failure_reason";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_resolution_report_get_extended_dns_error_code(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[34];
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_get_extended_dns_error_code";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_extended_dns_error_code";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_get_extended_dns_error_code";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_extended_dns_error_code";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_extended_dns_error_code";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_resolution_report_get_extended_dns_error_extra_text(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 3);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_get_extended_dns_error_extra_text";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_extended_dns_error_extra_text";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_get_extended_dns_error_extra_text";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_extended_dns_error_extra_text";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_extended_dns_error_extra_text";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_resolution_report_get_provider_name(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 2);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_resolution_report_get_provider_name";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_provider_name";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_resolution_report_get_provider_name";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_provider_name";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolution_report, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_resolution_report_get_provider_name";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolution_report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_establishment_report_set_l4s_enabled(void *a1, char a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 40) = *((_BYTE *)v3 + 40) & 0xFE | a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_protocol_establishment_report_set_l4s_enabled";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_protocol_establishment_report_set_l4s_enabled";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_protocol_establishment_report_set_l4s_enabled";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_protocol_establishment_report_set_l4s_enabled";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_protocol_establishment_report_set_l4s_enabled";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

const char *nw_connection_get_privacy_stance_string(int a1)
{
  else {
    return off_189BB70A8[a1 - 1];
  }
}

void nw_connection_fillout_failed_resolution_report_on_nw_queue(void *a1, void *a2)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    nw_context_assert_queue(v3[3]);
    unsigned int v5 = v4;
    if (v5)
    {
      uint64_t v6 = v5;
      int v7 = v5[29];

      if (v7 == 1)
      {
        os_log_type_t v8 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_resolution_report);
        __int16 v56 = WORD2(v6) ^ WORD1(v6) ^ HIWORD(v6) ^ (unsigned __int16)v6;
        nw_endpoint_t v9 = nw_endpoint_handler_copy_endpoint(v6);
        nw_endpoint_t v10 = v9;
        if (v9 && (v11 = v9, int v12 = -[nw_endpoint type](v11, "type"), v11, v12 == 3))
        {
          int v13 = 4;
          int v14 = 3;
        }

        else
        {
          int v13 = 2;
          int v14 = 1;
        }

        int event_milliseconds = nw_connection_get_event_milliseconds(v3, 2, v14, &v56, 0LL);
        v8->endpoint_size_t count = nw_endpoint_handler_get_resolved_endpoint_count(v6);
        v8->uint64_t source = nw_endpoint_handler_get_resolution_source(v6);
        v8->int protocol = nw_endpoint_handler_get_resolution_protocol(v6);
        nw_endpoint_t v24 = nw_endpoint_handler_copy_preferred_resolved_endpoint(v6);
        preferred_endpoint = v8->preferred_endpoint;
        v8->preferred_endpoint = v24;

        BOOL v26 = (OS_nw_array *)nw_endpoint_handler_copy_resolved_endpoints(v6);
        resolved_endpoints = v8->resolved_endpoints;
        v8->resolved_endpoints = v26;

        BOOL v55 = 0;
        nw_endpoint_handler_get_svcb_report(v6, 0LL, &v55, 0LL);
        *((_BYTE *)v8 + 70) = *((_BYTE *)v8 + 70) & 0xFE | v55;
        *(void *)int buf = 0LL;
        nw_endpoint_handler_get_resolution_provider(v6, (uint64_t)buf);
        v8->provider_name = *(char **)buf;
        unsigned __int16 v54 = 0;
        *(void *)os_log_type_t type = 0LL;
        nw_endpoint_handler_get_extended_dns_error(v6, &v54, (char **)type);
        v8->int extended_dns_error_code = v54;
        v8->extended_dns_error_extra_text = *(char **)type;
        BOOL v28 = v3[54];
        v3[54] = v8;
      }

      else
      {
        BOOL v15 = v6;
        int v16 = v6[29];

        if (v16 == 3 && !v3[54])
        {
          nw_endpoint_t v17 = nw_endpoint_handler_copy_endpoint(v15);
          nw_endpoint_t v18 = v17;
          if (v17)
          {
            uint64_t v19 = v17;
            unsigned int v20 = *((_DWORD *)v19 + 56);

            if (v20)
            {
              BOOL v21 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_resolution_report);
              if (v20 < 4) {
                v21->int extended_dns_error_code = v20 + 14;
              }
              id v22 = v3[54];
              v3[54] = v21;
            }
          }
        }
      }

      goto LABEL_17;
    }

    __nwlog_obj();
    BOOL v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v56) = 0;
    if (__nwlog_fault(v34, type, &v56))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s called with null handler", buf, 0xCu);
        }

void sub_181DC4FF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_failed_resolution_report(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    uint64_t v19 = __Block_byref_object_copy__7759;
    unsigned int v20 = __Block_byref_object_dispose__7760;
    id v21 = 0LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_copy_failed_resolution_report_block_invoke;
    v13[3] = &unk_189BC9210;
    BOOL v15 = buf;
    int v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_failed_resolution_report_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __Block_byref_object_copy__7759(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__7760(uint64_t a1)
{
}

void __nw_connection_copy_failed_resolution_report_block_invoke(uint64_t a1)
{
}

void __nw_connection_fillout_establishment_report_on_nw_queue_block_invoke(uint64_t a1, void *a2)
{
}

void __nw_connection_fillout_establishment_report_on_nw_queue_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_endpoint_t v4 = nw_endpoint_handler_copy_endpoint(v3);
  nw_endpoint_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = v4;
    id v7 = v6[15];

    uint64_t v8 = *(void *)(a1 + 32);
    nw_endpoint_t v9 = *(void **)(v8 + 48);
    *(void *)(v8 + 4_Block_object_dispose(va, 8) = v7;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 48LL);
      int v12 = 136446467;
      int v13 = "nw_connection_fillout_establishment_report_on_nw_queue_block_invoke_2";
      __int16 v14 = 2117;
      uint64_t v15 = v11;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s Proxied next hops: %{sensitive}@\n",  (uint8_t *)&v12,  0x16u);
    }
  }
}

void sub_181DC54F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_fillout_establishment_report_on_nw_queue_block_invoke_138(uint64_t a1)
{
  *(_DWORD *)(*(void *)(a1 + 32) + 56LL) = *(_DWORD *)(*(void *)(a1 + 40) + 504LL);
  objc_storeStrong((id *)(*(void *)(a1 + 40) + 416LL), *(id *)(a1 + 32));
}

void __nw_connection_copy_establishment_report_off_queue_block_invoke(uint64_t a1)
{
}

void nw_connection_access_establishment_report( nw_connection_t connection, dispatch_queue_t queue, nw_establishment_report_access_block_t access_block)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  nw_endpoint_t v5 = connection;
  uint64_t v6 = queue;
  nw_establishment_report_access_block_t v7 = access_block;
  uint64_t v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    nw_endpoint_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v35 = "nw_connection_access_establishment_report";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_connection_access_establishment_report";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v35 = "nw_connection_access_establishment_report";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10) {
          goto LABEL_5;
        }
LABEL_56:
        free(v10);
        goto LABEL_5;
      }

      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_connection_access_establishment_report";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v35 = "nw_connection_access_establishment_report";
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DC5C70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_access_establishment_report_block_invoke(uint64_t a1)
{
  nw_resolution_report_t v2 = *(void **)(a1 + 32);
  id v3 = (void *)v2[52];
  if (!v3)
  {
    nw_connection_fillout_establishment_report_on_nw_queue(v2, 0);
    id v3 = *(void **)(*(void *)(a1 + 32) + 416LL);
  }

  id v4 = v3;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __nw_connection_access_establishment_report_block_invoke_2;
  v8[3] = &unk_189BC91E8;
  nw_endpoint_t v5 = *(dispatch_queue_s **)(a1 + 40);
  id v6 = *(id *)(a1 + 48);
  id v9 = v4;
  id v10 = v6;
  id v7 = v4;
  dispatch_async(v5, v8);
}

uint64_t __nw_connection_access_establishment_report_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

nw_endpoint_t nw_establishment_report_copy_proxy_endpoint(nw_establishment_report_t report)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v1 = report;
  nw_establishment_report_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    nw_endpoint_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    nw_endpoint_t v17 = "nw_establishment_report_copy_proxy_endpoint";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          nw_endpoint_t v17 = "nw_establishment_report_copy_proxy_endpoint";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
        }
      }

      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)int buf = 136446466;
            nw_endpoint_t v17 = "nw_establishment_report_copy_proxy_endpoint";
            __int16 v18 = 2082;
            BOOL v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v11)
        {
          *(_DWORD *)int buf = 136446210;
          nw_endpoint_t v17 = "nw_establishment_report_copy_proxy_endpoint";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)int buf = 136446210;
          nw_endpoint_t v17 = "nw_establishment_report_copy_proxy_endpoint";
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_establishment_report_enumerate_resolutions( nw_establishment_report_t report, nw_report_resolution_enumerator_t enumerate_block)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v3 = report;
  nw_report_resolution_enumerator_t v4 = enumerate_block;
  nw_endpoint_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v26 = "nw_establishment_report_enumerate_resolutions";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_resolutions";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v26 = "nw_establishment_report_enumerate_resolutions";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_resolutions";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_resolutions";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_establishment_report_enumerate_resolutions_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void nw_establishment_report_enumerate_protocol_l4s_state(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v3 = a1;
  id v4 = a2;
  nw_endpoint_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v26 = "nw_establishment_report_enumerate_protocol_l4s_state";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_protocol_l4s_state";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v26 = "nw_establishment_report_enumerate_protocol_l4s_state";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_protocol_l4s_state";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_protocol_l4s_state";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_establishment_report_enumerate_protocol_l4s_state_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void nw_establishment_report_enumerate_proxied_next_hop_endpoints(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  nw_establishment_report_t v3 = a1;
  id v4 = a2;
  nw_endpoint_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v26 = "nw_establishment_report_enumerate_proxied_next_hop_endpoints";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_proxied_next_hop_endpoints";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v26 = "nw_establishment_report_enumerate_proxied_next_hop_endpoints";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_proxied_next_hop_endpoints";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v26 = "nw_establishment_report_enumerate_proxied_next_hop_endpoints";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t __nw_establishment_report_enumerate_proxied_next_hop_endpoints_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke_166(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  BOOL path_report_for_interface_locked = nw_data_transfer_report_get_path_report_for_interface_locked( *(void **)(a1 + 32),  *(void **)(*(void *)(a1 + 32) + 32LL),  0);
  if (!path_report_for_interface_locked)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v20 = "nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke";
        BOOL v11 = "%{public}s called with null ending_path_report";
LABEL_34:
        _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      }

void nw_data_transfer_update_path_report_end( nw_data_transfer_path_report *a1, nw_data_transfer_snapshot *a2)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    BOOL v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v65 = "nw_data_transfer_update_path_report_end";
    os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v65 = "nw_data_transfer_update_path_report_end";
        BOOL v55 = "%{public}s called with null path_report";
LABEL_69:
        _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
      }
    }

    else if (v62)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type;
      BOOL v59 = os_log_type_enabled(v53, type);
      if (backtrace_string)
      {
        if (v59)
        {
          *(_DWORD *)int buf = 136446466;
          int v65 = "nw_data_transfer_update_path_report_end";
          __int16 v66 = 2082;
          BOOL v67 = (nw_data_transfer_path_report *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null path_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_71:
        if (!v52) {
          return;
        }
LABEL_72:
        free(v52);
        return;
      }

      if (v59)
      {
        *(_DWORD *)int buf = 136446210;
        int v65 = "nw_data_transfer_update_path_report_end";
        BOOL v55 = "%{public}s called with null path_report, no backtrace";
        goto LABEL_69;
      }
    }

    else
    {
      __nwlog_obj();
      id v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v65 = "nw_data_transfer_update_path_report_end";
        BOOL v55 = "%{public}s called with null path_report, backtrace limit exceeded";
        goto LABEL_69;
      }
    }

void nw_data_transfer_update_path_report_begin( nw_data_transfer_path_report *a1, nw_data_transfer_snapshot *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    unint64_t v18 = "nw_data_transfer_update_path_report_begin";
    unint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        unint64_t v18 = "nw_data_transfer_update_path_report_begin";
        os_log_type_t v8 = "%{public}s called with null path_report";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          unint64_t v18 = "nw_data_transfer_update_path_report_begin";
          __int16 v19 = 2082;
          os_log_type_t v20 = (nw_data_transfer_path_report *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null path_report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5) {
          return;
        }
LABEL_39:
        free(v5);
        return;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        unint64_t v18 = "nw_data_transfer_update_path_report_begin";
        os_log_type_t v8 = "%{public}s called with null path_report, no backtrace";
        goto LABEL_36;
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        unint64_t v18 = "nw_data_transfer_update_path_report_begin";
        os_log_type_t v8 = "%{public}s called with null path_report, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

BOOL nw_data_transfer_report_get_path_report_for_interface_locked(void *a1, void *a2, int a3)
{
  uint64_t v102 = *MEMORY[0x1895F89C0];
  unint64_t v5 = a1;
  id v6 = a2;
  os_log_type_t v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
    BOOL v61 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (__nwlog_fault(v61, &type, &v91))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v63 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
          _os_log_impl(&dword_181A5C000, v62, v63, "%{public}s called with null report", buf, 0xCu);
        }
      }

      else if (v91)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v65 = type;
        BOOL v66 = os_log_type_enabled(v62, type);
        if (backtrace_string)
        {
          if (v66)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
            __int16 v95 = 2082;
            uint64_t v96 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v62,  v65,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_100;
        }

        if (v66)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
          _os_log_impl(&dword_181A5C000, v62, v65, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v71 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
          _os_log_impl( &dword_181A5C000,  v62,  v71,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181DC9154(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_data_transfer_report_collect_inner(void *a1, void *a2, void *a3, int a4)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  os_log_type_t v7 = a1;
  os_log_type_t v8 = a2;
  id v9 = a3;
  os_log_type_t v10 = (void (**)(void, void))v9;
  if (!v9 || v8 || (a4 & 1) != 0)
  {
    if (!v9 && gLogDatapath)
    {
      __nwlog_obj();
      id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_DEBUG, "%{public}s called without collect_block", buf, 0xCu);
      }
    }

    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    int v49 = __Block_byref_object_copy__7759;
    size_t v50 = __Block_byref_object_dispose__7760;
    id v51 = 0LL;
    uint64_t v44 = 0LL;
    int v45 = &v44;
    uint64_t v46 = 0x2020000000LL;
    char v47 = 0;
    uint64_t v40 = 0LL;
    os_log_type_t v41 = &v40;
    uint64_t v42 = 0x2020000000LL;
    char v43 = 0;
    uint64_t v11 = MEMORY[0x1895F87A8];
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke;
    aBlock[3] = &unk_189BB9B70;
    int v12 = v7;
    unint64_t v36 = v12;
    os_log_type_t v37 = &v40;
    uint64_t v38 = &v44;
    os_log_type_t v39 = buf;
    int v13 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v7 + 10);
    v13[2](v13);
    os_unfair_lock_unlock(v7 + 10);

    if (*((_BYTE *)v41 + 24))
    {
      if (!v10)
      {
LABEL_16:

        _Block_object_dispose(&v40, 8);
        _Block_object_dispose(&v44, 8);
        _Block_object_dispose(buf, 8);

        goto LABEL_17;
      }

      if (a4)
      {
        ((void (**)(void, os_unfair_lock_s *))v10)[2](v10, v12);
        goto LABEL_16;
      }

      block[0] = v11;
      block[1] = 3221225472LL;
      block[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_209;
      block[3] = &unk_189BC91E8;
      BOOL v16 = (id *)&v34;
      os_log_type_t v34 = v10;
      char v17 = (id *)&v33;
      unint64_t v33 = v12;
      dispatch_async(v8, block);
    }

    else
    {
      if (!*((_BYTE *)v45 + 24)) {
        goto LABEL_16;
      }
      uint64_t v14 = *(void *)(*(void *)&buf[8] + 40LL);
      if (!v14) {
        goto LABEL_16;
      }
      uint64_t v15 = *(void **)(v14 + 24);
      if (!v15) {
        goto LABEL_16;
      }
      v27[0] = v11;
      v27[1] = 3221225472LL;
      v27[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_2;
      void v27[3] = &unk_189BB6FA0;
      BOOL v28 = v12;
      v30[1] = buf;
      v30[0] = v10;
      char v31 = a4;
      uint64_t v29 = v8;
      nw_queue_context_async_if_needed(v15, v27);

      BOOL v16 = (id *)&v28;
      char v17 = (id *)v30;
    }

    goto LABEL_16;
  }

  __nwlog_obj();
  unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
  BOOL v19 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v44) = 16;
  LOBYTE(v40) = 0;
  if (__nwlog_fault(v19, &v44, &v40))
  {
    if (v44 == 17)
    {
      __nwlog_obj();
      int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v44;
      if (os_log_type_enabled(v20, (os_log_type_t)v44))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null queue", buf, 0xCu);
      }
    }

    else if ((_BYTE)v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v44;
      BOOL v25 = os_log_type_enabled(v20, (os_log_type_t)v44);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v24,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_37;
      }

      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl(&dword_181A5C000, v20, v24, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = v44;
      if (os_log_type_enabled(v20, (os_log_type_t)v44))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner";
        _os_log_impl( &dword_181A5C000,  v20,  v26,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DC969C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v40 - 192), 8);
  _Block_object_dispose((const void *)(v40 - 160), 8);

  _Unwind_Resume(a1);
}

void ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke( void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v2 = a1[4];
  if (*(_DWORD *)(v2 + 52) == 2)
  {
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
    return;
  }

  *(_BYTE *)(v2 + 424) |= 1u;
  *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
  uint64_t v3 = a1[4];
  if (*(void *)(v3 + 24)) {
    goto LABEL_23;
  }
  char v4 = *(_BYTE *)(v3 + 424);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v5 = (os_log_s *)(id)gLogObj;
  id v6 = v5;
  if ((v4 & 1) == 0)
  {
    os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "nw_data_transfer_report_collect_inner_block_invoke";
    os_log_type_t v7 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v7))
    {
LABEL_22:
      free(v7);
      goto LABEL_23;
    }

    __break(1u);
  }

  *(_DWORD *)int buf = 136446210;
  BOOL v19 = "nw_data_transfer_report_collect_inner_block_invoke";
  os_log_type_t v7 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault((const char *)v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "nw_data_transfer_report_collect_inner_block_invoke";
        os_log_type_t v10 = "%{public}s Report's (not in progress) associated connection unexpectedly nil";
LABEL_18:
        uint64_t v14 = v8;
        os_log_type_t v15 = v9;
LABEL_19:
        _os_log_impl(&dword_181A5C000, v14, v15, v10, buf, 0xCu);
        goto LABEL_20;
      }

      goto LABEL_20;
    }

    if (!v16)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "nw_data_transfer_report_collect_inner_block_invoke";
        os_log_type_t v10 = "%{public}s Report's (not in progress) associated connection unexpectedly nil, backtrace limit exceeded";
        goto LABEL_18;
      }

uint64_t ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_209( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_2( uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  uint64_t v45 = 0LL;
  uint64_t v46 = &v45;
  uint64_t v47 = 0x2020000000LL;
  char v48 = 1;
  uint64_t v2 = *(os_unfair_lock_s **)(a1 + 32);
  uint64_t v3 = MEMORY[0x1895F87A8];
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_3;
  aBlock[3] = &unk_189BC9210;
  char v43 = v2;
  uint64_t v44 = &v45;
  char v4 = (void (**)(void))_Block_copy(aBlock);
  v2 += 10;
  os_unfair_lock_lock(v2);
  v4[2](v4);
  os_unfair_lock_unlock(v2);

  if (*((_BYTE *)v46 + 24))
  {
    uint64_t v5 = mach_continuous_time();
    if (v5 <= 1) {
      uint64_t v6 = 1LL;
    }
    else {
      uint64_t v6 = v5;
    }
    if (gLogDatapath)
    {
      __nwlog_obj();
      __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v21 = *(void *)(a1 + 32);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner_block_invoke_2";
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = v21;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s report %p adding collecting snapshot",  buf,  0x16u);
      }
    }

    nw_data_transfer_report_add_snapshot_on_nw_queue(*(void **)(a1 + 32));
    os_log_type_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = v7[1];
    if (v8)
    {
      unint64_t v9 = nw_delta_nanos(v8, v6);
      uint64_t v10 = (v9 / 0xF4240);
      if (v9 > 0xF423FFFFFFFFFLL) {
        uint64_t v10 = 0xFFFFFFFFLL;
      }
      *(void *)(*(void *)(a1 + 32) + 16LL) = v10;
      os_log_type_t v7 = *(void **)(a1 + 32);
    }

    id v11 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    os_log_type_t v12 = v7;
    BOOL v13 = v12;
    if (v11)
    {
      if (v12)
      {
        *(void *)int buf = v3;
        *(void *)&sockaddr buf[8] = 3221225472LL;
        *(void *)&buf[16] = __nw_connection_remove_data_transfer_report_block_invoke;
        uint64_t v52 = &unk_189BC9238;
        id v14 = v11;
        id v53 = v14;
        id v54 = v13;
        nw_connection_async_if_needed(v14, buf);

LABEL_13:
        os_log_type_t v15 = *(os_unfair_lock_s **)(a1 + 32);
        v40[0] = v3;
        v40[1] = 3221225472LL;
        void v40[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_210;
        v40[3] = &unk_189BC93A0;
        os_log_type_t v41 = v15;
        char v16 = (void (**)(void))_Block_copy(v40);
        v15 += 10;
        os_unfair_lock_lock(v15);
        v16[2](v16);
        os_unfair_lock_unlock(v15);

        char v17 = v41;
LABEL_14:

        goto LABEL_16;
      }

      __nwlog_obj();
      os_log_type_t v26 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
      uint32_t v23 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v50 = OS_LOG_TYPE_ERROR;
      char v49 = 0;
      if (v50 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = v50;
        if (os_log_type_enabled(v24, v50))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null report", buf, 0xCu);
        }
      }

      else if (v49)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = v50;
        BOOL v34 = os_log_type_enabled(v24, v50);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v33,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v23) {
            goto LABEL_13;
          }
          goto LABEL_60;
        }

        if (v34)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_181A5C000, v24, v33, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = v50;
        if (os_log_type_enabled(v24, v50))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
      uint32_t v23 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v50 = OS_LOG_TYPE_ERROR;
      char v49 = 0;
      if (v50 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = v50;
        if (os_log_type_enabled(v24, v50))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v49)
      {
        uint64_t v29 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = v50;
        BOOL v31 = os_log_type_enabled(v24, v50);
        if (v29)
        {
          if (v31)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v29;
            _os_log_impl( &dword_181A5C000,  v24,  v30,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v29);
LABEL_59:
          if (!v23) {
            goto LABEL_13;
          }
LABEL_60:
          free(v23);
          goto LABEL_13;
        }

        if (v31)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl(&dword_181A5C000, v24, v30, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v35 = v50;
        if (os_log_type_enabled(v24, v50))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_remove_data_transfer_report";
          _os_log_impl( &dword_181A5C000,  v24,  v35,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_59;
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    char v17 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v28 = *(void *)(a1 + 32);
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_data_transfer_report_collect_inner_block_invoke_2";
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = v28;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v17,  OS_LOG_TYPE_DEBUG,  "%{public}s report %p already collected, delivering",  buf,  0x16u);
    }

    goto LABEL_14;
  }

void sub_181DCA29C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, char a30)
{
}

uint64_t ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_3( uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(_DWORD *)(v1 + 52) == 2 && (*(_BYTE *)(v1 + 424) & 1) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = 0;
  }
  return result;
}

void ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_210( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 24);
  *(void *)(v2 + 24) = 0LL;

  *(_DWORD *)(*(void *)(a1 + 32) + 52LL) = 2;
  *(_BYTE *)(*(void *)(a1 + 32) + 424LL) &= ~1u;
}

uint64_t ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_211( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

uint64_t nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count(void *a1, unsigned int a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
      __int16 v35 = 2082;
      os_log_type_t v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (a2 == -1)
  {
    uint64_t v7 = *((void *)v4 + 17);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 80);
        v11 += *(void *)(v13 + 440);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    char v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 280);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= a2)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DCA968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count(void *a1, unsigned int a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
      __int16 v35 = 2082;
      os_log_type_t v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (a2 == -1)
  {
    uint64_t v7 = *((void *)v4 + 18);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 88);
        v11 += *(void *)(v13 + 448);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    char v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 272);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= a2)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DCAF60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count( void *a1, unsigned int a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
      __int16 v35 = 2082;
      os_log_type_t v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (a2 == -1)
  {
    uint64_t v7 = *((void *)v4 + 19);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 96);
        v11 += *(void *)(v13 + 456);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    char v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 264);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= a2)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DCB558(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count(void *a1, unsigned int a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
        _os_log_impl(&dword_181A5C000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
      __int16 v35 = 2082;
      os_log_type_t v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v25,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_44;
  }

  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot retrieve data report values until collected",  buf,  0xCu);
    }

    goto LABEL_59;
  }

  if (a2 == -1)
  {
    uint64_t v7 = *((void *)v4 + 20);
    uint64_t v8 = *((unsigned int *)v4 + 11);
    if ((_DWORD)v8 == 2)
    {
      uint64_t v9 = 1LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = v8 - 1;
      uint64_t v13 = *((void *)v4 + 52);
      unint64_t v14 = (v8 - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v7 += *(void *)(v13 + 104);
        v11 += *(void *)(v13 + 464);
        v13 += 720LL;
        v14 -= 2LL;
      }

      while (v14);
      v7 += v11;
      if (v12 == ((v8 - 1) & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
      uint64_t v9 = v12 | 1;
    }

    uint64_t v15 = v8 - v9;
    char v16 = (void *)(*((void *)v4 + 52) + 360 * v9 - 256);
    do
    {
      v7 += *v16;
      v16 += 45;
      --v15;
    }

    while (v15);
    goto LABEL_14;
  }

  if (*((_DWORD *)v4 + 11) <= a2)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
    unint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s called with null (path_index < report->path_count)",  buf,  0xCu);
      }

void sub_181DCBB50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_copy_dictionary_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  char v4 = (void *)[a3 copyDictionary];
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), v4);

  return 1LL;
}

void sub_181DCBBA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_copy_dictionary_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  char v4 = (void *)[a3 copyDictionary];
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), v4);

  return 1LL;
}

void sub_181DCBBEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_establishment_report *nw_establishment_report_create_from_dictionary(void *a1)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v59 = "nw_establishment_report_create_from_dictionary";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v57 = OS_LOG_TYPE_ERROR;
    char v56 = 0;
    if (v57 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)int buf = 136446210;
        int v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null dictionary", buf, 0xCu);
      }
    }

    else if (v56)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = v57;
      BOOL v38 = os_log_type_enabled(v28, v57);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)int buf = 136446466;
          int v59 = "nw_establishment_report_create_from_dictionary";
          __int16 v60 = 2082;
          BOOL v61 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v37,  "%{public}s called with null dictionary, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v27) {
          goto LABEL_82;
        }
        goto LABEL_81;
      }

      if (v38)
      {
        *(_DWORD *)int buf = 136446210;
        int v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_181A5C000, v28, v37, "%{public}s called with null dictionary, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v45 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)int buf = 136446210;
        int v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v28,  v45,  "%{public}s called with null dictionary, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_79;
  }

  Class Class = object_getClass(v1);
  char v4 = (objc_class *)MEMORY[0x1895F9250];
  if (Class != (Class)MEMORY[0x1895F9250])
  {
    __nwlog_obj();
    os_log_type_t v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v59 = "nw_establishment_report_create_from_dictionary";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v57 = OS_LOG_TYPE_ERROR;
    char v56 = 0;
    if (v57 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)int buf = 136446210;
        int v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary))",  buf,  0xCu);
      }
    }

    else if (v56)
    {
      os_log_type_t v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = v57;
      BOOL v41 = os_log_type_enabled(v28, v57);
      if (v39)
      {
        if (v41)
        {
          *(_DWORD *)int buf = 136446466;
          int v59 = "nw_establishment_report_create_from_dictionary";
          __int16 v60 = 2082;
          BOOL v61 = v39;
          _os_log_impl( &dword_181A5C000,  v28,  v40,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v39);
LABEL_80:
        if (!v27)
        {
LABEL_82:
          uint64_t v5 = 0LL;
          goto LABEL_17;
        }

void sub_181DCC648( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_create_from_dictionary_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F9250])
  {
    uint64_t v5 = nw_endpoint_create_from_dictionary(v4);
    nw_array_append(*(void *)(*(void *)(a1 + 32) + 40LL), v5);
  }

  return 1LL;
}

void sub_181DCC724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_create_from_dictionary_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F9250])
  {
    uint64_t v5 = nw_endpoint_create_from_dictionary(v4);
    nw_array_append(*(void *)(*(void *)(a1 + 32) + 48LL), v5);
  }

  return 1LL;
}

void sub_181DCC7A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_create_from_dictionary_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) != (Class)MEMORY[0x1895F9250]) {
    goto LABEL_21;
  }
  string = xpc_dictionary_get_string(v4, "protocol");
  if (!strcmp(string, "tcp"))
  {
    xpc_object_t v6 = &g_tcp_definition;
LABEL_17:
    id v7 = (id)*v6;
    if (!v7) {
      goto LABEL_21;
    }
    goto LABEL_18;
  }

  if (strcmp(string, "tls"))
  {
    if (!strcmp(string, "quic"))
    {
      if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
      }
      xpc_object_t v6 = &nw_protocol_copy_quic_stream_definition::quic_definition;
    }

    else
    {
      if (strcmp(string, "quic-connection")) {
        goto LABEL_21;
      }
      if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
      }
      xpc_object_t v6 = &nw_protocol_copy_quic_connection_definition::quic_definition;
    }

    goto LABEL_17;
  }

  id v7 = (id)nw_protocol_boringssl_copy_definition();
  if (!v7) {
    goto LABEL_21;
  }
LABEL_18:
  char v8 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_establishment_report);
  xpc_object_t v9 = v8;
  if (v8)
  {
    objc_storeStrong((id *)&v8->protocol, v7);
    v9->handshake_milliseconds = xpc_dictionary_get_uint64(v4, "handshake_milliseconds");
    v9->handshake_rtt_milliseconds = xpc_dictionary_get_uint64(v4, "handshake_rtt_milliseconds");
    v9->client_accurate_ecn_state = xpc_dictionary_get_uint64(v4, "client_accurate_ecn_state");
    v9->server_accurate_ecn_state = xpc_dictionary_get_uint64(v4, "server_accurate_ecn_state");
    *((_BYTE *)v9 + 40) = *((_BYTE *)v9 + 40) & 0xFE | xpc_dictionary_get_BOOL(v4, "l4s_enabled");
    nw_array_append(*(void *)(*(void *)(a1 + 32) + 64LL), v9);
  }

LABEL_21:
  return 1LL;
}

void sub_181DCC9BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_create_from_dictionary_block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  Class Class = object_getClass(v4);
  xpc_object_t v6 = (objc_class *)MEMORY[0x1895F9250];
  if (Class == (Class)MEMORY[0x1895F9250])
  {
    id v7 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_resolution_report);
    v7->milliseconds = xpc_dictionary_get_uint64(v4, "milliseconds");
    if (!v4) {
      goto LABEL_6;
    }
    if (object_getClass(v4) == v6
      && (xpc_object_t value = xpc_dictionary_get_value(v4, "successful_endpoint")) != 0LL
      && (uint64_t v12 = value, object_getClass(value) == v6))
    {
      id v8 = v12;
      uint64_t v13 = nw_endpoint_create_from_dictionary(v8);
      successful_endpoint = v7->successful_endpoint;
      v7->successful_endpoint = v13;
    }

    else
    {
      id v8 = 0LL;
    }

    if (object_getClass(v4) == v6
      && (xpc_object_t v15 = xpc_dictionary_get_value(v4, "preferred_endpoint")) != 0LL
      && (xpc_object_t v16 = v15, object_getClass(v15) == v6))
    {
      id v9 = v16;
      BOOL v17 = nw_endpoint_create_from_dictionary(v9);
      preferred_endpoint = v7->preferred_endpoint;
      v7->preferred_endpoint = v17;
    }

    else
    {
LABEL_6:
      id v9 = 0LL;
    }

    v7->endpoint_size_t count = xpc_dictionary_get_uint64(v4, "endpoint_count");
    v7->uint64_t source = xpc_dictionary_get_uint64(v4, "source");
    nw_array_append(*(void *)(*(void *)(a1 + 32) + 72LL), v7);
  }

  return 1LL;
}

void sub_181DCCB50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

xpc_object_t nw_data_transfer_report_copy_dictionary(void *a1)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_data_transfer_report_copy_dictionary_block_invoke;
    aBlock[3] = &unk_189BC9210;
    os_log_type_t v64 = buf;
    uint64_t v3 = v1;
    os_log_type_t v63 = v3;
    id v4 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v1 + 10);
    v4[2](v4);
    os_unfair_lock_unlock(v1 + 10);

    if (*(_DWORD *)(*(void *)&buf[8] + 24LL) == 2)
    {
      uint64_t v5 = *(void *)&v3[4]._os_unfair_lock_opaque;
      if (v5) {
        xpc_dictionary_set_uint64(v2, "duration_milliseconds", v5);
      }
      if (v3[11]._os_unfair_lock_opaque)
      {
        xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
        id v7 = v6;
        uint64_t v8 = *(void *)&v3[14]._os_unfair_lock_opaque;
        if (v8) {
          xpc_dictionary_set_uint64(v6, "total_received_ip_packet_count", v8);
        }
        uint64_t v9 = *(void *)&v3[58]._os_unfair_lock_opaque;
        if (v9) {
          xpc_dictionary_set_uint64(v7, "incremental_received_ip_packet_count", v9);
        }
        uint64_t v10 = *(void *)&v3[16]._os_unfair_lock_opaque;
        if (v10) {
          xpc_dictionary_set_uint64(v7, "total_received_ip_ect1_packet_count", v10);
        }
        uint64_t v11 = *(void *)&v3[60]._os_unfair_lock_opaque;
        if (v11) {
          xpc_dictionary_set_uint64(v7, "incremental_received_ip_ect1_packet_count", v11);
        }
        uint64_t v12 = *(void *)&v3[18]._os_unfair_lock_opaque;
        if (v12) {
          xpc_dictionary_set_uint64(v7, "total_received_ip_ect0_packet_count", v12);
        }
        uint64_t v13 = *(void *)&v3[62]._os_unfair_lock_opaque;
        if (v13) {
          xpc_dictionary_set_uint64(v7, "incremental_received_ip_ect0_packet_count", v13);
        }
        uint64_t v14 = *(void *)&v3[20]._os_unfair_lock_opaque;
        if (v14) {
          xpc_dictionary_set_uint64(v7, "total_received_ip_ce_packet_count", v14);
        }
        uint64_t v15 = *(void *)&v3[64]._os_unfair_lock_opaque;
        if (v15) {
          xpc_dictionary_set_uint64(v7, "incremental_received_ip_ce_packet_count", v15);
        }
        uint64_t v16 = *(void *)&v3[22]._os_unfair_lock_opaque;
        if (v16) {
          xpc_dictionary_set_uint64(v7, "total_sent_ip_packet_count", v16);
        }
        uint64_t v17 = *(void *)&v3[66]._os_unfair_lock_opaque;
        if (v17) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_ip_packet_count", v17);
        }
        uint64_t v18 = *(void *)&v3[24]._os_unfair_lock_opaque;
        if (v18) {
          xpc_dictionary_set_uint64(v7, "total_received_transport_byte_count", v18);
        }
        uint64_t v19 = *(void *)&v3[68]._os_unfair_lock_opaque;
        if (v19) {
          xpc_dictionary_set_uint64(v7, "incremental_received_transport_byte_count", v19);
        }
        uint64_t v20 = *(void *)&v3[26]._os_unfair_lock_opaque;
        if (v20) {
          xpc_dictionary_set_uint64(v7, "total_received_transport_duplicate_byte_count", v20);
        }
        uint64_t v21 = *(void *)&v3[70]._os_unfair_lock_opaque;
        if (v21) {
          xpc_dictionary_set_uint64(v7, "incremental_received_transport_duplicate_byte_count", v21);
        }
        uint64_t v22 = *(void *)&v3[28]._os_unfair_lock_opaque;
        if (v22) {
          xpc_dictionary_set_uint64(v7, "total_received_transport_out_of_order_byte_count", v22);
        }
        uint64_t v23 = *(void *)&v3[72]._os_unfair_lock_opaque;
        if (v23) {
          xpc_dictionary_set_uint64(v7, "incremental_received_transport_out_of_order_byte_count", v23);
        }
        uint64_t v24 = *(void *)&v3[30]._os_unfair_lock_opaque;
        if (v24) {
          xpc_dictionary_set_uint64(v7, "total_sent_transport_byte_count", v24);
        }
        uint64_t v25 = *(void *)&v3[74]._os_unfair_lock_opaque;
        if (v25) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_transport_byte_count", v25);
        }
        uint64_t v26 = *(void *)&v3[32]._os_unfair_lock_opaque;
        if (v26) {
          xpc_dictionary_set_uint64(v7, "total_sent_transport_retransmitted_byte_count", v26);
        }
        uint64_t v27 = *(void *)&v3[76]._os_unfair_lock_opaque;
        if (v27) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_transport_retransmitted_byte_count", v27);
        }
        uint64_t v28 = *(void *)&v3[34]._os_unfair_lock_opaque;
        if (v28) {
          xpc_dictionary_set_uint64(v7, "total_sent_transport_ecn_capable_packet_count", v28);
        }
        uint64_t v29 = *(void *)&v3[78]._os_unfair_lock_opaque;
        if (v29) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_transport_ecn_capable_packet_count", v29);
        }
        uint64_t v30 = *(void *)&v3[36]._os_unfair_lock_opaque;
        if (v30) {
          xpc_dictionary_set_uint64(v7, "total_sent_transport_ecn_capable_acked_packet_count", v30);
        }
        uint64_t v31 = *(void *)&v3[80]._os_unfair_lock_opaque;
        if (v31) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_transport_ecn_capable_acked_packet_count", v31);
        }
        uint64_t v32 = *(void *)&v3[38]._os_unfair_lock_opaque;
        if (v32) {
          xpc_dictionary_set_uint64(v7, "total_sent_transport_ecn_capable_marked_packet_count", v32);
        }
        uint64_t v33 = *(void *)&v3[82]._os_unfair_lock_opaque;
        if (v33) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_transport_ecn_capable_marked_packet_count", v33);
        }
        uint64_t v34 = *(void *)&v3[40]._os_unfair_lock_opaque;
        if (v34) {
          xpc_dictionary_set_uint64(v7, "total_sent_transport_ecn_capable_lost_packet_count", v34);
        }
        uint64_t v35 = *(void *)&v3[84]._os_unfair_lock_opaque;
        if (v35) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_transport_ecn_capable_lost_packet_count", v35);
        }
        uint64_t v36 = *(void *)&v3[42]._os_unfair_lock_opaque;
        if (v36) {
          xpc_dictionary_set_uint64(v7, "total_transport_smoothed_rtt_milliseconds", v36);
        }
        uint64_t v37 = *(void *)&v3[86]._os_unfair_lock_opaque;
        if (v37) {
          xpc_dictionary_set_uint64(v7, "incremental_transport_smoothed_rtt_milliseconds", v37);
        }
        uint64_t v38 = *(void *)&v3[44]._os_unfair_lock_opaque;
        if (v38) {
          xpc_dictionary_set_uint64(v7, "total_transport_minimum_rtt_milliseconds", v38);
        }
        uint64_t v39 = *(void *)&v3[88]._os_unfair_lock_opaque;
        if (v39) {
          xpc_dictionary_set_uint64(v7, "incremental_transport_minimum_rtt_milliseconds", v39);
        }
        uint64_t v40 = *(void *)&v3[46]._os_unfair_lock_opaque;
        if (v40) {
          xpc_dictionary_set_uint64(v7, "total_transport_current_rtt_milliseconds", v40);
        }
        uint64_t v41 = *(void *)&v3[90]._os_unfair_lock_opaque;
        if (v41) {
          xpc_dictionary_set_uint64(v7, "incremental_transport_current_rtt_milliseconds", v41);
        }
        uint64_t v42 = *(void *)&v3[48]._os_unfair_lock_opaque;
        if (v42) {
          xpc_dictionary_set_uint64(v7, "total_transport_rtt_variance", v42);
        }
        uint64_t v43 = *(void *)&v3[92]._os_unfair_lock_opaque;
        if (v43) {
          xpc_dictionary_set_uint64(v7, "incremental_transport_rtt_variance", v43);
        }
        uint64_t v44 = *(void *)&v3[50]._os_unfair_lock_opaque;
        if (v44) {
          xpc_dictionary_set_uint64(v7, "total_transport_congestion_window", v44);
        }
        uint64_t v45 = *(void *)&v3[94]._os_unfair_lock_opaque;
        if (v45) {
          xpc_dictionary_set_uint64(v7, "incremental_transport_congestion_window", v45);
        }
        uint64_t v46 = *(void *)&v3[52]._os_unfair_lock_opaque;
        if (v46) {
          xpc_dictionary_set_uint64(v7, "total_transport_slow_start_threshold", v46);
        }
        uint64_t v47 = *(void *)&v3[96]._os_unfair_lock_opaque;
        if (v47) {
          xpc_dictionary_set_uint64(v7, "incremental_transport_slow_start_threshold", v47);
        }
        uint64_t v48 = *(void *)&v3[54]._os_unfair_lock_opaque;
        if (v48) {
          xpc_dictionary_set_uint64(v7, "total_received_application_byte_count", v48);
        }
        uint64_t v49 = *(void *)&v3[98]._os_unfair_lock_opaque;
        if (v49) {
          xpc_dictionary_set_uint64(v7, "incremental_received_application_byte_count", v49);
        }
        uint64_t v50 = *(void *)&v3[56]._os_unfair_lock_opaque;
        if (v50) {
          xpc_dictionary_set_uint64(v7, "total_sent_application_byte_count", v50);
        }
        uint64_t v51 = *(void *)&v3[100]._os_unfair_lock_opaque;
        if (v51) {
          xpc_dictionary_set_uint64(v7, "incremental_sent_application_byte_count", v51);
        }
        uint64_t v52 = nw_interface_copy_dictionary(*(void **)&v3[102]._os_unfair_lock_opaque);
        if (v52) {
          xpc_dictionary_set_value(v7, "interface", v52);
        }

        xpc_dictionary_set_value(v2, "primary_path", v7);
      }
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_98;
  }

  __nwlog_obj();
  id v54 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_data_transfer_report_copy_dictionary";
  uint64_t v55 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v65 = 0;
  if (__nwlog_fault(v55, &type, &v65))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v56, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_copy_dictionary";
        _os_log_impl(&dword_181A5C000, v56, v57, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v65)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = type;
      BOOL v60 = os_log_type_enabled(v56, type);
      if (backtrace_string)
      {
        if (v60)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_data_transfer_report_copy_dictionary";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v56,  v59,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_115;
      }

      if (v60)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_copy_dictionary";
        _os_log_impl(&dword_181A5C000, v56, v59, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v61 = type;
      if (os_log_type_enabled(v56, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_data_transfer_report_copy_dictionary";
        _os_log_impl( &dword_181A5C000,  v56,  v61,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DCD358( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_data_transfer_report_copy_dictionary_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 32) + 52LL);
  return result;
}

NWConcrete_nw_data_transfer_report *nw_data_transfer_report_create_from_dictionary(void *a1)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  xpc_object_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null dictionary", buf, 0xCu);
      }
    }

    else if (v39)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
          __int16 v43 = 2082;
          uint64_t v44 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v28,  "%{public}s called with null dictionary, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v18) {
          goto LABEL_66;
        }
        goto LABEL_65;
      }

      if (v29)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
        _os_log_impl(&dword_181A5C000, v19, v28, "%{public}s called with null dictionary, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v19,  v36,  "%{public}s called with null dictionary, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_63;
  }

  Class Class = object_getClass(v1);
  id v4 = (objc_class *)MEMORY[0x1895F9250];
  if (Class != (Class)MEMORY[0x1895F9250])
  {
    __nwlog_obj();
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary))",  buf,  0xCu);
      }
    }

    else if (v39)
    {
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v19, type);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
          __int16 v43 = 2082;
          uint64_t v44 = v30;
          _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
LABEL_64:
        if (!v18)
        {
LABEL_66:
          xpc_object_t v6 = 0LL;
          goto LABEL_8;
        }

void sub_181DCDED4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_interface_use_observer_create(const char *a1, void *a2, void *a3)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a2;
  xpc_object_t v6 = a3;
  id v7 = v6;
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v83 = "nw_interface_use_observer_create";
    uint64_t v41 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v81.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v41, &v81, &type))
    {
      if (LOBYTE(v81.receiver) == 17)
      {
        __nwlog_obj();
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t receiver = (os_log_type_t)v81.receiver;
        if (os_log_type_enabled(v42, (os_log_type_t)v81.receiver))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v83 = "nw_interface_use_observer_create";
          _os_log_impl(&dword_181A5C000, v42, receiver, "%{public}s called with null notification_name", buf, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v59 = (os_log_type_t)v81.receiver;
        BOOL v60 = os_log_type_enabled(v42, (os_log_type_t)v81.receiver);
        if (backtrace_string)
        {
          if (v60)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v83 = "nw_interface_use_observer_create";
            __int16 v84 = 2082;
            os_log_type_t v85 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v42,  v59,  "%{public}s called with null notification_name, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_99;
        }

        if (v60)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v83 = "nw_interface_use_observer_create";
          _os_log_impl( &dword_181A5C000,  v42,  v59,  "%{public}s called with null notification_name, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v70 = (os_log_type_t)v81.receiver;
        if (os_log_type_enabled(v42, (os_log_type_t)v81.receiver))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v83 = "nw_interface_use_observer_create";
          _os_log_impl( &dword_181A5C000,  v42,  v70,  "%{public}s called with null notification_name, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181DCEE9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

void __nw_interface_use_observer_create_block_invoke(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(id *)(a1 + 32);
  if (v3)
  {
    unsigned __int16 v4 = nw_interface_use_observer_get_in_use(a2);
    if (v4 >= 0x100u) {
      (*(void (**)(void, BOOL))(v3[4] + 16LL))(v3[4], v4 != 0);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v16 = "nw_interface_use_observer_update";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_interface_use_observer_update";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null observer", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v16 = "nw_interface_use_observer_update";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null observer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_interface_use_observer_update";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null observer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v16 = "nw_interface_use_observer_update";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null observer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DCF1A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_interface_use_observer_get_in_use(int a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t state64 = 0LL;
  uint32_t state = notify_get_state(a1, &state64);
  if (state)
  {
    uint32_t v2 = state;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    *(_DWORD *)int buf = 136446466;
    uint64_t v20 = "nw_interface_use_observer_get_in_use";
    __int16 v21 = 1024;
    uint32_t v22 = v2;
    unsigned __int16 v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v4, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (os_log_s *)(id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_20;
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_interface_use_observer_get_in_use";
        __int16 v21 = 1024;
        uint32_t v22 = v2;
        id v7 = "%{public}s notify_get_state [%u] failed";
LABEL_18:
        uint64_t v14 = v5;
        os_log_type_t v15 = v6;
        goto LABEL_19;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (os_log_s *)(id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_20;
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_interface_use_observer_get_in_use";
        __int16 v21 = 1024;
        uint32_t v22 = v2;
        id v7 = "%{public}s notify_get_state [%u] failed, backtrace limit exceeded";
        goto LABEL_18;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_20:

          if (!v4) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_interface_use_observer_get_in_use";
        __int16 v21 = 1024;
        uint32_t v22 = v2;
        id v7 = "%{public}s notify_get_state [%u] failed, no backtrace";
        uint64_t v14 = v5;
        os_log_type_t v15 = v11;
LABEL_19:
        _os_log_impl(&dword_181A5C000, v14, v15, v7, buf, 0x12u);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446722;
        uint64_t v20 = "nw_interface_use_observer_get_in_use";
        __int16 v21 = 1024;
        uint32_t v22 = v2;
        __int16 v23 = 2082;
        uint64_t v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v11,  "%{public}s notify_get_state [%u] failed, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(backtrace_string);
    }

    if (!v4)
    {
LABEL_14:
      BOOL v8 = 0;
      int v9 = 0;
      return v8 | (v9 << 8);
    }

uint64_t __nw_interface_use_observer_create_block_invoke_5(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 41)) {
    return (*(uint64_t (**)(void, void))(*(void *)(*(void *)(a1 + 32) + 32LL) + 16LL))( *(void *)(*(void *)(a1 + 32) + 32LL),  *(unsigned __int8 *)(a1 + 40));
  }
  std::__throw_bad_optional_access[abi:nn180100]();
  return std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t std::__throw_bad_optional_access[abi:nn180100]()
{
  return nw_interface_use_observer_cancel();
}

void nw_interface_use_observer_cancel(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint32_t v2 = v1;
  if (v1)
  {
    int v3 = v1[12];
    if (v3 == -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int16 v4 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_interface_use_observer_cancel";
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s Notify token not valid, this observer may have been cancelled",  buf,  0xCu);
      }
    }

    else
    {
      notify_cancel(v3);
      v2[12] = -1;
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_interface_use_observer_cancel";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_interface_use_observer_cancel";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null observer", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_interface_use_observer_cancel";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null observer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_interface_use_observer_cancel";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null observer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v16 = "nw_interface_use_observer_cancel";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null observer, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DCF820(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_interface_use_observer_post_notification(const char *a1, unsigned int a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v28 = "nw_interface_use_observer_post_notification";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v28 = "nw_interface_use_observer_post_notification";
        uint32_t v22 = "%{public}s called with null notification_name";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else
    {
      if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        BOOL v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)int buf = 136446466;
            int v28 = "nw_interface_use_observer_post_notification";
            __int16 v29 = 2082;
            uint64_t v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null notification_name, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (!v24) {
          goto LABEL_37;
        }
        *(_DWORD *)int buf = 136446210;
        int v28 = "nw_interface_use_observer_post_notification";
        uint32_t v22 = "%{public}s called with null notification_name, no backtrace";
        goto LABEL_36;
      }

      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v28 = "nw_interface_use_observer_post_notification";
        uint32_t v22 = "%{public}s called with null notification_name, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

uint64_t nw_connection_group_get_description(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint32_t v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    if (nw_parameters_get_sensitive_redacted(*((void **)v1 + 7)))
    {
      aBlock[0] = MEMORY[0x1895F87A8];
      aBlock[1] = 3221225472LL;
      aBlock[2] = __nw_connection_group_get_description_block_invoke;
      aBlock[3] = &unk_189BC93A0;
      int v3 = v2;
      uint64_t v20 = v3;
      uint32_t v4 = (void (**)(void))_Block_copy(aBlock);
      os_unfair_lock_lock(v2 + 43);
      v4[2](v4);
      os_unfair_lock_unlock(v2 + 43);

      uint64_t v5 = *(void *)&v3[38]._os_unfair_lock_opaque;
    }

    else
    {
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 3221225472LL;
      v17[2] = __nw_connection_group_get_description_block_invoke_2;
      v17[3] = &unk_189BC93A0;
      os_log_type_t v6 = v2;
      uint64_t v18 = v6;
      id v7 = (void (**)(void))_Block_copy(v17);
      os_unfair_lock_lock(v2 + 43);
      v7[2](v7);
      os_unfair_lock_unlock(v2 + 43);

      uint64_t v5 = *(void *)&v6[40]._os_unfair_lock_opaque;
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  int v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v24 = "nw_connection_group_get_description";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v22 = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v10, &v22, &v21))
  {
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint32_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v22;
      if (os_log_type_enabled(v11, v22))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v24 = "nw_connection_group_get_description";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint32_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v22;
      BOOL v15 = os_log_type_enabled(v11, v22);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v24 = "nw_connection_group_get_description";
          __int16 v25 = 2082;
          os_log_type_t v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v24 = "nw_connection_group_get_description";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint32_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = v22;
      if (os_log_type_enabled(v11, v22))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v24 = "nw_connection_group_get_description";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DD0FE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_get_description_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(void *)(v1 + 152))
  {
    int v3 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)(v1 + 56), 0);
    asprintf((char **)(*(void *)(a1 + 32) + 152LL), "[G%u %s]", *(_DWORD *)(*(void *)(a1 + 32) + 168LL), v3);
    if (v3) {
      free(v3);
    }
  }

void __nw_connection_group_get_description_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(void *)(v1 + 160))
  {
    int v3 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)(v1 + 56), 0);
    asprintf((char **)(*(void *)(a1 + 32) + 160LL), "[G%u %s]", *(_DWORD *)(*(void *)(a1 + 32) + 168LL), v3);
    if (v3) {
      free(v3);
    }
  }

const char *nw_connection_group_state_to_string(unsigned int a1)
{
  if (a1 > 4) {
    return "<unknown>";
  }
  else {
    return off_189BB8B98[a1];
  }
}

void sub_181DD2B08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_group_get_next_log_id(void)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  do
  {
    unsigned int v0 = __ldaxr((unsigned int *)&nw_connection_group_get_next_log_id(void)::s_last_top_level_id);
    uint64_t result = v0 + 1;
  }

  while (__stlxr(result, (unsigned int *)&nw_connection_group_get_next_log_id(void)::s_last_top_level_id));
  if (v0 == -2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v2 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446466;
      uint32_t v4 = "nw_connection_group_get_next_log_id";
      __int16 v5 = 1024;
      int v6 = -1;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s reached %u group logging ids, wrapping",  (uint8_t *)&v3,  0x12u);
    }

    return nw_connection_group_get_next_log_id();
  }

  return result;
}

void sub_181DD2D38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_add_connection_locked( NWConcrete_nw_connection_group *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  int v3 = a1;
  uint32_t v4 = a2;
  __int16 v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_add_connection_locked";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_add_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v67)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v41 = type;
      BOOL v42 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_add_connection_locked";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v41,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_117:
        if (!v18) {
          goto LABEL_131;
        }
LABEL_118:
        free(v18);
        goto LABEL_131;
      }

      if (v42)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_add_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v41, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_add_connection_locked";
        _os_log_impl( &dword_181A5C000,  v19,  v57,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_139:
    free(v30);
    goto LABEL_140;
  }

  __nwlog_obj();
  __int16 v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
  os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v67 = 0;
  if (__nwlog_fault(v26, &type, &v67))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
        _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v67)
    {
      uint64_t v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type;
      BOOL v50 = os_log_type_enabled(v27, type);
      if (v48)
      {
        if (v50)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v48;
          _os_log_impl( &dword_181A5C000,  v27,  v49,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v48);
        goto LABEL_122;
      }

      if (v50)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
        _os_log_impl(&dword_181A5C000, v27, v49, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
        _os_log_impl( &dword_181A5C000,  v27,  v60,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        goto LABEL_140;
      }

      if (!(_BYTE)v68)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v62 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v73 = "__nw_protocol_get_message_properties";
          _os_log_impl( &dword_181A5C000,  v24,  v62,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_139;
      }

      BOOL v50 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v51 = type[0];
      os_log_type_t v52 = os_log_type_enabled(v24, type[0]);
      if (!v50)
      {
        if (v52)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v73 = "__nw_protocol_get_message_properties";
          _os_log_impl(&dword_181A5C000, v24, v51, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }

        goto LABEL_139;
      }

      if (v52)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v73 = "__nw_protocol_get_message_properties";
        BOOL v74 = 2082;
        os_log_type_t v75 = v50;
        _os_log_impl( &dword_181A5C000,  v24,  v51,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    if (!v42)
    {
LABEL_47:
      _Block_object_dispose(&v81, 8);
      if ((v87 & 1) != 0)
      {
        if (v86) {
          os_release(v86);
        }
      }

                goto LABEL_140;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v39 = (id)gLogObj;
              *(_DWORD *)int buf = 136446466;
              uint64_t v83 = "nw_proxy_resolver_create_parsed_array";
              __int16 v84 = 2114;
              os_log_type_t v85 = v23;
              uint64_t v40 = (char *)_os_log_send_and_compose_impl();

              LOBYTE(valuePtr) = 16;
              objc_super v81 = 0;
              if (__nwlog_fault(v40, &valuePtr, &v81))
              {
                if (valuePtr == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v41 = (os_log_s *)(id)gLogObj;
                  BOOL v42 = valuePtr;
                  if (os_log_type_enabled(v41, (os_log_type_t)valuePtr))
                  {
                    *(_DWORD *)int buf = 136446466;
                    uint64_t v83 = "nw_proxy_resolver_create_parsed_array";
                    __int16 v84 = 2114;
                    os_log_type_t v85 = v23;
                    _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s _CFXPCCreateXPCObjectFromCFObject(%{public}@) failed",  buf,  0x16u);
                  }
                }

                else if (v81)
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  os_log_type_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  typea = valuePtr;
                  os_log_type_t v46 = os_log_type_enabled(v41, (os_log_type_t)valuePtr);
                  if (backtrace_string)
                  {
                    if (v46)
                    {
                      *(_DWORD *)int buf = 136446722;
                      uint64_t v83 = "nw_proxy_resolver_create_parsed_array";
                      __int16 v84 = 2114;
                      os_log_type_t v85 = v23;
                      __int16 v86 = 2082;
                      uint32_t v87 = backtrace_string;
                      _os_log_impl( &dword_181A5C000,  v41,  typea,  "%{public}s _CFXPCCreateXPCObjectFromCFObject(%{public}@) failed, dumping backtrace:%{public}s",  buf,  0x20u);
                    }

                    free(backtrace_string);
                    if (!v40) {
                      goto LABEL_69;
                    }
                    goto LABEL_147;
                  }

                  if (v46)
                  {
                    *(_DWORD *)int buf = 136446466;
                    uint64_t v83 = "nw_proxy_resolver_create_parsed_array";
                    __int16 v84 = 2114;
                    os_log_type_t v85 = v23;
                    _os_log_impl( &dword_181A5C000,  v41,  typea,  "%{public}s _CFXPCCreateXPCObjectFromCFObject(%{public}@) failed, no backtrace",  buf,  0x16u);
                  }
                }

                else
                {
                  __nwlog_obj();
                  os_log_type_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  uint64_t v48 = valuePtr;
                  if (os_log_type_enabled(v41, (os_log_type_t)valuePtr))
                  {
                    *(_DWORD *)int buf = 136446466;
                    uint64_t v83 = "nw_proxy_resolver_create_parsed_array";
                    __int16 v84 = 2114;
                    os_log_type_t v85 = v23;
                    _os_log_impl( &dword_181A5C000,  v41,  v48,  "%{public}s _CFXPCCreateXPCObjectFromCFObject(%{public}@) failed, backtrace limit exceeded",  buf,  0x16u);
                  }
                }
              }

              if (v40) {
LABEL_147:
              }
                free(v40);
LABEL_69:
              direct = 0LL;
              goto LABEL_70;
            }
          }

          os_log_type_t v37 = v5[2];
          if (v37 && *(_DWORD *)(v37 + 124) == 4) {
            goto LABEL_69;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v35 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            uint64_t v38 = " dry-run";
            if ((*((_BYTE *)v5 + 159) & 8) == 0) {
              uint64_t v38 = "";
            }
            *(_DWORD *)int buf = 136446978;
            uint64_t v83 = "nw_proxy_resolver_create_parsed_array";
            __int16 v84 = 2082;
            os_log_type_t v85 = (char *)v5 + 84;
            __int16 v86 = 2082;
            uint32_t v87 = (void *)v38;
            __int16 v88 = 2114;
            Domain = v20;
            _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s%{public}s proxy pac] Bad proxy hostname %{public}@",  buf,  0x2Au);
          }
        }

        else
        {
          os_log_type_t v34 = v5[2];
          if (v34 && *(_DWORD *)(v34 + 124) == 4) {
            goto LABEL_69;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v35 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            int v36 = " dry-run";
            if ((*((_BYTE *)v5 + 159) & 8) == 0) {
              int v36 = "";
            }
            *(_DWORD *)int buf = 136446978;
            uint64_t v83 = "nw_proxy_resolver_create_parsed_array";
            __int16 v84 = 2082;
            os_log_type_t v85 = (char *)v5 + 84;
            __int16 v86 = 2082;
            uint32_t v87 = (void *)v36;
            __int16 v88 = 2114;
            Domain = v20;
            _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s%{public}s proxy pac] Bad proxy type key %{public}@",  buf,  0x2Au);
          }
        }

        goto LABEL_69;
      }
    }

    else
    {
      char v79 = 0LL;
    }

        BYTE1(v10[1].super.isa) |= 0x40u;
        if ((v35 & 8) == 0)
        {
LABEL_80:
          if ((v35 & 0x2000) == 0) {
            goto LABEL_21;
          }
          goto LABEL_141;
        }

      uint64_t v35 = nw_path_evaluator_add_endpoint_to_necp_message(v50, 201, v35, v22, 7);
      if (v51)
      {
LABEL_74:
        os_log_type_t v52 = v51;

        *(_OWORD *)nw_endpoint_type_t v167 = *(_OWORD *)(v52 + 8);
        __int128 v168 = *(_OWORD *)(v52 + 24);
        uint64_t v169 = *((void *)v52 + 5);
        if (v35)
        {
          if (v22)
          {
            if (v35 >= v22)
            {
              __nwlog_obj();
              id v98 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)int buf = 136447234;
              int v171 = "nw_necp_append_tlv";
              uint64_t v172 = 2048;
              *(void *)int v173 = v35;
              *(_WORD *)&v173[8] = 2048;
              *(void *)&v173[10] = v22;
              *(_WORD *)&v173[18] = 1024;
              *(_DWORD *)nw_endpoint_type_t v174 = 222;
              *(_WORD *)&v174[4] = 1024;
              *(_DWORD *)&v174[6] = 42;
              id v54 = (const char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              int v165 = 0;
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                id v99 = type;
                if (os_log_type_enabled(v55, type))
                {
                  *(_DWORD *)int buf = 136447234;
                  int v171 = "nw_necp_append_tlv";
                  uint64_t v172 = 2048;
                  *(void *)int v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(void *)&v173[10] = v22;
                  *(_WORD *)&v173[18] = 1024;
                  *(_DWORD *)nw_endpoint_type_t v174 = 222;
                  *(_WORD *)&v174[4] = 1024;
                  *(_DWORD *)&v174[6] = 42;
                  _os_log_impl( &dword_181A5C000,  v55,  v99,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  buf,  0x2Cu);
                }

                goto LABEL_290;
              }

              if (!v165)
              {
                __nwlog_obj();
                os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                unsigned int v153 = type;
                if (os_log_type_enabled(v55, type))
                {
                  *(_DWORD *)int buf = 136447234;
                  int v171 = "nw_necp_append_tlv";
                  uint64_t v172 = 2048;
                  *(void *)int v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(void *)&v173[10] = v22;
                  *(_WORD *)&v173[18] = 1024;
                  *(_DWORD *)nw_endpoint_type_t v174 = 222;
                  *(_WORD *)&v174[4] = 1024;
                  *(_DWORD *)&v174[6] = 42;
                  _os_log_impl( &dword_181A5C000,  v55,  v153,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  buf,  0x2Cu);
                }

                goto LABEL_290;
              }

              os_log_type_t v129 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v130 = type;
              BOOL v131 = os_log_type_enabled(v60, type);
              if (!v129)
              {
                if (v131)
                {
                  *(_DWORD *)int buf = 136447234;
                  int v171 = "nw_necp_append_tlv";
                  uint64_t v172 = 2048;
                  *(void *)int v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(void *)&v173[10] = v22;
                  *(_WORD *)&v173[18] = 1024;
                  *(_DWORD *)nw_endpoint_type_t v174 = 222;
                  *(_WORD *)&v174[4] = 1024;
                  *(_DWORD *)&v174[6] = 42;
                  _os_log_impl( &dword_181A5C000,  v60,  v130,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  buf,  0x2Cu);
                }

                goto LABEL_98;
              }

              if (v131)
              {
                *(_DWORD *)int buf = 136447490;
                int v171 = "nw_necp_append_tlv";
                uint64_t v172 = 2048;
                *(void *)int v173 = v35;
                *(_WORD *)&v173[8] = 2048;
                *(void *)&v173[10] = v22;
                *(_WORD *)&v173[18] = 1024;
                *(_DWORD *)nw_endpoint_type_t v174 = 222;
                *(_WORD *)&v174[4] = 1024;
                *(_DWORD *)&v174[6] = 42;
                *(_WORD *)uint64_t v175 = 2082;
                *(void *)&v175[2] = v129;
                _os_log_impl( &dword_181A5C000,  v60,  v130,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
              }

              free(v129);
            }

            else
            {
              if (v22 - v35 > 0x2E)
              {
                *(_BYTE *)uint64_t v35 = -34;
                *(_DWORD *)(v35 + 1) = 42;
                os_log_type_t v57 = *(_OWORD *)v167;
                os_log_type_t v58 = v168;
                *(void *)(v35 + 37) = v169;
                *(_OWORD *)(v35 + 21) = v58;
                *(_OWORD *)(v35 + 5) = v57;
                *(_WORD *)(v35 + 45) = 0;
                goto LABEL_102;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v53 = (id)gLogObj;
              *(_DWORD *)int buf = 136447490;
              int v171 = "nw_necp_append_tlv";
              uint64_t v172 = 2048;
              *(void *)int v173 = v35;
              *(_WORD *)&v173[8] = 2048;
              *(void *)&v173[10] = 47LL;
              *(_WORD *)&v173[18] = 2048;
              *(void *)nw_endpoint_type_t v174 = v22;
              *(_WORD *)&v174[8] = 1024;
              *(_DWORD *)uint64_t v175 = 222;
              *(_WORD *)&v175[4] = 1024;
              *(_DWORD *)&v175[6] = 42;
              id v54 = (const char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              int v165 = 0;
              if (__nwlog_fault(v54, &type, &v165))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v55 = (os_log_s *)(id)gLogObj;
                  BOOL v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)int buf = 136447490;
                    int v171 = "nw_necp_append_tlv";
                    uint64_t v172 = 2048;
                    *(void *)int v173 = v35;
                    *(_WORD *)&v173[8] = 2048;
                    *(void *)&v173[10] = 47LL;
                    *(_WORD *)&v173[18] = 2048;
                    *(void *)nw_endpoint_type_t v174 = v22;
                    *(_WORD *)&v174[8] = 1024;
                    *(_DWORD *)uint64_t v175 = 222;
                    *(_WORD *)&v175[4] = 1024;
                    *(_DWORD *)&v175[6] = 42;
                    _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
                  }

      if (v154) {
        free(v154);
      }
      return 0LL;
    }

    if (!LOBYTE(v168.msg_name))
    {
      BOOL v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = buf[0];
      if (os_log_type_enabled(v56, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v177 = 136446210;
        *(void *)&v177[4] = "nw_socket_get_input_frames";
        os_log_type_t v58 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_138;
      }

      goto LABEL_139;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v56 = (os_log_s *)__nwlog_obj();
    os_log_type_t v57 = buf[0];
    int v156 = os_log_type_enabled(v56, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v156)
      {
        *(_DWORD *)uint64_t v177 = 136446210;
        *(void *)&v177[4] = "nw_socket_get_input_frames";
        os_log_type_t v58 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_138;
      }

      goto LABEL_139;
    }

    if (!v156) {
      goto LABEL_116;
    }
    *(_DWORD *)uint64_t v177 = 136446466;
    *(void *)&v177[4] = "nw_socket_get_input_frames";
    *(_WORD *)&v177[12] = 2082;
    *(void *)&v177[14] = backtrace_string;
    os_log_type_t v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_115:
    _os_log_impl(&dword_181A5C000, v56, v57, v62, v177, 0x16u);
    goto LABEL_116;
  }

  handle = a1->handle;
  p_uint64_t output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle) {
    id v9 = (char *)&a1[1].output_handler;
  }
  else {
    id v9 = 0LL;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)uint64_t v177 = 136446210;
    *(void *)&v177[4] = "nw_socket_get_input_frames";
    uint32_t v154 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    LOBYTE(v168.msg_name) = 0;
    if (buf[0] == 17)
    {
      BOOL v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = buf[0];
      if (os_log_type_enabled(v56, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v177 = 136446210;
        *(void *)&v177[4] = "nw_socket_get_input_frames";
        os_log_type_t v58 = "%{public}s called with null socket_handler";
        goto LABEL_138;
      }

      goto LABEL_139;
    }

    if (!LOBYTE(v168.msg_name))
    {
      BOOL v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = buf[0];
      if (os_log_type_enabled(v56, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v177 = 136446210;
        *(void *)&v177[4] = "nw_socket_get_input_frames";
        os_log_type_t v58 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_138;
      }

      goto LABEL_139;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v56 = (os_log_s *)__nwlog_obj();
    os_log_type_t v57 = buf[0];
    __int128 v157 = os_log_type_enabled(v56, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v157)
      {
        *(_DWORD *)uint64_t v177 = 136446210;
        *(void *)&v177[4] = "nw_socket_get_input_frames";
        os_log_type_t v58 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_138;
      }

      goto LABEL_139;
    }

    if (v157)
    {
      *(_DWORD *)uint64_t v177 = 136446466;
      *(void *)&v177[4] = "nw_socket_get_input_frames";
      *(_WORD *)&v177[12] = 2082;
      *(void *)&v177[14] = backtrace_string;
      os_log_type_t v62 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_115;
    }

      if (!v33) {
        return 0LL;
      }
      uint64_t v30 = (char *)v33;
      goto LABEL_26;
    }

    if (!(_BYTE)v62)
    {
      os_log_type_t v34 = (os_log_s *)__nwlog_obj();
      uint64_t v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        int v36 = "%{public}s called with null out_header_length, backtrace limit exceeded";
        goto LABEL_138;
      }

      goto LABEL_139;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v34 = (os_log_s *)__nwlog_obj();
    uint64_t v35 = type[0];
    os_log_type_t v46 = os_log_type_enabled(v34, type[0]);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
        int v36 = "%{public}s called with null out_header_length, no backtrace";
        goto LABEL_138;
      }

      goto LABEL_139;
    }

    if (v46)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      BOOL v66 = 2082;
      char v67 = (uint64_t)backtrace_string;
      int v39 = "%{public}s called with null out_header_length, dumping backtrace:%{public}s";
      goto LABEL_96;
    }

        goto LABEL_197;
      }

      if (v163 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        unsigned int v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v143 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_establishment_report";
          _os_log_impl( &dword_181A5C000,  v108,  v143,  "%{public}s metadata must be http_connection, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_139;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_browser_t v127 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v128 = type[0];
      os_log_type_t v129 = os_log_type_enabled(v127, type[0]);
      if (backtrace_string)
      {
        if (v129)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_establishment_report";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v127,  v128,  "%{public}s metadata must be http_connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
      }

      else
      {
        if (v129)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_establishment_report";
          _os_log_impl( &dword_181A5C000,  v127,  v128,  "%{public}s metadata must be http_connection, no backtrace",  buf,  0xCu);
        }
      }

      if (!v31) {
        goto LABEL_142;
      }
      goto LABEL_140;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v111 = "nw_protocol_http2_frame_output_finalizer";
    int v3 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v10_Block_object_dispose(va, 8) = 0;
    if (__nwlog_fault(v3, &type, &v108))
    {
      if (type == 17)
      {
        uint32_t v4 = (os_log_s *)__nwlog_obj();
        __int16 v5 = type;
        if (os_log_type_enabled(v4, (os_log_type_t)type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v111 = "nw_protocol_http2_frame_output_finalizer";
          int v6 = "%{public}s called with null http2";
          goto LABEL_41;
        }
      }

      else if ((_BYTE)v108)
      {
        uint64_t v14 = (char *)__nw_create_backtrace_string();
        uint32_t v4 = (os_log_s *)__nwlog_obj();
        __int16 v5 = type;
        __int16 v97 = os_log_type_enabled(v4, (os_log_type_t)type);
        if (v14)
        {
          if (v97)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v111 = "nw_protocol_http2_frame_output_finalizer";
            os_log_type_t v112 = 2082;
            *(void *)DNSServiceErrorType v113 = v14;
            os_log_type_t v16 = "%{public}s called with null http2, dumping backtrace:%{public}s";
            goto LABEL_16;
          }

          goto LABEL_17;
        }

        if (v97)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v111 = "nw_protocol_http2_frame_output_finalizer";
          int v6 = "%{public}s called with null http2, no backtrace";
          goto LABEL_41;
        }
      }

      else
      {
        uint32_t v4 = (os_log_s *)__nwlog_obj();
        __int16 v5 = type;
        if (os_log_type_enabled(v4, (os_log_type_t)type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v111 = "nw_protocol_http2_frame_output_finalizer";
          int v6 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
    }

void sub_181DD3DBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_prune_connections_locked(NWConcrete_nw_connection_group *a1)
{
  *(void *)((char *)&v59[2] + 2) = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint32_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 13);
    if (v3) {
      unint64_t v4 = (uint64_t)(*(void *)(v3 + 24) - *(void *)(v3 + 16)) >> 3;
    }
    else {
      unint64_t v4 = 0LL;
    }
    while (1)
    {
      __int16 v5 = nw_array_remove_object_at_index(*((void *)v2 + 13), (char *)--v4);
      if (!nw_parameters_get_logging_disabled(*((void *)v2 + 7)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        int v6 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          int v7 = *((_DWORD *)v2 + 42);
          *(_DWORD *)int buf = 136446722;
          os_log_type_t v57 = "nw_connection_group_prune_connections_locked";
          __int16 v58 = 1024;
          LODWORD(v59[0]) = v7;
          WORD2(v59[0]) = 2112;
          *(void *)((char *)v59 + 6) = v5;
          _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_INFO, "%{public}s [G%u] pruning connection %@", buf, 0x1Cu);
        }
      }

      nw_connection_reset_client(v5);
      handler[0] = MEMORY[0x1895F87A8];
      handler[1] = 3221225472LL;
      handler[2] = ___ZL44nw_connection_group_prune_connections_lockedP30NWConcrete_nw_connection_group_block_invoke;
      handler[3] = &unk_189BC9490;
      os_log_type_t v8 = v2;
      os_log_type_t v52 = v8;
      id v9 = v5;
      id v53 = v9;
      nw_connection_set_state_changed_handler((nw_connection_t)v9, handler);
      os_log_type_t v10 = v8;
      id v11 = *((id *)v2 + 7);
      os_log_type_t v12 = v11;
      if (!v11)
      {
        __nwlog_obj();
        __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v57 = "nw_connection_group_copy_workloop";
        uint64_t v18 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (__nwlog_fault(v18, &type, &v54))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v20 = type;
            if (os_log_type_enabled(v19, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v57 = "nw_connection_group_copy_workloop";
              _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null parameters", buf, 0xCu);
            }

            goto LABEL_67;
          }

          if (v54)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v31 = type;
            BOOL v32 = os_log_type_enabled(v19, type);
            if (backtrace_string)
            {
              if (v32)
              {
                *(_DWORD *)int buf = 136446466;
                os_log_type_t v57 = "nw_connection_group_copy_workloop";
                __int16 v58 = 2082;
                v59[0] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
              goto LABEL_68;
            }

            if (v32)
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v57 = "nw_connection_group_copy_workloop";
              _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v38 = type;
            if (os_log_type_enabled(v19, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v57 = "nw_connection_group_copy_workloop";
              _os_log_impl( &dword_181A5C000,  v19,  v38,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
            }
          }

void sub_181DD496C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, void *a23)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_connection_group_add_connection_lockedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke( uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v141 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  int v6 = *(void **)(a1 + 32);
  int v7 = *(void **)(a1 + 40);
  id v8 = v6;
  id v9 = v7;
  id v91 = v5;
  if (!v8)
  {
    __nwlog_obj();
    int v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_handle_connection_state_changed";
    os_log_type_t v64 = (char *)_os_log_send_and_compose_impl();

    v135[0] = 16;
    v131[0] = 0;
    if (v135[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v66 = v135[0];
      if (os_log_type_enabled(v65, (os_log_type_t)v135[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_connection_state_changed";
        _os_log_impl(&dword_181A5C000, v65, v66, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v131[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v74 = v135[0];
      BOOL v75 = os_log_type_enabled(v65, (os_log_type_t)v135[0]);
      if (backtrace_string)
      {
        if (v75)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_handle_connection_state_changed";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v65,  v74,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_170:
        if (!v64) {
          goto LABEL_21;
        }
LABEL_171:
        free(v64);
        goto LABEL_21;
      }

      if (v75)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_connection_state_changed";
        _os_log_impl(&dword_181A5C000, v65, v74, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v81 = v135[0];
      if (os_log_type_enabled(v65, (os_log_type_t)v135[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_connection_state_changed";
        _os_log_impl( &dword_181A5C000,  v65,  v81,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DD6164( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, id a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{
  _Block_object_dispose(&a16, 8);
  _Block_object_dispose(&a20, 8);

  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a30, 8);

  _Block_object_dispose(&a43, 8);
  _Unwind_Resume(a1);
}

void *___ZL51nw_connection_group_handle_connection_state_changedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection21nw_connection_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke( void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = *(void *)(result[4] + 104LL);
  if (v2) {
    BOOL v3 = v1 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    goto LABEL_10;
  }
  id v5 = *(void **)(v2 + 16);
  unint64_t v4 = *(void **)(v2 + 24);
  if (v5 != v4)
  {
    while (*v5 != v1)
    {
      if (++v5 == v4)
      {
        id v5 = v4;
        break;
      }
    }
  }

  if (v5 == v4) {
LABEL_10:
  }
    *(_BYTE *)(*(void *)(result[6] + 8LL) + 24LL) = 1;
  return result;
}

void ___ZL51nw_connection_group_handle_connection_state_changedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection21nw_connection_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_132( uint64_t a1)
{
}

void nw_synchronize<void({block_pointer} {__strong})(void)>(os_unfair_lock_s *a1, uint64_t a2)
{
}

void ___ZL51nw_connection_group_handle_connection_state_changedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection21nw_connection_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_133( uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 190) & 0x10) != 0)
  {
    if ((*(_BYTE *)(v2 + 190) & 0x40) == 0)
    {
      if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        BOOL v3 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
          int v5 = 136446466;
          int v6 = "nw_connection_group_handle_connection_state_changed_block_invoke";
          __int16 v7 = 1024;
          int v8 = v4;
          _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s [G%u] listener ready and first connection ready",  (uint8_t *)&v5,  0x12u);
        }
      }

      nw_connection_group_set_state_locked(*(void **)(a1 + 32), 2, 0LL);
    }
  }

  else
  {
    nw_connection_group_create_listener_from_connection_locked( (NWConcrete_nw_connection_group *)v2,  *(NWConcrete_nw_connection **)(a1 + 40));
  }

  *(_BYTE *)(*(void *)(a1 + 32) + 190LL) |= 0x40u;
}

void *__Block_byref_object_copy__134(uint64_t a1, uint64_t a2)
{
  uint64_t result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__135(uint64_t a1)
{
}

void ___ZL51nw_connection_group_handle_connection_state_changedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection21nw_connection_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_136( void *a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1[4] + 136LL));
  uint64_t v3 = *(void *)(a1[5] + 8LL);
  int v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  int v5 = _Block_copy(*(const void **)(a1[4] + 144LL));
  uint64_t v6 = *(void *)(a1[6] + 8LL);
  __int16 v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
}

void ___ZL38nw_connection_group_read_on_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke( uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  uint64_t v188 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a2;
  nw_content_context_t v10 = a3;
  id v11 = a5;
  data = v9;
  if (nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) || !gLogDatapath)
  {
    if (v11) {
      goto LABEL_4;
    }
LABEL_67:
    if (v10)
    {
      int v48 = 1;
      if (!v9) {
        goto LABEL_81;
      }
    }

    else
    {
      nw_content_context_t v10 = nw_content_context_create("connection_group incoming message");
      int v48 = 1;
      if (!v9) {
        goto LABEL_81;
      }
    }

    if ((a4 & 1) != 0) {
      goto LABEL_81;
    }
    size_t size = dispatch_data_get_size(v9);
    uint64_t v50 = *(void *)(a1 + 32);
    char v51 = *(_BYTE *)(v50 + 190);
    BOOL logging_disabled = nw_parameters_get_logging_disabled(*(void *)(v50 + 56));
    if ((v51 & 2) == 0)
    {
      if (!logging_disabled)
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        int v53 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          int v54 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
          size_t v55 = dispatch_data_get_size(data);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v54;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v55;
          _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_DEFAULT,  "%{public}s [G%u] oversized message is %zu bytes and not yet complete, delivering partial message",  buf,  0x1Cu);
        }
      }

      int v48 = 0;
LABEL_81:
      BOOL v58 = v10 == (nw_content_context_t)&__block_literal_global_3_41839
         || v10 == (nw_content_context_t)&__block_literal_global_41831
         || v10 == (nw_content_context_t)&__block_literal_global_4
         || v10 == (nw_content_context_t)&__block_literal_global_5_41854;
      char v59 = v58;
      if (v58 && !nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        unsigned int v90 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
        {
          int v91 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v91;
          _os_log_impl(&dword_181A5C000, v90, OS_LOG_TYPE_DEBUG, "%{public}s [G%u] context is static", buf, 0x12u);
        }
      }

      *(void *)os_log_type_t type = 0LL;
      int v171 = type;
      uint64_t v172 = 0x3032000000LL;
      int v173 = __Block_byref_object_copy__134;
      nw_endpoint_type_t v174 = __Block_byref_object_dispose__135;
      id v175 = 0LL;
      uint64_t v164 = 0LL;
      int v165 = &v164;
      uint64_t v166 = 0x3032000000LL;
      nw_endpoint_type_t v167 = __Block_byref_object_copy__8579;
      __int128 v168 = __Block_byref_object_dispose__8580;
      id v169 = 0LL;
      int v60 = *(os_unfair_lock_s **)(a1 + 32);
      aBlock[0] = MEMORY[0x1895F87A8];
      aBlock[1] = 3221225472LL;
      aBlock[2] = ___ZL38nw_connection_group_read_on_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_142;
      aBlock[3] = &unk_189BC16A8;
      id v162 = type;
      uint32_t v161 = v60;
      __int128 v163 = &v164;
      os_log_type_t v61 = (void (**)(void))_Block_copy(aBlock);
      os_unfair_lock_lock(v60 + 43);
      v61[2](v61);
      os_unfair_lock_unlock(v60 + 43);

      if (!*((void *)v171 + 5) || !v165[5])
      {
        if (nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
        {
          int v48 = 0;
          if (v10) {
            goto LABEL_108;
          }
          goto LABEL_150;
        }

        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        os_log_type_t v73 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v74 = *(void *)(a1 + 40);
          int v75 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v75;
          *(_WORD *)&buf[18] = 2112;
          *(void *)&buf[20] = v74;
          _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] no receive handler or client queue, stopping reads on connection %@",  buf,  0x1Cu);
        }

        int v48 = 0;
LABEL_107:

        if (v10)
        {
LABEL_108:
          unsigned __int16 v76 = v10;
          if (v10 == (nw_content_context_t)&__block_literal_global_41831
            || v10 == (nw_content_context_t)&__block_literal_global_5_41854)
          {

            goto LABEL_157;
          }

          int v77 = 1;
          if (v10 != (nw_content_context_t)&__block_literal_global_3_41839
            && v10 != (nw_content_context_t)&__block_literal_global_4)
          {
            int v77 = *((_BYTE *)v76 + 118) & 1;
          }

          if ((v77 & a4 & 1) == 0)
          {
LABEL_157:
            if (v48)
            {
              nw_connection_group_touch_connection( *(NWConcrete_nw_connection_group **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40));
              uint64_t v96 = *(void **)(a1 + 40);
              id v97 = *(id *)(a1 + 32);
              id v98 = v96;
              uint64_t v99 = v98;
              if (v97)
              {
                if (v98)
                {
                  if (!nw_parameters_get_logging_disabled(*((void *)v97 + 7)) && gLogDatapath)
                  {
                    if (__nwlog_connection_group_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
                    }
                    id v118 = (os_log_s *)(id)gconnection_groupLogObj;
                    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG))
                    {
                      int v119 = *((_DWORD *)v97 + 42);
                      *(_DWORD *)int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v119;
                      *(_WORD *)&buf[18] = 2112;
                      *(void *)&buf[20] = v99;
                      _os_log_impl( &dword_181A5C000,  v118,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] reading on connection %@",  buf,  0x1Cu);
                    }
                  }

                  unsigned int v100 = *((_DWORD *)v97 + 44);
                  if (!v100)
                  {
                    unsigned int v100 = 1;
                    if (!nw_parameters_get_logging_disabled(*((void *)v97 + 7)))
                    {
                      if (gLogDatapath)
                      {
                        if (__nwlog_connection_group_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
                        }
                        uint32_t v136 = (os_log_s *)(id)gconnection_groupLogObj;
                        if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
                        {
                          int v137 = *((_DWORD *)v97 + 42);
                          *(_DWORD *)int buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                          *(_WORD *)&_BYTE buf[12] = 1024;
                          *(_DWORD *)&buf[14] = v137;
                          _os_log_impl( &dword_181A5C000,  v136,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] overriding max size for reads to 1 since message size is 0",  buf,  0x12u);
                        }

                        unsigned int v100 = 1;
                      }
                    }
                  }

                  if (*((_DWORD *)v97 + 44) >= 0xFFFFFFFE) {
                    unsigned int v101 = -2;
                  }
                  else {
                    unsigned int v101 = *((_DWORD *)v97 + 44);
                  }
                  if (!nw_parameters_get_logging_disabled(*((void *)v97 + 7)) && gLogDatapath)
                  {
                    if (__nwlog_connection_group_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
                    }
                    int v120 = (os_log_s *)(id)gconnection_groupLogObj;
                    if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
                    {
                      int v121 = *((_DWORD *)v97 + 42);
                      *(_DWORD *)int buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v121;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = v101;
                      *(_WORD *)&_BYTE buf[24] = 1024;
                      *(_DWORD *)&buf[26] = v100;
                      _os_log_impl( &dword_181A5C000,  v120,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] reading with min: %u, max: %u",  buf,  0x1Eu);
                    }
                  }

                  *(void *)int buf = MEMORY[0x1895F87A8];
                  *(void *)&sockaddr buf[8] = 3221225472LL;
                  *(void *)&buf[16] = ___ZL38nw_connection_group_read_on_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke;
                  *(void *)&_BYTE buf[24] = &unk_189BC5F30;
                  *(void *)&_BYTE buf[32] = v97;
                  id v179 = v99;
                  nw_connection_receive_internal(v179, 0LL, v101, v100, buf);

                  goto LABEL_171;
                }

                __nwlog_obj();
                uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                DNSServiceErrorType v113 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v177 = OS_LOG_TYPE_ERROR;
                char v176 = 0;
                if (__nwlog_fault(v113, &v177, &v176))
                {
                  if (v177 == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    id v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v117 = v177;
                    if (os_log_type_enabled(v114, v177))
                    {
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                      _os_log_impl(&dword_181A5C000, v114, v117, "%{public}s called with null connection", buf, 0xCu);
                    }
                  }

                  else if (v176)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    id v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v134 = v177;
                    BOOL v135 = os_log_type_enabled(v114, v177);
                    if (backtrace_string)
                    {
                      if (v135)
                      {
                        *(_DWORD *)int buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = backtrace_string;
                        _os_log_impl( &dword_181A5C000,  v114,  v134,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
                      }

                      free(backtrace_string);
                      if (!v113) {
                        goto LABEL_171;
                      }
                      goto LABEL_299;
                    }

                    if (v135)
                    {
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                      _os_log_impl( &dword_181A5C000,  v114,  v134,  "%{public}s called with null connection, no backtrace",  buf,  0xCu);
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    id v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v147 = v177;
                    if (os_log_type_enabled(v114, v177))
                    {
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                      _os_log_impl( &dword_181A5C000,  v114,  v147,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
                    }
                  }

                  goto LABEL_297;
                }

LABEL_298:
                if (!v113)
                {
LABEL_171:

LABEL_174:
                  _Block_object_dispose(&v164, 8);

                  _Block_object_dispose(type, 8);
                  goto LABEL_175;
                }
              }
            }

      free(backtrace_string);
      goto LABEL_314;
    }

    goto LABEL_48;
  }

  int v27 = *(void *)(a1 + 112);
  if (!v27 && a6)
  {
    os_log_type_t v112 = a9;
    binary_message_length_inner = nw_http_get_binary_message_length_inner(v10, 0, a5);
    if (binary_message_length_inner)
    {
      int v29 = binary_message_length_inner;
      if (gLogDatapath)
      {
        int v89 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446466;
          int v126 = "nw_http_create_oblivious_request";
          os_log_type_t v127 = 2048;
          id v128 = v29;
          _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_DEBUG,  "%{public}s Creating binary request with length %zu",  buf,  0x16u);
        }
      }

      int v21 = arc4random_uniform(0x10u);
      if (!(v29 + v21))
      {
        unsigned int v90 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v90, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int buf = 136446210;
        int v126 = "strict_calloc";
        id v114 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort((uint64_t)v114);
        if (result) {
          goto LABEL_318;
        }
        free(v114);
      }

      DNSServiceErrorType v113 = a3;
      id v30 = (unsigned __int8 *)calloc(1uLL, v29 + v21);
      if (v30)
      {
        uint64_t v31 = v30;
        int v32 = nw_http_fillout_binary_message_inner(v10, 0, v16, v15, v30, v29);
        os_log_type_t v22 = v31;
        if (v32)
        {
          id v11 = "message/bhttp";
          int v15 = v29;
          id v16 = v31;
LABEL_25:
          uint64_t v20 = v112;
LABEL_47:
          int v13 = a7;
          int v12 = a8;
          a3 = v113;
          goto LABEL_48;
        }

        free(v31);
        goto LABEL_40;
      }

      int v91 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v91, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int buf = 136446722;
      int v126 = "strict_calloc";
      os_log_type_t v127 = 2048;
      id v128 = 1LL;
      os_log_type_t v129 = 2048;
      uint64_t v130 = v29 + v21;
      char v92 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort((uint64_t)v92);
      if (result) {
        goto LABEL_318;
      }
      free(v92);
      if (!nw_http_fillout_binary_message_inner(v10, 0, v16, v15, 0LL, v29))
      {
LABEL_40:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v41 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446210;
          int v126 = "nw_http_create_oblivious_request";
          BOOL v42 = "%{public}s Failed to fill out binary message";
          goto LABEL_136;
        }

        return 0LL;
      }

      id v16 = 0LL;
      os_log_type_t v22 = 0LL;
      int v15 = v29;
LABEL_276:
      id v11 = "message/bhttp";
      goto LABEL_25;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v126 = "nw_http_create_oblivious_request";
    id v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      __int16 v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      __int16 v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v24 = (os_log_s *)__nwlog_obj();
    __int16 v25 = type[0];
    id v108 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v108) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length, no backtrace";
      goto LABEL_313;
    }

    if (!v108) {
      goto LABEL_298;
    }
    goto LABEL_296;
  }

  if (v27 || (a6 & 1) != 0)
  {
    indeterminate_binary_message_chunk_size_t length = nw_http_get_indeterminate_binary_message_chunk_length(a5, a6, 0LL);
    if (indeterminate_binary_message_chunk_length)
    {
      os_log_type_t v40 = indeterminate_binary_message_chunk_length;
      if (gLogDatapath)
      {
        uint64_t v103 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446466;
          int v126 = "nw_http_create_oblivious_request";
          os_log_type_t v127 = 2048;
          id v128 = v40;
          _os_log_impl( &dword_181A5C000,  v103,  OS_LOG_TYPE_DEBUG,  "%{public}s Creating partial binary request with length %zu",  buf,  0x16u);
        }
      }

      if (a6) {
        int v21 = arc4random_uniform(0x10u);
      }
      else {
        int v21 = 0LL;
      }
      DNSServiceErrorType v113 = a3;
      if (!(v21 + v40))
      {
        int v104 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int buf = 136446210;
        int v126 = "strict_calloc";
        uint64_t v105 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort((uint64_t)v105);
        if (result) {
          goto LABEL_318;
        }
        free(v105);
        uint64_t v20 = a9;
      }

      __int16 v43 = (char *)calloc(1uLL, v21 + v40);
      if (v43)
      {
        os_log_type_t v44 = v43;
        if (nw_http_fillout_indeterminate_binary_message_body_chunk(v16, v15, a6, 0LL, v43, v40))
        {
          id v11 = "message/bhttp";
          int v15 = v40;
          id v16 = (const unsigned __int8 *)v44;
          os_log_type_t v22 = (unsigned __int8 *)v44;
          goto LABEL_47;
        }

        free(v44);
      }

      else
      {
        os_log_type_t v112 = v20;
        uint64_t v106 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int buf = 136446722;
        int v126 = "strict_calloc";
        os_log_type_t v127 = 2048;
        id v128 = 1LL;
        os_log_type_t v129 = 2048;
        uint64_t v130 = v21 + v40;
        os_log_type_t v107 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort((uint64_t)v107);
        if (result) {
          goto LABEL_318;
        }
        free(v107);
        if (nw_http_fillout_indeterminate_binary_message_body_chunk(v16, v15, a6, 0LL, 0LL, v40))
        {
          id v16 = 0LL;
          int v15 = v40;
          os_log_type_t v22 = 0LL;
          goto LABEL_276;
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v41 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        int v126 = "nw_http_create_oblivious_request";
        BOOL v42 = "%{public}s Failed to fill out binary message chunk";
        goto LABEL_136;
      }

      return 0LL;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v126 = "nw_http_create_oblivious_request";
    id v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      __int16 v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      __int16 v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v24 = (os_log_s *)__nwlog_obj();
    __int16 v25 = type[0];
    os_log_type_t v110 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v110) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length, no backtrace";
LABEL_313:
      _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
LABEL_314:
      if (v23) {
        free(v23);
      }
      return 0LL;
    }

    if (!v110) {
      goto LABEL_298;
    }
LABEL_296:
    *(_DWORD *)int buf = 136446466;
    int v126 = "nw_http_create_oblivious_request";
    os_log_type_t v127 = 2082;
    id v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null encoded_body_length, dumping backtrace:%{public}s";
    goto LABEL_297;
  }

  __int16 v33 = nw_http_get_binary_message_length_inner(v10, 1, 0LL);
  os_log_type_t v34 = nw_http_get_indeterminate_binary_message_chunk_length(v15, 0, 0LL);
  BOOL v35 = v34 + v33;
  if (!(v34 + v33))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v126 = "nw_http_create_oblivious_request";
    id v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      __int16 v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      __int16 v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v24 = (os_log_s *)__nwlog_obj();
    __int16 v25 = type[0];
    os_log_type_t v109 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v109) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v26 = "%{public}s called with null encoded_body_length, no backtrace";
      goto LABEL_313;
    }

    if (!v109) {
      goto LABEL_298;
    }
    goto LABEL_296;
  }

  int v36 = v34;
  os_log_type_t v111 = v34 + v33;
  if (gLogDatapath)
  {
    id v98 = (os_log_s *)__nwlog_obj();
    uint64_t v99 = os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG);
    BOOL v35 = v111;
    if (v99)
    {
      *(_DWORD *)int buf = 136446466;
      int v126 = "nw_http_create_oblivious_request";
      os_log_type_t v127 = 2048;
      id v128 = v111;
      _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_DEBUG,  "%{public}s Creating partial binary request with length %zu",  buf,  0x16u);
      BOOL v35 = v111;
    }
  }

  os_log_type_t v37 = (unsigned __int8 *)calloc(1uLL, v35);
  if (!v37)
  {
    os_log_type_t v115 = a3;
    unsigned int v100 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v100, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    int v126 = "strict_calloc";
    os_log_type_t v127 = 2048;
    id v128 = 1LL;
    os_log_type_t v129 = 2048;
    uint64_t v130 = v111;
    unsigned int v101 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v101);
    if (result) {
      goto LABEL_318;
    }
    free(v101);
    int v102 = nw_http_fillout_binary_message_inner(v10, 1, 0LL, 0LL, 0LL, v33);
    os_log_type_t v22 = 0LL;
    a3 = v115;
    if (v102) {
      goto LABEL_32;
    }
LABEL_75:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v41 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      int v126 = "nw_http_create_oblivious_request";
      BOOL v42 = "%{public}s Failed to fill out binary message header";
      goto LABEL_136;
    }

    return 0LL;
  }

  os_log_type_t v38 = nw_http_fillout_binary_message_inner(v10, 1, 0LL, 0LL, v37, v33);
  os_log_type_t v22 = v37;
  if (!v38)
  {
    free(v37);
    goto LABEL_75;
  }

                          if (v204) {
                            free(v204);
                          }
                          goto LABEL_300;
                        }
                      }

                      else if (v162)
                      {
                        goto LABEL_225;
                      }

                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      logc = (id)gconnectionLogObj;
                      id v175 = nw_endpoint_handler_get_id_string(v48);
                      char v176 = nw_endpoint_handler_dry_run_string(v48);
                      os_log_type_t v177 = nw_endpoint_handler_copy_endpoint(v48);
                      os_log_type_t v178 = nw_endpoint_get_logging_description(v177);
                      id v179 = nw_endpoint_handler_state_string(v48);
                      __int16 v180 = nw_endpoint_handler_mode_string(v48);
                      nw_content_context_t v181 = nw_endpoint_handler_copy_current_path(v48);
                      *(_DWORD *)int buf = 136448002;
                      v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                      v359 = 2082;
                      v360 = (char *)v175;
                      v361 = 2082;
                      v362 = v176;
                      v363 = 2082;
                      v364 = (void *)v178;
                      v365 = 2082;
                      v366 = v179;
                      v367 = 2082;
                      v368 = v180;
                      v369 = 2114;
                      v370 = v181;
                      v371 = 2114;
                      v372 = v347;
                      __int16 v182 = (char *)_os_log_send_and_compose_impl();

                      type[0] = OS_LOG_TYPE_ERROR;
                      LOBYTE(v353) = 0;
                      if ((__nwlog_fault(v182, type, &v353) & 1) != 0)
                      {
                        if (type[0] == OS_LOG_TYPE_FAULT)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          int v183 = (os_log_s *)(id)gconnectionLogObj;
                          __int16 v184 = type[0];
                          if (os_log_type_enabled(v183, type[0]))
                          {
                            uint64_t v185 = nw_endpoint_handler_get_id_string(v48);
                            __int16 v186 = nw_endpoint_handler_dry_run_string(v48);
                            logd = v183;
                            id v187 = nw_endpoint_handler_copy_endpoint(v48);
                            uint64_t v188 = nw_endpoint_get_logging_description(v187);
                            int v189 = v48;
                            int v190 = nw_endpoint_handler_state_string(v48);
                            BOOL v191 = nw_endpoint_handler_mode_string(v189);
                            int v192 = nw_endpoint_handler_copy_current_path(v189);
                            *(_DWORD *)int buf = 136448002;
                            v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            v359 = 2082;
                            v360 = (char *)v185;
                            v361 = 2082;
                            v362 = v186;
                            v363 = 2082;
                            v364 = (void *)v188;
                            v365 = 2082;
                            v366 = v190;
                            v367 = 2082;
                            v368 = v191;
                            v369 = 2114;
                            v370 = v192;
                            v371 = 2114;
                            v372 = v347;
                            _os_log_impl( &dword_181A5C000,  logd,  v184,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new %{public}@ insertion",  buf,  0x52u);

                            int v183 = logd;
                          }

                          goto LABEL_321;
                        }

                        if (!(_BYTE)v353)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          int v183 = (os_log_s *)(id)gconnectionLogObj;
                          uint32_t v215 = type[0];
                          if (os_log_type_enabled(v183, type[0]))
                          {
                            int v216 = nw_endpoint_handler_get_id_string(v48);
                            v217 = nw_endpoint_handler_dry_run_string(v48);
                            logf = v183;
                            os_log_type_t v218 = nw_endpoint_handler_copy_endpoint(v48);
                            v219 = nw_endpoint_get_logging_description(v218);
                            v220 = v48;
                            v221 = nw_endpoint_handler_state_string(v48);
                            os_log_type_t v222 = nw_endpoint_handler_mode_string(v220);
                            v223 = nw_endpoint_handler_copy_current_path(v220);
                            *(_DWORD *)int buf = 136448002;
                            v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            v359 = 2082;
                            v360 = (char *)v216;
                            v361 = 2082;
                            v362 = v217;
                            v363 = 2082;
                            v364 = (void *)v219;
                            v365 = 2082;
                            v366 = v221;
                            v367 = 2082;
                            v368 = v222;
                            v369 = 2114;
                            v370 = v223;
                            v371 = 2114;
                            v372 = v347;
                            _os_log_impl( &dword_181A5C000,  logf,  v215,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new %{public}@ insertion, backtrace limit exceeded",  buf,  0x52u);

                            int v183 = logf;
                          }

                          goto LABEL_321;
                        }

                        BOOL v193 = __nw_create_backtrace_string();
                        if (!v193)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          int v183 = (os_log_s *)(id)gconnectionLogObj;
                          v224 = type[0];
                          if (os_log_type_enabled(v183, type[0]))
                          {
                            v225 = nw_endpoint_handler_get_id_string(v48);
                            os_log_type_t v226 = nw_endpoint_handler_dry_run_string(v48);
                            logg = v183;
                            v227 = nw_endpoint_handler_copy_endpoint(v48);
                            v228 = nw_endpoint_get_logging_description(v227);
                            v229 = v48;
                            os_log_type_t v230 = nw_endpoint_handler_state_string(v48);
                            v231 = nw_endpoint_handler_mode_string(v229);
                            os_log_type_t v232 = nw_endpoint_handler_copy_current_path(v229);
                            *(_DWORD *)int buf = 136448002;
                            v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            v359 = 2082;
                            v360 = (char *)v225;
                            v361 = 2082;
                            v362 = v226;
                            v363 = 2082;
                            v364 = (void *)v228;
                            v365 = 2082;
                            v366 = v230;
                            v367 = 2082;
                            v368 = v231;
                            v369 = 2114;
                            v370 = v232;
                            v371 = 2114;
                            v372 = v347;
                            _os_log_impl( &dword_181A5C000,  logg,  v224,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new %{public}@ insertion, no backtrace",  buf,  0x52u);

                            int v183 = logg;
                          }

                          goto LABEL_321;
                        }

                        int v194 = (char *)v193;
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        int v195 = (os_log_s *)(id)gconnectionLogObj;
                        v196 = type[0];
                        if (os_log_type_enabled(v195, type[0]))
                        {
                          v197 = nw_endpoint_handler_get_id_string(v48);
                          loge = nw_endpoint_handler_dry_run_string(v48);
                          v327 = nw_endpoint_handler_copy_endpoint(v48);
                          __int16 v198 = nw_endpoint_get_logging_description(v327);
                          v199 = v48;
                          uint32_t v200 = nw_endpoint_handler_state_string(v48);
                          v201 = nw_endpoint_handler_mode_string(v199);
                          BOOL v202 = nw_endpoint_handler_copy_current_path(v199);
                          *(_DWORD *)int buf = 136448258;
                          v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                          v359 = 2082;
                          v360 = (char *)v197;
                          v361 = 2082;
                          v362 = loge;
                          v363 = 2082;
                          v364 = (void *)v198;
                          v365 = 2082;
                          v366 = v200;
                          v367 = 2082;
                          v368 = v201;
                          v369 = 2114;
                          v370 = v202;
                          v371 = 2114;
                          v372 = v347;
                          v373 = 2082;
                          v374 = v194;
                          _os_log_impl( &dword_181A5C000,  v195,  v196,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to r epair protocol stack: Could not undo new %{public}@ insertion, dumping backtrace:%{public}s",  buf,  0x5Cu);
                        }

                        goto LABEL_316;
                      }

LABEL_297:
              goto LABEL_298;
            }

                                if (*(_BYTE *)(a2 + *v8)) {
                                  v289 = 0;
                                }
LABEL_299:
                                *(_DWORD *)(a1 + 20) = v289;
                                goto LABEL_4;
                              case 8u:
                                *(_BYTE *)(a1 + 44) |= 0x40u;
                                __int128 v168 = *v3;
                                id v169 = *(void *)(a2 + v168);
                                if (v169 == -1LL || v169 >= *(void *)(a2 + *v6))
                                {
                                  uint64_t v172 = 0LL;
LABEL_276:
                                  *(_BYTE *)(a2 + *v_Block_object_dispose(va, 8) = 1;
                                  goto LABEL_277;
                                }

                                uint32_t v170 = v169 + 1;
                                int v171 = *(_BYTE *)(*(void *)(a2 + *v10) + v169);
                                *(void *)(a2 + v16_Block_object_dispose(va, 8) = v170;
                                uint64_t v172 = v171 & 0x7F;
                                if ((v171 & 0x80) == 0) {
                                  goto LABEL_277;
                                }
                                int v173 = *v3;
                                nw_endpoint_type_t v174 = *(void *)(a2 + v173);
                                if (v174 == -1LL || v174 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                id v175 = v174 + 1;
                                char v176 = *(char *)(*(void *)(a2 + *v10) + v174);
                                *(void *)(a2 + v173) = v175;
                                v172 |= (unint64_t)(v176 & 0x7F) << 7;
                                if ((v176 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                os_log_type_t v177 = *v3;
                                os_log_type_t v178 = *(void *)(a2 + v177);
                                if (v178 == -1LL || v178 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                id v179 = v178 + 1;
                                __int16 v180 = *(char *)(*(void *)(a2 + *v10) + v178);
                                *(void *)(a2 + v177) = v179;
                                v172 |= (unint64_t)(v180 & 0x7F) << 14;
                                if ((v180 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                nw_content_context_t v181 = *v3;
                                __int16 v182 = *(void *)(a2 + v181);
                                if (v182 == -1LL || v182 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                int v183 = v182 + 1;
                                __int16 v184 = *(char *)(*(void *)(a2 + *v10) + v182);
                                *(void *)(a2 + v181) = v183;
                                v172 |= (unint64_t)(v184 & 0x7F) << 21;
                                if ((v184 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                uint64_t v185 = *v3;
                                __int16 v186 = *(void *)(a2 + v185);
                                if (v186 == -1LL || v186 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                id v187 = v186 + 1;
                                uint64_t v188 = *(char *)(*(void *)(a2 + *v10) + v186);
                                *(void *)(a2 + v185) = v187;
                                v172 |= (unint64_t)(v188 & 0x7F) << 28;
                                if ((v188 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                int v189 = *v3;
                                int v190 = *(void *)(a2 + v189);
                                if (v190 == -1LL || v190 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                BOOL v191 = v190 + 1;
                                int v192 = *(char *)(*(void *)(a2 + *v10) + v190);
                                *(void *)(a2 + v189) = v191;
                                v172 |= (unint64_t)(v192 & 0x7F) << 35;
                                if ((v192 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                BOOL v193 = *v3;
                                int v194 = *(void *)(a2 + v193);
                                if (v194 == -1LL || v194 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                int v195 = v194 + 1;
                                v196 = *(char *)(*(void *)(a2 + *v10) + v194);
                                *(void *)(a2 + v193) = v195;
                                v172 |= (unint64_t)(v196 & 0x7F) << 42;
                                if ((v196 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                v197 = *v3;
                                __int16 v198 = *(void *)(a2 + v197);
                                if (v198 == -1LL || v198 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                v199 = v198 + 1;
                                uint32_t v200 = *(char *)(*(void *)(a2 + *v10) + v198);
                                *(void *)(a2 + v197) = v199;
                                v172 |= (unint64_t)(v200 & 0x7F) << 49;
                                if ((v200 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                v201 = *v3;
                                BOOL v202 = *(void *)(a2 + v201);
                                if (v202 == -1LL || v202 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                v203 = v202 + 1;
                                int v204 = *(char *)(*(void *)(a2 + *v10) + v202);
                                *(void *)(a2 + v201) = v203;
                                v172 |= (unint64_t)(v204 & 0x7F) << 56;
                                if ((v204 & 0x80000000) == 0) {
                                  goto LABEL_277;
                                }
                                int v205 = *v3;
                                int v206 = *(void *)(a2 + v205);
                                if (v206 == -1LL || v206 >= *(void *)(a2 + *v6)) {
                                  goto LABEL_276;
                                }
                                id v207 = v206 + 1;
                                int v208 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v206);
                                *(void *)(a2 + v205) = v207;
                                if ((v208 & 0x80) != 0)
                                {
                                  uint64_t v172 = 0LL;
                                  goto LABEL_279;
                                }

                                v172 |= v208 << 63;
LABEL_277:
                                if (*(_BYTE *)(a2 + *v8)) {
                                  uint64_t v172 = 0LL;
                                }
LABEL_279:
                                *(_BYTE *)(a1 + 40) = v172 != 0;
LABEL_4:
                                int v4 = *v3;
                                int v5 = *(void *)(a2 + v4);
                                __int16 v7 = *(void *)(a2 + *v6);
                                if (v5 >= v7) {
                                  return *(_BYTE *)(a2 + *v8) == 0;
                                }
                                continue;
                              default:
                                uint64_t result = PBReaderSkipValueWithTag();
                                if (!(_DWORD)result) {
                                  return result;
                                }
                                goto LABEL_4;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          int v13 = (_BYTE *)(a2 + *v8);
        }

        _DWORD *v13 = 1;
        goto LABEL_39;
      }

      break;
    }
  }

  return *(_BYTE *)(a2 + *v8) == 0;
}

                                  if (v204) {
                                    free(v204);
                                  }
                                  goto LABEL_299;
                                }
                              }

                              else if (v158)
                              {
                                goto LABEL_216;
                              }

                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                              }
                              logc = (id)gconnectionLogObj;
                              int v171 = nw_endpoint_handler_get_id_string(v45);
                              uint64_t v172 = nw_endpoint_handler_dry_run_string(v45);
                              int v173 = nw_endpoint_handler_copy_endpoint(v45);
                              nw_endpoint_type_t v174 = nw_endpoint_get_logging_description(v173);
                              id v175 = nw_endpoint_handler_state_string(v45);
                              char v176 = nw_endpoint_handler_mode_string(v45);
                              os_log_type_t v177 = nw_endpoint_handler_copy_current_path(v45);
                              *(_DWORD *)int buf = 136447746;
                              v355 = "nw_endpoint_start_tls_while_connected";
                              v356 = 2082;
                              v357 = (char *)v171;
                              v358 = 2082;
                              v359 = v172;
                              v360 = 2082;
                              v361 = (void *)v174;
                              v362 = 2082;
                              v363 = v175;
                              v364 = 2082;
                              v365 = v176;
                              v366 = 2114;
                              v367 = v177;
                              os_log_type_t v178 = (char *)_os_log_send_and_compose_impl();

                              type[0] = OS_LOG_TYPE_ERROR;
                              LOBYTE(v350) = 0;
                              if ((__nwlog_fault(v178, type, &v350) & 1) != 0)
                              {
                                if (type[0] == OS_LOG_TYPE_FAULT)
                                {
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  id v179 = (os_log_s *)(id)gconnectionLogObj;
                                  __int16 v180 = type[0];
                                  if (os_log_type_enabled(v179, type[0]))
                                  {
                                    nw_content_context_t v181 = nw_endpoint_handler_get_id_string(v45);
                                    __int16 v182 = nw_endpoint_handler_dry_run_string(v45);
                                    logd = v179;
                                    int v183 = nw_endpoint_handler_copy_endpoint(v45);
                                    __int16 v184 = nw_endpoint_get_logging_description(v183);
                                    uint64_t v185 = v45;
                                    __int16 v186 = nw_endpoint_handler_state_string(v45);
                                    id v187 = nw_endpoint_handler_mode_string(v185);
                                    uint64_t v188 = nw_endpoint_handler_copy_current_path(v185);
                                    *(_DWORD *)int buf = 136447746;
                                    v355 = "nw_endpoint_start_tls_while_connected";
                                    v356 = 2082;
                                    v357 = (char *)v181;
                                    v358 = 2082;
                                    v359 = v182;
                                    v360 = 2082;
                                    v361 = (void *)v184;
                                    v362 = 2082;
                                    v363 = v186;
                                    v364 = 2082;
                                    v365 = v187;
                                    v366 = 2114;
                                    v367 = v188;
                                    _os_log_impl( &dword_181A5C000,  logd,  v180,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] F ailed to repair protocol stack: Could not undo new TLS insertion",  buf,  0x48u);

                                    id v179 = logd;
                                  }

                                  goto LABEL_237;
                                }

                                if ((_BYTE)v350)
                                {
                                  int v192 = __nw_create_backtrace_string();
                                  if (v192)
                                  {
                                    BOOL v193 = (char *)v192;
                                    if (__nwlog_connection_log::onceToken != -1) {
                                      dispatch_once( &__nwlog_connection_log::onceToken,  &__block_literal_global_24_44325);
                                    }
                                    int v194 = (os_log_s *)(id)gconnectionLogObj;
                                    int v195 = type[0];
                                    if (os_log_type_enabled(v194, type[0]))
                                    {
                                      loge = v194;
                                      v196 = nw_endpoint_handler_get_id_string(v45);
                                      v325 = nw_endpoint_handler_dry_run_string(v45);
                                      v197 = nw_endpoint_handler_copy_endpoint(v45);
                                      __int16 v198 = nw_endpoint_get_logging_description(v197);
                                      v199 = v45;
                                      uint32_t v200 = nw_endpoint_handler_state_string(v45);
                                      v201 = nw_endpoint_handler_mode_string(v45);
                                      BOOL v202 = nw_endpoint_handler_copy_current_path(v199);
                                      *(_DWORD *)int buf = 136448002;
                                      v355 = "nw_endpoint_start_tls_while_connected";
                                      v356 = 2082;
                                      v357 = (char *)v196;
                                      v358 = 2082;
                                      v359 = v325;
                                      v360 = 2082;
                                      v361 = (void *)v198;
                                      v362 = 2082;
                                      v363 = v200;
                                      v364 = 2082;
                                      v365 = v201;
                                      v366 = 2114;
                                      v367 = v202;
                                      v368 = 2082;
                                      v369 = v193;
                                      _os_log_impl( &dword_181A5C000,  loge,  v195,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new TLS insertion, dumping back trace:%{public}s",  buf,  0x52u);

                                      int v194 = loge;
                                    }

                                    goto LABEL_315;
                                  }

                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  os_log_type_t v222 = (os_log_s *)(id)gconnectionLogObj;
                                  os_log_type_t v232 = type[0];
                                  if (os_log_type_enabled(v222, type[0]))
                                  {
                                    logg = v222;
                                    BOOL v233 = nw_endpoint_handler_get_id_string(v45);
                                    uint64_t v234 = nw_endpoint_handler_dry_run_string(v45);
                                    os_log_type_t v235 = nw_endpoint_handler_copy_endpoint(v45);
                                    BOOL v236 = nw_endpoint_get_logging_description(v235);
                                    BOOL v237 = v45;
                                    os_log_type_t v238 = nw_endpoint_handler_state_string(v45);
                                    BOOL v239 = nw_endpoint_handler_mode_string(v237);
                                    uint64_t v240 = nw_endpoint_handler_copy_current_path(v237);
                                    *(_DWORD *)int buf = 136447746;
                                    v355 = "nw_endpoint_start_tls_while_connected";
                                    v356 = 2082;
                                    v357 = (char *)v233;
                                    v358 = 2082;
                                    v359 = v234;
                                    v360 = 2082;
                                    v361 = (void *)v236;
                                    v362 = 2082;
                                    v363 = v238;
                                    v364 = 2082;
                                    v365 = v239;
                                    v366 = 2114;
                                    v367 = v240;
                                    _os_log_impl( &dword_181A5C000,  logg,  v232,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] F ailed to repair protocol stack: Could not undo new TLS insertion, no backtrace",  buf,  0x48u);

                                    os_log_type_t v222 = logg;
                                  }
                                }

                                else
                                {
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  os_log_type_t v222 = (os_log_s *)(id)gconnectionLogObj;
                                  v223 = type[0];
                                  if (os_log_type_enabled(v222, type[0]))
                                  {
                                    logf = v222;
                                    v224 = nw_endpoint_handler_get_id_string(v45);
                                    v225 = nw_endpoint_handler_dry_run_string(v45);
                                    os_log_type_t v226 = nw_endpoint_handler_copy_endpoint(v45);
                                    v227 = nw_endpoint_get_logging_description(v226);
                                    v228 = v45;
                                    v229 = nw_endpoint_handler_state_string(v45);
                                    os_log_type_t v230 = nw_endpoint_handler_mode_string(v228);
                                    v231 = nw_endpoint_handler_copy_current_path(v228);
                                    *(_DWORD *)int buf = 136447746;
                                    v355 = "nw_endpoint_start_tls_while_connected";
                                    v356 = 2082;
                                    v357 = (char *)v224;
                                    v358 = 2082;
                                    v359 = v225;
                                    v360 = 2082;
                                    v361 = (void *)v227;
                                    v362 = 2082;
                                    v363 = v229;
                                    v364 = 2082;
                                    v365 = v230;
                                    v366 = 2114;
                                    v367 = v231;
                                    _os_log_impl( &dword_181A5C000,  logf,  v223,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] F ailed to repair protocol stack: Could not undo new TLS insertion, backtrace limit exceeded",  buf,  0x48u);

                                    os_log_type_t v222 = logf;
                                  }
                                }

                                goto LABEL_325;
                              }

LABEL_172:
            if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
            {
              if (__nwlog_connection_group_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
              }
              int v102 = (os_log_s *)(id)gconnection_groupLogObj;
              if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v103 = *(void *)(a1 + 40);
                int v104 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
                *(_DWORD *)int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection_block_invoke";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v104;
                *(_WORD *)&buf[18] = 2112;
                *(void *)&buf[20] = v103;
                _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] stopping reads on %@",  buf,  0x1Cu);
              }
            }

            goto LABEL_174;
          }

  if (v58) {
    free(v58);
  }
  return 0LL;
}

  id v114 = *(void *)(a1 + 32);
  os_log_type_t v115 = *(unsigned __int8 *)(v114 + 109);
  if ((v115 & 0x40) != 0 && *(void *)(v114 + 144) == *(void *)(a1 + 40) && *(_DWORD *)(a1 + 68) != 2)
  {
    *(_BYTE *)(v114 + 109) = v115 & 0xBF;
    id v114 = *(void *)(a1 + 32);
    os_log_type_t v115 = *(unsigned __int8 *)(v114 + 109);
  }

  uint64_t v116 = (v115 >> 6) & 1;
  if (*(_DWORD *)(a1 + 68) == 2 && *(_DWORD *)(a1 + 64) == 3 && (v115 & 0x40) == 0)
  {
    uint64_t v116 = 0;
    os_log_type_t v117 = *(void *)(a1 + 40);
    if (v117)
    {
      if (v117 == *(void *)(v114 + 144))
      {
        id v118 = *(void **)(v114 + 152);
        *(void *)(v114 + 152) = 0LL;

        *(_BYTE *)(*(void *)(a1 + 32) + 109LL) |= 0x40u;
        int v119 = (void **)*(id *)(a1 + 32);
        int v120 = v119;
        if (v119)
        {
          nw_context_assert_queue(v119[3]);
          if ((*((_BYTE *)v120 + 109) & 0x40) != 0)
          {
            int v121 = v120[18];
            if (v121)
            {
              char v122 = (uint64_t)v120[36];
              if (v122)
              {
                BOOL v123 = v121;
                BOOL v124 = v123;
                __int16 v125 = v123[29];
                if (v125 == 4)
                {
                  nw_endpoint_fallback_reset_expected_progress_target(v123, v122);
                }

                else if (v125 == 2)
                {
                  nw_endpoint_flow_reset_expected_progress_target(v123, v122, (const unsigned __int8 *)v120 + 452);
                }
              }

              int v126 = v120[25];
              if (v126)
              {
                os_log_type_t v127 = v120[18];
                id v128 = v126;
                if (v127)
                {
                  os_log_type_t v129 = (NWConcrete_nw_endpoint_handler *)v127;
                  mode = v129->mode;

                  if ((_DWORD)mode == 2)
                  {
                    os_log_type_t v131 = (id *)nw_endpoint_handler_copy_flow(v129);
                    objc_storeStrong(v131 + 105, v126);

LABEL_233:
                    goto LABEL_234;
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  BOOL v132 = (id)gLogObj;
                  else {
                    os_log_type_t v133 = off_189BBBBC0[mode];
                  }
                  *(_DWORD *)int buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v133;
                  *(_WORD *)&buf[22] = 2082;
                  *(void *)&_BYTE buf[24] = "flow";
                  BOOL v135 = (char *)_os_log_send_and_compose_impl();

                  aBlock[0] = 16;
                  v537[0] = 0;
                  if (aBlock[0] == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    uint32_t v136 = (os_log_s *)(id)gLogObj;
                    int v137 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      else {
                        os_log_type_t v138 = off_189BBBBC0[mode];
                      }
                      *(_DWORD *)int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v138;
                      *(_WORD *)&buf[22] = 2082;
                      *(void *)&_BYTE buf[24] = "flow";
                      _os_log_impl( &dword_181A5C000,  v136,  v137,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
                    }
                  }

                  else if (v537[0])
                  {
                    os_log_type_t v139 = (char *)__nw_create_backtrace_string();
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    uint32_t v136 = (os_log_s *)(id)gLogObj;
                    uint32_t v140 = aBlock[0];
                    os_log_type_t v141 = os_log_type_enabled(v136, (os_log_type_t)aBlock[0]);
                    if (v139)
                    {
                      if (v141)
                      {
                        else {
                          BOOL v142 = off_189BBBBC0[mode];
                        }
                        *(_DWORD *)int buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v142;
                        *(_WORD *)&buf[22] = 2082;
                        *(void *)&_BYTE buf[24] = "flow";
                        *(_WORD *)v524 = 2082;
                        *(void *)&v524[2] = v139;
                        _os_log_impl( &dword_181A5C000,  v136,  v140,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
                      }

                      free(v139);
                      if (!v135) {
                        goto LABEL_233;
                      }
                      goto LABEL_232;
                    }

                    if (v141)
                    {
                      else {
                        BOOL v145 = off_189BBBBC0[mode];
                      }
                      *(_DWORD *)int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v145;
                      *(_WORD *)&buf[22] = 2082;
                      *(void *)&_BYTE buf[24] = "flow";
                      _os_log_impl( &dword_181A5C000,  v136,  v140,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
                    }
                  }

                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    uint32_t v136 = (os_log_s *)(id)gLogObj;
                    uint64_t v143 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      else {
                        os_log_type_t v144 = off_189BBBBC0[mode];
                      }
                      *(_DWORD *)int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v144;
                      *(_WORD *)&buf[22] = 2082;
                      *(void *)&_BYTE buf[24] = "flow";
                      _os_log_impl( &dword_181A5C000,  v136,  v143,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
                    }
                  }

                  goto LABEL_230;
                }

                __nwlog_obj();
                v489 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                BOOL v135 = (char *)_os_log_send_and_compose_impl();

                aBlock[0] = 16;
                v537[0] = 0;
                if (__nwlog_fault(v135, aBlock, v537))
                {
                  if (aBlock[0] == 17)
                  {
                    __nwlog_obj();
                    uint32_t v136 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    v490 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      _os_log_impl(&dword_181A5C000, v136, v490, "%{public}s called with null handler", buf, 0xCu);
                    }

    if (v72) {
      free(v72);
    }
    last_application_stream_id = -1LL;
    goto LABEL_55;
  }

  protocol_handler = a1->protocol_handler;
  nw_content_context_t v10 = MEMORY[0x1895F87A8];
  if (!protocol_handler)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
    os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v100[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      dispatch_qos_class_t v69 = (os_log_s *)__nwlog_obj();
      id v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_178;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
      os_log_type_t v71 = "%{public}s called with null transport_protocol";
    }

    else if (LOBYTE(v100[0]))
    {
      unsigned __int16 v76 = (char *)__nw_create_backtrace_string();
      dispatch_qos_class_t v69 = (os_log_s *)__nwlog_obj();
      id v70 = type[0];
      int v77 = os_log_type_enabled(v69, type[0]);
      if (v76)
      {
        if (v77)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v76;
          _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s called with null transport_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v76);
LABEL_178:
        if (!v68) {
          goto LABEL_69;
        }
        goto LABEL_179;
      }

      if (!v77) {
        goto LABEL_178;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
      os_log_type_t v71 = "%{public}s called with null transport_protocol, no backtrace";
    }

    else
    {
      dispatch_qos_class_t v69 = (os_log_s *)__nwlog_obj();
      id v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_178;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
      os_log_type_t v71 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
    }

          if (v67) {
            free(v67);
          }
LABEL_174:
          if (gLogDatapath)
          {
            int v87 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
            {
              __int16 v88 = *(void *)(a1 + 40);
              int v89 = "";
              unsigned int v90 = (const char *)(v88 + 205);
              int v85 = v88 == 0;
              int v91 = *(_DWORD *)(a1 + 56);
              if (!v85) {
                int v89 = v90;
              }
              *(_DWORD *)int buf = 136446978;
              unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
              int v102 = 2082;
              uint64_t v103 = (void *)v89;
              int v104 = 1024;
              *(_DWORD *)uint64_t v105 = v4;
              *(_WORD *)&v105[4] = 1024;
              *(_DWORD *)&v105[6] = v91;
              _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s reusing input frame of length %u, adjusting to %u",  buf,  0x22u);
            }

            uint64_t v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
              if (gLogDatapath)
              {
                char v92 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
                {
                  int v93 = *(void *)(a1 + 40);
                  if (v93) {
                    os_log_type_t v94 = (const char *)(v93 + 205);
                  }
                  else {
                    os_log_type_t v94 = "";
                  }
                  *(_DWORD *)int buf = 136446466;
                  unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
                  int v102 = 2082;
                  uint64_t v103 = (void *)v94;
                  _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s frame was exact match, not modifying",  buf,  0x16u);
                }
              }

              goto LABEL_177;
            }

            if (gLogDatapath)
            {
              uint64_t v95 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v96 = *(void *)(a1 + 40);
                *(_DWORD *)int buf = 136446722;
                unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
                if (v96) {
                  id v97 = (const char *)(v96 + 205);
                }
                else {
                  id v97 = "";
                }
                int v102 = 2082;
                uint64_t v103 = (void *)v97;
                int v104 = 1024;
                *(_DWORD *)uint64_t v105 = v82;
                _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s claiming %u bytes off end of frame",  buf,  0x1Cu);
              }
            }
          }

          else
          {
            uint64_t v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
LABEL_177:
              http2_transport_input_frame_context_reset(a2, *(void *)(a1 + 40), *(void *)(a1 + 48));
              uint64_t result = 0LL;
              *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
              return result;
            }
          }

          nw_frame_claim(a2, v7, 0, v82);
          goto LABEL_177;
        }

        return 1LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v30 = *(void *)(a1 + 40);
      if (v30) {
        uint64_t v31 = (const char *)(v30 + 205);
      }
      else {
        uint64_t v31 = "";
      }
      *(_DWORD *)int buf = 136446466;
      unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
      int v102 = 2082;
      uint64_t v103 = (void *)v31;
      int v32 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      id v98 = 0;
      if (__nwlog_fault(v32, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v33 = (os_log_s *)gLogObj;
          os_log_type_t v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_129;
          }
          BOOL v35 = *(void *)(a1 + 40);
          if (v35) {
            int v36 = (const char *)(v35 + 205);
          }
          else {
            int v36 = "";
          }
          *(_DWORD *)int buf = 136446466;
          unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v36;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer";
LABEL_128:
          _os_log_impl(&dword_181A5C000, v33, v34, v37, buf, 0x16u);
          goto LABEL_129;
        }

        if (!v98)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v33 = (os_log_s *)gLogObj;
          os_log_type_t v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_129;
          }
          os_log_type_t v71 = *(void *)(a1 + 40);
          if (v71) {
            dispatch_block_t v72 = (const char *)(v71 + 205);
          }
          else {
            dispatch_block_t v72 = "";
          }
          *(_DWORD *)int buf = 136446466;
          unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v72;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer, backtrace limit exceeded";
          goto LABEL_128;
        }

        BOOL v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v33 = (os_log_s *)gLogObj;
        os_log_type_t v34 = type;
        __int16 v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!v42)
        {
          if (!v43) {
            goto LABEL_129;
          }
          os_log_type_t v73 = *(void *)(a1 + 40);
          if (v73) {
            uint64_t v74 = (const char *)(v73 + 205);
          }
          else {
            uint64_t v74 = "";
          }
          *(_DWORD *)int buf = 136446466;
          unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v74;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer, no backtrace";
          goto LABEL_128;
        }

        if (v43)
        {
          os_log_type_t v44 = *(void *)(a1 + 40);
          if (v44) {
            BOOL v45 = (const char *)(v44 + 205);
          }
          else {
            BOOL v45 = "";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v101 = "http2_transport_create_input_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v45;
          int v104 = 2082;
          *(void *)uint64_t v105 = v42;
          _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s %{public}s destroying frame with NULL buffer, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v42);
      }

          if (v67) {
            free(v67);
          }
LABEL_174:
          if (gLogDatapath)
          {
            int v87 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
            {
              __int16 v88 = *(void *)(a1 + 40);
              int v89 = "";
              unsigned int v90 = (const char *)(v88 + 205);
              int v85 = v88 == 0;
              int v91 = *(_DWORD *)(a1 + 56);
              if (!v85) {
                int v89 = v90;
              }
              *(_DWORD *)int buf = 136446978;
              unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
              int v102 = 2082;
              uint64_t v103 = (void *)v89;
              int v104 = 1024;
              *(_DWORD *)uint64_t v105 = v4;
              *(_WORD *)&v105[4] = 1024;
              *(_DWORD *)&v105[6] = v91;
              _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s reusing output frame of length %u, adjusting to %u",  buf,  0x22u);
            }

            uint64_t v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
              if (gLogDatapath)
              {
                char v92 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
                {
                  int v93 = *(void *)(a1 + 40);
                  if (v93) {
                    os_log_type_t v94 = (const char *)(v93 + 205);
                  }
                  else {
                    os_log_type_t v94 = "";
                  }
                  *(_DWORD *)int buf = 136446466;
                  unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
                  int v102 = 2082;
                  uint64_t v103 = (void *)v94;
                  _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s frame was exact match, not modifying",  buf,  0x16u);
                }
              }

              goto LABEL_177;
            }

            if (gLogDatapath)
            {
              uint64_t v95 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v96 = *(void *)(a1 + 40);
                *(_DWORD *)int buf = 136446722;
                unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
                if (v96) {
                  id v97 = (const char *)(v96 + 205);
                }
                else {
                  id v97 = "";
                }
                int v102 = 2082;
                uint64_t v103 = (void *)v97;
                int v104 = 1024;
                *(_DWORD *)uint64_t v105 = v82;
                _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s claiming %u bytes off end of frame",  buf,  0x1Cu);
              }
            }
          }

          else
          {
            uint64_t v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
LABEL_177:
              http2_transport_output_frame_context_reset(a2, *(void *)(a1 + 40), *(void *)(a1 + 48));
              uint64_t result = 0LL;
              *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
              return result;
            }
          }

          nw_frame_claim(a2, v7, 0, v82);
          goto LABEL_177;
        }

        return 1LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v30 = *(void *)(a1 + 40);
      if (v30) {
        uint64_t v31 = (const char *)(v30 + 205);
      }
      else {
        uint64_t v31 = "";
      }
      *(_DWORD *)int buf = 136446466;
      unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
      int v102 = 2082;
      uint64_t v103 = (void *)v31;
      int v32 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      id v98 = 0;
      if (__nwlog_fault(v32, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v33 = (os_log_s *)gLogObj;
          os_log_type_t v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_129;
          }
          BOOL v35 = *(void *)(a1 + 40);
          if (v35) {
            int v36 = (const char *)(v35 + 205);
          }
          else {
            int v36 = "";
          }
          *(_DWORD *)int buf = 136446466;
          unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v36;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer";
LABEL_128:
          _os_log_impl(&dword_181A5C000, v33, v34, v37, buf, 0x16u);
          goto LABEL_129;
        }

        if (!v98)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v33 = (os_log_s *)gLogObj;
          os_log_type_t v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_129;
          }
          os_log_type_t v71 = *(void *)(a1 + 40);
          if (v71) {
            dispatch_block_t v72 = (const char *)(v71 + 205);
          }
          else {
            dispatch_block_t v72 = "";
          }
          *(_DWORD *)int buf = 136446466;
          unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v72;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer, backtrace limit exceeded";
          goto LABEL_128;
        }

        BOOL v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v33 = (os_log_s *)gLogObj;
        os_log_type_t v34 = type;
        __int16 v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!v42)
        {
          if (!v43) {
            goto LABEL_129;
          }
          os_log_type_t v73 = *(void *)(a1 + 40);
          if (v73) {
            uint64_t v74 = (const char *)(v73 + 205);
          }
          else {
            uint64_t v74 = "";
          }
          *(_DWORD *)int buf = 136446466;
          unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v74;
          os_log_type_t v37 = "%{public}s %{public}s destroying frame with NULL buffer, no backtrace";
          goto LABEL_128;
        }

        if (v43)
        {
          os_log_type_t v44 = *(void *)(a1 + 40);
          if (v44) {
            BOOL v45 = (const char *)(v44 + 205);
          }
          else {
            BOOL v45 = "";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v101 = "http2_transport_create_output_frame_block_invoke";
          int v102 = 2082;
          uint64_t v103 = (void *)v45;
          int v104 = 2082;
          *(void *)uint64_t v105 = v42;
          _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s %{public}s destroying frame with NULL buffer, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v42);
      }

        free(v51);
        goto LABEL_178;
      }

  __break(1u);
  return result;
}

    if (v90) {
      free(v90);
    }
    nw_protocol_set_output_handler(v25, v8);
    if (!v8)
    {
      __nwlog_obj();
      __int16 v86 = "invalid";
      goto LABEL_176;
    }

    if (v92) {
      free(v92);
    }
    if (!v14)
    {
      __nwlog_obj();
      int v75 = "invalid";
      goto LABEL_176;
    }

        if (v87) {
          free(v87);
        }

        LOWORD(v23) = 255;
        goto LABEL_119;
      }

      nw_context_assert_queue(*((void **)v7 + 3));
      uint64_t v9 = (unsigned __int8 *)*((void *)v7 + 49);
      if (!v9)
      {
        nw_content_context_t v10 = nw_array_create();
        id v11 = (void *)*((void *)v7 + 49);
        *((void *)v7 + 49) = v10;

        uint64_t v9 = (unsigned __int8 *)*((void *)v7 + 49);
      }

      *(void *)BOOL v132 = 0LL;
      *(void *)&v132[8] = v132;
      *(void *)&v132[16] = 0x2020000000LL;
      os_log_type_t v133 = -1;
      *(void *)os_log_type_t v134 = v4;
      *(void *)&v134[8] = 3221225472LL;
      *(void *)&v134[16] = ___ZL38nw_connection_add_activity_on_nw_queueP24NWConcrete_nw_connectionPU25objcproto14OS_nw_activity8NSObjectb_block_invoke;
      BOOL v135 = (const char *)&unk_189BC7960;
      int v12 = (char *)v8;
      *(void *)uint32_t v136 = v12;
      *(void *)&v136[8] = v132;
      nw_array_apply(v9, (uint64_t)v134);
      int v13 = *(unsigned __int16 *)(*(void *)&v132[8] + 24LL);
      if ((_DWORD)logging_description != 4 && v13 == 0xFFFF)
      {
        id v14 = v4;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v15 = (id)gLogObj;
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v129 = "nw_connection_add_activity_on_nw_queue";
        id v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        int v126 = 0;
        if (__nwlog_fault(v16, &type, &v126))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v17 = (os_log_s *)(id)gLogObj;
            int v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v129 = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started",  buf,  0xCu);
            }
          }

          else if (v126)
          {
            BOOL v47 = __nw_create_backtrace_string();
            if (v47)
            {
              int v48 = (char *)v47;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v49 = (os_log_s *)(id)gLogObj;
              uint64_t v50 = type;
              if (os_log_type_enabled(v49, type))
              {
                *(_DWORD *)int buf = 136446466;
                os_log_type_t v129 = "nw_connection_add_activity_on_nw_queue";
                uint64_t v130 = 2082;
                os_log_type_t v131 = v48;
                _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v48);
              if (!v16) {
                goto LABEL_79;
              }
              goto LABEL_78;
            }

            __nwlog_obj();
            uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            dispatch_qos_class_t v69 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v129 = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v17,  v69,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v17 = (os_log_s *)(id)gLogObj;
            id v64 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)int buf = 136446210;
              os_log_type_t v129 = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v17,  v64,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v16)
        {
LABEL_79:
          id v23 = 255;
          goto LABEL_80;
        }

    free(backtrace_string);
    if (!v33) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  uint64_t v17 = &g_registration_list;
  do
  {
    uint64_t v17 = (uint64_t *)*v17;
    if (!v17)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      goto LABEL_31;
    }
  }

  while (*(void *)identifier != v17[4]
       || *((void *)identifier + 1) != v17[5]
       || *((void *)identifier + 2) != v17[6]
       || *((void *)identifier + 3) != v17[7]
       || *((void *)identifier + 4) != v17[8]);
  os_log_type_t v22 = v17[13];
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  if (!v22)
  {
LABEL_31:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v15) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v27 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v15);
        id v118 = nw_endpoint_handler_dry_run_string(v15);
        int v29 = nw_endpoint_handler_copy_endpoint(v15);
        logging_description = nw_endpoint_get_logging_description(v29);
        id v30 = nw_endpoint_handler_state_string(v15);
        uint64_t v31 = nw_endpoint_handler_mode_string(v15);
        int v32 = nw_endpoint_handler_copy_current_path(v15);
        *(_DWORD *)int buf = 136448258;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        BOOL v132 = 2082;
        os_log_type_t v133 = (void *)id_string;
        os_log_type_t v134 = 2082;
        BOOL v135 = v118;
        uint32_t v136 = 2082;
        int v137 = (void *)logging_description;
        os_log_type_t v138 = 2082;
        os_log_type_t v139 = v30;
        uint32_t v140 = 2082;
        os_log_type_t v141 = v31;
        BOOL v142 = 2114;
        uint64_t v143 = v32;
        os_log_type_t v144 = 2080;
        BOOL v145 = identifier;
        os_log_type_t v146 = 2048;
        os_log_type_t v147 = (uint64_t)identifier;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not hav e accept function, cannot search for protocol to join",  buf,  0x5Cu);
      }
    }

    goto LABEL_72;
  }

  id v23 = v124;
  os_log_type_t v24 = v23;
  while (1)
  {
    registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join( (uint64_t)identifier,  -1LL,  v122,  v24,  v23,  v126,  v10 != 0);
    registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v24, v10 != 0);

    os_log_type_t v24 = (void *)registered_endpoint;
  }

  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v15) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v107 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
    {
      int v119 = nw_endpoint_handler_get_id_string(v15);
      os_log_type_t v117 = nw_endpoint_handler_dry_run_string(v15);
      id v108 = nw_endpoint_handler_copy_endpoint(v15);
      os_log_type_t v115 = nw_endpoint_get_logging_description(v108);
      id v114 = nw_endpoint_handler_state_string(v15);
      os_log_type_t v109 = nw_endpoint_handler_mode_string(v15);
      os_log_type_t v110 = nw_endpoint_handler_copy_current_path(v15);
      os_log_type_t v111 = v110;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      os_log_type_t v112 = "invalid";
      DNSServiceErrorType v113 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)int buf = 136448258;
      if (v113) {
        os_log_type_t v112 = v113;
      }
      BOOL v132 = 2082;
      os_log_type_t v133 = (void *)v119;
      os_log_type_t v134 = 2082;
      BOOL v135 = v117;
      uint32_t v136 = 2082;
      int v137 = (void *)v115;
      os_log_type_t v138 = 2082;
      os_log_type_t v139 = v114;
      uint32_t v140 = 2082;
      os_log_type_t v141 = v109;
      BOOL v142 = 2114;
      uint64_t v143 = v110;
      os_log_type_t v144 = 2080;
      BOOL v145 = (void *)v112;
      os_log_type_t v146 = 2048;
      os_log_type_t v147 = registered_endpoint;
      _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)",  buf,  0x5Cu);
    }
  }

      if (v118) {
        free(v118);
      }
      if ((*((_BYTE *)v5 + 36) & 2) == 0) {
        goto LABEL_15;
      }
      __nwlog_obj();
      uint64_t v143 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      v219 = "nw_endpoint_handler_get_logging_disabled";
      os_log_type_t v144 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v214) = 0;
      if (__nwlog_fault(v144, type, &v214))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          BOOL v145 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v146 = type[0];
          if (os_log_type_enabled(v145, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            v219 = "nw_endpoint_handler_get_logging_disabled";
            _os_log_impl(&dword_181A5C000, v145, v146, "%{public}s called with null handler", buf, 0xCu);
          }
        }

        else if ((_BYTE)v214)
        {
          os_log_type_t v147 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v145 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v148 = type[0];
          os_log_type_t v149 = os_log_type_enabled(v145, type[0]);
          if (v147)
          {
            if (v149)
            {
              *(_DWORD *)int buf = 136446466;
              v219 = "nw_endpoint_handler_get_logging_disabled";
              v220 = 2082;
              v221 = v147;
              _os_log_impl( &dword_181A5C000,  v145,  v148,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v147);
            goto LABEL_201;
          }

          if (v149)
          {
            *(_DWORD *)int buf = 136446210;
            v219 = "nw_endpoint_handler_get_logging_disabled";
            _os_log_impl(&dword_181A5C000, v145, v148, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          BOOL v145 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v150 = type[0];
          if (os_log_type_enabled(v145, type[0]))
          {
            *(_DWORD *)int buf = 136446210;
            v219 = "nw_endpoint_handler_get_logging_disabled";
            _os_log_impl( &dword_181A5C000,  v145,  v150,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

  if (v60) {
    free(v60);
  }
  LODWORD(v12) = 0;
LABEL_175:
  LODWORD(v_Block_object_dispose(va, 8) = v58 + v8;
  int v77 = *(void *)(a1 + 104);
  if ((!v77 || (*(__int16 *)(v77 + 388) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v227 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v228 = *(void *)(a1 + 104);
      v229 = "";
      os_log_type_t v230 = v228 == 0;
      v231 = *(_DWORD *)(v228 + 368);
      os_log_type_t v232 = (const char *)(v228 + 390);
      v256 = "send_data_callback_block_invoke";
      os_log_type_t v257 = 2082;
      if (v230) {
        os_log_type_t v232 = "";
      }
      *(_DWORD *)int buf = 136447234;
      if (!v230) {
        v229 = " ";
      }
      BOOL v258 = v232;
      os_log_type_t v259 = 2080;
      v260 = (size_t)v229;
      os_log_type_t v261 = 1024;
      *(_DWORD *)BOOL v262 = v231;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v58;
      _os_log_impl( &dword_181A5C000,  v227,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> wrote %u bytes of datagram context",  buf,  0x2Cu);
    }
  }

  if (v254 > v8)
  {
LABEL_179:
    BOOL v78 = *(dispatch_data_s **)(a1 + 160);
    if (!v78 || *(_BYTE *)(a1 + 208)) {
      goto LABEL_181;
    }
    uint64_t v103 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL);
    int v104 = *(_DWORD *)(a1 + 168) - v103;
    uint64_t v105 = v104 >= v12 ? v12 : v104;
    if (!(_DWORD)v105) {
      goto LABEL_181;
    }
    nw_dispatch_data_copyout_from_offset(v78, (uint64_t)&v6[v8], v105, v103);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v105;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v105;
    *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) += v105;
    id v16 = v12 >= v105;
    uint64_t v106 = (v12 - v105);
    LODWORD(v12) = v12 - v105;
    if (v16) {
      goto LABEL_369;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    os_log_type_t v257 = 2082;
    BOOL v258 = "bodyCopySize";
    os_log_type_t v259 = 2048;
    v260 = v105;
    os_log_type_t v261 = 2048;
    *(void *)BOOL v262 = v106;
    os_log_type_t v107 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v107, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v108 = (os_log_s *)__nwlog_obj();
        os_log_type_t v109 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          os_log_type_t v257 = 2082;
          BOOL v258 = "bodyCopySize";
          os_log_type_t v259 = 2048;
          v260 = v105;
          os_log_type_t v261 = 2048;
          *(void *)BOOL v262 = v106;
          os_log_type_t v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_365:
          _os_log_impl(&dword_181A5C000, v108, v109, v110, buf, 0x2Au);
        }
      }

      else if (v253)
      {
        int v126 = (char *)__nw_create_backtrace_string();
        id v108 = (os_log_s *)__nwlog_obj();
        os_log_type_t v109 = type[0];
        os_log_type_t v127 = os_log_type_enabled(v108, type[0]);
        if (v126)
        {
          if (v127)
          {
            *(_DWORD *)int buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            os_log_type_t v257 = 2082;
            BOOL v258 = "bodyCopySize";
            os_log_type_t v259 = 2048;
            v260 = v105;
            os_log_type_t v261 = 2048;
            *(void *)BOOL v262 = v106;
            *(_WORD *)&v262[8] = 2082;
            *(void *)&v262[10] = v126;
            _os_log_impl( &dword_181A5C000,  v108,  v109,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v126);
          goto LABEL_366;
        }

        if (v127)
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          os_log_type_t v257 = 2082;
          BOOL v258 = "bodyCopySize";
          os_log_type_t v259 = 2048;
          v260 = v105;
          os_log_type_t v261 = 2048;
          *(void *)BOOL v262 = v106;
          os_log_type_t v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_365;
        }
      }

      else
      {
        id v108 = (os_log_s *)__nwlog_obj();
        os_log_type_t v109 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          os_log_type_t v257 = 2082;
          BOOL v258 = "bodyCopySize";
          os_log_type_t v259 = 2048;
          v260 = v105;
          os_log_type_t v261 = 2048;
          *(void *)BOOL v262 = v106;
          os_log_type_t v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_365;
        }
      }
    }

  if (v53) {
    free(v53);
  }
  int v15 = 0LL;
LABEL_22:
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v20 = *(void *)(a1 + 88);
    if (v20)
    {
      int v21 = v20 - 1;
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = v21;
      if (!v21)
      {
        os_log_type_t v22 = *(void (***)(void))(a1 + 64);
        if (v22)
        {
          *(void *)(a1 + 64) = 0LL;
          v22[2](v22);
          _Block_release(v22);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          id v23 = *(const void **)(a1 + 64);
          if (v23) {
            _Block_release(v23);
          }
        }

        free((void *)a1);
      }
    }
  }

  if (!v15)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    dispatch_block_t v72 = "nw_protocol_test_access_options";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    dispatch_qos_class_t v69 = 0;
    if (__nwlog_fault(v24, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v25 = (os_log_s *)__nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          dispatch_block_t v72 = "nw_protocol_test_access_options";
          int v27 = "%{public}s called with null parameters";
          goto LABEL_88;
        }
      }

      else if (v69)
      {
        os_log_type_t v40 = (char *)__nw_create_backtrace_string();
        __int16 v25 = (os_log_s *)__nwlog_obj();
        os_log_type_t v26 = type;
        os_log_type_t v65 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v65)
          {
            *(_DWORD *)int buf = 136446466;
            dispatch_block_t v72 = "nw_protocol_test_access_options";
            os_log_type_t v73 = 2082;
            uint64_t v74 = v40;
            BOOL v42 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
            goto LABEL_63;
          }

          goto LABEL_64;
        }

        if (v65)
        {
          *(_DWORD *)int buf = 136446210;
          dispatch_block_t v72 = "nw_protocol_test_access_options";
          int v27 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_88;
        }
      }

      else
      {
        __int16 v25 = (os_log_s *)__nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)int buf = 136446210;
          dispatch_block_t v72 = "nw_protocol_test_access_options";
          int v27 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
    }

LABEL_312:
      if (!v35) {
        goto LABEL_32;
      }
      goto LABEL_234;
    }

    __nwlog_obj();
    __int16 v125 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
    BOOL v35 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v164) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v126 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v127 = type[0];
      if (os_log_type_enabled(v126, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
        _os_log_impl(&dword_181A5C000, v126, v127, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if ((_BYTE)v164)
    {
      uint32_t v140 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v126 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v141 = type[0];
      BOOL v142 = os_log_type_enabled(v126, type[0]);
      if (v140)
      {
        if (v142)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v140;
          _os_log_impl( &dword_181A5C000,  v126,  v141,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v140);
        goto LABEL_312;
      }

      if (v142)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
        _os_log_impl(&dword_181A5C000, v126, v141, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v126 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v148 = type[0];
      if (os_log_type_enabled(v126, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
        _os_log_impl( &dword_181A5C000,  v126,  v148,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DD87EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void *___ZL51nw_connection_group_handle_connection_state_changedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection21nw_connection_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_137( void *result)
{
  *(_DWORD *)(*(void *)(result[5] + 8LL) + 24LL) = *(_DWORD *)(result[4] + 40LL);
  *(_BYTE *)(*(void *)(result[6] + 8LL) + 24LL) = *(_BYTE *)(result[4] + 190LL) & 1;
  return result;
}

void ___ZL51nw_connection_group_handle_connection_state_changedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection21nw_connection_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_138( uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v3 = *(id *)(a1 + 32);
  id v4 = v2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v39 = "nw_connection_group_remove_connection_locked";
    int v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v39 = "nw_connection_group_remove_connection_locked";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v39 = "nw_connection_group_remove_connection_locked";
          __int16 v40 = 2082;
          *(void *)os_log_type_t v41 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_70:
        if (!v12) {
          goto LABEL_6;
        }
LABEL_71:
        free(v12);
        goto LABEL_6;
      }

      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v39 = "nw_connection_group_remove_connection_locked";
        _os_log_impl(&dword_181A5C000, v13, v24, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v39 = "nw_connection_group_remove_connection_locked";
        _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_connection_group_final_cleanup_locked(NWConcrete_nw_connection_group *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v1 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v3 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        int v4 = *((_DWORD *)v2 + 42);
        *(_DWORD *)int buf = 136446466;
        int v21 = "nw_connection_group_final_cleanup_locked";
        __int16 v22 = 1024;
        LODWORD(v23) = v4;
        _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_INFO, "%{public}s [G%u] final group cleanup", buf, 0x12u);
      }
    }

    nw_connection_group_set_state_locked(v2, 4, 0LL);
    int v5 = (void *)*((void *)v2 + 4);
    *((void *)v2 + 4) = 0LL;

    uint64_t v6 = (void *)*((void *)v2 + 17);
    *((void *)v2 + 17) = 0LL;

    uint64_t v7 = (void *)*((void *)v2 + 18);
    *((void *)v2 + 1_Block_object_dispose(va, 8) = 0LL;

    int v8 = (void *)*((void *)v2 + 1);
    *((void *)v2 + 1) = 0LL;

    uint64_t v9 = (void *)*((void *)v2 + 3);
    *((void *)v2 + 3) = 0LL;

    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v21 = "nw_connection_group_final_cleanup_locked";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v21 = "nw_connection_group_final_cleanup_locked";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          int v21 = "nw_connection_group_final_cleanup_locked";
          __int16 v22 = 2082;
          id v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        int v21 = "nw_connection_group_final_cleanup_locked";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v21 = "nw_connection_group_final_cleanup_locked";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DD945C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_set_state_locked(void *a1, signed int a2, void *a3)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  uint64_t v6 = a3;
  uint64_t v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    nw_content_context_t v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v77 = "nw_connection_group_set_state_locked";
    int v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (__nwlog_fault(v30, &type, &v74))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v64 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v77 = "nw_connection_group_set_state_locked";
          _os_log_impl(&dword_181A5C000, v31, v64, "%{public}s called with null group", buf, 0xCu);
        }

uint64_t ___ZL36nw_connection_group_set_state_lockedP30NWConcrete_nw_connection_group27nw_connection_group_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke( uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v3 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      uint64_t v5 = *(unsigned int *)(a1 + 56);
      else {
        uint64_t v6 = off_189BB8B98[v5];
      }
      uint64_t v7 = *(void *)(a1 + 40);
      int v8 = 136446978;
      uint64_t v9 = "nw_connection_group_set_state_locked_block_invoke";
      __int16 v10 = 1024;
      int v11 = v4;
      __int16 v12 = 2080;
      os_log_type_t v13 = v6;
      __int16 v14 = 2112;
      uint64_t v15 = v7;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] delivering state %s, error %@",  (uint8_t *)&v8,  0x26u);
    }
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16LL))();
}

uint64_t __Block_byref_object_copy__8579(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__8580(uint64_t a1)
{
}

void ___ZL38nw_connection_group_read_on_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_142( void *a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1[4] + 136LL));
  uint64_t v3 = *(void *)(a1[5] + 8LL);
  int v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), *(id *)(a1[4] + 8LL));
}

void ___ZL38nw_connection_group_read_on_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_2( uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(a1 + 32);
  BOOL v5 = v2 == &__block_literal_global_3_41839
    || v2 == &__block_literal_global_41831
    || v2 == &__block_literal_global_4
    || v2 == &__block_literal_global_5_41854;
  if (!v5 || *(void *)(a1 + 40))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 48) + 56LL)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      os_log_type_t v13 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        int v14 = *(_DWORD *)(*(void *)(a1 + 48) + 168LL);
        uint64_t v15 = *(nw_content_context **)(a1 + 32);
        identifier = nw_content_context_get_identifier(v15);
        id v17 = *(const char **)(a1 + 40);
        if (v17) {
          size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 40));
        }
        else {
          size_t size = 0LL;
        }
        int v19 = *(unsigned __int8 *)(a1 + 64);
        unsigned int v22 = "nw_connection_group_read_on_connection_block_invoke_2";
        int v21 = 136447746;
        __int16 v23 = 1024;
        if (v19) {
          uint64_t v20 = "true";
        }
        else {
          uint64_t v20 = "false";
        }
        int v24 = v14;
        __int16 v25 = 2048;
        uint64_t v26 = v15;
        __int16 v27 = 2080;
        BOOL v28 = identifier;
        __int16 v29 = 2048;
        int v30 = v17;
        __int16 v31 = 2048;
        size_t v32 = size;
        __int16 v33 = 2080;
        uint64_t v34 = v20;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] calling receive handler with context (%p: %s), content (%p: %zu bytes), complete %s",  (uint8_t *)&v21,  0x44u);
      }
    }

    uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    (*(void (**)(uint64_t, void))(v6 + 16))(v6, *(void *)(a1 + 40));
  }

  else if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 48) + 56LL)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v7 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      int v8 = *(_DWORD *)(*(void *)(a1 + 48) + 168LL);
      uint64_t v9 = *(nw_content_context **)(a1 + 32);
      __int16 v10 = nw_content_context_get_identifier(v9);
      int v11 = *(unsigned __int8 *)(a1 + 64);
      unsigned int v22 = "nw_connection_group_read_on_connection_block_invoke";
      __int16 v23 = 1024;
      int v21 = 136447234;
      if (v11) {
        __int16 v12 = "true";
      }
      else {
        __int16 v12 = "false";
      }
      int v24 = v8;
      __int16 v25 = 2048;
      uint64_t v26 = v9;
      __int16 v27 = 2080;
      BOOL v28 = v10;
      __int16 v29 = 2080;
      int v30 = v12;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] not calling receive handler with context (%p: %s), complete %s",  (uint8_t *)&v21,  0x30u);
    }
  }

void nw_connection_group_touch_connection(NWConcrete_nw_connection_group *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  int v4 = a2;
  BOOL v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v27 = "nw_connection_group_touch_connection";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v27 = "nw_connection_group_touch_connection";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v27 = "nw_connection_group_touch_connection";
          __int16 v28 = 2082;
          __int16 v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v27 = "nw_connection_group_touch_connection";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v27 = "nw_connection_group_touch_connection";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DDAA7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_connection_group_touch_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke( uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (nw_array_remove_object(*(void *)(*(void *)(a1 + 32) + 104LL), *(void *)(a1 + 40)))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v2 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v3 = *(void *)(a1 + 40);
        int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        int v5 = 136446722;
        uint64_t v6 = "nw_connection_group_touch_connection_block_invoke";
        __int16 v7 = 1024;
        int v8 = v4;
        __int16 v9 = 2112;
        uint64_t v10 = v3;
        _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] touching connection %@",  (uint8_t *)&v5,  0x1Cu);
      }
    }

    nw_array_insert_object_at_index(*(void *)(*(void *)(a1 + 32) + 104LL), *(void **)(a1 + 40), 0LL);
  }

void nw_connection_group_create_listener_from_connection_locked( NWConcrete_nw_connection_group *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v151 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  int v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v67 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)handler = 136446210;
    *(void *)&void handler[4] = "nw_connection_group_create_listener_from_connection_locked";
    os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = 0;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      dispatch_qos_class_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v70 = buf[0];
      if (os_log_type_enabled(v69, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)handler = 136446210;
        *(void *)&void handler[4] = "nw_connection_group_create_listener_from_connection_locked";
        _os_log_impl(&dword_181A5C000, v69, v70, "%{public}s called with null group", handler, 0xCu);
      }
    }

    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      dispatch_qos_class_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v74 = buf[0];
      BOOL v75 = os_log_type_enabled(v69, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v75)
        {
          *(_DWORD *)handler = 136446466;
          *(void *)&void handler[4] = "nw_connection_group_create_listener_from_connection_locked";
          *(_WORD *)&handler[12] = 2082;
          *(void *)&handler[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v69,  v74,  "%{public}s called with null group, dumping backtrace:%{public}s",  handler,  0x16u);
        }

        free(backtrace_string);
LABEL_143:
        if (!v68) {
          goto LABEL_60;
        }
        goto LABEL_144;
      }

      if (v75)
      {
        *(_DWORD *)handler = 136446210;
        *(void *)&void handler[4] = "nw_connection_group_create_listener_from_connection_locked";
        _os_log_impl(&dword_181A5C000, v69, v74, "%{public}s called with null group, no backtrace", handler, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      dispatch_qos_class_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v93 = buf[0];
      if (os_log_type_enabled(v69, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)handler = 136446210;
        *(void *)&void handler[4] = "nw_connection_group_create_listener_from_connection_locked";
        _os_log_impl( &dword_181A5C000,  v69,  v93,  "%{public}s called with null group, backtrace limit exceeded",  handler,  0xCu);
      }
    }

void sub_181DDC8B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, void *a39)
{
  _Unwind_Resume(a1);
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke( uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  nw_listener_t v6 = (os_unfair_lock_s *)*(id *)(a1 + 32);
  id v7 = v5;
  if (v6)
  {
    uint64_t v62 = 0LL;
    unsigned int v63 = &v62;
    int v65 = 0;
    uint64_t v8 = MEMORY[0x1895F87A8];
    uint64_t v64 = 0x2020000000LL;
    *(void *)aBlock = MEMORY[0x1895F87A8];
    *(void *)&aBlock[8] = 3221225472LL;
    *(void *)&aBlock[16] = ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke;
    dispatch_qos_class_t v69 = &unk_189BC9210;
    os_log_type_t v71 = &v62;
    __int16 v9 = v6;
    os_log_type_t v70 = v9;
    id v10 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v6 + 43);
    v10[2](v10);
    os_unfair_lock_unlock(v6 + 43);

    int v11 = *((_DWORD *)v63 + 6);
    if (a2 == 4 && v11 == 4)
    {
      if (!nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque) && gLogDatapath)
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        id v49 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          uint32_t os_unfair_lock_opaque = v9[42]._os_unfair_lock_opaque;
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = os_unfair_lock_opaque;
          _os_log_impl(&dword_181A5C000, v49, OS_LOG_TYPE_DEBUG, "%{public}s [G%u] listener cancelled", buf, 0x12u);
        }
      }

      *(void *)int buf = v8;
      *(void *)&sockaddr buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_169;
      *(void *)&_BYTE buf[24] = &unk_189BC93A0;
      *(void *)&_BYTE buf[32] = v9;
      os_log_type_t v12 = (void (**)(void))_Block_copy(buf);
      os_unfair_lock_lock(v6 + 43);
      v12[2](v12);
      os_unfair_lock_unlock(v6 + 43);

      id v13 = *(os_log_s **)&buf[32];
      goto LABEL_7;
    }

    if (v11 == 4)
    {
      if (nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque)) {
        goto LABEL_8;
      }
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      id v13 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        if (a2 > 4) {
          BOOL v14 = "<unknown>";
        }
        else {
          BOOL v14 = off_189BB8B98[a2];
        }
        uint32_t v21 = v9[42]._os_unfair_lock_opaque;
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_listener_state_change";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v21;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = v14;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] already cancelled, ignoring listener state %s",  buf,  0x1Cu);
      }

void sub_181DDD798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id a23, id a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, id a29)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_2( uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  uint64_t v107 = *MEMORY[0x1895F89C0];
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = *(id *)(a1 + 32);
  id v17 = v11;
  id v85 = v12;
  __int16 v84 = (nw_content_context *)v13;
  id v82 = v14;
  data = (dispatch_data_s *)v15;
  os_log_type_t v81 = v17;
  if (!v16)
  {
    __nwlog_obj();
    uint32_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
    int v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock[0]) = 16;
    LOBYTE(v96) = 0;
    if (LOBYTE(aBlock[0]) == 17)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v39, v40, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (!(_BYTE)v96)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v72 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl( &dword_181A5C000,  v39,  v72,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_118;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v53 = aBlock[0];
    BOOL v54 = os_log_type_enabled(v52, aBlock[0]);
    if (backtrace_string)
    {
      if (v54)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_137:
      if (!v38) {
        goto LABEL_29;
      }
LABEL_138:
      free(v38);
      goto LABEL_29;
    }

    if (v54)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
      _os_log_impl(&dword_181A5C000, v52, v53, "%{public}s called with null group, no backtrace", buf, 0xCu);
    }

    goto LABEL_136;
  }

  if (!v17)
  {
    __nwlog_obj();
    uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
    int v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock[0]) = 16;
    LOBYTE(v96) = 0;
    if (LOBYTE(aBlock[0]) == 17)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v39, v42, "%{public}s called with null source", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (!(_BYTE)v96)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v73 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl( &dword_181A5C000,  v39,  v73,  "%{public}s called with null source, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_118;
    }

    os_log_type_t v55 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v56 = aBlock[0];
    BOOL v57 = os_log_type_enabled(v52, aBlock[0]);
    if (!v55)
    {
      if (v57)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v52, v56, "%{public}s called with null source, no backtrace", buf, 0xCu);
      }

      goto LABEL_136;
    }

    if (v57)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v55;
      _os_log_impl( &dword_181A5C000,  v52,  v56,  "%{public}s called with null source, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_89;
  }

  if (!v85)
  {
    __nwlog_obj();
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
    int v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock[0]) = 16;
    LOBYTE(v96) = 0;
    if (LOBYTE(aBlock[0]) == 17)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v39, v44, "%{public}s called with null destination", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (!(_BYTE)v96)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v74 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl( &dword_181A5C000,  v39,  v74,  "%{public}s called with null destination, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_118;
    }

    os_log_type_t v55 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v58 = aBlock[0];
    BOOL v59 = os_log_type_enabled(v52, aBlock[0]);
    if (!v55)
    {
      if (v59)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v52, v58, "%{public}s called with null destination, no backtrace", buf, 0xCu);
      }

      goto LABEL_136;
    }

    if (v59)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v55;
      _os_log_impl( &dword_181A5C000,  v52,  v58,  "%{public}s called with null destination, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_89;
  }

  if (!v84)
  {
    __nwlog_obj();
    os_log_type_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
    int v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock[0]) = 16;
    LOBYTE(v96) = 0;
    if (LOBYTE(aBlock[0]) == 17)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v39, v46, "%{public}s called with null interface", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (!(_BYTE)v96)
    {
      __nwlog_obj();
      os_log_type_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v75 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl( &dword_181A5C000,  v39,  v75,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_118;
    }

    os_log_type_t v55 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v60 = aBlock[0];
    BOOL v61 = os_log_type_enabled(v52, aBlock[0]);
    if (!v55)
    {
      if (v61)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v52, v60, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }

      goto LABEL_136;
    }

    if (v61)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v55;
      _os_log_impl( &dword_181A5C000,  v52,  v60,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181DDECDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, id a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, id a39)
{
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a34, 8);

  _Unwind_Resume(a1);
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_3( uint64_t a1, NWConcrete_nw_connection *a2)
{
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_4( uint64_t a1, int a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (a2 == 3)
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      id v14 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        uint64_t v15 = *(void *)(a1 + 32);
        int v16 = *(_DWORD *)(v15 + 168);
        uint64_t v17 = *(void *)(v15 + 96);
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v17;
        _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_INFO, "%{public}s [G%u] unicast listener %@ failed", buf, 0x1Cu);
      }
    }

    BOOL v18 = *(os_unfair_lock_s **)(a1 + 32);
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_167;
    v20[3] = &unk_189BC9238;
    uint32_t v21 = v18;
    id v22 = v5;
    int v19 = (void (**)(void))_Block_copy(v20);
    v18 += 43;
    os_unfair_lock_lock(v18);
    v19[2](v19);
    os_unfair_lock_unlock(v18);
  }

  else if (a2 == 2)
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      nw_listener_t v6 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        int v8 = *(_DWORD *)(v7 + 168);
        uint64_t v9 = *(void *)(v7 + 96);
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked_block_invoke_4";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v9;
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_INFO, "%{public}s [G%u] unicast listener %@ ready", buf, 0x1Cu);
      }
    }

    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    *(void *)&_BYTE buf[24] = __Block_byref_object_copy__8579;
    __int16 v29 = __Block_byref_object_dispose__8580;
    id v30 = 0LL;
    uint64_t v10 = MEMORY[0x1895F87A8];
    id v11 = *(os_unfair_lock_s **)(a1 + 32);
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_163;
    aBlock[3] = &unk_189BC9210;
    id v27 = buf;
    uint32_t v26 = v11;
    id v12 = (void (**)(void))_Block_copy(aBlock);
    v11 += 43;
    os_unfair_lock_lock(v11);
    v12[2](v12);
    os_unfair_lock_unlock(v11);

    id v13 = *(unsigned __int8 **)(*(void *)&buf[8] + 40LL);
    v23[0] = v10;
    v23[1] = 3221225472LL;
    v23[2] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_2_164;
    v23[3] = &unk_189BC85B0;
    id v24 = *(id *)(a1 + 32);
    nw_array_apply(v13, (uint64_t)v23);

    _Block_object_dispose(buf, 8);
  }
}

void sub_181DDF100( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_2_168( uint64_t a1, NWConcrete_nw_connection *a2)
{
}

void nw_connection_group_handle_incoming_connection( NWConcrete_nw_connection_group *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  int v4 = a2;
  id v49 = v4;
  if (!v3)
  {
    __nwlog_obj();
    char v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v63 = "nw_connection_group_handle_incoming_connection";
    uint32_t v37 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v61 = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (v61 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = v61;
      if (os_log_type_enabled(v38, v61))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v63 = "nw_connection_group_handle_incoming_connection";
        _os_log_impl(&dword_181A5C000, v38, v39, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (!v60)
    {
      __nwlog_obj();
      int v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = v61;
      if (os_log_type_enabled(v38, v61))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v63 = "nw_connection_group_handle_incoming_connection";
        _os_log_impl( &dword_181A5C000,  v38,  v47,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v43 = v61;
    BOOL v44 = os_log_type_enabled(v38, v61);
    if (!backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v63 = "nw_connection_group_handle_incoming_connection";
        _os_log_impl(&dword_181A5C000, v38, v43, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (v44)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v63 = "nw_connection_group_handle_incoming_connection";
      __int16 v64 = 2082;
      *(void *)BOOL v65 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v38,  v43,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_65;
  }

  id v5 = v4;
  if (v4)
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v3 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      nw_listener_t v6 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *((_DWORD *)v3 + 42);
        *(_DWORD *)int buf = 136446722;
        BOOL v63 = "nw_connection_group_handle_incoming_connection";
        __int16 v64 = 1024;
        *(_DWORD *)BOOL v65 = v7;
        *(_WORD *)&v65[4] = 2112;
        *(void *)&v65[6] = v5;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s [G%u] new incoming connection %@",  buf,  0x1Cu);
      }

      id v5 = v49;
    }

    uint64_t v8 = MEMORY[0x1895F87A8];
    if (!*((void *)v3 + 18))
    {
      v50[0] = MEMORY[0x1895F87A8];
      v50[1] = 3221225472LL;
      v50[2] = ___ZL46nw_connection_group_handle_incoming_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_175;
      v50[3] = &unk_189BC9238;
      os_log_type_t v51 = v3;
      BOOL v18 = v5;
      os_log_type_t v52 = v18;
      int v19 = (void (**)(void))_Block_copy(v50);
      os_unfair_lock_lock((os_unfair_lock_t)v3 + 43);
      v19[2](v19);
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 43);

      nw_connection_start((nw_connection_t)v18);
LABEL_26:
      uint32_t v26 = v49;
      goto LABEL_27;
    }

    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL46nw_connection_group_handle_incoming_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke;
    aBlock[3] = &unk_189BC9238;
    uint64_t v9 = v5;
    os_log_type_t v58 = v9;
    uint64_t v10 = v3;
    BOOL v59 = v10;
    id v11 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 43);
    v11[2](v11);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 43);

    if (*((void *)v10 + 1))
    {
      id v12 = _Block_copy(*((const void **)v3 + 18));
      id v13 = (void *)*((void *)v10 + 1);
      dispatch_qos_class_t v14 = *((_DWORD *)v10 + 4);
      block[0] = v8;
      block[1] = 3221225472LL;
      block[2] = ___ZL46nw_connection_group_handle_incoming_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_2;
      block[3] = &unk_189BC50A8;
      BOOL v54 = v10;
      os_log_type_t v55 = v9;
      id v56 = v12;
      uint64_t v15 = v13;
      id v16 = v12;
      dispatch_block_t v17 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v14, 0, block);
      dispatch_async(v15, v17);

LABEL_25:
      goto LABEL_26;
    }

    if (nw_parameters_get_logging_disabled(*((void *)v3 + 7))) {
      goto LABEL_25;
    }
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    id v20 = (id)gconnection_groupLogObj;
    int v21 = *((_DWORD *)v10 + 42);
    *(_DWORD *)int buf = 136446722;
    BOOL v63 = "nw_connection_group_handle_incoming_connection";
    __int16 v64 = 1024;
    *(_DWORD *)BOOL v65 = v21;
    *(_WORD *)&v65[4] = 2112;
    *(void *)&v65[6] = v9;
    id v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v61 = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (__nwlog_fault(v22, &v61, &v60))
    {
      if (v61 == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        nw_content_context_t v23 = (os_log_s *)(id)gconnection_groupLogObj;
        os_log_type_t v24 = v61;
        if (os_log_type_enabled(v23, v61))
        {
          int v25 = *((_DWORD *)v10 + 42);
          *(_DWORD *)int buf = 136446722;
          BOOL v63 = "nw_connection_group_handle_incoming_connection";
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = v25;
          *(_WORD *)&v65[4] = 2112;
          *(void *)&v65[6] = v9;
          _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s [G%u] not delivering connection %@ since no queue is set",  buf,  0x1Cu);
        }
      }

      else if (v60)
      {
        id v27 = __nw_create_backtrace_string();
        if (v27)
        {
          BOOL v28 = (char *)v27;
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          __int16 v29 = (os_log_s *)(id)gconnection_groupLogObj;
          os_log_type_t v30 = v61;
          if (os_log_type_enabled(v29, v61))
          {
            int v31 = *((_DWORD *)v10 + 42);
            *(_DWORD *)int buf = 136446978;
            BOOL v63 = "nw_connection_group_handle_incoming_connection";
            __int16 v64 = 1024;
            *(_DWORD *)BOOL v65 = v31;
            *(_WORD *)&v65[4] = 2112;
            *(void *)&v65[6] = v9;
            __int16 v66 = 2082;
            id v67 = v28;
            _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s [G%u] not delivering connection %@ since no queue is set, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(v28);
          if (!v22) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }

        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        nw_content_context_t v23 = (os_log_s *)(id)gconnection_groupLogObj;
        os_log_type_t v34 = v61;
        if (os_log_type_enabled(v23, v61))
        {
          int v35 = *((_DWORD *)v10 + 42);
          *(_DWORD *)int buf = 136446722;
          BOOL v63 = "nw_connection_group_handle_incoming_connection";
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = v35;
          *(_WORD *)&v65[4] = 2112;
          *(void *)&v65[6] = v9;
          _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s [G%u] not delivering connection %@ since no queue is set, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        nw_content_context_t v23 = (os_log_s *)(id)gconnection_groupLogObj;
        os_log_type_t v32 = v61;
        if (os_log_type_enabled(v23, v61))
        {
          int v33 = *((_DWORD *)v10 + 42);
          *(_DWORD *)int buf = 136446722;
          BOOL v63 = "nw_connection_group_handle_incoming_connection";
          __int16 v64 = 1024;
          *(_DWORD *)BOOL v65 = v33;
          *(_WORD *)&v65[4] = 2112;
          *(void *)&v65[6] = v9;
          _os_log_impl( &dword_181A5C000,  v23,  v32,  "%{public}s [G%u] not delivering connection %@ since no queue is set, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

    if (!v22) {
      goto LABEL_25;
    }
LABEL_24:
    free(v22);
    goto LABEL_25;
  }

  __nwlog_obj();
  os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v63 = "nw_connection_group_handle_incoming_connection";
  uint32_t v37 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v61 = OS_LOG_TYPE_ERROR;
  char v60 = 0;
  if (__nwlog_fault(v37, &v61, &v60))
  {
    if (v61 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v41 = v61;
      if (os_log_type_enabled(v38, v61))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v63 = "nw_connection_group_handle_incoming_connection";
        _os_log_impl(&dword_181A5C000, v38, v41, "%{public}s called with null new_connection", buf, 0xCu);
      }

void sub_181DDFC04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL46nw_connection_group_handle_incoming_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke( uint64_t a1)
{
}

uint64_t ___ZL46nw_connection_group_handle_incoming_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_2( void *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(a1[4] + 56LL)) && gLogDatapath)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v3 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v4 = a1[5];
      int v5 = *(_DWORD *)(a1[4] + 168LL);
      int v6 = 136446722;
      int v7 = "nw_connection_group_handle_incoming_connection_block_invoke_2";
      __int16 v8 = 1024;
      int v9 = v5;
      __int16 v10 = 2112;
      uint64_t v11 = v4;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] delivering connection %@",  (uint8_t *)&v6,  0x1Cu);
    }
  }

  return (*(uint64_t (**)(void))(a1[6] + 16LL))();
}

uint64_t ___ZL46nw_connection_group_handle_incoming_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_175( uint64_t a1)
{
  return nw_connection_group_add_connection_locked( *(NWConcrete_nw_connection_group **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40));
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_163( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 112);
  *(void *)(v2 + 112) = 0LL;

  *(_BYTE *)(*(void *)(a1 + 32) + 190LL) |= 0x20u;
}

uint64_t ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_2_164( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = nw_parameters_copy_context(*(void **)(*(void *)(a1 + 32) + 56LL));
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_3_165;
  v8[3] = &unk_189BC9238;
  id v9 = *(id *)(a1 + 32);
  id v6 = v4;
  id v10 = v6;
  nw_queue_context_async(v5, v8);

  return 1LL;
}

void sub_181DDFE90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_167( uint64_t a1)
{
}

void ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_3_165( uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v2 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = *(void *)(a1 + 40);
      int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v5 = 136446722;
      id v6 = "nw_connection_group_set_up_and_start_listener_locked_block_invoke_3";
      __int16 v7 = 1024;
      int v8 = v4;
      __int16 v9 = 2112;
      uint64_t v10 = v3;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] sending queued request %@ ",  (uint8_t *)&v5,  0x1Cu);
    }
  }

  nw_connection_group_send_message( *(nw_connection_group_t *)(*(void *)(a1 + 40) + 8LL),  *(dispatch_data_t *)(*(void *)(a1 + 40) + 32LL),  *(nw_endpoint_t *)(*(void *)(a1 + 40) + 24LL),  *(nw_content_context_t *)(*(void *)(a1 + 40) + 40LL),  *(nw_connection_group_send_completion_t *)(*(void *)(a1 + 40) + 16LL));
}

void ___ZL42nw_connection_group_handle_incoming_packetP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectS3_PU26objcproto15OS_nw_interfaceS1_PU27objcproto16OS_nw_fd_wrapperS1_PU27objcproto16OS_dispatch_dataS1__block_invoke( void *a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1[4] + 136LL));
  uint64_t v3 = *(void *)(a1[5] + 8LL);
  int v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), *(id *)(a1[4] + 8LL));
}

uint64_t ___ZL42nw_connection_group_handle_incoming_packetP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectS3_PU26objcproto15OS_nw_interfaceS1_PU27objcproto16OS_nw_fd_wrapperS1_PU27objcproto16OS_dispatch_dataS1__block_invoke_2( uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v3 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(nw_content_context **)(a1 + 40);
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      identifier = nw_content_context_get_identifier(v4);
      uint64_t v7 = *(void *)(a1 + 48);
      if (v7) {
        size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 48));
      }
      else {
        size_t size = 0LL;
      }
      int v9 = 136447746;
      uint64_t v10 = "nw_connection_group_handle_incoming_packet_block_invoke_2";
      __int16 v11 = 1024;
      int v12 = v5;
      __int16 v13 = 2048;
      dispatch_qos_class_t v14 = v4;
      __int16 v15 = 2080;
      id v16 = identifier;
      __int16 v17 = 2048;
      uint64_t v18 = v7;
      __int16 v19 = 2048;
      size_t v20 = size;
      __int16 v21 = 2080;
      id v22 = "true";
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] calling receive handler with context (%p: %s), content (%p: %zu bytes), complete %s",  (uint8_t *)&v9,  0x44u);
    }
  }

  return (*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL) + 16LL))();
}

uint64_t ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke( uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 32) + 40LL);
  return result;
}

void ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_169( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 88);
  *(void *)(v1 + 8_Block_object_dispose(va, 8) = 0LL;
}

void ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_170( uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(int *)(v2 + 40) <= 0)
  {
    nw_connection_group_set_state_locked((void *)v2, 1, *(void **)(a1 + 40));
  }

  else if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)) && gLogDatapath)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v3 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v5 = 136446466;
      id v6 = "nw_connection_group_handle_listener_state_change_block_invoke";
      __int16 v7 = 1024;
      int v8 = v4;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] listener going to waiting but group already past waiting",  (uint8_t *)&v5,  0x12u);
    }
  }

void ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_171( uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 64);
  if (!v3 || (int v4 = v3, v5 = v4[2], v4, v2 = *(void *)(a1 + 32), v5 != 2))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      __int16 v7 = (os_log_s *)(id)gconnection_groupLogObj;
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      int v10 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v14 = 136446466;
      __int16 v15 = "nw_connection_group_handle_listener_state_change_block_invoke";
      __int16 v16 = 1024;
      int v17 = v10;
      uint64_t v9 = "%{public}s [G%u] group listener ready";
      goto LABEL_14;
    }

void ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_172( uint64_t a1)
{
}

void ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_2( uint64_t a1)
{
}

void ___ZL48nw_connection_group_handle_listener_state_changeP30NWConcrete_nw_connection_group19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke_173( uint64_t a1)
{
}

void nw_connection_group_cancel_connections_locked(NWConcrete_nw_connection_group *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v1 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v3 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        int v4 = *((_DWORD *)v2 + 42);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_connections_locked";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v4;
        _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_INFO, "%{public}s [G%u] cancelling connections", buf, 0x12u);
      }
    }

    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v25 = 0;
    int v5 = (unsigned __int8 *)*((void *)v2 + 13);
    if (!v5) {
      goto LABEL_10;
    }
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = ___ZL45nw_connection_group_cancel_connections_lockedP30NWConcrete_nw_connection_group_block_invoke;
    v16[3] = &unk_189BC7960;
    int v17 = v2;
    uint64_t v18 = buf;
    nw_array_apply(v5, (uint64_t)v16);

    if (!*(_BYTE *)(*(void *)&buf[8] + 24LL))
    {
LABEL_10:
      if (!nw_parameters_get_logging_disabled(*((void *)v2 + 7)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        char v6 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          int v7 = *((_DWORD *)v2 + 42);
          *(_DWORD *)size_t v20 = 136446466;
          __int16 v21 = "nw_connection_group_cancel_connections_locked";
          __int16 v22 = 1024;
          int v23 = v7;
          _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] no connections, cancelling group",  v20,  0x12u);
        }
      }

      nw_connection_group_final_cleanup_locked(v2);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_18;
  }

  __nwlog_obj();
  int v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_connections_locked";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  v20[0] = 16;
  char v19 = 0;
  if (__nwlog_fault(v9, v20, &v19))
  {
    if (v20[0] == 17)
    {
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v20[0];
      if (os_log_type_enabled(v10, (os_log_type_t)v20[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_connections_locked";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v20[0];
      BOOL v14 = os_log_type_enabled(v10, (os_log_type_t)v20[0]);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_connections_locked";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_connections_locked";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v20[0];
      if (os_log_type_enabled(v10, (os_log_type_t)v20[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_connections_locked";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DE097C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL45nw_connection_group_cancel_connections_lockedP30NWConcrete_nw_connection_group_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  int v4 = a3;
  if (!nw_connection_is_cancelled(v4))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      char v6 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        int v8 = 136446722;
        uint64_t v9 = "nw_connection_group_cancel_connections_locked_block_invoke";
        __int16 v10 = 1024;
        int v11 = v7;
        __int16 v12 = 2112;
        os_log_type_t v13 = v4;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] cancelling connection %@",  (uint8_t *)&v8,  0x1Cu);
      }
    }

    nw_connection_cancel(v4);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  return 1LL;
}

void sub_181DE0AF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL44nw_connection_group_prune_connections_lockedP30NWConcrete_nw_connection_group_block_invoke( uint64_t a1, unsigned int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    int v4 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      if (a2 > 5) {
        int v5 = "unknown";
      }
      else {
        int v5 = off_189BB9C00[a2];
      }
      uint64_t v6 = *(void *)(a1 + 40);
      int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v8 = 136446978;
      uint64_t v9 = "nw_connection_group_prune_connections_locked_block_invoke";
      __int16 v10 = 1024;
      int v11 = v7;
      __int16 v12 = 2112;
      uint64_t v13 = v6;
      __int16 v14 = 2080;
      os_log_type_t v15 = v5;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] pruned connection %@ going into state %s",  (uint8_t *)&v8,  0x26u);
    }
  }

nw_connection_group_t nw_connection_group_create( nw_group_descriptor_t group_descriptor, nw_parameters_t parameters)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v3 = group_descriptor;
  int v4 = parameters;
  int v5 = v4;
  if (v3)
  {
    if (v4)
    {
      uint64_t v6 = -[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]( (char *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_connection_group),  v3,  0LL,  v4);
      goto LABEL_4;
    }

    __nwlog_obj();
    __int16 v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_connection_group_create";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_connection_group_create";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null parameters", buf, 0xCu);
        }

void sub_181DE1114(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_connection_group_create_with_parameters(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    uint64_t v2 = -[NWConcrete_nw_group_descriptor initWithType:member:groupID:]( (uint64_t *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_group_descriptor),  4,  0LL,  0LL);
    uint64_t v3 = -[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]( (char *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_connection_group),  v2,  0LL,  v1);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_connection_group_create_with_parameters";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_connection_group_create_with_parameters";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_connection_group_create_with_parameters";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_connection_group_create_with_parameters";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v16 = "nw_connection_group_create_with_parameters";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DE1400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_connection_group_create_with_connection(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (v3)
  {
    if (v4)
    {
      uint64_t v6 = -[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]( (char *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_connection_group),  v3,  v4,  0LL);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v24 = "nw_connection_group_create_with_connection";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v24 = "nw_connection_group_create_with_connection";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null connection", buf, 0xCu);
        }

void sub_181DE18E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_set_queue(nw_connection_group_t group, dispatch_queue_t queue)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = group;
  id v4 = queue;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int v35 = 136446210;
    *(void *)&void v35[4] = "nw_connection_group_set_queue";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v28 = 0;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = buf[0];
      if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)int v35 = 136446210;
        *(void *)&void v35[4] = "nw_connection_group_set_queue";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null group", v35, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = buf[0];
      BOOL v18 = os_log_type_enabled(v12, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int v35 = 136446466;
          *(void *)&void v35[4] = "nw_connection_group_set_queue";
          *(_WORD *)&v35[12] = 2082;
          *(void *)&v35[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null group, dumping backtrace:%{public}s",  v35,  0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v11) {
          goto LABEL_11;
        }
LABEL_46:
        free(v11);
        goto LABEL_11;
      }

      if (v18)
      {
        *(_DWORD *)int v35 = 136446210;
        *(void *)&void v35[4] = "nw_connection_group_set_queue";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null group, no backtrace", v35, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)int v35 = 136446210;
        *(void *)&void v35[4] = "nw_connection_group_set_queue";
        _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null group, backtrace limit exceeded",  v35,  0xCu);
      }
    }

void sub_181DE1F08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Block_object_dispose((const void *)(v21 - 96), 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_set_queue_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v1 + 190) & 1) != 0) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }
  else {
    objc_storeStrong((id *)(v1 + 8), *(id *)(a1 + 40));
  }
}

void nw_connection_group_set_membership_changed_handler(void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int v35 = 136446210;
    *(void *)&void v35[4] = "nw_connection_group_set_membership_changed_handler";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v28 = 0;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = buf[0];
      if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)int v35 = 136446210;
        *(void *)&void v35[4] = "nw_connection_group_set_membership_changed_handler";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null group", v35, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = buf[0];
      BOOL v18 = os_log_type_enabled(v12, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int v35 = 136446466;
          *(void *)&void v35[4] = "nw_connection_group_set_membership_changed_handler";
          *(_WORD *)&v35[12] = 2082;
          *(void *)&v35[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null group, dumping backtrace:%{public}s",  v35,  0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v11) {
          goto LABEL_11;
        }
LABEL_46:
        free(v11);
        goto LABEL_11;
      }

      if (v18)
      {
        *(_DWORD *)int v35 = 136446210;
        *(void *)&void v35[4] = "nw_connection_group_set_membership_changed_handler";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null group, no backtrace", v35, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)int v35 = 136446210;
        *(void *)&void v35[4] = "nw_connection_group_set_membership_changed_handler";
        _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null group, backtrace limit exceeded",  v35,  0xCu);
      }
    }

void sub_181DE2580( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Block_object_dispose((const void *)(v21 - 96), 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_set_membership_changed_handler_block_invoke(uint64_t a1)
{
  if ((*(_BYTE *)(*(void *)(a1 + 32) + 190LL) & 1) != 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = *(void **)(v3 + 80);
    *(void *)(v3 + 80) = v2;
  }

void nw_connection_group_set_state_changed_handler( nw_connection_group_t group, nw_connection_group_state_changed_handler_t state_changed_handler)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v3 = group;
  nw_connection_group_state_changed_handler_t v4 = state_changed_handler;
  if (v3)
  {
    *(void *)char v28 = 0LL;
    *(void *)&v28[8] = v28;
    *(void *)&v28[16] = 0x2020000000LL;
    char v29 = 0;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_set_state_changed_handler_block_invoke;
    aBlock[3] = &unk_189BB7150;
    int v5 = v3;
    BOOL v18 = v5;
    id v19 = v4;
    os_log_type_t v20 = v28;
    uint64_t v6 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 43);
    v6[2](v6);
    os_unfair_lock_unlock(v3 + 43);

    if (*(_BYTE *)(*(void *)&v28[8] + 24LL)
      && !nw_parameters_get_logging_disabled(*(void *)&v5[14]._os_unfair_lock_opaque))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      int v7 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint32_t os_unfair_lock_opaque = v5[42]._os_unfair_lock_opaque;
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v23 = "nw_connection_group_set_state_changed_handler";
        __int16 v24 = 1024;
        uint32_t v25 = os_unfair_lock_opaque;
        __int16 v26 = 2080;
        uint64_t v27 = "set state changed handler";
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] failed to %s because group has already been started",  buf,  0x1Cu);
      }
    }

    _Block_object_dispose(v28, 8);
    goto LABEL_10;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)char v28 = 136446210;
  *(void *)&void v28[4] = "nw_connection_group_set_state_changed_handler";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  char v21 = 0;
  if (__nwlog_fault(v10, buf, &v21))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = buf[0];
      if (os_log_type_enabled(v11, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)char v28 = 136446210;
        *(void *)&void v28[4] = "nw_connection_group_set_state_changed_handler";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null group", v28, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = buf[0];
      BOOL v15 = os_log_type_enabled(v11, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)char v28 = 136446466;
          *(void *)&void v28[4] = "nw_connection_group_set_state_changed_handler";
          *(_WORD *)&v28[12] = 2082;
          *(void *)&v28[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null group, dumping backtrace:%{public}s",  v28,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *(_DWORD *)char v28 = 136446210;
        *(void *)&void v28[4] = "nw_connection_group_set_state_changed_handler";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null group, no backtrace", v28, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = buf[0];
      if (os_log_type_enabled(v11, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)char v28 = 136446210;
        *(void *)&void v28[4] = "nw_connection_group_set_state_changed_handler";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null group, backtrace limit exceeded",  v28,  0xCu);
      }
    }
  }

void sub_181DE2A10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Block_object_dispose((const void *)(v21 - 96), 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_set_state_changed_handler_block_invoke(uint64_t a1)
{
  if ((*(_BYTE *)(*(void *)(a1 + 32) + 190LL) & 1) != 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v3 = *(void *)(a1 + 32);
    nw_connection_group_state_changed_handler_t v4 = *(void **)(v3 + 32);
    *(void *)(v3 + 32) = v2;
  }

uint64_t nw_connection_group_get_connection_limit(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    int v20 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_get_connection_limit_block_invoke;
    aBlock[3] = &unk_189BC9210;
    os_log_type_t v16 = buf;
    BOOL v15 = v1;
    uint64_t v3 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 43);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 43);

    uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_group_get_connection_limit";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_connection_limit";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_get_connection_limit";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_connection_limit";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_connection_limit";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DE2DD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_group_get_connection_limit_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 32) + 180LL);
  return result;
}

void nw_connection_group_set_connection_limit(void *a1, int a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    if (a2)
    {
      aBlock[0] = MEMORY[0x1895F87A8];
      aBlock[1] = 3221225472LL;
      aBlock[2] = __nw_connection_group_set_connection_limit_block_invoke;
      aBlock[3] = &unk_189BC76E8;
      int v17 = a2;
      os_log_type_t v16 = v3;
      int v5 = (void (**)(void))_Block_copy(aBlock);
      os_unfair_lock_lock(v4 + 43);
      v5[2](v5);
      os_unfair_lock_unlock(v4 + 43);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_connection_group_set_connection_limit";
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot set connection limit lower than 1",  buf,  0xCu);
      }
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  int v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v21 = "nw_connection_group_set_connection_limit";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v8, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_connection_group_set_connection_limit";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v21 = "nw_connection_group_set_connection_limit";
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_connection_group_set_connection_limit";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v21 = "nw_connection_group_set_connection_limit";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DE318C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_set_connection_limit_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 40) != *(_DWORD *)(v1 + 180))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v1 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v3 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        int v5 = *(_DWORD *)(a1 + 40);
        int v9 = 136446722;
        os_log_type_t v10 = "nw_connection_group_set_connection_limit_block_invoke";
        __int16 v11 = 1024;
        int v12 = v4;
        __int16 v13 = 1024;
        int v14 = v5;
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] setting connection limit to %d",  (uint8_t *)&v9,  0x18u);
      }
    }

    unsigned int v6 = *(_DWORD *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 32);
    unsigned int v8 = *(_DWORD *)(v7 + 180);
    *(_DWORD *)(v7 + 180) = v6;
    if (v6 < v8) {
      nw_connection_group_prune_connections_locked(*(NWConcrete_nw_connection_group **)(a1 + 32));
    }
  }

uint64_t nw_connection_group_get_new_connection_limit(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    int v20 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_get_new_connection_limit_block_invoke;
    aBlock[3] = &unk_189BC9210;
    os_log_type_t v16 = buf;
    uint64_t v15 = v1;
    uint64_t v3 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 43);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 43);

    uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_group_get_new_connection_limit";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_new_connection_limit";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_get_new_connection_limit";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_new_connection_limit";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_new_connection_limit";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DE3610( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_group_get_new_connection_limit_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 32) + 184LL);
  return result;
}

void nw_connection_group_set_new_connection_limit(void *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_set_new_connection_limit_block_invoke;
    aBlock[3] = &unk_189BC76E8;
    int v16 = a2;
    uint64_t v15 = v3;
    int v5 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v4 + 43);
    v5[2](v5);
    os_unfair_lock_unlock(v4 + 43);

    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v20 = "nw_connection_group_set_new_connection_limit";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v20 = "nw_connection_group_set_new_connection_limit";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          int v20 = "nw_connection_group_set_new_connection_limit";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        int v20 = "nw_connection_group_set_new_connection_limit";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v20 = "nw_connection_group_set_new_connection_limit";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DE3950( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_set_new_connection_limit_block_invoke(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v1 = *(_DWORD *)(a1 + 40);
  if (v1)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v1 != *(_DWORD *)(v2 + 184))
    {
      *(_DWORD *)(v2 + 184) = v1;
      uint64_t v3 = *(void *)(a1 + 32);
      if ((*(_BYTE *)(v3 + 190) & 1) != 0)
      {
        uint64_t v4 = *(nw_listener **)(v3 + 88);
        if (v4)
        {
          nw_listener_set_new_connection_limit(v4, *(_DWORD *)(a1 + 40));
          return;
        }

        __nwlog_obj();
        int v5 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_set_new_connection_limit_block_invoke";
        unsigned int v6 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v13 = 0;
        BOOL v12 = (char *)v6;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v16 = "nw_connection_group_set_new_connection_limit_block_invoke";
            os_log_type_t v9 = "%{public}s called with null group->listener";
LABEL_20:
            _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
          }
        }

        else if (v13)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v8 = type;
          BOOL v11 = os_log_type_enabled(v7, type);
          if (backtrace_string)
          {
            if (v11)
            {
              *(_DWORD *)int buf = 136446466;
              int v16 = "nw_connection_group_set_new_connection_limit_block_invoke";
              __int16 v17 = 2082;
              char v18 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null group->listener, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_22;
          }

          if (v11)
          {
            *(_DWORD *)int buf = 136446210;
            int v16 = "nw_connection_group_set_new_connection_limit_block_invoke";
            os_log_type_t v9 = "%{public}s called with null group->listener, no backtrace";
            goto LABEL_20;
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)int buf = 136446210;
            int v16 = "nw_connection_group_set_new_connection_limit_block_invoke";
            os_log_type_t v9 = "%{public}s called with null group->listener, backtrace limit exceeded";
            goto LABEL_20;
          }
        }

LABEL_22:
        if (v12) {
          free(v12);
        }
      }
    }
  }

void nw_connection_group_set_new_connection_handler( nw_connection_group_t group, nw_connection_group_new_connection_handler_t new_connection_handler)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v3 = group;
  nw_connection_group_new_connection_handler_t v4 = new_connection_handler;
  if (v3)
  {
    *(void *)uint32_t v32 = 0LL;
    *(void *)&v32[8] = v32;
    *(void *)&v32[16] = 0x2020000000LL;
    char v33 = 0;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_set_new_connection_handler_block_invoke;
    aBlock[3] = &unk_189BB7150;
    int v5 = v3;
    __int16 v22 = v5;
    id v6 = v4;
    id v23 = v6;
    uint64_t v24 = v32;
    uint64_t v7 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 43);
    v7[2](v7);
    os_unfair_lock_unlock(v3 + 43);

    LODWORD(v7) = *(unsigned __int8 *)(*(void *)&v32[8] + 24LL);
    BOOL logging_disabled = nw_parameters_get_logging_disabled(*(void *)&v5[14]._os_unfair_lock_opaque);
    if ((_DWORD)v7)
    {
      if (!logging_disabled)
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        os_log_type_t v9 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          uint32_t os_unfair_lock_opaque = v5[42]._os_unfair_lock_opaque;
          *(_DWORD *)int buf = 136446466;
          uint64_t v27 = "nw_connection_group_set_new_connection_handler";
          __int16 v28 = 1024;
          uint32_t v29 = os_unfair_lock_opaque;
          _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] failed to set new connection handler because group has already been started",  buf,  0x12u);
        }

void sub_181DE40A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Block_object_dispose((const void *)(v21 - 96), 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_set_new_connection_handler_block_invoke(uint64_t a1)
{
  if ((*(_BYTE *)(*(void *)(a1 + 32) + 190LL) & 1) != 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v3 = *(void *)(a1 + 32);
    nw_connection_group_new_connection_handler_t v4 = *(void **)(v3 + 144);
    *(void *)(v3 + 144) = v2;
  }

void nw_connection_group_set_receive_handler( nw_connection_group_t group, uint32_t maximum_message_size, BOOL reject_oversized_messages, nw_connection_group_receive_handler_t receive_handler)
{
  BOOL v5 = reject_oversized_messages;
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v7 = group;
  nw_connection_group_receive_handler_t v8 = receive_handler;
  if (v7)
  {
    *(void *)os_log_type_t type = 0LL;
    char v33 = type;
    uint64_t v34 = 0x2020000000LL;
    char v35 = 0;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_set_receive_handler_block_invoke;
    aBlock[3] = &unk_189BB7178;
    os_log_type_t v9 = v7;
    uint64_t v27 = v9;
    uint32_t v30 = maximum_message_size;
    BOOL v31 = v5;
    id v10 = v8;
    id v28 = v10;
    uint32_t v29 = type;
    uint32_t v11 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v7 + 43);
    v11[2](v11);
    os_unfair_lock_unlock(v7 + 43);

    LODWORD(v11) = *((unsigned __int8 *)v33 + 24);
    BOOL logging_disabled = nw_parameters_get_logging_disabled(*(void *)&v9[14]._os_unfair_lock_opaque);
    if ((_DWORD)v11)
    {
      if (!logging_disabled)
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        char v13 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          uint32_t os_unfair_lock_opaque = v9[42]._os_unfair_lock_opaque;
          *(_DWORD *)int buf = 136446466;
          int v38 = "nw_connection_group_set_receive_handler";
          __int16 v39 = 1024;
          *(_DWORD *)os_log_type_t v40 = os_unfair_lock_opaque;
          _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] failed to set receive handler because group has already been started",  buf,  0x12u);
        }

void sub_181DE4610( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_set_receive_handler_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 190) & 1) != 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  else
  {
    *(_DWORD *)(v2 + 176) = *(_DWORD *)(a1 + 56);
    *(_BYTE *)(*(void *)(a1 + 32) + 190LL) = *(_BYTE *)(*(void *)(a1 + 32) + 190LL) & 0xFD | (2 * *(_BYTE *)(a1 + 60));
    uint64_t v3 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v4 = *(void *)(a1 + 32);
    BOOL v5 = *(void **)(v4 + 136);
    *(void *)(v4 + 136) = v3;
  }

void nw_connection_group_reply( nw_connection_group_t group, nw_content_context_t inbound_message, nw_content_context_t outbound_message, dispatch_data_t content)
{
  uint64_t v102 = *MEMORY[0x1895F89C0];
  nw_connection_group_t v7 = group;
  nw_connection_group_receive_handler_t v8 = inbound_message;
  os_log_type_t v9 = outbound_message;
  os_log_type_t v73 = v9;
  os_log_type_t v74 = content;
  if (!v7)
  {
    __nwlog_obj();
    BOOL v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
    uint64_t v45 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v90[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = type[0];
      if (os_log_type_enabled(v46, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
        _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (LOBYTE(v90[0]))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v55 = type[0];
      BOOL v56 = os_log_type_enabled(v46, type[0]);
      if (backtrace_string)
      {
        if (v56)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v46,  v55,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_133:
        if (!v45) {
          goto LABEL_67;
        }
LABEL_134:
        free(v45);
        goto LABEL_67;
      }

      if (v56)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
        _os_log_impl(&dword_181A5C000, v46, v55, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v64 = type[0];
      if (os_log_type_enabled(v46, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
        _os_log_impl( &dword_181A5C000,  v46,  v64,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DE5710( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, id a39)
{
  _Block_object_dispose((const void *)(v44 - 240), 8);
  _Block_object_dispose(&a34, 8);

  _Unwind_Resume(a1);
}

void __nw_connection_group_reply_block_invoke(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  uint64_t v3 = *(id *)(a1 + 32);
  id v4 = v2;
  BOOL v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)char v35 = 136446210;
    *(void *)&void v35[4] = "nw_connection_group_has_connection_locked";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)char v35 = 136446210;
        *(void *)&void v35[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null group", v35, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)char v35 = 136446466;
          *(void *)&void v35[4] = "nw_connection_group_has_connection_locked";
          *(_WORD *)&v35[12] = 2082;
          *(void *)&v35[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null group, dumping backtrace:%{public}s",  v35,  0x16u);
        }

        free(backtrace_string);
LABEL_53:
        if (!v18)
        {
LABEL_55:

          goto LABEL_11;
        }

void __nw_connection_group_reply_block_invoke_20(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a2;
  BOOL logging_disabled = nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL));
  if (v3)
  {
    if (!logging_disabled)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      BOOL v5 = (os_log_s *)(id)gconnection_groupLogObj;
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
      uint64_t v6 = *(void *)(a1 + 40);
      int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      identifier = nw_content_context_get_identifier(*(nw_content_context_t *)(a1 + 48));
      int v16 = 136447234;
      uint64_t v17 = "nw_connection_group_reply_block_invoke";
      __int16 v18 = 1024;
      int v19 = v7;
      __int16 v20 = 2048;
      uint64_t v21 = v6;
      __int16 v22 = 2080;
      os_log_type_t v23 = identifier;
      __int16 v24 = 2112;
      BOOL v25 = v3;
      os_log_type_t v9 = "%{public}s [G%u] context %p reply %s failed with error: %@";
      int v10 = v5;
      os_log_type_t v11 = OS_LOG_TYPE_ERROR;
LABEL_14:
      _os_log_impl(&dword_181A5C000, v10, v11, v9, (uint8_t *)&v16, 0x30u);
LABEL_15:
    }
  }

  else if (!logging_disabled)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    BOOL v5 = (os_log_s *)(id)gconnection_groupLogObj;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_15;
    }
    uint64_t v12 = *(void *)(a1 + 40);
    int v13 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
    uint64_t v14 = nw_content_context_get_identifier(*(nw_content_context_t *)(a1 + 48));
    size_t size = *(dispatch_data_s **)(a1 + 56);
    if (size) {
      size_t size = (dispatch_data_s *)dispatch_data_get_size(size);
    }
    int v16 = 136447234;
    uint64_t v17 = "nw_connection_group_reply_block_invoke";
    __int16 v18 = 1024;
    int v19 = v13;
    __int16 v20 = 2048;
    uint64_t v21 = v12;
    __int16 v22 = 2080;
    os_log_type_t v23 = v14;
    __int16 v24 = 2048;
    BOOL v25 = size;
    os_log_type_t v9 = "%{public}s [G%u] sent reply to context %p: (context: %s, content: %zu bytes)";
    int v10 = v5;
    os_log_type_t v11 = OS_LOG_TYPE_DEBUG;
    goto LABEL_14;
  }
}

nw_endpoint_t nw_connection_group_copy_remote_endpoint_for_message( nw_connection_group_t group, nw_content_context_t context)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  uint64_t v3 = group;
  id v4 = context;
  BOOL v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    int v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
    __int16 v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v44, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_33;
    }

    if (!v53)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v51 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl( &dword_181A5C000,  v23,  v51,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v47 = type;
    BOOL v48 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v47, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }

      goto LABEL_33;
    }

    if (v48)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
      __int16 v57 = 2082;
      os_log_type_t v58 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v47,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_26;
  }

  if (!v4)
  {
    __nwlog_obj();
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
    __int16 v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v46, "%{public}s called with null context", buf, 0xCu);
      }

      goto LABEL_33;
    }

    if (!v53)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl( &dword_181A5C000,  v23,  v52,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v49 = type;
    BOOL v50 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v49, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }

      goto LABEL_33;
    }

    if (v50)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v56 = "nw_connection_group_copy_remote_endpoint_for_message";
      __int16 v57 = 2082;
      os_log_type_t v58 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v49,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181DE6BFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_send_message( nw_connection_group_t group, dispatch_data_t content, nw_endpoint_t endpoint, nw_content_context_t context, nw_connection_group_send_completion_t completion)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  os_log_type_t v9 = group;
  id v10 = content;
  os_log_type_t v11 = endpoint;
  uint64_t v12 = context;
  nw_connection_group_send_completion_t v13 = completion;
  uint64_t v14 = v13;
  unsigned int v36 = v10;
  uint64_t v37 = v11;
  if (!v9)
  {
    __nwlog_obj();
    id v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
    __int16 v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v46;
      if (os_log_type_enabled(v23, v46))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_33;
    }

    if (!v45)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = v46;
      if (os_log_type_enabled(v23, v46))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
        _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v29 = v46;
    BOOL v30 = os_log_type_enabled(v28, v46);
    if (backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_40:
      if (!v22) {
        goto LABEL_6;
      }
LABEL_41:
      free(v22);
      goto LABEL_6;
    }

    if (v30)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
      _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null group, no backtrace", buf, 0xCu);
    }

void sub_181DE71F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, void *a22, void *a23, void *a24)
{
  _Block_object_dispose((const void *)(v29 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL42nw_connection_group_send_message_on_socketP30NWConcrete_nw_connection_groupPU27objcproto16OS_nw_fd_wrapper8NSObjectPU32objcproto21OS_nw_content_contextS1_S5_PU27objcproto16OS_dispatch_dataS1__block_invoke( uint64_t a1, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  return 1LL;
}

void ___ZL42nw_connection_group_send_message_on_socketP30NWConcrete_nw_connection_groupPU27objcproto16OS_nw_fd_wrapper8NSObjectPU32objcproto21OS_nw_content_contextS1_S5_PU27objcproto16OS_dispatch_dataS1__block_invoke_145( uint64_t a1)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  size_t v2 = *(void *)(a1 + 80);
  if (!v2)
  {
    __nwlog_obj();
    BOOL v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446210;
    *(void *)&void applier[4] = "strict_calloc";
    os_log_type_t v51 = (void *)_os_log_send_and_compose_impl();

    free(v51);
  }

  uint64_t v3 = calloc(1uLL, v2);
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446722;
    *(void *)&void applier[4] = "strict_calloc";
    *(_WORD *)&applier[12] = 2048;
    *(void *)&applier[14] = 1LL;
    *(_WORD *)&applier[22] = 2048;
    *(void *)&_BYTE applier[24] = v2;
    char v53 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v53))
    {
      free(v53);
      BOOL v5 = (uint64_t *)(a1 + 32);
      uint64_t v7 = nw_dispatch_data_copyout(*(dispatch_data_s **)(a1 + 32), 0LL, *(void *)(a1 + 80));
      goto LABEL_7;
    }

void __nw_connection_group_send_message_block_invoke(uint64_t a1)
{
  *(void *)&v41[13] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 96) || (*(_BYTE *)(v2 + 190) & 0x20) != 0) {
    return;
  }
  id v4 = *(void **)(a1 + 40);
  uint64_t v3 = *(void **)(a1 + 48);
  uint64_t v6 = *(void **)(a1 + 56);
  BOOL v5 = *(void **)(a1 + 64);
  id v35 = (id)v2;
  id v7 = v4;
  id v8 = v3;
  id v9 = v6;
  id v10 = v5;
  ssize_t v11 = v10;
  if (!v9)
  {
    __nwlog_obj();
    int v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    int v39 = "nw_connection_group_create_request";
    int v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v20, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v39 = "nw_connection_group_create_request";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null context", buf, 0xCu);
        }

        goto LABEL_43;
      }

      if (!v36)
      {
        __nwlog_obj();
        id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v39 = "nw_connection_group_create_request";
          _os_log_impl( &dword_181A5C000,  v21,  v33,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_43;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v28, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)int buf = 136446466;
          int v39 = "nw_connection_group_create_request";
          __int16 v40 = 2082;
          *(void *)unsigned int v41 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_37;
      }

      if (v30)
      {
        *(_DWORD *)int buf = 136446210;
        int v39 = "nw_connection_group_create_request";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }

void sub_181DE837C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_send_message_internal(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t v156 = *MEMORY[0x1895F89C0];
  id v9 = a1;
  content = a2;
  id v10 = a3;
  context = a4;
  id v11 = a5;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke;
  aBlock[3] = &unk_189BB72D8;
  ssize_t v12 = (char *)v9;
  id v129 = v12;
  id v119 = v11;
  id v130 = v119;
  os_log_type_t v116 = (void (**)(void *, uint64_t))_Block_copy(aBlock);
  if (!context)
  {
    if (nw_parameters_get_logging_disabled(*((void *)v12 + 7)))
    {
LABEL_158:
      uint64_t v73 = 22LL;
LABEL_159:
      v116[2](v116, v73);
      goto LABEL_75;
    }

    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    id v65 = (id)gconnection_groupLogObj;
    int v66 = *((_DWORD *)v12 + 42);
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v66;
    id v67 = (char *)_os_log_send_and_compose_impl();

    v154[0] = 16;
    v152[0] = 0;
    if (__nwlog_fault(v67, v154, v152))
    {
      if (v154[0] == 17)
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        int v68 = (os_log_s *)(id)gconnection_groupLogObj;
        os_log_type_t v69 = v154[0];
        if (os_log_type_enabled(v68, (os_log_type_t)v154[0]))
        {
          int v70 = *((_DWORD *)v12 + 42);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v70;
          _os_log_impl(&dword_181A5C000, v68, v69, "%{public}s [G%u] context must not be NULL", buf, 0x12u);
        }
      }

      else if (v152[0])
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          os_log_type_t v81 = (char *)backtrace_string;
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          id v82 = (os_log_s *)(id)gconnection_groupLogObj;
          os_log_type_t v83 = v154[0];
          if (os_log_type_enabled(v82, (os_log_type_t)v154[0]))
          {
            int v84 = *((_DWORD *)v12 + 42);
            *(_DWORD *)int buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v84;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v81;
            _os_log_impl( &dword_181A5C000,  v82,  v83,  "%{public}s [G%u] context must not be NULL, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v81);
          goto LABEL_156;
        }

        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        int v68 = (os_log_s *)(id)gconnection_groupLogObj;
        os_log_type_t v102 = v154[0];
        if (os_log_type_enabled(v68, (os_log_type_t)v154[0]))
        {
          int v103 = *((_DWORD *)v12 + 42);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v103;
          _os_log_impl( &dword_181A5C000,  v68,  v102,  "%{public}s [G%u] context must not be NULL, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        int v68 = (os_log_s *)(id)gconnection_groupLogObj;
        os_log_type_t v92 = v154[0];
        if (os_log_type_enabled(v68, (os_log_type_t)v154[0]))
        {
          int v93 = *((_DWORD *)v12 + 42);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v93;
          _os_log_impl( &dword_181A5C000,  v68,  v92,  "%{public}s [G%u] context must not be NULL, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

void sub_181DE9B40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, void *a23, void *a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *a43, void *a44)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke( uint64_t a1, int a2)
{
  id v4 = *(os_unfair_lock_s **)(a1 + 32);
  BOOL v5 = v4 + 43;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_2;
  aBlock[3] = &unk_189BC9440;
  id v8 = v4;
  id v9 = *(id *)(a1 + 40);
  int v10 = a2;
  uint64_t v6 = (void (**)(void))_Block_copy(aBlock);
  os_unfair_lock_lock(v5);
  v6[2](v6);
  os_unfair_lock_unlock(v5);
}

void sub_181DE9DC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_group_get_port(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    __int16 v20 = 0;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_get_port_block_invoke;
    aBlock[3] = &unk_189BC9210;
    uint64_t v15 = v1;
    BOOL v16 = buf;
    uint64_t v3 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 43);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 43);

    uint64_t v4 = *(unsigned __int16 *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_group_get_port";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_port";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_get_port";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_port";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_get_port";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DEA108( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke( uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 190) < 0)
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v6 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        *(_DWORD *)int buf = 136446466;
        BOOL v14 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
        __int16 v15 = 1024;
        int v16 = v7;
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, "%{public}s [G%u] has cancelled", buf, 0x12u);
      }
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v3 = *(unsigned __int8 **)(v2 + 104);
    if (v3)
    {
      v8[0] = MEMORY[0x1895F87A8];
      v8[1] = 3221225472LL;
      v8[2] = ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke_153;
      v8[3] = &unk_189BB9EC8;
      id v9 = (id)v2;
      id v10 = *(id *)(a1 + 40);
      id v4 = *(id *)(a1 + 48);
      uint64_t v5 = *(void *)(a1 + 64);
      id v11 = v4;
      uint64_t v12 = v5;
      nw_array_apply(v3, (uint64_t)v8);
    }
  }

void ___ZL65nw_connection_group_create_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS3_PU33objcproto22OS_nw_protocol_optionsS3_b_block_invoke( uint64_t a1)
{
}

uint64_t ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke_154( uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(_BYTE *)(*(void *)(result + 32) + 190LL) & 1;
  return result;
}

void ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_148( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 8);
  if (v2)
  {
    dispatch_qos_class_t v3 = *(_DWORD *)(v1 + 16);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_2_149;
    block[3] = &unk_189BC8740;
    id v7 = *(id *)(a1 + 40);
    id v4 = v2;
    dispatch_block_t v5 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v3, 0, block);
    dispatch_async(v4, v5);
  }

void ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_150( uint64_t a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v30 = 0LL;
  os_log_type_t v31 = &v30;
  uint64_t v32 = 0x3032000000LL;
  os_log_type_t v33 = __Block_byref_object_copy__8579;
  os_log_type_t v34 = __Block_byref_object_dispose__8580;
  id v35 = 0LL;
  uint64_t v4 = MEMORY[0x1895F87A8];
  dispatch_block_t v5 = *(os_unfair_lock_s **)(a1 + 32);
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_2_151;
  aBlock[3] = &unk_189BC9210;
  uint64_t v29 = &v30;
  id v28 = v5;
  uint64_t v6 = (void (**)(void))_Block_copy(aBlock);
  v5 += 43;
  os_unfair_lock_lock(v5);
  v6[2](v6);
  os_unfair_lock_unlock(v5);

  if (v31[5])
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      __int16 v15 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v16 = *(void *)(a1 + 40);
        int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        *(_DWORD *)int buf = 136446978;
        uint64_t v37 = "nw_connection_group_send_message_internal_block_invoke";
        __int16 v38 = 1024;
        *(_DWORD *)int v39 = v17;
        *(_WORD *)&v39[4] = 2112;
        *(void *)&v39[6] = v16;
        __int16 v40 = 2112;
        id v41 = v3;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Connection Group send to complete for connection (%@) with error: %@",  buf,  0x26u);
      }
    }

    id v7 = (void *)v31[5];
    dispatch_qos_class_t v8 = *(_DWORD *)(*(void *)(a1 + 32) + 16LL);
    block[0] = v4;
    block[1] = 3221225472LL;
    block[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_152;
    block[3] = &unk_189BC91E8;
    id v24 = *(id *)(a1 + 48);
    id v23 = v3;
    id v9 = v7;
    dispatch_block_t v10 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v8, 0, block);
    dispatch_async(v9, v10);

    goto LABEL_5;
  }

  __nwlog_obj();
  id v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v37 = "nw_connection_group_send_message_internal_block_invoke";
  uint64_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v12, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_connection_group_send_message_internal_block_invoke";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null client_queue", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v37 = "nw_connection_group_send_message_internal_block_invoke";
          __int16 v38 = 2082;
          *(void *)int v39 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null client_queue, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_connection_group_send_message_internal_block_invoke";
        _os_log_impl(&dword_181A5C000, v13, v19, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v37 = "nw_connection_group_send_message_internal_block_invoke";
        _os_log_impl( &dword_181A5C000,  v13,  v21,  "%{public}s called with null client_queue, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DEA878( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, id a32)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_2_151( uint64_t a1)
{
}

uint64_t ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_152( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_2_149( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_181DEA928( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke_153( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  dispatch_block_t v5 = a3;
  nw_endpoint_t v6 = nw_connection_copy_endpoint(v5);
  nw_parameters_t v7 = nw_connection_copy_parameters(v5);
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)) && gLogDatapath)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    os_log_type_t v21 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      int v22 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      *(_DWORD *)int buf = 136446722;
      id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
      __int16 v36 = 1024;
      *(_DWORD *)uint64_t v37 = v22;
      *(_WORD *)&v37[4] = 2112;
      *(void *)&void v37[6] = v5;
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [G%u] Inspecting connection %@", buf, 0x1Cu);
    }
  }

  if (!v7)
  {
    __nwlog_obj();
    int v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null connection_parameters", buf, 0xCu);
      }

      goto LABEL_57;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null connection_parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_57;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v26 = type;
    BOOL v27 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)int buf = 136446210;
        id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
        _os_log_impl( &dword_181A5C000,  v19,  v26,  "%{public}s called with null connection_parameters, no backtrace",  buf,  0xCu);
      }

      goto LABEL_57;
    }

    if (v27)
    {
      *(_DWORD *)int buf = 136446466;
      id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
      __int16 v36 = 2082;
      *(void *)uint64_t v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v26,  "%{public}s called with null connection_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_45;
  }

  BOOL v8 = nw_parameters_are_compatible(*(void **)(a1 + 40), -1LL, v7, 0LL, 0);
  if (!v6)
  {
    __nwlog_obj();
    id v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v35 = "nw_connection_group_copy_connection_for_endpoint_and_parameters_block_invoke";
        _os_log_impl(&dword_181A5C000, v19, v24, "%{public}s called with null connection_remote_endpoint", buf, 0xCu);
      }

void sub_181DEB084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_get_port_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(nw_listener **)(v2 + 96);
  if (v3)
  {
    if ((*(_BYTE *)(v2 + 190) & 0x20) != 0)
    {
      *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = nw_listener_get_port(v3);
      if (nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL))) {
        return;
      }
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v4 = (os_log_s *)(id)gconnection_groupLogObj;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_20;
      }
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v6 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      int v12 = 136446722;
      int v13 = "nw_connection_group_get_port_block_invoke";
      __int16 v14 = 1024;
      int v15 = v5;
      __int16 v16 = 1024;
      int v17 = v6;
      nw_parameters_t v7 = "%{public}s [G%u] using unicast_listener port=%d";
      goto LABEL_19;
    }

    goto LABEL_9;
  }

  if ((*(_BYTE *)(v2 + 190) & 0x10) == 0)
  {
LABEL_9:
    *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = *(_WORD *)(v2 + 188);
    if (nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL))) {
      return;
    }
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v4 = (os_log_s *)(id)gconnection_groupLogObj;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_20;
    }
    int v8 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
    int v9 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    int v12 = 136446722;
    int v13 = "nw_connection_group_get_port_block_invoke";
    __int16 v14 = 1024;
    int v15 = v8;
    __int16 v16 = 1024;
    int v17 = v9;
    nw_parameters_t v7 = "%{public}s [G%u] using initial port=%d";
    goto LABEL_19;
  }

  *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = nw_listener_get_port(*(nw_listener_t *)(v2 + 88));
  if (nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL))) {
    return;
  }
  if (__nwlog_connection_group_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
  }
  uint64_t v4 = (os_log_s *)(id)gconnection_groupLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    int v10 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
    int v11 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    int v12 = 136446722;
    int v13 = "nw_connection_group_get_port_block_invoke";
    __int16 v14 = 1024;
    int v15 = v10;
    __int16 v16 = 1024;
    int v17 = v11;
    nw_parameters_t v7 = "%{public}s [G%u] using listener port=%d";
LABEL_19:
    _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEBUG, v7, (uint8_t *)&v12, 0x18u);
  }

void ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_2( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 8);
  if (v2)
  {
    dispatch_qos_class_t v4 = *(_DWORD *)(v1 + 16);
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_3;
    v7[3] = &unk_189BC87B8;
    id v8 = *(id *)(a1 + 40);
    int v9 = *(_DWORD *)(a1 + 48);
    int v5 = v2;
    dispatch_block_t v6 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v4, 0, v7);
    dispatch_async(v5, v6);
  }

void ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_3( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  posix_error = nw_error_create_posix_error(*(_DWORD *)(a1 + 40));
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_181DEB444( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t nw_connection_group_get_type(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    dispatch_block_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v18 = "nw_connection_group_get_type";
    nw_parameters_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v18 = "nw_connection_group_get_type";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null group", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v18 = "nw_connection_group_get_type";
            __int16 v19 = 2082;
            os_log_type_t v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v12)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v18 = "nw_connection_group_get_type";
          _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null group, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v18 = "nw_connection_group_get_type";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

id nw_connection_group_copy_connection_for_message(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = (void *)nw_content_context_copy_connection(v4);
  if (v5)
  {
    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    _BYTE buf[24] = 0;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL47nw_connection_group_copy_connection_for_messageP30NWConcrete_nw_connection_groupPU32objcproto21OS_nw_content_context8NSObject_block_invoke;
    aBlock[3] = &unk_189BBEEE8;
    uint64_t v18 = buf;
    dispatch_block_t v6 = (uint64_t *)v3;
    __int16 v16 = v6;
    id v7 = v5;
    id v17 = v7;
    id v8 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 43);
    v8[2](v8);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 43);

    if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
    {
      id v9 = v7;
    }

    else
    {
      if (!nw_parameters_get_logging_disabled(v6[7]))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        BOOL v12 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          int v13 = *((_DWORD *)v6 + 42);
          *(_DWORD *)__int16 v19 = 136446722;
          os_log_type_t v20 = "nw_connection_group_copy_connection_for_message";
          __int16 v21 = 1024;
          int v22 = v13;
          __int16 v23 = 2112;
          id v24 = v4;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] Context %@ is not a valid inbound message received from this group",  v19,  0x1Cu);
        }
      }

      id v9 = 0LL;
    }

    _Block_object_dispose(buf, 8);
  }

  else
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v3 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      int v10 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        int v11 = *((_DWORD *)v3 + 42);
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_message";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v4;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] Context %@ is not a valid inbound message",  buf,  0x1Cu);
      }
    }

    id v9 = 0LL;
  }

  return v9;
}

void sub_181DEB9BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL47nw_connection_group_copy_connection_for_messageP30NWConcrete_nw_connection_groupPU32objcproto21OS_nw_content_context8NSObject_block_invoke( uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(a1 + 40);
  id v3 = *(id *)(a1 + 32);
  id v4 = v2;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      *(void *)os_log_type_t type = 0LL;
      __int16 v21 = type;
      uint64_t v22 = 0x2020000000LL;
      char v23 = 0;
      dispatch_block_t v6 = (unsigned __int8 *)v3[13];
      if (v6)
      {
        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&sockaddr buf[8] = 3221225472LL;
        *(void *)&buf[16] = ___ZL41nw_connection_group_has_connection_lockedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke;
        uint64_t v26 = &unk_189BC7960;
        id v27 = v4;
        os_log_type_t v28 = type;
        nw_array_apply(v6, (uint64_t)buf);

        LOBYTE(v6) = *((_BYTE *)v21 + 24) != 0;
      }

      _Block_object_dispose(type, 8);
      goto LABEL_6;
    }

    __nwlog_obj();
    int v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
    id v8 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v8, type, &v24))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
          _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection", buf, 0xCu);
        }

BOOL ___ZL41nw_connection_group_has_connection_lockedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3 == a3) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  return v3 != a3;
}

nw_protocol_metadata_t nw_connection_group_copy_protocol_metadata( nw_connection_group_t group, nw_protocol_definition_t definition)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v3 = group;
  id v4 = definition;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      *(void *)int buf = 0LL;
      *(void *)&sockaddr buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000LL;
      uint64_t v29 = __Block_byref_object_copy__8579;
      os_log_type_t v30 = __Block_byref_object_dispose__8580;
      id v31 = 0LL;
      aBlock[0] = MEMORY[0x1895F87A8];
      aBlock[1] = 3221225472LL;
      aBlock[2] = __nw_connection_group_copy_protocol_metadata_block_invoke;
      aBlock[3] = &unk_189BBEEE8;
      char v23 = v3;
      char v25 = buf;
      char v24 = v5;
      dispatch_block_t v6 = (void (**)(void))_Block_copy(aBlock);
      os_unfair_lock_lock(v3 + 43);
      v6[2](v6);
      os_unfair_lock_unlock(v3 + 43);

      id v7 = *(id *)(*(void *)&buf[8] + 40LL);
      _Block_object_dispose(buf, 8);

      goto LABEL_4;
    }

    __nwlog_obj();
    int v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_copy_protocol_metadata";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v10, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_copy_protocol_metadata";
          _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null definition", buf, 0xCu);
        }

void sub_181DEC4E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, id a26)
{
  _Block_object_dispose(&a21, 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_copy_protocol_metadata_block_invoke(uint64_t a1)
{
  id v1 = *(unsigned __int8 **)(*(void *)(a1 + 32) + 104LL);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_connection_group_copy_protocol_metadata_block_invoke_2;
  v4[3] = &unk_189BC7960;
  __int128 v3 = *(_OWORD *)(a1 + 40);
  id v2 = (id)v3;
  *(_OWORD *)uint64_t v5 = v3;
  nw_array_apply(v1, (uint64_t)v4);
}

BOOL __nw_connection_group_copy_protocol_metadata_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = nw_connection_copy_protocol_metadata_internal(v4, *(void **)(a1 + 32), 1);
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  BOOL v8 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) == 0LL;
  return v8;
}

void sub_181DEC604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_connection_t nw_connection_group_extract_connection( nw_connection_group_t group, nw_endpoint_t endpoint, nw_protocol_options_t protocol_options)
{
  uint64_t v145 = *MEMORY[0x1895F89C0];
  nw_connection_group_t v5 = group;
  uint64_t v6 = endpoint;
  id v7 = protocol_options;
  BOOL v8 = v7;
  os_log_type_t v112 = v6;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)aBlock = 136446210;
    *(void *)&void aBlock[4] = "nw_connection_group_extract_connection";
    uint64_t v48 = (char *)_os_log_send_and_compose_impl();

    iterate_block[0] = 16;
    LOBYTE(v124) = 0;
    if (__nwlog_fault(v48, iterate_block, &v124))
    {
      if (iterate_block[0] == 17)
      {
        __nwlog_obj();
        uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = iterate_block[0];
        if (os_log_type_enabled(v49, (os_log_type_t)iterate_block[0]))
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&void aBlock[4] = "nw_connection_group_extract_connection";
          _os_log_impl(&dword_181A5C000, v49, v50, "%{public}s called with null group", aBlock, 0xCu);
        }
      }

      else if ((_BYTE)v124)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v60 = iterate_block[0];
        BOOL v61 = os_log_type_enabled(v49, (os_log_type_t)iterate_block[0]);
        if (backtrace_string)
        {
          if (v61)
          {
            *(_DWORD *)aBlock = 136446466;
            *(void *)&void aBlock[4] = "nw_connection_group_extract_connection";
            *(_WORD *)&aBlock[12] = 2082;
            *(void *)&aBlock[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v49,  v60,  "%{public}s called with null group, dumping backtrace:%{public}s",  aBlock,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_110;
        }

        if (v61)
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&void aBlock[4] = "nw_connection_group_extract_connection";
          _os_log_impl(&dword_181A5C000, v49, v60, "%{public}s called with null group, no backtrace", aBlock, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v72 = iterate_block[0];
        if (os_log_type_enabled(v49, (os_log_type_t)iterate_block[0]))
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&void aBlock[4] = "nw_connection_group_extract_connection";
          _os_log_impl( &dword_181A5C000,  v49,  v72,  "%{public}s called with null group, backtrace limit exceeded",  aBlock,  0xCu);
        }
      }
    }

void sub_181DEDC7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20, void *a21, void *a22, void *a23, void *a24, void *a25, uint64_t a26, void *a27, void *a28, void *a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, id a41, char a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, id a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,id a53,id a54,id a55)
{
  _Block_object_dispose((const void *)(v63 - 176), 8);
  _Block_object_dispose(&a42, 8);

  _Block_object_dispose(&a32, 8);
  _Block_object_dispose(&a36, 8);

  _Unwind_Resume(a1);
}

void ___ZL37nw_connection_group_modify_parametersP30NWConcrete_nw_connection_groupPU27objcproto16OS_nw_parameters8NSObjectPU33objcproto22OS_nw_protocol_optionsS1__block_invoke( uint64_t a1, nw_protocol_options_t options)
{
  nw_protocol_definition_t v3 = nw_protocol_options_copy_definition(options);
  nw_protocol_definition_t v4 = v3;
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL))
  {
    nw_protocol_definition_t v6 = v3;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v3, *(void *)(a1 + 32));
    nw_protocol_definition_t v4 = v6;
    if (is_equal_unsafe)
    {
      nw_protocol_stack_replace_protocol(*(void **)(a1 + 40), v6, *(void **)(a1 + 48));
      *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
      nw_protocol_definition_t v4 = v6;
    }
  }
}

void sub_181DEDE98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZL65nw_connection_group_create_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS3_PU33objcproto22OS_nw_protocol_optionsS3_b_block_invoke_2( uint64_t a1)
{
}

nw_connection_t nw_connection_group_extract_connection_for_message( nw_connection_group_t group, nw_content_context_t context)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  nw_connection_group_t v3 = group;
  nw_protocol_definition_t v4 = context;
  nw_connection_group_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    char v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_extract_connection_for_message";
    char v24 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v4_Block_object_dispose((const void *)(v2 - 96), 8) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_extract_connection_for_message";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if ((_BYTE)v48)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type[0];
      BOOL v33 = os_log_type_enabled(v25, type[0]);
      if (backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_extract_connection_for_message";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v25,  v32,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_70:
        if (!v24)
        {
LABEL_72:
          int v21 = 0LL;
          goto LABEL_30;
        }

void sub_181DEE7AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id a24)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_extract_connection_for_message_block_invoke(uint64_t a1)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  id v2 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  nw_connection_group_t v3 = *(id *)(a1 + 32);
  id v4 = v2;
  nw_connection_group_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t v56 = 136446210;
    *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)os_log_type_t v56 = 136446210;
        *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null group", v56, 0xCu);
      }
    }

    else if (v51)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)os_log_type_t v56 = 136446466;
          *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
          *(_WORD *)&v56[12] = 2082;
          *(void *)&v56[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null group, dumping backtrace:%{public}s",  v56,  0x16u);
        }

        free(backtrace_string);
LABEL_78:
        if (!v18)
        {
LABEL_80:

          goto LABEL_81;
        }

BOOL nw_connection_group_reinsert_extracted_connection(nw_connection_group_t group, nw_connection_t connection)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_connection_group_t v3 = group;
  id v4 = connection;
  nw_connection_group_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_reinsert_extracted_connection";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reinsert_extracted_connection";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_52;
    }

    if (!v29)
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reinsert_extracted_connection";
        _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reinsert_extracted_connection";
        _os_log_impl(&dword_181A5C000, v13, v19, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }

      goto LABEL_52;
    }

    if (v20)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_reinsert_extracted_connection";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_40;
  }

  if (!v4)
  {
    __nwlog_obj();
    int v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_reinsert_extracted_connection";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reinsert_extracted_connection";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null connection", buf, 0xCu);
      }

void sub_181DEFA90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_reinsert_extracted_connection_block_invoke(uint64_t a1)
{
  v18[2] = *MEMORY[0x1895F89C0];
  nw_connection_get_group_uuid(*(void **)(a1 + 32), (unsigned __int8 *)v18);
  id v2 = *(uint64_t **)(a1 + 40);
  if (v2[15] != v18[0] || v2[16] != v18[1]) {
    goto LABEL_12;
  }
  uint64_t v3 = v2[13];
  id v4 = *(void **)(a1 + 32);
  if (!v3 || v4 == 0LL) {
    goto LABEL_20;
  }
  BOOL v7 = *(void ***)(v3 + 16);
  uint64_t v6 = *(void ***)(v3 + 24);
  if (v7 != v6)
  {
    while (*v7 != v4)
    {
      if (++v7 == v6)
      {
        BOOL v7 = v6;
        break;
      }
    }
  }

  if (v7 == v6)
  {
LABEL_20:
    nw_connection_reset_client(v4);
    nw_connection_group_add_connection_locked( *(NWConcrete_nw_connection_group **)(a1 + 40),  *(NWConcrete_nw_connection **)(a1 + 32));
    nw_connection_start(*(nw_connection_t *)(a1 + 32));
    char v11 = 1;
  }

  else
  {
LABEL_12:
    if (!nw_parameters_get_logging_disabled(v2[7]))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      BOOL v8 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        int v10 = *(_DWORD *)(*(void *)(a1 + 40) + 168LL);
        int v12 = 136446722;
        int v13 = "nw_connection_group_reinsert_extracted_connection_block_invoke";
        __int16 v14 = 1024;
        int v15 = v10;
        __int16 v16 = 2112;
        uint64_t v17 = v9;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] connection %@ was not extracted from this group or was already reinserted, reinsertion failed",  (uint8_t *)&v12,  0x1Cu);
      }
    }

    char v11 = 0;
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v11;
}

BOOL nw_connection_group_add_member(void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  nw_connection_group_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_add_member";
    int v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v34 = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (v34 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = v34;
      if (os_log_type_enabled(v16, v34))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_add_member";
        _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v34;
      BOOL v22 = os_log_type_enabled(v16, v34);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_add_member";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_50:
        if (!v15)
        {
LABEL_13:
          BOOL v12 = 0LL;
          goto LABEL_16;
        }

void sub_181DF02BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  _Block_object_dispose((const void *)(v23 - 96), 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_add_member_block_invoke(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    id v4 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v8 = 136447234;
      id v9 = "nw_connection_group_add_member_block_invoke";
      __int16 v10 = 1024;
      int v11 = v6;
      __int16 v12 = 2112;
      uint64_t v13 = v5;
      __int16 v14 = 1042;
      int v15 = 16;
      __int16 v16 = 2098;
      os_log_type_t v17 = a2;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] Adding member '%@' to Group Agent UUID=(%{public,uuid_t}.16P)",  (uint8_t *)&v8,  0x2Cu);
    }
  }

  BOOL v7 = nw_array_create();
  nw_array_append(v7, *(void **)(a1 + 40));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = nw_path_group_member_action( *(void **)(a1 + 48),  a2,  133,  (void *)v7);
}

void sub_181DF0468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_remove_member(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v31 = "nw_connection_group_remove_member";
    int v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v29 = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (v29 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v29;
      if (os_log_type_enabled(v12, v29))
      {
        *(_DWORD *)int buf = 136446210;
        id v31 = "nw_connection_group_remove_member";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = v29;
      BOOL v18 = os_log_type_enabled(v12, v29);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          id v31 = "nw_connection_group_remove_member";
          __int16 v32 = 2082;
          char v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11) {
          goto LABEL_8;
        }
LABEL_43:
        free(v11);
        goto LABEL_8;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        id v31 = "nw_connection_group_remove_member";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = v29;
      if (os_log_type_enabled(v12, v29))
      {
        *(_DWORD *)int buf = 136446210;
        id v31 = "nw_connection_group_remove_member";
        _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181DF09E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_remove_member_block_invoke(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    id v4 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v8 = 136447234;
      id v9 = "nw_connection_group_remove_member_block_invoke";
      __int16 v10 = 1024;
      int v11 = v6;
      __int16 v12 = 2112;
      uint64_t v13 = v5;
      __int16 v14 = 1042;
      int v15 = 16;
      __int16 v16 = 2098;
      os_log_type_t v17 = a2;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] Removing member '%@' from Group Agent UUID=(%{public,uuid_t}.16P)",  (uint8_t *)&v8,  0x2Cu);
    }
  }

  BOOL v7 = nw_array_create();
  nw_array_append(v7, *(void **)(a1 + 40));
  nw_path_group_member_action(*(void **)(a1 + 48), a2, 134, (void *)v7);
}

void sub_181DF0B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_start(nw_connection_group_t group)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = group;
  id v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_start_block_invoke;
    aBlock[3] = &unk_189BC93A0;
    uint64_t v13 = v1;
    id v3 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 43);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 43);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v17 = "nw_connection_group_start";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_connection_group_start";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v17 = "nw_connection_group_start";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_connection_group_start";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v17 = "nw_connection_group_start";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DF0E7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_start_block_invoke(uint64_t a1)
{
  uint64_t v183 = *MEMORY[0x1895F89C0];
  *(_DWORD *)(*(void *)(a1 + 32) + 16LL) = qos_class_self();
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 40);
  if (!v3)
  {
    if (!*(void *)(v2 + 8))
    {
      if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        id v4 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v17;
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] The group's client_queue is not set. You must set this group's client_queue using group() p rior to calling start.",  buf,  0x12u);
        }

        goto LABEL_77;
      }

      return;
    }

    if (!*(void *)(v2 + 136) && !*(void *)(v2 + 144))
    {
      if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        id v4 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v64 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v64;
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] The group does not have a receive handler or new connection handler set, You must set this group's receive handler or new connection handler prior to calling start.",  buf,  0x12u);
        }

        goto LABEL_77;
      }

      return;
    }

    if (!*(void *)(v2 + 32) && !nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      int v6 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v7;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] The group does not have a state changed handler set, no state updates will be delivered.",  buf,  0x12u);
      }
    }

    uint64_t v8 = *(void *)(a1 + 32);
    if (*(void *)(v8 + 88))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        int v11 = *(_DWORD *)(v10 + 168);
        int port = nw_listener_get_port(*(nw_listener_t *)(v10 + 88));
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(v13 + 56);
        id_string = nw_listener_get_id_string(*(void **)(v13 + 88));
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = port;
        *(_WORD *)char v176 = 2112;
        *(void *)&v176[2] = v14;
        *(_WORD *)&v176[10] = 2080;
        *(void *)&v176[12] = id_string;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s [G%u port: %u, parameters: %@, listener: [%s]] start",  buf,  0x2Cu);
      }

      uint64_t v8 = *(void *)(a1 + 32);
      if (*(_DWORD *)(v8 + 184))
      {
        nw_listener_set_new_connection_limit(*(nw_listener_t *)(v8 + 88), *(_DWORD *)(v8 + 184));
        uint64_t v8 = *(void *)(a1 + 32);
      }
    }

    objc_storeStrong((id *)(v8 + 24), (id)v8);
    *(_BYTE *)(*(void *)(a1 + 32) + 190LL) |= 1u;
    __int16 v18 = *(void **)(a1 + 32);
    if (!v18[10])
    {
      os_log_type_t v29 = v18;
LABEL_45:
      if (v29[13])
      {
        if (!nw_parameters_get_logging_disabled(v29[7]) && gLogDatapath)
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          uint32_t v96 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
          {
            int v97 = *((_DWORD *)v29 + 42);
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v97;
            _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] starting existing connections",  buf,  0x12u);
          }
        }

        nw_array_apply((unsigned __int8 *)v29[13], (uint64_t)&__block_literal_global_160);
      }

      goto LABEL_49;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s Calling nw_path_create_evaluator_for_group",  buf,  0xCu);
    }

    evaluator_for_group = nw_path_create_evaluator_for_group( *(void **)(*(void *)(a1 + 32) + 64LL),  *(void **)(*(void *)(a1 + 32) + 56LL));
    BOOL v21 = *(void **)(*(void *)(a1 + 32) + 72LL);
    *(void *)(*(void *)(a1 + 32) + 72LL) = evaluator_for_group;

    *(void *)int buf = 0LL;
    *(void *)&sockaddr buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    v176[0] = 0;
    os_log_type_t v22 = *(void **)(a1 + 32);
    os_log_type_t v23 = (void *)v22[9];
    os_log_type_t v24 = (void *)v22[1];
    v166[0] = MEMORY[0x1895F87A8];
    v166[1] = 3221225472LL;
    v166[2] = __nw_connection_group_start_block_invoke_26;
    v166[3] = &unk_189BB7260;
    __int128 v168 = buf;
    nw_endpoint_type_t v167 = v22;
    nw_path_evaluator_set_update_handler(v23, v24, v166);
    BOOL v25 = *(os_unfair_lock_s **)(*(void *)(a1 + 32) + 72LL);
    if (v25)
    {
      id v26 = v25 + 24;
      id v27 = v25;
      os_unfair_lock_lock(v26);
      id v28 = v27[6];
      os_unfair_lock_unlock(v26);

      if (v28)
      {
        v162[0] = MEMORY[0x1895F87A8];
        v162[1] = 3221225472LL;
        v162[2] = __nw_connection_group_start_block_invoke_29;
        v162[3] = &unk_189BB7210;
        id v163 = *(id *)(a1 + 32);
        id v28 = v28;
        id v164 = v28;
        int v165 = buf;
        nw_path_enumerate_group_options(v28, v162);
      }
    }

    else
    {
      id v28 = 0LL;
    }

    _Block_object_dispose(buf, 8);
    os_log_type_t v29 = *(id *)(a1 + 32);
    if (v29) {
      goto LABEL_45;
    }
    __nwlog_obj();
    os_log_type_t v92 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
    uint32_t v93 = (char *)_os_log_send_and_compose_impl();

    v180[0] = 16;
    handler[0] = 0;
    if (__nwlog_fault(v93, v180, handler))
    {
      if (v180[0] == 17)
      {
        __nwlog_obj();
        int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v95 = v180[0];
        if (os_log_type_enabled(v94, (os_log_type_t)v180[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
          _os_log_impl(&dword_181A5C000, v94, v95, "%{public}s called with null group", buf, 0xCu);
        }
      }

      else if (handler[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v99 = v180[0];
        BOOL v100 = os_log_type_enabled(v94, (os_log_type_t)v180[0]);
        if (backtrace_string)
        {
          if (v100)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v94,  v99,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_210;
        }

        if (v100)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
          _os_log_impl(&dword_181A5C000, v94, v99, "%{public}s called with null group, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v130 = v180[0];
        if (os_log_type_enabled(v94, (os_log_type_t)v180[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_start_existing_connections_locked";
          _os_log_impl( &dword_181A5C000,  v94,  v130,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_262:
              goto LABEL_263;
            }

            if (!handler[0])
            {
              __nwlog_obj();
              id v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v144 = v180[0];
              if (os_log_type_enabled(v113, (os_log_type_t)v180[0]))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v113,  v144,  "%{public}s called with null workloop, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_262;
            }

            os_log_type_t v128 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            id v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t typea = v180[0];
            BOOL v129 = os_log_type_enabled(v113, (os_log_type_t)v180[0]);
            if (!v128)
            {
              if (v129)
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v113,  typea,  "%{public}s called with null workloop, no backtrace",  buf,  0xCu);
              }

              goto LABEL_262;
            }

            if (v129)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v128;
              _os_log_impl( &dword_181A5C000,  v113,  typea,  "%{public}s called with null workloop, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v128);
          }

                        if ((v101 & 1) != 0)
                        {
                          BOOL v127 = 0LL;
                          if ((v119[402] & 2) != 0) {
                            goto LABEL_305;
                          }
                          goto LABEL_295;
                        }

                        os_log_type_t v140 = v88;
                        if (v140)
                        {
                          BOOL v127 = v140[97] >> 7;
                          goto LABEL_294;
                        }

                        __nwlog_obj();
                        BOOL v233 = (void *)objc_claimAutoreleasedReturnValue();
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                        uint64_t v234 = (char *)_os_log_send_and_compose_impl();

                        type[0] = 16;
                        LOBYTE(v279) = 0;
                        if (__nwlog_fault(v234, type, &v279))
                        {
                          if (type[0] == 17)
                          {
                            __nwlog_obj();
                            os_log_type_t v235 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            BOOL v236 = type[0];
                            if (os_log_type_enabled(v235, (os_log_type_t)type[0]))
                            {
                              *(_DWORD *)int buf = 136446210;
                              *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                              _os_log_impl( &dword_181A5C000,  v235,  v236,  "%{public}s called with null parameters",  buf,  0xCu);
                            }
                          }

                          else
                          {
                            if ((_BYTE)v279)
                            {
                              v244 = (char *)__nw_create_backtrace_string();
                              __nwlog_obj();
                              v245 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              v269 = type[0];
                              os_log_type_t v246 = os_log_type_enabled(v245, (os_log_type_t)type[0]);
                              if (v244)
                              {
                                if (v246)
                                {
                                  *(_DWORD *)int buf = 136446466;
                                  *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                                  *(_WORD *)&_BYTE buf[12] = 2082;
                                  *(void *)&buf[14] = v244;
                                  _os_log_impl( &dword_181A5C000,  v245,  v269,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                                }

                                free(v244);
                              }

                              else
                              {
                                if (v246)
                                {
                                  *(_DWORD *)int buf = 136446210;
                                  *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                                  _os_log_impl( &dword_181A5C000,  v245,  v269,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
                                }
                              }

                              goto LABEL_560;
                            }

                            __nwlog_obj();
                            os_log_type_t v235 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                            id v267 = type[0];
                            if (os_log_type_enabled(v235, (os_log_type_t)type[0]))
                            {
                              *(_DWORD *)int buf = 136446210;
                              *(void *)&uint8_t buf[4] = "nw_parameters_get_server_mode";
                              _os_log_impl( &dword_181A5C000,  v235,  v267,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
                            }
                          }
                        }

                  goto LABEL_263;
                }

                goto LABEL_263;
              }

              if (v204)
              {
                v217 = nw_endpoint_handler_get_minimize_logging(v471);
                os_log_type_t v218 = nw_endpoint_handler_get_logging_disabled(v471);
                if (v217)
                {
                  if ((v218 & 1) != 0) {
                    goto LABEL_263;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v219 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v219, OS_LOG_TYPE_DEBUG))
                  {
                    v338 = nw_endpoint_handler_get_id_string(v471);
                    v339 = nw_endpoint_handler_dry_run_string(v471);
                    v340 = nw_endpoint_handler_copy_endpoint(v471);
                    v341 = nw_endpoint_get_logging_description(v340);
                    v342 = nw_endpoint_handler_state_string(v471);
                    v343 = nw_endpoint_handler_mode_string(v471);
                    v344 = nw_endpoint_handler_copy_current_path(v471);
                    *(_DWORD *)int buf = 136447746;
                    v481 = "nw_endpoint_proxy_receive_report";
                    v482 = 2082;
                    v483 = (uint64_t)v338;
                    v484 = 2082;
                    v485 = (uint64_t)v339;
                    v486 = 2082;
                    v487 = v341;
                    v488 = 2082;
                    v489 = v342;
                    v490 = 2082;
                    v491 = v343;
                    v492 = 2114;
                    v493 = v344;
                    _os_log_impl( &dword_181A5C000,  v219,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] children failed, detected origin error",  buf,  0x48u);
                  }

                  goto LABEL_262;
                }

                if ((v218 & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v219 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v219, OS_LOG_TYPE_INFO))
                  {
                    v220 = nw_endpoint_handler_get_id_string(v471);
                    v221 = nw_endpoint_handler_dry_run_string(v471);
                    os_log_type_t v222 = nw_endpoint_handler_copy_endpoint(v471);
                    v223 = nw_endpoint_get_logging_description(v222);
                    v224 = nw_endpoint_handler_state_string(v471);
                    v225 = nw_endpoint_handler_mode_string(v471);
                    os_log_type_t v226 = nw_endpoint_handler_copy_current_path(v471);
                    *(_DWORD *)int buf = 136447746;
                    v481 = "nw_endpoint_proxy_receive_report";
                    v482 = 2082;
                    v483 = (uint64_t)v220;
                    v484 = 2082;
                    v485 = (uint64_t)v221;
                    v486 = 2082;
                    v487 = v223;
                    v488 = 2082;
                    v489 = v224;
                    v490 = 2082;
                    v491 = v225;
                    v492 = 2114;
                    v493 = v226;
                    _os_log_impl( &dword_181A5C000,  v219,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] children failed, detected origin error",  buf,  0x48u);
                  }

                  goto LABEL_262;
                }

        if (v131) {
LABEL_263:
        }
          free(v131);
LABEL_264:
        uint64_t v8 = v130;
        int v3 = v243;
        goto LABEL_187;
      }

      if (type[0])
      {
        os_log_type_t v156 = (char *)__nw_create_backtrace_string();
        os_log_type_t v157 = (os_log_s *)__nwlog_obj();
        __int128 v158 = v257[0];
        char v159 = os_log_type_enabled(v157, v257[0]);
        if (v156)
        {
          if (v159)
          {
            *(_DWORD *)int buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            os_log_type_t v255 = 2082;
            v256[0] = v156;
            _os_log_impl( &dword_181A5C000,  v157,  v158,  "%{public}s failed to detach packet, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v156);
          if (v131) {
            goto LABEL_263;
          }
          goto LABEL_264;
        }

        if (!v159) {
          goto LABEL_262;
        }
        *(_DWORD *)int buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        os_log_type_t v134 = v157;
        uint64_t v135 = v158;
        uint32_t v136 = "%{public}s failed to detach packet, no backtrace";
      }

      else
      {
        id v164 = (os_log_s *)__nwlog_obj();
        int v165 = v257[0];
        if (!os_log_type_enabled(v164, v257[0])) {
          goto LABEL_262;
        }
        *(_DWORD *)int buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        os_log_type_t v134 = v164;
        uint64_t v135 = v165;
        uint32_t v136 = "%{public}s failed to detach packet, backtrace limit exceeded";
      }

LABEL_263:
          if (!v112)
          {
LABEL_265:
            BOOL v44 = 0LL;
LABEL_61:

            goto LABEL_62;
          }

                    free(backtrace_string);
                    goto LABEL_308;
                  }

                  goto LABEL_308;
                }

                os_log_type_t v139 = v27;
                os_log_type_t v30 = 0LL;
                char v57 = 0;
                if ((_DWORD)a5 && v28)
                {
                  LODWORD(v30) = 0;
                  char v57 = 0;
                  do
                  {
                    outbound_data = nw_protocol_create_outbound_data((NWConcrete_nw_protocol_instance *)v14, v47, v142);
                    nw_protocol_metadata_t metadata = nw_frame_get_metadata(outbound_data);
                    if (metadata)
                    {
                      uint64_t v61 = (void *)metadata;
                      uint64_t v62 = v26;
                      uint64_t v63 = a5;
                      int v64 = v14;
                      if (nw_protocol_definition_get_message_is_stream(*((void **)v14 + 1))
                        && *((nw_protocol **)v14 - 6) == v141)
                      {
                        id v65 = -2LL;
                      }

                      else
                      {
                        id v65 = (uint64_t)v141;
                      }

                      *uint64_t v61 = v65;
                      uint64_t v14 = v143;
                      a5 = v63;
                      id v26 = v62;
                      id v28 = v140;
                    }

                    if (*((_OWORD *)v14 + 5) != 0LL) {
                      nw_frame_claim(outbound_data, v60, *((void *)v14 + 10), *((void *)v14 + 11));
                    }
                    *(void *)(outbound_data + 32) = 0LL;
                    tqh_last = a6->tqh_last;
                    *(void *)(outbound_data + 40) = tqh_last;
                    *tqh_last = (nw_frame *)outbound_data;
                    a6->tqh_last = (nw_frame **)(outbound_data + 32);
                    v57 += v47;
                    os_log_type_t v30 = (v30 + 1);
                  }

                  while (v30 < a5 && v57 < v28);
                }

                if ((v14[405] & 0x80000000) == 0 && gLogDatapath)
                {
                  __nwlog_obj();
                  BOOL v127 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)int buf = 136447234;
                    BOOL v151 = "nw_protocol_implementation_get_output_frames";
                    os_log_type_t v152 = 2082;
                    os_log_type_t v153 = (nw_protocol_identifier *)(v143 + 407);
                    os_log_type_t v154 = 2080;
                    os_log_type_t v155 = (nw_protocol *)" ";
                    os_log_type_t v156 = 1024;
                    *(_DWORD *)os_log_type_t v157 = v30;
                    *(_WORD *)&v157[4] = 1024;
                    *(_DWORD *)&v157[6] = v57;
                    _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sCreated %u outbound frames with total of %u bytes",  buf,  0x2Cu);
                  }

                  uint64_t v14 = v143;
                  if (v26)
                  {
LABEL_115:
                    *((_WORD *)v26 + 26) &= ~0x1000u;
                    BOOL v67 = v139;
                    if (!v139) {
                      goto LABEL_137;
                    }
                    goto LABEL_255;
                  }
                }

                else if (v26)
                {
                  goto LABEL_115;
                }

                v14[403] &= ~1u;
                BOOL v67 = v139;
                if (!v139) {
                  goto LABEL_137;
                }
LABEL_255:
                if (*v67 != -1) {
                  *v67 -= v57;
                }
                goto LABEL_137;
              }

              int v50 = nw_protocol_create_outbound_data((NWConcrete_nw_protocol_instance *)v14, v28, v142);
              nw_listener_t v51 = nw_frame_get_metadata(v50);
              id v53 = (uint64_t)v141;
              if (v51)
              {
                id v54 = (void *)v51;
                uint64_t v55 = v143;
                if (nw_protocol_definition_get_message_is_stream(*((void **)v143 + 1))
                  && *(v55 - 6) == v141)
                {
                  id v53 = -2LL;
                }

                *id v54 = v53;
              }

              if (*((_OWORD *)v143 + 5) != 0LL) {
                nw_frame_claim(v50, v52, *((void *)v143 + 10), *((void *)v143 + 11));
              }
              *(void *)(v50 + 32) = 0LL;
              id v56 = a6->tqh_last;
              *(void *)(v50 + 40) = v56;
              *id v56 = (nw_frame *)v50;
              a6->tqh_last = (nw_frame **)(v50 + 32);
              if ((v143[405] & 0x80000000) == 0 && gLogDatapath)
              {
                __nwlog_obj();
                os_log_type_t v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)int buf = 136446978;
                  BOOL v151 = "nw_protocol_implementation_get_output_frames";
                  os_log_type_t v152 = 2082;
                  os_log_type_t v153 = (nw_protocol_identifier *)(v143 + 407);
                  os_log_type_t v154 = 2080;
                  os_log_type_t v155 = (nw_protocol *)" ";
                  os_log_type_t v156 = 1024;
                  *(_DWORD *)os_log_type_t v157 = v28;
                  _os_log_impl( &dword_181A5C000,  v114,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sCreated 1 outbound frame with total of %u bytes",  buf,  0x26u);
                }

                if (!v27) {
                  goto LABEL_96;
                }
              }

              else if (!v27)
              {
LABEL_96:

                os_log_type_t v30 = 1LL;
                goto LABEL_97;
              }

              if (*v27 != -1) {
                *v27 -= v28;
              }
              goto LABEL_96;
            }

            __nwlog_obj();
            unsigned int v88 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)int buf = 136446210;
            BOOL v151 = "nw_protocol_implementation_get_output_frames";
            os_log_type_t v79 = (void *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v146) = 0;
            if (!__nwlog_fault((const char *)v79, type, &v146))
            {
LABEL_199:
              uint64_t v14 = v143;
              if (v79) {
                free(v79);
              }
              goto LABEL_136;
            }

            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              unsigned int v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v89 = type[0];
              if (os_log_type_enabled(v80, type[0]))
              {
                *(_DWORD *)int buf = 136446210;
                BOOL v151 = "nw_protocol_implementation_get_output_frames";
                _os_log_impl(&dword_181A5C000, v80, v89, "%{public}s called with null return_array", buf, 0xCu);
              }

                nw_endpoint_handler_handle_failure(v471);
                v471->event = (nw_endpoint_handler_event_s)327684;
                nw_endpoint_handler_report(v471, 0LL, &v471->event.domain, 0LL);
                goto LABEL_217;
              }

              if (v205 == *((_DWORD *)v42 + 6))
              {
                v227 = nw_endpoint_handler_get_minimize_logging(v471);
                v228 = nw_endpoint_handler_get_logging_disabled(v471);
                if (v227)
                {
                  if ((v228 & 1) != 0) {
                    goto LABEL_272;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v229 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v229, OS_LOG_TYPE_DEBUG))
                  {
                    v379 = nw_endpoint_handler_get_id_string(v471);
                    v380 = nw_endpoint_handler_dry_run_string(v471);
                    v381 = nw_endpoint_handler_copy_endpoint(v471);
                    v382 = nw_endpoint_get_logging_description(v381);
                    v383 = nw_endpoint_handler_state_string(v471);
                    v384 = nw_endpoint_handler_mode_string(v471);
                    v385 = nw_endpoint_handler_copy_current_path(v471);
                    *(_DWORD *)int buf = 136447746;
                    v481 = "nw_endpoint_proxy_receive_report";
                    v482 = 2082;
                    v483 = (uint64_t)v379;
                    v484 = 2082;
                    v485 = (uint64_t)v380;
                    v486 = 2082;
                    v487 = v382;
                    v488 = 2082;
                    v489 = v383;
                    v490 = 2082;
                    v491 = v384;
                    v492 = 2114;
                    v493 = v385;
                    _os_log_impl( &dword_181A5C000,  v229,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started child ren failed, start next child.",  buf,  0x48u);
                  }

                  goto LABEL_271;
                }

                if ((v228 & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v229 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v229, OS_LOG_TYPE_INFO))
                  {
                    os_log_type_t v230 = nw_endpoint_handler_get_id_string(v471);
                    v231 = nw_endpoint_handler_dry_run_string(v471);
                    os_log_type_t v232 = nw_endpoint_handler_copy_endpoint(v471);
                    BOOL v233 = nw_endpoint_get_logging_description(v232);
                    uint64_t v234 = nw_endpoint_handler_state_string(v471);
                    os_log_type_t v235 = nw_endpoint_handler_mode_string(v471);
                    BOOL v236 = nw_endpoint_handler_copy_current_path(v471);
                    *(_DWORD *)int buf = 136447746;
                    v481 = "nw_endpoint_proxy_receive_report";
                    v482 = 2082;
                    v483 = (uint64_t)v230;
                    v484 = 2082;
                    v485 = (uint64_t)v231;
                    v486 = 2082;
                    v487 = v233;
                    v488 = 2082;
                    v489 = v234;
                    v490 = 2082;
                    v491 = v235;
                    v492 = 2114;
                    v493 = v236;
                    _os_log_impl( &dword_181A5C000,  v229,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started child ren failed, start next child.",  buf,  0x48u);
                  }

  uint32_t v136 = *v74;
  if (!v136) {
    return result;
  }
  *(void *)int buf = 0LL;
  asprintf((char **)buf, "%s,%s", v75, v136);
  nw_http_fields_append(v72, (uint64_t)"Priority", *(uint64_t *)buf);
  os_log_type_t v78 = *(char **)buf;
  if (*(void *)buf) {
    goto LABEL_131;
  }
  return 1LL;
}

            if (v90) {
              free(v90);
            }
            BOOL v67 = v580;
            *(_DWORD *)(v580 + 336) = -1;
            os_log_type_t v87 = v579;
            int v68 = &qword_18C45F000;
LABEL_266:
            int v190 = *(unsigned int *)(v67 + 360) + 1LL;
            BOOL v191 = v190 << 31 >> 31;
            *(_DWORD *)(v67 + 360) = v190;
            if (v191 == v190 && (v191 & 0x8000000000000000LL) == 0) {
              goto LABEL_285;
            }
            int v192 = v67;
            __nwlog_obj();
            BOOL v193 = *(unsigned int *)(v192 + 360);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "http1->next_connection_log_num";
            *(_WORD *)&buf[22] = 2048;
            v608 = 1LL;
            *(_WORD *)v609 = 2048;
            *(void *)&v609[2] = v193;
            int v194 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(aBlock) = 0;
            if (__nwlog_fault(v194, type, &aBlock))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                int v195 = (os_log_s *)__nwlog_obj();
                v196 = type[0];
                if (os_log_type_enabled(v195, type[0]))
                {
                  v197 = *(unsigned int *)(v580 + 360);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = "http1->next_connection_log_num";
                  *(_WORD *)&buf[22] = 2048;
                  v608 = 1LL;
                  *(_WORD *)v609 = 2048;
                  *(void *)&v609[2] = v197;
                  __int16 v198 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_281:
                  _os_log_impl(&dword_181A5C000, v195, v196, v198, buf, 0x2Au);
                }
              }

              else if ((_BYTE)aBlock)
              {
                v199 = v38;
                uint32_t v200 = (char *)__nw_create_backtrace_string();
                int v195 = (os_log_s *)__nwlog_obj();
                v196 = type[0];
                v201 = os_log_type_enabled(v195, type[0]);
                if (v200)
                {
                  if (v201)
                  {
                    BOOL v202 = *(unsigned int *)(v580 + 360);
                    *(_DWORD *)int buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = "http1->next_connection_log_num";
                    *(_WORD *)&buf[22] = 2048;
                    v608 = 1LL;
                    *(_WORD *)v609 = 2048;
                    *(void *)&v609[2] = v202;
                    *(_WORD *)&v609[10] = 2082;
                    *(void *)&v609[12] = v200;
                    _os_log_impl( &dword_181A5C000,  v195,  v196,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(v200);
                  os_log_type_t v38 = v199;
                  goto LABEL_282;
                }

                os_log_type_t v38 = v199;
                if (v201)
                {
                  int v204 = *(unsigned int *)(v580 + 360);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = "http1->next_connection_log_num";
                  *(_WORD *)&buf[22] = 2048;
                  v608 = 1LL;
                  *(_WORD *)v609 = 2048;
                  *(void *)&v609[2] = v204;
                  __int16 v198 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                  goto LABEL_281;
                }
              }

              else
              {
                int v195 = (os_log_s *)__nwlog_obj();
                v196 = type[0];
                if (os_log_type_enabled(v195, type[0]))
                {
                  v203 = *(unsigned int *)(v580 + 360);
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = "http1->next_connection_log_num";
                  *(_WORD *)&buf[22] = 2048;
                  v608 = 1LL;
                  *(_WORD *)v609 = 2048;
                  *(void *)&v609[2] = v203;
                  __int16 v198 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_281;
                }
              }
            }

void sub_181DF3284( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_start_block_invoke_26(uint64_t a1, void *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v5;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s Path evaluator update handler called, initial_set_members_complete=%{BOOL}d",  buf,  0x12u);
  }

  uint64_t v27 = 0LL;
  id v28 = &v27;
  uint64_t v29 = 0x2020000000LL;
  char v30 = 0;
  int v6 = *(os_unfair_lock_s **)(a1 + 32);
  uint64_t v7 = MEMORY[0x1895F87A8];
  int v8 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = __nw_connection_group_start_block_invoke_27;
  aBlock[3] = &unk_189BB7238;
  BOOL v25 = &v27;
  os_log_type_t v9 = v6;
  uint64_t v10 = *(void *)(a1 + 40);
  os_log_type_t v23 = v9;
  uint64_t v26 = v10;
  id v11 = v3;
  id v24 = v11;
  __int16 v12 = (void (**)(void))_Block_copy(aBlock);
  v6 += 43;
  os_unfair_lock_lock(v6);
  v12[2](v12);
  os_unfair_lock_unlock(v6);

  if (v8 && !*((_BYTE *)v28 + 24))
  {
    uint64_t v13 = (void **)*(id *)(a1 + 32);
    id v14 = v11;
    uint64_t v15 = (uint64_t)nw_group_descriptor_copy_members(v13[8]);
    id v16 = nw_path_copy_group_members(v14);
    BOOL v17 = (BOOL)v16;
    if (v15)
    {
      if (v16) {
        goto LABEL_7;
      }
    }

    else
    {
      uint64_t v15 = nw_array_create();
      if (v17) {
        goto LABEL_7;
      }
    }

    BOOL v17 = nw_array_create();
LABEL_7:
    nw_group_descriptor_set_members(v13[8], (void *)v17);
    __int16 v18 = v13[8];
    if (v18)
    {
      os_log_type_t v19 = v18;
      int v20 = v19[2];

      if (v20 == 3 && *((int *)v13 + 10) <= 2)
      {
        *(void *)int buf = v7;
        *(void *)&sockaddr buf[8] = 3221225472LL;
        *(void *)&buf[16] = ___ZL37nw_connection_group_reconcile_membersP30NWConcrete_nw_connection_groupPU21objcproto10OS_nw_path8NSObject_block_invoke;
        uint64_t v34 = &unk_189BC85B0;
        int v35 = v13;
        nw_array_apply((unsigned __int8 *)v17, (uint64_t)buf);
      }
    }

    v31[0] = v7;
    v31[1] = 3221225472LL;
    v31[2] = ___ZL37nw_connection_group_reconcile_membersP30NWConcrete_nw_connection_groupPU21objcproto10OS_nw_path8NSObject_block_invoke_2;
    v31[3] = &unk_189BB7390;
    BOOL v21 = v13;
    int v32 = v21;
    nw_array_review_change(v15, v17, (uint64_t)&__block_literal_global_158, (uint64_t)v31);
  }

  _Block_object_dispose(&v27, 8);
}

void sub_181DF3684( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_start_block_invoke_29(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    int v6 = 136446722;
    uint64_t v7 = "nw_connection_group_start_block_invoke";
    __int16 v8 = 1042;
    int v9 = 16;
    __int16 v10 = 2098;
    id v11 = a2;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s Group Agent UUID=(%{public,uuid_t}.16P)",  (uint8_t *)&v6,  0x1Cu);
  }

  id v5 = nw_group_descriptor_copy_members(*(void **)(*(void *)(a1 + 32) + 64LL));
  nw_path_group_member_action(*(void **)(a1 + 40), a2, 133, v5);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  nw_connection_group_set_state_locked(*(void **)(a1 + 32), 2, 0LL);
}

void sub_181DF3804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL53nw_connection_group_start_existing_connections_lockedP30NWConcrete_nw_connection_group_block_invoke( int a1, int a2, nw_connection_t connection)
{
  return 1LL;
}

void __nw_connection_group_start_block_invoke_27(uint64_t a1)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = *(_BYTE *)(*(void *)(a1 + 32) + 190LL) >> 7;
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL)
    && !*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    id v5[2] = __nw_connection_group_start_block_invoke_2;
    v5[3] = &unk_189BB7210;
    uint64_t v2 = *(void **)(a1 + 40);
    id v6 = *(id *)(a1 + 32);
    id v3 = *(id *)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 56);
    id v7 = v3;
    uint64_t v8 = v4;
    nw_path_enumerate_group_options(v2, v5);
  }

void sub_181DF3904( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
}

uint64_t ___ZL37nw_connection_group_reconcile_membersP30NWConcrete_nw_connection_groupPU21objcproto10OS_nw_path8NSObject_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v96 = *MEMORY[0x1895F89C0];
  id v70 = a3;
  uint64_t v4 = nw_endpoint_copy(v70);
  id v5 = *(id *)(*(void *)(a1 + 32) + 56LL);
  BOOL v6 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v5,  0,  0);

  id v7 = (os_unfair_lock_s *)*(id *)(a1 + 32);
  id v8 = v4;
  id v9 = (id)v6;
  __int16 v10 = v9;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)aBlock = 136446210;
    *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
    BOOL v42 = (char *)_os_log_send_and_compose_impl();

    v94[0] = 16;
    buf[0] = 0;
    if (v94[0] == 17)
    {
      __nwlog_obj();
      id v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = v94[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v94[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null group", aBlock, 0xCu);
      }

      goto LABEL_102;
    }

    if (!buf[0])
    {
      __nwlog_obj();
      id v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v61 = v94[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v94[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl( &dword_181A5C000,  v43,  v61,  "%{public}s called with null group, backtrace limit exceeded",  aBlock,  0xCu);
      }

      goto LABEL_102;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v50 = v94[0];
    BOOL v51 = os_log_type_enabled(v43, (os_log_type_t)v94[0]);
    if (!backtrace_string)
    {
      if (v51)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl(&dword_181A5C000, v43, v50, "%{public}s called with null group, no backtrace", aBlock, 0xCu);
      }

      goto LABEL_102;
    }

    if (v51)
    {
      *(_DWORD *)aBlock = 136446466;
      *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
      *(_WORD *)&aBlock[12] = 2082;
      *(void *)&aBlock[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v43,  v50,  "%{public}s called with null group, dumping backtrace:%{public}s",  aBlock,  0x16u);
    }

    goto LABEL_68;
  }

  if (!v8)
  {
    __nwlog_obj();
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)aBlock = 136446210;
    *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
    BOOL v42 = (char *)_os_log_send_and_compose_impl();

    v94[0] = 16;
    buf[0] = 0;
    if (v94[0] == 17)
    {
      __nwlog_obj();
      id v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = v94[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v94[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl(&dword_181A5C000, v43, v46, "%{public}s called with null remote_endpoint", aBlock, 0xCu);
      }

      goto LABEL_102;
    }

    if (!buf[0])
    {
      __nwlog_obj();
      id v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = v94[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v94[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl( &dword_181A5C000,  v43,  v62,  "%{public}s called with null remote_endpoint, backtrace limit exceeded",  aBlock,  0xCu);
      }

      goto LABEL_102;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v52 = v94[0];
    BOOL v53 = os_log_type_enabled(v43, (os_log_type_t)v94[0]);
    if (!backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl( &dword_181A5C000,  v43,  v52,  "%{public}s called with null remote_endpoint, no backtrace",  aBlock,  0xCu);
      }

      goto LABEL_102;
    }

    if (v53)
    {
      *(_DWORD *)aBlock = 136446466;
      *(void *)&void aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
      *(_WORD *)&aBlock[12] = 2082;
      *(void *)&aBlock[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v43,  v52,  "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s",  aBlock,  0x16u);
    }

void sub_181DF4790( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, void *a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, id a39, id a40, id a41)
{
  _Block_object_dispose((const void *)(v42 - 240), 8);
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a25, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_connection_group_reconcile_membersP30NWConcrete_nw_connection_groupPU21objcproto10OS_nw_path8NSObject_block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 80LL) + 16LL))();
}

uint64_t ___ZL37nw_connection_group_reconcile_membersP30NWConcrete_nw_connection_groupPU21objcproto10OS_nw_path8NSObject_block_invoke_156( uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "isEqual:");
}

void __nw_connection_group_start_block_invoke_2(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    int v6 = 136446722;
    id v7 = "nw_connection_group_start_block_invoke_2";
    __int16 v8 = 1042;
    int v9 = 16;
    __int16 v10 = 2098;
    id v11 = a2;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s Group Agent UUID=(%{public,uuid_t}.16P)",  (uint8_t *)&v6,  0x1Cu);
  }

  id v5 = nw_group_descriptor_copy_members(*(void **)(*(void *)(a1 + 32) + 64LL));
  nw_path_group_member_action(*(void **)(a1 + 40), a2, 133, v5);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  nw_connection_group_set_state_locked(*(void **)(a1 + 32), 2, 0LL);
}

void sub_181DF4A04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_group_cancel(nw_connection_group_t group)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = group;
  uint64_t v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_cancel_block_invoke;
    aBlock[3] = &unk_189BC93A0;
    id v13 = v1;
    id v3 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 43);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 43);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v17 = "nw_connection_group_cancel";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_connection_group_cancel";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v17 = "nw_connection_group_cancel";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_connection_group_cancel";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v17 = "nw_connection_group_cancel";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181DF4D10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_connection_group_cancel_block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(char *)(v2 + 190);
  BOOL logging_disabled = nw_parameters_get_logging_disabled(*(void *)(v2 + 56));
  if (v3 < 0)
  {
    if (logging_disabled) {
      return;
    }
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    int v16 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v18 = 136446466;
      BOOL v19 = "nw_connection_group_cancel_block_invoke";
      __int16 v20 = 1024;
      int v21 = v17;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] The group has already been cancelled, ignoring nw_connection_group_cancel().",  (uint8_t *)&v18,  0x12u);
    }

    goto LABEL_33;
  }

  if (!logging_disabled)
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    id v5 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      int v18 = 136446466;
      BOOL v19 = "nw_connection_group_cancel_block_invoke";
      __int16 v20 = 1024;
      int v21 = v6;
      _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s [G%u] cancel", (uint8_t *)&v18, 0x12u);
    }
  }

  uint64_t v7 = *(void *)(a1 + 32);
  __int16 v8 = *(void **)(v7 + 72);
  if (v8)
  {
    nw_path_evaluator_cancel(v8);
    uint64_t v7 = *(void *)(a1 + 32);
  }

  *(_BYTE *)(v7 + 190) |= 0x80u;
  uint64_t v9 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v9 + 190) & 8) != 0 && *(void *)(v9 + 88))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v9 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      BOOL v10 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        int v18 = 136446466;
        BOOL v19 = "nw_connection_group_cancel_block_invoke";
        __int16 v20 = 1024;
        int v21 = v11;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] cancelling group listener",  (uint8_t *)&v18,  0x12u);
      }
    }

    nw_listener_cancel(*(nw_listener_t *)(*(void *)(a1 + 32) + 88LL));
  }

  else
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v9 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v12 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        int v13 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        int v18 = 136446466;
        BOOL v19 = "nw_connection_group_cancel_block_invoke";
        __int16 v20 = 1024;
        int v21 = v13;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] cancelling group connections",  (uint8_t *)&v18,  0x12u);
      }
    }

    nw_connection_group_cancel_connections_locked(*(NWConcrete_nw_connection_group **)(a1 + 32));
  }

  char v14 = *(nw_listener **)(*(void *)(a1 + 32) + 96LL);
  if (v14)
  {
    nw_listener_cancel(v14);
    uint64_t v15 = *(void *)(a1 + 32);
    int v16 = *(os_log_s **)(v15 + 96);
    *(void *)(v15 + 96) = 0LL;
LABEL_33:
  }

nw_group_descriptor_t nw_connection_group_copy_descriptor(nw_connection_group_t group)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = group;
  uint64_t v2 = v1;
  if (v1)
  {
    int v3 = (nw_group_descriptor *)v1[8];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_connection_group_copy_descriptor";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_copy_descriptor";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_connection_group_copy_descriptor";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_copy_descriptor";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_copy_descriptor";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

nw_parameters_t nw_connection_group_copy_parameters(nw_connection_group_t group)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = group;
  uint64_t v2 = v1;
  if (v1)
  {
    int v3 = (nw_parameters *)v1[7];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_connection_group_copy_parameters";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_connection_group_copy_parameters";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_copy_parameters";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_connection_group_get_id(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[42];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v16 = "nw_connection_group_get_id";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_get_id";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v16 = "nw_connection_group_get_id";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_get_id";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v16 = "nw_connection_group_get_id";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

nw_protocol_metadata_t nw_connection_group_copy_protocol_metadata_for_message( nw_connection_group_t group, nw_content_context_t context, nw_protocol_definition_t definition)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  id v5 = group;
  int v6 = context;
  uint64_t v7 = definition;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v47, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (!v61)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl( &dword_181A5C000,  v26,  v58,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v52 = type;
    BOOL v53 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v52, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (v53)
    {
      *(_DWORD *)int buf = 136446466;
      id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
      __int16 v65 = 2082;
      id v66 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v26,  v52,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v48 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v49, "%{public}s called with null context", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (!v61)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl( &dword_181A5C000,  v26,  v59,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v54 = type;
    BOOL v55 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v55)
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v54, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (v55)
    {
      *(_DWORD *)int buf = 136446466;
      id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
      __int16 v65 = 2082;
      id v66 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v26,  v54,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v50 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v51 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v51, "%{public}s called with null definition", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (!v61)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl( &dword_181A5C000,  v26,  v60,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v56 = type;
    BOOL v57 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v57)
      {
        *(_DWORD *)int buf = 136446210;
        id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
        _os_log_impl(&dword_181A5C000, v26, v56, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }

      goto LABEL_32;
    }

    if (v57)
    {
      *(_DWORD *)int buf = 136446466;
      id v64 = "nw_connection_group_copy_protocol_metadata_for_message";
      __int16 v65 = 2082;
      id v66 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v26,  v56,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181DF64D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_connection_group_copy_local_endpoint_for_message( nw_connection_group_t group, nw_content_context_t context)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  uint64_t v3 = group;
  uint64_t v4 = context;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
    unsigned int v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v44, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_34;
    }

    if (!v53)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v51 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl( &dword_181A5C000,  v23,  v51,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v47 = type;
    BOOL v48 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v47, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }

      goto LABEL_34;
    }

    if (v48)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
      __int16 v57 = 2082;
      os_log_type_t v58 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v47,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_27;
  }

  if (!v4)
  {
    __nwlog_obj();
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
    unsigned int v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v46, "%{public}s called with null context", buf, 0xCu);
      }

      goto LABEL_34;
    }

    if (!v53)
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl( &dword_181A5C000,  v23,  v52,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v49 = type;
    BOOL v50 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
        _os_log_impl(&dword_181A5C000, v23, v49, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }

      goto LABEL_34;
    }

    if (v50)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v56 = "nw_connection_group_copy_local_endpoint_for_message";
      __int16 v57 = 2082;
      os_log_type_t v58 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v49,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181DF6F9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_path_t nw_connection_group_copy_path_for_message(nw_connection_group_t group, nw_content_context_t context)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  nw_connection_group_t v3 = group;
  uint64_t v4 = context;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v77 = "nw_connection_group_copy_path_for_message";
    BOOL v35 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl(&dword_181A5C000, v36, v57, "%{public}s called with null group", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (!v75)
    {
      __nwlog_obj();
      unsigned int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v64 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl( &dword_181A5C000,  v36,  v64,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v60 = type[0];
    BOOL v61 = os_log_type_enabled(v36, type[0]);
    if (!backtrace_string)
    {
      if (v61)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl(&dword_181A5C000, v36, v60, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (v61)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v77 = "nw_connection_group_copy_path_for_message";
      __int16 v78 = 2082;
      os_log_type_t v79 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v36,  v60,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_34;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v77 = "nw_connection_group_copy_path_for_message";
    BOOL v35 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl(&dword_181A5C000, v36, v59, "%{public}s called with null context", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (!v75)
    {
      __nwlog_obj();
      unsigned int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v65 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl( &dword_181A5C000,  v36,  v65,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v62 = type[0];
    BOOL v63 = os_log_type_enabled(v36, type[0]);
    if (!backtrace_string)
    {
      if (v63)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl(&dword_181A5C000, v36, v62, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (v63)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v77 = "nw_connection_group_copy_path_for_message";
      __int16 v78 = 2082;
      os_log_type_t v79 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v36,  v62,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_181DF7C74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id a25)
{
  _Block_object_dispose(&a20, 8);
  _Unwind_Resume(a1);
}

void __nw_connection_group_copy_path_for_message_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 56LL);
  BOOL v3 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v2,  0,  0);

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_181DF7D58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_get_next_instance_id()
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  do
    unsigned int v0 = __ldaxr(nw_protocol_get_next_instance_id::s_last_instance_id);
  while (__stlxr(v0 + 1, nw_protocol_get_next_instance_id::s_last_instance_id));
  uint64_t result = v0 + 1;
  if (v0 == -1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446466;
      uint64_t v4 = "nw_protocol_get_next_instance_id";
      __int16 v5 = 1024;
      int v6 = 0;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s reached %u instance ids, wrapping",  (uint8_t *)&v3,  0x12u);
    }

    return nw_protocol_get_next_instance_id();
  }

  return result;
}

uint64_t nw_protocol_add_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(a1 + 88);
      if (v5) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
      }
    }

    if (a2)
    {
      int v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      int v8 = *(uint64_t (***)(uint64_t, uint64_t))(a1 + 24);
      if (v8)
      {
        uint64_t v9 = *v8;
        if (v9)
        {
          uint64_t v10 = v9(a1, a2);
          if (v6 != &nw_protocol_ref_counted_handle)
          {
LABEL_13:
            if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v12 = *(void *)(a1 + 88);
              if (v12)
              {
                uint64_t v13 = v12 - 1;
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13;
                if (!v13)
                {
                  int v14 = *(void (***)(void))(a1 + 64);
                  if (v14)
                  {
                    *(void *)(a1 + 64) = 0LL;
                    v14[2](v14);
                    _Block_release(v14);
                  }

                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    uint64_t v15 = *(const void **)(a1 + 64);
                    if (v15) {
                      _Block_release(v15);
                    }
                  }

                  free((void *)a1);
                }
              }
            }

            return v10;
          }

uint64_t nw_protocol_add_input_handler_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  int v3 = *(uint64_t (***)(uint64_t, uint64_t))(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  if (a2)
  {
    int v6 = *v3;
    if (v6)
    {
      uint64_t v7 = *(void **)(a1 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8) {
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
        }
      }

      if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a2 + 88);
        if (v9) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
        }
        uint64_t v5 = v6(a1, a2);
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v11 = *(void *)(a2 + 88);
          if (v11)
          {
            uint64_t v12 = v11 - 1;
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12;
            if (!v12)
            {
              uint64_t v13 = *(void (***)(void))(a2 + 64);
              if (v13)
              {
                *(void *)(a2 + 64) = 0LL;
                v13[2](v13);
                _Block_release(v13);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                int v14 = *(const void **)(a2 + 64);
                if (v14) {
                  _Block_release(v14);
                }
              }

              free((void *)a2);
            }
          }
        }
      }

      else
      {
        uint64_t v5 = v6(a1, a2);
      }

      if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v15 = *(void *)(a1 + 88);
        if (v15)
        {
          uint64_t v16 = v15 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
          if (!v16)
          {
            uint64_t v17 = *(void (***)(void))(a1 + 64);
            if (v17)
            {
              *(void *)(a1 + 64) = 0LL;
              v17[2](v17);
              _Block_release(v17);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              int v18 = *(const void **)(a1 + 64);
              if (v18) {
                _Block_release(v18);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v5;
}

uint64_t nw_protocol_add_input_handler_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    id v2 = *(void **)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *v2 != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_replace_input_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
      }
    }

    if (a2)
    {
      uint64_t v8 = *(void **)(a2 + 40);
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a2 + 88);
        if (v9) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
        }
      }

      if (a3)
      {
        uint64_t v10 = *(void **)(a3 + 40);
        if (v10 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v11 = *(void *)(a3 + 88);
          if (v11) {
            *(void *)(a3 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v11 + 1;
          }
        }

        uint64_t v12 = *(void *)(a1 + 24);
        if (v12)
        {
          uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 16);
          if (v13)
          {
            uint64_t v14 = v13(a1, a2, a3);
            if (v10 != &nw_protocol_ref_counted_handle)
            {
LABEL_17:
              if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v20 = *(void *)(a2 + 88);
                if (v20)
                {
                  uint64_t v21 = v20 - 1;
                  *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v21;
                  if (!v21)
                  {
                    unsigned int v22 = *(void (***)(void))(a2 + 64);
                    if (v22)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v22[2](v22);
                      _Block_release(v22);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      os_log_type_t v23 = *(const void **)(a2 + 64);
                      if (v23) {
                        _Block_release(v23);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }

uint64_t nw_protocol_replace_input_handler_quiet(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  if (a3)
  {
    if (a2)
    {
      uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v4 + 16);
      if (v8)
      {
        uint64_t v9 = *(void **)(a1 + 40);
        if (v9 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v10 = *(void *)(a1 + 88);
          if (v10) {
            *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10 + 1;
          }
        }

        uint64_t v11 = *(void **)(a2 + 40);
        if (v11 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v12 = *(void *)(a2 + 88);
          if (v12) {
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12 + 1;
          }
        }

        if (*(_UNKNOWN **)(a3 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v13 = *(void *)(a3 + 88);
          if (v13) {
            *(void *)(a3 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13 + 1;
          }
          uint64_t v6 = v8(a1, a2, a3);
          if (*(_UNKNOWN **)(a3 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v15 = *(void *)(a3 + 88);
            if (v15)
            {
              uint64_t v16 = v15 - 1;
              *(void *)(a3 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
              if (!v16)
              {
                uint64_t v17 = *(void (***)(void))(a3 + 64);
                if (v17)
                {
                  *(void *)(a3 + 64) = 0LL;
                  v17[2](v17);
                  _Block_release(v17);
                }

                if ((*(_BYTE *)(a3 + 72) & 1) != 0)
                {
                  int v18 = *(const void **)(a3 + 64);
                  if (v18) {
                    _Block_release(v18);
                  }
                }

                free((void *)a3);
              }
            }
          }
        }

        else
        {
          uint64_t v6 = v8(a1, a2, a3);
        }

        if (v11 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v19 = *(void *)(a2 + 88);
          if (v19)
          {
            uint64_t v20 = v19 - 1;
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v20;
            if (!v20)
            {
              uint64_t v21 = *(void (***)(void))(a2 + 64);
              if (v21)
              {
                *(void *)(a2 + 64) = 0LL;
                v21[2](v21);
                _Block_release(v21);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                unsigned int v22 = *(const void **)(a2 + 64);
                if (v22) {
                  _Block_release(v22);
                }
              }

              free((void *)a2);
            }
          }
        }

        if (v9 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v23 = *(void *)(a1 + 88);
          if (v23)
          {
            uint64_t v24 = v23 - 1;
            *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v24;
            if (!v24)
            {
              uint64_t v25 = *(void (***)(void))(a1 + 64);
              if (v25)
              {
                *(void *)(a1 + 64) = 0LL;
                v25[2](v25);
                _Block_release(v25);
              }

              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                os_log_type_t v26 = *(const void **)(a1 + 64);
                if (v26) {
                  _Block_release(v26);
                }
              }

              free((void *)a1);
            }
          }
        }
      }
    }
  }

  return v6;
}

uint64_t nw_protocol_replace_input_handler_is_valid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      LODWORD(v3) = *(void *)(v3 + 16) != 0LL;
    }
  }

  else
  {
    LODWORD(v3) = 0;
  }

  if (!a2) {
    LODWORD(v3) = 0;
  }
  if (a3) {
    return v3;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_remove_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(a1 + 88);
      if (v5) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = *(void *)(a1 + 24);
      if (v8)
      {
        uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 8);
        if (v9)
        {
          uint64_t v10 = v9(a1, a2);
          if (v6 != &nw_protocol_ref_counted_handle)
          {
LABEL_13:
            if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v12 = *(void *)(a1 + 88);
              if (v12)
              {
                uint64_t v13 = v12 - 1;
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13;
                if (!v13)
                {
                  uint64_t v14 = *(void (***)(void))(a1 + 64);
                  if (v14)
                  {
                    *(void *)(a1 + 64) = 0LL;
                    v14[2](v14);
                    _Block_release(v14);
                  }

                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    uint64_t v15 = *(const void **)(a1 + 64);
                    if (v15) {
                      _Block_release(v15);
                    }
                  }

                  free((void *)a1);
                }
              }
            }

            return v10;
          }

uint64_t nw_protocol_remove_input_handler_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  if (a2)
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 8);
    if (v6)
    {
      uint64_t v7 = *(void **)(a1 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8) {
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
        }
      }

      if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a2 + 88);
        if (v9) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
        }
        uint64_t v5 = v6(a1, a2);
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v11 = *(void *)(a2 + 88);
          if (v11)
          {
            uint64_t v12 = v11 - 1;
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12;
            if (!v12)
            {
              uint64_t v13 = *(void (***)(void))(a2 + 64);
              if (v13)
              {
                *(void *)(a2 + 64) = 0LL;
                v13[2](v13);
                _Block_release(v13);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                uint64_t v14 = *(const void **)(a2 + 64);
                if (v14) {
                  _Block_release(v14);
                }
              }

              free((void *)a2);
            }
          }
        }
      }

      else
      {
        uint64_t v5 = v6(a1, a2);
      }

      if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v15 = *(void *)(a1 + 88);
        if (v15)
        {
          uint64_t v16 = v15 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
          if (!v16)
          {
            uint64_t v17 = *(void (***)(void))(a1 + 64);
            if (v17)
            {
              *(void *)(a1 + 64) = 0LL;
              v17[2](v17);
              _Block_release(v17);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              int v18 = *(const void **)(a1 + 64);
              if (v18) {
                _Block_release(v18);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v5;
}

uint64_t nw_protocol_remove_input_handler_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 8) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_add_listen_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    if (v3 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v4 = *(void *)(a1 + 88);
      if (v4) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v4 + 1;
      }
    }

    if (a2)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      if (v5)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t))(v5 + 232);
        if (v6)
        {
          uint64_t v7 = v6(a1);
          if (v3 != &nw_protocol_ref_counted_handle) {
            return v7;
          }
          goto LABEL_9;
        }
      }

      __nwlog_obj();
      uint64_t v13 = *(const char **)(a1 + 16);
      *(_DWORD *)int buf = 136446722;
      BOOL v40 = "__nw_protocol_add_listen_handler";
      if (!v13) {
        uint64_t v13 = "invalid";
      }
      __int16 v41 = 2082;
      unsigned int v42 = (void *)v13;
      __int16 v43 = 2048;
      uint64_t v44 = a1;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (__nwlog_fault(v14, &type, &v37))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          uint64_t v17 = *(const char **)(a1 + 16);
          if (!v17) {
            uint64_t v17 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_add_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v17;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid add_listen_handler callback";
LABEL_61:
          id v34 = v15;
          os_log_type_t v35 = v16;
          uint32_t v36 = 32;
LABEL_75:
          _os_log_impl(&dword_181A5C000, v34, v35, v18, buf, v36);
          goto LABEL_76;
        }

        if (!v37)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          os_log_type_t v32 = *(const char **)(a1 + 16);
          if (!v32) {
            os_log_type_t v32 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_add_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v32;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid add_listen_handler callback, backtrace limit exceeded";
          goto LABEL_61;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v26 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (!v26) {
            goto LABEL_76;
          }
          os_log_type_t v33 = *(const char **)(a1 + 16);
          if (!v33) {
            os_log_type_t v33 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_add_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v33;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid add_listen_handler callback, no backtrace";
          goto LABEL_61;
        }

        if (v26)
        {
          BOOL v27 = *(const char **)(a1 + 16);
          if (!v27) {
            BOOL v27 = "invalid";
          }
          *(_DWORD *)int buf = 136446978;
          BOOL v40 = "__nw_protocol_add_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v27;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          __int16 v45 = 2082;
          os_log_type_t v46 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s protocol %{public}s (%p) has invalid add_listen_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
      }

uint64_t nw_protocol_add_listen_handler_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  if (a2)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t))(v3 + 232);
    if (v5)
    {
      if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
        return v5(a1);
      }
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
      }
      uint64_t v4 = v5(a1);
      if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8)
        {
          uint64_t v9 = v8 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9;
          if (!v9)
          {
            uint64_t v10 = *(void (***)(void))(a1 + 64);
            if (v10)
            {
              *(void *)(a1 + 64) = 0LL;
              v10[2](v10);
              _Block_release(v10);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              uint64_t v11 = *(const void **)(a1 + 64);
              if (v11) {
                _Block_release(v11);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v4;
}

uint64_t nw_protocol_add_listen_handler_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 232) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_remove_listen_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    if (v3 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v4 = *(void *)(a1 + 88);
      if (v4) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v4 + 1;
      }
    }

    if (a2)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      if (v5)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t))(v5 + 240);
        if (v6)
        {
          uint64_t v7 = v6(a1);
          if (v3 != &nw_protocol_ref_counted_handle) {
            return v7;
          }
          goto LABEL_9;
        }
      }

      __nwlog_obj();
      uint64_t v13 = *(const char **)(a1 + 16);
      *(_DWORD *)int buf = 136446722;
      BOOL v40 = "__nw_protocol_remove_listen_handler";
      if (!v13) {
        uint64_t v13 = "invalid";
      }
      __int16 v41 = 2082;
      unsigned int v42 = (void *)v13;
      __int16 v43 = 2048;
      uint64_t v44 = a1;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (__nwlog_fault(v14, &type, &v37))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          uint64_t v17 = *(const char **)(a1 + 16);
          if (!v17) {
            uint64_t v17 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_remove_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v17;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid remove_listen_handler callback";
LABEL_61:
          id v34 = v15;
          os_log_type_t v35 = v16;
          uint32_t v36 = 32;
LABEL_75:
          _os_log_impl(&dword_181A5C000, v34, v35, v18, buf, v36);
          goto LABEL_76;
        }

        if (!v37)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          os_log_type_t v32 = *(const char **)(a1 + 16);
          if (!v32) {
            os_log_type_t v32 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_remove_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v32;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid remove_listen_handler callback, backtrace limit exceeded";
          goto LABEL_61;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v26 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (!v26) {
            goto LABEL_76;
          }
          os_log_type_t v33 = *(const char **)(a1 + 16);
          if (!v33) {
            os_log_type_t v33 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_remove_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v33;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid remove_listen_handler callback, no backtrace";
          goto LABEL_61;
        }

        if (v26)
        {
          BOOL v27 = *(const char **)(a1 + 16);
          if (!v27) {
            BOOL v27 = "invalid";
          }
          *(_DWORD *)int buf = 136446978;
          BOOL v40 = "__nw_protocol_remove_listen_handler";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v27;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          __int16 v45 = 2082;
          os_log_type_t v46 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s protocol %{public}s (%p) has invalid remove_listen_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
      }

uint64_t nw_protocol_remove_listen_handler_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  if (a2)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t))(v3 + 240);
    if (v5)
    {
      if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
        return v5(a1);
      }
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
      }
      uint64_t v4 = v5(a1);
      if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8)
        {
          uint64_t v9 = v8 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9;
          if (!v9)
          {
            uint64_t v10 = *(void (***)(void))(a1 + 64);
            if (v10)
            {
              *(void *)(a1 + 64) = 0LL;
              v10[2](v10);
              _Block_release(v10);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              uint64_t v11 = *(const void **)(a1 + 64);
              if (v11) {
                _Block_release(v11);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v4;
}

uint64_t nw_protocol_remove_listen_handler_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 240) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_get_input_frames(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v8 = *(void **)(a1 + 40);
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *(void *)(a1 + 88);
      if (v9) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
      }
    }

    if (a2)
    {
      uint64_t v10 = *(void **)(a2 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(a2 + 88);
        if (v11) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v11 + 1;
        }
      }

      if (a6)
      {
        uint64_t v12 = *(void *)(a1 + 24);
        if (v12)
        {
          uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 80);
          if (v13)
          {
            uint64_t v14 = v13(a1, a2);
            if (v10 == &nw_protocol_ref_counted_handle)
            {
LABEL_13:
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v20 = *(void *)(a2 + 88);
                if (v20)
                {
                  uint64_t v21 = v20 - 1;
                  *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v21;
                  if (!v21)
                  {
                    unsigned int v22 = *(void (***)(void))(a2 + 64);
                    if (v22)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v22[2](v22);
                      _Block_release(v22);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      os_log_type_t v23 = *(const void **)(a2 + 64);
                      if (v23) {
                        _Block_release(v23);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }
            }

uint64_t nw_protocol_get_input_frames_quiet( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  if (a6)
  {
    if (a2)
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 80);
      if (v10)
      {
        uint64_t v11 = *(void **)(a1 + 40);
        if (v11 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v12 = *(void *)(a1 + 88);
          if (v12) {
            *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12 + 1;
          }
        }

        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v13 = *(void *)(a2 + 88);
          if (v13) {
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13 + 1;
          }
          uint64_t v8 = v10(a1, a2);
          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v15 = *(void *)(a2 + 88);
            if (v15)
            {
              uint64_t v16 = v15 - 1;
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
              if (!v16)
              {
                uint64_t v17 = *(void (***)(void))(a2 + 64);
                if (v17)
                {
                  *(void *)(a2 + 64) = 0LL;
                  v17[2](v17);
                  _Block_release(v17);
                }

                if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                {
                  int v18 = *(const void **)(a2 + 64);
                  if (v18) {
                    _Block_release(v18);
                  }
                }

                free((void *)a2);
              }
            }
          }
        }

        else
        {
          uint64_t v8 = v10(a1, a2);
        }

        if (v11 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v19 = *(void *)(a1 + 88);
          if (v19)
          {
            uint64_t v20 = v19 - 1;
            *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v20;
            if (!v20)
            {
              uint64_t v21 = *(void (***)(void))(a1 + 64);
              if (v21)
              {
                *(void *)(a1 + 64) = 0LL;
                v21[2](v21);
                _Block_release(v21);
              }

              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                unsigned int v22 = *(const void **)(a1 + 64);
                if (v22) {
                  _Block_release(v22);
                }
              }

              free((void *)a1);
            }
          }
        }
      }
    }
  }

  return v8;
}

uint64_t nw_protocol_get_input_frames_is_valid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      LODWORD(v3) = *(void *)(v3 + 80) != 0LL;
    }
  }

  else
  {
    LODWORD(v3) = 0;
  }

  if (!a2) {
    LODWORD(v3) = 0;
  }
  if (a3) {
    return v3;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_get_output_frames( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v8 = *(void **)(a1 + 40);
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *(void *)(a1 + 88);
      if (v9) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
      }
    }

    if (a2)
    {
      uint64_t v10 = *(void **)(a2 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(a2 + 88);
        if (v11) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v11 + 1;
        }
      }

      if (a6)
      {
        uint64_t v12 = *(void *)(a1 + 24);
        if (v12)
        {
          uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 88);
          if (v13)
          {
            uint64_t v14 = v13(a1, a2);
            if (v10 == &nw_protocol_ref_counted_handle)
            {
LABEL_13:
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v20 = *(void *)(a2 + 88);
                if (v20)
                {
                  uint64_t v21 = v20 - 1;
                  *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v21;
                  if (!v21)
                  {
                    unsigned int v22 = *(void (***)(void))(a2 + 64);
                    if (v22)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v22[2](v22);
                      _Block_release(v22);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      os_log_type_t v23 = *(const void **)(a2 + 64);
                      if (v23) {
                        _Block_release(v23);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }
            }

uint64_t nw_protocol_get_output_frames_quiet( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  if (a6)
  {
    if (a2)
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 88);
      if (v10)
      {
        uint64_t v11 = *(void **)(a1 + 40);
        if (v11 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v12 = *(void *)(a1 + 88);
          if (v12) {
            *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12 + 1;
          }
        }

        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v13 = *(void *)(a2 + 88);
          if (v13) {
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13 + 1;
          }
          uint64_t v8 = v10(a1, a2);
          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v15 = *(void *)(a2 + 88);
            if (v15)
            {
              uint64_t v16 = v15 - 1;
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
              if (!v16)
              {
                uint64_t v17 = *(void (***)(void))(a2 + 64);
                if (v17)
                {
                  *(void *)(a2 + 64) = 0LL;
                  v17[2](v17);
                  _Block_release(v17);
                }

                if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                {
                  int v18 = *(const void **)(a2 + 64);
                  if (v18) {
                    _Block_release(v18);
                  }
                }

                free((void *)a2);
              }
            }
          }
        }

        else
        {
          uint64_t v8 = v10(a1, a2);
        }

        if (v11 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v19 = *(void *)(a1 + 88);
          if (v19)
          {
            uint64_t v20 = v19 - 1;
            *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v20;
            if (!v20)
            {
              uint64_t v21 = *(void (***)(void))(a1 + 64);
              if (v21)
              {
                *(void *)(a1 + 64) = 0LL;
                v21[2](v21);
                _Block_release(v21);
              }

              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                unsigned int v22 = *(const void **)(a1 + 64);
                if (v22) {
                  _Block_release(v22);
                }
              }

              free((void *)a1);
            }
          }
        }
      }
    }
  }

  return v8;
}

uint64_t nw_protocol_get_output_frames_is_valid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      LODWORD(v3) = *(void *)(v3 + 88) != 0LL;
    }
  }

  else
  {
    LODWORD(v3) = 0;
  }

  if (!a2) {
    LODWORD(v3) = 0;
  }
  if (a3) {
    return v3;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    if (v3 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v4 = *(void *)(a1 + 88);
      if (v4) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v4 + 1;
      }
    }

    if (a2)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      if (v5)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t))(v5 + 96);
        if (v6)
        {
          uint64_t v7 = v6(a1);
          if (v3 != &nw_protocol_ref_counted_handle) {
            return v7;
          }
          goto LABEL_9;
        }
      }

      __nwlog_obj();
      uint64_t v13 = *(const char **)(a1 + 16);
      *(_DWORD *)int buf = 136446722;
      BOOL v40 = "__nw_protocol_finalize_output_frames";
      if (!v13) {
        uint64_t v13 = "invalid";
      }
      __int16 v41 = 2082;
      unsigned int v42 = (void *)v13;
      __int16 v43 = 2048;
      uint64_t v44 = a1;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (__nwlog_fault(v14, &type, &v37))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          uint64_t v17 = *(const char **)(a1 + 16);
          if (!v17) {
            uint64_t v17 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v17;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_61:
          id v34 = v15;
          os_log_type_t v35 = v16;
          uint32_t v36 = 32;
LABEL_75:
          _os_log_impl(&dword_181A5C000, v34, v35, v18, buf, v36);
          goto LABEL_76;
        }

        if (!v37)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          os_log_type_t v32 = *(const char **)(a1 + 16);
          if (!v32) {
            os_log_type_t v32 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v32;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
          goto LABEL_61;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v26 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (!v26) {
            goto LABEL_76;
          }
          os_log_type_t v33 = *(const char **)(a1 + 16);
          if (!v33) {
            os_log_type_t v33 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v33;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
          goto LABEL_61;
        }

        if (v26)
        {
          os_log_type_t v27 = *(const char **)(a1 + 16);
          if (!v27) {
            os_log_type_t v27 = "invalid";
          }
          *(_DWORD *)int buf = 136446978;
          BOOL v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v27;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          __int16 v45 = 2082;
          BOOL v46 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
      }

uint64_t nw_protocol_finalize_output_frames_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  if (a2)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t))(v3 + 96);
    if (v5)
    {
      if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
        return v5(a1);
      }
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
      }
      uint64_t v4 = v5(a1);
      if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8)
        {
          uint64_t v9 = v8 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9;
          if (!v9)
          {
            uint64_t v10 = *(void (***)(void))(a1 + 64);
            if (v10)
            {
              *(void *)(a1 + 64) = 0LL;
              v10[2](v10);
              _Block_release(v10);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              uint64_t v11 = *(const void **)(a1 + 64);
              if (v11) {
                _Block_release(v11);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v4;
}

uint64_t nw_protocol_finalize_output_frames_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 96) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_get_parameters_quiet(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 112);
  if (!v3) {
    return 0LL;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
    return v3(a1);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5) {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
  }
  uint64_t v6 = v3(a1);
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7)
    {
      uint64_t v8 = v7 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8;
      if (!v8)
      {
        uint64_t v9 = *(void (***)(void))(a1 + 64);
        if (v9)
        {
          *(void *)(a1 + 64) = 0LL;
          v9[2](v9);
          _Block_release(v9);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v10 = *(const void **)(a1 + 64);
          if (v10) {
            _Block_release(v10);
          }
        }

        free((void *)a1);
      }
    }
  }

  return v6;
}

BOOL nw_protocol_get_parameters_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 112) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_get_path(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v32 = "__nw_protocol_get_path";
    int v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_path";
          os_log_type_t v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v32 = "__nw_protocol_get_path";
            __int16 v33 = 2082;
            id v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v26)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_path";
          os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_path";
          os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

uint64_t nw_protocol_get_path_quiet(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 120);
  if (!v3) {
    return 0LL;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
    return v3(a1);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5) {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
  }
  uint64_t v6 = v3(a1);
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7)
    {
      uint64_t v8 = v7 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8;
      if (!v8)
      {
        uint64_t v9 = *(void (***)(void))(a1 + 64);
        if (v9)
        {
          *(void *)(a1 + 64) = 0LL;
          v9[2](v9);
          _Block_release(v9);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v10 = *(const void **)(a1 + 64);
          if (v10) {
            _Block_release(v10);
          }
        }

        free((void *)a1);
      }
    }
  }

  return v6;
}

BOOL nw_protocol_get_path_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 120) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_get_remote_endpoint_quiet(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 136);
  if (!v3) {
    return 0LL;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
    return v3(a1);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5) {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
  }
  uint64_t v6 = v3(a1);
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7)
    {
      uint64_t v8 = v7 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8;
      if (!v8)
      {
        uint64_t v9 = *(void (***)(void))(a1 + 64);
        if (v9)
        {
          *(void *)(a1 + 64) = 0LL;
          v9[2](v9);
          _Block_release(v9);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v10 = *(const void **)(a1 + 64);
          if (v10) {
            _Block_release(v10);
          }
        }

        free((void *)a1);
      }
    }
  }

  return v6;
}

BOOL nw_protocol_get_remote_endpoint_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 136) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_get_local_endpoint(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
    int v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
            __int16 v33 = 2082;
            id v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v26)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

uint64_t nw_protocol_get_local_endpoint_quiet(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 128);
  if (!v3) {
    return 0LL;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
    return v3(a1);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5) {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
  }
  uint64_t v6 = v3(a1);
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7)
    {
      uint64_t v8 = v7 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8;
      if (!v8)
      {
        uint64_t v9 = *(void (***)(void))(a1 + 64);
        if (v9)
        {
          *(void *)(a1 + 64) = 0LL;
          v9[2](v9);
          _Block_release(v9);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v10 = *(const void **)(a1 + 64);
          if (v10) {
            _Block_release(v10);
          }
        }

        free((void *)a1);
      }
    }
  }

  return v6;
}

BOOL nw_protocol_get_local_endpoint_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 128) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_get_output_local_endpoint(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v32 = "__nw_protocol_get_output_local_endpoint";
    int v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_output_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v32 = "__nw_protocol_get_output_local_endpoint";
            __int16 v33 = 2082;
            id v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v26)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_output_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_output_local_endpoint";
          os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

uint64_t nw_protocol_get_output_local_endpoint_quiet(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 200);
  if (!v3) {
    return 0LL;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
    return v3(a1);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5) {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
  }
  uint64_t v6 = v3(a1);
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7)
    {
      uint64_t v8 = v7 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8;
      if (!v8)
      {
        uint64_t v9 = *(void (***)(void))(a1 + 64);
        if (v9)
        {
          *(void *)(a1 + 64) = 0LL;
          v9[2](v9);
          _Block_release(v9);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v10 = *(const void **)(a1 + 64);
          if (v10) {
            _Block_release(v10);
          }
        }

        free((void *)a1);
      }
    }
  }

  return v6;
}

BOOL nw_protocol_get_output_local_endpoint_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 200) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_get_output_interface(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v32 = "__nw_protocol_get_output_interface";
    int v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_output_interface";
          os_log_type_t v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v32 = "__nw_protocol_get_output_interface";
            __int16 v33 = 2082;
            id v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v26)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_output_interface";
          os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_get_output_interface";
          os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

uint64_t nw_protocol_get_output_interface_quiet(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 208);
  if (!v3) {
    return 0LL;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
    return v3(a1);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5) {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
  }
  uint64_t v6 = v3(a1);
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7)
    {
      uint64_t v8 = v7 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8;
      if (!v8)
      {
        uint64_t v9 = *(void (***)(void))(a1 + 64);
        if (v9)
        {
          *(void *)(a1 + 64) = 0LL;
          v9[2](v9);
          _Block_release(v9);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v10 = *(const void **)(a1 + 64);
          if (v10) {
            _Block_release(v10);
          }
        }

        free((void *)a1);
      }
    }
  }

  return v6;
}

BOOL nw_protocol_get_output_interface_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 208) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(a1 + 88);
      if (v5) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = *(void *)(a1 + 24);
      if (v8)
      {
        uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 24);
        if (v9)
        {
          uint64_t v10 = v9(a1, a2);
          if (v6 != &nw_protocol_ref_counted_handle)
          {
LABEL_13:
            if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v12 = *(void *)(a1 + 88);
              if (v12)
              {
                uint64_t v13 = v12 - 1;
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13;
                if (!v13)
                {
                  uint64_t v14 = *(void (***)(void))(a1 + 64);
                  if (v14)
                  {
                    *(void *)(a1 + 64) = 0LL;
                    v14[2](v14);
                    _Block_release(v14);
                  }

                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    os_log_type_t v15 = *(const void **)(a1 + 64);
                    if (v15) {
                      _Block_release(v15);
                    }
                  }

                  free((void *)a1);
                }
              }
            }

            return v10;
          }

uint64_t nw_protocol_connect_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  if (a2)
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 24);
    if (v6)
    {
      uint64_t v7 = *(void **)(a1 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8) {
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
        }
      }

      if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a2 + 88);
        if (v9) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
        }
        uint64_t v5 = v6(a1, a2);
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v11 = *(void *)(a2 + 88);
          if (v11)
          {
            uint64_t v12 = v11 - 1;
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12;
            if (!v12)
            {
              uint64_t v13 = *(void (***)(void))(a2 + 64);
              if (v13)
              {
                *(void *)(a2 + 64) = 0LL;
                v13[2](v13);
                _Block_release(v13);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                uint64_t v14 = *(const void **)(a2 + 64);
                if (v14) {
                  _Block_release(v14);
                }
              }

              free((void *)a2);
            }
          }
        }
      }

      else
      {
        uint64_t v5 = v6(a1, a2);
      }

      if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v15 = *(void *)(a1 + 88);
        if (v15)
        {
          uint64_t v16 = v15 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
          if (!v16)
          {
            uint64_t v17 = *(void (***)(void))(a1 + 64);
            if (v17)
            {
              *(void *)(a1 + 64) = 0LL;
              v17[2](v17);
              _Block_release(v17);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              int v18 = *(const void **)(a1 + 64);
              if (v18) {
                _Block_release(v18);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v5;
}

uint64_t nw_protocol_connect_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 24) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_connected_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 40);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_connected_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 40) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_disconnect(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 32);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_disconnect";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_disconnect";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_disconnect";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_disconnect";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_disconnect";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_disconnect_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 32);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_disconnect_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 32) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_disconnected(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 48);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_disconnected";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_disconnected";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_disconnected";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_disconnected";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_disconnected";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_disconnected_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 48);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_disconnected_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 48) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_input_available(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 64);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_input_available";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_input_available";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_input_available_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 64);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_input_available_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 64) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_output_available(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 72);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_output_available";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_output_available";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_output_available";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_output_available";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_output_available";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_output_available_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 72);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_output_available_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 72) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_input_finished(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 184);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_input_finished";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_finished";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_finished";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_input_finished";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_finished";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_input_finished_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 184);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_input_finished_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 184) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_output_finished(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 192);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_output_finished";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_output_finished";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_output_finished";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_output_finished";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_output_finished";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_output_finished_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 192);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_output_finished_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 192) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_input_flush(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 264);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_input_flush";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_flush";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_flush";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_input_flush";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid input_flush callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_input_flush";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_input_flush_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 264);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_input_flush_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 264) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_error(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        uint64_t v9 = *(void (**)(void *, uint64_t))(v8 + 56);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      int v18 = *(const char **)(v3 + 16);
      *(_DWORD *)int buf = 136446722;
      unsigned int v42 = "__nw_protocol_error";
      if (!v18) {
        int v18 = "invalid";
      }
      __int16 v43 = 2082;
      uint64_t v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_error";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid error callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          __int16 v37 = *(const char **)(v3 + 16);
          if (!v37) {
            __int16 v37 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_error";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            os_log_type_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              os_log_type_t v32 = "invalid";
            }
            *(_DWORD *)int buf = 136446978;
            unsigned int v42 = "__nw_protocol_error";
            __int16 v43 = 2082;
            uint64_t v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          BOOL v38 = *(const char **)(v3 + 16);
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          unsigned int v42 = "__nw_protocol_error";
          __int16 v43 = 2082;
          uint64_t v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

void nw_protocol_error_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(v3 + 56);
        if (v5)
        {
          uint64_t v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
            }
          }

          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v10;
                if (!v10)
                {
                  uint64_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0LL;
                    v11[2](v11);
                    _Block_release(v11);
                  }

                  if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                  {
                    uint64_t v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }

                  free((void *)a2);
                }
              }
            }
          }

          else
          {
            v5(a1, a2);
          }

          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v14;
              if (!v14)
              {
                uint64_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v15[2](v15);
                  _Block_release(v15);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_error_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 56) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_reset(uint64_t a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(a1 + 88);
      if (v5) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = *(void *)(a1 + 24);
      if (v8)
      {
        uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 256);
        if (v9)
        {
          uint64_t v10 = v9(a1, a2);
          if (v6 != &nw_protocol_ref_counted_handle)
          {
LABEL_13:
            if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v12 = *(void *)(a1 + 88);
              if (v12)
              {
                uint64_t v13 = v12 - 1;
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13;
                if (!v13)
                {
                  uint64_t v14 = *(void (***)(void))(a1 + 64);
                  if (v14)
                  {
                    *(void *)(a1 + 64) = 0LL;
                    v14[2](v14);
                    _Block_release(v14);
                  }

                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    uint64_t v15 = *(const void **)(a1 + 64);
                    if (v15) {
                      _Block_release(v15);
                    }
                  }

                  free((void *)a1);
                }
              }
            }

            return v10;
          }

uint64_t nw_protocol_reset_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  if (a2)
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 256);
    if (v6)
    {
      uint64_t v7 = *(void **)(a1 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8) {
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
        }
      }

      if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a2 + 88);
        if (v9) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
        }
        uint64_t v5 = v6(a1, a2);
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v11 = *(void *)(a2 + 88);
          if (v11)
          {
            uint64_t v12 = v11 - 1;
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12;
            if (!v12)
            {
              uint64_t v13 = *(void (***)(void))(a2 + 64);
              if (v13)
              {
                *(void *)(a2 + 64) = 0LL;
                v13[2](v13);
                _Block_release(v13);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                uint64_t v14 = *(const void **)(a2 + 64);
                if (v14) {
                  _Block_release(v14);
                }
              }

              free((void *)a2);
            }
          }
        }
      }

      else
      {
        uint64_t v5 = v6(a1, a2);
      }

      if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v15 = *(void *)(a1 + 88);
        if (v15)
        {
          uint64_t v16 = v15 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
          if (!v16)
          {
            uint64_t v17 = *(void (***)(void))(a1 + 64);
            if (v17)
            {
              *(void *)(a1 + 64) = 0LL;
              v17[2](v17);
              _Block_release(v17);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              int v18 = *(const void **)(a1 + 64);
              if (v18) {
                _Block_release(v18);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v5;
}

uint64_t nw_protocol_reset_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 256) != 0LL;
    }
  }

  else
  {
    LODWORD(v2) = 0;
  }

  if (a2) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void nw_protocol_get_message_properties(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = a2;
    uint64_t v4 = (uint64_t)a1;
    uint64_t v5 = (void *)a1[5];
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = a1[11];
      if (v6) {
        a1[11] = v6 + 1;
      }
    }

    if (a2)
    {
      uint64_t v7 = *(void **)(a2 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a2 + 88);
        if (v8) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
        }
      }

      if (a3)
      {
        uint64_t v9 = a1[3];
        if (v9)
        {
          uint64_t v10 = *(void (**)(void *, uint64_t))(v9 + 248);
          if (v10)
          {
            v10(a1, a2);
            goto LABEL_13;
          }
        }

        __nwlog_obj();
        uint64_t v19 = *(const char **)(v4 + 16);
        *(_DWORD *)int buf = 136446722;
        uint64_t v50 = "__nw_protocol_get_message_properties";
        if (!v19) {
          uint64_t v19 = "invalid";
        }
        __int16 v51 = 2082;
        os_log_type_t v52 = (void *)v19;
        __int16 v53 = 2048;
        uint64_t v54 = v4;
        os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v47 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_108;
          }
          os_log_type_t v23 = *(const char **)(v4 + 16);
          if (!v23) {
            os_log_type_t v23 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          uint64_t v50 = "__nw_protocol_get_message_properties";
          __int16 v51 = 2082;
          os_log_type_t v52 = (void *)v23;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback";
LABEL_87:
          uint64_t v44 = v21;
          os_log_type_t v45 = v22;
          uint32_t v46 = 32;
LABEL_107:
          _os_log_impl(&dword_181A5C000, v44, v45, v24, buf, v46);
          goto LABEL_108;
        }

        if (!v47)
        {
          os_log_type_t v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_108;
          }
          unsigned int v42 = *(const char **)(v4 + 16);
          if (!v42) {
            unsigned int v42 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          uint64_t v50 = "__nw_protocol_get_message_properties";
          __int16 v51 = 2082;
          os_log_type_t v52 = (void *)v42;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, backtrace limit exceeded";
          goto LABEL_87;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v34 = os_log_type_enabled(v21, type);
        if (!backtrace_string)
        {
          if (!v34) {
            goto LABEL_108;
          }
          char v43 = *(const char **)(v4 + 16);
          if (!v43) {
            char v43 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          uint64_t v50 = "__nw_protocol_get_message_properties";
          __int16 v51 = 2082;
          os_log_type_t v52 = (void *)v43;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          os_log_type_t v24 = "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, no backtrace";
          goto LABEL_87;
        }

        if (v34)
        {
          BOOL v35 = *(const char **)(v4 + 16);
          if (!v35) {
            BOOL v35 = "invalid";
          }
          *(_DWORD *)int buf = 136446978;
          uint64_t v50 = "__nw_protocol_get_message_properties";
          __int16 v51 = 2082;
          os_log_type_t v52 = (void *)v35;
          __int16 v53 = 2048;
          uint64_t v54 = v4;
          __int16 v55 = 2082;
          os_log_type_t v56 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
LABEL_108:
        if (!v20) {
          goto LABEL_13;
        }
        goto LABEL_109;
      }

      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "__nw_protocol_get_message_properties";
      os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_108;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v50 = "__nw_protocol_get_message_properties";
        os_log_type_t v24 = "%{public}s called with null message_properties";
      }

      else if (v47)
      {
        BOOL v40 = (char *)__nw_create_backtrace_string();
        BOOL v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v41 = os_log_type_enabled(v31, type);
        if (v40)
        {
          if (v41)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v50 = "__nw_protocol_get_message_properties";
            __int16 v51 = 2082;
            os_log_type_t v52 = v40;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null message_properties, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v40);
          if (!v20)
          {
LABEL_13:
            if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v15 = *(void *)(v3 + 88);
              if (v15)
              {
                uint64_t v16 = v15 - 1;
                *(void *)(v3 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
                if (!v16)
                {
                  uint64_t v17 = *(void (***)(void))(v3 + 64);
                  if (v17)
                  {
                    *(void *)(v3 + 64) = 0LL;
                    v17[2](v17);
                    _Block_release(v17);
                  }

                  if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                  {
                    int v18 = *(const void **)(v3 + 64);
                    if (v18) {
                      _Block_release(v18);
                    }
                  }

void nw_protocol_get_message_properties_quiet(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4)
    {
      if (a3)
      {
        if (a2)
        {
          uint64_t v6 = *(void (**)(uint64_t, uint64_t))(v4 + 248);
          if (v6)
          {
            uint64_t v7 = *(void **)(a1 + 40);
            if (v7 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v8 = *(void *)(a1 + 88);
              if (v8) {
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
              }
            }

            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9) {
                *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
              }
              v6(a1, a2);
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v10 = *(void *)(a2 + 88);
                if (v10)
                {
                  uint64_t v11 = v10 - 1;
                  *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v11;
                  if (!v11)
                  {
                    uint64_t v12 = *(void (***)(void))(a2 + 64);
                    if (v12)
                    {
                      *(void *)(a2 + 64) = 0LL;
                      v12[2](v12);
                      _Block_release(v12);
                    }

                    if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                    {
                      uint64_t v13 = *(const void **)(a2 + 64);
                      if (v13) {
                        _Block_release(v13);
                      }
                    }

                    free((void *)a2);
                  }
                }
              }
            }

            else
            {
              v6(a1, a2);
            }

            if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v14 = *(void *)(a1 + 88);
              if (v14)
              {
                uint64_t v15 = v14 - 1;
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v15;
                if (!v15)
                {
                  uint64_t v16 = *(void (***)(void))(a1 + 64);
                  if (v16)
                  {
                    *(void *)(a1 + 64) = 0LL;
                    v16[2](v16);
                    _Block_release(v16);
                  }

                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    uint64_t v17 = *(const void **)(a1 + 64);
                    if (v17) {
                      _Block_release(v17);
                    }
                  }

                  free((void *)a1);
                }
              }
            }
          }
        }
      }
    }
  }

uint64_t nw_protocol_get_message_properties_is_valid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      LODWORD(v3) = *(void *)(v3 + 248) != 0LL;
    }
  }

  else
  {
    LODWORD(v3) = 0;
  }

  if (!a2) {
    LODWORD(v3) = 0;
  }
  if (a3) {
    return v3;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_protocol_copy_info(uint64_t a1, int a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    if (v3 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v4 = *(void *)(a1 + 88);
      if (v4) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v4 + 1;
      }
    }

    if (a2)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      if (v5)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t))(v5 + 224);
        if (v6)
        {
          uint64_t v7 = v6(a1);
          if (v3 != &nw_protocol_ref_counted_handle) {
            return v7;
          }
          goto LABEL_9;
        }
      }

      __nwlog_obj();
      uint64_t v13 = *(const char **)(a1 + 16);
      *(_DWORD *)int buf = 136446722;
      BOOL v40 = "__nw_protocol_copy_info";
      if (!v13) {
        uint64_t v13 = "invalid";
      }
      __int16 v41 = 2082;
      unsigned int v42 = (void *)v13;
      __int16 v43 = 2048;
      uint64_t v44 = a1;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (__nwlog_fault(v14, &type, &v37))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          uint64_t v17 = *(const char **)(a1 + 16);
          if (!v17) {
            uint64_t v17 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_copy_info";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v17;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback";
LABEL_61:
          BOOL v34 = v15;
          os_log_type_t v35 = v16;
          uint32_t v36 = 32;
LABEL_75:
          _os_log_impl(&dword_181A5C000, v34, v35, v18, buf, v36);
          goto LABEL_76;
        }

        if (!v37)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          os_log_type_t v32 = *(const char **)(a1 + 16);
          if (!v32) {
            os_log_type_t v32 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_copy_info";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v32;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback, backtrace limit exceeded";
          goto LABEL_61;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v26 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (!v26) {
            goto LABEL_76;
          }
          __int16 v33 = *(const char **)(a1 + 16);
          if (!v33) {
            __int16 v33 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          BOOL v40 = "__nw_protocol_copy_info";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v33;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          int v18 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback, no backtrace";
          goto LABEL_61;
        }

        if (v26)
        {
          os_log_type_t v27 = *(const char **)(a1 + 16);
          if (!v27) {
            os_log_type_t v27 = "invalid";
          }
          *(_DWORD *)int buf = 136446978;
          BOOL v40 = "__nw_protocol_copy_info";
          __int16 v41 = 2082;
          unsigned int v42 = (void *)v27;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          __int16 v45 = 2082;
          uint32_t v46 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s protocol %{public}s (%p) has invalid copy_info callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
      }

uint64_t nw_protocol_copy_info_quiet(uint64_t a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 224);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = *(void **)(a1 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v6 = *(void *)(a1 + 88);
    if (v6) {
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v6 + 1;
    }
  }

  if (a2)
  {
    uint64_t v7 = v4(a1);
    if (v5 != &nw_protocol_ref_counted_handle) {
      return v7;
    }
    goto LABEL_9;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v22 = "__nw_protocol_copy_info";
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v13, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "__nw_protocol_copy_info";
      os_log_type_t v16 = "%{public}s called with null type";
LABEL_33:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      goto LABEL_34;
    }

    if (!v19)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "__nw_protocol_copy_info";
      os_log_type_t v16 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v22 = "__nw_protocol_copy_info";
      os_log_type_t v16 = "%{public}s called with null type, no backtrace";
      goto LABEL_33;
    }

    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v22 = "__nw_protocol_copy_info";
      __int16 v23 = 2082;
      os_log_type_t v24 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
  }

BOOL nw_protocol_copy_info_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 224) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_supports_external_data(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v32 = "__nw_protocol_supports_external_data";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_supports_external_data";
          os_log_type_t v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v32 = "__nw_protocol_supports_external_data";
            __int16 v33 = 2082;
            BOOL v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v26)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_supports_external_data";
          os_log_type_t v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        char v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v32 = "__nw_protocol_supports_external_data";
          os_log_type_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

uint64_t nw_protocol_supports_external_data_quiet(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 176);
  if (!v3) {
    return 0LL;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle) {
    return v3(a1);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5) {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
  }
  uint64_t v6 = v3(a1);
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7)
    {
      uint64_t v8 = v7 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8;
      if (!v8)
      {
        uint64_t v9 = *(void (***)(void))(a1 + 64);
        if (v9)
        {
          *(void *)(a1 + 64) = 0LL;
          v9[2](v9);
          _Block_release(v9);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          uint64_t v10 = *(const void **)(a1 + 64);
          if (v10) {
            _Block_release(v10);
          }
        }

        free((void *)a1);
      }
    }
  }

  return v6;
}

BOOL nw_protocol_supports_external_data_is_valid(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(void *)(v1 + 176) != 0LL;
  }

  return result;
}

uint64_t nw_protocol_waiting_for_output(uint64_t a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(a1 + 88);
      if (v5) {
        *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v5 + 1;
      }
    }

    if (a2)
    {
      uint64_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v7 + 1;
        }
      }

      uint64_t v8 = *(void *)(a1 + 24);
      if (v8)
      {
        uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 216);
        if (v9)
        {
          uint64_t v10 = v9(a1, a2);
          if (v6 != &nw_protocol_ref_counted_handle)
          {
LABEL_13:
            if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v12 = *(void *)(a1 + 88);
              if (v12)
              {
                uint64_t v13 = v12 - 1;
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v13;
                if (!v13)
                {
                  uint64_t v14 = *(void (***)(void))(a1 + 64);
                  if (v14)
                  {
                    *(void *)(a1 + 64) = 0LL;
                    v14[2](v14);
                    _Block_release(v14);
                  }

                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    os_log_type_t v15 = *(const void **)(a1 + 64);
                    if (v15) {
                      _Block_release(v15);
                    }
                  }

                  free((void *)a1);
                }
              }
            }

            return v10;
          }

uint64_t nw_protocol_waiting_for_output_quiet(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  if (a2)
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 216);
    if (v6)
    {
      uint64_t v7 = *(void **)(a1 + 40);
      if (v7 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8) {
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v8 + 1;
        }
      }

      if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v9 = *(void *)(a2 + 88);
        if (v9) {
          *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v9 + 1;
        }
        uint64_t v5 = v6(a1, a2);
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v11 = *(void *)(a2 + 88);
          if (v11)
          {
            uint64_t v12 = v11 - 1;
            *(void *)(a2 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v12;
            if (!v12)
            {
              uint64_t v13 = *(void (***)(void))(a2 + 64);
              if (v13)
              {
                *(void *)(a2 + 64) = 0LL;
                v13[2](v13);
                _Block_release(v13);
              }

              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                uint64_t v14 = *(const void **)(a2 + 64);
                if (v14) {
                  _Block_release(v14);
                }
              }

              free((void *)a2);
            }
          }
        }
      }

      else
      {
        uint64_t v5 = v6(a1, a2);
      }

      if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v15 = *(void *)(a1 + 88);
        if (v15)
        {
          uint64_t v16 = v15 - 1;
          *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 96), 8) = v16;
          if (!v16)
          {
            uint64_t v17 = *(void (***)(void))(a1 + 64);
            if (v17)
            {
              *(void *)(a1 + 64) = 0LL;
              v17[2](v17);
              _Block_release(v17);
            }

            if ((*(_BYTE *)(a1 + 72) & 1) != 0)
            {
              BOOL v18 = *(const void **)(a1 + 64);
              if (v18) {
                _Block_release(v18);
              }
            }

            free((void *)a1);
          }
        }
      }
    }
  }

  return v5;
}