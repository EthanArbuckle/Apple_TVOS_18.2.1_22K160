void __nwphRunProbe_block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  os_log_s *v10;
  os_log_s *v11;
  os_log_s *v12;
  id v13;
  os_log_s *v14;
  os_log_s *v15;
  void *v16;
  void *v17;
  int v18;
  const char *v19;
  __int16 v20;
  id v21;
  uint64_t v22;
  v22 = *MEMORY[0x1895F89C0];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    v18 = 136446210;
    v19 = "nwphRunProbe_block_invoke";
    _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s Probe complete", (uint8_t *)&v18, 0xCu);
  }

  if (v9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v18 = 136446466;
      v19 = "nwphRunProbe_block_invoke";
      v20 = 2112;
      v21 = v9;
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Got error: %@", (uint8_t *)&v18, 0x16u);
    }
  }

  if (!v8) {
    goto LABEL_20;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    v18 = 136446466;
    v19 = "nwphRunProbe_block_invoke";
    v20 = 2112;
    v21 = v8;
    _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Got response: %@", (uint8_t *)&v18, 0x16u);
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_20;
  }
  v13 = v8;
  if ([v13 statusCode] != 200)
  {

LABEL_20:
    v16 = *(void **)(a1 + 32);
    if (v9)
    {
      [v9 domain];
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      nw_activity_complete_with_reason_and_underlying_error(v16, 3u, (int)v17, [v9 code]);
    }

    else
    {
      nw_activity_complete_with_reason_and_underlying_error(*(void **)(a1 + 32), 3u, 0, 0);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
    [*(id *)(a1 + 40) invalidateAndCancel];
    goto LABEL_24;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    v18 = 136446210;
    v19 = "nwphRunProbe_block_invoke";
    _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, "%{public}s Got back 200 OK", (uint8_t *)&v18, 0xCu);
  }

  if (v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v18 = 136446466;
      v19 = "nwphRunProbe_block_invoke";
      v20 = 2112;
      v21 = v7;
      _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, "%{public}s Got back data: %@", (uint8_t *)&v18, 0x16u);
    }
  }

  nw_activity_complete_with_reason(*(void **)(a1 + 32), 2u);
  (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  [*(id *)(a1 + 40) invalidateAndCancel];

LABEL_24:
}

void __nwphRunECHProbes_block_invoke_385(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (os_log_s *)(id)gLogObj;
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_INFO);
  if (a2)
  {
    if (v5)
    {
      v6 = "regional";
      if (!*(_BYTE *)(a1 + 80)) {
        v6 = "generic";
      }
      *(_DWORD *)buf = 136446466;
      v18 = "nwphRunECHProbes_block_invoke";
      __int16 v19 = 2082;
      v20 = v6;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s Second %{public}s ECH probe succeeded, starting third",  buf,  0x16u);
    }

    if (*(_BYTE *)(a1 + 80)) {
      int v7 = 4;
    }
    else {
      int v7 = 7;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v7;
    uint64_t v8 = *(void *)(a1 + 72);
    int v9 = *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL);
    v13[0] = MEMORY[0x1895F87A8];
    v13[2] = __nwphRunECHProbes_block_invoke_386;
    v13[3] = &unk_189BB9358;
    v10 = *(void **)(a1 + 32);
    v11 = *(void **)(a1 + 40);
    v13[1] = 3221225472LL;
    uint64_t v15 = v8;
    char v16 = *(_BYTE *)(a1 + 80);
    id v14 = *(id *)(a1 + 48);
    nwphRunProbe(v10, 0, v11, v9, v13);
  }

  else
  {
    if (v5)
    {
      v12 = "regional";
      if (!*(_BYTE *)(a1 + 80)) {
        v12 = "generic";
      }
      *(_DWORD *)buf = 136446466;
      v18 = "nwphRunECHProbes_block_invoke";
      __int16 v19 = 2082;
      v20 = v12;
      _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_INFO, "%{public}s Second %{public}s ECH probe failed", buf, 0x16u);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

uint64_t __nwphRunECHProbes_block_invoke_386(uint64_t a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (os_log_s *)(id)gLogObj;
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_INFO);
  if (a2)
  {
    if (v5)
    {
      v6 = "regional";
      if (!*(_BYTE *)(a1 + 48)) {
        v6 = "generic";
      }
      int v9 = 136446466;
      v10 = "nwphRunECHProbes_block_invoke";
      __int16 v11 = 2082;
      v12 = v6;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s Third %{public}s ECH probe succeeded",  (uint8_t *)&v9,  0x16u);
    }
  }

  else if (v5)
  {
    int v7 = "regional";
    if (!*(_BYTE *)(a1 + 48)) {
      int v7 = "generic";
    }
    int v9 = 136446466;
    v10 = "nwphRunECHProbes_block_invoke";
    __int16 v11 = 2082;
    v12 = v7;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s Third %{public}s ECH probe failed",  (uint8_t *)&v9,  0x16u);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __nwphRunProbes_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    BOOL v5 = "failed";
    if (a2) {
      BOOL v5 = "succeeded";
    }
    int v6 = 136446466;
    int v7 = "nwphRunProbes_block_invoke_2";
    __int16 v8 = 2082;
    int v9 = v5;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s ECH probes %{public}s, saving",  (uint8_t *)&v6,  0x16u);
  }

  nwphProbesComplete(a2, *(void **)(a1 + 32), *(void **)(a1 + 40));
}

void nwphProbesComplete(char a1, void *a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  id v6 = a3;
  int v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nwphProbesComplete";
    __int16 v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwphProbesComplete";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null parent_activity", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nwphProbesComplete";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null parent_activity, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v11) {
          goto LABEL_4;
        }
LABEL_39:
        free(v11);
        goto LABEL_4;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwphProbesComplete";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null parent_activity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwphProbesComplete";
        _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null parent_activity, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181F98438( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t __Block_byref_object_copy__23863(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__23864(uint64_t a1)
{
}

void __nwphProbesComplete_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  v2 = (void *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:1];
  [MEMORY[0x189607968] numberWithBool:*(unsigned __int8 *)(a1 + 48)];
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  [NSString stringWithUTF8String:nw_setting_ech_probe_enabled];
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 setValue:v3 forKey:v4];

  addNewNetworkdSettings(v2, 0);
  if (*(_BYTE *)(a1 + 48)) {
    uint32_t v5 = 2;
  }
  else {
    uint32_t v5 = 3;
  }
  nw_activity_complete_with_reason(*(void **)(a1 + 32), v5);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(unsigned __int8 *)(a1 + 48);
    uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    int v11 = 136446722;
    v12 = "nwphProbesComplete_block_invoke";
    __int16 v13 = 1024;
    int v14 = v7;
    __int16 v15 = 2112;
    uint64_t v16 = v8;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s Probes complete (success: %u). Finished with transaction %@",  (uint8_t *)&v11,  0x1Cu);
  }

  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = 0LL;

  gRunningProbes = 0;
}

uint64_t network_config_cellular_blocked_observer_create(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136446210;
    int v7 = "network_config_cellular_blocked_observer_create";
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s creating cellular blocked observer",  (uint8_t *)&v6,  0xCu);
  }

  return network_config_policy_observer_create(1, a1, a2);
}

uint64_t network_config_policy_observer_create(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if (a3)
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      uint64_t v21 = 0LL;
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = ___ZL37network_config_policy_observer_create34network_config_policy_event_type_tP16dispatch_queue_sU13block_pointerFvPvS2_S2_E_block_invoke;
      block[3] = &unk_189BB9620;
      int v17 = a1;
      block[5] = buf;
      block[6] = a2;
      void block[4] = a3;
      dispatch_sync((dispatch_queue_t)nw_policy_event_queue(void)::queue, block);
      uint64_t v6 = *(void *)(*(void *)&buf[8] + 24LL);
      _Block_object_dispose(buf, 8);
      return v6;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (v19 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      if (os_log_type_enabled(v9, v19))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
        int v11 = "%{public}s called with null block";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v18)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      if (os_log_type_enabled(v9, v19))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
        int v11 = "%{public}s called with null block, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v19;
    BOOL v15 = os_log_type_enabled(v9, v19);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
        int v11 = "%{public}s called with null block, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      int v14 = "%{public}s called with null block, dumping backtrace:%{public}s";
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v19 = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (v19 != OS_LOG_TYPE_FAULT)
  {
    if (!v18)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      if (os_log_type_enabled(v9, v19))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
        int v11 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v19;
    BOOL v13 = os_log_type_enabled(v9, v19);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
        int v11 = "%{public}s called with null queue, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "network_config_policy_observer_create";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      int v14 = "%{public}s called with null queue, dumping backtrace:%{public}s";
LABEL_23:
      _os_log_impl(&dword_181A5C000, v9, v10, v14, buf, 0x16u);
    }

void ___ZL37network_config_policy_observer_create34network_config_policy_event_type_tP16dispatch_queue_sU13block_pointerFvPvS2_S2_E_block_invoke( uint64_t a1)
{
  *(void *)&v67[13] = *MEMORY[0x1895F89C0];
  if (network_config_setup_policy_event_watcher(void)::kevsrc)
  {
    v2 = *(dispatch_object_s **)(a1 + 48);
    if (v2) {
      goto LABEL_3;
    }
    goto LABEL_52;
  }

  int v9 = socket(32, 3, 1);
  if ((v9 & 0x80000000) == 0)
  {
    unsigned int v10 = v9;
    int v60 = 3;
    *(void *)v59 = 0x100000001LL;
    if (ioctl(v9, 0x800C6502uLL, v59))
    {
      int v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)v64 = 136446466;
      v65 = "network_config_setup_policy_event_watcher";
      __int16 v66 = 1024;
      *(_DWORD *)v67 = v11;
      v12 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v58 = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)gLogObj;
        os_log_type_t v14 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_96;
        }
        *(_DWORD *)v64 = 136446466;
        v65 = "network_config_setup_policy_event_watcher";
        __int16 v66 = 1024;
        *(_DWORD *)v67 = v11;
        BOOL v15 = "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d";
LABEL_94:
        v45 = v13;
        os_log_type_t v46 = v14;
        uint32_t v47 = 18;
LABEL_95:
        _os_log_impl(&dword_181A5C000, v45, v46, v15, v64, v47);
        goto LABEL_96;
      }

      if (v58 == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)gLogObj;
        os_log_type_t v14 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_96;
        }
        *(_DWORD *)v64 = 136446466;
        v65 = "network_config_setup_policy_event_watcher";
        __int16 v66 = 1024;
        *(_DWORD *)v67 = v11;
        BOOL v15 = "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_94;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type[0];
      BOOL v28 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!backtrace_string)
      {
        if (!v28) {
          goto LABEL_96;
        }
        *(_DWORD *)v64 = 136446466;
        v65 = "network_config_setup_policy_event_watcher";
        __int16 v66 = 1024;
        *(_DWORD *)v67 = v11;
        BOOL v15 = "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, no backtrace";
        goto LABEL_94;
      }

      if (v28)
      {
        *(_DWORD *)v64 = 136446722;
        v65 = "network_config_setup_policy_event_watcher";
        __int16 v66 = 1024;
        *(_DWORD *)v67 = v11;
        v67[2] = 2082;
        *(void *)&v67[3] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, dumping backtrace:%{public}s",  v64,  0x1Cu);
      }

      free(backtrace_string);
LABEL_96:
      if (!v12)
      {
LABEL_98:
        close(v10);
        return;
      }

uint64_t ___ZL41network_config_setup_policy_event_watcherv_block_invoke(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

void ___ZL41network_config_setup_policy_event_watcherv_block_invoke_2(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  *(_OWORD *)value = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  uint64_t v2 = MEMORY[0x1895F87A8];
  while (1)
  {
    ssize_t v3 = recv(*(_DWORD *)(a1 + 32), &v22, 0x80uLL, 0);
    if (v3 < 1) {
      break;
    }
    if ((unint64_t)v3 >= 0x18
      && DWORD1(v22) == 1
      && DWORD2(v22) == 1
      && HIDWORD(v22) == 3
      && v22 >= 0x40
      && v3 >= (unint64_t)v22)
    {
      xpc_object_t v8 = xpc_uint64_create(value[0]);
      xpc_object_t v9 = xpc_uuid_create((const unsigned __int8 *)&value[1]);
      if (DWORD1(v23) == 1)
      {
        v12 = (void **)&g_wifi_blocked_handlers;
        if (DWORD2(v25) != 3) {
          v12 = (void **)&g_cellular_blocked_handlers;
        }
        int v11 = *v12;
        if (!*v12)
        {
LABEL_33:
          if (!v8) {
            goto LABEL_26;
          }
LABEL_25:
          xpc_release(v8);
          goto LABEL_26;
        }
      }

      else if (DWORD1(v23) == 2)
      {
        int v11 = (void *)g_cellular_failed_handlers;
        if (!g_cellular_failed_handlers) {
          goto LABEL_33;
        }
      }

      else
      {
        unsigned int v10 = &g_cellular_blocked_handlers;
        if (DWORD1(v23) == 3)
        {
          unsigned int v10 = &g_local_network_blocked_handlers;
          if (DWORD2(v25) != 1) {
            goto LABEL_33;
          }
        }

        int v11 = (void *)*v10;
        if (!*v10) {
          goto LABEL_33;
        }
      }

      *(void *)applier = v2;
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = ___ZL42network_config_handle_policy_event_messagelP14kern_event_msg_block_invoke;
      *(void *)&applier[24] = &__block_descriptor_tmp_18_23928;
      xpc_object_t v31 = v8;
      xpc_object_t v32 = v9;
      xpc_array_apply(v11, applier);
      if (v8) {
        goto LABEL_25;
      }
LABEL_26:
      if (v9) {
        xpc_release(v9);
      }
    }
  }

  if (v3 < 0)
  {
    int v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v13 != 35)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "network_config_setup_policy_event_watcher_block_invoke_2";
      *(_WORD *)&applier[12] = 1024;
      *(_DWORD *)&applier[14] = v13;
      os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v20 = 0;
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v20)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v15 = (os_log_s *)gLogObj;
          os_log_type_t v16 = type;
          BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v19)
            {
              *(_DWORD *)applier = 136446722;
              *(void *)&applier[4] = "network_config_setup_policy_event_watcher_block_invoke";
              *(_WORD *)&applier[12] = 1024;
              *(_DWORD *)&applier[14] = v13;
              *(_WORD *)&applier[18] = 2082;
              *(void *)&applier[20] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s recv from kernel event socket failed %{darwin.errno}d, dumping backtrace:%{public}s",  applier,  0x1Cu);
            }

            free(backtrace_string);
            goto LABEL_51;
          }

          if (!v19) {
            goto LABEL_51;
          }
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "network_config_setup_policy_event_watcher_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = v13;
          int v17 = "%{public}s recv from kernel event socket failed %{darwin.errno}d, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v15 = (os_log_s *)gLogObj;
          os_log_type_t v16 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_51;
          }
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "network_config_setup_policy_event_watcher_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = v13;
          int v17 = "%{public}s recv from kernel event socket failed %{darwin.errno}d, backtrace limit exceeded";
        }

uint64_t ___ZL42network_config_handle_policy_event_messagelP14kern_event_msg_block_invoke(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t pointer = xpc_dictionary_get_pointer();
  uint64_t v3 = xpc_dictionary_get_pointer();
  if (!pointer)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v10 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 1LL;
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "network_config_handle_policy_event_message_block_invoke";
    int v11 = "%{public}s Event handler has no block set";
LABEL_11:
    _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, 0xCu);
    return 1LL;
  }

  int v4 = (dispatch_queue_s *)v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v10 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 1LL;
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "network_config_handle_policy_event_message_block_invoke";
    int v11 = "%{public}s Event handler has no queue set";
    goto LABEL_11;
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v19 = 0x2000000000LL;
  uint64_t v20 = 0LL;
  uint32_t v5 = *(void **)(a1 + 32);
  if (v5)
  {
    xpc_object_t v6 = xpc_retain(v5);
    *(void *)(*((void *)&buf + 1) + 24LL) = v6;
  }

  uint64_t v14 = 0LL;
  BOOL v15 = &v14;
  uint64_t v16 = 0x2000000000LL;
  uint64_t v17 = 0LL;
  xpc_object_t v7 = *(void **)(a1 + 40);
  if (v7)
  {
    xpc_object_t v8 = xpc_retain(v7);
    v15[3] = (uint64_t)v8;
    uint64_t v9 = *(void *)(a1 + 40);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 0x40000000LL;
  v13[2] = ___ZL42network_config_handle_policy_event_messagelP14kern_event_msg_block_invoke_15;
  v13[3] = &unk_189BB9688;
  void v13[4] = pointer;
  v13[5] = &buf;
  v13[6] = &v14;
  v13[7] = v9;
  dispatch_async(v4, v13);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&buf, 8);
  return 1LL;
}

void ___ZL42network_config_handle_policy_event_messagelP14kern_event_msg_block_invoke_15(void *a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1[5] + 8LL) + 24LL);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = 0LL;
  }

  uint64_t v3 = *(void **)(*(void *)(a1[6] + 8LL) + 24LL);
  if (v3)
  {
    xpc_release(v3);
    *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = 0LL;
  }

dispatch_queue_t ___ZL21nw_policy_event_queuev_block_invoke()
{
  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t result = dispatch_queue_create("com.apple.libnetwork.cellular_blocked", v0);
  nw_policy_event_queue(void)::queue = (uint64_t)result;
  return result;
}

uint64_t network_config_cellular_failed_observer_create(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v4 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136446210;
    xpc_object_t v7 = "network_config_cellular_failed_observer_create";
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s creating cellular failed observer",  (uint8_t *)&v6,  0xCu);
  }

  return network_config_policy_observer_create(2, a1, a2);
}

uint64_t network_config_wifi_blocked_observer_create(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v4 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136446210;
    xpc_object_t v7 = "network_config_wifi_blocked_observer_create";
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s creating Wi-Fi blocked observer",  (uint8_t *)&v6,  0xCu);
  }

  return network_config_policy_observer_create(3, a1, a2);
}

uint64_t network_config_local_network_blocked_observer_create(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v4 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136446210;
    xpc_object_t v7 = "network_config_local_network_blocked_observer_create";
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s creating local network blocked observer",  (uint8_t *)&v6,  0xCu);
  }

  return network_config_policy_observer_create(4, a1, a2);
}

void network_config_policy_observer_cancel(void *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)gLogObj;
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v13 = "network_config_policy_observer_cancel";
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEFAULT,  "%{public}s cancelling cellular blocked observer",  buf,  0xCu);
    }

    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = ___ZL37network_config_policy_observer_cancelPv_block_invoke;
    block[3] = &__block_descriptor_tmp_19_23949;
    void block[4] = a1;
    dispatch_sync((dispatch_queue_t)nw_policy_event_queue(void)::queue, block);
    return;
  }

  *(_DWORD *)__int128 buf = 136446210;
  int v13 = "network_config_policy_observer_cancel";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v11 = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &v11, &v10))
  {
    if (v11 == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = v11;
      if (!os_log_type_enabled(v4, v11)) {
        goto LABEL_22;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v13 = "network_config_policy_observer_cancel";
      int v6 = "%{public}s called with null observer";
      goto LABEL_21;
    }

    if (!v10)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = v11;
      if (!os_log_type_enabled(v4, v11)) {
        goto LABEL_22;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v13 = "network_config_policy_observer_cancel";
      int v6 = "%{public}s called with null observer, backtrace limit exceeded";
      goto LABEL_21;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = v11;
    BOOL v8 = os_log_type_enabled(v4, v11);
    if (backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v13 = "network_config_policy_observer_cancel";
        __int16 v14 = 2082;
        BOOL v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null observer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_22;
    }

    if (v8)
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v13 = "network_config_policy_observer_cancel";
      int v6 = "%{public}s called with null observer, no backtrace";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    }
  }

void ___ZL37network_config_policy_observer_cancelPv_block_invoke(uint64_t a1)
{
}

void network_config_remove_observer_from_array(void **a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (v19 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      if (!os_log_type_enabled(v9, v19)) {
        goto LABEL_36;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
      os_log_type_t v11 = "%{public}s called with null array_ptr";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      BOOL v13 = os_log_type_enabled(v9, v19);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null array_ptr, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v8) {
          return;
        }
LABEL_37:
        free(v8);
        return;
      }

      if (!v13) {
        goto LABEL_36;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
      os_log_type_t v11 = "%{public}s called with null array_ptr, no backtrace";
    }

    else
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      if (!os_log_type_enabled(v9, v19)) {
        goto LABEL_36;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "network_config_remove_observer_from_array";
      os_log_type_t v11 = "%{public}s called with null array_ptr, backtrace limit exceeded";
    }

BOOL ___ZL41network_config_remove_observer_from_arrayPPvS__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 == a3) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return v3 != a3;
}

uint64_t ___ZL41network_config_remove_observer_from_arrayPPvS__block_invoke_2( uint64_t a1, int a2, xpc_object_t value)
{
  if (*(xpc_object_t *)(a1 + 32) == value)
  {
    uint64_t pointer = (const void *)xpc_dictionary_get_pointer();
    xpc_object_t v4 = (dispatch_object_s *)xpc_dictionary_get_pointer();
    if (v4) {
      dispatch_release(v4);
    }
    xpc_dictionary_set_pointer();
    xpc_dictionary_set_pointer();
  }

  else
  {
    xpc_array_append_value(*(xpc_object_t *)(a1 + 40), value);
  }

  return 1LL;
}

uint64_t network_config_mptcp_watcher_create(uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "network_config_mptcp_watcher_create";
    __int128 v28 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v43) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v43)
      {
        __int128 v29 = (os_log_s *)__nwlog_obj();
        os_log_type_t v30 = type[0];
        if (!os_log_type_enabled(v29, type[0])) {
          goto LABEL_90;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_mptcp_watcher_create";
        xpc_object_t v31 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_89;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __int128 v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type[0];
      BOOL v33 = os_log_type_enabled(v29, type[0]);
      if (!backtrace_string)
      {
        if (!v33) {
          goto LABEL_90;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_mptcp_watcher_create";
        xpc_object_t v31 = "%{public}s called with null queue, no backtrace";
        goto LABEL_89;
      }

      if (v33)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "network_config_mptcp_watcher_create";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v34 = "%{public}s called with null queue, dumping backtrace:%{public}s";
LABEL_79:
        _os_log_impl(&dword_181A5C000, v29, v30, v34, buf, 0x16u);
      }

void __network_config_mptcp_watcher_create_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(dispatch_object_s **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

void __network_config_mptcp_watcher_create_block_invoke_2(uint64_t a1)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  while (1)
  {
    ssize_t v3 = recv(*(_DWORD *)(a1 + 48), &v38, 0x80uLL, 0);
    if (v3 < 1) {
      break;
    }
    if (DWORD2(v38) == 1 && HIDWORD(v38) == 12)
    {
      if (DWORD1(v39) == 1)
      {
        int v11 = DWORD2(v39);
        if ((((DWORD2(v39) == 0) ^ sMptcpUsesCell) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v12 = (os_log_s *)gLogObj;
          BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT);
          int v11 = DWORD2(v39);
          if (v13)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v14 = "on";
            if (!DWORD2(v39)) {
              BOOL v14 = "off";
            }
            BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
            __int16 v36 = 2082;
            *(void *)unsigned int v37 = v14;
            _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEFAULT,  "%{public}s MPTCP changing cell-icon to %{public}s",  buf,  0x16u);
            int v11 = DWORD2(v39);
          }
        }

        sMptcpUsesCell = v11 != 0;
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 0x40000000LL;
        block[2] = __network_config_mptcp_watcher_create_block_invoke_4;
        block[3] = &unk_189BB95A8;
        uint64_t v2 = *(dispatch_queue_s **)(a1 + 40);
        void block[4] = *(void *)(a1 + 32);
        dispatch_async(v2, block);
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v15 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
          __int16 v36 = 1024;
          *(_DWORD *)unsigned int v37 = DWORD1(v39);
          _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s Received unexpected event-code: %u",  buf,  0x12u);
        }
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)__int128 buf = 136446722;
      BOOL v35 = "network_config_mptcp_watcher_create_block_invoke_2";
      __int16 v36 = 1024;
      *(_DWORD *)unsigned int v37 = DWORD2(v38);
      *(_WORD *)&v37[4] = 1024;
      *(_DWORD *)&v37[6] = HIDWORD(v38);
      int v5 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v32 = 0;
      if (__nwlog_fault(v5, &type, &v32))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v6 = gLogObj;
          os_log_type_t v7 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)__int128 buf = 136446722;
            BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
            __int16 v36 = 1024;
            *(_DWORD *)unsigned int v37 = DWORD2(v38);
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = HIDWORD(v38);
            BOOL v8 = (os_log_s *)v6;
            os_log_type_t v9 = v7;
            os_log_type_t v10 = "%{public}s Received unexpected msg: class %u subclass %u";
LABEL_29:
            _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0x18u);
          }
        }

        else if (v32)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = (os_log_s *)gLogObj;
          os_log_type_t v18 = type;
          BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v19)
            {
              *(_DWORD *)__int128 buf = 136446978;
              BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
              __int16 v36 = 1024;
              *(_DWORD *)unsigned int v37 = DWORD2(v38);
              *(_WORD *)&v37[4] = 1024;
              *(_DWORD *)&v37[6] = HIDWORD(v38);
              *(_WORD *)&v37[10] = 2082;
              *(void *)&v37[12] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s Received unexpected msg: class %u subclass %u, dumping backtrace:%{public}s",  buf,  0x22u);
            }

            free(backtrace_string);
          }

          else if (v19)
          {
            *(_DWORD *)__int128 buf = 136446722;
            BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
            __int16 v36 = 1024;
            *(_DWORD *)unsigned int v37 = DWORD2(v38);
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = HIDWORD(v38);
            BOOL v8 = v17;
            os_log_type_t v9 = v18;
            os_log_type_t v10 = "%{public}s Received unexpected msg: class %u subclass %u, no backtrace";
            goto LABEL_29;
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = gLogObj;
          os_log_type_t v21 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)__int128 buf = 136446722;
            BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
            __int16 v36 = 1024;
            *(_DWORD *)unsigned int v37 = DWORD2(v38);
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = HIDWORD(v38);
            BOOL v8 = (os_log_s *)v20;
            os_log_type_t v9 = v21;
            os_log_type_t v10 = "%{public}s Received unexpected msg: class %u subclass %u, backtrace limit exceeded";
            goto LABEL_29;
          }
        }
      }

      if (v5) {
        free(v5);
      }
    }
  }

  if (v3 < 0)
  {
    int v22 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v22 != 35)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v35 = "network_config_mptcp_watcher_create_block_invoke_2";
      __int16 v36 = 1024;
      *(_DWORD *)unsigned int v37 = v22;
      os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v32 = 0;
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v32)
        {
          BOOL v27 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v24 = (os_log_s *)gLogObj;
          os_log_type_t v25 = type;
          BOOL v28 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v27)
          {
            if (v28)
            {
              *(_DWORD *)__int128 buf = 136446722;
              BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
              __int16 v36 = 1024;
              *(_DWORD *)unsigned int v37 = v22;
              *(_WORD *)&v37[4] = 2082;
              *(void *)&v37[6] = v27;
              _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s recv from kernel event socket failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v27);
            goto LABEL_48;
          }

          if (!v28) {
            goto LABEL_48;
          }
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
          __int16 v36 = 1024;
          *(_DWORD *)unsigned int v37 = v22;
          __int128 v26 = "%{public}s recv from kernel event socket failed %{darwin.errno}d, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v24 = (os_log_s *)gLogObj;
          os_log_type_t v25 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_48;
          }
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v35 = "network_config_mptcp_watcher_create_block_invoke";
          __int16 v36 = 1024;
          *(_DWORD *)unsigned int v37 = v22;
          __int128 v26 = "%{public}s recv from kernel event socket failed %{darwin.errno}d, backtrace limit exceeded";
        }

uint64_t __network_config_mptcp_watcher_create_block_invoke_4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __network_config_mptcp_watcher_create_block_invoke_6(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  return (*(uint64_t (**)(void))(v1 + 16))();
}

uint64_t network_config_mptcp_cell_in_use()
{
  return sMptcpUsesCell;
}

char *nw_connection_copy_description_level(void *a1, int a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  ssize_t v3 = a1;
  id v4 = v3;
  if (v3)
  {
    BOOL v33 = 0LL;
    int v5 = (void *)v3[1];
    if (a2 == 1) {
      description = nw_endpoint_get_description(v5);
    }
    else {
      description = nw_endpoint_get_logging_description(v5);
    }
    os_log_type_t v7 = description;
    BOOL v8 = nw_parameters_copy_description_internal(*((NWConcrete_nw_parameters **)v4 + 2), 0);
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    BOOL v35 = __Block_byref_object_copy__24148;
    __int16 v36 = __Block_byref_object_dispose__24149;
    id v37 = 0LL;
    *(void *)os_log_type_t type = 0LL;
    os_log_type_t v30 = type;
    uint64_t v31 = 0x2020000000LL;
    char v32 = 0;
    v25[0] = MEMORY[0x1895F87A8];
    v25[1] = 3221225472LL;
    v25[2] = ___ZL36nw_connection_copy_description_levelP24NWConcrete_nw_connection26nw_context_privacy_level_t_block_invoke;
    v25[3] = &unk_189BC16A8;
    os_log_type_t v9 = v4;
    id v26 = v9;
    BOOL v27 = buf;
    BOOL v28 = type;
    os_unfair_lock_lock((os_unfair_lock_t)v4 + 34);
    ___ZL36nw_connection_copy_description_levelP24NWConcrete_nw_connection26nw_context_privacy_level_t_block_invoke(v25);
    os_unfair_lock_unlock((os_unfair_lock_t)v4 + 34);
    os_log_type_t v10 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v10) {
      BOOL v11 = nw_path_copy_description(v10);
    }
    else {
      BOOL v11 = 0LL;
    }
    int v12 = "";
    if (*((_BYTE *)v30 + 24)) {
      BOOL v13 = "connected ";
    }
    else {
      BOOL v13 = "";
    }
    BOOL v14 = ", path ";
    if (v11) {
      int v12 = (const char *)v11;
    }
    else {
      BOOL v14 = "";
    }
    asprintf(&v33, "[C%u %s%s %s%s%s]", v9[112], v13, v7, v8, v14, v12);
    if (v8) {
      free(v8);
    }
    if (v11) {
      free((void *)v11);
    }
    BOOL v15 = v33;

    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);

    goto LABEL_19;
  }

  __nwlog_obj();
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_description_level";
  os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v33) = 0;
  if (__nwlog_fault(v18, type, &v33))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_description_level";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if ((_BYTE)v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type[0];
      BOOL v23 = os_log_type_enabled(v19, type[0]);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_description_level";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (v23)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_description_level";
        _os_log_impl(&dword_181A5C000, v19, v22, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_description_level";
        _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181F9C83C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__24148(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__24149(uint64_t a1)
{
}

void ___ZL36nw_connection_copy_description_levelP24NWConcrete_nw_connection26nw_context_privacy_level_t_block_invoke( void *a1)
{
  uint64_t v2 = a1[4];
  ssize_t v3 = *(void **)(v2 + 144);
  if (v3)
  {
    if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
    {
      uint64_t v8 = nw_endpoint_handler_copy_connected_path(v3);
      uint64_t v9 = *(void *)(a1[5] + 8LL);
      os_log_type_t v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v8;

      *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
    }

    else
    {
      id v4 = v3;
      os_unfair_lock_lock((os_unfair_lock_t)v4 + 28);
      id v5 = *((id *)v4 + 8);
      os_unfair_lock_unlock((os_unfair_lock_t)v4 + 28);

      uint64_t v6 = *(void *)(a1[5] + 8LL);
      os_log_type_t v7 = *(void **)(v6 + 40);
      *(void *)(v6 + 40) = v5;
    }
  }

char *__cdecl nw_connection_copy_description(nw_connection_t connection)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = connection;
  uint64_t v2 = v1;
  if (v1)
  {
    ssize_t v3 = nw_connection_copy_description_level(v1, 1);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v16 = "nw_connection_copy_description";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v16 = "nw_connection_copy_description";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v16 = "nw_connection_copy_description";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v16 = "nw_connection_copy_description";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v16 = "nw_connection_copy_description";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181F9CBE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_cancel_update_handler(NWConcrete_nw_connection *a1)
{
  uint64_t v1 = a1;
  v23[0] = 0LL;
  v23[1] = v23;
  v23[2] = 0x3032000000LL;
  v23[3] = __Block_byref_object_copy__8;
  v23[4] = __Block_byref_object_dispose__9;
  id v24 = 0LL;
  v21[0] = 0LL;
  v21[1] = v21;
  v21[2] = 0x3032000000LL;
  v21[3] = __Block_byref_object_copy__8;
  v21[4] = __Block_byref_object_dispose__9;
  id v22 = 0LL;
  v19[0] = 0LL;
  v19[1] = v19;
  v19[2] = 0x3032000000LL;
  v19[3] = __Block_byref_object_copy__8;
  v19[4] = __Block_byref_object_dispose__9;
  id v20 = 0LL;
  v17[0] = 0LL;
  v17[1] = v17;
  v17[2] = 0x3032000000LL;
  v17[3] = __Block_byref_object_copy__8;
  v17[4] = __Block_byref_object_dispose__9;
  id v18 = 0LL;
  v15[0] = 0LL;
  v15[1] = v15;
  v15[2] = 0x3032000000LL;
  v15[3] = __Block_byref_object_copy__8;
  v15[4] = __Block_byref_object_dispose__9;
  id v16 = 0LL;
  v13[0] = 0LL;
  v13[1] = v13;
  v13[2] = 0x3032000000LL;
  v13[3] = __Block_byref_object_copy__8;
  void v13[4] = __Block_byref_object_dispose__9;
  id v14 = 0LL;
  p_lock = &v1->lock;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___ZL35nw_connection_cancel_update_handlerP24NWConcrete_nw_connection_block_invoke;
  v5[3] = &unk_189BB9B20;
  uint64_t v6 = v1;
  os_log_type_t v7 = v23;
  os_log_type_t v8 = v21;
  uint64_t v9 = v19;
  os_log_type_t v10 = v17;
  BOOL v11 = v15;
  os_log_type_t v12 = v13;
  ssize_t v3 = v1;
  os_unfair_lock_lock(p_lock);
  ___ZL35nw_connection_cancel_update_handlerP24NWConcrete_nw_connection_block_invoke(v5, v4);
  os_unfair_lock_unlock(p_lock);

  _Block_object_dispose(v13, 8);
  _Block_object_dispose(v15, 8);

  _Block_object_dispose(v17, 8);
  _Block_object_dispose(v19, 8);

  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v23, 8);
}

void *__Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  dispatch_queue_t result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
}

void ___ZL35nw_connection_cancel_update_handlerP24NWConcrete_nw_connection_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = *(void *)(v3 + 368);
  if (v4)
  {
    nw_queue_cancel_source(v4, a2);
    *(void *)(a1[4] + 368LL) = 0LL;
    uint64_t v3 = a1[4];
  }

  id v5 = *(void **)(v3 + 144);
  *(void *)(v3 + 144) = 0LL;

  uint64_t v6 = a1[4];
  os_log_type_t v7 = *(void **)(v6 + 176);
  *(void *)(v6 + 176) = 0LL;

  uint64_t v8 = a1[4];
  uint64_t v9 = *(void **)(v8 + 184);
  *(void *)(v8 + 184) = 0LL;

  uint64_t v11 = a1[4];
  uint64_t v12 = *(void *)(v11 + 224);
  if (v12)
  {
    nw_queue_cancel_source(v12, v10);
    *(void *)(a1[4] + 224LL) = 0LL;
    uint64_t v11 = a1[4];
  }

  *(_BYTE *)(v11 + 109) &= ~0x40u;
  char v13 = _Block_copy(*(const void **)(a1[4] + 208LL));
  uint64_t v14 = *(void *)(a1[5] + 8LL);
  BOOL v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;

  uint64_t v16 = a1[4];
  __int16 v17 = *(void **)(v16 + 208);
  *(void *)(v16 + 20_Block_object_dispose(va, 8) = 0LL;

  id v18 = _Block_copy(*(const void **)(a1[4] + 232LL));
  uint64_t v19 = *(void *)(a1[6] + 8LL);
  id v20 = *(void **)(v19 + 40);
  *(void *)(v19 + 40) = v18;

  uint64_t v21 = a1[4];
  id v22 = *(void **)(v21 + 232);
  *(void *)(v21 + 232) = 0LL;

  BOOL v23 = _Block_copy(*(const void **)(a1[4] + 240LL));
  uint64_t v24 = *(void *)(a1[7] + 8LL);
  os_log_type_t v25 = *(void **)(v24 + 40);
  *(void *)(v24 + 40) = v23;

  uint64_t v26 = a1[4];
  BOOL v27 = *(void **)(v26 + 240);
  *(void *)(v26 + 240) = 0LL;

  BOOL v28 = _Block_copy(*(const void **)(a1[4] + 248LL));
  uint64_t v29 = *(void *)(a1[8] + 8LL);
  os_log_type_t v30 = *(void **)(v29 + 40);
  *(void *)(v29 + 40) = v28;

  uint64_t v31 = a1[4];
  char v32 = *(void **)(v31 + 248);
  *(void *)(v31 + 24_Block_object_dispose(va, 8) = 0LL;

  BOOL v33 = _Block_copy(*(const void **)(a1[4] + 256LL));
  uint64_t v34 = *(void *)(a1[9] + 8LL);
  BOOL v35 = *(void **)(v34 + 40);
  *(void *)(v34 + 40) = v33;

  uint64_t v36 = a1[4];
  id v37 = *(void **)(v36 + 256);
  *(void *)(v36 + 256) = 0LL;

  uint64_t v38 = _Block_copy(*(const void **)(a1[4] + 384LL));
  uint64_t v39 = *(void *)(a1[10] + 8LL);
  __int128 v40 = *(void **)(v39 + 40);
  *(void *)(v39 + 40) = v38;

  uint64_t v41 = a1[4];
  __int128 v42 = *(void **)(v41 + 384);
  *(void *)(v41 + 384) = 0LL;

  __int128 v43 = *(void **)(a1[4] + 264LL);
  if (v43)
  {
    __int128 v45 = (void *)*v43;
    __int128 v44 = (void *)v43[1];
    if (*v43)
    {
      do
      {
        v45[1] = v44;
        *(void *)v43[1] = v45;
        free(v43);
        __int128 v43 = v45;
        __int128 v45 = (void *)*v45;
        __int128 v44 = (void *)v43[1];
      }

      while (v45);
    }

    *(void *)(a1[4] + 272LL) = v44;
    *__int128 v44 = 0LL;
    free(v43);
  }

void _nw_connection_send_idempotent_content_block_invoke()
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v0 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v11 = "_nw_connection_send_idempotent_content_block_invoke";
  uint64_t v1 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (!__nwlog_fault(v1, &type, &v8))
  {
LABEL_6:
    if (!v1) {
      return;
    }
    goto LABEL_7;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    os_log_type_t v3 = type;
    if (os_log_type_enabled(v2, type))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v11 = "_nw_connection_send_idempotent_content_block_invoke";
      _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s _nw_connection_send_idempotent_content called directly",  buf,  0xCu);
    }

void _nw_connection_write_idempotent_block_invoke_2()
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v0 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446210;
  char v13 = "_nw_connection_write_idempotent_block_invoke_2";
  uint64_t v1 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    os_log_type_t v3 = type;
    if (!os_log_type_enabled(v2, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)__int128 buf = 136446210;
    char v13 = "_nw_connection_write_idempotent_block_invoke_2";
    uint64_t v4 = "%{public}s _nw_connection_write_idempotent called directly";
LABEL_15:
    char v8 = v2;
    os_log_type_t v9 = v3;
LABEL_16:
    _os_log_impl(&dword_181A5C000, v8, v9, v4, buf, 0xCu);
    goto LABEL_17;
  }

  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    os_log_type_t v3 = type;
    if (!os_log_type_enabled(v2, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)__int128 buf = 136446210;
    char v13 = "_nw_connection_write_idempotent_block_invoke_2";
    uint64_t v4 = "%{public}s _nw_connection_write_idempotent called directly, backtrace limit exceeded";
    goto LABEL_15;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  os_log_type_t v6 = type;
  BOOL v7 = os_log_type_enabled(v2, type);
  if (backtrace_string)
  {
    if (v7)
    {
      *(_DWORD *)__int128 buf = 136446466;
      char v13 = "_nw_connection_write_idempotent_block_invoke_2";
      __int16 v14 = 2082;
      BOOL v15 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v2,  v6,  "%{public}s _nw_connection_write_idempotent called directly, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_10:
    if (!v1) {
      return;
    }
    goto LABEL_11;
  }

  if (v7)
  {
    *(_DWORD *)__int128 buf = 136446210;
    char v13 = "_nw_connection_write_idempotent_block_invoke_2";
    uint64_t v4 = "%{public}s _nw_connection_write_idempotent called directly, no backtrace";
    char v8 = v2;
    os_log_type_t v9 = v6;
    goto LABEL_16;
  }

void nw_connection_async_if_needed(void *a1, void *a2)
{
  uint64_t v4 = a1;
  os_log_type_t v3 = a2;
  else {
    v3[2](v3);
  }
}

void sub_181F9D5A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __nw_connection_async_client_block_invoke(uint64_t a1)
{
}

void __nw_connection_async_client(void *a1, dispatch_qos_class_t a2, void *a3)
{
  id v9 = a1;
  id v5 = a3;
  os_log_type_t v6 = (void *)*((void *)v9 + 25);
  if (v6)
  {
    BOOL v7 = v6;
    dispatch_block_t v8 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, a2, 0, v5);
    dispatch_async(v7, v8);
  }

  else if (!*((void *)v9 + 5))
  {
    nw_context_queue_block(*((void **)v9 + 3), v5);
  }
}

void sub_181F9D66C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __nw_connection_async_client_if_needed_with_override_block_invoke(uint64_t a1)
{
}

void __nw_connection_async_client_if_needed_with_override( void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  __int16 v12 = a1;
  BOOL v7 = a2;
  dispatch_block_t v8 = a4;
  if (v7)
  {
    dispatch_block_t v9 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, a3, 0, v8);
    dispatch_async(v7, v9);
LABEL_5:

    goto LABEL_6;
  }

  char v10 = (void *)v12[25];
  if (v10)
  {
    uint64_t v11 = v10;
    dispatch_block_t v9 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, a3, 0, v8);
    dispatch_async(v11, v9);

    goto LABEL_5;
  }

  if (!v12[5]) {
    v8[2](v8);
  }
LABEL_6:
}

void sub_181F9D774( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_add_probe(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      *(void *)__int128 buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000LL;
      char v28 = 0;
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_connection_add_probe_block_invoke;
      v21[3] = &unk_189BBEEE8;
      uint64_t v24 = buf;
      id v22 = v3;
      id v23 = v5;
      os_unfair_lock_lock(v3 + 34);
      __nw_connection_add_probe_block_invoke((uint64_t)v21);
      os_unfair_lock_unlock(v3 + 34);
      BOOL v6 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }

    __nwlog_obj();
    __int16 v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_add_probe";
    dispatch_block_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_add_probe";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null probe", buf, 0xCu);
        }

uint64_t __nw_connection_add_probe_block_invoke(uint64_t a1)
{
  uint64_t result = nw_connection_add_probe_locked( *(NWConcrete_nw_connection **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = result;
  return result;
}

uint64_t nw_connection_add_probe_locked(NWConcrete_nw_connection *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    v67 = "nw_connection_add_probe_locked";
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        v67 = "nw_connection_add_probe_locked";
        _os_log_impl(&dword_181A5C000, v53, v54, "%{public}s called with null connection", buf, 0xCu);
      }

      goto LABEL_128;
    }

    if (!v64)
    {
      __nwlog_obj();
      v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        v67 = "nw_connection_add_probe_locked";
        _os_log_impl( &dword_181A5C000,  v53,  v62,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_128;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v58 = type;
    BOOL v59 = os_log_type_enabled(v53, type);
    if (!backtrace_string)
    {
      if (v59)
      {
        *(_DWORD *)__int128 buf = 136446210;
        v67 = "nw_connection_add_probe_locked";
        _os_log_impl(&dword_181A5C000, v53, v58, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }

      goto LABEL_128;
    }

    if (v59)
    {
      *(_DWORD *)__int128 buf = 136446466;
      v67 = "nw_connection_add_probe_locked";
      __int16 v68 = 2082;
      *(void *)v69 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v53,  v58,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_116;
  }

  if (!v4)
  {
    __nwlog_obj();
    unsigned int v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    v67 = "nw_connection_add_probe_locked";
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        v67 = "nw_connection_add_probe_locked";
        _os_log_impl(&dword_181A5C000, v53, v56, "%{public}s called with null probe", buf, 0xCu);
      }

void nw_connection_access_probe_connections(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v26 = "nw_connection_access_probe_connections";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_access_probe_connections";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v24;
      BOOL v16 = os_log_type_enabled(v10, v24);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v26 = "nw_connection_access_probe_connections";
          __int16 v27 = 2082;
          char v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_access_probe_connections";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_access_probe_connections";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void __nw_connection_access_probe_connections_block_invoke(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(a1 + 40);
  uint64_t v2 = *(id *)(a1 + 32);
  id v3 = v1;
  id v4 = v3;
  if (!v2)
  {
    __nwlog_obj();
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_40:
        free(v7);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

uint64_t ___ZL45nw_connection_access_probe_connections_lockedP24NWConcrete_nw_connectionU13block_pointerFbS0_E_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void nw_connection_remove_probe(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v26 = "nw_connection_remove_probe";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_remove_probe";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v24;
      BOOL v16 = os_log_type_enabled(v10, v24);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v26 = "nw_connection_remove_probe";
          __int16 v27 = 2082;
          char v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_remove_probe";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_remove_probe";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void __nw_connection_remove_probe_block_invoke(uint64_t a1)
{
}

void nw_connection_remove_probe_locked(NWConcrete_nw_connection *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v50 = "nw_connection_remove_probe_locked";
    os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v50 = "nw_connection_remove_probe_locked";
        _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      BOOL v41 = os_log_type_enabled(v35, type);
      if (backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v50 = "nw_connection_remove_probe_locked";
          __int16 v51 = 2082;
          *(void *)uint64_t v52 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v35,  v40,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_90:
        if (!v34) {
          goto LABEL_56;
        }
        goto LABEL_91;
      }

      if (v41)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v50 = "nw_connection_remove_probe_locked";
        _os_log_impl(&dword_181A5C000, v35, v40, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v50 = "nw_connection_remove_probe_locked";
        _os_log_impl( &dword_181A5C000,  v35,  v45,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_connection_reset_client(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    os_log_type_t v32 = __Block_byref_object_copy__24148;
    BOOL v33 = __Block_byref_object_dispose__24149;
    id v34 = 0LL;
    uint64_t v3 = MEMORY[0x1895F87A8];
    v22[0] = MEMORY[0x1895F87A8];
    v22[1] = 3221225472LL;
    v22[2] = __nw_connection_reset_client_block_invoke;
    v22[3] = &unk_189BC9210;
    os_log_type_t v24 = buf;
    id v4 = v1;
    id v23 = v4;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_reset_client_block_invoke((uint64_t)v22);
    os_unfair_lock_unlock(v2 + 34);
    v19[0] = v3;
    v19[1] = 3221225472LL;
    v19[2] = __nw_connection_reset_client_block_invoke_2;
    v19[3] = &unk_189BC9210;
    id v5 = v4;
    os_log_type_t v20 = v5;
    os_log_type_t v21 = buf;
    nw_connection_async_if_needed(v5, v19);
    v17[0] = v3;
    v17[1] = 3221225472LL;
    v17[2] = __nw_connection_reset_client_block_invoke_3;
    v17[3] = &unk_189BC93A0;
    BOOL v6 = v5;
    os_log_type_t v18 = v6;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_reset_client_block_invoke_3((uint64_t)v17);
    os_unfair_lock_unlock(v2 + 34);
    id v7 = v6;
    *(void *)os_log_type_t type = v3;
    uint64_t v27 = 3221225472LL;
    char v28 = __nw_connection_allow_reset_queue_block_invoke;
    uint64_t v29 = &unk_189BC93A0;
    unsigned int v8 = v7;
    os_log_type_t v30 = v8;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_allow_reset_queue_block_invoke((uint64_t)type);
    os_unfair_lock_unlock(v2 + 34);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_reset_client";
  char v10 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v10, type, &v25))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_reset_client";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type[0];
      BOOL v15 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_reset_client";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_reset_client";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_reset_client";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FA087C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29)
{
  _Block_object_dispose((const void *)(v30 - 144), 8);
  _Unwind_Resume(a1);
}

void __nw_connection_reset_client_block_invoke(uint64_t a1)
{
}

void __nw_connection_reset_client_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 168LL);
  uint64_t v3 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  id v4 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
  nw_read_request_report_error_with_override(v2, v3, v4);

  uint64_t v5 = *(void *)(a1 + 32);
  BOOL v6 = *(void **)(v5 + 168);
  *(void *)(v5 + 16_Block_object_dispose(va, 8) = 0LL;

  id v7 = *(void **)(*(void *)(a1 + 32) + 160LL);
  unsigned int v8 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  os_log_type_t v9 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
  nw_write_request_report_error_with_override(v7, v8, v9);

  uint64_t v10 = *(void *)(a1 + 32);
  BOOL v11 = *(void **)(v10 + 160);
  *(void *)(v10 + 160) = 0LL;

  os_log_type_t v12 = *(void **)(*(void *)(a1 + 32) + 144LL);
  if (v12) {
    nw_endpoint_handler_cancel_read_write_requests(v12, *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
  }
}

void sub_181FA09C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_reset_client_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 200);
  *(void *)(v2 + 200) = 0LL;

  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void **)(v4 + 208);
  *(void *)(v4 + 20_Block_object_dispose(va, 8) = 0LL;
}

uint64_t __nw_connection_allow_reset_queue_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 109LL) &= ~0x10u;
  return result;
}

BOOL nw_connection_is_cancelled(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v19 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_is_cancelled_block_invoke;
    v13[3] = &unk_189BC9210;
    BOOL v15 = buf;
    os_log_type_t v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_is_cancelled_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_is_cancelled";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_is_cancelled";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_is_cancelled";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_is_cancelled";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_is_cancelled";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_connection_is_cancelled_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = (*(_BYTE *)(*(void *)(result + 32) + 109LL) & 8) != 0;
  return result;
}

uint64_t __nw_connection_is_cancelled_or_failed_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  BOOL v2 = (*(_BYTE *)(v1 + 109) & 8) != 0 || (*(_DWORD *)(v1 + 80) & 0xFFFFFFFE) == 4;
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = v2;
  return result;
}

BOOL nw_connection_should_run_probe(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v19 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_should_run_probe_block_invoke;
    v13[3] = &unk_189BC9210;
    BOOL v15 = buf;
    os_log_type_t v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_should_run_probe_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_should_run_probe";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_should_run_probe";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_should_run_probe";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_should_run_probe";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_should_run_probe";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL __nw_connection_should_run_probe_block_invoke(uint64_t a1)
{
  BOOL result = nw_connection_should_run_probe_locked(*(NWConcrete_nw_connection **)(a1 + 32));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

BOOL nw_connection_should_run_probe_locked(NWConcrete_nw_connection *a1)
{
  *(void *)&v38[5] = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v36 = "nw_connection_should_run_probe_locked";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v26, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v36 = "nw_connection_should_run_probe_locked";
          _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        BOOL v31 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v36 = "nw_connection_should_run_probe_locked";
            __int16 v37 = 2082;
            *(void *)os_log_type_t v38 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_78;
        }

        if (v31)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v36 = "nw_connection_should_run_probe_locked";
          _os_log_impl(&dword_181A5C000, v27, v30, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v36 = "nw_connection_should_run_probe_locked";
          _os_log_impl( &dword_181A5C000,  v27,  v32,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FA1894(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_check_experimental_probe_options(void *a1, void *a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  BOOL v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  uint64_t v27 = 0LL;
  os_log_type_t v28 = &v27;
  uint64_t v29 = 0x2020000000LL;
  char v30 = 0;
  if (v3)
  {
    if (v4)
    {
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_connection_check_experimental_probe_options_block_invoke;
      v21[3] = &unk_189BBEEE8;
      unsigned int v24 = &v27;
      unsigned int v22 = v3;
      id v23 = v5;
      os_unfair_lock_lock(v3 + 34);
      __nw_connection_check_experimental_probe_options_block_invoke((uint64_t)v21);
      os_unfair_lock_unlock(v3 + 34);
      BOOL v6 = *((_BYTE *)v28 + 24) != 0;

      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v32 = "nw_connection_check_experimental_probe_options";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_connection_check_experimental_probe_options";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config", buf, 0xCu);
        }

uint64_t __nw_connection_check_experimental_probe_options_block_invoke(uint64_t a1)
{
  uint64_t result = nw_connection_check_experimental_probe_options_locked(*(void **)(a1 + 32), *(void **)(a1 + 40));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = result;
  return result;
}

uint64_t nw_connection_check_experimental_probe_options_locked(void *a1, void *a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  BOOL v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = type;
      BOOL v35 = os_log_type_enabled(v29, type);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
          __int16 v45 = 2082;
          os_log_type_t v46 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v28) {
          goto LABEL_75;
        }
        goto LABEL_74;
      }

      if (v35)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
        _os_log_impl(&dword_181A5C000, v29, v34, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
        _os_log_impl( &dword_181A5C000,  v29,  v39,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_72;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
        _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v41)
    {
      os_log_type_t v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v29, type);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v44 = "nw_connection_check_experimental_probe_options_locked";
          __int16 v45 = 2082;
          os_log_type_t v46 = v36;
          _os_log_impl( &dword_181A5C000,  v29,  v37,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v36);
LABEL_73:
        if (!v28)
        {
LABEL_75:
          uint64_t v14 = 0LL;
          goto LABEL_38;
        }

void sub_181FA25B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_connection_create_experimental_probe_configuration_block_for_protocol( void *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  unsigned int v7 = a1;
  id v8 = a2;
  id v9 = a4;
  os_log_type_t v10 = v9;
  uint64_t v45 = 0LL;
  os_log_type_t v46 = &v45;
  uint64_t v47 = 0x3032000000LL;
  uint64_t v48 = __Block_byref_object_copy__8;
  unsigned int v49 = __Block_byref_object_dispose__9;
  id v50 = 0LL;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v14, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        BOOL v27 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
            __int16 v53 = 2082;
            uint64_t v54 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v26,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v27)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl(&dword_181A5C000, v15, v26, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl( &dword_181A5C000,  v15,  v34,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void __nw_connection_create_experimental_probe_configuration_block_for_protocol_block_invoke(uint64_t a1)
{
  uint64_t v2 = nw_connection_create_experimental_probe_configuration_block_for_protocol_locked( *(void **)(a1 + 32),  *(void **)(a1 + 40),  *(void *)(a1 + 64),  *(void **)(a1 + 48));
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

id nw_connection_create_experimental_probe_configuration_block_for_protocol_locked( void *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  unsigned int v7 = a1;
  id v8 = a2;
  id v9 = a4;
  os_log_type_t v10 = v9;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
    BOOL v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (__nwlog_fault(v30, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
          _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v65)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        BOOL v47 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v47)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
            __int16 v69 = 2082;
            __int16 v70 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v31,  v46,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v47)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
          _os_log_impl(&dword_181A5C000, v31, v46, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v57 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
          _os_log_impl( &dword_181A5C000,  v31,  v57,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FA3970(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL79nw_connection_create_experimental_probe_configuration_block_for_protocol_lockedP24NWConcrete_nw_connectionPU24objcproto13OS_xpc_object8NSObjectPKcPU36objcproto25OS_nw_protocol_definitionS1__block_invoke( uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  id v2 = a2;
  if ((sec_protocol_options_apply_config() & 1) != 0) {
    goto LABEL_9;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked_block_invoke";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked_block_invoke";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s sec_protocol_options_apply_config failed", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s sec_protocol_options_apply_config failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v4) {
          goto LABEL_8;
        }
        goto LABEL_9;
      }

      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked_block_invoke";
        _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s sec_protocol_options_apply_config failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked_block_invoke";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s sec_protocol_options_apply_config failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v4) {
LABEL_8:
  }
    free(v4);
LABEL_9:
  sec_protocol_options_set_experiment_identifier();
  *(void *)__int128 buf = 0LL;
  *(void *)&buf[8] = 0LL;
  sec_protocol_metadata_copy_connection_id();
  sec_protocol_options_set_connection_id();
}

void sub_181FA3CE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_create_experimental_probe(void *a1, void *a2, uint64_t a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a2;
  unsigned int v7 = v6;
  uint64_t v30 = 0LL;
  BOOL v31 = &v30;
  uint64_t v32 = 0x3032000000LL;
  BOOL v33 = __Block_byref_object_copy__24148;
  os_log_type_t v34 = __Block_byref_object_dispose__24149;
  id v35 = 0LL;
  if (v5)
  {
    if (v6)
    {
      v23[0] = MEMORY[0x1895F87A8];
      v23[1] = 3221225472LL;
      v23[2] = __nw_connection_create_experimental_probe_block_invoke;
      v23[3] = &unk_189BBEC90;
      os_log_type_t v26 = &v30;
      os_log_type_t v24 = v5;
      id v25 = v7;
      uint64_t v27 = a3;
      os_unfair_lock_lock(v5 + 34);
      __nw_connection_create_experimental_probe_block_invoke((uint64_t)v23);
      os_unfair_lock_unlock(v5 + 34);
      id v8 = (id)v31[5];

      goto LABEL_4;
    }

    __nwlog_obj();
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v37 = "nw_connection_create_experimental_probe";
    char v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v37 = "nw_connection_create_experimental_probe";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null config", buf, 0xCu);
        }

void __nw_connection_create_experimental_probe_block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v2 = *(void **)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 56);
  id v4 = (NWConcrete_nw_connection *)*(id *)(a1 + 32);
  id v5 = v2;
  id v6 = v5;
  if (!v4)
  {
    __nwlog_obj();
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v35 = "nw_connection_create_experimental_probe_locked";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v35 = "nw_connection_create_experimental_probe_locked";
        _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null connection", buf, 0xCu);
      }

      goto LABEL_58;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v35 = "nw_connection_create_experimental_probe_locked";
        _os_log_impl( &dword_181A5C000,  v16,  v29,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_58;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v35 = "nw_connection_create_experimental_probe_locked";
        _os_log_impl(&dword_181A5C000, v16, v23, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }

      goto LABEL_58;
    }

    if (v24)
    {
      *(_DWORD *)__int128 buf = 136446466;
      id v35 = "nw_connection_create_experimental_probe_locked";
      __int16 v36 = 2082;
      os_log_type_t v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_40;
  }

  if (!v5)
  {
    __nwlog_obj();
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v35 = "nw_connection_create_experimental_probe_locked";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v35 = "nw_connection_create_experimental_probe_locked";
        _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null config", buf, 0xCu);
      }

      goto LABEL_58;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v35 = "nw_connection_create_experimental_probe_locked";
        _os_log_impl( &dword_181A5C000,  v16,  v30,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_58;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v35 = "nw_connection_create_experimental_probe_locked";
        _os_log_impl(&dword_181A5C000, v16, v25, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }

      goto LABEL_58;
    }

    if (v26)
    {
      *(_DWORD *)__int128 buf = 136446466;
      id v35 = "nw_connection_create_experimental_probe_locked";
      __int16 v36 = 2082;
      os_log_type_t v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v16,  v25,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_40;
  }

  if (!v3)
  {
    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v35 = "nw_connection_create_experimental_probe_locked";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v35 = "nw_connection_create_experimental_probe_locked";
        _os_log_impl(&dword_181A5C000, v16, v21, "%{public}s called with null experiment_identifier", buf, 0xCu);
      }

void sub_181FA49DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_connection *nw_connection_create_probe_locked(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (!v4)
  {
    __nwlog_obj();
    char v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v26 = "nw_connection_create_probe_locked";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v12, &v24, &v23))
    {
      if (v24 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = v24;
        if (os_log_type_enabled(v13, v24))
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v26 = "nw_connection_create_probe_locked";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null probe_parameters", buf, 0xCu);
        }
      }

      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = v24;
        BOOL v17 = os_log_type_enabled(v13, v24);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v26 = "nw_connection_create_probe_locked";
            __int16 v27 = 2082;
            BOOL v28 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null probe_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v26 = "nw_connection_create_probe_locked";
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null probe_parameters, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = v24;
        if (os_log_type_enabled(v13, v24))
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v26 = "nw_connection_create_probe_locked";
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null probe_parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FA4DA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL33nw_connection_create_probe_lockedP24NWConcrete_nw_connectionPU27objcproto16OS_nw_parameters8NSObject_block_invoke( uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  switch(a2)
  {
    case 3u:
      uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v11 && !nw_path_parameters_get_logging_disabled(*(void *)(v11 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v12 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          int v13 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          int v22 = 136446466;
          char v23 = "nw_connection_create_probe_locked_block_invoke";
          __int16 v24 = 1024;
          int v25 = v13;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Probe connection succeeded",  (uint8_t *)&v22,  0x12u);
        }
      }

      os_log_type_t v14 = *(void **)(a1 + 40);
      BOOL v9 = (nw_connection_t *)(a1 + 40);
      nw_connection_remove_probe(*(v9 - 1), v14);
      goto LABEL_20;
    case 5u:
      uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v15 && !nw_path_parameters_get_logging_disabled(*(void *)(v15 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          int v22 = 136446466;
          char v23 = "nw_connection_create_probe_locked_block_invoke";
          __int16 v24 = 1024;
          int v25 = v17;
          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Probe connection cancelled",  (uint8_t *)&v22,  0x12u);
        }
      }

      nw_connection_remove_probe(*(void **)(a1 + 32), *(void **)(a1 + 40));
      break;
    case 4u:
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v6 && !nw_path_parameters_get_logging_disabled(*(void *)(v6 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        nw_connection_t v7 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          int v8 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          int v22 = 136446466;
          char v23 = "nw_connection_create_probe_locked_block_invoke";
          __int16 v24 = 1024;
          int v25 = v8;
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Probe connection failed",  (uint8_t *)&v22,  0x12u);
        }
      }

      os_log_type_t v10 = *(void **)(a1 + 40);
      BOOL v9 = (nw_connection_t *)(a1 + 40);
      nw_connection_remove_probe(*(v9 - 1), v10);
LABEL_20:
      nw_connection_cancel(*v9);
      break;
    default:
      uint64_t v18 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v18 && !nw_path_parameters_get_logging_disabled(*(void *)(v18 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v19 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          int v20 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          if (a2 > 2) {
            os_log_type_t v21 = "unknown";
          }
          else {
            os_log_type_t v21 = off_189BB9BB8[a2];
          }
          int v22 = 136446722;
          char v23 = "nw_connection_create_probe_locked_block_invoke";
          __int16 v24 = 1024;
          int v25 = v20;
          __int16 v26 = 2080;
          __int16 v27 = v21;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Probe connection state: %s",  (uint8_t *)&v22,  0x1Cu);
        }
      }

      break;
  }
}

void sub_181FA517C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_cancel_inner(NWConcrete_nw_connection *a1, char a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = MEMORY[0x1895F87A8];
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  v9[2] = ___ZL27nw_connection_set_cancelledP24NWConcrete_nw_connection_block_invoke;
  v9[3] = &unk_189BC93A0;
  v9[4] = v3;
  os_unfair_lock_lock(&v3->lock);
  ___ZL27nw_connection_set_cancelledP24NWConcrete_nw_connection_block_invoke((uint64_t)v9);
  os_unfair_lock_unlock(&v3->lock);

  v6[0] = v4;
  v6[1] = 3221225472LL;
  v6[2] = ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke;
  v6[3] = &unk_189BC5EB8;
  id v5 = v3;
  nw_connection_t v7 = v5;
  char v8 = a2;
  nw_connection_async_if_needed(v5, v6);
}

void sub_181FA5264( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_connection_set_cancelledP24NWConcrete_nw_connection_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 109LL) |= 8u;
  return result;
}

void ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke(uint64_t a1)
{
  uint64_t v151 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 80);
  BOOL logging_disabled = nw_parameters_get_logging_disabled(*(void *)(v2 + 16));
  if (v3 != 5)
  {
    if (!logging_disabled && (nw_parameters_get_minimize_logging(*(void **)(*(void *)(a1 + 32) + 16LL)) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        int v13 = *(_DWORD *)(v12 + 448);
        logging_description = nw_endpoint_get_logging_description(*(void **)(v12 + 8));
        uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 16LL);
        os_log_type_t v16 = "force-";
        if (!*(_BYTE *)(a1 + 40)) {
          os_log_type_t v16 = "";
        }
        *(_DWORD *)__int128 buf = 67110402;
        *(_DWORD *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[8] = 1042;
        *(_DWORD *)&buf[10] = 16;
        *(_WORD *)&buf[14] = 2098;
        *(void *)&buf[16] = v12 + 452;
        *(_WORD *)&_BYTE buf[24] = 2082;
        *(void *)&buf[26] = logging_description;
        *(_WORD *)&buf[34] = 2114;
        *(void *)&buf[36] = v15;
        *(_WORD *)&buf[44] = 2082;
        *(void *)&buf[46] = v16;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEFAULT,  "[C%u %{public,uuid_t}.16P %{public}s %{public}@] %{public}scancel",  buf,  0x36u);
      }
    }

    int v17 = *(os_unfair_lock_s **)(a1 + 32);
    int os_unfair_lock_opaque = v17[20]._os_unfair_lock_opaque;
    os_log_type_t v19 = v17 + 34;
    uint64_t v20 = MEMORY[0x1895F87A8];
    v148[0] = MEMORY[0x1895F87A8];
    v148[1] = 3221225472LL;
    v148[2] = ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_232;
    v148[3] = &unk_189BC93A0;
    v149 = v17;
    os_unfair_lock_lock(v19);
    ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_232((uint64_t)v148);
    os_unfair_lock_unlock(v19);
    id v21 = *(id *)(a1 + 32);
    int v22 = v21;
    if (v21)
    {
      nw_context_assert_queue(*((void **)v21 + 3));
      uint64_t v23 = v22[53];
      if (v23)
      {
        uint64_t v24 = nw_array_create();
        if (v24 != v23)
        {
          uint64_t v25 = v24;
          std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v24 + 16,  *(void ***)(v23 + 16),  *(void ***)(v23 + 24),  (uint64_t)(*(void *)(v23 + 24) - *(void *)(v23 + 16)) >> 3);
          uint64_t v23 = v25;
        }

        nw_array_apply((unsigned __int8 *)v23, (uint64_t)&__block_literal_global_227);
      }

      goto LABEL_24;
    }

    __nwlog_obj();
    v95 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_cleanup_data_transfer_reports_on_nw_queue";
    v96 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v139[0]) = 0;
    if (__nwlog_fault(v96, type, v139))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v98 = type[0];
        if (os_log_type_enabled(v97, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_cleanup_data_transfer_reports_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v97, v98, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (LOBYTE(v139[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v104 = type[0];
        BOOL v105 = os_log_type_enabled(v97, type[0]);
        if (backtrace_string)
        {
          if (v105)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_cleanup_data_transfer_reports_on_nw_queue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v97,  v104,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_132;
        }

        if (v105)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_cleanup_data_transfer_reports_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v97, v104, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v113 = type[0];
        if (os_log_type_enabled(v97, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_cleanup_data_transfer_reports_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v97,  v113,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FA64DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_232(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 80LL) = 5;
  return result;
}

void ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 400);
  if (v2 && *(void *)(v2 + 24) != *(void *)(v2 + 16))
  {
    uint64_t v4 = *(void *)(v1 + 16);
    if (v4 && !nw_path_parameters_get_logging_disabled(*(void *)(v4 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v5 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        uint64_t v7 = *(void *)(v6 + 400);
        if (v7) {
          uint64_t v7 = (uint64_t)(*(void *)(v7 + 24) - *(void *)(v7 + 16)) >> 3;
        }
        int v8 = *(_DWORD *)(v6 + 448);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v29 = "nw_connection_cancel_probes_block_invoke";
        __int16 v30 = 1024;
        int v31 = v8;
        __int16 v32 = 2048;
        uint64_t v33 = v7;
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Waiting on %zu probes before cancelling",  buf,  0x1Cu);
      }
    }

    BOOL v9 = nw_array_create();
    os_log_type_t v10 = *(void **)(a1 + 32);
    uint64_t v11 = (unsigned __int8 *)v10[50];
    uint64_t v12 = MEMORY[0x1895F87A8];
    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    v24[2] = ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke_234;
    v24[3] = &unk_189BB9B98;
    uint64_t v25 = v10;
    int v13 = (id)v9;
    id v26 = v13;
    char v27 = *(_BYTE *)(a1 + 40);
    nw_array_apply(v11, (uint64_t)v24);
    if (v13 && v13[3] != v13[2])
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v14 && !nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v15 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          int v16 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v29 = "nw_connection_cancel_probes_block_invoke";
          __int16 v30 = 1024;
          int v31 = v16;
          _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Have probes to remove before cancel",  buf,  0x12u);
        }
      }

      v22[0] = v12;
      v22[1] = 3221225472LL;
      v22[2] = ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke_235;
      v22[3] = &unk_189BC85B0;
      id v23 = *(id *)(a1 + 32);
      nw_array_apply((unsigned __int8 *)v13, (uint64_t)v22);
    }

    uint64_t v17 = *(void *)(a1 + 32);
    uint64_t v18 = *(void *)(v17 + 400);
    if (!v18 || *(void *)(v18 + 24) == *(void *)(v18 + 16))
    {
      uint64_t v19 = *(void *)(v17 + 16);
      if (v19)
      {
        if (!nw_path_parameters_get_logging_disabled(*(void *)(v19 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v20 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
          {
            int v21 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v29 = "nw_connection_cancel_probes_block_invoke_2";
            __int16 v30 = 1024;
            int v31 = v21;
            _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] After removing invalid probes, no probes remain",  buf,  0x12u);
          }
        }
      }
    }
  }

BOOL nw_connection_endpoint_report_on_nw_queue(void *a1, int a2, int a3, uint64_t a4, void *a5, void *a6)
{
  id v11 = a1;
  id v12 = a5;
  id v13 = a6;
  uint64_t v14 = (os_unfair_lock_s *)v13;
  if (v13)
  {
    nw_context_assert_queue(*((void **)v13 + 3));
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke;
    v16[3] = &unk_189BC70B8;
    uint64_t v17 = v14;
    uint64_t v20 = a4;
    id v18 = v11;
    id v19 = v12;
    int v21 = a3;
    int v22 = a2;
    os_unfair_lock_lock(v14 + 34);
    ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v14 + 34);
  }

  return v14 != 0LL;
}

void sub_181FA6ABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_233(void *a1)
{
  int v3 = _Block_copy(*(const void **)(a1[4] + 216LL));
  uint64_t v4 = *(void *)(a1[5] + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), *(id *)(a1[4] + 408LL));
  objc_storeStrong((id *)(*(void *)(a1[7] + 8LL) + 40LL), *(id *)(a1[4] + 200LL));
  BOOL is_inline = nw_context_is_inline(*(void **)(a1[4] + 24LL));
  if (is_inline)
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    }
    id v1 = (id)nw_context_copy_implicit_context::implicit_context;
    BOOL v7 = nw_context_copy_workloop(v1);
  }

  else
  {
    BOOL v7 = nw_context_copy_workloop(*(void **)(a1[4] + 24LL));
  }

  objc_storeStrong((id *)(*(void *)(a1[8] + 8LL) + 40LL), (id)v7);
  if (is_inline)
  {

    BOOL v7 = (BOOL)v1;
  }

  int v8 = _Block_copy(*(const void **)(a1[4] + 208LL));
  uint64_t v9 = *(void *)(a1[9] + 8LL);
  os_log_type_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;

  uint64_t v11 = a1[4];
  id v12 = *(void **)(v11 + 216);
  *(void *)(v11 + 216) = 0LL;

  uint64_t v13 = a1[4];
  uint64_t v14 = *(void **)(v13 + 48);
  *(void *)(v13 + 4_Block_object_dispose(va, 8) = 0LL;
}

void sub_181FA6C14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(void *)(*(void *)(v2 + 8) + 40LL))
  {
    int v3 = *(_DWORD **)(a1 + 32);
    uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
    dispatch_qos_class_t v5 = v3[48];
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    v6[2] = ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_3;
    v6[3] = &unk_189BC9210;
    uint64_t v8 = v2;
    BOOL v7 = v3;
    nw_connection_async_on_queue(v7, v4, v5, v6);
  }

void sub_181FA6CE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

void nw_connection_report_state_with_handler_on_nw_queue(void *a1, unsigned int a2, void *a3, void *a4)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a3;
  id v9 = a4;
  if (!v7)
  {
    __nwlog_obj();
    int v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v44 = "nw_connection_report_state_with_handler_on_nw_queue";
    id v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault(v23, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v44 = "nw_connection_report_state_with_handler_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v41)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v44 = "nw_connection_report_state_with_handler_on_nw_queue";
            __int16 v45 = 2082;
            *(void *)os_log_type_t v46 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_72;
        }

        if (v28)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v44 = "nw_connection_report_state_with_handler_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v44 = "nw_connection_report_state_with_handler_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FA740C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) + 16LL))();
}

void nw_connection_async_on_queue(void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if (nw_parameters_is_persona_set(v7[2]))
  {
    os_log_type_t v10 = (void *)v7[2];
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = ___ZL28nw_connection_async_on_queueP24NWConcrete_nw_connectionPU28objcproto17OS_dispatch_queue8NSObject11qos_class_tU13block_pointerFvvE_block_invoke;
    v11[3] = &unk_189BC16F8;
    uint64_t v12 = v7;
    id v13 = v8;
    dispatch_qos_class_t v15 = a3;
    id v14 = v9;
    nw_utilities_execute_block_as_persona_from_parameters(v10, v11);
  }

  else
  {
    __nw_connection_async_on_queue(v7, v8, a3, v9);
  }
}

void sub_181FA7564( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void ___ZL28nw_connection_async_on_queueP24NWConcrete_nw_connectionPU28objcproto17OS_dispatch_queue8NSObject11qos_class_tU13block_pointerFvvE_block_invoke( uint64_t a1)
{
}

void __nw_connection_async_on_queue(void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if (v8)
  {
    dispatch_block_t v10 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, a3, 0, v9);
    dispatch_async(v8, v10);

    goto LABEL_3;
  }

  if (!v7[5])
  {
    nw_context_queue_block(v7[3], v9);
    goto LABEL_3;
  }

  uint64_t v11 = v7[2];
  if (v11 && !nw_path_parameters_get_logging_disabled(v11[13]))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v12 = (id)gconnectionLogObj;
    int v13 = *((_DWORD *)v7 + 112);
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v30 = "__nw_connection_async_on_queue";
    __int16 v31 = 1024;
    int v32 = v13;
    id v14 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault((const char *)v14, &type, &v27))
    {
LABEL_16:
      if (!v14) {
        goto LABEL_3;
      }
LABEL_17:
      free(v14);
      goto LABEL_3;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      dispatch_qos_class_t v15 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        int v17 = *((_DWORD *)v7 + 112);
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v30 = "__nw_connection_async_on_queue";
        __int16 v31 = 1024;
        int v32 = v17;
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s [C%u] unable to dispatch block", buf, 0x12u);
      }

void sub_181FA79D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL51nw_connection_report_state_with_handler_on_nw_queueP24NWConcrete_nw_connection21nw_connection_state_tU13block_pointerFvS1_PU22objcproto11OS_nw_error8NSObjectEPU28objcproto17OS_dispatch_queueS2__block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 48) + 16LL))( *(void *)(a1 + 48),  *(unsigned int *)(a1 + 56),  *(void *)(a1 + 32));
}

void __nw_connection_report_error_to_proxy_agent_on_nw_queue_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  memset(uu, 0, 16);
  id v6 = nw_parameters_copy_effective_proxy_config(a2);
  id v7 = v6;
  if (!v6)
  {
LABEL_10:

    int is_null = uuid_is_null(uu);
    uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (is_null)
    {
      if (v16 && !nw_path_parameters_get_logging_disabled(*(void *)(v16 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          int v18 = *(_DWORD *)(a1 + 40);
          int v22 = 136446722;
          os_log_type_t v23 = "nw_connection_report_error_to_proxy_agent_on_nw_queue_block_invoke";
          __int16 v24 = 1024;
          int v25 = v17;
          __int16 v26 = 1024;
          int v27 = v18;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Cannot report error %d, no proxy agent",  (uint8_t *)&v22,  0x18u);
        }

        id v8 = 0LL;
        goto LABEL_18;
      }
    }

    else
    {
      if (v16 && !nw_path_parameters_get_logging_disabled(*(void *)(v16 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v19 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          int v20 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          int v21 = *(_DWORD *)(a1 + 40);
          int v22 = 136447234;
          os_log_type_t v23 = "nw_connection_report_error_to_proxy_agent_on_nw_queue_block_invoke";
          __int16 v24 = 1024;
          int v25 = v20;
          __int16 v26 = 1024;
          int v27 = v21;
          __int16 v28 = 1042;
          int v29 = 16;
          __int16 v30 = 2098;
          __int16 v31 = uu;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Reporting error %d to proxy agent %{public, uuid_t}.16P",  (uint8_t *)&v22,  0x28u);
        }
      }

      nw_path_report_error_to_agent(v5, uu, *(_DWORD *)(a1 + 40));
    }

    id v8 = 0LL;
    goto LABEL_28;
  }

  id v8 = v6;
  char v9 = v8[170];

  if ((v9 & 1) != 0)
  {
    id v14 = v8;
    *(_OWORD *)uu = *(_OWORD *)(v14 + 56);

    goto LABEL_10;
  }

  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v10 && !nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v13 = *(_DWORD *)(a1 + 40);
      int v22 = 136446722;
      os_log_type_t v23 = "nw_connection_report_error_to_proxy_agent_on_nw_queue_block_invoke";
      __int16 v24 = 1024;
      int v25 = v12;
      __int16 v26 = 1024;
      int v27 = v13;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Not reporting error %d, not privacy proxy",  (uint8_t *)&v22,  0x18u);
    }

void sub_181FA7D24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_report_error_to_proxy_agent_on_nw_queue_block_invoke_25(uint64_t a1, void *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if ((int)nw_endpoint_handler_get_state(v3) >= 1 && (int)nw_endpoint_handler_get_state(v3) <= 4)
  {
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v3) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      dispatch_qos_class_t v15 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v3);
        int v17 = nw_endpoint_handler_dry_run_string(v3);
        nw_endpoint_t v24 = nw_endpoint_handler_copy_endpoint(v3);
        logging_description = nw_endpoint_get_logging_description(v24);
        id v19 = nw_endpoint_handler_state_string(v3);
        int v20 = nw_endpoint_handler_mode_string(v3);
        id v21 = nw_endpoint_handler_copy_current_path(v3);
        int v22 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136448002;
        __int16 v26 = "nw_connection_report_error_to_proxy_agent_on_nw_queue_block_invoke";
        __int16 v27 = 2082;
        __int16 v28 = id_string;
        os_log_type_t v23 = v21;
        __int16 v29 = 2082;
        __int16 v30 = v17;
        __int16 v31 = 2082;
        int v32 = logging_description;
        __int16 v33 = 2082;
        id v34 = v19;
        __int16 v35 = 2082;
        id v36 = v20;
        __int16 v37 = 2114;
        id v38 = v21;
        __int16 v39 = 1024;
        int v40 = v22;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] reporting proxy error %d",  buf,  0x4Eu);
      }
    }

    id v4 = nw_endpoint_handler_copy_parameters(v3);
    id v5 = nw_endpoint_handler_copy_current_path(v3);
    id v6 = v5;
    if (v4 && v5) {
      (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    }

LABEL_8:
    goto LABEL_10;
  }

  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v3) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEBUG))
    {
      id v8 = nw_endpoint_handler_get_id_string(v3);
      char v9 = nw_endpoint_handler_dry_run_string(v3);
      nw_endpoint_t v10 = nw_endpoint_handler_copy_endpoint(v3);
      uint64_t v11 = nw_endpoint_get_logging_description(v10);
      int v12 = nw_endpoint_handler_state_string(v3);
      int v13 = nw_endpoint_handler_mode_string(v3);
      *(_DWORD *)__int128 buf = 136447746;
      __int16 v26 = "nw_connection_report_error_to_proxy_agent_on_nw_queue_block_invoke";
      __int16 v27 = 2082;
      __int16 v28 = v8;
      id v14 = nw_endpoint_handler_copy_current_path(v3);
      __int16 v29 = 2082;
      __int16 v30 = v9;
      __int16 v31 = 2082;
      int v32 = v11;
      __int16 v33 = 2082;
      id v34 = v12;
      __int16 v35 = 2082;
      id v36 = v13;
      __int16 v37 = 2114;
      id v38 = v14;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] skipping endpoint handler that is not in correct state for reporting proxy errors",  buf,  0x48u);
    }

    goto LABEL_8;
  }

void sub_181FA8080( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke( uint64_t a1)
{
  uint64_t v550 = *MEMORY[0x1895F89C0];
  uint64_t v2 = mach_continuous_time();
  if (v2 <= 1) {
    uint64_t v3 = 1LL;
  }
  else {
    uint64_t v3 = v2;
  }
  unint64_t v4 = nw_delta_nanos(*(void *)(*(void *)(a1 + 32) + 72LL), v3);
  unint64_t v5 = v4 / 0xF4240;
  if (v4 > 0xF423FFFFFFFFFLL) {
    LODWORD(v5) = -1;
  }
  int v519 = v5;
  if (!*(void *)(a1 + 56)) {
    goto LABEL_51;
  }
  id v6 = *(void **)(a1 + 40);
  if (!v6) {
    goto LABEL_51;
  }
  id v7 = v6;
  char v8 = v7[268];

  if ((v8 & 1) != 0) {
    goto LABEL_51;
  }
  char v9 = *(void **)(a1 + 48);
  if (!v9)
  {
    LOBYTE(v15) = -1;
    goto LABEL_38;
  }

  id v10 = *(id *)(a1 + 32);
  id v11 = v9;
  if (!v10)
  {
    __nwlog_obj();
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
    int v17 = (char *)_os_log_send_and_compose_impl();

    aBlock[0] = 16;
    v537[0] = 0;
    if (__nwlog_fault(v17, aBlock, v537))
    {
      if (aBlock[0] == 17)
      {
        __nwlog_obj();
        int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = aBlock[0];
        if (os_log_type_enabled(v18, (os_log_type_t)aBlock[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v537[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = aBlock[0];
        BOOL v22 = os_log_type_enabled(v18, (os_log_type_t)aBlock[0]);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_34;
        }

        if (v22)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v18, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = aBlock[0];
        if (os_log_type_enabled(v18, (os_log_type_t)aBlock[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_818:
          if (v454) {
            free(v454);
          }
LABEL_237:

          v149 = (void **)*(id *)(a1 + 32);
          v150 = v149;
          if (v149)
          {
            nw_context_assert_queue(v149[3]);
            if ((nw_parameters_get_is_probe(v150[2]) & 1) != 0) {
              goto LABEL_313;
            }
            uint64_t v151 = v150;
            nw_context_assert_queue(v150[3]);
            if (!nw_connection_should_run_probe_locked(v151)
              || (*((_BYTE *)v150[2] + 101) & 0x40) == 0
              && !networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_enable_tls_experiments))
            {
LABEL_262:

              v168 = v151;
              nw_context_assert_queue(v150[3]);
              if (!nw_connection_should_run_probe_locked(v168))
              {
LABEL_312:

                goto LABEL_313;
              }

              if ((nw_parameters_get_tls(v150[2]) & 1) == 0)
              {
                v195 = v150[2];
                if (!v195 || nw_path_parameters_get_logging_disabled(v195[13])) {
                  goto LABEL_312;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v169 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v169, OS_LOG_TYPE_DEBUG))
                {
                  unsigned int top_id = v168->top_id;
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = top_id;
                  _os_log_impl( &dword_181A5C000,  v169,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] stack doesn't include TLS; not running ECH probe",
                    buf,
                    0x12u);
                }

                goto LABEL_311;
              }

              v169 = (os_log_s *)nw_protocol_boringssl_copy_definition();
              id v170 = nw_connection_copy_protocol_metadata_locked((uint64_t)v168, v169, 0, 0);
              v171 = v170;
              if (v170)
              {
                v172 = (sec_protocol_metadata *)v170;
                if (sec_protocol_metadata_get_negotiated_protocol_version(v172) != kTLSProtocol13)
                {
                  v199 = v150[2];
                  if (v199 && !nw_path_parameters_get_logging_disabled(v199[13]))
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v200 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v200, OS_LOG_TYPE_DEBUG))
                    {
                      unsigned int v201 = v168->top_id;
                      *(_DWORD *)__int128 buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v201;
                      _os_log_impl( &dword_181A5C000,  v200,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] TLS 1.3 wasn't the negotiated protocol; not running ECH probe",
                        buf,
                        0x12u);
                    }
                  }

                  goto LABEL_309;
                }

                if (nw_endpoint_get_type(v168->endpoint) == nw_endpoint_type_host)
                {
                  v520 = v168;
                  v173 = (void *)nw_endpoint_handler_copy_connected_path(v520->parent_endpoint_handler);
                  v174 = v173;
                  if (!v173)
                  {
                    v329 = v150[2];
                    if (v329 && !nw_path_parameters_get_logging_disabled(v329[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v330 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v330, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v331 = v520->top_id;
                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_has_eligible_interface_for_probe";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v331;
                        _os_log_impl( &dword_181A5C000,  v330,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] no connected path, not probing",  buf,  0x12u);
                      }
                    }

                    goto LABEL_309;
                  }

                  v175 = (nw_interface *)nw_path_copy_interface(v173);
                  v176 = v175;
                  if (!v175
                    || nw_interface_get_type(v175) != nw_interface_type_cellular
                    && nw_interface_get_type(v176) != nw_interface_type_wifi
                    && nw_interface_get_type(v176) != nw_interface_type_wired)
                  {
                    v337 = v150[2];
                    if (v337 && !nw_path_parameters_get_logging_disabled(v337[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v338 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v338, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v339 = v520->top_id;
                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_has_eligible_interface_for_probe";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v339;
                        _os_log_impl( &dword_181A5C000,  v338,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] no interface or ineligible interface type, not probing",  buf,  0x12u);
                      }
                    }

                    goto LABEL_309;
                  }

                  if (nw_parameters_get_should_skip_probe_sampling(v150[2]))
                  {
                    v177 = v150[2];
                    if (v177 && !nw_path_parameters_get_logging_disabled(v177[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v178 = (os_log_s *)(id)gconnectionLogObj;
                      if (!os_log_type_enabled(v178, OS_LOG_TYPE_INFO)) {
                        goto LABEL_280;
                      }
                      unsigned int v179 = v520->top_id;
                      *(_DWORD *)__int128 buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v179;
                      v180 = "%{public}s [C%u] sampling overridden, running ECH probe";
                      v181 = v178;
                      os_log_type_t v182 = OS_LOG_TYPE_INFO;
                      uint32_t v183 = 18;
LABEL_279:
                      _os_log_impl(&dword_181A5C000, v181, v182, v180, buf, v183);
LABEL_280:

                      goto LABEL_281;
                    }

                    goto LABEL_281;
                  }

                  if (networkd_settings_get_BOOL((const char *)nw_setting_ech_probe_enabled))
                  {
                    uint32_t int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_ech_probe_numerator,  0LL);
                    uint32_t v341 = networkd_settings_get_int64_with_default((const char *)nw_setting_ech_probe_denominator, 0LL);
                    if (arc4random_uniform(v341) < int64_with_default)
                    {
                      v342 = v150[2];
                      if (v342 && !nw_path_parameters_get_logging_disabled(v342[13]))
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        v178 = (os_log_s *)(id)gconnectionLogObj;
                        if (!os_log_type_enabled(v178, OS_LOG_TYPE_DEBUG)) {
                          goto LABEL_280;
                        }
                        unsigned int v343 = v520->top_id;
                        *(_DWORD *)__int128 buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v343;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = int64_with_default;
                        *(_WORD *)&_BYTE buf[24] = 1024;
                        *(_DWORD *)&buf[26] = v341;
                        v180 = "%{public}s [C%u] ECH probe sampled at %u / %u";
                        v181 = v178;
                        os_log_type_t v182 = OS_LOG_TYPE_DEBUG;
                        uint32_t v183 = 30;
                        goto LABEL_279;
                      }

          if (v442) {
            free(v442);
          }
          id v38 = v441;
LABEL_86:
          *(void *)__int128 buf = 0LL;
          *(void *)&buf[8] = buf;
          *(void *)&buf[16] = 0x2000000000LL;
          v608 = (uint64_t)v41;
          aBlock = v54;
          v585 = 0x40000000LL;
          v586 = ___ZL26nw_http1_connection_createP11nw_protocolP17nw_protocol_http1P11nw_endpointP13nw_parameters_block_invoke_2;
          v587 = &unk_189BBD4F0;
          v588 = (uint64_t *)buf;
          *((void *)v41 + 76) = _Block_copy(&aBlock);
          _Block_object_dispose(buf, 8);
          if ((*((_BYTE *)v41 + 158) & 1) == 0)
          {
            if (gLogDatapath)
            {
              v455 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v455, OS_LOG_TYPE_DEBUG))
              {
                os_log_type_t v456 = *((void *)v41 + 61);
                v457 = *(_DWORD *)(*((void *)v41 + 60) + 372LL);
                v458 = *((_DWORD *)v41 + 215);
                if (v456) {
                  LODWORD(v456) = *(_DWORD *)(v456 + 424);
                }
                *(_DWORD *)__int128 buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_create";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = (char *)v41 + 74;
                *(_WORD *)&_BYTE buf[22] = 2080;
                v608 = (uint64_t)" ";
                *(_WORD *)v609 = 1024;
                *(_DWORD *)&v609[2] = v457;
                *(_WORD *)&v609[6] = 1024;
                *(_DWORD *)&v609[8] = v458;
                *(_WORD *)&v609[12] = 1024;
                *(_DWORD *)&v609[14] = v456;
                *(_WORD *)&v609[18] = 2048;
                *(void *)&v609[20] = v41;
                _os_log_impl( &dword_181A5C000,  v455,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> created %p",  buf,  0x3Cu);
              }
            }
          }

          unint64_t v65 = (nw_path **)(v41 + 32);
          nw_protocol_replace_input_handler((uint64_t)v38, v579, (uint64_t)v41);
          *BOOL v41 = *v38;
          unsigned int v66 = (void *)*((void *)v41 + 92);
          if (v66)
          {
            int v67 = v580;
            __int16 v68 = &qword_18C45F000;
            if (!*((void *)v41 + 66))
            {
              __int16 v69 = (void **)(v41 + 35);
              os_log_type_t v70 = nw_parameters_copy_context(*((void **)v41 + 92));
              *(void *)__int128 buf = nw_path_copy_flow_registration(v70, (uint64_t)v41);
              nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v41 + 35), buf);
              int v71 = (void *)*((void *)v41 + 70);
              if (v71)
              {
                id v72 = v38;
                v73 = nw_path_flow_registration_copy_endpoint(v71);
                id v74 = nw_path_flow_registration_copy_parameters(*v69);
                *(void *)__int128 buf = nw_endpoint_copy_association_with_evaluator(v73, v74, 0LL);
                nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v41 + 33), buf);
                if (*((void *)v41 + 66))
                {
                  *(void *)__int128 buf = nw_protocol_instance_stub_create((nw_protocol *)v41);
                  nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v41 + 34), buf);
                  nw_association_register_internal( *((void **)v41 + 66),  v66,  *((void **)v41 + 68),  0,  0,  &__block_literal_global_65);
                  nw_endpoint_t v75 = nw_association_copy_current_path(*((void **)v41 + 66), v74);
                  if (v75)
                  {
                    v76 = v75;
                    v77 = (nw_path *)nw_path_copy_for_flow_registration(v75, *v69);
                    if (v77)
                    {
                      uint64_t v78 = v77;
                      if (*v65 != v77)
                      {
                        *(void *)__int128 buf = os_retain(v77);
                        nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v41 + 32), buf);
                      }

                      if (nw_path_has_flows(v78)) {
                        id v79 = 4096;
                      }
                      else {
                        id v79 = 0;
                      }
                      v80 = *((_WORD *)v41 + 436) & 0xEFFF | (*((unsigned __int8 *)v41 + 874) << 16);
                      *((_WORD *)v41 + 436) = *((_WORD *)v41 + 436) & 0xEFFF | v79;
                      *((_BYTE *)v41 + 874) = BYTE2(v80);
                      int v81 = nw_parameters_copy_effective_proxy_config(v66);
                      if (v81)
                      {
                        uint64_t v82 = v81;
                        if (nw_path_has_proxy_config(v76, v81))
                        {
                          *(void *)__int128 buf = os_retain(v82);
                          nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v41 + 36), buf);
                        }

                        os_release(v82);
                      }

                      os_release(v78);
                    }

                    os_release(v76);
                  }
                }

                if (v74) {
                  os_release(v74);
                }
                id v38 = v72;
                if (v73) {
                  os_release(v73);
                }
              }

              int v67 = v580;
              __int16 v68 = &qword_18C45F000;
              if (v70)
              {
                os_release(v70);
                __int16 v68 = &qword_18C45F000;
                int v67 = v580;
              }
            }

            v83 = *v65;
            if (*v65)
            {
LABEL_112:
              v84 = nw_path_uses_interface_type(v83, nw_interface_type_cellular);
              __int16 v68 = &qword_18C45F000;
              int v67 = v580;
              if (v84) {
                *((void *)v41 + 24) = 1000LL;
              }
            }

LABEL_557:
                    v349 = v150[2];
                    if (v349 && !nw_path_parameters_get_logging_disabled(v349[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v350 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v350, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v351 = v520->top_id;
                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v351;
                        _os_log_impl( &dword_181A5C000,  v350,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] connection wasn't sampled for ECH probe",  buf,  0x12u);
                      }
                    }

                    goto LABEL_309;
                  }

                  v346 = v150[2];
                  if (v346)
                  {
                    if (!nw_path_parameters_get_logging_disabled(v346[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v347 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v347, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v348 = v520->top_id;
                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v348;
                        _os_log_impl( &dword_181A5C000,  v347,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] ECH probes not enabled on this network",  buf,  0x12u);
                      }
                    }

                    goto LABEL_557;
                  }
                }
              }

              else
              {
                v197 = v150[2];
                if (!v197 || nw_path_parameters_get_logging_disabled(v197[13])) {
                  goto LABEL_310;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v172 = (sec_protocol_metadata *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v172, OS_LOG_TYPE_DEBUG))
                {
                  unsigned int v198 = v168->top_id;
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v198;
                  _os_log_impl( &dword_181A5C000,  v172,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] No TLS metadata; not running ECH probe",
                    buf,
                    0x12u);
                }
              }

          if (!v267) {
            goto LABEL_559;
          }
          goto LABEL_558;
        }

      free(v293);
      goto LABEL_558;
    }

    uint64_t v294 = (os_log_s *)__nwlog_obj();
    uint64_t v295 = __len[1];
    if (!os_log_type_enabled(v294, __len[1])) {
      goto LABEL_556;
    }
    *(_DWORD *)__int128 buf = 136446210;
    v364 = "nw_http1_get_http1_protocol";
    id v296 = "%{public}s called with null handle";
    goto LABEL_555;
  }

  uint64_t v3 = *((_DWORD *)handle + 6);
  unint64_t v4 = a1->handle;
  if (v3 == 1) {
    goto LABEL_10;
  }
  if (v3 != 2)
  {
    if (v3 != 3) {
      goto LABEL_558;
    }
    unint64_t v5 = *((void *)handle + 2);
    if (v5)
    {
      unint64_t v4 = (void *)(v5 + 480);
      goto LABEL_10;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v364 = "nw_http1_get_http1_protocol";
    uint64_t v293 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__len[1]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v293, &__len[1], type))
    {
      if (LOBYTE(__len[1]) == 17)
      {
        uint64_t v294 = (os_log_s *)__nwlog_obj();
        uint64_t v295 = __len[1];
        if (!os_log_type_enabled(v294, __len[1])) {
          goto LABEL_556;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v364 = "nw_http1_get_http1_protocol";
        id v296 = "%{public}s called with null handle->http1_connection";
        goto LABEL_555;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v294 = (os_log_s *)__nwlog_obj();
        uint64_t v295 = __len[1];
        if (!os_log_type_enabled(v294, __len[1])) {
          goto LABEL_556;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v364 = "nw_http1_get_http1_protocol";
        id v296 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_555;
      }

      v304 = (char *)__nw_create_backtrace_string();
      uint64_t v294 = (os_log_s *)__nwlog_obj();
      uint64_t v295 = __len[1];
      os_log_type_t v323 = os_log_type_enabled(v294, __len[1]);
      if (!v304)
      {
        if (!v323) {
          goto LABEL_556;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v364 = "nw_http1_get_http1_protocol";
        id v296 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_555;
      }

      if (v323)
      {
        *(_DWORD *)__int128 buf = 136446466;
        v364 = "nw_http1_get_http1_protocol";
        v365 = 2082;
        *(void *)v366 = v304;
        int v306 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
        goto LABEL_463;
      }

      goto LABEL_464;
    }

LABEL_823:
          if (v458) {
            free(v458);
          }
LABEL_313:

          v202 = (void **)*(id *)(a1 + 32);
          v203 = v202;
          if (v202)
          {
            nw_context_assert_queue(v202[3]);
            v204 = nw_endpoint_handler_copy_connected_flow_handler(v203[18]);
            v205 = v204;
            if (v204)
            {
              v206 = v204;
              id v207 = v206[4];

              if (v207)
              {
                id v208 = v207;
                v209 = v208;
                if (*((void *)v208 + 24)
                  || (v215 = (void *)*((void *)v208 + 23)) != 0LL
                  && (v216 = v215, BOOL v217 = (v216[171] & 0x40) == 0, v216, !v217))
                {

                  uint32_t v210 = networkd_settings_get_int64_with_default( (const char *)nw_setting_proxy_race_report_numerator,  1LL);
                  uint32_t v211 = networkd_settings_get_int64_with_default( (const char *)nw_setting_proxy_race_report_denominator,  20000LL);
                  if (arc4random_uniform(v211) < v210)
                  {
                    v212 = v203[2];
                    if (v212 && !nw_path_parameters_get_logging_disabled(v212[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v213 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v213, OS_LOG_TYPE_DEBUG))
                      {
                        int v214 = *((_DWORD *)v203 + 112);
                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v214;
                        _os_log_impl( &dword_181A5C000,  v213,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] selected for reporting (proxy race)",  buf,  0x12u);
                      }
                    }

                    *((_BYTE *)v203 + 109) |= 2u;
                  }
                }

                else
                {
                }
              }
            }

            goto LABEL_331;
          }

          __nwlog_obj();
          v461 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
          v462 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v537[0] = 0;
          if (__nwlog_fault(v462, aBlock, v537))
          {
            if (aBlock[0] == 17)
            {
              __nwlog_obj();
              v463 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v464 = aBlock[0];
              if (os_log_type_enabled(v463, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                _os_log_impl(&dword_181A5C000, v463, v464, "%{public}s called with null connection", buf, 0xCu);
              }
            }

            else if (v537[0])
            {
              v478 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v463 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v479 = aBlock[0];
              BOOL v480 = os_log_type_enabled(v463, (os_log_type_t)aBlock[0]);
              if (v478)
              {
                if (v480)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v478;
                  _os_log_impl( &dword_181A5C000,  v463,  v479,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v478);
                goto LABEL_828;
              }

              if (v480)
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                _os_log_impl( &dword_181A5C000,  v463,  v479,  "%{public}s called with null connection, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v463 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v494 = aBlock[0];
              if (os_log_type_enabled(v463, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                _os_log_impl( &dword_181A5C000,  v463,  v494,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

      if (v455) {
        free(v455);
      }
      *(_DWORD *)(v9 + 352) = -1;
      goto LABEL_826;
    }

    __nwlog_obj();
    os_log_type_t v326 = *(unsigned int *)(v9 + 348);
    *(_DWORD *)__int128 buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "http1->pending_stream_count";
    *(_WORD *)&_BYTE buf[22] = 2048;
    v783 = 1LL;
    *(_WORD *)v784 = 2048;
    *(void *)&v784[2] = v326;
    v327 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(aBlock) = 0;
    if (__nwlog_fault(v327, type, &aBlock))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v328 = (os_log_s *)__nwlog_obj();
        v329 = type[0];
        if (os_log_type_enabled(v328, type[0]))
        {
          v330 = *(unsigned int *)(v9 + 348);
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->pending_stream_count";
          *(_WORD *)&_BYTE buf[22] = 2048;
          v783 = 1LL;
          *(_WORD *)v784 = 2048;
          *(void *)&v784[2] = v330;
          unsigned int v331 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_660:
          _os_log_impl(&dword_181A5C000, v328, v329, v331, buf, 0x2Au);
        }
      }

      else if ((_BYTE)aBlock)
      {
        int v385 = (char *)__nw_create_backtrace_string();
        v328 = (os_log_s *)__nwlog_obj();
        v329 = type[0];
        int v386 = os_log_type_enabled(v328, type[0]);
        if (v385)
        {
          if (v386)
          {
            v387 = *(unsigned int *)(v9 + 348);
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->pending_stream_count";
            *(_WORD *)&_BYTE buf[22] = 2048;
            v783 = 1LL;
            *(_WORD *)v784 = 2048;
            *(void *)&v784[2] = v387;
            *(_WORD *)&v784[10] = 2082;
            *(void *)&v784[12] = v385;
            _os_log_impl( &dword_181A5C000,  v328,  v329,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v385);
          goto LABEL_661;
        }

        if (v386)
        {
          uint64_t v408 = *(unsigned int *)(v9 + 348);
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->pending_stream_count";
          *(_WORD *)&_BYTE buf[22] = 2048;
          v783 = 1LL;
          *(_WORD *)v784 = 2048;
          *(void *)&v784[2] = v408;
          unsigned int v331 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_660;
        }
      }

      else
      {
        v328 = (os_log_s *)__nwlog_obj();
        v329 = type[0];
        if (os_log_type_enabled(v328, type[0]))
        {
          v398 = *(unsigned int *)(v9 + 348);
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->pending_stream_count";
          *(_WORD *)&_BYTE buf[22] = 2048;
          v783 = 1LL;
          *(_WORD *)v784 = 2048;
          *(void *)&v784[2] = v398;
          unsigned int v331 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_660;
        }
      }
    }

                                  if (v479) {
                                    free(v479);
                                  }
                                }

                                if ((*(_BYTE *)(v6 + 158) & 1) == 0)
                                {
                                  os_log_type_t v497 = (os_log_s *)__nwlog_obj();
                                  if (os_log_type_enabled(v497, OS_LOG_TYPE_DEBUG))
                                  {
                                    BOOL v498 = *(void *)(v6 + 488);
                                    os_log_type_t v499 = *(_DWORD *)(*(void *)(v6 + 480) + 372LL);
                                    v500 = *(_DWORD *)(v6 + 860);
                                    if (v498) {
                                      LODWORD(v49_Block_object_dispose(va, 8) = *(_DWORD *)(v498 + 424);
                                    }
                                    *(_DWORD *)__int128 buf = 136447746;
                                    *(void *)&uint8_t buf[4] = "nw_http1_connection_send_final_chunk";
                                    v638 = 2082;
                                    *(void *)v639 = v6 + 74;
                                    *(_WORD *)&v639[8] = 2080;
                                    *(void *)&v639[10] = " ";
                                    *(_WORD *)&v639[18] = 1024;
                                    *(_DWORD *)v640 = v499;
                                    *(_WORD *)&v640[4] = 1024;
                                    *(_DWORD *)&v640[6] = v500;
                                    *(_WORD *)v641 = 1024;
                                    *(_DWORD *)&v641[2] = v498;
                                    *(_WORD *)&v641[6] = 1024;
                                    *(_DWORD *)&v641[8] = 5;
                                    _os_log_impl( &dword_181A5C000,  v497,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> output handler refused frame request for frames of length %u",  buf,  0x38u);
                                  }
                                }

                                goto LABEL_779;
                              }

                              __nwlog_obj();
                              *(_DWORD *)__int128 buf = 136446210;
                              *(void *)&uint8_t buf[4] = "nw_http1_connection_send_final_chunk";
                              v518 = (char *)_os_log_send_and_compose_impl();
                              LOBYTE(v643) = 16;
                              LOBYTE(v647) = 0;
                              if (v643 == 17)
                              {
                                int v519 = (os_log_s *)__nwlog_obj();
                                v520 = v643;
                                if (os_log_type_enabled(v519, (os_log_type_t)v643))
                                {
                                  *(_DWORD *)__int128 buf = 136446210;
                                  *(void *)&uint8_t buf[4] = "nw_http1_connection_send_final_chunk";
                                  v521 = "%{public}s called with null output_handler";
                                  goto LABEL_975;
                                }

LABEL_828:
          if (v462) {
            free(v462);
          }
LABEL_331:

          id v218 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          v219 = v218;
          if (v218)
          {
            if (nw_path_is_multilayer_packet_logging_enabled(v218))
            {
              *(void *)aBlock = 0LL;
              *(void *)&aBlock[8] = 0LL;
              if (nw_endpoint_handler_get_flow_id(*(void **)(a1 + 40), aBlock))
              {
                uint64_t v220 = *(void *)(*(void *)(a1 + 32) + 16LL);
                if (v220 && !nw_path_parameters_get_logging_disabled(*(void *)(v220 + 104)))
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v221 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v221, OS_LOG_TYPE_DEFAULT))
                  {
                    int v222 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
                    *(_DWORD *)__int128 buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v222;
                    _os_log_impl( &dword_181A5C000,  v221,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%u] Multilayer packet logging enabled",  buf,  0x12u);
                  }
                }

                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v223 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v223, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v224 = *(void *)(a1 + 32);
                  int v225 = *(_DWORD *)(v224 + 448);
                  *(_DWORD *)__int128 buf = 67110146;
                  *(_DWORD *)&uint8_t buf[4] = v225;
                  *(_WORD *)&buf[8] = 1042;
                  *(_DWORD *)&buf[10] = 16;
                  *(_WORD *)&buf[14] = 2098;
                  *(void *)&buf[16] = v224 + 452;
                  *(_WORD *)&_BYTE buf[24] = 1042;
                  *(_DWORD *)&buf[26] = 16;
                  *(_WORD *)&buf[30] = 2098;
                  *(void *)v524 = aBlock;
                  _os_log_impl( &dword_181A5C000,  v223,  OS_LOG_TYPE_DEFAULT,  "[C%u %{public,uuid_t}.16P] newly connected endpoint handler with UUID %{public,uuid_t}.16P",  buf,  0x28u);
                }

                pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
                v226 = (os_log_s *)gMpklLogObj;
                if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v227 = *(void *)(a1 + 32);
                  uint64_t v228 = v227 + 452;
                  LODWORD(v227) = *(unsigned __int8 *)(v227 + 500);
                  *(_DWORD *)__int128 buf = 67110658;
                  *(_DWORD *)&uint8_t buf[4] = 140;
                  *(_WORD *)&buf[8] = 1024;
                  *(_DWORD *)&buf[10] = 150;
                  *(_WORD *)&buf[14] = 1042;
                  *(_DWORD *)&buf[16] = 16;
                  *(_WORD *)&buf[20] = 2098;
                  *(void *)&_BYTE buf[22] = v228;
                  *(_WORD *)&buf[30] = 1042;
                  *(_DWORD *)v524 = 16;
                  *(_WORD *)&v524[4] = 2098;
                  *(void *)&v524[6] = aBlock;
                  *(_WORD *)&v524[14] = 1024;
                  *(_DWORD *)&v524[16] = v227;
                  _os_log_impl( &dword_181A5C000,  v226,  OS_LOG_TYPE_DEFAULT,  "33 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, nextUUID: %{public}.16P, logSeqn: %hhu}",  buf,  0x34u);
                }

                ++*(_BYTE *)(*(void *)(a1 + 32) + 500LL);
              }
            }
          }

          uint64_t v229 = *(void *)(a1 + 32);
          v230 = *(void **)(v229 + 440);
          *(void *)(v229 + 440) = 0LL;

          v231 = *(void **)(*(void *)(a1 + 32) + 432LL);
          *(void *)(*(void *)(a1 + 32) + 432LL) = 0LL;

          v232 = nw_endpoint_handler_copy_connected_flow_handler(*(void **)(a1 + 40));
          uint64_t v233 = MEMORY[0x1895F87A8];
          v521[0] = MEMORY[0x1895F87A8];
          v521[1] = 3221225472LL;
          v521[2] = ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke_214;
          v521[3] = &unk_189BB9A20;
          id v522 = *(id *)(a1 + 32);
          nw_endpoint_handler_access_proxy_handler(v232, v521);
          nw_connection_fillout_establishment_report_on_nw_queue(*(void **)(a1 + 32), 1);
          uint64_t v234 = *(void *)(a1 + 32);
          if ((*(_BYTE *)(v234 + 108) & 1) == 0)
          {
            v235 = (id *)(id)v234;
            id v236 = v235[2];

            uint64_t v234 = *(void *)(a1 + 32);
          }

          id v237 = nw_endpoint_handler_copy_current_path(*(void **)(v234 + 144));
          v238 = v237;
          if (v237)
          {
            v239 = v237;
            int v240 = v239[93];

            *(_DWORD *)(*(void *)(a1 + 32) + 284LL) = v240;
            uint64_t v241 = *(void *)(a1 + 32);
            int v242 = *(_DWORD *)(v241 + 284);
            uint64_t v243 = *(void *)(v241 + 16);
            if (v242)
            {
              if (v243 && !nw_path_parameters_get_logging_disabled(*(void *)(v243 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v244 = (os_log_s *)(id)gconnectionLogObj;
                if (!os_log_type_enabled(v244, OS_LOG_TYPE_INFO)) {
                  goto LABEL_369;
                }
                uint64_t v245 = *(void *)(a1 + 32);
                int v246 = *(_DWORD *)(v245 + 448);
                LODWORD(v245) = *(_DWORD *)(v245 + 284);
                *(_DWORD *)__int128 buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke_2";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v246;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v245;
                v247 = "%{public}s [C%u] Connected fallback generation %u";
                v248 = v244;
                os_log_type_t v249 = OS_LOG_TYPE_INFO;
                uint32_t v250 = 24;
LABEL_368:
                _os_log_impl(&dword_181A5C000, v248, v249, v247, buf, v250);
LABEL_369:
              }
            }

            else if (v243 && !nw_path_parameters_get_logging_disabled(*(void *)(v243 + 104)))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v244 = (os_log_s *)(id)gconnectionLogObj;
              if (!os_log_type_enabled(v244, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_369;
              }
              int v251 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v251;
              v247 = "%{public}s [C%u] Connected fallback generation 0";
              v248 = v244;
              os_log_type_t v249 = OS_LOG_TYPE_DEBUG;
              uint32_t v250 = 18;
              goto LABEL_368;
            }
          }

          v252 = *(id *)(a1 + 32);
          id v253 = v252;
          if (v252)
          {
            uint64_t v254 = v252[2];
            if (v254 && !nw_path_parameters_get_logging_disabled(*(void *)(v254 + 104)))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v255 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v255, OS_LOG_TYPE_INFO))
              {
                int v256 = *((_DWORD *)v253 + 112);
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v256;
                _os_log_impl( &dword_181A5C000,  v255,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Checking whether to start candidate manager",  buf,  0x12u);
              }
            }

            if (nw_parameters_get_multipath_service(*((nw_parameters_t *)v253 + 2)))
            {
              v257 = (uint64_t *)*((void *)v253 + 2);
              if (*((void *)v253 + 52))
              {
                if (nw_parameters_get_server_mode(v257))
                {
                  uint64_t v258 = *((void *)v253 + 2);
                  if (!v258 || nw_path_parameters_get_logging_disabled(*(void *)(v258 + 104))) {
                    goto LABEL_440;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v259 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v259, OS_LOG_TYPE_DEFAULT))
                  {
                    int v260 = *((_DWORD *)v253 + 112);
                    *(_DWORD *)__int128 buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v260;
                    _os_log_impl( &dword_181A5C000,  v259,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%u] Server side, will wait for call to set IDS endpoint",  buf,  0x12u);
                  }

                  goto LABEL_401;
                }

                *(void *)aBlock = 0LL;
                *(void *)&aBlock[8] = aBlock;
                *(void *)&aBlock[16] = 0x3032000000LL;
                v541 = __Block_byref_object_copy__24148;
                v542 = __Block_byref_object_dispose__24149;
                id v543 = 0LL;
                *(void *)v537 = 0LL;
                *(void *)&v537[8] = v537;
                *(void *)&v537[16] = 0x3032000000LL;
                *(void *)&v537[24] = __Block_byref_object_copy__24148;
                v538 = __Block_byref_object_dispose__24149;
                id v539 = 0LL;
                v264 = (nw_establishment_report *)*((void *)v253 + 52);
                *(void *)__int128 buf = v233;
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = ___ZL54nw_connection_start_candidate_manager_if_needed_lockedP24NWConcrete_nw_connection_block_invoke;
                *(void *)&_BYTE buf[24] = &unk_189BB9A70;
                id v265 = v253;
                *(void *)v524 = v265;
                *(void *)&v524[8] = aBlock;
                *(void *)&v524[16] = v537;
                nw_establishment_report_enumerate_resolution_reports(v264, buf);
                if ((nw_parameters_get_server_mode(*((void **)v253 + 2)) & 1) == 0)
                {
                  uint64_t v266 = *((void *)v253 + 2);
                  if (v266 && !nw_path_parameters_get_logging_disabled(*(void *)(v266 + 104)))
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v267 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v267, OS_LOG_TYPE_DEFAULT))
                    {
                      unsigned int v268 = *((_DWORD *)v265 + 112);
                      *(_DWORD *)v544 = 136446466;
                      v545 = "nw_connection_start_candidate_manager_if_needed_locked";
                      __int16 v546 = 1024;
                      unsigned int v547 = v268;
                      _os_log_impl( &dword_181A5C000,  v267,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%u] Client side",  v544,  0x12u);
                    }
                  }

                  uint64_t v269 = *(void *)&aBlock[8];
                  if (!*(void *)(*(void *)&aBlock[8] + 40LL) && *(void *)(*(void *)&v537[8] + 40LL))
                  {
                    nw_endpoint_t v274 = nw_connection_copy_endpoint((nw_connection_t)v265);
                    v275 = *(void **)(*(void *)&aBlock[8] + 40LL);
                    *(void *)(*(void *)&aBlock[8] + 40LL) = v274;

                    uint64_t v276 = *((void *)v253 + 2);
                    if (v276 && !nw_path_parameters_get_logging_disabled(*(void *)(v276 + 104)))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v277 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v277, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v278 = *((_DWORD *)v265 + 112);
                        v279 = *(nw_connection **)(*(void *)&aBlock[8] + 40LL);
                        *(_DWORD *)v544 = 136446722;
                        v545 = "nw_connection_start_candidate_manager_if_needed_locked";
                        __int16 v546 = 1024;
                        unsigned int v547 = v278;
                        __int16 v548 = 2112;
                        v549 = v279;
                        _os_log_impl( &dword_181A5C000,  v277,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Trying to use original endpoint %@",  v544,  0x1Cu);
                      }
                    }

                    nw_endpoint_type_t type = nw_endpoint_get_type(*(nw_endpoint_t *)(*(void *)&aBlock[8] + 40LL));
                    uint64_t v269 = *(void *)&aBlock[8];
                    if (type != nw_endpoint_type_bonjour_service)
                    {
                      v281 = *(void **)(*(void *)&aBlock[8] + 40LL);
                      *(void *)(*(void *)&aBlock[8] + 40LL) = 0LL;

                      uint64_t v269 = *(void *)&aBlock[8];
                    }
                  }

                  v270 = (uint64_t *)*((void *)v253 + 2);
                  if (!*(void *)(v269 + 40))
                  {
                    if (!v270 || nw_path_parameters_get_logging_disabled(v270[13])) {
                      goto LABEL_439;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v282 = (os_log_s *)(id)gconnectionLogObj;
                    if (!os_log_type_enabled(v282, OS_LOG_TYPE_DEBUG)) {
                      goto LABEL_438;
                    }
                    unsigned int v283 = *((_DWORD *)v265 + 112);
                    *(_DWORD *)v544 = 136446466;
                    v545 = "nw_connection_start_candidate_manager_if_needed_locked";
                    __int16 v546 = 1024;
                    unsigned int v547 = v283;
                    v284 = "%{public}s [C%u] No bonjour endpoint in establishment report, cannot start candidate manager";
                    v285 = v282;
                    os_log_type_t v286 = OS_LOG_TYPE_DEBUG;
                    goto LABEL_437;
                  }

                  if (nw_parameters_get_stricter_path_scoping(v270))
                  {
                    id v271 = nw_candidate_manager_create_with_connection(v265, *(void **)(*(void *)&aBlock[8] + 40LL));
                    v272 = (void *)*((void *)v265 + 7);
                    *((void *)v265 + 7) = v271;

                    v273 = (void *)*((void *)v265 + 7);
                    if (v273)
                    {
                      nw_candidate_manager_set_original_path(v273, *(void **)(*(void *)&v537[8] + 40LL));
                      nw_candidate_manager_start_client(*((void **)v265 + 7), 0);
                      goto LABEL_439;
                    }

                    uint64_t v287 = *((void *)v253 + 2);
                    if (!v287 || nw_path_parameters_get_logging_disabled(*(void *)(v287 + 104))) {
                      goto LABEL_439;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v282 = (os_log_s *)(id)gconnectionLogObj;
                    if (!os_log_type_enabled(v282, OS_LOG_TYPE_INFO))
                    {
LABEL_438:

                      goto LABEL_439;
                    }

                    unsigned int v288 = *((_DWORD *)v265 + 112);
                    *(_DWORD *)v544 = 136446466;
                    v545 = "nw_connection_start_candidate_manager_if_needed_locked";
                    __int16 v546 = 1024;
                    unsigned int v547 = v288;
                    v284 = "%{public}s [C%u] Failed to create candidate manager";
                    v285 = v282;
                    os_log_type_t v286 = OS_LOG_TYPE_INFO;
LABEL_437:
                    _os_log_impl(&dword_181A5C000, v285, v286, v284, v544, 0x12u);
                    goto LABEL_438;
                  }
                }

LABEL_401:
LABEL_440:
            uint64_t v114 = *(void *)(a1 + 32);
            LOBYTE(v115) = *(_BYTE *)(v114 + 109);
            int v116 = 1;
            goto LABEL_441;
          }

          __nwlog_obj();
          v465 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
          v466 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v537[0] = 0;
          if (__nwlog_fault(v466, aBlock, v537))
          {
            if (aBlock[0] == 17)
            {
              __nwlog_obj();
              v467 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v468 = aBlock[0];
              if (os_log_type_enabled(v467, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                _os_log_impl(&dword_181A5C000, v467, v468, "%{public}s called with null connection", buf, 0xCu);
              }
            }

            else if (v537[0])
            {
              v481 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v467 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v482 = aBlock[0];
              BOOL v483 = os_log_type_enabled(v467, (os_log_type_t)aBlock[0]);
              if (v481)
              {
                if (v483)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v481;
                  _os_log_impl( &dword_181A5C000,  v467,  v482,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v481);
                goto LABEL_833;
              }

              if (v483)
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                _os_log_impl( &dword_181A5C000,  v467,  v482,  "%{public}s called with null connection, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v467 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v495 = aBlock[0];
              if (os_log_type_enabled(v467, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                _os_log_impl( &dword_181A5C000,  v467,  v495,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

            if ((*(_BYTE *)(v6 + 158) & 1) == 0)
            {
              if (gLogDatapath)
              {
                v505 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v505, OS_LOG_TYPE_DEBUG))
                {
                  v506 = *(void *)(v6 + 488);
                  os_log_type_t v507 = *(_DWORD *)(*(void *)(v6 + 480) + 372LL);
                  v508 = *(_DWORD *)(v6 + 860);
                  if (v506) {
                    LODWORD(v506) = *(_DWORD *)(v506 + 424);
                  }
                  *(_DWORD *)__int128 buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_enqueue_outbound_frame";
                  v638 = 2082;
                  *(void *)v639 = v6 + 74;
                  *(_WORD *)&v639[8] = 2080;
                  *(void *)&v639[10] = " ";
                  *(_WORD *)&v639[18] = 1024;
                  *(_DWORD *)v640 = v507;
                  *(_WORD *)&v640[4] = 1024;
                  *(_DWORD *)&v640[6] = v508;
                  *(_WORD *)v641 = 1024;
                  *(_DWORD *)&v641[2] = v506;
                  *(_WORD *)&v641[6] = 2048;
                  *(void *)&v641[8] = a1;
                  _os_log_impl( &dword_181A5C000,  v505,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> enqueuing outbound frame %p",  buf,  0x3Cu);
                  id v6 = v627;
                }
              }
            }

            *((void *)a1 + 4) = 0LL;
            v203 = *(void **)(v6 + 656);
            *((void *)a1 + 5) = v203;
            *v203 = a1;
            *(void *)(v6 + 656) = (char *)a1 + 32;
            if ((*(_WORD *)(*(void *)(v6 + 488) + 428LL) & 2) == 0) {
              goto LABEL_779;
            }
            if ((*(_BYTE *)(v6 + 158) & 1) == 0)
            {
              if (gLogDatapath)
              {
                id v522 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v522, OS_LOG_TYPE_DEBUG))
                {
                  v523 = *(void *)(v6 + 488);
                  v524 = *(_DWORD *)(*(void *)(v6 + 480) + 372LL);
                  __int16 v525 = *(_DWORD *)(v6 + 860);
                  if (v523) {
                    LODWORD(v523) = *(_DWORD *)(v523 + 424);
                  }
                  *(_DWORD *)__int128 buf = 136447490;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                  v638 = 2082;
                  *(void *)v639 = v6 + 74;
                  *(_WORD *)&v639[8] = 2080;
                  *(void *)&v639[10] = " ";
                  *(_WORD *)&v639[18] = 1024;
                  *(_DWORD *)v640 = v524;
                  *(_WORD *)&v640[4] = 1024;
                  *(_DWORD *)&v640[6] = v525;
                  *(_WORD *)v641 = 1024;
                  *(_DWORD *)&v641[2] = v523;
                  _os_log_impl( &dword_181A5C000,  v522,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> draining pending outbound frames",  buf,  0x32u);
                  id v6 = v627;
                }
              }
            }

            if (!*(void *)(v6 + 480))
            {
              __nwlog_obj();
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
              v518 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v643) = 16;
              LOBYTE(v647) = 0;
              if (v643 == 17)
              {
                int v519 = (os_log_s *)__nwlog_obj();
                v520 = v643;
                if (os_log_type_enabled(v519, (os_log_type_t)v643))
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                  v521 = "%{public}s called with null http1_connection->protocol_http1";
                  goto LABEL_975;
                }

                goto LABEL_977;
              }

              if (!(_BYTE)v647)
              {
                int v519 = (os_log_s *)__nwlog_obj();
                v520 = v643;
                if (os_log_type_enabled(v519, (os_log_type_t)v643))
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                  v521 = "%{public}s called with null http1_connection->protocol_http1, backtrace limit exceeded";
                  goto LABEL_975;
                }

                goto LABEL_977;
              }

              v526 = (char *)__nw_create_backtrace_string();
              __int16 v527 = (os_log_s *)__nwlog_obj();
              v528 = v643;
              __int16 v529 = os_log_type_enabled(v527, (os_log_type_t)v643);
              if (v526)
              {
                if (v529)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                  v638 = 2082;
                  *(void *)v639 = v526;
                  int v530 = "%{public}s called with null http1_connection->protocol_http1, dumping backtrace:%{public}s";
                  goto LABEL_908;
                }

                goto LABEL_909;
              }

              if (!v529) {
                goto LABEL_977;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
              v521 = "%{public}s called with null http1_connection->protocol_http1, no backtrace";
              goto LABEL_1014;
            }

            if (!*(void *)(v6 + 488))
            {
              __nwlog_obj();
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
              v518 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v643) = 16;
              LOBYTE(v647) = 0;
              if (v643 == 17)
              {
                int v519 = (os_log_s *)__nwlog_obj();
                v520 = v643;
                if (os_log_type_enabled(v519, (os_log_type_t)v643))
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                  v521 = "%{public}s called with null http1_connection->current_stream";
                  goto LABEL_975;
                }

                goto LABEL_977;
              }

              if (!(_BYTE)v647)
              {
                int v519 = (os_log_s *)__nwlog_obj();
                v520 = v643;
                if (!os_log_type_enabled(v519, (os_log_type_t)v643)) {
                  goto LABEL_977;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                v521 = "%{public}s called with null http1_connection->current_stream, backtrace limit exceeded";
                goto LABEL_975;
              }

              v526 = (char *)__nw_create_backtrace_string();
              __int16 v527 = (os_log_s *)__nwlog_obj();
              v528 = v643;
              __int16 v531 = os_log_type_enabled(v527, (os_log_type_t)v643);
              if (v526)
              {
                if (v531)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_drain_outbound_frames";
                  v638 = 2082;
                  *(void *)v639 = v526;
                  int v530 = "%{public}s called with null http1_connection->current_stream, dumping backtrace:%{public}s";
                  goto LABEL_908;
                }

                        if (v167) {
                          free(v167);
                        }
                        uint64_t v2 = v305;
                        goto LABEL_92;
                      }
                    }
                  }

                  __nwlog_obj();
                  v154 = *(void *)(*(void *)(v2 + 1064) + 32LL);
                  v155 = "invalid";
                  if (v154)
                  {
                    v156 = *(const char **)(v154 + 16);
                    if (v156) {
                      v155 = v156;
                    }
                  }

                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v155;
                  v157 = (char *)_os_log_send_and_compose_impl();
                  nw_endpoint_type_t type = OS_LOG_TYPE_ERROR;
                  int v306 = 0;
                  if (__nwlog_fault(v157, &type, &v306))
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      BOOL v158 = (os_log_s *)__nwlog_obj();
                      char v159 = type;
                      if (os_log_type_enabled(v158, type))
                      {
                        v160 = *(void *)(*(void *)(v305 + 1064) + 32LL);
                        id v161 = "invalid";
                        if (v160)
                        {
                          int v162 = *(const char **)(v160 + 16);
                          if (v162) {
                            id v161 = v162;
                          }
                        }

                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v161;
                        v163 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
LABEL_391:
                        _os_log_impl(&dword_181A5C000, v158, v159, v163, buf, 0x16u);
                      }
                    }

                    else if (v306)
                    {
                      uint32_t v211 = (char *)__nw_create_backtrace_string();
                      BOOL v158 = (os_log_s *)__nwlog_obj();
                      char v159 = type;
                      v212 = os_log_type_enabled(v158, type);
                      if (v211)
                      {
                        if (v212)
                        {
                          v213 = *(void *)(*(void *)(v305 + 1064) + 32LL);
                          int v214 = "invalid";
                          if (v213)
                          {
                            v215 = *(const char **)(v213 + 16);
                            if (v215) {
                              int v214 = v215;
                            }
                          }

                          *(_DWORD *)__int128 buf = 136446722;
                          *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v214;
                          *(_WORD *)&_BYTE buf[22] = 2082;
                          v309 = v211;
                          _os_log_impl( &dword_181A5C000,  v158,  v159,  "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x20u);
                        }

                        free(v211);
                        goto LABEL_392;
                      }

                      if (v212)
                      {
                        v264 = *(void *)(*(void *)(v305 + 1064) + 32LL);
                        id v265 = "invalid";
                        if (v264)
                        {
                          uint64_t v266 = *(const char **)(v264 + 16);
                          if (v266) {
                            id v265 = v266;
                          }
                        }

                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v265;
                        v163 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
                        goto LABEL_391;
                      }
                    }

                    else
                    {
                      BOOL v158 = (os_log_s *)__nwlog_obj();
                      char v159 = type;
                      if (os_log_type_enabled(v158, type))
                      {
                        int v246 = *(void *)(*(void *)(v305 + 1064) + 32LL);
                        v247 = "invalid";
                        if (v246)
                        {
                          v248 = *(const char **)(v246 + 16);
                          if (v248) {
                            v247 = v248;
                          }
                        }

                        *(_DWORD *)__int128 buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v247;
                        v163 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
                        goto LABEL_391;
                      }
                    }
                  }

LABEL_833:
          if (v466) {
            free(v466);
          }
          goto LABEL_440;
        }

        __nwlog_obj();
        v449 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
        v450 = (char *)_os_log_send_and_compose_impl();

        aBlock[0] = 16;
        v537[0] = 0;
        if (__nwlog_fault(v450, aBlock, v537))
        {
          if (aBlock[0] == 17)
          {
            __nwlog_obj();
            v451 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v452 = aBlock[0];
            if (os_log_type_enabled(v451, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
              _os_log_impl(&dword_181A5C000, v451, v452, "%{public}s called with null connection", buf, 0xCu);
            }
          }

          else if (v537[0])
          {
            v469 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v451 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v470 = aBlock[0];
            BOOL v471 = os_log_type_enabled(v451, (os_log_type_t)aBlock[0]);
            if (v469)
            {
              if (v471)
              {
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v469;
                _os_log_impl( &dword_181A5C000,  v451,  v470,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v469);
              goto LABEL_813;
            }

            if (v471)
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v451,  v470,  "%{public}s called with null connection, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            v451 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v491 = aBlock[0];
            if (os_log_type_enabled(v451, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v451,  v491,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

LABEL_813:
        if (v450) {
          free(v450);
        }
        goto LABEL_234;
      }
    }
  }

LABEL_441:
  if ((v115 & 0x40) == 0)
  {
    uint64_t v290 = *(void *)(v114 + 152);
    v289 = (id *)(v114 + 152);
    if (!v290)
    {
      v291 = *(unsigned __int16 **)(a1 + 56);
      if (!v291) {
        goto LABEL_582;
      }
      int v292 = *v291;
      if (v292 != 3) {
        goto LABEL_445;
      }
      if (v291[1] == 5)
      {
        objc_storeStrong(v289, *(id *)(a1 + 40));
        v313 = *(nw_connection **)(a1 + 32);
        if ((*((_BYTE *)v313 + 108) & 1) == 0)
        {
          nw_parameters_t v314 = nw_connection_copy_parameters(v313);
          nw_parameters_t v315 = v314;
        }
      }
    }
  }

  v291 = *(unsigned __int16 **)(a1 + 56);
  if (!v291) {
    goto LABEL_582;
  }
  int v292 = *v291;
LABEL_445:
  if (v292 == 5 && v291[1] - 3 <= 1)
  {
    uint64_t v293 = *(void *)(a1 + 32);
    if ((*(_BYTE *)(v293 + 109) & 0x40) != 0 || *(void *)(v293 + 152))
    {
      if (nw_connection_used_fallback_locked((void *)v293))
      {
        uint64_t v294 = *(void *)(a1 + 32);
        uint64_t v295 = 144LL;
        if ((*(_BYTE *)(v294 + 109) & 0x40) == 0) {
          uint64_t v295 = 152LL;
        }
        id v296 = *(id *)(v294 + v295);
        v297 = v296;
        if (v296)
        {
          v298 = (unsigned int *)v296;
          uint64_t v299 = v298[29];

          if ((_DWORD)v299 == 2)
          {
            v300 = v298;
            int state = v300->state;

            if (state != 5)
            {
              v302 = nw_endpoint_handler_copy_flow(v300);
              if ((*((_BYTE *)v302 + 33) & 0x40) != 0) {
                goto LABEL_580;
              }
              v303 = v300;
              v304 = v303->parameters;

              LOBYTE(v303) = nw_parameters_multipath_fallback_allowed(v304);
              uint64_t v305 = *((void *)v302 + 114);
              if (!v305) {
                goto LABEL_580;
              }
              if (*(_UNKNOWN **)(v305 + 40) == &nw_protocol_ref_counted_handle)
              {
                *(_DWORD *)aBlock = 1;
                if (!setsockopt(*(_DWORD *)(v305 + 268), 0xFFFF, 4373, aBlock, 4u))
                {
                  if ((*(_WORD *)(v305 + 397) & 0x80) != 0) {
                    goto LABEL_580;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  uint64_t v332 = gconnectionLogObj;
                  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
                    goto LABEL_580;
                  }
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v305 + 404;
                  v309 = "%{public}s %{public}s Setting SO_MARK_CELLFALLBACK on socket";
                  v310 = (os_log_s *)v332;
                  os_log_type_t v311 = OS_LOG_TYPE_INFO;
                  uint32_t v312 = 22;
                  goto LABEL_523;
                }

                int v306 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v307 = (os_log_s *)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__int128 buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v305 + 404;
                  *(_WORD *)&_BYTE buf[22] = 1024;
                  *(_DWORD *)&_BYTE buf[24] = v306;
                  _os_log_impl( &dword_181A5C000,  v307,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d",  buf,  0x1Cu);
                }

                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v308 = gLogObj;
                if (v306 == 22)
                {
                  if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  {
LABEL_580:

                    goto LABEL_581;
                  }

                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 22;
                  v309 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d";
                  v310 = (os_log_s *)v308;
                  os_log_type_t v311 = OS_LOG_TYPE_ERROR;
                  uint32_t v312 = 18;
LABEL_523:
                  _os_log_impl(&dword_181A5C000, v310, v311, v309, buf, v312);
                  goto LABEL_580;
                }

                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v306;
                v333 = (char *)_os_log_send_and_compose_impl();
                v537[0] = 16;
                v544[0] = 0;
                if (v537[0] == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v334 = (os_log_s *)gLogObj;
                  os_log_type_t v335 = v537[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v537[0])) {
                    goto LABEL_578;
                  }
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v306;
                  v336 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d";
                  goto LABEL_576;
                }

                if (!v544[0])
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v334 = (os_log_s *)gLogObj;
                  os_log_type_t v335 = v537[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v537[0])) {
                    goto LABEL_578;
                  }
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v306;
                  v336 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_576;
                }

                v344 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v334 = (os_log_s *)gLogObj;
                os_log_type_t v335 = v537[0];
                BOOL v345 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v537[0]);
                if (v344)
                {
                  if (v345)
                  {
                    *(_DWORD *)__int128 buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v306;
                    *(_WORD *)&buf[18] = 2082;
                    *(void *)&buf[20] = v344;
                    _os_log_impl( &dword_181A5C000,  v334,  v335,  "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
                  }

                  free(v344);
                  if (!v333) {
                    goto LABEL_580;
                  }
                  goto LABEL_579;
                }

                if (v345)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v306;
                  v336 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d, no backtrace";
LABEL_576:
                  v354 = v334;
                  os_log_type_t v355 = v335;
                  uint32_t v356 = 18;
LABEL_577:
                  _os_log_impl(&dword_181A5C000, v354, v355, v336, buf, v356);
                }

LABEL_578:
                if (!v333) {
                  goto LABEL_580;
                }
LABEL_579:
                free(v333);
                goto LABEL_580;
              }

              __nwlog_obj();
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
              v333 = (char *)_os_log_send_and_compose_impl();
              aBlock[0] = 16;
              v537[0] = 0;
              if (aBlock[0] == 17)
              {
                v508 = (os_log_s *)__nwlog_obj();
                os_log_type_t v509 = aBlock[0];
                if (!os_log_type_enabled(v508, (os_log_type_t)aBlock[0])) {
                  goto LABEL_578;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                v336 = "%{public}s called with null socket_handler";
              }

              else if (v537[0])
              {
                v510 = (char *)__nw_create_backtrace_string();
                v508 = (os_log_s *)__nwlog_obj();
                os_log_type_t v509 = aBlock[0];
                BOOL v511 = os_log_type_enabled(v508, (os_log_type_t)aBlock[0]);
                if (v510)
                {
                  if (v511)
                  {
                    *(_DWORD *)__int128 buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v510;
                    _os_log_impl( &dword_181A5C000,  v508,  v509,  "%{public}s called with null socket_handler, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v510);
                  goto LABEL_578;
                }

                if (!v511) {
                  goto LABEL_578;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                v336 = "%{public}s called with null socket_handler, no backtrace";
              }

              else
              {
                v508 = (os_log_s *)__nwlog_obj();
                os_log_type_t v509 = aBlock[0];
                if (!os_log_type_enabled(v508, (os_log_type_t)aBlock[0])) {
                  goto LABEL_578;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                v336 = "%{public}s called with null socket_handler, backtrace limit exceeded";
              }

              v354 = v508;
              os_log_type_t v355 = v509;
              uint32_t v356 = 12;
              goto LABEL_577;
            }

      free(v328);
    }

          goto LABEL_579;
        }

        nw_endpoint_t v27 = *(void **)(v26 + 24);
        if (!v27 || !v10 || !*v27)
        {
          __nwlog_obj();
          int v246 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v246, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446466;
            v378 = "nw_protocol_utilities_add_input_handler";
            v379 = 2048;
            v380 = (char *)v26;
            _os_log_impl( &dword_181A5C000,  v246,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid",  buf,  0x16u);
          }

          goto LABEL_581;
        }

        if ((nw_protocol_add_input_handler(v26, v10) & 1) == 0) {
          goto LABEL_581;
        }
        if (!v21) {
          goto LABEL_129;
        }
        if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v54 = *(void *)(v21 + 88);
          if (v54) {
            *(void *)(v21 + 8_Block_object_dispose(va, 8) = v54 + 1;
          }
          *(void *)v375 = v21;
          uint64_t v28 = v376 | 1;
        }

        else
        {
          *(void *)v375 = v21;
          uint64_t v28 = v376 & 0xFE;
        }

        int v376 = v28;
        if (*(_UNKNOWN **)(v10 + 40) == &nw_protocol_ref_counted_handle)
        {
          nw_endpoint_t v56 = *(void *)(v10 + 88);
          if (v56) {
            *(void *)(v10 + 8_Block_object_dispose(va, 8) = v56 + 1;
          }
          *(void *)v373 = v10;
          unint64_t v55 = v374 | 1;
        }

        else
        {
          *(void *)v373 = v10;
          unint64_t v55 = v374 & 0xFE;
        }

        v374 = v55;
        if (*(_UNKNOWN **)(v26 + 40) == &nw_protocol_ref_counted_handle)
        {
          unsigned int v58 = *(void *)(v26 + 88);
          if (v58) {
            *(void *)(v26 + 8_Block_object_dispose(va, 8) = v58 + 1;
          }
          *(void *)uint64_t v370 = v26;
          BOOL v57 = v371 | 1;
        }

        else
        {
          *(void *)uint64_t v370 = v26;
          BOOL v57 = v371 & 0xFE;
        }

        v371 = v57;
        id v59 = *(void *)(v21 + 24);
        if (v59)
        {
          id v60 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v59 + 16);
          if (v60)
          {
            unsigned int v61 = v60(v21, v10, v26);
            if ((v371 & 1) == 0) {
              goto LABEL_123;
            }
LABEL_122:
            nw::release_if_needed<nw_protocol *>((uint64_t *)v370);
            goto LABEL_123;
          }
        }

        __nwlog_obj();
        v110 = (void *)objc_claimAutoreleasedReturnValue();
        v111 = *(const char **)(v21 + 16);
        if (!v111) {
          v111 = "invalid";
        }
        *(_DWORD *)__int128 buf = 136446722;
        v378 = "__nw_protocol_replace_input_handler";
        v379 = 2082;
        v380 = (char *)v111;
        v381 = 2048;
        v382 = (const char *)v21;
        v352 = (const char *)_os_log_send_and_compose_impl();

        nw_endpoint_type_t type = OS_LOG_TYPE_ERROR;
        v369 = 0;
        os_log_type_t v112 = (char *)v352;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          int v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v344 = type;
          if (os_log_type_enabled(v113, type))
          {
            uint64_t v114 = *(const char **)(v21 + 16);
            if (!v114) {
              uint64_t v114 = "invalid";
            }
            *(_DWORD *)__int128 buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            v379 = 2082;
            v380 = (char *)v114;
            v381 = 2048;
            v382 = (const char *)v21;
            _os_log_impl( &dword_181A5C000,  v113,  v344,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback",  buf,  0x20u);
          }

LABEL_581:
            goto LABEL_582;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v316 = (id)gLogObj;
          else {
            v317 = off_189BBBBC0[v299];
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v317;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)&_BYTE buf[24] = "flow";
          v318 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v537[0] = 0;
          if (aBlock[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v319 = (os_log_s *)(id)gLogObj;
            os_log_type_t v320 = aBlock[0];
            if (os_log_type_enabled(v319, (os_log_type_t)aBlock[0]))
            {
              else {
                v321 = off_189BBBBC0[v299];
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v321;
              *(_WORD *)&_BYTE buf[22] = 2082;
              *(void *)&_BYTE buf[24] = "flow";
              _os_log_impl( &dword_181A5C000,  v319,  v320,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
            }
          }

          else if (v537[0])
          {
            v322 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v319 = (os_log_s *)(id)gLogObj;
            os_log_type_t v323 = aBlock[0];
            BOOL v324 = os_log_type_enabled(v319, (os_log_type_t)aBlock[0]);
            if (v322)
            {
              if (v324)
              {
                else {
                  v325 = off_189BBBBC0[v299];
                }
                *(_DWORD *)__int128 buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v325;
                *(_WORD *)&_BYTE buf[22] = 2082;
                *(void *)&_BYTE buf[24] = "flow";
                *(_WORD *)v524 = 2082;
                *(void *)&v524[2] = v322;
                _os_log_impl( &dword_181A5C000,  v319,  v323,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(v322);
              if (!v318) {
                goto LABEL_581;
              }
              goto LABEL_517;
            }

            if (v324)
            {
              else {
                v328 = off_189BBBBC0[v299];
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v328;
              *(_WORD *)&_BYTE buf[22] = 2082;
              *(void *)&_BYTE buf[24] = "flow";
              _os_log_impl( &dword_181A5C000,  v319,  v323,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v319 = (os_log_s *)(id)gLogObj;
            os_log_type_t v326 = aBlock[0];
            if (os_log_type_enabled(v319, (os_log_type_t)aBlock[0]))
            {
              else {
                v327 = off_189BBBBC0[v299];
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v327;
              *(_WORD *)&_BYTE buf[22] = 2082;
              *(void *)&_BYTE buf[24] = "flow";
              _os_log_impl( &dword_181A5C000,  v319,  v326,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
            }
          }

          goto LABEL_515;
        }

        __nwlog_obj();
        v484 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
        v318 = (char *)_os_log_send_and_compose_impl();

        aBlock[0] = 16;
        v537[0] = 0;
        if (__nwlog_fault(v318, aBlock, v537))
        {
          if (aBlock[0] == 17)
          {
            __nwlog_obj();
            v319 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v485 = aBlock[0];
            if (os_log_type_enabled(v319, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              _os_log_impl(&dword_181A5C000, v319, v485, "%{public}s called with null handler", buf, 0xCu);
            }

LABEL_515:
            goto LABEL_516;
          }

          if (!v537[0])
          {
            __nwlog_obj();
            v319 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v499 = aBlock[0];
            if (os_log_type_enabled(v319, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              _os_log_impl( &dword_181A5C000,  v319,  v499,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_515;
          }

          v486 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v319 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v487 = aBlock[0];
          BOOL v488 = os_log_type_enabled(v319, (os_log_type_t)aBlock[0]);
          if (!v486)
          {
            if (v488)
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              _os_log_impl(&dword_181A5C000, v319, v487, "%{public}s called with null handler, no backtrace", buf, 0xCu);
            }

            goto LABEL_515;
          }

          if (v488)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v486;
            _os_log_impl( &dword_181A5C000,  v319,  v487,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v486);
        }

  if (v208) {
    free(v208);
  }
LABEL_436:
  v235 = 0LL;
  v173 = 0LL;
LABEL_442:

  return v173;
}

LABEL_516:
        if (!v318) {
          goto LABEL_581;
        }
LABEL_517:
        free(v318);
        goto LABEL_581;
      }
    }
  }

LABEL_582:
  int v357 = *(_DWORD *)(a1 + 64);
  int v358 = *(_DWORD *)(a1 + 68);
  v359 = *(_WORD **)(a1 + 56);
  if (v358 == 1 && v357 == 4 && v359 && *v359 == 2 && v359[1] == 2)
  {
    v360 = *(void **)(a1 + 48);
    if (v360)
    {
      v361 = v360;
      int v362 = v361[3];

      if (v362 != -65554)
      {
        v363 = *(void **)(a1 + 32);
        v364 = *(void **)(a1 + 40);
        int error_code = nw_error_get_error_code(*(nw_error_t *)(a1 + 48));
        nw_connection_report_symptom_on_nw_queue(v363, 421894, v364, error_code);
      }
    }

    v366 = *(void **)(a1 + 40);
    if (v366) {
      goto LABEL_591;
    }
    goto LABEL_639;
  }

  v367 = (void **)*(id *)(a1 + 32);
  v368 = v367;
  if (v367)
  {
    nw_context_assert_queue(v367[3]);
    if (v358 == 2
      && v357 == 4
      && v359
      && *v359 == 3
      && v359[1] == 7
      && ((nw_parameters_get_tls(v368[2]) & 1) != 0
       || (*((_BYTE *)v368 + 109) & 0x40) != 0 && nw_endpoint_handler_stack_uses_tls(v368[18])))
    {
      v369 = v368;
      nw_context_assert_queue(v368[3]);
      uint64_t v370 = *((unsigned __int16 *)v369 + 161);
      if (*((_WORD *)v369 + 161))
      {
        v371 = (char *)v369[39] + 10;
        while (*(v371 - 1) != 3 || *v371 != 5)
        {
          v371 += 8;
          if (!--v370) {
            goto LABEL_609;
          }
        }

        v373 = *(void **)(a1 + 32);
        v372 = *(void **)(a1 + 40);
        v374 = *(void **)(a1 + 48);
        if (v374)
        {
          v375 = v374;
          int v376 = v375[3];
        }

        else
        {
          int v376 = 0;
        }

        nw_connection_report_symptom_on_nw_queue(v373, 421893, v372, v376);
        goto LABEL_639;
      }

LABEL_609:
    }

    goto LABEL_610;
  }

  __nwlog_obj();
  v441 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
  v442 = (char *)_os_log_send_and_compose_impl();

  aBlock[0] = 16;
  v537[0] = 0;
  if (__nwlog_fault(v442, aBlock, v537))
  {
    if (aBlock[0] == 17)
    {
      __nwlog_obj();
      v443 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v444 = aBlock[0];
      if (os_log_type_enabled(v443, (os_log_type_t)aBlock[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v443, v444, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v537[0])
    {
      v445 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v443 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v446 = aBlock[0];
      BOOL v447 = os_log_type_enabled(v443, (os_log_type_t)aBlock[0]);
      if (v445)
      {
        if (v447)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v445;
          _os_log_impl( &dword_181A5C000,  v443,  v446,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v445);
        goto LABEL_753;
      }

      if (v447)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v443, v446, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v443 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v448 = aBlock[0];
      if (os_log_type_enabled(v443, (os_log_type_t)aBlock[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v443,  v448,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        PBReaderRecallMark();
LABEL_5:
        unint64_t v4 = *v3;
        unint64_t v5 = *(void *)(a2 + v4);
        id v7 = *(void *)(a2 + *v6);
        if (v5 >= v7) {
          return *(_BYTE *)(a2 + *v8) == 0;
        }
        break;
      case 0x19u:
        unsigned int v58 = objc_alloc_init(&OBJC_CLASS___NWPBInterface);
        if (a1)
        {
          v267 = *(void **)(a1 + 136);
          if (!v267)
          {
            unsigned int v268 = objc_alloc_init(MEMORY[0x189603FA8]);
            uint64_t v269 = *(void **)(a1 + 136);
            *(void *)(a1 + 136) = v268;

            v267 = *(void **)(a1 + 136);
          }

          [v267 addObject:v58];
        }

LABEL_345:
        goto LABEL_620;
      case 0x1Au:
        unsigned int v58 = objc_alloc_init(&OBJC_CLASS___NWPBAgentClass);
        if (!a1) {
          goto LABEL_618;
        }
        id v59 = *(void **)(a1 + 128);
        if (v59) {
          goto LABEL_617;
        }
        id v265 = objc_alloc_init(MEMORY[0x189603FA8]);
        uint64_t v266 = *(void **)(a1 + 128);
        *(void *)(a1 + 12_Block_object_dispose(va, 8) = v265;

        uint64_t v62 = 128LL;
        goto LABEL_616;
      case 0x1Bu:
        unsigned int v58 = objc_alloc_init(&OBJC_CLASS___NWPBAgentClass);
        if (!a1) {
          goto LABEL_618;
        }
        id v59 = *(void **)(a1 + 152);
        if (v59) {
          goto LABEL_617;
        }
        v738 = objc_alloc_init(MEMORY[0x189603FA8]);
        v739 = *(void **)(a1 + 152);
        *(void *)(a1 + 152) = v738;

        uint64_t v62 = 152LL;
        goto LABEL_616;
      case 0x1Cu:
        unsigned int v58 = objc_alloc_init(&OBJC_CLASS___NWPBAgentClass);
        if (!a1) {
          goto LABEL_618;
        }
        id v59 = *(void **)(a1 + 120);
        if (v59) {
          goto LABEL_617;
        }
        id v60 = objc_alloc_init(MEMORY[0x189603FA8]);
        unsigned int v61 = *(void **)(a1 + 120);
        *(void *)(a1 + 120) = v60;

        uint64_t v62 = 120LL;
LABEL_616:
        id v59 = *(void **)(a1 + v62);
LABEL_617:
        [v59 addObject:v58];
LABEL_618:

        if (PBReaderPlaceMark() && NWPBAgentClassReadFrom((uint64_t)v58, a2))
        {
LABEL_620:
          PBReaderRecallMark();

          goto LABEL_5;
        }

LABEL_753:
  if (v442) {
    free(v442);
  }
LABEL_610:

  v377 = *(_WORD **)(a1 + 56);
  v378 = (void **)*(id *)(a1 + 32);
  v379 = v378;
  if (v377 && *v377 == 5 && v377[1] == 5 && (nw_parameters_get_tls(v378[2]) & 1) != 0)
  {

    v381 = *(void **)(a1 + 32);
    v380 = *(void **)(a1 + 40);
    v382 = *(void **)(a1 + 48);
    if (v382)
    {
      v383 = v382;
      int v384 = v383[3];
    }

    else
    {
      int v384 = 0;
    }

    nw_connection_report_symptom_on_nw_queue(v381, 421895, v380, v384);
    nw_connection_enable_stats_report_on_nw_queue(*(void **)(a1 + 32), 5);
  }

  else
  {

    int v385 = *(_DWORD *)(a1 + 64);
    int v386 = *(_DWORD *)(a1 + 68);
    v387 = *(_WORD **)(a1 + 56);
    if (v386 == 2 && v385 == 4 && v387)
    {
      if (*v387 == 3 && v387[1] == 7)
      {
        v389 = *(void **)(a1 + 32);
        v388 = *(void **)(a1 + 40);
        v390 = *(void **)(a1 + 48);
        if (v390)
        {
          v391 = v390;
          int v392 = v391[3];
        }

        else
        {
          int v392 = 0;
        }

        nw_connection_report_symptom_on_nw_queue(v389, 421904, v388, v392);
      }
    }

    else if (v386 == 3 && v385 == 4 && v387 && *v387 == 4 && v387[1] == 5)
    {
      v393 = *(void **)(a1 + 32);
      v394 = *(void **)(a1 + 40);
      v395 = *(nw_error **)(a1 + 48);
      int v396 = v395 ? nw_error_get_error_code(v395) : 0;
      nw_connection_report_symptom_on_nw_queue(v393, 421902, v394, v396);
      v366 = *(void **)(a1 + 40);
      if (v366) {
LABEL_591:
      }
        nw_connection_fillout_failed_resolution_report_on_nw_queue(*(void **)(a1 + 32), v366);
    }
  }

              if (*(void *)(v12 + 488))
              {
LABEL_762:
                if (v147) {
                  os_release(v147);
                }
                return;
              }

LABEL_639:
  if (*(_DWORD *)(a1 + 64) == 4 && (v397 = *(_WORD **)(a1 + 56)) != 0LL && *v397 == 1 && v397[1] == 9)
  {
    *(_BYTE *)(*(void *)(a1 + 32) + 110LL) |= 1u;
  }

  else
  {
    v398 = *(void **)(a1 + 40);
    if (v398)
    {
      v399 = *(void **)(a1 + 32);
      nw_endpoint_t v400 = nw_endpoint_handler_copy_endpoint(v398);
      id v401 = v399;
      v402 = v400;
      v403 = v402;
      if (v402)
      {
        if (*((void *)v402 + 11))
        {
          if ((*((_BYTE *)v401 + 110) & 4) == 0)
          {
            v404 = v402;
            BOOL v405 = (*((_BYTE *)v404 + 231) & 0x40) == 0;

            if (v405
              && nw_parameters_get_attribution(*((nw_parameters_t *)v401 + 2)) == nw_parameters_attribution_developer
              && ne_tracker_should_save_stacktrace())
            {
              char v406 = *((_BYTE *)v401 + 110);
              *((_BYTE *)v401 + 110) = v406 | 4;
              v407 = (dispatch_data_s *)*((void *)v401 + 11);
              if (v407)
              {
                *(void *)__int128 buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = ___ZL49nw_connection_check_for_unlisted_tracker_on_queueP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObject_block_invoke;
                *(void *)&_BYTE buf[24] = &unk_189BB9A98;
                *(void *)v524 = v404;
                dispatch_data_apply(v407, buf);
              }

              else
              {
                *((_BYTE *)v401 + 110) = v406 | 6;
              }
            }
          }
        }
      }
    }
  }

  if (!v116)
  {
    unsigned int v410 = *(_DWORD *)(a1 + 64);
    uint64_t v411 = *(void *)(a1 + 32);
    if (v410 != 5) {
      goto LABEL_671;
    }
LABEL_670:
    nw_connection_set_state_on_nw_queue((NWConcrete_nw_connection *)v411, 5u);
    goto LABEL_687;
  }

  uint64_t v408 = *(void *)(a1 + 32);
  if (!*(void *)(v408 + 176) && !nw_endpoint_handler_uses_multipath(*(void **)(v408 + 144)))
  {
    v409 = *(_WORD **)(a1 + 56);
    if (v409)
    {
      if (*v409 == 1 && v409[1] == 5) {
        nw_connection_start_dry_run_on_nw_queue(*(NWConcrete_nw_connection **)(a1 + 32));
      }
    }
  }

  unsigned int v410 = *(_DWORD *)(a1 + 64);
  uint64_t v411 = *(void *)(a1 + 32);
  if (v410 == 5) {
    goto LABEL_670;
  }
  if (*(void *)(a1 + 40) == *(void *)(v411 + 144))
  {
    v412 = *(_WORD **)(a1 + 56);
    if (v412 && *v412 == 3 && v412[1] == 8)
    {
      nw_connection_update_better_path_locked_on_nw_queue((NWConcrete_nw_connection *)v411);
      v413 = *(NWConcrete_nw_connection **)(a1 + 32);
      int is_viable = nw_endpoint_handler_is_viable(*(void **)(a1 + 40));
      nw_connection_send_viability_changed_on_nw_queue(v413, is_viable);
      uint64_t v411 = *(void *)(a1 + 32);
      unsigned int v410 = *(_DWORD *)(a1 + 64);
    }

    goto LABEL_686;
  }

              if ((*(_BYTE *)(v248 + 158) & 1) == 0)
              {
                v402 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v402, OS_LOG_TYPE_DEBUG))
                {
                  v403 = *(void *)(v248 + 256);
                  v404 = *(_DWORD *)(*(void *)(v248 + 248) + 372LL);
                  if (v403) {
                    LODWORD(v403) = *(_DWORD *)(v403 + 860);
                  }
                  BOOL v405 = *(_DWORD *)(v248 + 424);
                  *(_DWORD *)__int128 buf = 136448258;
                  *(void *)&uint8_t buf[4] = "nw_http1_start_new_connection_for_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v248 + 74;
                  *(_WORD *)&_BYTE buf[22] = 2080;
                  v961 = (uint64_t)" ";
                  *(_WORD *)v962 = 1024;
                  *(_DWORD *)&v962[2] = v404;
                  *(_WORD *)&v962[6] = 1024;
                  *(_DWORD *)&v962[8] = v403;
                  *(_WORD *)&v962[12] = 1024;
                  *(_DWORD *)&v962[14] = v405;
                  *(_WORD *)&v962[18] = 2048;
                  *(void *)&v962[20] = v166;
                  *(_WORD *)&v962[28] = 1024;
                  *(_DWORD *)&v962[30] = v405;
                  *(_WORD *)&v962[34] = 2048;
                  *(void *)&v962[36] = v248;
                  _os_log_impl( &dword_181A5C000,  v402,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> created new connection %p for stream %u (%p)",  buf,  0x4Cu);
                }
              }

              nw_http_transaction_metadata_set_first_on_connection(*(void **)(v248 + 352));
              char v406 = nw_protocol_copy_info((uint64_t)v163, 255);
              v407 = (void *)v406;
              if (v406
                && (uint64_t v408 = *(void *)(v406 + 24), *(void *)(v406 + 16) != v408)
                && (v409 = *(void **)(v408 - 8)) != 0LL)
              {
                unsigned int v410 = (nw_protocol_metadata *)os_retain(v409);
                uint64_t v411 = v410;
                if (v410 && nw_protocol_metadata_is_tls(v410))
                {
                  uint64_t v411 = v411;
                  nw_http_connection_metadata_set_sec_metadata(*((void **)v166 + 96), v411);
                  os_release(v411);
                  nw_protocol_connect((uint64_t)v163, (uint64_t)v166);
                  goto LABEL_653;
                }
              }

              else
              {
                uint64_t v411 = 0LL;
              }

              if (v166)
              {
                nw_protocol_connect((uint64_t)v163, (uint64_t)v166);
                if (!v411) {
                  goto LABEL_654;
                }
                goto LABEL_653;
              }

              v696 = (uint64_t)v163;
              __nwlog_obj();
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_get_output_protocol";
              v697 = (char *)_os_log_send_and_compose_impl();
              v963[0] = 16;
              LOBYTE(aBlock) = 0;
              if (__nwlog_fault(v697, v963, &aBlock))
              {
                if (v963[0] == 17)
                {
                  v698 = (os_log_s *)__nwlog_obj();
                  v699 = v963[0];
                  if (!os_log_type_enabled(v698, (os_log_type_t)v963[0])) {
                    goto LABEL_1364;
                  }
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_get_output_protocol";
                  v700 = "%{public}s called with null connection";
LABEL_1363:
                  _os_log_impl(&dword_181A5C000, v698, v699, v700, buf, 0xCu);
                  goto LABEL_1364;
                }

                if (!(_BYTE)aBlock)
                {
                  v698 = (os_log_s *)__nwlog_obj();
                  v699 = v963[0];
                  if (!os_log_type_enabled(v698, (os_log_type_t)v963[0])) {
                    goto LABEL_1364;
                  }
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_get_output_protocol";
                  v700 = "%{public}s called with null connection, backtrace limit exceeded";
                  goto LABEL_1363;
                }

                v754 = (char *)__nw_create_backtrace_string();
                v698 = (os_log_s *)__nwlog_obj();
                v699 = v963[0];
                v755 = os_log_type_enabled(v698, (os_log_type_t)v963[0]);
                if (!v754)
                {
                  if (!v755) {
                    goto LABEL_1364;
                  }
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_get_output_protocol";
                  v700 = "%{public}s called with null connection, no backtrace";
                  goto LABEL_1363;
                }

                if (v755)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http1_get_output_protocol";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v754;
                  _os_log_impl( &dword_181A5C000,  v698,  v699,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v754);
              }

LABEL_671:
  if ((*(_BYTE *)(v411 + 109) & 0x40) == 0)
  {
    uint64_t v415 = *(void *)(v411 + 144);
    if (*(void *)(a1 + 40) == v415)
    {
      if (v415)
      {
        if (v410 != 1
          || (v416 = *(_WORD **)(a1 + 56)) == 0LL
          || *v416 != 1
          || (int v417 = (unsigned __int16)v416[1], v417 != 5) && v417 != 3)
        {
LABEL_686:
          nw_connection_set_state_on_nw_queue((NWConcrete_nw_connection *)v411, v410);
          goto LABEL_687;
        }

        int minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40));
        char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40));
        if (!minimize_logging)
        {
          if ((logging_disabled & 1) != 0) {
            goto LABEL_687;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v420 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v420, OS_LOG_TYPE_INFO))
          {
            v421 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
            v422 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
            nw_endpoint_t v423 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
            v424 = nw_endpoint_get_logging_description(v423);
            v425 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
            v426 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
            v427 = (char *)nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
            *(_DWORD *)__int128 buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v421;
            *(_WORD *)&_BYTE buf[22] = 2082;
            *(void *)&_BYTE buf[24] = v422;
            *(_WORD *)v524 = 2082;
            *(void *)&v524[2] = v424;
            *(_WORD *)&v524[10] = 2082;
            *(void *)&v524[12] = v425;
            *(_WORD *)&v524[20] = 2082;
            *(void *)&v524[22] = v426;
            __int16 v525 = 2114;
            v526 = v427;
            _os_log_impl( &dword_181A5C000,  v420,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] skipping state update",  buf,  0x48u);
          }

          goto LABEL_685;
        }

        if ((logging_disabled & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v420 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v420, OS_LOG_TYPE_DEBUG))
          {
            v500 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
            v501 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
            nw_endpoint_t v502 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
            v503 = nw_endpoint_get_logging_description(v502);
            v504 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
            v505 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
            v506 = (char *)nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
            *(_DWORD *)__int128 buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v500;
            *(_WORD *)&_BYTE buf[22] = 2082;
            *(void *)&_BYTE buf[24] = v501;
            *(_WORD *)v524 = 2082;
            *(void *)&v524[2] = v503;
            *(_WORD *)&v524[10] = 2082;
            *(void *)&v524[12] = v504;
            *(_WORD *)&v524[20] = 2082;
            *(void *)&v524[22] = v505;
            __int16 v525 = 2114;
            v526 = v506;
            _os_log_impl( &dword_181A5C000,  v420,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] skipping state update",  buf,  0x48u);
          }
            }

LABEL_685:
        }
      }
    }
  }

LABEL_687:
  uint64_t v429 = *(void *)(a1 + 32);
  v428 = *(void **)(a1 + 40);
  v430 = *(void **)(v429 + 144);
  if (v428 == v430)
  {
    if ((*(_BYTE *)(v429 + 109) & 0x40) != 0
      && (v431 = *(_WORD **)(a1 + 56)) != 0LL
      && *v431 == 1
      && (unsigned int v432 = (unsigned __int16)v431[1], v432 <= 6)
      && ((1 << v432) & 0x68) != 0)
    {
      id v433 = (id)v429;
      nw_context_assert_queue(*((void **)v433 + 3));
      v434 = (unsigned __int8 *)*((void *)v433 + 53);
      if (v434) {
        nw_array_apply(v434, (uint64_t)&__block_literal_global_228);
      }

      uint64_t v429 = *(void *)(a1 + 32);
      v428 = *(void **)(a1 + 40);
      v430 = *(void **)(v429 + 144);
    }

    else
    {
      v430 = *(void **)(a1 + 40);
    }
  }

  if (v428 == v430 && v430)
  {
    v435 = *(_WORD **)(a1 + 56);
    if (v435 && *v435 == 1 && (unsigned int v436 = (unsigned __int16)v435[1], v436 <= 6) && ((1 << v436) & 0x68) != 0)
    {
      id v437 = v430;
      os_unfair_lock_lock((os_unfair_lock_t)v437 + 28);
      id v438 = *((id *)v437 + 8);
      os_unfair_lock_unlock((os_unfair_lock_t)v437 + 28);

      nw_connection_send_path_changed_on_nw_queue((void *)v429, v438);
      uint64_t v429 = *(void *)(a1 + 32);
      v428 = *(void **)(a1 + 40);
      v430 = *(void **)(v429 + 144);
    }

    else
    {
      v428 = v430;
    }
  }

  if (v428 == v430)
  {
    if (v430)
    {
      v439 = *(_WORD **)(a1 + 56);
      if (v439)
      {
        if (*v439 == 1 && v439[1] == 10)
        {
          v440 = (void *)nw_endpoint_handler_copy_connected_path(v430);
          nw_connection_send_path_changed_on_nw_queue((void *)v429, v440);
        }
      }
    }
  }

void sub_181FAD40C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL62nw_connection_take_initial_data_transfer_snapshots_on_nw_queueP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  return 1LL;
}

BOOL ___ZL51nw_connection_run_sec_experiment_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  experimental_probe = (nw_connection *)nw_connection_create_experimental_probe(*(void **)(a1 + 32), v5, a2);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (experimental_probe)
  {
    if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      char v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)__int128 buf = 136446722;
        int v18 = "nw_connection_run_sec_experiment_locked_on_nw_queue_block_invoke";
        __int16 v19 = 1024;
        int v20 = v9;
        __int16 v21 = 2082;
        uint64_t v22 = a2;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Probe connection started for experiment %{public}s",  buf,  0x1Cu);
      }
    }

    BOOL v10 = nw_queue_copy_current_workloop();
    nw_connection_set_queue(experimental_probe, (dispatch_queue_t)v10);

    nw_connection_add_probe(*(void **)(a1 + 32), experimental_probe);
    id v11 = *(void **)(*(void *)(a1 + 32) + 24LL);
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = ___ZL51nw_connection_run_sec_experiment_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke_217;
    v15[3] = &unk_189BC93A0;
    uint64_t v16 = experimental_probe;
    nw_queue_context_async(v11, v15);
    uint64_t v12 = v16;
LABEL_16:

    goto LABEL_17;
  }

  if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v12 = (nw_connection *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      int v13 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)__int128 buf = 136446722;
      int v18 = "nw_connection_run_sec_experiment_locked_on_nw_queue_block_invoke_2";
      __int16 v19 = 1024;
      int v20 = v13;
      __int16 v21 = 2082;
      uint64_t v22 = a2;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Probe connection skipped for experiment %{public}s: nw_connection_create_experimental_probe ret urned nil connection",  buf,  0x1Cu);
    }

    goto LABEL_16;
  }

void sub_181FAD9F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL51nw_connection_run_sec_experiment_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke_220( uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v2 && !nw_path_parameters_get_logging_disabled(*(void *)(v2 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v5 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v7 = 136446722;
      char v8 = "nw_connection_run_sec_experiment_locked_on_nw_queue_block_invoke";
      __int16 v9 = 1024;
      int v10 = v6;
      __int16 v11 = 2082;
      uint64_t v12 = a2;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Probe connection skipped for experiment %{public}s",  (uint8_t *)&v7,  0x1Cu);
    }
  }

id nw_connection_copy_protocol_metadata_locked(uint64_t a1, void *a2, int a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v7 = a2;
  if (a1)
  {
    id v8 = nw_endpoint_handler_copy_protocol_metadata(*(void **)(a1 + 144), v7, a3, a4);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v21 = "nw_connection_copy_protocol_metadata_locked";
  __int16 v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v21 = "nw_connection_copy_protocol_metadata_locked";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v21 = "nw_connection_copy_protocol_metadata_locked";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v21 = "nw_connection_copy_protocol_metadata_locked";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v21 = "nw_connection_copy_protocol_metadata_locked";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FADDFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL46nw_connection_run_ech_probe_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke( uint64_t a1, void *a2)
{
  id v3 = a2;
  id v6 = v3;
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    unint64_t v4 = *(void **)(a1 + 32);
    id v5 = nw_protocol_options_copy(v3);
    nw_protocol_stack_append_application_protocol(v4, v5);
  }

  else if (nw_protocol_options_is_tls(v3))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
    nw_protocol_stack_append_application_protocol(*(void **)(a1 + 32), *(void **)(a1 + 40));
  }
}

void sub_181FADE90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL46nw_connection_run_ech_probe_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke_224( uint64_t a1)
{
}

void ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke_214( uint64_t a1, void *a2)
{
  id v3 = a2;
  *(_DWORD *)(*(void *)(a1 + 32) + 504LL) = nw_endpoint_handler_get_proxy_privacy_stance(v3);
}

nw_parameters_t nw_connection_copy_parameters(nw_connection_t connection)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = connection;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (nw_parameters *)v1[2];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v16 = "nw_connection_copy_parameters";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_connection_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v16 = "nw_connection_copy_parameters";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_connection_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_connection_copy_parameters";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t ___ZL54nw_connection_start_candidate_manager_if_needed_lockedP24NWConcrete_nw_connection_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  unint64_t v4 = nw_resolution_report_copy_successful_endpoint(v3);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v5 && !nw_path_parameters_get_logging_disabled(*(void *)(v5 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v6 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v11 = 136446722;
      os_log_type_t v12 = "nw_connection_start_candidate_manager_if_needed_locked_block_invoke";
      __int16 v13 = 1024;
      int v14 = v7;
      __int16 v15 = 2112;
      BOOL v16 = v4;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Found endpoint %@",  (uint8_t *)&v11,  0x1Cu);
    }
  }

  nw_endpoint_type_t type = nw_endpoint_get_type(v4);
  if (type == nw_endpoint_type_address)
  {
    uint64_t v9 = a1 + 48;
    goto LABEL_12;
  }

  if (type == nw_endpoint_type_bonjour_service)
  {
    uint64_t v9 = a1 + 40;
LABEL_12:
    objc_storeStrong((id *)(*(void *)(*(void *)v9 + 8LL) + 40LL), v4);
  }

  return 1LL;
}

void sub_181FAE2F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL49nw_connection_check_for_unlisted_tracker_on_queueP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObject_block_invoke()
{
  return 0LL;
}

void nw_connection_start_dry_run_on_nw_queue(NWConcrete_nw_connection *a1)
{
  *(void *)&v30[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1->context);
    parameters = (uint64_t *)v2->parameters;
    if (v2->dry_run_endpoint_handler)
    {
      if (parameters && !nw_path_parameters_get_logging_disabled(parameters[13]))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          unsigned int top_id = v2->top_id;
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v28 = "nw_connection_start_dry_run_on_nw_queue";
          __int16 v29 = 1024;
          *(_DWORD *)uint64_t v30 = top_id;
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Dry run endpoint handler already started",  buf,  0x12u);
        }
      }
    }

    else
    {
      id v6 = parameters;
      BOOL v7 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v6,  0,  0);

      nw_parameters_set_dry_run((void *)v7, 1u);
      nw_parameters_set_indefinite((void *)v7, 1);
      inner = nw_endpoint_handler_create_inner( v2->endpoint,  (void *)v7,  nw_connection_endpoint_report_dry_run_on_nw_queue,  v2,  0LL,  0,  1);
      dry_run_endpoint_handler = v2->dry_run_endpoint_handler;
      v2->dry_run_endpoint_handler = (OS_nw_endpoint_handler *)inner;

      os_log_type_t v10 = v2->parameters;
      if (v10 && !nw_path_parameters_get_logging_disabled(*((void *)v10 + 13)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v11 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          unsigned int v12 = v2->top_id;
          id_string = nw_endpoint_handler_get_id_string(v2->dry_run_endpoint_handler);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v28 = "nw_connection_start_dry_run_on_nw_queue";
          __int16 v29 = 1024;
          *(_DWORD *)uint64_t v30 = v12;
          v30[2] = 2082;
          *(void *)&v30[3] = id_string;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Starting dry-run endpoint handler [C%{public}s] to check for a better path",  buf,  0x1Cu);
        }
      }

      context = v2->context;
      v23[0] = MEMORY[0x1895F87A8];
      v23[1] = 3221225472LL;
      v23[2] = ___ZL39nw_connection_start_dry_run_on_nw_queueP24NWConcrete_nw_connection_block_invoke;
      v23[3] = &unk_189BC93A0;
      uint64_t v24 = v2;
      nw_queue_context_async(context, v23);
    }

    goto LABEL_18;
  }

  __nwlog_obj();
  __int16 v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v28 = "nw_connection_start_dry_run_on_nw_queue";
  BOOL v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v16, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_connection_start_dry_run_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v28 = "nw_connection_start_dry_run_on_nw_queue";
          __int16 v29 = 2082;
          *(void *)uint64_t v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v21)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_connection_start_dry_run_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_connection_start_dry_run_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FAE808( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_state_on_nw_queue(NWConcrete_nw_connection *a1, unsigned int a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  unint64_t v4 = v3;
  if (v3)
  {
    nw_context_assert_queue(v3->context);
    int state = v4->state;
    if (state != a2 && state != 5)
    {
      v4->int state = a2;
      if (a2 == 4)
      {
        BOOL v7 = v4;
        nw_context_assert_queue(v4->context);
        data_transfer_reports = v7->data_transfer_reports;
        if (data_transfer_reports)
        {
          uint64_t v9 = (OS_nw_array *)nw_array_create();
          if (v9 != data_transfer_reports)
          {
            os_log_type_t v10 = v9;
            std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( (uint64_t)&v9[2],  (void **)&data_transfer_reports[2].super.super.isa->isa,  (void **)&data_transfer_reports[3].super.super.isa->isa,  data_transfer_reports[3].super.super.isa - data_transfer_reports[2].super.super.isa);
            data_transfer_reports = v10;
          }

          nw_array_apply((unsigned __int8 *)data_transfer_reports, (uint64_t)&__block_literal_global_227);
        }
      }

      int v11 = v4;
      nw_context_assert_queue(v4->context);
      nw_connection_report_state_with_handler_on_nw_queue(v11, a2, v11[26], v11[25]);
    }

    goto LABEL_13;
  }

  __nwlog_obj();
  unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v23 = "nw_connection_set_state_on_nw_queue";
  __int16 v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v23 = "nw_connection_set_state_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v23 = "nw_connection_set_state_on_nw_queue";
          __int16 v24 = 2082;
          char v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }

      if (v18)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v23 = "nw_connection_set_state_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v23 = "nw_connection_set_state_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FAEB70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_update_better_path_locked_on_nw_queue(NWConcrete_nw_connection *a1)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1->context);
    id v3 = v2->parent_endpoint_handler;
    if ((*((_BYTE *)v2 + 109) & 0x40) != 0) {
      unint64_t v4 = nw_endpoint_handler_copy_connected_flow_handler(v2->parent_endpoint_handler);
    }
    else {
      unint64_t v4 = 0LL;
    }
    uint64_t v5 = v2->ready_dry_run_endpoint_handler;
    if (v5 || (v6 = v4, v3, uint64_t v5 = v6, (v3 = v5) != 0LL))
    {
      BOOL v7 = v5;
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 28);
      id v8 = *((id *)v7 + 8);
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 28);

      if (!v4) {
        goto LABEL_21;
      }
      if (nw_endpoint_handler_get_alternate_path_state(v4, v3, v7, v8))
      {
        if (v2->alternate_path_state != 1)
        {
          v2->alternate_path_int state = 1;
          parameters = v2->parameters;
          if (parameters && !nw_path_parameters_get_logging_disabled(*((void *)parameters + 13)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
            {
              unsigned int top_id = v2->top_id;
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = top_id;
              _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Better alternate path available",  buf,  0x12u);
            }
          }

          stats_report = v2->stats_report;
          if (stats_report) {
            ++stats_report->u.legacy.statistics_report.better_route_event_count;
          }
          char v13 = 1;
          int v14 = 1;
          goto LABEL_54;
        }

void sub_181FAF330( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_connection_send_viability_changed_on_nw_queue(NWConcrete_nw_connection *a1, int a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  unint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v35 = "nw_connection_send_viability_changed_on_nw_queue";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v33 = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v18, &v33, &v32))
    {
      if (v33 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = v33;
        if (os_log_type_enabled(v19, v33))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v35 = "nw_connection_send_viability_changed_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = v33;
        BOOL v23 = os_log_type_enabled(v19, v33);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v35 = "nw_connection_send_viability_changed_on_nw_queue";
            __int16 v36 = 2082;
            BOOL v37 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v23)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v35 = "nw_connection_send_viability_changed_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v19, v22, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = v33;
        if (os_log_type_enabled(v19, v33))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v35 = "nw_connection_send_viability_changed_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FAF86C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, void *a25)
{
  _Unwind_Resume(a1);
}

void nw_connection_send_path_changed_on_nw_queue(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    nw_context_assert_queue(*((void **)v3 + 3));
    uint64_t v5 = (const void *)*((void *)v3 + 32);
    if (v5 && *((_DWORD *)v3 + 20) != 5)
    {
      id v6 = _Block_copy(v5);
      dispatch_qos_class_t v7 = *((_DWORD *)v3 + 48);
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 3221225472LL;
      v17[2] = ___ZL43nw_connection_send_path_changed_on_nw_queueP24NWConcrete_nw_connectionPU21objcproto10OS_nw_path8NSObject_block_invoke;
      v17[3] = &unk_189BC91E8;
      id v19 = v6;
      id v18 = v4;
      id v8 = v6;
      nw_connection_async_client(v3, v7, v17);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v23 = "nw_connection_send_path_changed_on_nw_queue";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v21 = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v10, &v21, &v20))
  {
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v21;
      if (os_log_type_enabled(v11, v21))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v23 = "nw_connection_send_path_changed_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v21;
      BOOL v15 = os_log_type_enabled(v11, v21);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v23 = "nw_connection_send_path_changed_on_nw_queue";
          __int16 v24 = 2082;
          char v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v23 = "nw_connection_send_path_changed_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = v21;
      if (os_log_type_enabled(v11, v21))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v23 = "nw_connection_send_path_changed_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FAFBE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_connection_send_path_changed_on_nw_queueP24NWConcrete_nw_connectionPU21objcproto10OS_nw_path8NSObject_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

uint64_t ___ZL54nw_connection_update_data_transfer_reports_on_nw_queueP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  return 1LL;
}

void ___ZL48nw_connection_send_viability_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke( uint64_t a1)
{
  id v1 = *(_DWORD **)(a1 + 32);
  if (v1[32] == 2)
  {
    dispatch_qos_class_t v3 = v1[48];
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 3221225472LL;
    v4[2] = ___ZL48nw_connection_send_viability_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke_2;
    v4[3] = &unk_189BC71E8;
    id v5 = *(id *)(a1 + 40);
    char v6 = *(_BYTE *)(a1 + 48);
    nw_connection_async_client(v1, v3, v4);
  }

void sub_181FAFCE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

uint64_t ___ZL48nw_connection_send_viability_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke_3( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

uint64_t ___ZL48nw_connection_send_viability_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

uint64_t ___ZL50nw_connection_send_better_path_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

uint64_t ___ZL59nw_connection_send_alternate_path_state_changed_on_nw_queueP24NWConcrete_nw_connection36nw_connection_alternate_path_state_t_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned int *)(a1 + 40));
}

uint64_t nw_connection_endpoint_report_dry_run_on_nw_queue( void *a1, int a2, int a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v9 = a1;
  os_log_type_t v10 = a6;
  nw_context_assert_queue(v10[3]);
  int v11 = (os_unfair_lock_s *)(v10 + 17);
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3221225472LL;
  v15[2] = ___ZL49nw_connection_endpoint_report_dry_run_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke;
  v15[3] = &unk_189BC75E8;
  os_log_type_t v12 = v10;
  void v15[4] = v12;
  id v13 = v9;
  void v15[5] = v13;
  int v16 = a3;
  int v17 = a2;
  os_unfair_lock_lock(v11);
  ___ZL49nw_connection_endpoint_report_dry_run_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke((uint64_t)v15);
  os_unfair_lock_unlock(v11);

  return 1LL;
}

void sub_181FAFE18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL39nw_connection_start_dry_run_on_nw_queueP24NWConcrete_nw_connection_block_invoke(uint64_t a1)
{
  id v1 = *(void **)(*(void *)(a1 + 32) + 176LL);
  if (v1) {
    nw_endpoint_handler_start(v1);
  }
}

void ___ZL49nw_connection_endpoint_report_dry_run_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke( uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v2 && !nw_path_parameters_get_logging_disabled(*(void *)(v2 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    dispatch_qos_class_t v3 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      id v5 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
      uint64_t v6 = *(unsigned int *)(a1 + 48);
      else {
        dispatch_qos_class_t v7 = off_189BBBBF0[v6];
      }
      int v9 = 136446978;
      os_log_type_t v10 = "nw_connection_endpoint_report_dry_run_on_nw_queue_block_invoke";
      __int16 v11 = 1024;
      int v12 = v4;
      __int16 v13 = 2082;
      os_log_type_t v14 = v5;
      __int16 v15 = 2082;
      int v16 = v7;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Dry run state update (mode %{public}s, state %{public}s)",  (uint8_t *)&v9,  0x26u);
    }
  }

  if (*(_DWORD *)(a1 + 52) == 2 && *(_DWORD *)(a1 + 48) == 3) {
    objc_storeStrong((id *)(*(void *)(a1 + 32) + 184LL), *(id *)(a1 + 40));
  }
  id v8 = *(NWConcrete_nw_connection **)(a1 + 32);
}

uint64_t __nw_connection_start_block_invoke_15(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 109LL) |= 0x10u;
  return result;
}

uint64_t __nw_connection_start_block_invoke_16(uint64_t a1)
{
  uint64_t result = mach_continuous_time();
  if (result <= 1) {
    uint64_t v3 = 1LL;
  }
  else {
    uint64_t v3 = result;
  }
  *(void *)(*(void *)(a1 + 32) + 72LL) = v3;
  *(_DWORD *)(*(void *)(a1 + 32) + 504LL) = 1;
  return result;
}

void ___ZL51nw_connection_run_sec_experiment_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke_217( uint64_t a1)
{
}

uint64_t ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke_234( uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = a3;
  id v5 = v4 + 34;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke_2;
  v10[3] = &unk_189BC6E60;
  uint64_t v6 = v4;
  v10[4] = v6;
  id v7 = *(id *)(a1 + 32);
  v10[5] = v7;
  id v8 = *(id *)(a1 + 40);
  v10[6] = v8;
  os_unfair_lock_lock(v5);
  ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke_2((uint64_t)v10);
  os_unfair_lock_unlock(v5);
  if (*(_BYTE *)(a1 + 48)) {
    nw_connection_force_cancel(v6);
  }
  else {
    nw_connection_cancel(v6);
  }

  return 1LL;
}

void sub_181FB0100(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke_235( uint64_t a1, int a2, NWConcrete_nw_connection *a3)
{
  return 1LL;
}

void ___ZL27nw_connection_cancel_probesP24NWConcrete_nw_connectionb_block_invoke_2(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 80) == 5)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 16LL);
    if (!v3 || nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104))) {
      goto LABEL_10;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v4 = (id)gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR))
    {
LABEL_9:

LABEL_10:
      nw_array_append(*(void *)(a1 + 48), *(void **)(a1 + 32));
      return;
    }

    int v5 = *(_DWORD *)(*(void *)(a1 + 40) + 448LL);
    int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    int v11 = 136446722;
    int v12 = "nw_connection_cancel_probes_block_invoke_2";
    __int16 v13 = 1024;
    int v14 = v5;
    __int16 v15 = 1024;
    int v16 = v6;
    id v7 = "%{public}s [C%u] Probe already cancelled, removing probe [C%u]";
LABEL_8:
    _os_log_impl(&dword_181A5C000, (os_log_t)v4, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v11, 0x18u);
    goto LABEL_9;
  }

  if (!*(void *)(v2 + 216) && !*(void *)(v2 + 208))
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 16LL);
    if (!v8 || nw_path_parameters_get_logging_disabled(*(void *)(v8 + 104))) {
      goto LABEL_10;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v4 = (id)gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_9;
    }
    int v9 = *(_DWORD *)(*(void *)(a1 + 40) + 448LL);
    int v10 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    int v11 = 136446722;
    int v12 = "nw_connection_cancel_probes_block_invoke";
    __int16 v13 = 1024;
    int v14 = v9;
    __int16 v15 = 1024;
    int v16 = v10;
    id v7 = "%{public}s [C%u] Probe has no handlers that would communicate cancelled state, removing probe [C%u]";
    goto LABEL_8;
  }

void nw_connection_force_cancel(nw_connection_t connection)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = connection;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_connection_cancel_inner((NWConcrete_nw_connection *)v1, 1);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  int v14 = "nw_connection_force_cancel";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v14 = "nw_connection_force_cancel";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v14 = "nw_connection_force_cancel";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v14 = "nw_connection_force_cancel";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v14 = "nw_connection_force_cancel";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FB05B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL55nw_connection_cleanup_data_transfer_reports_on_nw_queueP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  return 1LL;
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_24718()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

uint64_t nw_connection_get_attempted_probe_on_queue(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(*((void **)v1 + 3));
    uint64_t v3 = v2[109] & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  int v16 = "nw_connection_get_attempted_probe_on_queue";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v16 = "nw_connection_get_attempted_probe_on_queue";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v16 = "nw_connection_get_attempted_probe_on_queue";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v16 = "nw_connection_get_attempted_probe_on_queue";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v16 = "nw_connection_get_attempted_probe_on_queue";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FB08AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_connection_create_with_connection(void *a1, void *a2)
{
  uint64_t v217 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
    v96 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v19_Block_object_dispose(va, 8) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v98 = type[0];
      if (os_log_type_enabled(v97, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        _os_log_impl(&dword_181A5C000, v97, v98, "%{public}s called with null original_connection", buf, 0xCu);
      }
    }

    else if ((_BYTE)v198)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v104 = type[0];
      BOOL v105 = os_log_type_enabled(v97, type[0]);
      if (backtrace_string)
      {
        if (v105)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v97,  v104,  "%{public}s called with null original_connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v96) {
          goto LABEL_240;
        }
        goto LABEL_239;
      }

      if (v105)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        _os_log_impl( &dword_181A5C000,  v97,  v104,  "%{public}s called with null original_connection, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v136 = type[0];
      if (os_log_type_enabled(v97, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        _os_log_impl( &dword_181A5C000,  v97,  v136,  "%{public}s called with null original_connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_237;
  }

  if (!v4)
  {
    __nwlog_obj();
    unsigned int v99 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
    v96 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v19_Block_object_dispose(va, 8) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v100 = type[0];
      if (os_log_type_enabled(v97, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        _os_log_impl(&dword_181A5C000, v97, v100, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if ((_BYTE)v198)
    {
      v106 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v107 = type[0];
      BOOL v108 = os_log_type_enabled(v97, type[0]);
      if (v106)
      {
        if (v108)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v106;
          _os_log_impl( &dword_181A5C000,  v97,  v107,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v106);
LABEL_238:
        if (!v96)
        {
LABEL_240:
          os_log_type_t v39 = 0LL;
          goto LABEL_225;
        }

LABEL_239:
        free(v96);
        goto LABEL_240;
      }

      if (v108)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        _os_log_impl(&dword_181A5C000, v97, v107, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v137 = type[0];
      if (os_log_type_enabled(v97, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connection";
        _os_log_impl( &dword_181A5C000,  v97,  v137,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      id v60 = v39;
      unsigned int v61 = v40;
      nw_endpoint_t v62 = 42;
      goto LABEL_94;
    }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v95 = "nw_protocol_http1_notify";
          uint64_t v47 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v92 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v48 = (os_log_s *)__nwlog_obj();
            int v49 = type;
            if (!os_log_type_enabled(v48, type)) {
              goto LABEL_274;
            }
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v95 = "nw_protocol_http1_notify";
            os_log_type_t v50 = "%{public}s called with null http1_stream";
            goto LABEL_273;
          }

          if (v92)
          {
            nw_endpoint_t v56 = (char *)__nw_create_backtrace_string();
            uint64_t v48 = (os_log_s *)__nwlog_obj();
            int v49 = type;
            id v90 = os_log_type_enabled(v48, type);
            if (v56)
            {
              if (!v90) {
                goto LABEL_267;
              }
              goto LABEL_212;
            }

            if (!v90) {
              goto LABEL_274;
            }
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v95 = "nw_protocol_http1_notify";
            os_log_type_t v50 = "%{public}s called with null http1_stream, no backtrace";
          }

          else
          {
            uint64_t v48 = (os_log_s *)__nwlog_obj();
            int v49 = type;
            if (!os_log_type_enabled(v48, type)) {
              goto LABEL_274;
            }
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v95 = "nw_protocol_http1_notify";
            os_log_type_t v50 = "%{public}s called with null http1_stream, backtrace limit exceeded";
          }

  if (v95)
  {
    LODWORD(a1[3].output_handler_context) = nw_path_get_maximum_packet_size(v95);
    LODWORD(a1[3].handle) = nw_path_get_mtu(v95);
  }

void sub_181FB2A08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20, uint64_t a21, void *a22, void *a23, uint64_t a24, uint64_t a25, void *a26, void *a27, void *a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, id a43, char a44)
{
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose(&a44, 8);

  _Unwind_Resume(a1);
}

void __nw_connection_create_with_connection_block_invoke(void *a1)
{
  *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = (*(_BYTE *)(a1[4] + 109LL) & 0x40) != 0;
  objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), *(id *)(a1[4] + 144LL));
}

void *nw_connection_create_with_client_id(const unsigned __int8 *a1, void *a2)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (!v3)
  {
    os_log_type_t v45 = 0LL;
    __nwlog_obj();
    uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v71 = "nw_connection_create_with_client_id";
    uint64_t v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v71 = "nw_connection_create_with_client_id";
        _os_log_impl(&dword_181A5C000, v49, v50, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v68)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type;
      BOOL v55 = os_log_type_enabled(v49, type);
      if (backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v71 = "nw_connection_create_with_client_id";
          __int16 v72 = 2082;
          *(void *)v73 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v49,  v54,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v48) {
          goto LABEL_105;
        }
        goto LABEL_104;
      }

      if (v55)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v71 = "nw_connection_create_with_client_id";
        _os_log_impl(&dword_181A5C000, v49, v54, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v71 = "nw_connection_create_with_client_id";
        _os_log_impl( &dword_181A5C000,  v49,  v59,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_102;
  }

  id v67 = v3;
  if (uuid_is_null(a1))
  {
    os_log_type_t v45 = v3;
    __nwlog_obj();
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v71 = "nw_connection_create_with_client_id";
    uint64_t v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v71 = "nw_connection_create_with_client_id";
        _os_log_impl(&dword_181A5C000, v49, v52, "%{public}s called with null !uuid_is_null(client_id)", buf, 0xCu);
      }
    }

    else if (v68)
    {
      nw_endpoint_t v56 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type;
      BOOL v58 = os_log_type_enabled(v49, type);
      if (v56)
      {
        if (v58)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v71 = "nw_connection_create_with_client_id";
          __int16 v72 = 2082;
          *(void *)v73 = v56;
          _os_log_impl( &dword_181A5C000,  v49,  v57,  "%{public}s called with null !uuid_is_null(client_id), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v56);
LABEL_103:
        if (!v48)
        {
LABEL_105:
          os_log_type_t v22 = 0LL;
          goto LABEL_69;
        }

void sub_181FB3964( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20, void *a21)
{
  _Unwind_Resume(a1);
}

void nw_connection_add_initial_inbound_data(void *a1, void *a2, int a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v29 = "nw_connection_add_initial_inbound_data";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v27 = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (v27 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v27;
      if (os_log_type_enabled(v10, v27))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v29 = "nw_connection_add_initial_inbound_data";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v27;
      BOOL v16 = os_log_type_enabled(v10, v27);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v29 = "nw_connection_add_initial_inbound_data";
          __int16 v30 = 2082;
          os_log_type_t v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v29 = "nw_connection_add_initial_inbound_data";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v27;
      if (os_log_type_enabled(v10, v27))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v29 = "nw_connection_add_initial_inbound_data";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FB3EE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_add_initial_inbound_data_block_invoke(uint64_t a1)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  id v1 = *(void **)(a1 + 40);
  int v2 = *(_DWORD *)(a1 + 48);
  id v3 = *(id *)(*(void *)(a1 + 32) + 144LL);
  id v4 = v1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v38 = (id)gLogObj;
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v6_Block_object_dispose(va, 8) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v19 = (os_log_s *)(id)gLogObj;
      os_log_type_t v39 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
        _os_log_impl(&dword_181A5C000, v19, v39, "%{public}s called with null handler", applier, 0xCu);
      }
    }

    else if ((_BYTE)v68)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v19 = (os_log_s *)(id)gLogObj;
      os_log_type_t v44 = type[0];
      BOOL v45 = os_log_type_enabled(v19, type[0]);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v44,  "%{public}s called with null handler, dumping backtrace:%{public}s",  applier,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_72;
      }

      if (v45)
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
        _os_log_impl(&dword_181A5C000, v19, v44, "%{public}s called with null handler, no backtrace", applier, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v19 = (os_log_s *)(id)gLogObj;
      os_log_type_t v64 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
        _os_log_impl( &dword_181A5C000,  v19,  v64,  "%{public}s called with null handler, backtrace limit exceeded",  applier,  0xCu);
      }
    }

void sub_181FB54D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_connection_create_with_connected_socket_and_parameters(int a1, void *a2)
{
  id v3 = a2;
  do_not_guard = nw_fd_wrapper_create_do_not_guard(a1);
  id v5 = v3;
  BOOL v6 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v5,  0,  0);

  id v7 = nw_connection_create_with_connected_socket_internal(do_not_guard, (void *)v6, 0LL, 0LL, 0);
  if (!v7) {
    nw_fd_wrapper_relinquish_fd(do_not_guard);
  }

  return v7;
}

void sub_181FB558C(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

void *nw_connection_create_with_connected_socket_internal(void *a1, void *a2, void *a3, void *a4, int a5)
{
  uint64_t v155 = *MEMORY[0x1895F89C0];
  id v10 = a1;
  id v11 = a2;
  os_log_type_t v136 = a3;
  id v138 = a4;
  nw_allow_use_of_dispatch_internal();
  os_log_type_t v137 = v10;
  if (!v11)
  {
    __nwlog_obj();
    v80 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
    int v81 = (char *)_os_log_send_and_compose_impl();

    v149[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v149[0] == 17)
    {
      __nwlog_obj();
      uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v83 = v149[0];
      if (os_log_type_enabled(v82, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        _os_log_impl(&dword_181A5C000, v82, v83, "%{public}s called with null parameters", buf, 0xCu);
      }

      goto LABEL_179;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v114 = v149[0];
      if (os_log_type_enabled(v82, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        _os_log_impl( &dword_181A5C000,  v82,  v114,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_179;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v94 = v149[0];
    BOOL v95 = os_log_type_enabled(v93, (os_log_type_t)v149[0]);
    if (backtrace_string)
    {
      if (v95)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v93,  v94,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      if (!v81) {
        goto LABEL_198;
      }
      goto LABEL_197;
    }

    if (v95)
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
      _os_log_impl(&dword_181A5C000, v93, v94, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
    }

    goto LABEL_195;
  }

  if (!v10)
  {
    __nwlog_obj();
    v84 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
    int v81 = (char *)_os_log_send_and_compose_impl();

    v149[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v149[0] == 17)
    {
      __nwlog_obj();
      uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v85 = v149[0];
      if (os_log_type_enabled(v82, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        _os_log_impl(&dword_181A5C000, v82, v85, "%{public}s called with null fd_wrapper", buf, 0xCu);
      }

void sub_181FB7178( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20, void *a21, void *a22, void *a23)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL51nw_connection_create_with_connected_socket_internalPU27objcproto16OS_nw_fd_wrapper8NSObjectPU27objcproto16OS_nw_parametersS_PU25objcproto14OS_nw_endpointS_S5_b_block_invoke( uint64_t a1, int a2)
{
  nw_endpoint_t v3 = nw_endpoint_create_with_peer_name(a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) != 0LL;
}

uint64_t ___ZL51nw_connection_create_with_connected_socket_internalPU27objcproto16OS_nw_fd_wrapper8NSObjectPU27objcproto16OS_nw_parametersS_PU25objcproto14OS_nw_endpointS_S5_b_block_invoke_2( uint64_t a1, int a2)
{
  nw_endpoint_t v3 = nw_endpoint_create_with_sock_name(a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return 1LL;
}

void *nw_connection_create_with_connected_socket(int a1, unsigned int a2)
{
  nw_parameters_t v4 = nw_parameters_create();
  nw_parameters_set_data_mode(v4, a2);
  do_not_guard = nw_fd_wrapper_create_do_not_guard(a1);
  BOOL v6 = nw_connection_create_with_connected_socket_internal(do_not_guard, v4, 0LL, 0LL, 0);
  if (!v6) {
    nw_fd_wrapper_relinquish_fd(do_not_guard);
  }

  return v6;
}

void sub_181FB7398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_connection_create_from_protocol_on_nw_queue(void *a1, void *a2, nw_protocol *a3)
{
  uint64_t v126 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  nw_allow_use_of_dispatch_internal();
  id v111 = v5;
  if (v5)
  {
    if (v6)
    {
      id v7 = v6;
      id v8 = *(id *)(v7[13] + 136LL);

      nw_context_assert_queue(v8);
      uint64_t v9 = v7;
      BOOL v10 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v9,  0,  0);
      id v110 = v6;

      if (v10)
      {
        id v11 = (id)v10;
        v11[12] = v11[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;

        uint64_t v12 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]( (void **)objc_alloc(&OBJC_CLASS___NWConcrete_nw_connection),  v5,  v11,  0);
        uint64_t v13 = v12;
        if (v12)
        {
          uint64_t v14 = *(void *)(v12 + 8);
          uint64_t v15 = *(void *)(v12 + 16);
          nw_allow_use_of_dispatch_internal();
          if (has_modifiers == 1)
          {
            os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
            uint64_t v16 = (void *)g_modifier_list;
            if (g_modifier_list)
            {
              while (1)
              {
                int v17 = (uint64_t (*)(uint64_t, uint64_t))v16[2];
                if (v17)
                {
                  if ((v17(v14, v15) & 1) != 0) {
                    break;
                  }
                }

                uint64_t v16 = (void *)*v16;
                if (!v16) {
                  goto LABEL_7;
                }
              }

              os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
              uint64_t v18 = *(void *)(v13 + 16);
              if (!v18)
              {
                uint64_t v21 = 0LL;
LABEL_19:
                *(_BYTE *)(v13 + 109) |= 4u;
                unsigned int v22 = *(_DWORD *)(v13 + 448);
                id v23 = *(id *)(v13 + 8);
                id v24 = v21;
                BOOL v108 = v24;
                os_log_type_t v109 = (id)v13;
                if (!v23)
                {
                  __nwlog_obj();
                  v87 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)__int128 buf = 136446210;
                  os_log_type_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                  uint64_t v88 = (char *)_os_log_send_and_compose_impl();

                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v112 = 0;
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v90 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)__int128 buf = 136446210;
                      os_log_type_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_181A5C000, v89, v90, "%{public}s called with null endpoint", buf, 0xCu);
                    }
                  }

                  else if (v112)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v94 = type;
                    BOOL v95 = os_log_type_enabled(v89, type);
                    if (backtrace_string)
                    {
                      if (v95)
                      {
                        *(_DWORD *)__int128 buf = 136446466;
                        os_log_type_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        __int16 v116 = 2082;
                        *(void *)uint64_t v117 = backtrace_string;
                        _os_log_impl( &dword_181A5C000,  v89,  v94,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
                      }

                      free(backtrace_string);
                      if (!v88) {
                        goto LABEL_195;
                      }
                      goto LABEL_194;
                    }

                    if (v95)
                    {
                      *(_DWORD *)__int128 buf = 136446210;
                      os_log_type_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl( &dword_181A5C000,  v89,  v94,  "%{public}s called with null endpoint, no backtrace",  buf,  0xCu);
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v101 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)__int128 buf = 136446210;
                      os_log_type_t v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl( &dword_181A5C000,  v89,  v101,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
                    }
                  }

                  goto LABEL_192;
                }

                if (v24)
                {
                  id v25 = -[NWConcrete_nw_endpoint_handler initWithEndpoint:parameters:reportCallback:context:parent:identifier:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_endpoint_handler),  v23,  v24,  nw_connection_endpoint_report_on_nw_queue,  v109,  0LL,  v22);
                  id v26 = v25;
                  if (v25)
                  {
                    *((_DWORD *)v25 + 29) = 2;
                    id v27 = v25[9];
                    os_log_type_t v28 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
                    *((_BYTE *)v28 + 32) = *((_BYTE *)v28 + 32) & 0xFC | (v27 == 0LL) | 2;
                    id v29 = v26[31];
                    v26[31] = v28;

                    if (nw_endpoint_flow_pre_attach_protocols(v26, a3))
                    {
                      id v30 = v26;
LABEL_103:

LABEL_104:
                      os_log_type_t v67 = (void *)v109[18];
                      v109[18] = v30;

                      uint64_t v68 = *(void *)(v13 + 16);
                      if (v109[18])
                      {
                        if (v68 && !nw_path_parameters_get_logging_disabled(*(void *)(v68 + 104)))
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          __int16 v69 = (os_log_s *)(id)gconnectionLogObj;
                          if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
                          {
                            int v70 = *(_DWORD *)(v13 + 448);
                            logging_description = nw_endpoint_get_logging_description(v111);
                            *(_DWORD *)__int128 buf = 136446722;
                            os_log_type_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
                            __int16 v116 = 1024;
                            *(_DWORD *)uint64_t v117 = v70;
                            *(_WORD *)&v117[4] = 2082;
                            *(void *)&v117[6] = logging_description;
                            _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] create connection to %{public}s",  buf,  0x1Cu);
                          }
                        }

                        BOOL v59 = v109;
                        goto LABEL_121;
                      }

                      if (v68 && !nw_path_parameters_get_logging_disabled(*(void *)(v68 + 104)))
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        int v72 = (os_log_s *)(id)gconnectionLogObj;
                        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                        {
                          int v73 = *(_DWORD *)(v13 + 448);
                          *(_DWORD *)__int128 buf = 136446466;
                          os_log_type_t v115 = "nw_connection_create_from_protocol_on_nw_queue";
                          __int16 v116 = 1024;
                          *(_DWORD *)uint64_t v117 = v73;
                          _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Failed to create connection from listener",  buf,  0x12u);
                        }
                      }

void sub_181FB8A50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_get_connected_socket(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    int v19 = -1;
    *(void *)&buf[16] = 0x2020000000LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_get_connected_socket_block_invoke;
    v13[3] = &unk_189BC9210;
    uint64_t v14 = v1;
    uint64_t v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_get_connected_socket_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    uint64_t v3 = *(unsigned int *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_get_connected_socket";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_connected_socket";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_get_connected_socket";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_connected_socket";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_connected_socket";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_get_connected_socket_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    id v6 = nw_endpoint_handler_copy_connected_socket_wrapper(*(void **)(v2 + 144));
    if (!v6)
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v9 && !nw_path_parameters_get_logging_disabled(*(void *)(v9 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v49 = "nw_connection_get_connected_socket_block_invoke";
          __int16 v50 = 1024;
          int v51 = v11;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Connection has no connected socket",  buf,  0x12u);
        }
      }

      nw_parameters_t v4 = 0LL;
      goto LABEL_75;
    }

    nw_parameters_t v4 = (os_unfair_lock_s *)v6;
    os_unfair_lock_lock(v4 + 3);
    char os_unfair_lock_opaque = v4[6]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v4 + 3);

    os_log_type_t v8 = *(NWConcrete_nw_parameters **)(*(void *)(a1 + 32) + 16LL);
    if ((os_unfair_lock_opaque & 1) == 0)
    {
      if ((nw_parameters_get_allow_socket_access(v8) & 1) != 0)
      {
        v45[0] = MEMORY[0x1895F87A8];
        v45[1] = 3221225472LL;
        v45[2] = __nw_connection_get_connected_socket_block_invoke_12;
        v45[3] = &unk_189BC78E8;
        v45[4] = *(void *)(a1 + 40);
        nw_fd_wrapper_get_fd(v4, v45);
LABEL_75:

        return;
      }

      uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (!v21 || nw_path_parameters_get_logging_disabled(*(void *)(v21 + 104))) {
        goto LABEL_75;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v22 = (id)gconnectionLogObj;
      int v23 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v49 = "nw_connection_get_connected_socket_block_invoke";
      __int16 v50 = 1024;
      int v51 = v23;
      os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v46 = 0;
      if (__nwlog_fault(v12, &type, &v46))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v24 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            int v26 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v49 = "nw_connection_get_connected_socket_block_invoke";
            __int16 v50 = 1024;
            int v51 = v26;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s [C%u] parameters do not allow socket access",  buf,  0x12u);
          }
        }

        else if (v46)
        {
          backtrace_string = __nw_create_backtrace_string();
          if (backtrace_string)
          {
            os_log_type_t v33 = (char *)backtrace_string;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v34 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v35 = type;
            if (os_log_type_enabled(v34, type))
            {
              int v36 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
              *(_DWORD *)__int128 buf = 136446722;
              os_log_type_t v49 = "nw_connection_get_connected_socket_block_invoke";
              __int16 v50 = 1024;
              int v51 = v36;
              __int16 v52 = 2082;
              os_log_type_t v53 = v33;
              _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s [C%u] parameters do not allow socket access, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v33);
            if (!v12) {
              goto LABEL_75;
            }
            goto LABEL_74;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v24 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v43 = type;
          if (os_log_type_enabled(v24, type))
          {
            int v44 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v49 = "nw_connection_get_connected_socket_block_invoke";
            __int16 v50 = 1024;
            int v51 = v44;
            _os_log_impl( &dword_181A5C000,  v24,  v43,  "%{public}s [C%u] parameters do not allow socket access, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v24 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v41 = type;
          if (os_log_type_enabled(v24, type))
          {
            int v42 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v49 = "nw_connection_get_connected_socket_block_invoke";
            __int16 v50 = 1024;
            int v51 = v42;
            _os_log_impl( &dword_181A5C000,  v24,  v41,  "%{public}s [C%u] parameters do not allow socket access, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

void sub_181FB9770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_get_connected_socket_block_invoke_12(uint64_t a1, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  return 1LL;
}

const char *nw_connection_state_to_string(unsigned int a1)
{
  if (a1 > 5) {
    return "unknown";
  }
  else {
    return off_189BB9C00[a1];
  }
}

void nw_connection_restart(nw_connection_t connection)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = connection;
  uint64_t v2 = v1;
  if (v1)
  {
    if (!nw_parameters_get_logging_disabled(v1[2]))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v3 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        int v4 = *((_DWORD *)v2 + 112);
        logging_description = nw_endpoint_get_logging_description((void *)v2[1]);
        uint64_t v6 = v2[2];
        *(_DWORD *)__int128 buf = 67109634;
        *(_DWORD *)int v20 = v4;
        *(_WORD *)&v20[4] = 2082;
        *(void *)&v20[6] = logging_description;
        *(_WORD *)&v20[14] = 2114;
        *(void *)&v20[16] = v6;
        _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_DEFAULT, "[C%u %{public}s %{public}@] restart", buf, 0x1Cu);
      }
    }

    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_restart_block_invoke;
    v15[3] = &unk_189BC93A0;
    char v16 = v2;
    nw_connection_async_if_needed(v16, v15);

    goto LABEL_9;
  }

  __nwlog_obj();
  id v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)int v20 = "nw_connection_restart";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v8, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)int v20 = "nw_connection_restart";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)int v20 = "nw_connection_restart";
          *(_WORD *)&v20[8] = 2082;
          *(void *)&v20[10] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)int v20 = "nw_connection_restart";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)int v20 = "nw_connection_restart";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FB9B3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_restart_block_invoke(uint64_t a1)
{
  uint64_t v100 = *MEMORY[0x1895F89C0];
  id v1 = *(id *)(*(void *)(a1 + 32) + 144LL);
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (NWConcrete_nw_endpoint_handler *)v1;
    int v4 = v3;
    parameters = v3->parameters;
    if (parameters)
    {
      uint64_t v6 = parameters;
      uint64_t v7 = *((void *)v6 + 12);

      if ((v7 & 0x4000000000LL) != 0)
      {
        BOOL v57 = v4;
        char v58 = *((_BYTE *)v57 + 268);

        if ((v58 & 0x20) != 0) {
          goto LABEL_25;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v8 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          BOOL v59 = v57;

          os_log_type_t v60 = v59;
          char v61 = *((_BYTE *)v57 + 268);

          if ((v61 & 1) != 0) {
            os_log_type_t v62 = "dry-run ";
          }
          else {
            os_log_type_t v62 = "";
          }
          nw_endpoint_t v63 = nw_endpoint_handler_copy_endpoint(v60);
          logging_description = nw_endpoint_get_logging_description(v63);
          logc = v59 + 168;
          os_log_type_t v65 = v60;
          id v66 = v65;
          uint64_t v67 = v65[30];
          else {
            uint64_t v68 = off_189BBBBF0[v67];
          }
          os_log_type_t v79 = v68;

          int v72 = v66;
          int v73 = v72;
          id v74 = v2;
          os_log_type_t v75 = "path";
          switch(*((_DWORD *)v72 + 29))
          {
            case 0:
              break;
            case 1:
              os_log_type_t v75 = "resolver";
              break;
            case 2:
              os_log_type_t v75 = nw_endpoint_flow_mode_string(v72[31]);
              break;
            case 3:
              os_log_type_t v75 = "proxy";
              break;
            case 4:
              os_log_type_t v75 = "fallback";
              break;
            case 5:
              os_log_type_t v75 = "transform";
              break;
            default:
              os_log_type_t v75 = "unknown-mode";
              break;
          }

          BOOL v77 = v73;
          os_unfair_lock_lock((os_unfair_lock_t)v77 + 28);
          id v78 = v77[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v77 + 28);

          *(_DWORD *)__int128 buf = 136447746;
          v87 = "nw_endpoint_handler_restart";
          __int16 v88 = 2082;
          id_str = logc;
          __int16 v90 = 2082;
          os_log_type_t v91 = v62;
          __int16 v92 = 2082;
          int v93 = logging_description;
          __int16 v94 = 2082;
          BOOL v95 = v79;
          __int16 v96 = 2082;
          os_log_type_t v97 = v75;
          __int16 v98 = 2114;
          id v99 = v78;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);

          uint64_t v2 = v74;
        }

void sub_181FBA6C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_cancel_handler(void *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_set_cancel_handler_block_invoke;
    v15[3] = &unk_189BC91E8;
    int v5 = v3;
    void v15[4] = v5;
    id v6 = v4;
    void v15[5] = v6;
    os_unfair_lock_lock(v3 + 34);
    __nw_connection_set_cancel_handler_block_invoke((uint64_t)v15);
    os_unfair_lock_unlock(v3 + 34);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v19 = "nw_connection_set_cancel_handler";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      if (os_log_type_enabled(v9, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_cancel_handler";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      BOOL v13 = os_log_type_enabled(v9, v17);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v19 = "nw_connection_set_cancel_handler";
          __int16 v20 = 2082;
          id v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_cancel_handler";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v17;
      if (os_log_type_enabled(v9, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_cancel_handler";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_set_cancel_handler_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 216);
  *(void *)(v3 + 216) = v2;
}

void nw_connection_cancel_current_endpoint(nw_connection_t connection)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = connection;
  uint64_t v2 = v1;
  if (v1)
  {
    if (!nw_parameters_get_logging_disabled(v1[2]))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v3 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        int v4 = *((_DWORD *)v2 + 112);
        logging_description = nw_endpoint_get_logging_description((void *)v2[1]);
        uint64_t v6 = v2[2];
        *(_DWORD *)__int128 buf = 67109634;
        *(_DWORD *)__int16 v20 = v4;
        *(_WORD *)&v20[4] = 2082;
        *(void *)&v20[6] = logging_description;
        *(_WORD *)&v20[14] = 2114;
        *(void *)&v20[16] = v6;
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEFAULT,  "[C%u %{public}s %{public}@] cancel current endpoint",  buf,  0x1Cu);
      }
    }

    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_cancel_current_endpoint_block_invoke;
    v15[3] = &unk_189BC93A0;
    char v16 = v2;
    nw_connection_async_if_needed(v16, v15);

    goto LABEL_9;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)__int16 v20 = "nw_connection_cancel_current_endpoint";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v8, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)__int16 v20 = "nw_connection_cancel_current_endpoint";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)__int16 v20 = "nw_connection_cancel_current_endpoint";
          *(_WORD *)&v20[8] = 2082;
          *(void *)&v20[10] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)__int16 v20 = "nw_connection_cancel_current_endpoint";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)__int16 v20 = "nw_connection_cancel_current_endpoint";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FBAE54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_cancel_current_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v6 = nw_endpoint_handler_copy_connected_flow_handler(*(void **)(v2 + 144));
    if (v6)
    {
      int v4 = (os_log_s *)v6;
      nw_endpoint_handler_cancel(v6, 0LL, 1);
    }

    else
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v8 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          int v10 = 136446466;
          int v11 = "nw_connection_cancel_current_endpoint_block_invoke";
          __int16 v12 = 1024;
          int v13 = v9;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Connection had no connected handler, cannot cancel endpoint",  (uint8_t *)&v10,  0x12u);
        }
      }

      int v4 = 0LL;
    }

    goto LABEL_18;
  }

  uint64_t v3 = *(void *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v10 = 136446466;
      int v11 = "nw_connection_cancel_current_endpoint_block_invoke";
      __int16 v12 = 1024;
      int v13 = v5;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Connection is not ready, cannot cancel endpoint",  (uint8_t *)&v10,  0x12u);
    }

void sub_181FBB060(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_get_listener_protocol_on_nw_queue(void *a1, void *a2, int a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v35 = "nw_connection_get_listener_protocol_on_nw_queue";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v35 = "nw_connection_get_listener_protocol_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v35 = "nw_connection_get_listener_protocol_on_nw_queue";
          __int16 v36 = 2082;
          os_log_type_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_62:
        if (!v19)
        {
LABEL_19:
          uint64_t listener_protocol_on_nw_queue = 0LL;
          goto LABEL_20;
        }

void sub_181FBB6E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_connected_parameters_with_protocol(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    uint64_t v22 = __Block_byref_object_copy__24148;
    os_log_type_t v23 = __Block_byref_object_dispose__24149;
    id v24 = 0LL;
    v15[0] = MEMORY[0x1895F87A8];
    v15[2] = __nw_connection_copy_connected_parameters_with_protocol_block_invoke;
    v15[3] = &unk_189BBEEE8;
    v15[1] = 3221225472LL;
    char v16 = v3;
    uint64_t v18 = buf;
    id v17 = v4;
    os_unfair_lock_lock(v3 + 34);
    __nw_connection_copy_connected_parameters_with_protocol_block_invoke((uint64_t)v15);
    os_unfair_lock_unlock(v3 + 34);
    id v5 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_parameters_with_protocol";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_parameters_with_protocol";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_parameters_with_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_parameters_with_protocol";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_parameters_with_protocol";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_copy_connected_parameters_with_protocol_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    id v6 = nw_endpoint_handler_copy_connected_parameters_with_protocol(*(void **)(v2 + 144), *(void **)(a1 + 40));
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8LL);
    os_log_type_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v9 = 136446466;
        os_log_type_t v10 = "nw_connection_copy_connected_parameters_with_protocol_block_invoke";
        __int16 v11 = 1024;
        int v12 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Client called nw_connection_copy_connected_parameters_with_protocol on unconnected nw_connection",  (uint8_t *)&v9,  0x12u);
      }
    }
  }

id nw_connection_copy_protocol_metadata_on_queue(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    nw_context_assert_queue(*((void **)v3 + 3));
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    uint64_t v22 = __Block_byref_object_copy__24148;
    os_log_type_t v23 = __Block_byref_object_dispose__24149;
    id v24 = 0LL;
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_copy_protocol_metadata_on_queue_block_invoke;
    v15[3] = &unk_189BBEEE8;
    uint64_t v18 = buf;
    id v16 = v3;
    id v17 = v4;
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 34);
    __nw_connection_copy_protocol_metadata_on_queue_block_invoke((uint64_t)v15);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 34);
    id v5 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FBBF30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_copy_protocol_metadata_on_queue_block_invoke(uint64_t a1)
{
  id v2 = nw_connection_copy_protocol_metadata_locked(*(void *)(a1 + 32), *(void **)(a1 + 40), 1, 0);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

BOOL nw_connection_uses_sleep_proxy(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v19 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_uses_sleep_proxy_block_invoke;
    v13[3] = &unk_189BC9210;
    os_log_type_t v14 = v1;
    int v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_uses_sleep_proxy_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_uses_sleep_proxy";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_sleep_proxy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_uses_sleep_proxy";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_sleep_proxy";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_sleep_proxy";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_uses_sleep_proxy_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = nw_endpoint_handler_uses_sleep_proxy(*(void **)(v2 + 144));
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v6 = 136446466;
        uint64_t v7 = "nw_connection_uses_sleep_proxy_block_invoke";
        __int16 v8 = 1024;
        int v9 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Client called nw_connection_uses_sleep_proxy on unconnected nw_connection",  (uint8_t *)&v6,  0x12u);
      }
    }
  }

nw_path_t nw_connection_copy_current_path(nw_connection_t connection)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = connection;
  uint64_t v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    char v19 = __Block_byref_object_copy__24148;
    uint64_t v20 = __Block_byref_object_dispose__24149;
    id v21 = 0LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_copy_current_path_block_invoke;
    v13[3] = &unk_189BC9210;
    os_log_type_t v14 = v1;
    int v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_current_path_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    uint64_t v3 = (nw_path *)*(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_current_path";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_current_path";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_current_path";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_current_path";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_current_path";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_copy_current_path_block_invoke(uint64_t a1)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v10 = nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8LL);
    os_log_type_t v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    return;
  }

  uint64_t v3 = *(void **)(v2 + 152);
  if (v3)
  {
    id v4 = v3;
    int v5 = (os_unfair_lock_s *)(v4 + 112);
    os_unfair_lock_lock((os_unfair_lock_t)v4 + 28);
    if (*((_DWORD *)v4 + 29) != 2)
    {
      os_unfair_lock_unlock(v5);
      if ((v4[268] & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v19 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          if ((v4[268] & 1) != 0) {
            uint64_t v20 = "dry-run ";
          }
          else {
            uint64_t v20 = "";
          }
          nw_endpoint_t v21 = nw_endpoint_handler_copy_endpoint(v4);
          logging_description = nw_endpoint_get_logging_description(v21);
          uint64_t v23 = *((unsigned int *)v4 + 30);
          int v44 = logging_description;
          else {
            id v24 = off_189BBBBF0[v23];
          }
          os_log_type_t v43 = v24;
          os_log_type_t v28 = v4;
          BOOL v29 = v28;
          os_log_type_t v30 = "path";
          switch(*((_DWORD *)v4 + 29))
          {
            case 0:
              break;
            case 1:
              os_log_type_t v30 = "resolver";
              break;
            case 2:
              os_log_type_t v30 = nw_endpoint_flow_mode_string(v28[31]);
              break;
            case 3:
              os_log_type_t v30 = "proxy";
              break;
            case 4:
              os_log_type_t v30 = "fallback";
              break;
            case 5:
              os_log_type_t v30 = "transform";
              break;
            default:
              os_log_type_t v30 = "unknown-mode";
              break;
          }

          os_log_type_t v31 = v29;
          os_unfair_lock_lock(v5);
          id v32 = v31[8];
          os_unfair_lock_unlock(v5);

          *(_DWORD *)__int128 buf = 136447746;
          nw_endpoint_t v48 = "nw_endpoint_handler_copy_flow_path";
          __int16 v49 = 2082;
          __int16 v50 = v4 + 168;
          __int16 v51 = 2082;
          __int16 v52 = v20;
          __int16 v53 = 2082;
          __int16 v54 = v44;
          __int16 v55 = 2082;
          os_log_type_t v56 = v43;
          __int16 v57 = 2082;
          char v58 = v30;
          __int16 v59 = 2114;
          id v60 = v32;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is not flow",  buf,  0x48u);
        }
      }

      id v9 = 0LL;
      goto LABEL_39;
    }

    int v6 = (os_unfair_lock_s *)*((id *)v4 + 31);
    if (v6)
    {
      uint64_t v7 = (id *)v6;
      os_log_type_t v8 = v6 + 220;
      os_unfair_lock_lock(v6 + 220);
      id v9 = v7[2];
      os_unfair_lock_unlock(v8);

      if (v9)
      {
LABEL_7:
        os_unfair_lock_unlock(v5);
LABEL_39:

        uint64_t v33 = *(void *)(*(void *)(a1 + 40) + 8LL);
        os_log_type_t v34 = *(void **)(v33 + 40);
        *(void *)(v33 + 40) = v9;

        return;
      }

void sub_181FBCD84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_get_flow_id_on_nw_queue(void *a1, _OWORD *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (v3)
  {
    nw_context_assert_queue(v3[3]);
    uint64_t flow_id = nw_endpoint_handler_get_flow_id(v4[18], a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v18 = "nw_connection_get_flow_id_on_nw_queue";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_connection_get_flow_id_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v18 = "nw_connection_get_flow_id_on_nw_queue";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_connection_get_flow_id_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_connection_get_flow_id_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FBD06C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint32_t nw_connection_get_maximum_datagram_size(nw_connection_t connection)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = connection;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_path_t v3 = nw_connection_copy_current_path(v1);
    nw_path_t v4 = v3;
    if (v3) {
      maximum_datagram_unsigned int size = nw_path_get_maximum_datagram_size(v3);
    }
    else {
      maximum_datagram_unsigned int size = 1500;
    }

    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v18 = "nw_connection_get_maximum_datagram_size";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_connection_get_maximum_datagram_size";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v18 = "nw_connection_get_maximum_datagram_size";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_connection_get_maximum_datagram_size";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_connection_get_maximum_datagram_size";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FBD330(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_host_endpoint(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    __int16 v19 = __Block_byref_object_copy__24148;
    uint64_t v20 = __Block_byref_object_dispose__24149;
    id v21 = 0LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_copy_host_endpoint_block_invoke;
    v13[3] = &unk_189BC9210;
    os_log_type_t v14 = v1;
    char v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_host_endpoint_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_host_endpoint";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_host_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_host_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_host_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_host_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_copy_host_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (NWConcrete_nw_endpoint_handler *)*(id *)(*(void *)(a1 + 32) + 144LL);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v2)
  {
    nw_path_t v4 = v2;
    if ((*(_BYTE *)(v3 + 109) & 0x40) == 0
      || (int v5 = nw_endpoint_handler_copy_connected_flow_handler(v2), v4, (v4 = v5) != 0LL))
    {
      while (1)
      {
        int v6 = nw_endpoint_handler_copy_endpoint(v4);
        uint64_t v7 = v4;
        nw_path_t v4 = (NWConcrete_nw_endpoint_handler *)v7[9];

        if (!v4) {
          return;
        }
      }

      uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
      BOOL v11 = *(void **)(v10 + 40);
      *(void *)(v10 + 40) = v6;

      goto LABEL_14;
    }
  }

  else
  {
    uint64_t v8 = *(void *)(v3 + 16);
    if (v8 && !nw_path_parameters_get_logging_disabled(*(void *)(v8 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_path_t v4 = (NWConcrete_nw_endpoint_handler *)(id)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR))
      {
        int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v12 = 136446466;
        BOOL v13 = "nw_connection_copy_host_endpoint_block_invoke";
        __int16 v14 = 1024;
        int v15 = v9;
        _os_log_impl( &dword_181A5C000,  (os_log_t)v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Client error, called nw_connection_copy_host_endpoint on connection in wrong state",  (uint8_t *)&v12,  0x12u);
      }

void sub_181FBD81C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_add_extra_interface_option_block_invoke(uint64_t a1)
{
  uint64_t v144 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    v121 = nw_endpoint_handler_copy_connected_flow_handler(*(void **)(v2 + 144));
    if (!v121)
    {
LABEL_120:

      return;
    }

    int v6 = *(void **)(a1 + 40);
    uint64_t v7 = v121;
    id v8 = v6;
    int v9 = v7;
    uint64_t mode = v9->mode;

    BOOL v119 = v9;
    __int16 v120 = v8;
    if ((_DWORD)mode == 2)
    {
      if (v8)
      {
        BOOL v11 = &qword_18C45F000;
        if (nw_endpoint_handler_get_minimize_logging(v9))
        {
          if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) != 0)
          {
LABEL_55:
            os_log_type_t v43 = nw_endpoint_handler_copy_flow(v9);
            int v44 = (void *)*((void *)v43 + 104);
            if (v44)
            {
              nw_path_flow_registration_add_extra_interface_option(v44, v8);
              id v45 = (id)nw_path_flow_registration_copy_path(*((void **)v43 + 104));
              os_unfair_lock_lock((os_unfair_lock_t)v43 + 220);
              objc_storeStrong((id *)v43 + 2, v45);
              if ((*((_BYTE *)v43 + 33) & 4) != 0) {
                objc_storeStrong((id *)v43 + 1, v45);
              }
              os_unfair_lock_unlock((os_unfair_lock_t)v43 + 220);
              id v46 = (const char *)*((void *)v43 + 51);
              id v47 = *((id *)v43 + 2);
              if (v46 && (uint64_t v48 = *((void *)v46 + 3)) != 0)
              {
                if (*(void *)(v48 + 168)) {
                  BOOL v49 = v47 == 0LL;
                }
                else {
                  BOOL v49 = 1;
                }
                int v50 = !v49;

                if (v50)
                {
                  id v51 = *((id *)v43 + 2);
                  __int16 v52 = v51;
                  __int16 v53 = (void *)*((void *)v46 + 5);
                  if (v53 == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v67 = *((void *)v46 + 11);
                    if (v67) {
                      *((void *)v46 + 11) = v67 + 1;
                    }
                    char v54 = -1;
                  }

                  else
                  {
                    char v54 = 0;
                  }

                  *(void *)os_log_type_t type = v46;
                  char v127 = v54;
                  uint64_t v68 = (void *)*((void *)v43 + 52);
                  if (v68 == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v70 = *((void *)v43 + 58);
                    if (v70) {
                      *((void *)v43 + 5_Block_object_dispose(va, 8) = v70 + 1;
                    }
                    char v69 = -1;
                  }

                  else
                  {
                    char v69 = 0;
                  }

                  uint64_t v124 = (uint64_t)v43 + 376;
                  char v125 = v69;
                  if (v51)
                  {
                    uint64_t v71 = *((void *)v46 + 3);
                    if (v71)
                    {
                      int v72 = *(void (**)(const char *, char *, id))(v71 + 168);
                      if (v72)
                      {
                        v72(v46, (char *)v43 + 376, v51);
LABEL_91:
                        if (v68 == &nw_protocol_ref_counted_handle) {
                          nw::release_if_needed<nw_protocol *>(&v124);
                        }
                        if (v53 == &nw_protocol_ref_counted_handle) {
                          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                        }

                        goto LABEL_117;
                      }
                    }

                    __nwlog_obj();
                    BOOL v86 = (void *)objc_claimAutoreleasedReturnValue();
                    v87 = (const char *)*((void *)v46 + 2);
                    *(_DWORD *)__int128 buf = 136446722;
                    v129 = "__nw_protocol_updated_path";
                    if (!v87) {
                      v87 = "invalid";
                    }
                    __int16 v130 = 2082;
                    id_str = (char *)v87;
                    __int16 v132 = 2048;
                    int v133 = v46;
                    __int16 v88 = (char *)_os_log_send_and_compose_impl();

                    os_log_type_t v123 = OS_LOG_TYPE_ERROR;
                    char v122 = 0;
                    if (v123 == OS_LOG_TYPE_FAULT)
                    {
                      __nwlog_obj();
                      os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v90 = v123;
                      if (os_log_type_enabled(v89, v123))
                      {
                        os_log_type_t v91 = (const char *)*((void *)v46 + 2);
                        if (!v91) {
                          os_log_type_t v91 = "invalid";
                        }
                        *(_DWORD *)__int128 buf = 136446722;
                        v129 = "__nw_protocol_updated_path";
                        __int16 v130 = 2082;
                        id_str = (char *)v91;
                        __int16 v132 = 2048;
                        int v133 = v46;
                        _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback",  buf,  0x20u);
                      }
                    }

                    else
                    {
                      if (v122)
                      {
                        backtrace_string = (char *)__nw_create_backtrace_string();
                        __nwlog_obj();
                        BOOL v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v116 = v123;
                        BOOL v106 = os_log_type_enabled(v105, v123);
                        if (backtrace_string)
                        {
                          if (v106)
                          {
                            nw_endpoint_t v107 = (const char *)*((void *)v46 + 2);
                            if (!v107) {
                              nw_endpoint_t v107 = "invalid";
                            }
                            *(_DWORD *)__int128 buf = 136446978;
                            v129 = "__nw_protocol_updated_path";
                            __int16 v130 = 2082;
                            id_str = (char *)v107;
                            __int16 v132 = 2048;
                            int v133 = v46;
                            __int16 v134 = 2082;
                            id v135 = backtrace_string;
                            _os_log_impl( &dword_181A5C000,  v105,  v116,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                          }

                          free(backtrace_string);
                        }

                        else
                        {
                          if (v106)
                          {
                            os_log_type_t v114 = (const char *)*((void *)v46 + 2);
                            if (!v114) {
                              os_log_type_t v114 = "invalid";
                            }
                            *(_DWORD *)__int128 buf = 136446722;
                            v129 = "__nw_protocol_updated_path";
                            __int16 v130 = 2082;
                            id_str = (char *)v114;
                            __int16 v132 = 2048;
                            int v133 = v46;
                            _os_log_impl( &dword_181A5C000,  v105,  v116,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, no backtrace",  buf,  0x20u);
                          }
                        }

void sub_181FBECD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void __nw_connection_remove_extra_interface_option_block_invoke(uint64_t a1)
{
  uint64_t v152 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    v129 = nw_endpoint_handler_copy_connected_flow_handler(*(void **)(v2 + 144));
    if (!v129)
    {
LABEL_120:

      return;
    }

    int v6 = *(void **)(a1 + 40);
    uint64_t v7 = v129;
    id v8 = v6;
    int v9 = v7;
    uint64_t mode = v9->mode;

    if ((_DWORD)mode == 2)
    {
      if (v8)
      {
        id v128 = v8;
        BOOL v11 = nw_endpoint_handler_copy_flow(v9);
        uint64_t v12 = *((void *)v11 + 104);
        int minimize_logging = nw_endpoint_handler_get_minimize_logging(v9);
        if (!v12)
        {
          if (minimize_logging)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            BOOL v41 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
            {
              id_string = nw_endpoint_handler_get_id_string(v9);
              id v101 = nw_endpoint_handler_dry_run_string(v9);
              nw_endpoint_t v102 = nw_endpoint_handler_copy_endpoint(v9);
              logging_description = nw_endpoint_get_logging_description(v102);
              os_log_type_t v104 = nw_endpoint_handler_state_string(v9);
              BOOL v105 = nw_endpoint_handler_mode_string(v9);
              id v106 = nw_endpoint_handler_copy_current_path(v9);
              *(_DWORD *)__int128 buf = 136448002;
              os_log_type_t v137 = "nw_endpoint_handler_remove_extra_interface_option";
              __int16 v138 = 2082;
              v139 = (void *)id_string;
              __int16 v140 = 2082;
              id v141 = v101;
              __int16 v142 = 2082;
              id v143 = (void *)logging_description;
              __int16 v144 = 2082;
              __int16 v145 = v104;
              __int16 v146 = 2082;
              __int16 v147 = v105;
              __int16 v148 = 2114;
              id v149 = v106;
              __int16 v150 = 2112;
              id v151 = v128;
              _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping remove extra i nterface option %@, no active flow registration",  buf,  0x52u);
            }
          }

          else
          {
            os_log_type_t v39 = v9;
            char v40 = *((_BYTE *)v39 + 268);

            if ((v40 & 0x20) != 0)
            {
LABEL_118:

              os_log_type_t v28 = v128;
              goto LABEL_119;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            BOOL v41 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
            {
              id v42 = v39;

              os_log_type_t v43 = v42;
              char v44 = *((_BYTE *)v39 + 268);

              if ((v44 & 1) != 0) {
                id v45 = "dry-run ";
              }
              else {
                id v45 = "";
              }
              nw_endpoint_t v46 = nw_endpoint_handler_copy_endpoint(v43);
              id v47 = nw_endpoint_get_logging_description(v46);
              id_str = v42->id_str;
              BOOL v49 = v43;
              int v50 = v49;
              uint64_t v51 = v49[30];
              else {
                __int16 v52 = off_189BBBBF0[v51];
              }
              os_log_type_t v123 = v52;

              nw_endpoint_t v61 = v50;
              os_log_type_t v62 = v61;
              nw_endpoint_t v63 = "path";
              switch(v9->mode)
              {
                case 0:
                  break;
                case 1:
                  nw_endpoint_t v63 = "resolver";
                  break;
                case 2:
                  nw_endpoint_t v63 = nw_endpoint_flow_mode_string(v61[31]);
                  break;
                case 3:
                  nw_endpoint_t v63 = "proxy";
                  break;
                case 4:
                  nw_endpoint_t v63 = "fallback";
                  break;
                case 5:
                  nw_endpoint_t v63 = "transform";
                  break;
                default:
                  nw_endpoint_t v63 = "unknown-mode";
                  break;
              }

              nw_endpoint_t v81 = v62;
              os_unfair_lock_lock((os_unfair_lock_t)v81 + 28);
              id v82 = v81[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v81 + 28);

              *(_DWORD *)__int128 buf = 136448002;
              os_log_type_t v137 = "nw_endpoint_handler_remove_extra_interface_option";
              __int16 v138 = 2082;
              v139 = id_str;
              __int16 v140 = 2082;
              id v141 = v45;
              __int16 v142 = 2082;
              id v143 = (void *)v47;
              __int16 v144 = 2082;
              __int16 v145 = v123;
              __int16 v146 = 2082;
              __int16 v147 = v63;
              __int16 v148 = 2114;
              id v149 = v82;
              __int16 v150 = 2112;
              id v151 = v128;
              _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping remove extra i nterface option %@, no active flow registration",  buf,  0x52u);
            }
          }

          goto LABEL_117;
        }

        if (minimize_logging)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) != 0)
          {
LABEL_76:
            nw_path_flow_registration_remove_extra_interface_option(*((void **)v11 + 104), v8);
            BOOL v41 = (os_log_s *)nw_path_flow_registration_copy_path(*((void **)v11 + 104));
            os_unfair_lock_lock((os_unfair_lock_t)v11 + 220);
            objc_storeStrong((id *)v11 + 2, v41);
            if ((*((_BYTE *)v11 + 33) & 4) != 0) {
              objc_storeStrong((id *)v11 + 1, v41);
            }
            os_unfair_lock_unlock((os_unfair_lock_t)v11 + 220);
            id v66 = (const char *)*((void *)v11 + 51);
            id v67 = *((id *)v11 + 2);
            if (v66 && (uint64_t v68 = *((void *)v66 + 3)) != 0)
            {
              if (*(void *)(v68 + 168)) {
                BOOL v69 = v67 == 0LL;
              }
              else {
                BOOL v69 = 1;
              }
              int v70 = !v69;

              if (v70)
              {
                id v71 = *((id *)v11 + 2);
                int v72 = v71;
                int v73 = (void *)*((void *)v66 + 5);
                if (v73 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v75 = *((void *)v66 + 11);
                  if (v75) {
                    *((void *)v66 + 11) = v75 + 1;
                  }
                  char v74 = -1;
                }

                else
                {
                  char v74 = 0;
                }

                *(void *)os_log_type_t type = v66;
                char v135 = v74;
                id v76 = (void *)*((void *)v11 + 52);
                if (v76 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v78 = *((void *)v11 + 58);
                  if (v78) {
                    *((void *)v11 + 5_Block_object_dispose(va, 8) = v78 + 1;
                  }
                  char v77 = -1;
                }

                else
                {
                  char v77 = 0;
                }

                uint64_t v132 = (uint64_t)v11 + 376;
                char v133 = v77;
                if (v71)
                {
                  uint64_t v79 = *((void *)v66 + 3);
                  if (v79)
                  {
                    v80 = *(void (**)(const char *, char *, id))(v79 + 168);
                    if (v80)
                    {
                      v80(v66, (char *)v11 + 376, v71);
LABEL_101:
                      if (v76 == &nw_protocol_ref_counted_handle) {
                        nw::release_if_needed<nw_protocol *>(&v132);
                      }
                      if (v73 == &nw_protocol_ref_counted_handle) {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                      }

                      goto LABEL_117;
                    }
                  }

                  __nwlog_obj();
                  os_log_type_t v93 = (void *)objc_claimAutoreleasedReturnValue();
                  BOOL v94 = (const char *)*((void *)v66 + 2);
                  *(_DWORD *)__int128 buf = 136446722;
                  os_log_type_t v137 = "__nw_protocol_updated_path";
                  if (!v94) {
                    BOOL v94 = "invalid";
                  }
                  __int16 v138 = 2082;
                  v139 = (void *)v94;
                  __int16 v140 = 2048;
                  id v141 = v66;
                  uint64_t v126 = (void *)_os_log_send_and_compose_impl();

                  os_log_type_t v131 = OS_LOG_TYPE_ERROR;
                  char v130 = 0;
                  if (!__nwlog_fault((const char *)v126, &v131, &v130))
                  {
LABEL_195:
                    if (v126) {
                      free(v126);
                    }
                    goto LABEL_101;
                  }

                  if (v131 == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    BOOL v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v96 = v131;
                    if (os_log_type_enabled(v95, v131))
                    {
                      nw_endpoint_t v97 = (const char *)*((void *)v66 + 2);
                      if (!v97) {
                        nw_endpoint_t v97 = "invalid";
                      }
                      *(_DWORD *)__int128 buf = 136446722;
                      os_log_type_t v137 = "__nw_protocol_updated_path";
                      __int16 v138 = 2082;
                      v139 = (void *)v97;
                      __int16 v140 = 2048;
                      id v141 = v66;
                      _os_log_impl( &dword_181A5C000,  v95,  v96,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback",  buf,  0x20u);
                    }
                  }

                  else
                  {
                    if (v130)
                    {
                      backtrace_string = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      os_log_type_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v120 = v131;
                      BOOL v111 = os_log_type_enabled(v110, v131);
                      if (backtrace_string)
                      {
                        if (v111)
                        {
                          os_log_type_t v112 = (const char *)*((void *)v66 + 2);
                          if (!v112) {
                            os_log_type_t v112 = "invalid";
                          }
                          *(_DWORD *)__int128 buf = 136446978;
                          os_log_type_t v137 = "__nw_protocol_updated_path";
                          __int16 v138 = 2082;
                          v139 = (void *)v112;
                          __int16 v140 = 2048;
                          id v141 = v66;
                          __int16 v142 = 2082;
                          id v143 = backtrace_string;
                          _os_log_impl( &dword_181A5C000,  v110,  v120,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                        }

                        free(backtrace_string);
                      }

                      else
                      {
                        if (v111)
                        {
                          __int16 v118 = (const char *)*((void *)v66 + 2);
                          if (!v118) {
                            __int16 v118 = "invalid";
                          }
                          *(_DWORD *)__int128 buf = 136446722;
                          os_log_type_t v137 = "__nw_protocol_updated_path";
                          __int16 v138 = 2082;
                          v139 = (void *)v118;
                          __int16 v140 = 2048;
                          id v141 = v66;
                          _os_log_impl( &dword_181A5C000,  v110,  v120,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, no backtrace",  buf,  0x20u);
                        }
                      }

                      goto LABEL_195;
                    }

                    __nwlog_obj();
                    BOOL v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v116 = v131;
                    if (os_log_type_enabled(v95, v131))
                    {
                      uint64_t v117 = (const char *)*((void *)v66 + 2);
                      if (!v117) {
                        uint64_t v117 = "invalid";
                      }
                      *(_DWORD *)__int128 buf = 136446722;
                      os_log_type_t v137 = "__nw_protocol_updated_path";
                      __int16 v138 = 2082;
                      v139 = (void *)v117;
                      __int16 v140 = 2048;
                      id v141 = v66;
                      _os_log_impl( &dword_181A5C000,  v95,  v116,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded",  buf,  0x20u);
                    }
                  }
                }

                else
                {
                  __nwlog_obj();
                  nw_endpoint_t v107 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)__int128 buf = 136446210;
                  os_log_type_t v137 = "__nw_protocol_updated_path";
                  uint64_t v126 = (void *)_os_log_send_and_compose_impl();

                  os_log_type_t v131 = OS_LOG_TYPE_ERROR;
                  char v130 = 0;
                  if (v131 == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    BOOL v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v108 = v131;
                    if (os_log_type_enabled(v95, v131))
                    {
                      *(_DWORD *)__int128 buf = 136446210;
                      os_log_type_t v137 = "__nw_protocol_updated_path";
                      _os_log_impl(&dword_181A5C000, v95, v108, "%{public}s called with null path", buf, 0xCu);
                    }
                  }

                  else if (v130)
                  {
                    os_log_type_t v114 = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    BOOL v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v121 = v131;
                    BOOL v115 = os_log_type_enabled(v95, v131);
                    if (v114)
                    {
                      if (v115)
                      {
                        *(_DWORD *)__int128 buf = 136446466;
                        os_log_type_t v137 = "__nw_protocol_updated_path";
                        __int16 v138 = 2082;
                        v139 = v114;
                        _os_log_impl( &dword_181A5C000,  v95,  v121,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
                      }

                      free(v114);
                      goto LABEL_195;
                    }

                    if (v115)
                    {
                      *(_DWORD *)__int128 buf = 136446210;
                      os_log_type_t v137 = "__nw_protocol_updated_path";
                      _os_log_impl( &dword_181A5C000,  v95,  v121,  "%{public}s called with null path, no backtrace",  buf,  0xCu);
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    BOOL v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v119 = v131;
                    if (os_log_type_enabled(v95, v131))
                    {
                      *(_DWORD *)__int128 buf = 136446210;
                      os_log_type_t v137 = "__nw_protocol_updated_path";
                      _os_log_impl( &dword_181A5C000,  v95,  v119,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
                    }
                  }
                }

                goto LABEL_195;
              }
            }

            else
            {
            }

void sub_181FC024C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void nw_connection_remove_all_interface_options(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 2);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_path_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = v2[112];
        *(_DWORD *)__int128 buf = 136446466;
        char v19 = "nw_connection_remove_all_interface_options";
        __int16 v20 = 1024;
        LODWORD(v21) = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Removing paths from connection",  buf,  0x12u);
      }
    }

    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_connection_remove_all_interface_options_block_invoke;
    v14[3] = &unk_189BC93A0;
    char v15 = v2;
    nw_connection_async_if_needed(v15, v14);

    goto LABEL_10;
  }

  __nwlog_obj();
  int v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v19 = "nw_connection_remove_all_interface_options";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v19 = "nw_connection_remove_all_interface_options";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v19 = "nw_connection_remove_all_interface_options";
          __int16 v20 = 2082;
          nw_endpoint_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v19 = "nw_connection_remove_all_interface_options";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v19 = "nw_connection_remove_all_interface_options";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FC06A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_connection_remove_all_interface_options_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v1 + 109) & 0x40) != 0)
  {
    nw_endpoint_handler_remove_all_interface_options(*(void **)(v1 + 144));
  }

  else
  {
    uint64_t v2 = *(void *)(v1 + 16);
    if (v2 && !nw_path_parameters_get_logging_disabled(*(void *)(v2 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_path_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v6 = 136446466;
        uint64_t v7 = "nw_connection_remove_all_interface_options_block_invoke";
        __int16 v8 = 1024;
        int v9 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Connection is not ready, ignore",  (uint8_t *)&v6,  0x12u);
      }
    }
  }

void nw_connection_set_interface_use_callback(void *a1, void *a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v35 = "nw_connection_set_interface_use_callback";
    char v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v15, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v35 = "nw_connection_set_interface_use_callback";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v35 = "nw_connection_set_interface_use_callback";
            __int16 v36 = 2082;
            BOOL v37 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v24)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v35 = "nw_connection_set_interface_use_callback";
          _os_log_impl(&dword_181A5C000, v16, v23, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v35 = "nw_connection_set_interface_use_callback";
          _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void __nw_connection_set_interface_use_callback_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v4 = a2;
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v5 && !nw_path_parameters_get_logging_disabled(*(void *)(v5 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v6 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v7 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      __int16 v8 = v4 + 104;
      if (!v4) {
        __int16 v8 = "(null)";
      }
      int v19 = 136446722;
      __int16 v20 = "nw_connection_set_interface_use_callback_block_invoke";
      __int16 v21 = 1024;
      int v22 = v7;
      __int16 v23 = 2080;
      BOOL v24 = v8;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Got migration callback interface %s",  (uint8_t *)&v19,  0x1Cu);
    }
  }

  BOOL v9 = nw_interface_shallow_compare(v4, *(void **)(*(void *)(a1 + 32) + 520LL));
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v9)
  {
    if (v10 && !nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v11 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v19 = 136446466;
        __int16 v20 = "nw_connection_set_interface_use_callback_block_invoke";
        __int16 v21 = 1024;
        int v22 = v12;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] No change in AWDL usage",  (uint8_t *)&v19,  0x12u);
      }
    }
  }

  else
  {
    if (v10 && !nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v13 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        uint64_t v14 = *(void *)(a1 + 32);
        int v15 = *(_DWORD *)(v14 + 448);
        uint64_t v16 = *(void *)(v14 + 520);
        if (v16) {
          os_log_type_t v17 = (const char *)(v16 + 104);
        }
        else {
          os_log_type_t v17 = "(null)";
        }
        uint64_t v18 = v4 + 104;
        if (!v4) {
          uint64_t v18 = "(null)";
        }
        int v19 = 136446978;
        __int16 v20 = "nw_connection_set_interface_use_callback_block_invoke";
        __int16 v21 = 1024;
        int v22 = v15;
        __int16 v23 = 2080;
        BOOL v24 = v17;
        __int16 v25 = 2080;
        os_log_type_t v26 = v18;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Changed from %s to %s",  (uint8_t *)&v19,  0x26u);
      }
    }

    (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 512LL) + 16LL))();
    objc_storeStrong((id *)(*(void *)(a1 + 32) + 520LL), a2);
    *(_BYTE *)(*(void *)(a1 + 32) + 109LL) |= 0x80u;
  }
}

void sub_181FC10F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_internet_fallback_endpoint(void *a1, void *a2)
{
  *(void *)&v25[13] = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    uint64_t v5 = *((void *)v3 + 2);
    if (v5 && !nw_path_parameters_get_logging_disabled(*(void *)(v5 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v6 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        int v7 = *((_DWORD *)v3 + 112);
        *(_DWORD *)__int128 buf = 136446722;
        __int16 v23 = "nw_connection_set_internet_fallback_endpoint";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = v7;
        v25[2] = 2112;
        *(void *)&v25[3] = v4;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Setting internet fallback endpoint %@",  buf,  0x1Cu);
      }
    }

    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    v17[2] = __nw_connection_set_internet_fallback_endpoint_block_invoke;
    v17[3] = &unk_189BC9238;
    id v18 = v3;
    id v8 = v4;
    id v19 = v8;
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 34);
    __nw_connection_set_internet_fallback_endpoint_block_invoke((uint64_t)v17);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 34);

    goto LABEL_10;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v23 = "nw_connection_set_internet_fallback_endpoint";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v10, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v23 = "nw_connection_set_internet_fallback_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v23 = "nw_connection_set_internet_fallback_endpoint";
          __int16 v24 = 2082;
          *(void *)__int16 v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v23 = "nw_connection_set_internet_fallback_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v23 = "nw_connection_set_internet_fallback_endpoint";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_set_internet_fallback_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  BOOL local_only = nw_parameters_get_local_only(*(nw_parameters_t *)(*(void *)(a1 + 32) + 16LL));
  id v3 = *(uint64_t **)(*(void *)(a1 + 32) + 16LL);
  if (local_only)
  {
    if (!v3 || nw_path_parameters_get_logging_disabled(v3[13])) {
      return;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v4 = (id)gconnectionLogObj;
    int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    *(_DWORD *)__int128 buf = 136446466;
    id v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
    __int16 v46 = 1024;
    int v47 = v5;
    int v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v6, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v7 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          id v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
          __int16 v46 = 1024;
          int v47 = v9;
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s [C%u] Connection is local only", buf, 0x12u);
        }

void nw_connection_reset_traffic_class(void *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_reset_traffic_class_block_invoke;
    v13[3] = &unk_189BC76E8;
    id v14 = v3;
    int v15 = a2;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  id v19 = "nw_connection_reset_traffic_class";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_connection_reset_traffic_class";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v19 = "nw_connection_reset_traffic_class";
          __int16 v20 = 2082;
          __int16 v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_connection_reset_traffic_class";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_connection_reset_traffic_class";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FC20C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_connection_reset_traffic_class_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    nw_endpoint_handler_reset_traffic_class(*(void **)(v2 + 144), *(_DWORD *)(a1 + 40));
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v6 = 136446466;
        int v7 = "nw_connection_reset_traffic_class_block_invoke";
        __int16 v8 = 1024;
        int v9 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Connection is not ready, ignore",  (uint8_t *)&v6,  0x12u);
      }
    }
  }

void nw_connection_reset_expected_progress_target(void *a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_reset_expected_progress_target_block_invoke;
    v13[3] = &unk_189BC66E8;
    id v14 = v3;
    uint64_t v15 = a2;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  id v19 = "nw_connection_reset_expected_progress_target";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_connection_reset_expected_progress_target";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v19 = "nw_connection_reset_expected_progress_target";
          __int16 v20 = 2082;
          __int16 v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_connection_reset_expected_progress_target";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_connection_reset_expected_progress_target";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FC24EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void __nw_connection_reset_expected_progress_target_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(os_unfair_lock_s **)(a1 + 32);
  id v3 = v2 + 34;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __nw_connection_reset_expected_progress_target_block_invoke_2;
  v6[3] = &unk_189BC66E8;
  int v5 = v2;
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[4] = v5;
  v6[5] = v4;
  os_unfair_lock_lock(v3);
  __nw_connection_reset_expected_progress_target_block_invoke_2((uint64_t)v6);
  os_unfair_lock_unlock(v3);
}

void __nw_connection_reset_expected_progress_target_block_invoke_2(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 80) == 3 && (*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    *(void *)(v2 + 28_Block_object_dispose(va, 8) = 0LL;
    nw_endpoint_handler_reset_expected_progress_target( *(void **)(*(void *)(a1 + 32) + 144LL),  *(void *)(a1 + 40),  (const unsigned __int8 *)(*(void *)(a1 + 32) + 452LL));
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v6 = 136446466;
        int v7 = "nw_connection_reset_expected_progress_target_block_invoke_2";
        __int16 v8 = 1024;
        int v9 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Connection is not ready, pending progress target",  (uint8_t *)&v6,  0x12u);
      }
    }

    *(void *)(*(void *)(a1 + 32) + 288LL) = *(void *)(a1 + 40);
    nw_endpoint_handler_reset_expected_progress_target( *(void **)(*(void *)(a1 + 32) + 144LL),  *(void *)(a1 + 40),  (const unsigned __int8 *)(*(void *)(a1 + 32) + 452LL));
  }

void nw_connection_decrement_estimated_bytes(void *a1, char a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  int v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    int v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v24 = "nw_connection_decrement_estimated_bytes";
    __int16 v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v24 = "nw_connection_decrement_estimated_bytes";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v24 = "nw_connection_decrement_estimated_bytes";
          __int16 v25 = 2082;
          int v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v24 = "nw_connection_decrement_estimated_bytes";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v24 = "nw_connection_decrement_estimated_bytes";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FC2BB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_inject_up(void *a1, int a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  int v6 = v5;
  if (v5)
  {
    if (a3)
    {
      __int128 v7 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)__int128 buf = *(_OWORD *)a3;
      *(_OWORD *)&buf[16] = v7;
      uint64_t v8 = *(void *)(a3 + 32);
    }

    else
    {
      uint64_t v8 = 0LL;
      memset(buf, 0, 32);
    }

    v19[1] = 3221225472LL;
    __int128 v21 = *(_OWORD *)buf;
    __int128 v22 = *(_OWORD *)&buf[16];
    v19[0] = MEMORY[0x1895F87A8];
    v19[2] = __nw_connection_inject_up_block_invoke;
    v19[3] = &unk_189BB9888;
    BOOL v25 = a3 != 0;
    uint64_t v23 = v8;
    int v24 = a2;
    id v20 = v5;
    nw_connection_async_if_needed(v20, v19);

    goto LABEL_6;
  }

  __nwlog_obj();
  int v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_inject_up";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_inject_up";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_inject_up";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_inject_up";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_inject_up";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FC2ECC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void __nw_connection_inject_up_block_invoke(uint64_t a1)
{
  uint64_t v108 = *MEMORY[0x1895F89C0];
  int v2 = *(unsigned __int8 *)(a1 + 84);
  if (*(_BYTE *)(a1 + 84)) {
    uint64_t v3 = (void *)(a1 + 40);
  }
  else {
    uint64_t v3 = 0LL;
  }
  int v4 = *(_DWORD *)(a1 + 80);
  if (v4 == 3)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    char v11 = *(_BYTE *)(v10 + 109);
    uint64_t v12 = *(void *)(v10 + 16);
    if ((v11 & 0x40) != 0)
    {
      if (v12 && !nw_path_parameters_get_logging_disabled(*(void *)(v12 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v55 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
        {
          int v56 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          nw_endpoint_t v97 = "nw_connection_inject_up_block_invoke";
          __int16 v98 = 1024;
          *(_DWORD *)os_log_type_t v99 = v56;
          _os_log_impl(&dword_181A5C000, v55, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] injecting timed out", buf, 0x12u);
        }
      }

      nw_endpoint_handler_inject_disconnect_error(*(void **)(*(void *)(a1 + 32) + 144LL), v3, 60LL);
    }

    else if (v12 && !nw_path_parameters_get_logging_disabled(*(void *)(v12 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v13 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)__int128 buf = 136446466;
        nw_endpoint_t v97 = "nw_connection_inject_up_block_invoke";
        __int16 v98 = 1024;
        *(_DWORD *)os_log_type_t v99 = v13;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] timed out failed, not connected",  buf,  0x12u);
      }

      goto LABEL_30;
    }

    return;
  }

  if (v4 != 2)
  {
    if (v4 == 1)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      char v6 = *(_BYTE *)(v5 + 109);
      uint64_t v7 = *(void *)(v5 + 16);
      if ((v6 & 0x40) == 0)
      {
        if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v8 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)__int128 buf = 136446466;
            nw_endpoint_t v97 = "nw_connection_inject_up_block_invoke";
            __int16 v98 = 1024;
            *(_DWORD *)os_log_type_t v99 = v9;
            _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] read close failed, not connected",  buf,  0x12u);
          }

void sub_181FC4070( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_read_multiple(void *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  id v8 = a4;
  int v9 = v8;
  if (v7)
  {
    if (v8)
    {
      *(void *)id v63 = 0LL;
      *(void *)&v63[8] = v63;
      *(void *)&v63[16] = 0x2020000000LL;
      char v64 = 1;
      uint64_t v10 = MEMORY[0x1895F87A8];
      v55[0] = MEMORY[0x1895F87A8];
      v55[1] = 3221225472LL;
      v55[2] = __nw_connection_read_multiple_block_invoke;
      v55[3] = &unk_189BC9210;
      int v57 = v63;
      char v11 = v7;
      int v56 = v11;
      os_unfair_lock_lock(v7 + 34);
      __nw_connection_read_multiple_block_invoke((uint64_t)v55);
      os_unfair_lock_unlock(v7 + 34);
      if (*(_BYTE *)(*(void *)&v63[8] + 24LL))
      {
        v52[0] = v10;
        v52[1] = 3221225472LL;
        v52[2] = __nw_connection_read_multiple_block_invoke_29;
        v52[3] = &unk_189BB98B0;
        id v53 = v9;
        multiple = nw_read_request_create_multiple(a2, a3, v11, v52);
        BOOL v13 = multiple != 0LL;
        if (multiple)
        {
          nw_connection_add_read_request(v11, multiple);
LABEL_57:

          goto LABEL_58;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = (id)gLogObj;
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v60 = "nw_connection_read_multiple";
        os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (__nwlog_fault(v22, &type, &v54))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v23 = (os_log_s *)(id)gLogObj;
            os_log_type_t v24 = type;
            if (os_log_type_enabled(v23, type))
            {
              *(_DWORD *)__int128 buf = 136446210;
              os_log_type_t v60 = "nw_connection_read_multiple";
              _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s nw_read_request_create_multiple failed", buf, 0xCu);
            }
          }

          else if (v54)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v23 = (os_log_s *)(id)gLogObj;
            os_log_type_t v31 = type;
            BOOL v32 = os_log_type_enabled(v23, type);
            if (backtrace_string)
            {
              if (v32)
              {
                *(_DWORD *)__int128 buf = 136446466;
                os_log_type_t v60 = "nw_connection_read_multiple";
                __int16 v61 = 2082;
                v62[0] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v23,  v31,  "%{public}s nw_read_request_create_multiple failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
              if (!v22) {
                goto LABEL_57;
              }
              goto LABEL_56;
            }

            if (v32)
            {
              *(_DWORD *)__int128 buf = 136446210;
              os_log_type_t v60 = "nw_connection_read_multiple";
              _os_log_impl( &dword_181A5C000,  v23,  v31,  "%{public}s nw_read_request_create_multiple failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v23 = (os_log_s *)(id)gLogObj;
            os_log_type_t v35 = type;
            if (os_log_type_enabled(v23, type))
            {
              *(_DWORD *)__int128 buf = 136446210;
              os_log_type_t v60 = "nw_connection_read_multiple";
              _os_log_impl( &dword_181A5C000,  v23,  v35,  "%{public}s nw_read_request_create_multiple failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v22) {
          goto LABEL_57;
        }
LABEL_56:
        free(v22);
        goto LABEL_57;
      }

      uint64_t v14 = *(void *)&v11[4]._os_unfair_lock_opaque;
      if (v14 && !nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v15 = (id)gconnectionLogObj;
        uint32_t os_unfair_lock_opaque = v11[112]._os_unfair_lock_opaque;
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v60 = "nw_connection_read_multiple";
        __int16 v61 = 1024;
        LODWORD(v62[0]) = os_unfair_lock_opaque;
        int v17 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (__nwlog_fault(v17, &type, &v54))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v18 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v19 = type;
            if (os_log_type_enabled(v18, type))
            {
              uint32_t v20 = v11[112]._os_unfair_lock_opaque;
              *(_DWORD *)__int128 buf = 136446466;
              os_log_type_t v60 = "nw_connection_read_multiple";
              __int16 v61 = 1024;
              LODWORD(v62[0]) = v20;
              _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s [C%u] client_queue is nil", buf, 0x12u);
            }
          }

          else if (v54)
          {
            int v25 = __nw_create_backtrace_string();
            if (v25)
            {
              id v26 = (char *)v25;
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v27 = (os_log_s *)(id)gconnectionLogObj;
              os_log_type_t v28 = type;
              if (os_log_type_enabled(v27, type))
              {
                uint32_t v29 = v11[112]._os_unfair_lock_opaque;
                *(_DWORD *)__int128 buf = 136446722;
                os_log_type_t v60 = "nw_connection_read_multiple";
                __int16 v61 = 1024;
                LODWORD(v62[0]) = v29;
                WORD2(v62[0]) = 2082;
                *(void *)((char *)v62 + 6) = v26;
                _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s [C%u] client_queue is nil, dumping backtrace:%{public}s",  buf,  0x1Cu);
              }

              free(v26);
              if (!v17) {
                goto LABEL_51;
              }
              goto LABEL_50;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v18 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v36 = type;
            if (os_log_type_enabled(v18, type))
            {
              uint32_t v37 = v11[112]._os_unfair_lock_opaque;
              *(_DWORD *)__int128 buf = 136446466;
              os_log_type_t v60 = "nw_connection_read_multiple";
              __int16 v61 = 1024;
              LODWORD(v62[0]) = v37;
              _os_log_impl(&dword_181A5C000, v18, v36, "%{public}s [C%u] client_queue is nil, no backtrace", buf, 0x12u);
            }
          }

          else
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v18 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v33 = type;
            if (os_log_type_enabled(v18, type))
            {
              uint32_t v34 = v11[112]._os_unfair_lock_opaque;
              *(_DWORD *)__int128 buf = 136446466;
              os_log_type_t v60 = "nw_connection_read_multiple";
              __int16 v61 = 1024;
              LODWORD(v62[0]) = v34;
              _os_log_impl( &dword_181A5C000,  v18,  v33,  "%{public}s [C%u] client_queue is nil, backtrace limit exceeded",  buf,  0x12u);
            }
          }
        }

        if (v17) {
LABEL_50:
        }
          free(v17);
      }

void sub_181FC4C0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24)
{
  _Block_object_dispose((const void *)(v27 - 144), 8);
  _Unwind_Resume(a1);
}

BOOL __nw_connection_read_multiple_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 200)) {
    BOOL result = 1LL;
  }
  else {
    BOOL result = nw_context_is_inline(*(void **)(v2 + 24));
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

void __nw_connection_read_multiple_block_invoke_29(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v6 = a5;
  id v7 = v6;
  if (v6) {

  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_181FC4D04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_connection_add_read_request(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v16 = 0LL;
  int v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  char v19 = 1;
  uint64_t v5 = v3 + 34;
  uint64_t v6 = MEMORY[0x1895F87A8];
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  v12[2] = ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke;
  v12[3] = &unk_189BBEEE8;
  id v7 = v3;
  BOOL v13 = v7;
  id v8 = v4;
  id v14 = v8;
  id v15 = &v16;
  os_unfair_lock_lock(v5);
  ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke((uint64_t)v12);
  os_unfair_lock_unlock(v5);
  if (*((_BYTE *)v17 + 24))
  {
    v9[0] = v6;
    v9[1] = 3221225472LL;
    v9[2] = ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke_2;
    v9[3] = &unk_189BC9238;
    uint64_t v10 = v7;
    id v11 = v8;
    nw_connection_async_if_needed(v10, v9);
  }

  _Block_object_dispose(&v16, 8);
}

void sub_181FC4E60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21)
{
  _Block_object_dispose((const void *)(v23 - 96), 8);
  _Unwind_Resume(a1);
}

void ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v1 + 109) & 0x20) != 0)
  {
    BOOL request_list_append = nw_read_request_list_append(*(void **)(v1 + 120), *(void **)(a1 + 40));
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void **)(v4 + 120);
    *(void *)(v4 + 120) = request_list_append;

    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
  }

void ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke_2( uint64_t a1)
{
}

void nw_connection_add_read_request_on_queue(void *a1, void *a2, int a3)
{
  id v5 = a1;
  id v6 = a2;
  nw_context_assert_queue(*((void **)v5 + 3));
  uint64_t v12 = 0LL;
  BOOL v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  char v15 = 0;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  v9[2] = ___ZL39nw_connection_add_read_request_on_queueP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObjectb_block_invoke;
  v9[3] = &unk_189BC9210;
  id v11 = &v12;
  id v7 = (void **)v5;
  uint64_t v10 = v7;
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 34);
  ___ZL39nw_connection_add_read_request_on_queueP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObjectb_block_invoke((uint64_t)v9);
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 34);
  if (*((_BYTE *)v13 + 24))
  {
    int v8 = 89;
LABEL_8:
    nw_read_request_fail(v6, v8);
    goto LABEL_9;
  }

  if (!nw_endpoint_handler_add_read_request(v7[18], v6))
  {
    int v8 = 57;
    goto LABEL_8;
  }

  if (a3 && (*((_BYTE *)v7 + 109) & 0x40) != 0) {
    nw_endpoint_handler_service_reads(v7[18]);
  }
LABEL_9:

  _Block_object_dispose(&v12, 8);
}

void sub_181FC5024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL39nw_connection_add_read_request_on_queueP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObjectb_block_invoke( uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = (*(_BYTE *)(*(void *)(result + 32) + 109LL) & 8) != 0;
  return result;
}

uint64_t nw_connection_read_buffer(void *a1, char *a2, unint64_t a3, unint64_t a4, void *a5)
{
  uint64_t v99 = *MEMORY[0x1895F89C0];
  uint64_t v10 = a1;
  id v11 = a5;
  uint64_t v12 = v11;
  if (v10)
  {
    if (v11)
    {
      *(void *)v87 = 0LL;
      os_log_type_t v88 = v87;
      uint64_t v89 = 0x2020000000LL;
      char v90 = 1;
      v84[0] = MEMORY[0x1895F87A8];
      v84[1] = 3221225472LL;
      v84[2] = __nw_connection_read_buffer_block_invoke;
      v84[3] = &unk_189BC9210;
      os_log_type_t v86 = v87;
      BOOL v13 = v10;
      id v85 = v13;
      os_unfair_lock_lock(v10 + 34);
      __nw_connection_read_buffer_block_invoke((uint64_t)v84);
      os_unfair_lock_unlock(v10 + 34);
      if (*((_BYTE *)v88 + 24))
      {
        uint64_t v14 = v13;
        id v15 = v12;
        if (a2)
        {
          if (a3 <= 1) {
            unint64_t v16 = 1LL;
          }
          else {
            unint64_t v16 = a3;
          }
          if (v16 > a4)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v17 = (id)gLogObj;
            *(_DWORD *)__int128 buf = 136446722;
            char v94 = "nw_read_request_create_with_buffer";
            __int16 v95 = 2048;
            *(void *)os_log_type_t v96 = v16;
            *(_WORD *)&v96[8] = 2048;
            *(void *)&v96[10] = a4;
            uint64_t v18 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v91 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v19 = (os_log_s *)(id)gLogObj;
              os_log_type_t v20 = type;
              if (os_log_type_enabled(v19, type))
              {
                *(_DWORD *)__int128 buf = 136446722;
                char v94 = "nw_read_request_create_with_buffer";
                __int16 v95 = 2048;
                *(void *)os_log_type_t v96 = v16;
                *(_WORD *)&v96[8] = 2048;
                *(void *)&v96[10] = a4;
                _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s minlength (%zu) > max_data_count (%zu)",  buf,  0x20u);
              }

void sub_181FC63AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __nw_connection_read_buffer_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 200)) {
    BOOL result = 1LL;
  }
  else {
    BOOL result = nw_context_is_inline(*(void **)(v2 + 24));
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

void nw_connection_receive_multiple(void *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a4;
  int v9 = v8;
  if (!v7)
  {
    __nwlog_obj();
    id v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v39 = "nw_connection_receive_multiple";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v37 = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (v37 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v37;
      if (os_log_type_enabled(v19, v37))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v39 = "nw_connection_receive_multiple";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v37;
      BOOL v25 = os_log_type_enabled(v19, v37);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v39 = "nw_connection_receive_multiple";
          __int16 v40 = 2082;
          BOOL v41 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v18) {
          goto LABEL_7;
        }
LABEL_42:
        free(v18);
        goto LABEL_7;
      }

      if (v25)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v39 = "nw_connection_receive_multiple";
        _os_log_impl(&dword_181A5C000, v19, v24, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = v37;
      if (os_log_type_enabled(v19, v37))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v39 = "nw_connection_receive_multiple";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FC69D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

void __nw_connection_receive_multiple_block_invoke(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  LODWORD(v5) = a4;
  id v10 = a5;
  if ((_DWORD)v5)
  {
    uint64_t v9 = (v5 - 1);
    uint64_t v5 = v5;
    do
    {
      (*(void (**)(void, void, void, BOOL, id))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *a2++,  *a3++,  v9-- == 0,  v10);
      --v5;
    }

    while (v5);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
}

void sub_181FC6AD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_connection_receive_multiple_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, uint64_t, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  0LL,  0LL,  1LL,  *(void *)(a1 + 32));
}

void nw_connection_receive_file_at_path_with_progress( void *a1, const char *a2, unint64_t a3, void *a4)
{
  uint64_t v75 = *MEMORY[0x1895F89C0];
  id v8 = a1;
  id v9 = a4;
  id v10 = v9;
  if (!v8)
  {
    __nwlog_obj();
    BOOL v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    v64[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v64[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = v64[0];
      if (os_log_type_enabled(v45, v64[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
        _os_log_impl(&dword_181A5C000, v45, v46, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v50 = v64[0];
      BOOL v51 = os_log_type_enabled(v45, v64[0]);
      if (backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v45,  v50,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_83:
        if (!v44) {
          goto LABEL_44;
        }
LABEL_84:
        free(v44);
        goto LABEL_44;
      }

      if (v51)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
        _os_log_impl(&dword_181A5C000, v45, v50, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = v64[0];
      if (os_log_type_enabled(v45, v64[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
        _os_log_impl( &dword_181A5C000,  v45,  v57,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FC7660( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, id a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, id a35, id a36)
{
  _Block_object_dispose(&a24, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_receive_file_at_path_with_progress_block_invoke(uint64_t a1, int a2)
{
  if (fstat(a2, &v7) == -1)
  {
    posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
    goto LABEL_5;
  }

  if ((v7.st_mode & 0xF000) != 0x8000)
  {
    posix_error = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 9);
LABEL_5:
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = posix_error;
  }

  return 1LL;
}

uint64_t ___ZL35nw_connection_receive_file_internalP24NWConcrete_nw_connectionPU27objcproto16OS_nw_fd_wrapper8NSObjectmU13block_pointerFbmPU32objcproto21OS_nw_content_contextS1_bPU22objcproto11OS_nw_errorS1_E_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  0LL,  0LL,  0LL,  *(void *)(a1 + 32));
}

uint64_t __nw_connection_receive_file_at_path_with_progress_block_invoke_31(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  0LL,  0LL,  0LL,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
}

void nw_connection_receive_internal(void *a1, void *a2, unsigned int a3, unsigned int a4, void *a5)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  id v9 = a1;
  id v10 = a2;
  id v11 = a5;
  id v12 = v11;
  if (!v9)
  {
    __nwlog_obj();
    id v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v37 = "nw_connection_receive_internal";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v37 = "nw_connection_receive_internal";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v37 = "nw_connection_receive_internal";
          __int16 v38 = 2082;
          uint64_t v39 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v18) {
          goto LABEL_7;
        }
LABEL_42:
        free(v18);
        goto LABEL_7;
      }

      if (v25)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v37 = "nw_connection_receive_internal";
        _os_log_impl(&dword_181A5C000, v19, v24, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v37 = "nw_connection_receive_internal";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FC7D68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL30nw_connection_receive_internalP24NWConcrete_nw_connectionPU32objcproto21OS_nw_content_context8NSObjectjjU13block_pointerFvPU27objcproto16OS_dispatch_dataS1_S3_bPU22objcproto11OS_nw_errorS1_E_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  0LL,  0LL,  0LL,  *(void *)(a1 + 32));
}

void nw_connection_receive_message(nw_connection_t connection, nw_connection_receive_completion_t completion)
{
}

void nw_connection_receive_with_context(void *a1, void *a2, unsigned int a3, unsigned int a4, void *a5)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v9 = a1;
  id v10 = a2;
  id v11 = a5;
  if (v10)
  {
    nw_connection_receive_internal(v9, v10, a3, a4, v11);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  qos_class_t v23 = "nw_connection_receive_with_context";
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        qos_class_t v23 = "nw_connection_receive_with_context";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null message", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)__int128 buf = 136446466;
          qos_class_t v23 = "nw_connection_receive_with_context";
          __int16 v24 = 2082;
          BOOL v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v18)
      {
        *(_DWORD *)__int128 buf = 136446210;
        qos_class_t v23 = "nw_connection_receive_with_context";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        qos_class_t v23 = "nw_connection_receive_with_context";
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FC80B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_receive_message_with_context(void *a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (v6)
  {
    nw_connection_receive_internal(v5, v6, 0xFFFFFFFF, 0xFFFFFFFF, v7);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v19 = "nw_connection_receive_message_with_context";
  id v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_receive_message_with_context";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null message", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v19 = "nw_connection_receive_message_with_context";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_receive_message_with_context";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_receive_message_with_context";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FC8390(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_read(void *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a4;
  id v9 = v8;
  if (v7)
  {
    if (v8)
    {
      v25[0] = MEMORY[0x1895F87A8];
      v25[1] = 3221225472LL;
      v25[2] = __nw_connection_read_block_invoke;
      v25[3] = &unk_189BC56E8;
      id v26 = v8;
      nw_connection_receive_internal(v7, 0LL, a2, a3, v25);

      uint64_t v10 = 1LL;
      goto LABEL_4;
    }

    __nwlog_obj();
    char v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v30 = "nw_connection_read";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v13, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v30 = "nw_connection_read";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null handler", buf, 0xCu);
        }

void sub_181FC88B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_connection_read_block_invoke(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v11 = a2;
  id v8 = a3;
  id v9 = a5;
  uint64_t v10 = v9;
  if (v9) {

  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_181FC8980( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __nw_connection_send_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 22);
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_181FC89F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_connection_add_write_request(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v16 = 0LL;
  os_log_type_t v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  char v19 = 1;
  id v5 = v3 + 34;
  uint64_t v6 = MEMORY[0x1895F87A8];
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  v12[2] = ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke;
  v12[3] = &unk_189BBEEE8;
  id v7 = v3;
  os_log_type_t v13 = v7;
  id v8 = v4;
  id v14 = v8;
  os_log_type_t v15 = &v16;
  os_unfair_lock_lock(v5);
  ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke((uint64_t)v12);
  os_unfair_lock_unlock(v5);
  if (*((_BYTE *)v17 + 24))
  {
    v9[0] = v6;
    v9[1] = 3221225472LL;
    v9[2] = ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke_2;
    v9[3] = &unk_189BC9238;
    uint64_t v10 = v7;
    id v11 = v8;
    nw_connection_async_if_needed(v10, v9);
  }

  _Block_object_dispose(&v16, 8);
}

void sub_181FC8B4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21)
{
  _Block_object_dispose((const void *)(v23 - 96), 8);
  _Unwind_Resume(a1);
}

void ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v1 + 109) & 0x20) != 0)
  {
    BOOL v3 = nw_write_request_list_append(*(void **)(v1 + 112), *(void **)(a1 + 40));
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = *(void **)(v4 + 112);
    *(void *)(v4 + 112) = v3;

    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
  }

void ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke_2( uint64_t a1)
{
}

void nw_connection_add_write_request_on_queue(void *a1, void *a2, int a3)
{
  id v5 = a1;
  id v6 = a2;
  nw_context_assert_queue(*((void **)v5 + 3));
  uint64_t v12 = 0LL;
  os_log_type_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  char v15 = 0;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  v9[2] = ___ZL40nw_connection_add_write_request_on_queueP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObjectb_block_invoke;
  v9[3] = &unk_189BC9210;
  id v11 = &v12;
  id v7 = (void **)v5;
  uint64_t v10 = v7;
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 34);
  ___ZL40nw_connection_add_write_request_on_queueP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObjectb_block_invoke((uint64_t)v9);
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 34);
  if (*((_BYTE *)v13 + 24))
  {
    int v8 = 89;
LABEL_8:
    nw_write_request_fail(v6, v8);
    goto LABEL_9;
  }

  if (!nw_endpoint_handler_add_write_request(v7[18], v6))
  {
    int v8 = 57;
    goto LABEL_8;
  }

  if (a3 && (*((_BYTE *)v7 + 109) & 0x40) != 0) {
    nw_endpoint_handler_service_writes(v7[18]);
  }
LABEL_9:

  _Block_object_dispose(&v12, 8);
}

void sub_181FC8D10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL40nw_connection_add_write_request_on_queueP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObjectb_block_invoke( uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = (*(_BYTE *)(*(void *)(result + 32) + 109LL) & 8) != 0;
  return result;
}

void nw_connection_send_idempotent(nw_connection *a1, dispatch_data_s *a2, nw_content_context *a3, BOOL a4)
{
}

void nw_connection_send_reply(void *a1, void *a2, void *a3, void *a4, int a5, void *a6)
{
  *(void *)&v67[13] = *MEMORY[0x1895F89C0];
  id v11 = a1;
  id v12 = a2;
  id v13 = a3;
  id v14 = a4;
  id v15 = a6;
  uint64_t v16 = v15;
  id v59 = v11;
  if (!v11)
  {
    __nwlog_obj();
    os_log_type_t v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v65 = "nw_connection_send_reply";
    os_log_type_t v46 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint32_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v48 = type;
      if (os_log_type_enabled(v47, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v65 = "nw_connection_send_reply";
        _os_log_impl(&dword_181A5C000, v47, v48, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v62)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint32_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      BOOL v53 = os_log_type_enabled(v47, type);
      if (backtrace_string)
      {
        if (v53)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v65 = "nw_connection_send_reply";
          __int16 v66 = 2082;
          *(void *)os_log_type_t v67 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v47,  v52,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_92:
        if (!v46) {
          goto LABEL_29;
        }
LABEL_93:
        free(v46);
        goto LABEL_29;
      }

      if (v53)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v65 = "nw_connection_send_reply";
        _os_log_impl(&dword_181A5C000, v47, v52, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint32_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v47, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v65 = "nw_connection_send_reply";
        _os_log_impl( &dword_181A5C000,  v47,  v57,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FC97A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void __nw_connection_send_reply_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 22);
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_181FC9860( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_connection_send_file_at_path_with_progress( void *a1, const char *a2, void *a3, uint64_t a4, int a5, void *a6)
{
  uint64_t v124 = *MEMORY[0x1895F89C0];
  id v12 = a1;
  id v106 = a3;
  id v13 = a6;
  id v107 = v13;
  if (!v12)
  {
    __nwlog_obj();
    id v69 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int16 v118 = 136446210;
    *(void *)&v118[4] = "nw_connection_send_file_at_path_with_progress";
    char v70 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v112) = 0;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      id v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v72 = buf[0];
      if (os_log_type_enabled(v71, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v118 = 136446210;
        *(void *)&v118[4] = "nw_connection_send_file_at_path_with_progress";
        _os_log_impl(&dword_181A5C000, v71, v72, "%{public}s called with null connection", v118, 0xCu);
      }

      goto LABEL_144;
    }

    if (!(_BYTE)v112)
    {
      __nwlog_obj();
      id v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v91 = buf[0];
      if (os_log_type_enabled(v71, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v118 = 136446210;
        *(void *)&v118[4] = "nw_connection_send_file_at_path_with_progress";
        _os_log_impl( &dword_181A5C000,  v71,  v91,  "%{public}s called with null connection, backtrace limit exceeded",  v118,  0xCu);
      }

      goto LABEL_144;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v76 = buf[0];
    BOOL v77 = os_log_type_enabled(v71, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v77)
      {
        *(_DWORD *)__int16 v118 = 136446210;
        *(void *)&v118[4] = "nw_connection_send_file_at_path_with_progress";
        _os_log_impl(&dword_181A5C000, v71, v76, "%{public}s called with null connection, no backtrace", v118, 0xCu);
      }

      goto LABEL_144;
    }

    if (v77)
    {
      *(_DWORD *)__int16 v118 = 136446466;
      *(void *)&v118[4] = "nw_connection_send_file_at_path_with_progress";
      *(_WORD *)&v118[12] = 2082;
      *(void *)&v118[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v71,  v76,  "%{public}s called with null connection, dumping backtrace:%{public}s",  v118,  0x16u);
    }

    goto LABEL_117;
  }

  id v14 = v13;
  if (v13)
  {
    *(void *)__int16 v118 = 0LL;
    *(void *)&v118[8] = v118;
    *(void *)&v118[16] = 0x3032000000LL;
    os_log_type_t v119 = __Block_byref_object_copy__24148;
    os_log_type_t v120 = __Block_byref_object_dispose__24149;
    id v121 = 0LL;
    uint64_t v112 = 0LL;
    os_log_type_t v113 = &v112;
    uint64_t v114 = 0x2020000000LL;
    uint64_t v115 = a4;
    int v15 = open(a2, 4);
    uint64_t v16 = MEMORY[0x1895F87A8];
    if (v15 == -1)
    {
      posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
      os_log_type_t v39 = *(void **)(*(void *)&v118[8] + 40LL);
      *(void *)(*(void *)&v118[8] + 40LL) = posix_error;

      os_log_type_t v17 = 0LL;
      uint64_t v18 = *(void *)(*(void *)&v118[8] + 40LL);
      id v14 = v107;
    }

    else
    {
      os_log_type_t v17 = nw_fd_wrapper_create(v15);
      v111[0] = v16;
      v111[1] = 3221225472LL;
      v111[2] = __nw_connection_send_file_at_path_with_progress_block_invoke;
      v111[3] = &unk_189BB9918;
      v111[4] = v118;
      v111[5] = &v112;
      nw_fd_wrapper_get_fd(v17, v111);
      uint64_t v18 = *(void *)(*(void *)&v118[8] + 40LL);
      if (!v18 && v17)
      {
        uint64_t v19 = *((void *)v12 + 2);
        if (v19 && !nw_path_parameters_get_logging_disabled(*(void *)(v19 + 104)) && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v85 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
          {
            int v86 = *((_DWORD *)v12 + 112);
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_connection_send_file_at_path_with_progress";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v86;
            *(_WORD *)&buf[18] = 2112;
            *(void *)&buf[20] = v17;
            _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] attempting file write request on fd: %@",  buf,  0x1Cu);
          }

          id v14 = v107;
        }

        uint64_t v20 = v113[3];
        id v21 = v12;
        char v22 = v12;
        uint64_t v23 = v17;
        id v24 = v106;
        id v25 = v14;
        __int16 v104 = v22;
        BOOL v105 = v23;
        id v101 = v24;
        __int16 v102 = v21;
        os_log_type_t v103 = v25;
        if (v24 == &__block_literal_global_5_41854)
        {
          uint64_t v43 = v21[2];
          uint64_t v44 = MEMORY[0x1895F87A8];
          if (v43 && !nw_path_parameters_get_logging_disabled(*(void *)(v43 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v45 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
            {
              int v46 = v22[112];
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_connection_send_file_internal";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v46;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = "Cannot send replies on new inbound message context";
              _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] %{public}s, sending error callback",  buf,  0x1Cu);
            }
          }

          dispatch_qos_class_t v47 = v22[48];
          *(void *)__int128 buf = v44;
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL32nw_connection_send_file_internalP24NWConcrete_nw_connectionPU27objcproto16OS_nw_fd_wrapper8NSObjectPU32objcproto21OS_nw_content_contextS1_mbU13block_pointerFbmbPU22objcproto11OS_nw_errorS1_E_block_invoke;
          *(void *)&_BYTE buf[24] = &unk_189BC8740;
          id v123 = v103;
          nw_connection_async_client_if_needed_with_override(v22, 0LL, v47, buf);
          os_log_type_t v48 = v123;
          id v12 = v21;
          goto LABEL_95;
        }

        uint64_t v26 = v25;
        if (v24) {
          char v27 = v24;
        }
        else {
          char v27 = &__block_literal_global_41831;
        }
        id v28 = v27;
        __int16 v98 = v23;
        id v29 = v28;
        __int16 v100 = v22;
        id aBlock = v26;
        if (!v20
          && (a5 & 1) == 0
          && (v29 == &__block_literal_global_3_41839
           || v29 == &__block_literal_global_41831
           || v29 == &__block_literal_global_4
           || v29 == &__block_literal_global_5_41854))
        {
          __nwlog_obj();
          BOOL v80 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_write_request_create_with_file";
          os_log_type_t v81 = (char *)_os_log_send_and_compose_impl();

          id v12 = v102;
          uint64_t v82 = MEMORY[0x1895F87A8];
          os_log_type_t v117 = OS_LOG_TYPE_ERROR;
          char v116 = 0;
          if (__nwlog_fault(v81, &v117, &v116))
          {
            if (v117 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v84 = v117;
              if (os_log_type_enabled(v83, v117))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_write_request_create_with_file";
                _os_log_impl( &dword_181A5C000,  v83,  v84,  "%{public}s Send content may only be nil if the request is marked as complete",  buf,  0xCu);
              }
            }

            else if (v116)
            {
              v87 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v89 = v117;
              BOOL v90 = os_log_type_enabled(v88, v117);
              if (v87)
              {
                if (v90)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_write_request_create_with_file";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v87;
                  _os_log_impl( &dword_181A5C000,  v88,  v89,  "%{public}s Send content may only be nil if the request is marked as complete, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                id v12 = v102;
                uint64_t v82 = MEMORY[0x1895F87A8];
                free(v87);
              }

              else
              {
                if (v90)
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_write_request_create_with_file";
                  _os_log_impl( &dword_181A5C000,  v88,  v89,  "%{public}s Send content may only be nil if the request is marked as complete, no backtrace",  buf,  0xCu);
                }

                id v12 = v102;
                uint64_t v82 = MEMORY[0x1895F87A8];
              }
            }

            else
            {
              __nwlog_obj();
              char v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v95 = v117;
              if (os_log_type_enabled(v94, v117))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_write_request_create_with_file";
                _os_log_impl( &dword_181A5C000,  v94,  v95,  "%{public}s Send content may only be nil if the request is marked as complete, backtrace limit exceeded",  buf,  0xCu);
              }

              id v12 = v102;
            }
          }

          if (v81) {
            free(v81);
          }
          os_log_type_t v96 = (dispatch_queue_s *)v100[25];
          if (v96)
          {
            *(void *)__int128 buf = v82;
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = __nw_write_request_create_with_file_block_invoke;
            *(void *)&_BYTE buf[24] = &unk_189BC8740;
            id v123 = aBlock;
            dispatch_async(v96, buf);
            os_log_type_t v55 = 0LL;
            __int16 v31 = v123;
          }

          else
          {
            __int16 v31 = nw_error_create_posix_error(22);
            os_log_type_t v55 = 0LL;
            (*((void (**)(id, void, void, _DWORD *))aBlock + 2))(aBlock, 0LL, 0LL, v31);
            id v12 = v102;
          }

void sub_181FCAB98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20, void *a21, void *a22, void *a23, uint64_t a24, uint64_t a25, void *a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, char a40)
{
  _Block_object_dispose(&a40, 8);
  _Block_object_dispose((const void *)(v41 - 208), 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_connection_send_file_at_path_with_progress_block_invoke(uint64_t a1, int a2)
{
  if (fstat(a2, &v12) == -1)
  {
    posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = posix_error;
  }

  else
  {
    st_unsigned int size = v12.st_size;
    if ((v12.st_mode & 0xF000) != 0x8000)
    {
      uint64_t v4 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 9);
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
      id v6 = *(void **)(v5 + 40);
      *(void *)(v5 + 40) = v4;
    }

    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
    if (st_size < *(void *)(v7 + 24)) {
      *(void *)(v7 + 24) = st_size;
    }
  }

  return 1LL;
}

void ___ZL32nw_connection_send_file_internalP24NWConcrete_nw_connectionPU27objcproto16OS_nw_fd_wrapper8NSObjectPU32objcproto21OS_nw_content_contextS1_mbU13block_pointerFbmbPU22objcproto11OS_nw_errorS1_E_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 22);
  (*(void (**)(uint64_t, void, void))(v1 + 16))(v1, 0LL, 0LL);
}

void sub_181FCADC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_connection_send_file_at_path_with_progress_block_invoke_39(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  0LL,  0LL,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
}

void nw_connection_batch(nw_connection_t connection, dispatch_block_t batch_block)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  BOOL v3 = connection;
  uint64_t v4 = batch_block;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    int v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_batch";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_batch";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_batch";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9) {
          goto LABEL_6;
        }
LABEL_41:
        free(v9);
        goto LABEL_6;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_batch";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_batch";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FCB37C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_batch_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = (*(_BYTE *)(*(void *)(result + 32) + 109LL) & 0x20) != 0;
  *(_BYTE *)(*(void *)(result + 32) + 109LL) |= 0x20u;
  return result;
}

void __nw_connection_batch_block_invoke_2(uint64_t a1)
{
  uint64_t v50 = 0LL;
  BOOL v51 = &v50;
  uint64_t v52 = 0x3032000000LL;
  BOOL v53 = __Block_byref_object_copy__24148;
  BOOL v54 = __Block_byref_object_dispose__24149;
  id v55 = 0LL;
  uint64_t v44 = 0LL;
  os_log_type_t v45 = &v44;
  uint64_t v46 = 0x3032000000LL;
  dispatch_qos_class_t v47 = __Block_byref_object_copy__24148;
  os_log_type_t v48 = __Block_byref_object_dispose__24149;
  id v49 = 0LL;
  uint64_t v2 = *(os_unfair_lock_s **)(a1 + 32);
  BOOL v3 = v2 + 34;
  uint64_t v4 = MEMORY[0x1895F87A8];
  v40[0] = MEMORY[0x1895F87A8];
  v40[1] = 3221225472LL;
  v40[2] = __nw_connection_batch_block_invoke_3;
  v40[3] = &unk_189BC16A8;
  uint64_t v41 = v2;
  dispatch_qos_class_t v42 = &v50;
  uint64_t v43 = &v44;
  os_unfair_lock_lock(v3);
  __nw_connection_batch_block_invoke_3(v40);
  os_unfair_lock_unlock(v3);
  uint64_t v5 = (void *)v51[5];
  if (!v5) {
    goto LABEL_32;
  }
  uint64_t v6 = v5;
  uint64_t v7 = (unsigned __int8 *)v6;
  do
  {
    while (1)
    {
      int v8 = v6;
      uint64_t v7 = v7;
      uint64_t v9 = *((id *)v7 + 1);
      id v10 = v9;
      if (v9)
      {
        unsigned int v11 = v7[128];
        if ((v11 & 3) == 0 && !*((void *)v7 + 14) && !v9[14] && *((void *)v7 + 8) == v9[8])
        {
          int v12 = (v11 >> 2) & 1;
          unsigned int v13 = *((unsigned __int8 *)v9 + 128);
          if (v12 == ((v13 >> 2) & 1)
            && ((v13 ^ v11) & 8) == 0
            && *((void *)v7 + 13) == v9[13]
            && !*((void *)v7 + 9)
            && !v9[9])
          {
            break;
          }
        }
      }

      id v14 = (unsigned __int8 *)*((id *)v7 + 1);
      uint64_t v7 = v14;
      if (!v14) {
        goto LABEL_26;
      }
    }

    if (!v12)
    {
      __int16 v38 = _Block_copy(*((const void **)v7 + 3));
      os_log_type_t v15 = _Block_copy(*((const void **)v10 + 3));
      aBlock[0] = v4;
      aBlock[1] = 3221225472LL;
      aBlock[2] = ___ZL35nw_write_request_coalesce_with_nextP27NWConcrete_nw_write_requestS0__block_invoke;
      aBlock[3] = &unk_189BBBF20;
      id v57 = v38;
      id v58 = v15;
      id v39 = v38;
      id v16 = v15;
      os_log_type_t v17 = _Block_copy(aBlock);
      os_log_type_t v18 = (void *)*((void *)v7 + 3);
      *((void *)v7 + 3) = v17;
    }

    BOOL v19 = (dispatch_data_s *)*((void *)v7 + 7);
    os_log_type_t v20 = (dispatch_data_s *)*((void *)v10 + 7);
    if (v19)
    {
      if (!v20) {
        goto LABEL_21;
      }
      dispatch_data_t concat = dispatch_data_create_concat(v19, v20);
    }

    else
    {
      dispatch_data_t concat = v20;
    }

    char v22 = (void *)*((void *)v7 + 7);
    *((void *)v7 + 7) = concat;

LABEL_21:
    objc_storeStrong((id *)v7 + 1, *((id *)v10 + 1));
    if ((id)v6[2] == v10) {
      v6[2] = v7;
    }
    uint64_t v23 = (void *)*((void *)v10 + 1);
    *((void *)v10 + 1) = 0LL;
  }

  while (v7);
LABEL_26:

  while (1)
  {
    id v24 = v51;
    id v25 = (void *)v51[5];
    if (!v25) {
      break;
    }
    id v26 = v25;
    BOOL v27 = nw_write_request_list_remove_head((void *)v24[5]);
    id v28 = (void *)v51[5];
    v51[5] = v27;

    nw_connection_add_write_request_on_queue(*(void **)(a1 + 32), v26, 0);
  }

  uint64_t v29 = *(void *)(a1 + 32);
  char v30 = *(void **)(v29 + 144);
  if (v30 && (*(_BYTE *)(v29 + 109) & 0x40) != 0) {
    nw_endpoint_handler_service_writes(v30);
  }
LABEL_32:
  uint64_t v31 = v45;
  id v32 = (void *)v45[5];
  if (v32)
  {
    do
    {
      id v33 = v32;
      BOOL v34 = nw_read_request_list_remove_head((void *)v31[5]);
      os_log_type_t v35 = (void *)v45[5];
      void v45[5] = v34;

      nw_connection_add_read_request_on_queue(*(void **)(a1 + 32), v33, 0);
      uint64_t v31 = v45;
      id v32 = (void *)v45[5];
    }

    while (v32);
    uint64_t v36 = *(void *)(a1 + 32);
    char v37 = *(void **)(v36 + 144);
    if (v37 && (*(_BYTE *)(v36 + 109) & 0x40) != 0) {
      nw_endpoint_handler_service_reads(v37);
    }
  }

  _Block_object_dispose(&v44, 8);
  _Block_object_dispose(&v50, 8);
}

void sub_181FCB770( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, id a29)
{
  _Block_object_dispose(&a24, 8);
  _Unwind_Resume(a1);
}

void __nw_connection_batch_block_invoke_3(void *a1)
{
  *(_BYTE *)(a1[4] + 109LL) &= ~0x20u;
  objc_storeStrong((id *)(*(void *)(a1[5] + 8LL) + 40LL), *(id *)(a1[4] + 112LL));
  uint64_t v2 = a1[4];
  BOOL v3 = *(void **)(v2 + 112);
  *(void *)(v2 + 112) = 0LL;

  objc_storeStrong((id *)(*(void *)(a1[6] + 8LL) + 40LL), *(id *)(a1[4] + 120LL));
  uint64_t v4 = a1[4];
  uint64_t v5 = *(void **)(v4 + 120);
  *(void *)(v4 + 120) = 0LL;
}

uint64_t nw_connection_write(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  uint64_t v6 = a2;
  id v7 = a3;
  int v8 = v7;
  if (v6)
  {
    if (v7)
    {
      if (v7 == &__block_literal_global_41)
      {
        uint64_t v9 = 1LL;
        nw_connection_send( v5,  v6,  (nw_content_context_t)&__block_literal_global_41831,  1,  &__block_literal_global_24170);
      }

      else
      {
        completion[0] = MEMORY[0x1895F87A8];
        completion[1] = 3221225472LL;
        completion[2] = __nw_connection_write_block_invoke;
        completion[3] = &unk_189BC5710;
        id v25 = v7;
        nw_connection_send(v5, v6, (nw_content_context_t)&__block_literal_global_41831, 1, completion);

        uint64_t v9 = 1LL;
      }

      goto LABEL_6;
    }

    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v29 = "nw_connection_write";
    int v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v12, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unsigned int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v29 = "nw_connection_write";
          _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null handler", buf, 0xCu);
        }

void sub_181FCBD80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_write_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3) {

  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_181FCBE08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t nw_connection_write_multiple(void *a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a4;
  uint64_t v9 = v8;
  if (v7)
  {
    if (v8)
    {
      *(void *)BOOL v66 = 0LL;
      *(void *)&v66[8] = v66;
      *(void *)&v66[16] = 0x2020000000LL;
      char v67 = 0;
      uint64_t v10 = MEMORY[0x1895F87A8];
      v56[0] = MEMORY[0x1895F87A8];
      v56[1] = 3221225472LL;
      v56[2] = __nw_connection_write_multiple_block_invoke;
      v56[3] = &unk_189BC9210;
      id v58 = v66;
      unsigned int v11 = v7;
      id v57 = v11;
      os_unfair_lock_lock(v7 + 34);
      __nw_connection_write_multiple_block_invoke((uint64_t)v56);
      os_unfair_lock_unlock(v7 + 34);
      if (*(_BYTE *)(*(void *)&v66[8] + 24LL))
      {
        if (a2)
        {
          if (a3)
          {
            batch_block[0] = v10;
            batch_block[1] = 3221225472LL;
            batch_block[2] = __nw_connection_write_multiple_block_invoke_2;
            batch_block[3] = &unk_189BB99A8;
            id v50 = v9;
            int v52 = a3;
            id v49 = v11;
            uint64_t v51 = a2;
            nw_connection_batch(v49, batch_block);

            uint64_t v12 = 1LL;
LABEL_49:

            _Block_object_dispose(v66, 8);
            goto LABEL_50;
          }

          os_log_type_t v20 = "datagram_count parameter is 0";
          uint64_t v21 = *(void *)&v11[4]._os_unfair_lock_opaque;
          if (!v21) {
            goto LABEL_35;
          }
        }

        else
        {
          os_log_type_t v20 = "datagrams parameter is nil";
          uint64_t v21 = *(void *)&v11[4]._os_unfair_lock_opaque;
          if (!v21)
          {
LABEL_35:
            dispatch_qos_class_t os_unfair_lock_opaque = v11[48]._os_unfair_lock_opaque;
            v53[0] = v10;
            v53[1] = 3221225472LL;
            v53[2] = __nw_connection_write_multiple_block_invoke_44;
            v53[3] = &unk_189BC8740;
            id v54 = v9;
            nw_connection_async_client_if_needed_with_override(v11, 0LL, os_unfair_lock_opaque, v53);

LABEL_48:
            uint64_t v12 = 0LL;
            goto LABEL_49;
          }
        }

        if (!nw_path_parameters_get_logging_disabled(*(void *)(v21 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v27 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            uint32_t v28 = v11[112]._os_unfair_lock_opaque;
            *(_DWORD *)__int128 buf = 136446722;
            id v61 = "nw_connection_write_multiple";
            __int16 v62 = 1024;
            uint32_t v63 = v28;
            __int16 v64 = 2082;
            os_log_type_t v65 = v20;
            _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] %{public}s, sending error callback",  buf,  0x1Cu);
          }
        }

        goto LABEL_35;
      }

      uint64_t v13 = *(void *)&v11[4]._os_unfair_lock_opaque;
      if (!v13 || nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104))) {
        goto LABEL_48;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v14 = (id)gconnectionLogObj;
      uint32_t v15 = v11[112]._os_unfair_lock_opaque;
      *(_DWORD *)__int128 buf = 136446466;
      id v61 = "nw_connection_write_multiple";
      __int16 v62 = 1024;
      uint32_t v63 = v15;
      os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v59 = OS_LOG_TYPE_ERROR;
      char v55 = 0;
      if (__nwlog_fault(v16, &v59, &v55))
      {
        if (v59 == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v18 = v59;
          if (os_log_type_enabled(v17, v59))
          {
            uint32_t v19 = v11[112]._os_unfair_lock_opaque;
            *(_DWORD *)__int128 buf = 136446466;
            id v61 = "nw_connection_write_multiple";
            __int16 v62 = 1024;
            uint32_t v63 = v19;
            _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s [C%u] no client queue", buf, 0x12u);
          }
        }

        else if (v55)
        {
          backtrace_string = __nw_create_backtrace_string();
          if (backtrace_string)
          {
            os_log_type_t v23 = (char *)backtrace_string;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v24 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v25 = v59;
            if (os_log_type_enabled(v24, v59))
            {
              uint32_t v26 = v11[112]._os_unfair_lock_opaque;
              *(_DWORD *)__int128 buf = 136446722;
              id v61 = "nw_connection_write_multiple";
              __int16 v62 = 1024;
              uint32_t v63 = v26;
              __int16 v64 = 2082;
              os_log_type_t v65 = v23;
              _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s [C%u] no client queue, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v23);
            if (!v16) {
              goto LABEL_48;
            }
            goto LABEL_47;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v32 = v59;
          if (os_log_type_enabled(v17, v59))
          {
            uint32_t v33 = v11[112]._os_unfair_lock_opaque;
            *(_DWORD *)__int128 buf = 136446466;
            id v61 = "nw_connection_write_multiple";
            __int16 v62 = 1024;
            uint32_t v63 = v33;
            _os_log_impl(&dword_181A5C000, v17, v32, "%{public}s [C%u] no client queue, no backtrace", buf, 0x12u);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v30 = v59;
          if (os_log_type_enabled(v17, v59))
          {
            uint32_t v31 = v11[112]._os_unfair_lock_opaque;
            *(_DWORD *)__int128 buf = 136446466;
            id v61 = "nw_connection_write_multiple";
            __int16 v62 = 1024;
            uint32_t v63 = v31;
            _os_log_impl( &dword_181A5C000,  v17,  v30,  "%{public}s [C%u] no client queue, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      if (!v16) {
        goto LABEL_48;
      }
LABEL_47:
      free(v16);
      goto LABEL_48;
    }

    __nwlog_obj();
    id v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)BOOL v66 = 136446210;
    *(void *)&v66[4] = "nw_connection_write_multiple";
    uint64_t v36 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t v59 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v36, buf, &v59))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        char v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v40 = buf[0];
        if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)BOOL v66 = 136446210;
          *(void *)&v66[4] = "nw_connection_write_multiple";
          _os_log_impl(&dword_181A5C000, v37, v40, "%{public}s called with null handler", v66, 0xCu);
        }

void sub_181FCC81C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32)
{
  _Block_object_dispose((const void *)(v35 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_write_multiple_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(void *)(*(void *)(result + 32) + 200LL) != 0LL;
  return result;
}

uint64_t __nw_connection_write_multiple_block_invoke_44(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __nw_connection_write_multiple_block_invoke_2(uint64_t a1)
{
  if (*(_UNKNOWN **)(a1 + 40) == &__block_literal_global_41)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      unint64_t v9 = 0LL;
      do
        nw_connection_send( *(nw_connection_t *)(a1 + 32),  *(dispatch_data_t *)(*(void *)(a1 + 48) + 8 * v9++),  (nw_content_context_t)&__block_literal_global_41831,  1,  &__block_literal_global_24170);
      while (v9 < *(unsigned int *)(a1 + 56));
    }
  }

  else
  {
    v16[0] = 0LL;
    v16[1] = v16;
    int v17 = 0;
    v16[2] = 0x2020000000LL;
    uint64_t v2 = dispatch_group_create();
    uint64_t v3 = MEMORY[0x1895F87A8];
    if (*(_DWORD *)(a1 + 56))
    {
      unint64_t v4 = 0LL;
      do
      {
        dispatch_group_enter(v2);
        uint64_t v5 = *(dispatch_data_s **)(*(void *)(a1 + 48) + 8 * v4);
        uint64_t v6 = *(nw_connection **)(a1 + 32);
        completion[0] = v3;
        completion[1] = 3221225472LL;
        completion[2] = __nw_connection_write_multiple_block_invoke_3;
        completion[3] = &unk_189BB9980;
        uint32_t v15 = v16;
        id v14 = v2;
        nw_connection_send(v6, v5, (nw_content_context_t)&__block_literal_global_41831, 1, completion);

        ++v4;
      }

      while (v4 < *(unsigned int *)(a1 + 56));
    }

    id v7 = *(void **)(a1 + 40);
    id v8 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 200LL);
    v10[0] = v3;
    v10[1] = 3221225472LL;
    v10[2] = __nw_connection_write_multiple_block_invoke_4;
    v10[3] = &unk_189BBF570;
    id v11 = v7;
    uint64_t v12 = v16;
    dispatch_group_notify(v2, v8, v10);

    _Block_object_dispose(v16, 8);
  }

void sub_181FCCA54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_write_multiple_block_invoke_4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
}

void __nw_connection_write_multiple_block_invoke_3(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (v5)
  {
    uint64_t v3 = v5;
    int v4 = v3[3];

    if (v4) {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v4;
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

BOOL nw_connection_write_close(void *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v4)
  {
    if (v4 == &__block_literal_global_41)
    {
      nw_connection_send( v3,  0LL,  (nw_content_context_t)&__block_literal_global_3_41839,  1,  &__block_literal_global_24170);
    }

    else
    {
      completion[0] = MEMORY[0x1895F87A8];
      completion[1] = 3221225472LL;
      completion[2] = __nw_connection_write_close_block_invoke;
      completion[3] = &unk_189BC5710;
      id v16 = v4;
      nw_connection_send(v3, 0LL, (nw_content_context_t)&__block_literal_global_3_41839, 1, completion);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  id v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v20 = "nw_connection_write_close";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v8, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_connection_write_close";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v20 = "nw_connection_write_close";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_connection_write_close";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_connection_write_close";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FCCE18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_write_close_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3) {

  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_181FCCE9C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t nw_connection_get_unsent_byte_count(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_get_unsent_byte_count_block_invoke;
    v13[3] = &unk_189BC9210;
    os_log_type_t v14 = v1;
    uint32_t v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_get_unsent_byte_count_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    uint64_t v3 = *(unsigned int *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_get_unsent_byte_count";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_unsent_byte_count";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_get_unsent_byte_count";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_unsent_byte_count";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_unsent_byte_count";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_get_unsent_byte_count_block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v6 = (os_unfair_lock_s *)*(id *)(v2 + 144);
    id v7 = v6;
    if (v6)
    {
      os_unfair_lock_lock(v6 + 28);
      if (v7[29]._os_unfair_lock_opaque != 2)
      {
        int v13 = 0;
        goto LABEL_20;
      }

      os_log_type_t v8 = (os_unfair_lock_s *)*(id *)&v7[62]._os_unfair_lock_opaque;
      unint64_t v9 = v8;
      if (v8)
      {
        os_unfair_lock_lock(v8 + 220);
        *(void *)os_log_type_t type = 0LL;
        uint32_t v31 = type;
        uint64_t v32 = 0x2020000000LL;
        uint32_t os_unfair_lock_opaque = v9[224]._os_unfair_lock_opaque;
        id v10 = *(id *)&v9[222]._os_unfair_lock_opaque;
        if ((v9[8]._os_unfair_lock_opaque & 2) == 0)
        {
          BOOL v11 = *(void **)&v9[234]._os_unfair_lock_opaque;
          if (v11)
          {
            id v12 = nw_endpoint_handler_copy_connected_socket_wrapper(v11);

            id v10 = v12;
          }
        }

        if (v10)
        {
          *(void *)__int128 buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = __nw_endpoint_flow_get_unsent_byte_count_block_invoke;
          uint64_t v36 = &unk_189BC78E8;
          char v37 = type;
          nw_fd_wrapper_get_fd(v10, buf);
        }

        os_unfair_lock_unlock(v9 + 220);
        int v13 = *((_DWORD *)v31 + 6);

        _Block_object_dispose(type, 8);
LABEL_18:

LABEL_20:
        os_unfair_lock_unlock(v7 + 28);
LABEL_21:

        *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v13;
        return;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v18 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_unsent_byte_count";
      int v19 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (__nwlog_fault(v19, type, &v34))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (os_log_s *)(id)gLogObj;
          os_log_type_t v21 = type[0];
          if (os_log_type_enabled(v20, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_unsent_byte_count";
            _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null endpoint_flow", buf, 0xCu);
          }
        }

        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (os_log_s *)(id)gLogObj;
          os_log_type_t v26 = type[0];
          BOOL v27 = os_log_type_enabled(v20, type[0]);
          if (backtrace_string)
          {
            if (v27)
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_unsent_byte_count";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v20,  v26,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_58;
          }

          if (v27)
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_unsent_byte_count";
            _os_log_impl( &dword_181A5C000,  v20,  v26,  "%{public}s called with null endpoint_flow, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (os_log_s *)(id)gLogObj;
          os_log_type_t v29 = type[0];
          if (os_log_type_enabled(v20, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_get_unsent_byte_count";
            _os_log_impl( &dword_181A5C000,  v20,  v29,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

void sub_181FCD8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_connection_register_context(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v26 = "nw_connection_register_context";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_register_context";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v26 = "nw_connection_register_context";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_register_context";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_register_context";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FCDE30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_register_context_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    if ((nw_endpoint_handler_register_context(*(void **)(v2 + 144), *(void **)(a1 + 40)) & 1) == 0)
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v9)
      {
        if (!nw_path_parameters_get_logging_disabled(*(void *)(v9 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v4 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
            goto LABEL_16;
          }
          uint64_t v10 = *(void *)(a1 + 40);
          int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          int v12 = 136446722;
          os_log_type_t v13 = "nw_connection_register_context_block_invoke";
          __int16 v14 = 1024;
          int v15 = v11;
          __int16 v16 = 2112;
          uint64_t v17 = v10;
          uint64_t v6 = "%{public}s [C%u] Failed to register context %@";
          id v7 = v4;
          uint32_t v8 = 28;
          goto LABEL_15;
        }
      }
    }
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v4 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        goto LABEL_16;
      }
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v12 = 136446466;
      os_log_type_t v13 = "nw_connection_register_context_block_invoke";
      __int16 v14 = 1024;
      int v15 = v5;
      uint64_t v6 = "%{public}s [C%u] Cannot register a context on a connection that is not ready";
      id v7 = v4;
      uint32_t v8 = 18;
LABEL_15:
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v12, v8);
LABEL_16:
    }
  }

void nw_connection_unregister_context(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v26 = "nw_connection_unregister_context";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint32_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint32_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v26 = "nw_connection_unregister_context";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint32_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v26 = "nw_connection_unregister_context";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FCE538( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_unregister_context_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    nw_endpoint_handler_unregister_context(*(void **)(v2 + 144), *(void **)(a1 + 40));
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v6 = 136446466;
        id v7 = "nw_connection_unregister_context_block_invoke";
        __int16 v8 = 1024;
        int v9 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Cannot unregister a context on a connection that is not ready",  (uint8_t *)&v6,  0x12u);
      }
    }
  }

void nw_connection_tls_apply(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (v3)
  {
    if (v4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v27 = "nw_connection_tls_apply";
      id v7 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v24 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v27 = "nw_connection_tls_apply";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s nw_connection_tls_apply is not implemented", buf, 0xCu);
        }

uint64_t nw_connection_modify_connected_protocol_stack_internal(void *a1, void *a2, char a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = v6;
  if (v5)
  {
    if (v6)
    {
      v23[0] = MEMORY[0x1895F87A8];
      v23[1] = 3221225472LL;
      v23[2] = __nw_connection_modify_connected_protocol_stack_internal_block_invoke;
      v23[3] = &unk_189BBBE50;
      id v24 = v5;
      char v26 = a3;
      id v25 = v7;
      nw_connection_async_if_needed(v24, v23);

      uint64_t v8 = 1LL;
      goto LABEL_4;
    }

    __nwlog_obj();
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v30 = "nw_connection_modify_connected_protocol_stack_internal";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v28 = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v11, &v28, &v27))
    {
      if (v28 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = v28;
        if (os_log_type_enabled(v12, v28))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v30 = "nw_connection_modify_connected_protocol_stack_internal";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null modifier", buf, 0xCu);
        }

void sub_181FCF290( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_modify_connected_protocol_stack_internal_block_invoke(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    id v6 = *(void **)(v2 + 144);
    if (*(_BYTE *)(a1 + 48)) {
      id v7 = v6;
    }
    else {
      id v7 = nw_endpoint_handler_copy_top_protocol_flow_handler(v6);
    }
    id v4 = v7;
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (v8 && !nw_path_parameters_get_logging_disabled(*(void *)(v8 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v9 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        int v10 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v32 = "nw_connection_modify_connected_protocol_stack_internal_block_invoke";
        __int16 v33 = 1024;
        int v34 = v10;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Failed to modify protocol stack, cancelling connection",  buf,  0x12u);
      }
    }

    uint64_t v11 = *(void *)(a1 + 32);
    BOOL v12 = *(void **)(v11 + 144);
    if (v12)
    {
      nw_endpoint_handler_cancel(v12, 0LL, 0);
LABEL_34:

      return;
    }

    uint64_t v13 = *(void *)(v11 + 16);
    if (!v13 || nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104))) {
      goto LABEL_34;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v14 = (id)gconnectionLogObj;
    int v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v32 = "nw_connection_modify_connected_protocol_stack_internal_block_invoke";
    __int16 v33 = 1024;
    int v34 = v15;
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v16, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          int v19 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v32 = "nw_connection_modify_connected_protocol_stack_internal_block_invoke";
          __int16 v33 = 1024;
          int v34 = v19;
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s [C%u] No parent endpoint handler found", buf, 0x12u);
        }
      }

      else if (v29)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          os_log_type_t v21 = (char *)backtrace_string;
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v22 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            int v24 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)__int128 buf = 136446722;
            uint64_t v32 = "nw_connection_modify_connected_protocol_stack_internal_block_invoke";
            __int16 v33 = 1024;
            int v34 = v24;
            __int16 v35 = 2082;
            uint64_t v36 = v21;
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s [C%u] No parent endpoint handler found, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v21);
          if (!v16) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v17, type))
        {
          int v28 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v32 = "nw_connection_modify_connected_protocol_stack_internal_block_invoke";
          __int16 v33 = 1024;
          int v34 = v28;
          _os_log_impl( &dword_181A5C000,  v17,  v27,  "%{public}s [C%u] No parent endpoint handler found, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v17, type))
        {
          int v26 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v32 = "nw_connection_modify_connected_protocol_stack_internal_block_invoke";
          __int16 v33 = 1024;
          int v34 = v26;
          _os_log_impl( &dword_181A5C000,  v17,  v25,  "%{public}s [C%u] No parent endpoint handler found, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v16) {
      goto LABEL_34;
    }
LABEL_33:
    free(v16);
    goto LABEL_34;
  }

  uint64_t v3 = *(void *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v4 = (NWConcrete_nw_endpoint_handler *)(id)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v32 = "nw_connection_modify_connected_protocol_stack_internal_block_invoke";
      __int16 v33 = 1024;
      int v34 = v5;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] No connected endpoint handler found",  buf,  0x12u);
    }

    goto LABEL_34;
  }

void sub_181FCF820(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_modify_connected_protocol_stack(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (v3)
  {
    if (v4)
    {
      uint64_t v6 = nw_connection_modify_connected_protocol_stack_internal(v3, v4, 0);
      goto LABEL_4;
    }

    __nwlog_obj();
    BOOL v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v24 = "nw_connection_modify_connected_protocol_stack";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v24 = "nw_connection_modify_connected_protocol_stack";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null modifier", buf, 0xCu);
        }

void sub_181FCFCF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_append_and_start_application_protocol(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v26 = "nw_connection_append_and_start_application_protocol";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v26 = "nw_connection_append_and_start_application_protocol";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v26 = "nw_connection_append_and_start_application_protocol";
          __int16 v27 = 2082;
          int v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v26 = "nw_connection_append_and_start_application_protocol";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v26 = "nw_connection_append_and_start_application_protocol";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FD0210( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_append_and_start_application_protocol_block_invoke(uint64_t a1)
{
  *(void *)&v38[13] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 80) == 3)
  {
    if ((*(_BYTE *)(v2 + 109) & 0x40) == 0)
    {
      uint64_t v3 = *(void *)(v2 + 16);
      if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v4 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
          __int16 v37 = 1024;
          *(_DWORD *)uint64_t v38 = v5;
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] No connected endpoint handler found, cannot add new protocol",  buf,  0x12u);
        }
      }

      return;
    }

    uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (v14 && !nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v15 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v16 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
        __int16 v37 = 1024;
        *(_DWORD *)uint64_t v38 = v16;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Failed to append and start new protocol, cancelling connection",  buf,  0x12u);
      }
    }

    BOOL v17 = *(void **)(*(void *)(a1 + 32) + 144LL);
    if (v17)
    {
      nw_endpoint_handler_cancel(v17, 0LL, 0);
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v25 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
    int v26 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v27 = (os_log_s *)(id)gLogObj;
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
        _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s Connection has no parent endpoint handler", buf, 0xCu);
      }
    }

    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
          __int16 v37 = 2082;
          *(void *)uint64_t v38 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s Connection has no parent endpoint handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_66;
      }

      if (v31)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
        _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s Connection has no parent endpoint handler, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
        _os_log_impl( &dword_181A5C000,  v27,  v32,  "%{public}s Connection has no parent endpoint handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_66:
    if (!v26) {
      return;
    }
    os_log_type_t v13 = (char *)v26;
LABEL_23:
    free(v13);
    return;
  }

  uint64_t v6 = *(void *)(v2 + 16);
  if (!v6 || nw_path_parameters_get_logging_disabled(*(void *)(v6 + 104))) {
    return;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  id v7 = (id)gconnectionLogObj;
  int v8 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
  *(_DWORD *)__int128 buf = 136446466;
  uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
  __int16 v37 = 1024;
  *(_DWORD *)uint64_t v38 = v8;
  os_log_type_t v9 = (const char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v10 = (os_log_s *)(id)gconnectionLogObj;
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
      __int16 v37 = 1024;
      *(_DWORD *)uint64_t v38 = v12;
      _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s [C%u] Connection is not ready, cannot add new protocol",  buf,  0x12u);
    }

void __nw_connection_start_tls_block_invoke(uint64_t a1)
{
  *(void *)&v42[13] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 80) == 3)
  {
    if ((*(_BYTE *)(v2 + 109) & 0x40) == 0)
    {
      uint64_t v3 = *(void *)(v2 + 16);
      if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v4 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
          __int16 v41 = 1024;
          *(_DWORD *)os_log_type_t v42 = v5;
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] No connected endpoint handler found",  buf,  0x12u);
        }
      }

      return;
    }

    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (v11 && !nw_path_parameters_get_logging_disabled(*(void *)(v11 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v12 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
        __int16 v41 = 1024;
        *(_DWORD *)os_log_type_t v42 = v13;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Failed to start TLS, cancelling connection",  buf,  0x12u);
      }
    }

    uint64_t v14 = *(void **)(*(void *)(a1 + 32) + 144LL);
    if (v14)
    {
      nw_endpoint_handler_cancel(v14, 0LL, 0);
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v26 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
    __int16 v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v28 = (os_log_s *)(id)gLogObj;
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s Connection has no parent endpoint handler", buf, 0xCu);
      }
    }

    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type;
      BOOL v34 = os_log_type_enabled(v28, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
          __int16 v41 = 2082;
          *(void *)os_log_type_t v42 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s Connection has no parent endpoint handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_74;
      }

      if (v34)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
        _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s Connection has no parent endpoint handler, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
        _os_log_impl( &dword_181A5C000,  v28,  v36,  "%{public}s Connection has no parent endpoint handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_74:
    if (!v27) {
      return;
    }
    int v21 = (char *)v27;
    goto LABEL_76;
  }

  uint64_t v6 = *(void *)(v2 + 144);
  uint64_t v7 = *(void *)(v2 + 16);
  if (v6)
  {
    if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
        __int16 v41 = 1024;
        *(_DWORD *)os_log_type_t v42 = v9;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Connection is not ready yet, setting TLS on parameters",  buf,  0x12u);
      }
    }

    id v10 = nw_endpoint_handler_copy_parameters(*(void **)(*(void *)(a1 + 32) + 144LL));
    nw_parameters_set_tls(v10, 1);
    nw_parameters_set_tls_session_id(v10, *(void **)(a1 + 40));

    return;
  }

  if (!v7 || nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104))) {
    return;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  id v15 = (id)gconnectionLogObj;
  int v16 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
  *(_DWORD *)__int128 buf = 136446466;
  os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
  __int16 v41 = 1024;
  *(_DWORD *)os_log_type_t v42 = v16;
  BOOL v17 = (const char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v18 = (os_log_s *)(id)gconnectionLogObj;
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v18, type))
    {
      int v20 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v40 = "nw_connection_start_tls_block_invoke";
      __int16 v41 = 1024;
      *(_DWORD *)os_log_type_t v42 = v20;
      _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s [C%u] No parent endpoint handler found", buf, 0x12u);
    }

void sub_181FD11D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_better_path_available_handler( nw_connection_t connection, nw_connection_BOOLean_event_handler_t handler)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = connection;
  nw_connection_BOOLean_event_handler_t v4 = handler;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_set_better_path_available_handler_block_invoke;
    v13[3] = &unk_189BC91E8;
    uint64_t v14 = v3;
    id v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v19 = "nw_connection_set_better_path_available_handler";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_better_path_available_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v19 = "nw_connection_set_better_path_available_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_better_path_available_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_better_path_available_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FD14E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_better_path_available_handler_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  nw_connection_BOOLean_event_handler_t v4 = *(void **)(v3 + 240);
  *(void *)(v3 + 240) = v2;
}

void nw_connection_set_path_changed_handler( nw_connection_t connection, nw_connection_path_event_handler_t handler)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = connection;
  nw_connection_path_event_handler_t v4 = handler;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_set_path_changed_handler_block_invoke;
    v13[3] = &unk_189BC91E8;
    uint64_t v14 = v3;
    id v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v19 = "nw_connection_set_path_changed_handler";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_path_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v19 = "nw_connection_set_path_changed_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_path_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_path_changed_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FD1830( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_path_changed_handler_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  nw_connection_path_event_handler_t v4 = *(void **)(v3 + 256);
  *(void *)(v3 + 256) = v2;
}

void nw_connection_set_adaptive_read_handler(void *a1, int a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a3;
  if (v5)
  {
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_set_adaptive_read_handler_block_invoke;
    v15[3] = &unk_189BC9440;
    id v16 = v5;
    int v18 = a2;
    id v17 = v6;
    nw_connection_async_if_needed(v16, v15);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v22 = "nw_connection_set_adaptive_read_handler";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v20 = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &v20, &v19))
  {
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v20;
      if (os_log_type_enabled(v9, v20))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_connection_set_adaptive_read_handler";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v20;
      BOOL v13 = os_log_type_enabled(v9, v20);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v22 = "nw_connection_set_adaptive_read_handler";
          __int16 v23 = 2082;
          BOOL v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_connection_set_adaptive_read_handler";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v20;
      if (os_log_type_enabled(v9, v20))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_connection_set_adaptive_read_handler";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FD1B88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_adaptive_read_handler_block_invoke(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(a1 + 40);
  int v2 = *(_DWORD *)(a1 + 48);
  id v3 = *(id *)(*(void *)(a1 + 32) + 144LL);
  id v4 = v1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_read_handler";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v12, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_read_handler";
          _os_log_impl(&dword_181A5C000, v13, v24, "%{public}s called with null handler", buf, 0xCu);
        }

        goto LABEL_37;
      }

      if (!v29)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_read_handler";
          _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_37;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_read_handler";
          _os_log_impl(&dword_181A5C000, v13, v26, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_37;
      }

      if (v27)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_read_handler";
        __int16 v33 = 2082;
        BOOL v34 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181FD2270(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_adaptive_write_handler(void *a1, int a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a3;
  if (v5)
  {
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_set_adaptive_write_handler_block_invoke;
    v15[3] = &unk_189BC9440;
    id v16 = v5;
    int v18 = a2;
    id v17 = v6;
    nw_connection_async_if_needed(v16, v15);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v22 = "nw_connection_set_adaptive_write_handler";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v20 = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &v20, &v19))
  {
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v20;
      if (os_log_type_enabled(v9, v20))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_connection_set_adaptive_write_handler";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v20;
      BOOL v13 = os_log_type_enabled(v9, v20);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v22 = "nw_connection_set_adaptive_write_handler";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_connection_set_adaptive_write_handler";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v20;
      if (os_log_type_enabled(v9, v20))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_connection_set_adaptive_write_handler";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FD2590( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_adaptive_write_handler_block_invoke(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(a1 + 40);
  int v2 = *(_DWORD *)(a1 + 48);
  id v3 = *(id *)(*(void *)(a1 + 32) + 144LL);
  id v4 = v1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_write_handler";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v12, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_write_handler";
          _os_log_impl(&dword_181A5C000, v13, v24, "%{public}s called with null handler", buf, 0xCu);
        }

        goto LABEL_37;
      }

      if (!v29)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_write_handler";
          _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_37;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_write_handler";
          _os_log_impl(&dword_181A5C000, v13, v26, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_37;
      }

      if (v27)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v32 = "nw_endpoint_handler_set_adaptive_write_handler";
        __int16 v33 = 2082;
        BOOL v34 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181FD2C78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_excessive_keepalive_handler(void *a1, int a2, int a3, void *a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a4;
  if (v7)
  {
    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    v17[2] = __nw_connection_set_excessive_keepalive_handler_block_invoke;
    v17[3] = &unk_189BC6EB0;
    id v18 = v7;
    int v20 = a2;
    int v21 = a3;
    id v19 = v8;
    nw_connection_async_if_needed(v18, v17);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v25 = "nw_connection_set_excessive_keepalive_handler";
  id v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v23 = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v10, &v23, &v22))
  {
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v23;
      if (os_log_type_enabled(v11, v23))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v25 = "nw_connection_set_excessive_keepalive_handler";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v23;
      BOOL v15 = os_log_type_enabled(v11, v23);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v25 = "nw_connection_set_excessive_keepalive_handler";
          __int16 v26 = 2082;
          BOOL v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v25 = "nw_connection_set_excessive_keepalive_handler";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = v23;
      if (os_log_type_enabled(v11, v23))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v25 = "nw_connection_set_excessive_keepalive_handler";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FD2F9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_excessive_keepalive_handler_block_invoke(void *a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v1 = (void *)a1[5];
  int32x2_t v2 = (int32x2_t)a1[6];
  id v3 = *(id *)(a1[4] + 144LL);
  id v4 = v1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v32 = "nw_endpoint_handler_set_keepalive_handler";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v12, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_keepalive_handler";
          _os_log_impl(&dword_181A5C000, v13, v24, "%{public}s called with null handler", buf, 0xCu);
        }

        goto LABEL_37;
      }

      if (!v29)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_keepalive_handler";
          _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_37;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_set_keepalive_handler";
          _os_log_impl(&dword_181A5C000, v13, v26, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_37;
      }

      if (v27)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v32 = "nw_endpoint_handler_set_keepalive_handler";
        __int16 v33 = 2082;
        BOOL v34 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181FD3694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_low_throughput_handler(void *a1, int a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a3;
  if (v5)
  {
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_set_low_throughput_handler_block_invoke;
    v15[3] = &unk_189BC9440;
    id v16 = v5;
    id v17 = v6;
    int v18 = a2;
    nw_connection_async_if_needed(v16, v15);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v22 = "nw_connection_set_low_throughput_handler";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v20 = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &v20, &v19))
  {
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v20;
      if (os_log_type_enabled(v9, v20))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_connection_set_low_throughput_handler";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v20;
      BOOL v13 = os_log_type_enabled(v9, v20);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v22 = "nw_connection_set_low_throughput_handler";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_connection_set_low_throughput_handler";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v20;
      if (os_log_type_enabled(v9, v20))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_connection_set_low_throughput_handler";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FD39B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_low_throughput_handler_block_invoke(uint64_t a1)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  int32x2_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 384);
  *(void *)(v3 + 384) = v2;

  int v5 = *(_DWORD *)(a1 + 48);
  id v6 = *(void **)(a1 + 32);
  if (!v5)
  {
    os_log_type_t v12 = v6;
    BOOL v13 = v12;
    if (v12)
    {
      nw_context_assert_queue(v12[3]);
      uint64_t v15 = (uint64_t)v13[46];
      if (v15)
      {
        nw_queue_cancel_source(v15, v14);
        *((_OWORD *)v13 + 22) = 0u;
        *((_OWORD *)v13 + 23) = 0u;
        *((_OWORD *)v13 + 21) = 0u;
      }

void sub_181FD450C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_metadata_changed_handler(void *a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (!v5)
  {
    __nwlog_obj();
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    dispatch_time_t v29 = "nw_connection_set_metadata_changed_handler";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        dispatch_time_t v29 = "nw_connection_set_metadata_changed_handler";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          dispatch_time_t v29 = "nw_connection_set_metadata_changed_handler";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446210;
        dispatch_time_t v29 = "nw_connection_set_metadata_changed_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        dispatch_time_t v29 = "nw_connection_set_metadata_changed_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FD4A90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_metadata_changed_handler_block_invoke(uint64_t a1)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void **)(a1 + 32);
  int32x2_t v2 = *(void **)(a1 + 40);
  uint64_t v4 = v3[33];
  id v5 = v3;
  id v6 = v2;
  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v38 = "nw_connection_get_metadata_changed_registration_on_nw_queue";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v14, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v38 = "nw_connection_get_metadata_changed_registration_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)__int128 buf = 136446466;
            id v38 = "nw_connection_get_metadata_changed_registration_on_nw_queue";
            __int16 v39 = 2082;
            uint64_t v40 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v38 = "nw_connection_get_metadata_changed_registration_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v38 = "nw_connection_get_metadata_changed_registration_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FD5018( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
}

void __nw_connection_set_metadata_changed_handler_block_invoke_45(uint64_t a1, void *a2, void *a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void **)*(id *)(a1 + 32);
  id v8 = v5;
  id v9 = v6;
  os_log_type_t v10 = v9;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v29,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_78:
        if (!v19) {
          goto LABEL_13;
        }
LABEL_79:
        free(v19);
        goto LABEL_13;
      }

      if (v30)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v29, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v20,  v43,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FD5AAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL56nw_connection_deliver_metadata_changed_event_on_nw_queueP24NWConcrete_nw_connectionPU36objcproto25OS_nw_protocol_definition8NSObjectPU34objcproto23OS_nw_protocol_metadataS1__block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void nw_connection_get_parent_uuid(void *a1, unsigned __int8 *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v23 = "nw_connection_get_parent_uuid";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v21;
      if (os_log_type_enabled(v7, v21))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v23 = "nw_connection_get_parent_uuid";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null out_uuid", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v21;
      BOOL v13 = os_log_type_enabled(v7, v21);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v23 = "nw_connection_get_parent_uuid";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null out_uuid, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v23 = "nw_connection_get_parent_uuid";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null out_uuid, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = v21;
      if (os_log_type_enabled(v7, v21))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v23 = "nw_connection_get_parent_uuid";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null out_uuid, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FD6014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __nw_connection_get_parent_uuid_block_invoke(uint64_t a1)
{
  uint64_t v1 = (__n128 *)(*(void *)(a1 + 32) + 468LL);
  __n128 result = *v1;
  *(__n128 *)*(void *)(a1 + 40) = *v1;
  return result;
}

void nw_connection_set_group_uuid(void *a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!a2)
  {
    __nwlog_obj();
    id v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v24 = "nw_connection_set_group_uuid";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v22;
      if (os_log_type_enabled(v8, v22))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v24 = "nw_connection_set_group_uuid";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null in_uuid", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v22;
      BOOL v14 = os_log_type_enabled(v8, v22);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v24 = "nw_connection_set_group_uuid";
          __int16 v25 = 2082;
          uint64_t v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null in_uuid, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v24 = "nw_connection_set_group_uuid";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null in_uuid, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v22;
      if (os_log_type_enabled(v8, v22))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v24 = "nw_connection_set_group_uuid";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null in_uuid, backtrace limit exceeded",  buf,  0xCu);
      }
    }

__n128 __nw_connection_set_group_uuid_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(__n128 **)(a1 + 40);
  __n128 result = *v1;
  *(__n128 *)(*(void *)(a1 + 32) + 484LL) = *v1;
  return result;
}

void nw_connection_get_group_uuid(void *a1, unsigned __int8 *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v23 = "nw_connection_get_group_uuid";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v21;
      if (os_log_type_enabled(v7, v21))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v23 = "nw_connection_get_group_uuid";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null out_uuid", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v21;
      BOOL v13 = os_log_type_enabled(v7, v21);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v23 = "nw_connection_get_group_uuid";
          __int16 v24 = 2082;
          __int16 v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null out_uuid, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v23 = "nw_connection_get_group_uuid";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null out_uuid, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = v21;
      if (os_log_type_enabled(v7, v21))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v23 = "nw_connection_get_group_uuid";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null out_uuid, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FD6A48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __nw_connection_get_group_uuid_block_invoke(uint64_t a1)
{
  uint64_t v1 = (__n128 *)(*(void *)(a1 + 32) + 484LL);
  __n128 result = *v1;
  *(__n128 *)*(void *)(a1 + 40) = *v1;
  return result;
}

void sub_181FD6E34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181FD6FB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

__n128 __Block_byref_object_copy__25636(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 48);
  __int128 v3 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v3;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = v2;
  __n128 result = *(__n128 *)(a2 + 96);
  __int128 v5 = *(_OWORD *)(a2 + 112);
  __int128 v6 = *(_OWORD *)(a2 + 128);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(_OWORD *)(a1 + 112) = v5;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = v6;
  *(__n128 *)(a1 + 96) = result;
  return result;
}

id nw_endpoint_create_custom(unsigned int a1, void *a2, void *a3)
{
  *(void *)&v64[13] = *MEMORY[0x1895F89C0];
  id v6 = a2;
  id v7 = a3;
  if (v6)
  {
    os_log_type_t v8 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_custom_endpoint);
    id v9 = v7;
    os_log_type_t v10 = (dispatch_data_s *)v6;
    os_log_type_t v11 = v10;
    if (!v8) {
      goto LABEL_21;
    }
    if (a1 <= 0x3E7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v12 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
      __int16 v63 = 1024;
      *(_DWORD *)__int16 v64 = 1000;
      BOOL v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v59 = 0;
      if (__nwlog_fault(v13, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v14 = (os_log_s *)(id)gLogObj;
          os_log_type_t v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
            __int16 v63 = 1024;
            *(_DWORD *)__int16 v64 = 1000;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Custom endpoint type values must start at %d",  buf,  0x12u);
          }
        }

        else if (v59)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v14 = (os_log_s *)(id)gLogObj;
          os_log_type_t v34 = type;
          BOOL v35 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v35)
            {
              *(_DWORD *)__int128 buf = 136446722;
              __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
              __int16 v63 = 1024;
              *(_DWORD *)__int16 v64 = 1000;
              v64[2] = 2082;
              *(void *)&v64[3] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v14,  v34,  "%{public}s Custom endpoint type values must start at %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(backtrace_string);
            if (!v13) {
              goto LABEL_20;
            }
            goto LABEL_10;
          }

          if (v35)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
            __int16 v63 = 1024;
            *(_DWORD *)__int16 v64 = 1000;
            _os_log_impl( &dword_181A5C000,  v14,  v34,  "%{public}s Custom endpoint type values must start at %d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v14 = (os_log_s *)(id)gLogObj;
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
            __int16 v63 = 1024;
            *(_DWORD *)__int16 v64 = 1000;
            _os_log_impl( &dword_181A5C000,  v14,  v40,  "%{public}s Custom endpoint type values must start at %d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      if (v13) {
LABEL_10:
      }
        free(v13);
LABEL_20:

      goto LABEL_21;
    }

    if (dispatch_data_get_size(v10) >= 0x401)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v16 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
      __int16 v63 = 1024;
      *(_DWORD *)__int16 v64 = 1024;
      os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v59 = 0;
      if (__nwlog_fault(v17, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v18 = (os_log_s *)(id)gLogObj;
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
            __int16 v63 = 1024;
            *(_DWORD *)__int16 v64 = 1024;
            _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s Custom data size must be no larger than %d",  buf,  0x12u);
          }
        }

        else if (v59)
        {
          os_log_type_t v37 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v18 = (os_log_s *)(id)gLogObj;
          os_log_type_t v38 = type;
          BOOL v39 = os_log_type_enabled(v18, type);
          if (v37)
          {
            if (v39)
            {
              *(_DWORD *)__int128 buf = 136446722;
              __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
              __int16 v63 = 1024;
              *(_DWORD *)__int16 v64 = 1024;
              v64[2] = 2082;
              *(void *)&v64[3] = v37;
              _os_log_impl( &dword_181A5C000,  v18,  v38,  "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v37);
            if (!v17) {
              goto LABEL_20;
            }
            goto LABEL_19;
          }

          if (v39)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
            __int16 v63 = 1024;
            *(_DWORD *)__int16 v64 = 1024;
            _os_log_impl( &dword_181A5C000,  v18,  v38,  "%{public}s Custom data size must be no larger than %d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v18 = (os_log_s *)(id)gLogObj;
          os_log_type_t v41 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
            __int16 v63 = 1024;
            *(_DWORD *)__int16 v64 = 1024;
            _os_log_impl( &dword_181A5C000,  v18,  v41,  "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      if (!v17) {
        goto LABEL_20;
      }
LABEL_19:
      free(v17);
      goto LABEL_20;
    }

    v58.os_log_type_t receiver = v8;
    v58.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_custom_endpoint;
    os_log_type_t v28 = objc_msgSendSuper2(&v58, sel_init);
    id v29 = v28;
    if (v28)
    {
      v28[62] = a1;
      BOOL v30 = _Block_copy(v9);
      int v31 = (void *)*((void *)v29 + 30);
      *((void *)v29 + 30) = v30;

      objc_storeStrong((id *)v29 + 29, a2);
      id v24 = v29;
      goto LABEL_37;
    }

    __nwlog_obj();
    id v49 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
    id v50 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if ((__nwlog_fault(v50, &type, &v59) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v52 = type;
        if (os_log_type_enabled(v51, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
          _os_log_impl(&dword_181A5C000, v51, v52, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v59)
      {
        char v54 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v55 = type;
        BOOL v56 = os_log_type_enabled(v51, type);
        if (v54)
        {
          if (v56)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
            __int16 v63 = 2082;
            *(void *)__int16 v64 = v54;
            _os_log_impl( &dword_181A5C000,  v51,  v55,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v54);
          goto LABEL_104;
        }

        if (v56)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
          _os_log_impl(&dword_181A5C000, v51, v55, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v57 = type;
        if (os_log_type_enabled(v51, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v62 = "-[NWConcrete_nw_custom_endpoint initWithType:resolver:data:]";
          _os_log_impl( &dword_181A5C000,  v51,  v57,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FD7DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_copy_custom_data(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  __int128 v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v24 = "nw_endpoint_copy_custom_data";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v7, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v24 = "nw_endpoint_copy_custom_data";
          _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null endpoint", buf, 0xCu);
        }

void sub_181FD8314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

size_t nw_endpoint_get_custom_data_length(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  __int128 v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v25 = "nw_endpoint_get_custom_data_length";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v8, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v25 = "nw_endpoint_get_custom_data_length";
          _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null endpoint", buf, 0xCu);
        }

void sub_181FD8840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_endpoint_copy_custom_resolver_block(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  __int128 v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v24 = "nw_endpoint_copy_custom_resolver_block";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v7, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v24 = "nw_endpoint_copy_custom_resolver_block";
          _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null endpoint", buf, 0xCu);
        }

void sub_181FD8D68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int *nw_protocol_demux_identifier()
{
  if (nw_protocol_demux_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_demux_identifier::onceToken, &__block_literal_global_25762);
  }
  return &g_demux_protocol_identifier;
}

double __nw_protocol_demux_identifier_block_invoke()
{
  unk_18C593DDE = 0LL;
  unk_18C593DD6 = 0LL;
  word_18C593DEE = 0;
  unk_18C593DE6 = 0LL;
  strcpy((char *)&g_demux_protocol_identifier, "demux");
  *(void *)&double result = 0x200000000LL;
  qword_18C593DF0 = 0x200000000LL;
  qword_18C593D38 = (uint64_t)nw_protocol_default_get_local;
  unk_18C593D40 = nw_protocol_default_get_remote;
  qword_18C593D28 = (uint64_t)nw_protocol_default_get_parameters;
  unk_18C593D30 = nw_protocol_default_get_path;
  qword_18C593D78 = (uint64_t)nw_protocol_default_output_finished;
  unk_18C593D80 = nw_protocol_default_get_output_local;
  qword_18C593DB8 = (uint64_t)nw_protocol_default_reset;
  unk_18C593DC0 = nw_protocol_default_input_flush;
  qword_18C593D88 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C593D90 = nw_protocol_default_waiting_for_output;
  qword_18C593D48 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C593D50 = nw_protocol_default_unregister_notification;
  qword_18C593D58 = (uint64_t)nw_protocol_default_notify;
  unk_18C593D60 = nw_protocol_default_updated_path;
  qword_18C593D98 = (uint64_t)nw_protocol_default_copy_info;
  unk_18C593DA0 = nw_protocol_default_add_listen_handler;
  qword_18C593DA8 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_18C593DB0 = nw_protocol_default_get_message_properties;
  g_demux_protocol_callbacks = (uint64_t)nw_protocol_demux_add_input_handler;
  unk_18C593CC0 = nw_protocol_demux_remove_input_handler;
  qword_18C593CC8 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_18C593CD0 = nw_protocol_demux_connect;
  qword_18C593CD8 = (uint64_t)nw_protocol_demux_disconnect;
  unk_18C593CE0 = nw_protocol_common_connected;
  qword_18C593CE8 = (uint64_t)nw_protocol_demux_disconnected;
  unk_18C593CF0 = nw_protocol_default_error;
  qword_18C593D68 = (uint64_t)nw_protocol_demux_supports_external_data;
  unk_18C593D70 = nw_protocol_default_input_finished;
  qword_18C593D18 = (uint64_t)nw_protocol_demux_finalize_output_frames;
  unk_18C593D20 = nw_protocol_default_link_state;
  qword_18C593D08 = (uint64_t)nw_protocol_demux_get_input_frames;
  unk_18C593D10 = nw_protocol_demux_get_output_frames;
  qword_18C593CF8 = (uint64_t)nw_protocol_demux_input_available;
  unk_18C593D00 = nw_protocol_default_output_available;
  return result;
}

BOOL nw_protocol_demux_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_demux_add_input_handler";
    __int16 v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v37)
      {
        uint64_t v27 = (os_log_s *)__nwlog_obj();
        os_log_type_t v28 = type;
        if (!os_log_type_enabled(v27, type)) {
          goto LABEL_67;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_demux_add_input_handler";
        id v29 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_66;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v31 = os_log_type_enabled(v27, type);
      if (!backtrace_string)
      {
        if (!v31) {
          goto LABEL_67;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_demux_add_input_handler";
        id v29 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_66;
      }

      if (v31)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_demux_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        os_log_type_t v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_54:
        _os_log_impl(&dword_181A5C000, v27, v28, v32, buf, 0x16u);
      }

uint64_t nw_protocol_demux_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    id v24 = "nw_protocol_demux_remove_input_handler";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        BOOL v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type;
        if (!os_log_type_enabled(v12, type)) {
          goto LABEL_48;
        }
        *(_DWORD *)__int128 buf = 136446210;
        id v24 = "nw_protocol_demux_remove_input_handler";
        os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_47;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (!v16) {
          goto LABEL_48;
        }
        *(_DWORD *)__int128 buf = 136446210;
        id v24 = "nw_protocol_demux_remove_input_handler";
        os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_47;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446466;
        id v24 = "nw_protocol_demux_remove_input_handler";
        __int16 v25 = 2082;
        __int16 v26 = backtrace_string;
        os_log_type_t v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
      }

uint64_t nw_protocol_demux_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v20 = "nw_protocol_demux_connect";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        uint64_t v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_41;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_protocol_demux_connect";
        BOOL v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_40;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v14) {
          goto LABEL_41;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_protocol_demux_connect";
        BOOL v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_40;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v20 = "nw_protocol_demux_connect";
        __int16 v21 = 2082;
        char v22 = backtrace_string;
        os_log_type_t v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_30:
        _os_log_impl(&dword_181A5C000, v10, v11, v15, buf, 0x16u);
      }

void nw_protocol_demux_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v19 = "nw_protocol_demux_disconnect";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v19 = "nw_protocol_demux_disconnect";
      os_log_type_t v11 = "%{public}s called with null protocol";
      goto LABEL_39;
    }

    if (!v16)
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v19 = "nw_protocol_demux_disconnect";
      os_log_type_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v19 = "nw_protocol_demux_disconnect";
      os_log_type_t v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_39;
    }

    if (v13)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v19 = "nw_protocol_demux_disconnect";
      __int16 v20 = 2082;
      __int16 v21 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_40:
    if (!v8) {
      return;
    }
    goto LABEL_41;
  }

  handle = (nw_protocol **)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v19 = "nw_protocol_demux_disconnect";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v19 = "nw_protocol_demux_disconnect";
      os_log_type_t v11 = "%{public}s called with null demux";
      goto LABEL_39;
    }

    if (!v16)
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v19 = "nw_protocol_demux_disconnect";
      os_log_type_t v11 = "%{public}s called with null demux, backtrace limit exceeded";
      goto LABEL_39;
    }

    BOOL v14 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (v14)
    {
      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v19 = "nw_protocol_demux_disconnect";
        __int16 v20 = 2082;
        __int16 v21 = v14;
        _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null demux, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v14);
      if (!v8) {
        return;
      }
LABEL_41:
      free(v8);
      return;
    }

    if (v15)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v19 = "nw_protocol_demux_disconnect";
      os_log_type_t v11 = "%{public}s called with null demux, no backtrace";
LABEL_39:
      _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      goto LABEL_40;
    }

    goto LABEL_40;
  }

  if (handle[6] == a2)
  {
    output_handler = a1->output_handler;
    if (output_handler)
    {
      callbacks = output_handler->callbacks;
      if (callbacks)
      {
        disconnect = (void (*)(nw_protocol *, nw_protocol *))callbacks->disconnect;
        if (disconnect) {
          goto LABEL_11;
        }
      }
    }
  }

  else if (a2)
  {
    unsigned int v4 = a2->callbacks;
    if (v4)
    {
      disconnect = (void (*)(nw_protocol *, nw_protocol *))v4->disconnected;
      if (disconnect)
      {
        output_handler = a2;
LABEL_11:
        disconnect(output_handler, a1);
      }
    }
  }

void nw_protocol_demux_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v21 = "nw_protocol_demux_disconnected";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (v19 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      if (!os_log_type_enabled(v9, v19)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v21 = "nw_protocol_demux_disconnected";
      os_log_type_t v11 = "%{public}s called with null protocol";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      BOOL v14 = os_log_type_enabled(v9, v19);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v21 = "nw_protocol_demux_disconnected";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8) {
          return;
        }
LABEL_42:
        free(v8);
        return;
      }

      if (!v14) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v21 = "nw_protocol_demux_disconnected";
      os_log_type_t v11 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v19;
      if (!os_log_type_enabled(v9, v19)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v21 = "nw_protocol_demux_disconnected";
      os_log_type_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

BOOL nw_protocol_demux_supports_external_data(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[88] != 0;
    }
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v14 = "nw_protocol_demux_supports_external_data";
    __int128 v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_supports_external_data";
        uint64_t v6 = "%{public}s called with null demux";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v11)
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_supports_external_data";
        uint64_t v6 = "%{public}s called with null demux, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_supports_external_data";
        uint64_t v6 = "%{public}s called with null demux, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v14 = "nw_protocol_demux_supports_external_data";
      __int16 v15 = 2082;
      BOOL v16 = backtrace_string;
      os_log_type_t v9 = "%{public}s called with null demux, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v14 = "nw_protocol_demux_supports_external_data";
  __int128 v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_supports_external_data";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_supports_external_data";
        uint64_t v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v14 = "nw_protocol_demux_supports_external_data";
      __int16 v15 = 2082;
      BOOL v16 = backtrace_string;
      os_log_type_t v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

uint64_t nw_protocol_demux_get_output_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a1->handle) {
      return nw_protocol_get_output_frames((uint64_t)a1->output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
    }
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v18 = "nw_protocol_demux_get_output_frames";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v18 = "nw_protocol_demux_get_output_frames";
        BOOL v10 = "%{public}s called with null demux";
        goto LABEL_31;
      }

      if (!v15)
      {
        BOOL v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v18 = "nw_protocol_demux_get_output_frames";
        BOOL v10 = "%{public}s called with null demux, backtrace limit exceeded";
        goto LABEL_31;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v18 = "nw_protocol_demux_get_output_frames";
          __int16 v19 = 2082;
          __int16 v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null demux, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v7) {
          return 0LL;
        }
        goto LABEL_33;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v18 = "nw_protocol_demux_get_output_frames";
        BOOL v10 = "%{public}s called with null demux, no backtrace";
LABEL_31:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v18 = "nw_protocol_demux_get_output_frames";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v18 = "nw_protocol_demux_get_output_frames";
      BOOL v10 = "%{public}s called with null protocol";
      goto LABEL_31;
    }

    if (!v15)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v18 = "nw_protocol_demux_get_output_frames";
      BOOL v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }

    char v11 = (char *)__nw_create_backtrace_string();
    BOOL v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (!v11)
    {
      if (!v12) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v18 = "nw_protocol_demux_get_output_frames";
      BOOL v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_31;
    }

    if (v12)
    {
      *(_DWORD *)__int128 buf = 136446466;
      char v18 = "nw_protocol_demux_get_output_frames";
      __int16 v19 = 2082;
      __int16 v20 = v11;
      _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v11);
  }

uint64_t nw_protocol_demux_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a1->handle) {
      return nw_protocol_finalize_output_frames((uint64_t)a1->output_handler, (uint64_t)a2);
    }
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v14 = "nw_protocol_demux_finalize_output_frames";
    __int128 v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v3, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_finalize_output_frames";
        uint64_t v6 = "%{public}s called with null demux";
        goto LABEL_31;
      }

      if (!v11)
      {
        unsigned int v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_finalize_output_frames";
        uint64_t v6 = "%{public}s called with null demux, backtrace limit exceeded";
        goto LABEL_31;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v14 = "nw_protocol_demux_finalize_output_frames";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null demux, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v3) {
          return 0LL;
        }
        goto LABEL_33;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_protocol_demux_finalize_output_frames";
        uint64_t v6 = "%{public}s called with null demux, no backtrace";
LABEL_31:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v14 = "nw_protocol_demux_finalize_output_frames";
    __int128 v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_protocol_demux_finalize_output_frames";
      uint64_t v6 = "%{public}s called with null protocol";
      goto LABEL_31;
    }

    if (!v11)
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_protocol_demux_finalize_output_frames";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }

    uint64_t v7 = (char *)__nw_create_backtrace_string();
    unsigned int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!v7)
    {
      if (!v8) {
        goto LABEL_32;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_protocol_demux_finalize_output_frames";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_31;
    }

    if (v8)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v14 = "nw_protocol_demux_finalize_output_frames";
      __int16 v15 = 2082;
      BOOL v16 = v7;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v7);
  }

uint64_t nw_protocol_demux_get_input_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
    __int16 v26 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v70) = 0;
    if (type != 17)
    {
      if (!(_BYTE)v70)
      {
        uint64_t v27 = (os_log_s *)__nwlog_obj();
        os_log_type_t v28 = type;
        if (!os_log_type_enabled(v27, (os_log_type_t)type)) {
          goto LABEL_68;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
        id v29 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_67;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v31 = os_log_type_enabled(v27, (os_log_type_t)type);
      if (!backtrace_string)
      {
        if (!v31) {
          goto LABEL_68;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
        id v29 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_67;
      }

      if (v31)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        os_log_type_t v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_47:
        _os_log_impl(&dword_181A5C000, v27, v28, v32, buf, 0x16u);
      }

void nw_protocol_demux_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v19 = "nw_protocol_demux_input_available";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v19 = "nw_protocol_demux_input_available";
      int v10 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      BOOL v12 = os_log_type_enabled(v8, v17);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v19 = "nw_protocol_demux_input_available";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v7) {
          return;
        }
LABEL_41:
        free(v7);
        return;
      }

      if (!v12) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v19 = "nw_protocol_demux_input_available";
      int v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v19 = "nw_protocol_demux_input_available";
      int v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t ___ZL33nw_protocol_demux_input_availableP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v4 = object;
  if (object)
  {
    uint64_t v5 = *(void *)(object + 24);
    if (v5)
    {
      uint64_t v6 = *(void (**)(uint64_t, void))(v5 + 64);
      if (v6)
      {
        v6(object, *(void *)(a1 + 32));
        return *(unsigned __int8 *)(*(void *)(a1 + 32) + 89LL);
      }
    }

    __nwlog_obj();
    BOOL v8 = *(const char **)(v4 + 16);
    if (!v8) {
      BOOL v8 = "invalid";
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v8 = "invalid";
  }

  *(_DWORD *)__int128 buf = 136446466;
  uint64_t v22 = "nw_protocol_demux_input_available_block_invoke";
  __int16 v23 = 2082;
  uint64_t v24 = v8;
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_36;
      }
      BOOL v12 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        BOOL v12 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_input_available_block_invoke";
      __int16 v23 = 2082;
      uint64_t v24 = v12;
      BOOL v13 = "%{public}s protocol %{public}s has invalid input_available callback";
      goto LABEL_35;
    }

    if (!v19)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_36;
      }
      os_log_type_t v17 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        os_log_type_t v17 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_input_available_block_invoke";
      __int16 v23 = 2082;
      uint64_t v24 = v17;
      BOOL v13 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v15 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v15)
      {
        char v16 = "invalid";
        if (v4 && *(void *)(v4 + 16)) {
          char v16 = *(const char **)(v4 + 16);
        }
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v22 = "nw_protocol_demux_input_available_block_invoke";
        __int16 v23 = 2082;
        uint64_t v24 = v16;
        __int16 v25 = 2082;
        __int16 v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_36;
    }

    if (v15)
    {
      uint64_t v18 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        uint64_t v18 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_input_available_block_invoke";
      __int16 v23 = 2082;
      uint64_t v24 = v18;
      BOOL v13 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v10, v11, v13, buf, 0x16u);
    }
  }

uint64_t ___ZL34nw_protocol_demux_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
      int v10 = "%{public}s called with null frame";
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      BOOL v12 = os_log_type_enabled(v8, type[0]);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (!v12)
      {
LABEL_23:
        if (v7) {
          free(v7);
        }
        goto LABEL_25;
      }

      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
      int v10 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
      int v10 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_23;
  }

  uint64_t v4 = *(void *)(a2 + 112);
  if (!v4)
  {
LABEL_26:
    uint64_t v6 = 0LL;
    goto LABEL_27;
  }

  if ((*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
LABEL_25:
    LODWORD(v4) = 0;
    goto LABEL_26;
  }

  LODWORD(v4) = *(_DWORD *)(a2 + 52);
  uint64_t v5 = *(unsigned int *)(a2 + 56);
  if ((_DWORD)v4) {
    LODWORD(v4) = v4 - (v5 + *(_DWORD *)(a2 + 60));
  }
  uint64_t v6 = *(void *)(a2 + 112) + v5;
LABEL_27:
  BOOL v14 = (void *)(a2 + 32);
  uint64_t v13 = *(void *)(a2 + 32);
  if (v13)
  {
    *(void *)(v13 + 40) = *(void *)(a2 + 40);
    BOOL v15 = *(void **)(a2 + 40);
  }

  else
  {
    BOOL v15 = *(void **)(a2 + 40);
    *(void *)(*(void *)(a1 + 56) + 8LL) = v15;
  }

  *BOOL v15 = v13;
  *BOOL v14 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  *(void *)__int128 buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  char v42 = 0;
  uint64_t v16 = *(void *)(a1 + 64);
  os_log_type_t v17 = *(char **)(v16 + 80);
  v29[0] = MEMORY[0x1895F87A8];
  v29[1] = 0x40000000LL;
  v29[2] = ___ZL34nw_protocol_demux_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2;
  v29[3] = &unk_189BB9DC8;
  int v35 = v4;
  uint64_t v31 = v6;
  v29[4] = buf;
  __int128 v32 = *(_OWORD *)(a1 + 72);
  uint64_t v33 = a2;
  uint64_t v34 = v16;
  __int128 v30 = *(_OWORD *)(a1 + 32);
  nw_hash_table_apply(v17, (uint64_t)v29);
  if (!*(_BYTE *)(*(void *)&buf[8] + 24LL))
  {
    if (*(void *)(a1 + 88) == *(void *)(*(void *)(a1 + 96) + 48LL))
    {
      if (gLogDatapath)
      {
        __int16 v26 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v27 = *(void *)(a1 + 64);
          if (v27) {
            os_log_type_t v28 = (const char *)(v27 + 90);
          }
          else {
            os_log_type_t v28 = "";
          }
          *(_DWORD *)os_log_type_t type = 136446466;
          os_log_type_t v38 = "nw_protocol_demux_get_input_frames_block_invoke";
          __int16 v39 = 2080;
          __int128 v40 = v28;
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Received frame for default input handler",  (uint8_t *)type,  0x16u);
        }
      }

      uint64_t v20 = *(void *)(a1 + 80);
      *(void *)(a2 + 32) = 0LL;
      uint64_t v21 = *(void **)(v20 + 8);
      *(void *)(a2 + 40) = v21;
      *uint64_t v21 = a2;
      *(void *)(v20 + _Block_object_dispose(va, 8) = v14;
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    }

    else
    {
      if (gLogDatapath)
      {
        __int16 v23 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v24 = *(void *)(a1 + 64);
          if (v24) {
            __int16 v25 = (const char *)(v24 + 90);
          }
          else {
            __int16 v25 = "";
          }
          *(_DWORD *)os_log_type_t type = 136446466;
          os_log_type_t v38 = "nw_protocol_demux_get_input_frames_block_invoke";
          __int16 v39 = 2080;
          __int128 v40 = v25;
          _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Received frame for default input handler, pending",  (uint8_t *)type,  0x16u);
        }
      }

      uint64_t v18 = *(void *)(a1 + 64);
      *(void *)(a2 + 32) = 0LL;
      char v19 = *(void **)(v18 + 72);
      *(void *)(a2 + 40) = v19;
      *char v19 = a2;
      *(void *)(v18 + 72) = v14;
      *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
    }
  }

  _Block_object_dispose(buf, 8);
  return 1LL;
}

uint64_t ___ZL34nw_protocol_demux_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_30( uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!*(void *)nw_hash_node_get_extra(a2)) {
    return 1LL;
  }
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v5 = object;
  if (object)
  {
    uint64_t v6 = *(void *)(object + 24);
    if (v6)
    {
      uint64_t v7 = *(void (**)(uint64_t, void))(v6 + 64);
      if (v7)
      {
        v7(object, *(void *)(a1 + 32));
        return 1LL;
      }
    }

    __nwlog_obj();
    os_log_type_t v9 = *(const char **)(v5 + 16);
    if (!v9) {
      os_log_type_t v9 = "invalid";
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v9 = "invalid";
  }

  *(_DWORD *)__int128 buf = 136446466;
  __int16 v23 = "nw_protocol_demux_get_input_frames_block_invoke";
  __int16 v24 = 2082;
  __int16 v25 = v9;
  int v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v10, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_37;
      }
      uint64_t v13 = "invalid";
      if (v5 && *(void *)(v5 + 16)) {
        uint64_t v13 = *(const char **)(v5 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v23 = "nw_protocol_demux_get_input_frames_block_invoke";
      __int16 v24 = 2082;
      __int16 v25 = v13;
      BOOL v14 = "%{public}s protocol %{public}s has invalid input_available callback";
      goto LABEL_36;
    }

    if (!v20)
    {
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_37;
      }
      uint64_t v18 = "invalid";
      if (v5 && *(void *)(v5 + 16)) {
        uint64_t v18 = *(const char **)(v5 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v23 = "nw_protocol_demux_get_input_frames_block_invoke";
      __int16 v24 = 2082;
      __int16 v25 = v18;
      BOOL v14 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v16 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v16)
      {
        os_log_type_t v17 = "invalid";
        if (v5 && *(void *)(v5 + 16)) {
          os_log_type_t v17 = *(const char **)(v5 + 16);
        }
        *(_DWORD *)__int128 buf = 136446722;
        __int16 v23 = "nw_protocol_demux_get_input_frames_block_invoke";
        __int16 v24 = 2082;
        __int16 v25 = v17;
        __int16 v26 = 2082;
        uint64_t v27 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_37;
    }

    if (v16)
    {
      char v19 = "invalid";
      if (v5 && *(void *)(v5 + 16)) {
        char v19 = *(const char **)(v5 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v23 = "nw_protocol_demux_get_input_frames_block_invoke";
      __int16 v24 = 2082;
      __int16 v25 = v19;
      BOOL v14 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_36:
      _os_log_impl(&dword_181A5C000, v11, v12, v14, buf, 0x16u);
    }
  }

BOOL ___ZL34nw_protocol_demux_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  for (i = *(uint64_t **)(extra + 16); i; i = (uint64_t *)*i)
  {
    uint64_t v6 = *((unsigned __int16 *)i + 9);
    if (*((_WORD *)i + 9))
    {
      uint64_t v7 = *((unsigned __int16 *)i + 8);
      if (*(_DWORD *)(a1 + 96) >= (v7 + v6))
      {
        BOOL v8 = (unsigned __int8 *)(*(void *)(a1 + 56) + v7);
        for (j = (unsigned __int8 *)i + 50; ; ++j)
        {
          int v10 = *v8++;
          if (((*(j - 30) ^ v10) & *j) != 0) {
            break;
          }
          if (!--v6)
          {
            *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
            if (*(void *)(a1 + 64) == a2)
            {
              uint64_t v13 = *(void *)(a1 + 72);
              uint64_t v14 = *(void *)(a1 + 80);
              *(void *)(v14 + 32) = 0LL;
              BOOL v15 = *(void **)(v13 + 8);
              *(void *)(v14 + 40) = v15;
              *BOOL v15 = v14;
              *(void *)(v13 + _Block_object_dispose(va, 8) = v14 + 32;
              if (gLogDatapath)
              {
                char v20 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v21 = *(void *)(a1 + 88);
                  if (v21) {
                    uint64_t v22 = (const char *)(v21 + 90);
                  }
                  else {
                    uint64_t v22 = "";
                  }
                  int v23 = 136446466;
                  __int16 v24 = "nw_protocol_demux_get_input_frames_block_invoke_2";
                  __int16 v25 = 2080;
                  __int16 v26 = v22;
                  _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Found frame matching pattern",  (uint8_t *)&v23,  0x16u);
                }
              }

              ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
            }

            else
            {
              uint64_t v11 = *(void *)(a1 + 80);
              *(void *)(v11 + 32) = 0LL;
              os_log_type_t v12 = *(void **)(extra + 8);
              *(void *)(v11 + 40) = v12;
              void *v12 = v11;
              *(void *)(extra + _Block_object_dispose(va, 8) = v11 + 32;
              if (gLogDatapath)
              {
                os_log_type_t v17 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v18 = *(void *)(a1 + 88);
                  if (v18) {
                    char v19 = (const char *)(v18 + 90);
                  }
                  else {
                    char v19 = "";
                  }
                  int v23 = 136446466;
                  __int16 v24 = "nw_protocol_demux_get_input_frames_block_invoke";
                  __int16 v25 = 2080;
                  __int16 v26 = v19;
                  _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Found frame matching pattern, pending",  (uint8_t *)&v23,  0x16u);
                }
              }

              *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
            }

            return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
          }
        }
      }
    }
  }

  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

uint64_t ___ZL30nw_protocol_demux_disconnectedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v4 = object;
  if (object)
  {
    uint64_t v5 = *(void *)(object + 24);
    if (v5)
    {
      uint64_t v6 = *(void (**)(uint64_t, void))(v5 + 48);
      if (v6)
      {
        v6(object, *(void *)(a1 + 32));
        return 1LL;
      }
    }

    __nwlog_obj();
    BOOL v8 = *(const char **)(v4 + 16);
    if (!v8) {
      BOOL v8 = "invalid";
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v8 = "invalid";
  }

  *(_DWORD *)__int128 buf = 136446466;
  uint64_t v22 = "nw_protocol_demux_disconnected_block_invoke";
  __int16 v23 = 2082;
  __int16 v24 = v8;
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_36;
      }
      os_log_type_t v12 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        os_log_type_t v12 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_disconnected_block_invoke";
      __int16 v23 = 2082;
      __int16 v24 = v12;
      uint64_t v13 = "%{public}s protocol %{public}s has invalid disconnected callback";
      goto LABEL_35;
    }

    if (!v19)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_36;
      }
      os_log_type_t v17 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        os_log_type_t v17 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_disconnected_block_invoke";
      __int16 v23 = 2082;
      __int16 v24 = v17;
      uint64_t v13 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v15 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v15)
      {
        BOOL v16 = "invalid";
        if (v4 && *(void *)(v4 + 16)) {
          BOOL v16 = *(const char **)(v4 + 16);
        }
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v22 = "nw_protocol_demux_disconnected_block_invoke";
        __int16 v23 = 2082;
        __int16 v24 = v16;
        __int16 v25 = 2082;
        __int16 v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_36;
    }

    if (v15)
    {
      uint64_t v18 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        uint64_t v18 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_disconnected_block_invoke";
      __int16 v23 = 2082;
      __int16 v24 = v18;
      uint64_t v13 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v10, v11, v13, buf, 0x16u);
    }
  }

void nw_protocol_demux_destroy(char *a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (*((char **)a1 + 5) != a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v30 = "nw_protocol_demux_destroy";
    __int128 v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v2))
    {
      __break(1u);
      return;
    }

    free(v2);
  }

  if (gLogDatapath)
  {
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      __int128 v30 = "nw_protocol_demux_destroy";
      __int16 v31 = 2080;
      __int128 v32 = a1 + 90;
      _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %s Destroying protocol", buf, 0x16u);
    }
  }

  __int128 v3 = (char *)*((void *)a1 + 10);
  if (v3)
  {
    v26[0] = MEMORY[0x1895F87A8];
    v26[1] = 0x40000000LL;
    v26[2] = ___ZL25nw_protocol_demux_destroyP8nw_demux_block_invoke;
    v26[3] = &__block_descriptor_tmp_20_25923;
    v26[4] = a1;
    nw_hash_table_apply(v3, (uint64_t)v26);
    uint64_t v5 = (os_unfair_lock_s *)*((void *)a1 + 10);
    if (v5)
    {
      _nw_hash_table_release(v5, v4);
      *((void *)a1 + 10) = 0LL;
    }
  }

  uint64_t v6 = (void *)*((void *)a1 + 8);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        if (!v6) {
          goto LABEL_29;
        }
        uint64_t v7 = (void (*)(void *, void, uint64_t))v6[10];
        BOOL v8 = (void *)v6[4];
        if (!v7) {
          break;
        }
        uint64_t v9 = v6[11];
        v6[10] = 0LL;
        v6[11] = 0LL;
        v7(v6, 0LL, v9);
        uint64_t v6 = v8;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      __int128 v30 = "__nw_frame_finalize";
      int v10 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v27 = 0;
      __int16 v25 = (char *)v10;
      if (__nwlog_fault(v10, &type, &v27))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v22 = (os_log_s *)__nwlog_obj();
          os_log_type_t log = type;
          if (!os_log_type_enabled(v22, type)) {
            goto LABEL_26;
          }
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v30 = "__nw_frame_finalize";
          os_log_type_t v11 = v22;
          os_log_type_t v12 = log;
          uint64_t v13 = "%{public}s called with null frame->finalizer";
LABEL_25:
          _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
          goto LABEL_26;
        }

        if (!v27)
        {
          __int16 v24 = (os_log_s *)__nwlog_obj();
          os_log_type_t logb = type;
          if (!os_log_type_enabled(v24, type)) {
            goto LABEL_26;
          }
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v30 = "__nw_frame_finalize";
          os_log_type_t v11 = v24;
          os_log_type_t v12 = logb;
          uint64_t v13 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_25;
        }

        backtrace_string = __nw_create_backtrace_string();
        nw_endpoint_t loga = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v14 = os_log_type_enabled(loga, type);
        BOOL v15 = (char *)backtrace_string;
        if (!backtrace_string)
        {
          if (!v14) {
            goto LABEL_26;
          }
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v30 = "__nw_frame_finalize";
          os_log_type_t v11 = loga;
          os_log_type_t v12 = v18;
          uint64_t v13 = "%{public}s called with null frame->finalizer, no backtrace";
          goto LABEL_25;
        }

        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int128 v30 = "__nw_frame_finalize";
          __int16 v31 = 2082;
          __int128 v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  loga,  v18,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          BOOL v15 = (char *)backtrace_string;
        }

        free(v15);
      }

uint64_t ___ZL38nw_protocol_demux_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v4 = object;
  if (object)
  {
    uint64_t v5 = *(void *)(object + 24);
    if (v5)
    {
      uint64_t v6 = *(void (**)(uint64_t, void))(v5 + 48);
      if (v6)
      {
        v6(object, *(void *)(a1 + 32));
        return 1LL;
      }
    }

    __nwlog_obj();
    BOOL v8 = *(const char **)(v4 + 16);
    if (!v8) {
      BOOL v8 = "invalid";
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v8 = "invalid";
  }

  *(_DWORD *)__int128 buf = 136446466;
  uint64_t v22 = "nw_protocol_demux_remove_input_handler_block_invoke";
  __int16 v23 = 2082;
  __int16 v24 = v8;
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_36;
      }
      os_log_type_t v12 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        os_log_type_t v12 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_remove_input_handler_block_invoke";
      __int16 v23 = 2082;
      __int16 v24 = v12;
      uint64_t v13 = "%{public}s protocol %{public}s has invalid disconnected callback";
      goto LABEL_35;
    }

    if (!v19)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_36;
      }
      os_log_type_t v17 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        os_log_type_t v17 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_remove_input_handler_block_invoke";
      __int16 v23 = 2082;
      __int16 v24 = v17;
      uint64_t v13 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v15 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v15)
      {
        uint64_t v16 = "invalid";
        if (v4 && *(void *)(v4 + 16)) {
          uint64_t v16 = *(const char **)(v4 + 16);
        }
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v22 = "nw_protocol_demux_remove_input_handler_block_invoke";
        __int16 v23 = 2082;
        __int16 v24 = v16;
        __int16 v25 = 2082;
        __int16 v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_36;
    }

    if (v15)
    {
      os_log_type_t v18 = "invalid";
      if (v4 && *(void *)(v4 + 16)) {
        os_log_type_t v18 = *(const char **)(v4 + 16);
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_demux_remove_input_handler_block_invoke";
      __int16 v23 = 2082;
      __int16 v24 = v18;
      uint64_t v13 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v10, v11, v13, buf, 0x16u);
    }
  }

BOOL nw_protocol_demux_destroy_entry(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  uint64_t extra = (void *)nw_hash_node_get_extra(a2);
  uint64_t v5 = (void *)*extra;
  if (*extra)
  {
    while (1)
    {
      while (1)
      {
        if (!v5) {
          goto LABEL_22;
        }
        uint64_t v6 = (void (*)(void *, void, uint64_t))v5[10];
        uint64_t v7 = (void *)v5[4];
        if (!v6) {
          break;
        }
        uint64_t v8 = v5[11];
        v5[10] = 0LL;
        v5[11] = 0LL;
        v6(v5, 0LL, v8);
        uint64_t v5 = v7;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v38 = "__nw_frame_finalize";
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v35 = 0;
      uint64_t v34 = (char *)v9;
      if (__nwlog_fault(v9, &type, &v35))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v31 = (os_log_s *)__nwlog_obj();
          os_log_type_t log = type;
          if (!os_log_type_enabled(v31, type)) {
            goto LABEL_19;
          }
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v38 = "__nw_frame_finalize";
          int v10 = v31;
          os_log_type_t v11 = log;
          os_log_type_t v12 = "%{public}s called with null frame->finalizer";
LABEL_18:
          _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
          goto LABEL_19;
        }

        if (!v35)
        {
          uint64_t v33 = (os_log_s *)__nwlog_obj();
          os_log_type_t logb = type;
          if (!os_log_type_enabled(v33, type)) {
            goto LABEL_19;
          }
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v38 = "__nw_frame_finalize";
          int v10 = v33;
          os_log_type_t v11 = logb;
          os_log_type_t v12 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_18;
        }

        backtrace_string = __nw_create_backtrace_string();
        nw_endpoint_t loga = (os_log_s *)__nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v13 = os_log_type_enabled(loga, type);
        BOOL v14 = (char *)backtrace_string;
        if (!backtrace_string)
        {
          if (!v13) {
            goto LABEL_19;
          }
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v38 = "__nw_frame_finalize";
          int v10 = loga;
          os_log_type_t v11 = v27;
          os_log_type_t v12 = "%{public}s called with null frame->finalizer, no backtrace";
          goto LABEL_18;
        }

        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v38 = "__nw_frame_finalize";
          __int16 v39 = 2082;
          __int128 v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  loga,  v27,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          BOOL v14 = (char *)backtrace_string;
        }

        free(v14);
      }

uint64_t ___ZL25nw_protocol_demux_destroyP8nw_demux_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t ___ZL35nw_demux_options_copy_pattern_chainP19nw_protocol_optionsP21nw_demux_pattern_headP16nw_demux_pattern_block_invoke( uint64_t a1, uint64_t **a2)
{
  return 1LL;
}

void nw_demux_copy_pattern_chain(uint64_t **a1, void *a2, _DWORD *a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v24 = "nw_demux_copy_pattern_chain";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_copy_pattern_chain";
      BOOL v15 = "%{public}s called with null old_head";
      goto LABEL_40;
    }

    if (!v21)
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_copy_pattern_chain";
      BOOL v15 = "%{public}s called with null old_head, backtrace limit exceeded";
      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v13 = (os_log_s *)__nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v17 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (!v17) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_copy_pattern_chain";
      BOOL v15 = "%{public}s called with null old_head, no backtrace";
      goto LABEL_40;
    }

    if (v17)
    {
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v24 = "nw_demux_copy_pattern_chain";
      __int16 v25 = 2082;
      uint64_t v26 = (uint64_t)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null old_head, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_41:
    if (!v12) {
      return;
    }
    goto LABEL_42;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v24 = "nw_demux_copy_pattern_chain";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_copy_pattern_chain";
      BOOL v15 = "%{public}s called with null new_head";
      goto LABEL_40;
    }

    if (!v21)
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_copy_pattern_chain";
      BOOL v15 = "%{public}s called with null new_head, backtrace limit exceeded";
      goto LABEL_40;
    }

    BOOL v18 = (char *)__nw_create_backtrace_string();
    BOOL v13 = (os_log_s *)__nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v19 = os_log_type_enabled(v13, type);
    if (v18)
    {
      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v24 = "nw_demux_copy_pattern_chain";
        __int16 v25 = 2082;
        uint64_t v26 = (uint64_t)v18;
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null new_head, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v18);
      if (!v12) {
        return;
      }
LABEL_42:
      free(v12);
      return;
    }

    if (v19)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_copy_pattern_chain";
      BOOL v15 = "%{public}s called with null new_head, no backtrace";
LABEL_40:
      _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
      goto LABEL_41;
    }

    goto LABEL_41;
  }

  uint64_t v4 = *a1;
  if (*a1)
  {
    uint64_t v6 = a3 + 5;
    uint64_t v7 = (char *)a3 + 50;
    do
    {
      if (a3 && !*a2)
      {
        a3[4] = *((_DWORD *)v4 + 4);
        memcpy(v6, (char *)v4 + 20, *((unsigned __int16 *)v4 + 9));
        memcpy(v7, (char *)v4 + 50, *((unsigned __int16 *)v4 + 9));
        *(void *)a3 = 0LL;
        uint64_t v8 = (void *)a2[1];
        *((void *)a3 + 1) = v8;
        *uint64_t v8 = a3;
        uint64_t v9 = a3;
      }

      else
      {
        uint64_t v9 = calloc(1uLL, 0x50uLL);
        if (!v9)
        {
          os_log_type_t v11 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int128 buf = 136446722;
          __int16 v24 = "strict_calloc";
          __int16 v25 = 2048;
          uint64_t v26 = 1LL;
          __int16 v27 = 2048;
          uint64_t v28 = 80LL;
          char v20 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort((uint64_t)v20))
          {
            __break(1u);
            return;
          }

          free(v20);
        }

        void v9[4] = *((_DWORD *)v4 + 4);
        memcpy(v9 + 5, (char *)v4 + 20, *((unsigned __int16 *)v4 + 9));
        memcpy((char *)v9 + 50, (char *)v4 + 50, *((unsigned __int16 *)v4 + 9));
        *(void *)uint64_t v9 = 0LL;
        int v10 = (void *)a2[1];
        *((void *)v9 + 1) = v10;
        void *v10 = v9;
      }

      a2[1] = v9;
      uint64_t v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

void *nw_protocol_demux_copy_definition()
{
  if (nw_protocol_demux_copy_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
  }
  uint64_t result = (void *)nw_protocol_demux_copy_definition::definition;
  if (nw_protocol_demux_copy_definition::definition) {
    return os_retain((void *)nw_protocol_demux_copy_definition::definition);
  }
  return result;
}

BOOL __nw_protocol_demux_copy_definition_block_invoke()
{
  if (nw_protocol_demux_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_demux_identifier::onceToken, &__block_literal_global_25762);
  }
  nw_protocol_demux_copy_definition::definition = (uint64_t)nw_protocol_definition_create_with_identifier((__int128 *)&g_demux_protocol_identifier);
  nw_protocol_definition_set_options_allocator( (void *)nw_protocol_demux_copy_definition::definition,  (uint64_t)nw_demux_allocate_options,  (uint64_t)nw_demux_copy_options,  (uint64_t)nw_demux_deallocate_options);
  nw_protocol_definition_set_options_equality_check( (void *)nw_protocol_demux_copy_definition::definition,  (uint64_t)nw_demux_option_is_equal);
  nw_protocol_definition_set_options_comparator( (void *)nw_protocol_demux_copy_definition::definition,  (uint64_t)nw_demux_compare_options);
  return nw_protocol_register_handle( (uint64_t)&g_demux_protocol_identifier,  (void *)nw_protocol_demux_copy_definition::definition,  (uint64_t)nw_protocol_demux_create,  0LL);
}

BOOL nw_demux_allocate_options(nw_protocol_definition *a1)
{
  id v1 = calloc(1uLL, 0x60uLL);
  if (v1) {
    goto LABEL_2;
  }
  __int128 v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
LABEL_2:
    *id v1 = 0LL;
    v1[1] = v1;
    return (BOOL)v1;
  }

  __break(1u);
  return result;
}

BOOL nw_demux_copy_options(nw_protocol_definition *a1, uint64_t **a2)
{
  __int128 v3 = calloc(1uLL, 0x60uLL);
  if (v3) {
    goto LABEL_2;
  }
  uint64_t v5 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  uint64_t v6 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v6);
  if (!result)
  {
    free(v6);
LABEL_2:
    void *v3 = 0LL;
    v3[1] = v3;
    nw_demux_copy_pattern_chain(a2, v3, (_DWORD *)v3 + 4);
    return (BOOL)v3;
  }

  __break(1u);
  return result;
}

void nw_demux_deallocate_options(nw_protocol_definition *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    __int128 v3 = (char *)*a2;
    if (*a2)
    {
      uint64_t v4 = (char *)(a2 + 2);
      do
      {
        uint64_t v6 = *(char **)v3;
        uint64_t v5 = (char **)*((void *)v3 + 1);
        if (*(void *)v3)
        {
          *((void *)v6 + 1) = v5;
          uint64_t v5 = (char **)*((void *)v3 + 1);
        }

        else
        {
          a2[1] = v5;
        }

        *uint64_t v5 = v6;
        *(void *)__int128 v3 = 0LL;
        *((void *)v3 + 1) = 0LL;
        if (v3 != v4) {
          free(v3);
        }
        __int128 v3 = v6;
      }

      while (v6);
    }

    free(a2);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v16 = "nw_demux_free_pattern_chain";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "nw_demux_free_pattern_chain";
      int v10 = "%{public}s called with null head";
      goto LABEL_24;
    }

    if (!v13)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "nw_demux_free_pattern_chain";
      int v10 = "%{public}s called with null head, backtrace limit exceeded";
      goto LABEL_24;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v16 = "nw_demux_free_pattern_chain";
        __int16 v17 = 2082;
        BOOL v18 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null head, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_25;
    }

    if (v12)
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "nw_demux_free_pattern_chain";
      int v10 = "%{public}s called with null head, no backtrace";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    }
  }

BOOL nw_demux_option_is_equal(nw_protocol_definition *a1, void **a2, void **a3)
{
  __int128 v3 = a3;
  uint64_t v4 = a2;
  int v5 = -1;
  uint64_t v6 = a2;
  do
  {
    uint64_t v6 = (void **)*v6;
    ++v5;
  }

  while (v6);
  int v7 = -1;
  uint64_t v8 = a3;
  do
  {
    uint64_t v8 = (void **)*v8;
    ++v7;
  }

  while (v8);
  if (v5 != v7) {
    return 0LL;
  }
  if (!v5) {
    return 1LL;
  }
  while (1)
  {
    __int128 v3 = (void **)*v3;
    uint64_t v4 = (void **)*v4;
    BOOL v9 = !v4 || v3 == 0LL;
    BOOL result = v9;
    if (v9) {
      break;
    }
    if (*((unsigned __int16 *)v4 + 8) == *((unsigned __int16 *)v3 + 8))
    {
      size_t v11 = *((unsigned __int16 *)v4 + 9);
      if ((_DWORD)v11 == *((unsigned __int16 *)v3 + 9)
        && !memcmp((char *)v4 + 20, (char *)v3 + 20, *((unsigned __int16 *)v4 + 9))
        && !memcmp((char *)v4 + 50, (char *)v3 + 50, v11))
      {
        continue;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t nw_demux_compare_options(uint64_t a1, void *a2, void *a3, int a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v24 = "nw_demux_compare_options";
    char v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_compare_options";
      uint64_t v16 = "%{public}s called with null handle1";
      goto LABEL_51;
    }

    if (!v21)
    {
      os_log_type_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_compare_options";
      uint64_t v16 = "%{public}s called with null handle1, backtrace limit exceeded";
      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_compare_options";
      uint64_t v16 = "%{public}s called with null handle1, no backtrace";
      goto LABEL_51;
    }

    if (v18)
    {
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v24 = "nw_demux_compare_options";
      __int16 v25 = 2082;
      uint64_t v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null handle1, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_52:
    if (!v13) {
      return 0LL;
    }
LABEL_53:
    free(v13);
    return 0LL;
  }

  uint64_t v4 = a3;
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v24 = "nw_demux_compare_options";
    char v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_compare_options";
      uint64_t v16 = "%{public}s called with null handle2";
      goto LABEL_51;
    }

    if (!v21)
    {
      os_log_type_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_compare_options";
      uint64_t v16 = "%{public}s called with null handle2, backtrace limit exceeded";
      goto LABEL_51;
    }

    uint64_t v19 = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v20 = os_log_type_enabled(v14, type);
    if (v19)
    {
      if (v20)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v24 = "nw_demux_compare_options";
        __int16 v25 = 2082;
        uint64_t v26 = v19;
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null handle2, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v19);
      if (!v13) {
        return 0LL;
      }
      goto LABEL_53;
    }

    if (v20)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v24 = "nw_demux_compare_options";
      uint64_t v16 = "%{public}s called with null handle2, no backtrace";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      goto LABEL_52;
    }

    goto LABEL_52;
  }

  uint64_t v6 = a2;
  int v7 = -1;
  uint64_t v8 = a2;
  do
  {
    uint64_t v8 = (void *)*v8;
    ++v7;
  }

  while (v8);
  int v9 = -1;
  int v10 = a3;
  do
  {
    int v10 = (void *)*v10;
    ++v9;
  }

  while (v10);
  if (v7 != v9) {
    return 0LL;
  }
  if (!v7) {
    return 1LL;
  }
  while (1)
  {
    uint64_t v4 = (void *)*v4;
    uint64_t v6 = (void *)*v6;
    BOOL v11 = !v6 || v4 == 0LL;
    uint64_t result = v11;
    if (v11) {
      break;
    }
    if (*((unsigned __int16 *)v6 + 8) == *((unsigned __int16 *)v4 + 8))
    {
      size_t v12 = *((unsigned __int16 *)v6 + 9);
      if ((_DWORD)v12 == *((unsigned __int16 *)v4 + 9)
        && !memcmp((char *)v6 + 20, (char *)v4 + 20, *((unsigned __int16 *)v6 + 9))
        && !memcmp((char *)v6 + 50, (char *)v4 + 50, v12))
      {
        continue;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t nw_protocol_demux_create( const nw_protocol_identifier *a1, nw_object *a2, nw_endpoint *a3, nw_parameters *a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  __memptr = 0LL;
  if (!posix_memalign(&__memptr, 8uLL, 0xB0uLL))
  {
    uint64_t result = (uint64_t)__memptr;
    if (__memptr) {
      goto LABEL_3;
    }
  }

  int v5 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  int v8 = 136446722;
  int v9 = "strict_memalign";
  __int16 v10 = 2048;
  uint64_t v11 = 8LL;
  __int16 v12 = 2048;
  uint64_t v13 = 176LL;
  uint64_t v6 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v6);
  if (!(_DWORD)result)
  {
    free(v6);
    uint64_t result = (uint64_t)__memptr;
LABEL_3:
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(void *)(result + 16) = &g_demux_protocol_identifier;
    *(void *)(result + 24) = &g_demux_protocol_callbacks;
    *(void *)(result + 40) = result;
    *(void *)(result + 72) = result + 64;
    return result;
  }

  __break(1u);
  return result;
}

NWConcrete_nw_protocol_options *nw_demux_create_options()
{
  if (nw_protocol_demux_copy_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
  }
  if (!nw_protocol_demux_copy_definition::definition) {
    return nw_protocol_create_options(0LL);
  }
  id v0 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
  nw_protocol_options_t options = nw_protocol_create_options(v0);
  if (v0) {
    os_release(v0);
  }
  return options;
}

BOOL nw_protocol_options_is_demux(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v14 = "nw_protocol_options_is_demux";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v5, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v14 = "nw_protocol_options_is_demux";
          int v8 = "%{public}s called with null options";
LABEL_22:
          _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
        }
      }

      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v14 = "nw_protocol_options_is_demux";
            __int16 v15 = 2082;
            uint64_t v16 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v14 = "nw_protocol_options_is_demux";
          int v8 = "%{public}s called with null options, no backtrace";
          goto LABEL_22;
        }
      }

      else
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v14 = "nw_protocol_options_is_demux";
          int v8 = "%{public}s called with null options, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }

void nw_demux_options_add_pattern(void *a1, __int16 a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v21 = "nw_demux_options_add_pattern";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (v19 != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = v19;
        if (!os_log_type_enabled(v6, v19)) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v21 = "nw_demux_options_add_pattern";
        int v8 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_46;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v19;
      BOOL v10 = os_log_type_enabled(v6, v19);
      if (!backtrace_string)
      {
        if (!v10) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v21 = "nw_demux_options_add_pattern";
        int v8 = "%{public}s called with null options, no backtrace";
        goto LABEL_46;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446466;
        char v21 = "nw_demux_options_add_pattern";
        __int16 v22 = 2082;
        __int16 v23 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_47;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = v19;
    if (!os_log_type_enabled(v6, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)__int128 buf = 136446210;
    char v21 = "nw_demux_options_add_pattern";
    int v8 = "%{public}s called with null options";
LABEL_46:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_47;
  }

  if (a3 < 0x1F)
  {
    if (a4)
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 0x40000000LL;
      v15[2] = __nw_demux_options_add_pattern_block_invoke;
      v15[3] = &__block_descriptor_tmp_7_25997;
      __int16 v16 = a2;
      __int16 v17 = a3;
      void v15[4] = a4;
      void v15[5] = a5;
      nw_protocol_options_access_handle(a1, v15);
      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v21 = "nw_demux_options_add_pattern";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v5, &v19, &v18))
    {
      if (v19 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = v19;
        if (!os_log_type_enabled(v6, v19)) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v21 = "nw_demux_options_add_pattern";
        int v8 = "%{public}s called with null pattern";
        goto LABEL_46;
      }

      if (!v18)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = v19;
        if (!os_log_type_enabled(v6, v19)) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v21 = "nw_demux_options_add_pattern";
        int v8 = "%{public}s called with null pattern, backtrace limit exceeded";
        goto LABEL_46;
      }

      char v11 = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v19;
      BOOL v14 = os_log_type_enabled(v6, v19);
      if (!v11)
      {
        if (!v14) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v21 = "nw_demux_options_add_pattern";
        int v8 = "%{public}s called with null pattern, no backtrace";
        goto LABEL_46;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446466;
        char v21 = "nw_demux_options_add_pattern";
        __int16 v22 = 2082;
        __int16 v23 = v11;
        uint64_t v13 = "%{public}s called with null pattern, dumping backtrace:%{public}s";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

BOOL __nw_demux_options_add_pattern_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!*(void *)a2)
  {
    uint64_t v4 = (_WORD *)(a2 + 16);
    *(_WORD *)(a2 + 32) = *(_WORD *)(a1 + 48);
    *(_WORD *)(a2 + 34) = *(_WORD *)(a1 + 50);
    memcpy((void *)(a2 + 36), *(const void **)(a1 + 32), *(unsigned __int16 *)(a1 + 50));
    int v9 = *(const void **)(a1 + 40);
    BOOL v10 = (void *)(a2 + 66);
    size_t v11 = *(unsigned __int16 *)(a1 + 50);
    if (v9) {
      memcpy(v10, v9, v11);
    }
    else {
      memset(v10, 255, v11);
    }
    BOOL v12 = *(void **)(a2 + 8);
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = v12;
    goto LABEL_11;
  }

  uint64_t v4 = calloc(1uLL, 0x50uLL);
  if (v4)
  {
LABEL_3:
    v4[8] = *(_WORD *)(a1 + 48);
    size_t v5 = *(unsigned __int16 *)(a1 + 50);
    v4[9] = v5;
    memcpy(v4 + 10, *(const void **)(a1 + 32), v5);
    uint64_t v6 = *(const void **)(a1 + 40);
    os_log_type_t v7 = v4 + 25;
    size_t v8 = *(unsigned __int16 *)(a1 + 50);
    if (v6) {
      memcpy(v7, v6, v8);
    }
    else {
      memset(v7, 255, v8);
    }
    *(void *)uint64_t v4 = 0LL;
    BOOL v12 = *(void **)(a2 + 8);
    *((void *)v4 + 1) = v12;
LABEL_11:
    void *v12 = v4;
    *(void *)(a2 + _Block_object_dispose(va, 8) = v4;
    return 1LL;
  }

  BOOL v14 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  __int16 v15 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v15);
  if (!result)
  {
    free(v15);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

void nw_demux_options_add_pattern_data(void *a1, __int16 a2, dispatch_data_t data)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v22 = "nw_demux_options_add_pattern_data";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (v20 != OS_LOG_TYPE_FAULT)
    {
      if (!v19)
      {
        size_t v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = v20;
        if (!os_log_type_enabled(v8, v20)) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_demux_options_add_pattern_data";
        BOOL v10 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_46;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v20;
      BOOL v12 = os_log_type_enabled(v8, v20);
      if (!backtrace_string)
      {
        if (!v12) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_demux_options_add_pattern_data";
        BOOL v10 = "%{public}s called with null options, no backtrace";
        goto LABEL_46;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v22 = "nw_demux_options_add_pattern_data";
        __int16 v23 = 2082;
        uint64_t v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_47;
    }

    size_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = v20;
    if (!os_log_type_enabled(v8, v20)) {
      goto LABEL_47;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v22 = "nw_demux_options_add_pattern_data";
    BOOL v10 = "%{public}s called with null options";
LABEL_46:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_47;
  }

  if (data)
  {
    size_t size = dispatch_data_get_size(data);
    if (size < 0x1F)
    {
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 0x40000000LL;
      v17[2] = __nw_demux_options_add_pattern_data_block_invoke;
      v17[3] = &__block_descriptor_tmp_8_26013;
      __int16 v18 = a2;
      void v17[4] = size;
      void v17[5] = data;
      nw_protocol_options_access_handle(a1, v17);
      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v22 = "nw_demux_options_add_pattern_data";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &v20, &v19))
    {
      if (v20 == OS_LOG_TYPE_FAULT)
      {
        size_t v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = v20;
        if (!os_log_type_enabled(v8, v20)) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_demux_options_add_pattern_data";
        BOOL v10 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH)";
        goto LABEL_46;
      }

      if (!v19)
      {
        size_t v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = v20;
        if (!os_log_type_enabled(v8, v20)) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_demux_options_add_pattern_data";
        BOOL v10 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), backtrace limit exceeded";
        goto LABEL_46;
      }

      uint64_t v13 = (char *)__nw_create_backtrace_string();
      size_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v20;
      BOOL v16 = os_log_type_enabled(v8, v20);
      if (!v13)
      {
        if (!v16) {
          goto LABEL_47;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v22 = "nw_demux_options_add_pattern_data";
        BOOL v10 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), no backtrace";
        goto LABEL_46;
      }

      if (v16)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v22 = "nw_demux_options_add_pattern_data";
        __int16 v23 = 2082;
        uint64_t v24 = v13;
        __int16 v15 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), dumping backtrace:%{public}s";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

BOOL __nw_demux_options_add_pattern_data_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!*(void *)a2)
  {
    uint64_t v4 = (_WORD *)(a2 + 16);
    *(_WORD *)(a2 + 32) = *(_WORD *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 32);
    *(_WORD *)(a2 + 34) = v8;
    os_log_type_t v9 = *(dispatch_data_s **)(a1 + 40);
    uint64_t v17 = 0LL;
    __int16 v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    uint64_t v20 = 0LL;
    uint64_t v13 = 0LL;
    BOOL v14 = &v13;
    uint64_t v15 = 0x2000000000LL;
    BOOL v16 = (char *)(a2 + 36);
    if (v9)
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      uint64_t v22 = (uint64_t)&unk_189BBF598;
      uint64_t v24 = &v13;
      uint64_t v25 = v8;
      __int16 v23 = &v17;
      dispatch_data_apply(v9, applier);
    }

    _Block_object_dispose(&v13, 8);
    _Block_object_dispose(&v17, 8);
    memset((void *)(a2 + 66), 255, *(void *)(a1 + 32));
    os_log_type_t v7 = *(void **)(a2 + 8);
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = v7;
    goto LABEL_9;
  }

  uint64_t v4 = calloc(1uLL, 0x50uLL);
  if (v4)
  {
LABEL_3:
    v4[8] = *(_WORD *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 32);
    v4[9] = v5;
    uint64_t v6 = *(dispatch_data_s **)(a1 + 40);
    uint64_t v17 = 0LL;
    __int16 v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    uint64_t v20 = 0LL;
    uint64_t v13 = 0LL;
    BOOL v14 = &v13;
    uint64_t v15 = 0x2000000000LL;
    BOOL v16 = (char *)(v4 + 10);
    if (v6)
    {
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      uint64_t v22 = (uint64_t)&unk_189BBF598;
      uint64_t v24 = &v13;
      uint64_t v25 = v5;
      __int16 v23 = &v17;
      dispatch_data_apply(v6, applier);
    }

    _Block_object_dispose(&v13, 8);
    _Block_object_dispose(&v17, 8);
    memset(v4 + 25, 255, *(void *)(a1 + 32));
    *(void *)uint64_t v4 = 0LL;
    os_log_type_t v7 = *(void **)(a2 + 8);
    *((void *)v4 + 1) = v7;
LABEL_9:
    *os_log_type_t v7 = v4;
    *(void *)(a2 + _Block_object_dispose(va, 8) = v4;
    return 1LL;
  }

  size_t v11 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446722;
  *(void *)&applier[4] = "strict_calloc";
  *(_WORD *)&applier[12] = 2048;
  *(void *)&applier[14] = 1LL;
  *(_WORD *)&applier[22] = 2048;
  uint64_t v22 = 80LL;
  BOOL v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

void nw_demux_options_enumerate_patterns(void *a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      v10[0] = MEMORY[0x1895F87A8];
      v10[1] = 0x40000000LL;
      v10[2] = __nw_demux_options_enumerate_patterns_block_invoke;
      v10[3] = &unk_189BB9D20;
      void v10[4] = a2;
      nw_protocol_options_access_handle(a1, v10);
      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v14 = "nw_demux_options_enumerate_patterns";
    __int128 v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v12 = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v2, &v12, &v11))
    {
      if (v12 == OS_LOG_TYPE_FAULT)
      {
        BOOL v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = v12;
        if (!os_log_type_enabled(v3, v12)) {
          goto LABEL_33;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_demux_options_enumerate_patterns";
        uint64_t v5 = "%{public}s called with null enumerate_block";
        goto LABEL_32;
      }

      if (!v11)
      {
        BOOL v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = v12;
        if (!os_log_type_enabled(v3, v12)) {
          goto LABEL_33;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_demux_options_enumerate_patterns";
        uint64_t v5 = "%{public}s called with null enumerate_block, backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v12;
      BOOL v9 = os_log_type_enabled(v3, v12);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v14 = "nw_demux_options_enumerate_patterns";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null enumerate_block, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v14 = "nw_demux_options_enumerate_patterns";
        uint64_t v5 = "%{public}s called with null enumerate_block, no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v14 = "nw_demux_options_enumerate_patterns";
    __int128 v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v12 = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (v12 == OS_LOG_TYPE_FAULT)
    {
      BOOL v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v12;
      if (!os_log_type_enabled(v3, v12)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_demux_options_enumerate_patterns";
      uint64_t v5 = "%{public}s called with null options";
      goto LABEL_32;
    }

    if (!v11)
    {
      BOOL v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v12;
      if (!os_log_type_enabled(v3, v12)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_demux_options_enumerate_patterns";
      uint64_t v5 = "%{public}s called with null options, backtrace limit exceeded";
      goto LABEL_32;
    }

    uint64_t v6 = (char *)__nw_create_backtrace_string();
    BOOL v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = v12;
    BOOL v7 = os_log_type_enabled(v3, v12);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "nw_demux_options_enumerate_patterns";
      uint64_t v5 = "%{public}s called with null options, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v14 = "nw_demux_options_enumerate_patterns";
      __int16 v15 = 2082;
      BOOL v16 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

uint64_t __nw_demux_options_enumerate_patterns_block_invoke(uint64_t a1, void *a2)
{
  do
    a2 = (void *)*a2;
  while (a2 && ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))() & 1) != 0);
  return 1LL;
}

void __nw_authentication_credential_storage_copy_shared_block_invoke()
{
  id v0 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_authentication_credential_storage);
  id v1 = (void *)nw_authentication_credential_storage_copy_shared_storage;
  nw_authentication_credential_storage_copy_shared_storage = (uint64_t)v0;

  uint64_t v2 = [MEMORY[0x189601ED0] sharedCredentialStorage];
  BOOL v3 = *(void **)(nw_authentication_credential_storage_copy_shared_storage + 8);
  *(void *)(nw_authentication_credential_storage_copy_shared_storage + _Block_object_dispose(va, 8) = v2;
}

NWConcrete_nw_authentication_credential_storage *nw_authentication_credential_storage_create_ns(void *a1)
{
  id v1 = a1;
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_authentication_credential_storage);
  credentialStorage = v2->credentialStorage;
  v2->credentialStorage = v1;

  return v2;
}

_DWORD *nw_authentication_credential_storage_copy_default_credential(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  BOOL v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      id v6 = v3[1];
      ns_protection_space = (void *)nw_authentication_challenge_get_ns_protection_space(v5);
      if (ns_protection_space)
      {
        [v6 defaultCredentialForProtectionSpace:ns_protection_space];
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
        if (v8)
        {
          BOOL v9 = -[NWConcrete_nw_authentication_credential initWithType:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_authentication_credential),  1);
          nw_authentication_credential_apply_ns(v9, v8);
        }

        else
        {
          BOOL v9 = 0LL;
        }

        BOOL v10 = v9;
      }

      else
      {
        BOOL v10 = 0LL;
      }

      goto LABEL_10;
    }

    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v25 = "nw_authentication_credential_storage_copy_default_credential";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null challenge";
          goto LABEL_37;
        }

        goto LABEL_38;
      }

      if (!v22)
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null challenge, backtrace limit exceeded";
          goto LABEL_37;
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v21 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null challenge, no backtrace";
          goto LABEL_37;
        }

        goto LABEL_38;
      }

      if (!v21) {
        goto LABEL_28;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v25 = "nw_authentication_credential_storage_copy_default_credential";
      __int16 v26 = 2082;
      uint64_t v27 = backtrace_string;
      uint64_t v20 = "%{public}s called with null challenge, dumping backtrace:%{public}s";
LABEL_27:
      _os_log_impl(&dword_181A5C000, v14, v15, v20, buf, 0x16u);
LABEL_28:

      free(backtrace_string);
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v25 = "nw_authentication_credential_storage_copy_default_credential";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v25 = "nw_authentication_credential_storage_copy_default_credential";
          BOOL v16 = "%{public}s called with null storage";
LABEL_37:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }

uint64_t nw_authentication_challenge_get_ns_protection_space(void *a1)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v31 = "nw_authentication_challenge_get_ns_protection_space";
    BOOL v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v21, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v31 = "nw_authentication_challenge_get_ns_protection_space";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null challenge", buf, 0xCu);
        }
      }

      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v31 = "nw_authentication_challenge_get_ns_protection_space";
            __int16 v32 = 2082;
            uint64_t v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }

        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v31 = "nw_authentication_challenge_get_ns_protection_space";
          _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v31 = "nw_authentication_challenge_get_ns_protection_space";
          _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FE1458(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_authentication_credential_apply_ns(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    [v4 user];
    id v6 = (void *)objc_claimAutoreleasedReturnValue();
    [v5 password];
    BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
    nw_authentication_credential_set_username(v3, (const char *)[v6 UTF8String]);
    nw_authentication_credential_set_password(v3, (const char *)[v7 UTF8String]);
    unint64_t v8 = [v5 persistence];
    if (v8 <= 3)
    {
      int v9 = v8;
      int v10 = v3;
      v10[3] = v9;
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  char v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v22 = "nw_authentication_credential_apply_ns";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_authentication_credential_apply_ns";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null credential", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v22 = "nw_authentication_credential_apply_ns";
          __int16 v23 = 2082;
          uint64_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_authentication_credential_apply_ns";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v22 = "nw_authentication_credential_apply_ns";
        _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_credential_storage_set_default_credential(void *a1, void *a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a2;
  id v7 = a3;
  unint64_t v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v28 = "nw_authentication_credential_storage_set_default_credential";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        BOOL v20 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v28 = "nw_authentication_credential_storage_set_default_credential";
            __int16 v29 = 2082;
            __int128 v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null storage, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_50:
          if (!v13) {
            goto LABEL_7;
          }
LABEL_51:
          free(v13);
          goto LABEL_7;
        }

        if (v20)
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v28 = "nw_authentication_credential_storage_set_default_credential";
          os_log_type_t v16 = "%{public}s called with null storage, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v28 = "nw_authentication_credential_storage_set_default_credential";
          os_log_type_t v16 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)__int128 buf = 136446210;
    char v28 = "nw_authentication_credential_storage_set_default_credential";
    os_log_type_t v16 = "%{public}s called with null storage";
    goto LABEL_48;
  }

  if (!v6)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v28 = "nw_authentication_credential_storage_set_default_credential";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v28 = "nw_authentication_credential_storage_set_default_credential";
          os_log_type_t v16 = "%{public}s called with null challenge, backtrace limit exceeded";
          goto LABEL_48;
        }

        goto LABEL_49;
      }

      BOOL v21 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (!v21)
      {
        if (v22)
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v28 = "nw_authentication_credential_storage_set_default_credential";
          os_log_type_t v16 = "%{public}s called with null challenge, no backtrace";
          goto LABEL_48;
        }

        goto LABEL_49;
      }

      if (v22)
      {
        *(_DWORD *)__int128 buf = 136446466;
        char v28 = "nw_authentication_credential_storage_set_default_credential";
        __int16 v29 = 2082;
        __int128 v30 = v21;
        __int16 v23 = "%{public}s called with null challenge, dumping backtrace:%{public}s";
LABEL_33:
        _os_log_impl(&dword_181A5C000, v14, v15, v23, buf, 0x16u);
      }

uint64_t nw_authentication_credential_create_ns(void *a1)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[2];

    id v4 = (void *)*((void *)v2 + 3);
    goto LABEL_3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v13 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446210;
  __int128 v40 = "nw_authentication_credential_get_username";
  os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (__nwlog_fault(v14, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v40 = "nw_authentication_credential_get_username";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null credential", buf, 0xCu);
      }

void nw_authentication_credential_cache_entry_set_http_authentication(void *a1, const void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = (const void *)v3[1];
    if (v5)
    {
      CFRelease(v5);
      v4[1] = 0LL;
    }

    if (a2) {
      v4[1] = CFRetain(a2);
    }
    goto LABEL_6;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_authentication_credential_cache_entry_set_http_authentication";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_cache_entry_set_http_authentication";
        uint64_t v10 = "%{public}s called with null cache_entry";
LABEL_20:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      }
    }

    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v16 = "nw_authentication_credential_cache_entry_set_http_authentication";
            __int16 v17 = 2082;
            os_log_type_t v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null cache_entry, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }

        if (!v12) {
          goto LABEL_21;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_cache_entry_set_http_authentication";
        uint64_t v10 = "%{public}s called with null cache_entry, no backtrace";
        goto LABEL_20;
      }

      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_cache_entry_set_http_authentication";
        uint64_t v10 = "%{public}s called with null cache_entry, backtrace limit exceeded";
        goto LABEL_20;
      }
    }

CFTypeRef nw_authentication_credential_cache_entry_get_http_authentication(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
        os_log_type_t v9 = "%{public}s called with null cache_entry";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }
    }

    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
            __int16 v17 = 2082;
            os_log_type_t v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null cache_entry, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v11) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
        os_log_type_t v9 = "%{public}s called with null cache_entry, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_cache_entry_get_http_authentication";
        os_log_type_t v9 = "%{public}s called with null cache_entry, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

void nw_authentication_credential_cache_entry_set_credential(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v4 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 16), a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v15 = "nw_authentication_credential_cache_entry_set_credential";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_authentication_credential_cache_entry_set_credential";
        os_log_type_t v9 = "%{public}s called with null cache_entry";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }
    }

    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v15 = "nw_authentication_credential_cache_entry_set_credential";
            __int16 v16 = 2082;
            __int16 v17 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null cache_entry, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v11) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_authentication_credential_cache_entry_set_credential";
        os_log_type_t v9 = "%{public}s called with null cache_entry, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_authentication_credential_cache_entry_set_credential";
        os_log_type_t v9 = "%{public}s called with null cache_entry, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

void nw_authentication_credential_cache_entry_set_for_proxy(uint64_t a1, char a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(_BYTE *)(a1 + 2_Block_object_dispose(va, 8) = a2;
    return;
  }

  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v12 = "nw_authentication_credential_cache_entry_set_for_proxy";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v12 = "nw_authentication_credential_cache_entry_set_for_proxy";
        id v6 = "%{public}s called with null cache_entry";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v12 = "nw_authentication_credential_cache_entry_set_for_proxy";
            __int16 v13 = 2082;
            os_log_type_t v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null cache_entry, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v8) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v12 = "nw_authentication_credential_cache_entry_set_for_proxy";
        id v6 = "%{public}s called with null cache_entry, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v12 = "nw_authentication_credential_cache_entry_set_for_proxy";
        id v6 = "%{public}s called with null cache_entry, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

void sub_181FE5574( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *a34)
{
  _Unwind_Resume(a1);
}

void sub_181FE6118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181FE71C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_proxy_unsatisfied_handler_should_use_proxy(void *a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t v27 = 136446210;
    *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
    __int16 v13 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v22 = 0;
    if (__nwlog_fault(v13, buf, &v22))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = buf[0];
        if (os_log_type_enabled(v14, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v27 = 136446210;
          *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null path", v27, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = buf[0];
        BOOL v18 = os_log_type_enabled(v14, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)os_log_type_t v27 = 136446466;
            *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
            *(_WORD *)&v27[12] = 2082;
            *(void *)&v27[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null path, dumping backtrace:%{public}s",  v27,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v18)
        {
          *(_DWORD *)os_log_type_t v27 = 136446210;
          *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null path, no backtrace", v27, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = buf[0];
        if (os_log_type_enabled(v14, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v27 = 136446210;
          *(void *)&v27[4] = "nw_endpoint_proxy_unsatisfied_handler_should_use_proxy";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null path, backtrace limit exceeded",  v27,  0xCu);
        }
      }
    }

void sub_181FE7F68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL35nw_endpoint_proxy_configs_are_equalPU22objcproto11OS_nw_array8NSObjectS1__block_invoke( uint64_t a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  nw_array_get_object_at_index(*(void *)(a1 + 32), a2);
  int v6 = (void *)objc_claimAutoreleasedReturnValue();
  char is_equal = nw_proxy_config_is_equal(v5, v6);

  if ((is_equal & 1) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  }
  uint64_t v8 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);

  return v8;
}

void sub_181FE8010(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_proxy_unsatisfied_handler_should_use_proxy_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  if (!nw_proxy_config_supports_unsatisfied_paths(a3)) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void sub_181FE80F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181FE826C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181FE8350( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL31nw_endpoint_proxy_check_for_pacP30NWConcrete_nw_endpoint_handlerPU22objcproto11OS_nw_array8NSObject_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = nw_proxy_config_get_mode(a3) & 0xFFFFFFFE;
  if (v4 == 2)
  {
    *(_BYTE *)(*(void *)(a1 + 32) + 97LL) |= 2u;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  return v4 != 2;
}

uint64_t __Block_byref_object_copy__26348(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__26349(uint64_t a1)
{
}

uint64_t ___ZL43nw_endpoint_proxy_check_for_companion_proxyPU22objcproto11OS_nw_array8NSObject_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v8 = *(void *)(v6 + 40);
  BOOL v7 = (id *)(v6 + 40);
  if (!v8)
  {
    objc_storeStrong(v7, a3);
LABEL_7:
    uint64_t v11 = 1LL;
    goto LABEL_8;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v9 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
    int v13 = 136446722;
    os_log_type_t v14 = "nw_endpoint_proxy_check_for_companion_proxy_block_invoke";
    __int16 v15 = 2112;
    uint64_t v16 = v10;
    __int16 v17 = 2112;
    id v18 = v5;
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Can only have a single companion proxy, got %@ and %@",  (uint8_t *)&v13,  0x20u);
  }

  uint64_t v11 = 0LL;
LABEL_8:

  return v11;
}

CFURLRef nw_endpoint_proxy_copy_synthesized_url(void *a1, void *a2, int a3, _BYTE *a4)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a2;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_copy_synthesized_url";
    BOOL v24 = (char *)_os_log_send_and_compose_impl();

    v52[0] = 16;
    char v51 = 0;
    if (v52[0] == 17)
    {
      __nwlog_obj();
      __int16 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v45 = v52[0];
      if (os_log_type_enabled(v25, (os_log_type_t)v52[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_copy_synthesized_url";
        _os_log_impl(&dword_181A5C000, v25, v45, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v51)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = v52[0];
      BOOL v48 = os_log_type_enabled(v25, (os_log_type_t)v52[0]);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_copy_synthesized_url";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v25,  v47,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_68;
      }

      if (v48)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_copy_synthesized_url";
        _os_log_impl(&dword_181A5C000, v25, v47, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = v52[0];
      if (os_log_type_enabled(v25, (os_log_type_t)v52[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_copy_synthesized_url";
        _os_log_impl( &dword_181A5C000,  v25,  v49,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181FE8F4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_endpoint_proxy_process_configP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;

  return 1LL;
}

uint64_t ___ZL32nw_endpoint_proxy_process_configP30NWConcrete_nw_endpoint_handler_block_invoke_2( void **a1, uint64_t a2, void *a3)
{
  id v4 = a3;

  return 1LL;
}

void sub_181FE907C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_endpoint_proxy_process_configP30NWConcrete_nw_endpoint_handler_block_invoke_3( void **a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ((nw_proxy_config_is_privacy_proxy(v4, 0LL) & 1) == 0) {
    nw_endpoint_proxy_add_config_if_applicable(a1[4], a1[5], v4, a1[6], a1[7], 0);
  }

  return 1LL;
}

void sub_181FE90E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_endpoint_proxy_process_configP30NWConcrete_nw_endpoint_handler_block_invoke_4( void **a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ((nw_proxy_config_is_privacy_proxy(v4, 0LL) & 1) == 0) {
    nw_endpoint_proxy_add_config_if_applicable(a1[4], a1[5], v4, a1[6], a1[7], 1);
  }

  return 1LL;
}

void sub_181FE914C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v141 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  int mode = nw_proxy_config_get_mode(v4);
  if ((mode & 0xFFFFFFFE) == 2)
  {
    int v6 = mode;
    id v121 = nw_endpoint_handler_copy_context(*(void **)(a1 + 32));
    if (v6 == 2)
    {
      id v7 = (os_log_s *)nw_proxy_config_copy_endpoint(v4);
      os_log_type_t v119 = v7;
      if (v7)
      {
        id v8 = v7;
        CFTypeRef v9 = nw_endpoint_copy_cfurl(v7);
        if (v9)
        {
          int v10 = *(void **)(a1 + 32);
          if (*(void *)(*(void *)(a1 + 40) + 64LL))
          {
            id v11 = nw_endpoint_handler_copy_parameters(v10);
            memset(bytes, 0, sizeof(bytes));
            int effective_audit_token = nw_parameters_get_effective_audit_token(v11, bytes);
            int v13 = (CFAllocatorRef *)MEMORY[0x189604DB0];
            if (effective_audit_token) {
              CFDataRef v14 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, 32LL);
            }
            else {
              CFDataRef v14 = 0LL;
            }
            os_log_type_t log = v9;
            effective_bundle_id = (const char *)nw_parameters_get_effective_bundle_id(v11);
            if (effective_bundle_id) {
              CFStringRef v76 = CFStringCreateWithCString(*v13, effective_bundle_id, 0x8000100u);
            }
            else {
              CFStringRef v76 = 0LL;
            }
            os_log_type_t v113 = *(const void **)(*(void *)(a1 + 40) + 64LL);
            char is_opaque = nw_parameters_get_https_proxy_is_opaque(v11);
            int https_proxy_over_tls = nw_parameters_get_https_proxy_over_tls(v11);
            int should_trust_invalid_certificates = nw_parameters_get_should_trust_invalid_certificates(v11);
            char is_dry_run = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 32));
            id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
            v128[0] = MEMORY[0x1895F87A8];
            v128[1] = 3221225472LL;
            v128[2] = ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_140;
            v128[3] = &unk_189BB9EF0;
            id v129 = *(id *)(a1 + 32);
            id v130 = *(id *)(a1 + 40);
            id v131 = v4;
            __int16 v25 = nw_pac_resolver_create_with_url( log,  v113,  v14,  v76,  v121,  is_opaque,  https_proxy_over_tls,  should_trust_invalid_certificates,  is_dry_run,  (uint64_t)id_string,  v128);
            if (v14) {
              CFRelease(v14);
            }
            if (v76) {
              CFRelease(v76);
            }

            CFTypeRef v9 = log;
LABEL_69:
            os_log_type_t v74 = v119;
            CFRelease(v9);
LABEL_70:

            if (v25)
            {
              uint64_t v86 = *(void *)(*(void *)(a1 + 40) + 72LL);
              if (v86
                || (BOOL v87 = nw_array_create(),
                    uint64_t v88 = *(void *)(a1 + 40),
                    os_log_type_t v89 = *(void **)(v88 + 72),
                    *(void *)(v88 + 72) = v87,
                    v89,
                    (uint64_t v86 = *(void *)(*(void *)(a1 + 40) + 72LL)) != 0))
              {
                nw_array_append(v86, v25);
              }

              nw_pac_resolver_start(v25);
              __int16 v15 = (os_log_s *)v121;
              id v121 = v25;
              goto LABEL_88;
            }

            if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) != 0)
            {
LABEL_89:

              goto LABEL_90;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            __int16 v15 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              BOOL v90 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
              os_log_type_t v91 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
              os_log_type_t v119 = v15;
              nw_endpoint_t v92 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
              logging_description = nw_endpoint_get_logging_description(v92);
              char v94 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
              os_log_type_t v95 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
              id v96 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
              *(_DWORD *)bytes = 136447746;
              *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
              *(_WORD *)&bytes[12] = 2082;
              *(void *)&bytes[14] = v90;
              *(_WORD *)&bytes[22] = 2082;
              *(void *)&bytes[24] = v91;
              __int16 v133 = 2082;
              __int16 v134 = logging_description;
              __int16 v135 = 2082;
              __int16 v136 = v94;
              __int16 v137 = 2082;
              __int16 v138 = v95;
              __int16 v139 = 2114;
              id v140 = v96;
              _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nw_pac_resolver_create returned nil",  bytes,  0x48u);

              goto LABEL_27;
            }

void sub_181FEA10C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_proxy_complete_resolve(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v214 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    __int16 v145 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
    __int16 v146 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    BOOL v206 = 0;
    if (__nwlog_fault(v146, type, &v206))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v148 = type[0];
        if (os_log_type_enabled(v147, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
          _os_log_impl(&dword_181A5C000, v147, v148, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v206)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v150 = type[0];
        BOOL v151 = os_log_type_enabled(v147, type[0]);
        if (backtrace_string)
        {
          if (v151)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v147,  v150,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_171;
        }

        if (v151)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
          _os_log_impl(&dword_181A5C000, v147, v150, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v160 = type[0];
        if (os_log_type_enabled(v147, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
          _os_log_impl( &dword_181A5C000,  v147,  v160,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FEBA74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
  _Block_object_dispose(&a30, 8);
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_proxy_has_unresolved_proxies(NWConcrete_nw_endpoint_handler *a1, BOOL *a2)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v39 = 0LL;
  BOOL v40 = &v39;
  uint64_t v41 = 0x2020000000LL;
  char v42 = 0;
  uint64_t v35 = 0LL;
  BOOL v36 = &v35;
  uint64_t v37 = 0x2020000000LL;
  char v38 = 0;
  id v4 = nw_endpoint_handler_copy_proxy(v3);
  id v5 = (unsigned __int8 *)*((void *)v4 + 7);
  v34[0] = MEMORY[0x1895F87A8];
  v34[1] = 3221225472LL;
  v34[2] = ___ZL40nw_endpoint_proxy_has_unresolved_proxiesP30NWConcrete_nw_endpoint_handlerPb_block_invoke;
  v34[3] = &unk_189BC52F8;
  void v34[4] = &v39;
  v34[5] = &v35;
  nw_array_apply(v5, (uint64_t)v34);
  if (!*((_BYTE *)v40 + 24) && !*((_BYTE *)v36 + 24))
  {
    if ((*((_BYTE *)v4 + 96) & 0xA0) == 0x20)
    {
      int minimize_logging = nw_endpoint_handler_get_minimize_logging(v3);
      char logging_disabled = nw_endpoint_handler_get_logging_disabled(v3);
      if (minimize_logging)
      {
        if ((logging_disabled & 1) != 0) {
          goto LABEL_19;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v8 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v3);
          BOOL v27 = nw_endpoint_handler_dry_run_string(v3);
          nw_endpoint_t v28 = nw_endpoint_handler_copy_endpoint(v3);
          logging_description = nw_endpoint_get_logging_description(v28);
          int v30 = nw_endpoint_handler_state_string(v3);
          uint64_t v31 = nw_endpoint_handler_mode_string(v3);
          id v32 = nw_endpoint_handler_copy_current_path(v3);
          *(_DWORD *)__int128 buf = 136447746;
          os_log_type_t v44 = "nw_endpoint_proxy_has_unresolved_proxies";
          __int16 v45 = 2082;
          uint64_t v46 = id_string;
          __int16 v47 = 2082;
          BOOL v48 = v27;
          __int16 v49 = 2082;
          id v50 = logging_description;
          __int16 v51 = 2082;
          BOOL v52 = v30;
          __int16 v53 = 2082;
          __int16 v54 = v31;
          __int16 v55 = 2114;
          id v56 = v32;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] direct attempts prohibited, not recommending",  buf,  0x48u);
        }

        goto LABEL_10;
      }

      if ((logging_disabled & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v8 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v9 = nw_endpoint_handler_get_id_string(v3);
          int v10 = nw_endpoint_handler_dry_run_string(v3);
          nw_endpoint_t v11 = nw_endpoint_handler_copy_endpoint(v3);
          CFURLRef v12 = nw_endpoint_get_logging_description(v11);
          BOOL v13 = nw_endpoint_handler_state_string(v3);
          CFDataRef v14 = nw_endpoint_handler_mode_string(v3);
          id v15 = nw_endpoint_handler_copy_current_path(v3);
          *(_DWORD *)__int128 buf = 136447746;
          os_log_type_t v44 = "nw_endpoint_proxy_has_unresolved_proxies";
          __int16 v45 = 2082;
          uint64_t v46 = v9;
          __int16 v47 = 2082;
          BOOL v48 = v10;
          __int16 v49 = 2082;
          id v50 = v12;
          __int16 v51 = 2082;
          BOOL v52 = v13;
          __int16 v53 = 2082;
          __int16 v54 = v14;
          __int16 v55 = 2114;
          id v56 = v15;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] direct attempts prohibited, not recommending",  buf,  0x48u);
        }

void sub_181FEC140( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);

  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);

  _Unwind_Resume(a1);
}

BOOL ___ZL34nw_endpoint_proxy_complete_resolveP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  int mode = nw_proxy_config_get_mode(a3);
  if (mode == 4) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return mode != 4;
}

uint64_t ___ZL34nw_endpoint_proxy_complete_resolveP30NWConcrete_nw_endpoint_handler_block_invoke_147( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3;
  uint64_t v194 = *MEMORY[0x1895F89C0];
  id v170 = a3;
  int mode = nw_proxy_config_get_mode(v170);
  if (mode != 4 && mode != 1) {
    goto LABEL_103;
  }
  int v7 = mode;
  if (*(_BYTE *)(a1 + 56) && !*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
    goto LABEL_100;
  }
  id v8 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  BOOL v9 = (NWConcrete_nw_endpoint_handler *)*(id *)(a1 + 32);
  id v10 = v170;
  id v166 = v8;
  v171 = v9;
  os_log_type_t v160 = v10;
  v169 = nw_endpoint_handler_copy_proxy(v9);
  uint64_t v158 = a1;
  id v159 = v3;
  int v157 = v7;
  if (!v10)
  {
    __nwlog_obj();
    nw_endpoint_t v92 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    nw_endpoint_t v178 = "nw_endpoint_proxy_add_child_for_config";
    nw_endpoint_t v93 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(iterate_block[0]) = 16;
    LOBYTE(v193) = 0;
    if (__nwlog_fault(v93, iterate_block, &v193))
    {
      if (LOBYTE(iterate_block[0]) == 17)
      {
        __nwlog_obj();
        id v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v95 = iterate_block[0];
        if (os_log_type_enabled(v94, iterate_block[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          nw_endpoint_t v178 = "nw_endpoint_proxy_add_child_for_config";
          _os_log_impl(&dword_181A5C000, v94, v95, "%{public}s called with null config", buf, 0xCu);
        }
      }

      else
      {
        if ((_BYTE)v193)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v112 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v113 = iterate_block[0];
          BOOL v114 = os_log_type_enabled(v112, iterate_block[0]);
          if (backtrace_string)
          {
            if (v114)
            {
              *(_DWORD *)__int128 buf = 136446466;
              nw_endpoint_t v178 = "nw_endpoint_proxy_add_child_for_config";
              __int16 v179 = 2082;
              nw_endpoint_t v180 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v112,  v113,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
          }

          else
          {
            if (v114)
            {
              *(_DWORD *)__int128 buf = 136446210;
              nw_endpoint_t v178 = "nw_endpoint_proxy_add_child_for_config";
              _os_log_impl(&dword_181A5C000, v112, v113, "%{public}s called with null config, no backtrace", buf, 0xCu);
            }
          }

          goto LABEL_173;
        }

        __nwlog_obj();
        id v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v129 = iterate_block[0];
        if (os_log_type_enabled(v94, iterate_block[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          nw_endpoint_t v178 = "nw_endpoint_proxy_add_child_for_config";
          _os_log_impl( &dword_181A5C000,  v94,  v129,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FEDA24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, void *a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, void *a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, void *a32)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_proxy_start_next_child(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v181 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v72 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v166 = "nw_endpoint_proxy_start_next_child";
    id v73 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v163 = 0;
    if (__nwlog_fault(v73, &type, &v163))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_multipath_service_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v75 = type;
        if (os_log_type_enabled(v74, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v166 = "nw_endpoint_proxy_start_next_child";
          _os_log_impl(&dword_181A5C000, v74, v75, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v163)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_multipath_service_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v77 = type;
        BOOL v78 = os_log_type_enabled(v74, type);
        if (backtrace_string)
        {
          if (v78)
          {
            *(_DWORD *)__int128 buf = 136446466;
            id v166 = "nw_endpoint_proxy_start_next_child";
            __int16 v167 = 2082;
            int v168 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v74,  v77,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_159;
        }

        if (v78)
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v166 = "nw_endpoint_proxy_start_next_child";
          _os_log_impl(&dword_181A5C000, v74, v77, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        nw_multipath_service_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v92 = type;
        if (os_log_type_enabled(v74, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v166 = "nw_endpoint_proxy_start_next_child";
          _os_log_impl( &dword_181A5C000,  v74,  v92,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FEF1FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_proxy_get_success_count(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1;
    nw_endpoint_handler_initialize_association(v3);
    id v4 = v3[7];

    if (!v4) {
      goto LABEL_7;
    }
    cached_content_for_protocol = (unsigned int *)nw_association_get_cached_content_for_protocol( v4,  (void *)nw_protocol_copy_proxy_definition(void)::proxy_definition);
    if (cached_content_for_protocol) {
      uint64_t v6 = *cached_content_for_protocol;
    }
    else {
LABEL_7:
    }
      uint64_t v6 = 0LL;

    goto LABEL_9;
  }

  __nwlog_obj();
  char v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  id v19 = "nw_endpoint_proxy_get_success_count";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_endpoint_proxy_get_success_count";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null child_handler", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v19 = "nw_endpoint_proxy_get_success_count";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null child_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_endpoint_proxy_get_success_count";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null child_handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_endpoint_proxy_get_success_count";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null child_handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FEF670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_proxy_get_failure_count(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1;
    nw_endpoint_handler_initialize_association(v3);
    id v4 = v3[7];

    if (!v4) {
      goto LABEL_7;
    }
    uint64_t cached_content_for_protocol = nw_association_get_cached_content_for_protocol( v4,  (void *)nw_protocol_copy_proxy_definition(void)::proxy_definition);
    if (cached_content_for_protocol) {
      uint64_t v6 = *(unsigned int *)(cached_content_for_protocol + 4);
    }
    else {
LABEL_7:
    }
      uint64_t v6 = 0LL;

    goto LABEL_9;
  }

  __nwlog_obj();
  char v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  id v19 = "nw_endpoint_proxy_get_failure_count";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_endpoint_proxy_get_failure_count";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null child_handler", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v19 = "nw_endpoint_proxy_get_failure_count";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null child_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_endpoint_proxy_get_failure_count";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null child_handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_endpoint_proxy_get_failure_count";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null child_handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FEF98C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL34nw_endpoint_proxy_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1)
{
  return nw_endpoint_proxy_start_next_child(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
}

unint64_t nw_endpoint_proxy_get_timeout_nanos(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  uint64_t v3 = a1;
  id v4 = &nw_setting_proxy_fast_rtt_delay_factor;
  if (a2)
  {
    int64_t v5 = 1LL;
  }

  else
  {
    id v4 = &nw_setting_proxy_rtt_delay_factor;
    int64_t v5 = 4LL;
  }

  int64_t int64_with_default = networkd_settings_get_int64_with_default(*v4, v5);
  if (v3)
  {
    unint64_t v7 = nw_endpoint_handler_get_child_timeout_nanos(v3) * int64_with_default;
    if (!a2) {
      goto LABEL_8;
    }
  }

  else
  {
    unint64_t v7 = 250000000 * int64_with_default;
    if (!a2) {
      goto LABEL_8;
    }
  }

  int64_t v8 = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_fast_max_delay_ms, 10000LL);
  if (v7 >= 1000000 * v8) {
    unint64_t v7 = 1000000 * v8;
  }
LABEL_8:

  return v7;
}

void sub_181FEFA64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL34nw_endpoint_proxy_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke_153( uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 100LL) |= 1u;
  return nw_endpoint_proxy_start_next_child(*(NWConcrete_nw_endpoint_handler **)(a1 + 40));
}

void ___ZL33nw_protocol_copy_proxy_definitionv_block_invoke()
{
  named = nw_protocol_definition_create_named(1, 0LL);
  id v1 = (void *)nw_protocol_copy_proxy_definition(void)::proxy_definition;
  nw_protocol_copy_proxy_definition(void)::proxy_definition = (uint64_t)named;

  nw_protocol_definition_set_cache_entry_deallocator( (void *)nw_protocol_copy_proxy_definition(void)::proxy_definition,  nw_proxy_deallocate_cache_entry);
  nw_protocol_definition_set_should_flush_cache_entry( (void *)nw_protocol_copy_proxy_definition(void)::proxy_definition,  nw_proxy_should_flush_cache_entry);
}

void nw_proxy_deallocate_cache_entry(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

size_t nw_proxy_should_flush_cache_entry(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5)
{
  id v7 = a4;
  id v8 = a5;
  BOOL v9 = v8;
  if ((a3 & 1) != 0) {
    size_t v10 = 1LL;
  }
  else {
    size_t v10 = nw_path_signature_changed_from_previous(v8, v7);
  }

  return v10;
}

void sub_181FEFB4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL38nw_endpoint_proxy_add_child_for_configP30NWConcrete_nw_endpoint_handlerPU29objcproto18OS_nw_proxy_config8NSObjectS3__block_invoke( uint64_t a1, void *a2)
{
  v8[2] = *MEMORY[0x1895F89C0];
  uint64_t v3 = a2;
  if (nw_protocol_options_is_serializable_tls(v3))
  {
    v8[0] = 0LL;
    v8[1] = 0LL;
    options_from_serializable = nw_tls_create_options_from_serializable(v3, (uint64_t)v8, 0LL);

    uint64_t v3 = options_from_serializable;
  }

  if (nw_protocol_options_is_tls(v3)
    && nw_parameters_get_should_trust_invalid_certificates(*(void **)(a1 + 32)))
  {
    int64_t v5 = v3;
    sec_protocol_options_set_peer_authentication_required(v5, 0);
  }

  uint64_t v6 = *(void **)(a1 + 40);
  id v7 = nw_protocol_options_copy(v3);
  nw_protocol_stack_append_application_protocol(v6, v7);
}

void sub_181FEFC38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_proxy_receive_report(void *a1, uint64_t a2, int a3, _WORD *a4, void *a5, void *a6)
{
  uint64_t v500 = *MEMORY[0x1895F89C0];
  BOOL v9 = a1;
  id v472 = a5;
  id v10 = a6;
  os_log_type_t v473 = v10;
  BOOL v474 = v9;
  if (!v10)
  {
    __nwlog_obj();
    int v306 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    v481 = "nw_endpoint_proxy_receive_report";
    v307 = (char *)_os_log_send_and_compose_impl();

    uu[0] = 16;
    char v478 = 0;
    if (__nwlog_fault(v307, uu, &v478))
    {
      if (uu[0] == 17)
      {
        __nwlog_obj();
        uint64_t v308 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v309 = uu[0];
        if (os_log_type_enabled(v308, (os_log_type_t)uu[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          v481 = "nw_endpoint_proxy_receive_report";
          _os_log_impl(&dword_181A5C000, v308, v309, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v478)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v308 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v313 = uu[0];
        BOOL v314 = os_log_type_enabled(v308, (os_log_type_t)uu[0]);
        if (backtrace_string)
        {
          if (v314)
          {
            *(_DWORD *)__int128 buf = 136446466;
            v481 = "nw_endpoint_proxy_receive_report";
            __int16 v482 = 2082;
            uint64_t v483 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v308,  v313,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_355;
        }

        if (v314)
        {
          *(_DWORD *)__int128 buf = 136446210;
          v481 = "nw_endpoint_proxy_receive_report";
          _os_log_impl(&dword_181A5C000, v308, v313, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v308 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v315 = uu[0];
        if (os_log_type_enabled(v308, (os_log_type_t)uu[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          v481 = "nw_endpoint_proxy_receive_report";
          _os_log_impl( &dword_181A5C000,  v308,  v315,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_355:
    if (v307) {
      free(v307);
    }
    goto LABEL_18;
  }

  os_log_type_t v11 = (unsigned int *)v10;
  uint64_t v12 = v11[29];

  if ((_DWORD)v12 != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v25 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      else {
        unint64_t v26 = off_189BBBBC0[v12];
      }
      *(_DWORD *)__int128 buf = 136446722;
      v481 = "nw_endpoint_proxy_receive_report";
      __int16 v482 = 2082;
      uint64_t v483 = (uint64_t)v26;
      __int16 v484 = 2082;
      uint64_t v485 = (uint64_t)"proxy";
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

LABEL_18:
    uint64_t v27 = 0LL;
LABEL_219:

    return v27;
  }

  os_log_type_t v13 = v11;
  char v14 = *((_BYTE *)v13 + 268);
  BOOL v471 = (NWConcrete_nw_endpoint_handler *)v13;

  int v464 = a3;
  if ((v14 & 0x20) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v15 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t log = v15;
      char v16 = v471;

      nw_endpoint_t v17 = v16;
      char v18 = *((_BYTE *)v471 + 268);

      if ((v18 & 1) != 0) {
        id v19 = "dry-run ";
      }
      else {
        id v19 = "";
      }
      nw_endpoint_t v460 = nw_endpoint_handler_copy_endpoint(v17);
      logging_description = nw_endpoint_get_logging_description(v460);
      int v21 = v17;
      uint64_t v22 = v21;
      uint64_t v23 = v21[30];
      else {
        uint64_t v24 = off_189BBBBF0[v23];
      }
      v455 = v24;

      id v28 = v22;
      v457 = logging_description;
      id v29 = "path";
      switch(v11[29])
      {
        case 0u:
          break;
        case 1u:
          id v29 = "resolver";
          break;
        case 2u:
          id v29 = nw_endpoint_flow_mode_string(v28[31]);
          break;
        case 3u:
          id v29 = "proxy";
          break;
        case 4u:
          id v29 = "fallback";
          break;
        case 5u:
          id v29 = "transform";
          break;
        default:
          id v29 = "unknown-mode";
          break;
      }

      os_log_type_t v452 = v29;

      int v30 = v28;
      os_unfair_lock_lock((os_unfair_lock_t)v30 + 28);
      id v31 = v30[8];
      os_unfair_lock_unlock((os_unfair_lock_t)v30 + 28);

      id v32 = v31;
      id_string = nw_endpoint_handler_get_id_string(v9);
      BOOL v34 = nw_endpoint_handler_dry_run_string(v9);
      nw_endpoint_t v35 = nw_endpoint_handler_copy_endpoint(v9);
      BOOL v36 = v19;
      v450 = a5;
      uint64_t v37 = nw_endpoint_get_logging_description(v35);
      id_str = v16->id_str;
      uint64_t v39 = nw_endpoint_handler_state_string(v474);
      char v40 = nw_endpoint_handler_mode_string(v474);
      id v41 = nw_endpoint_handler_copy_current_path(v474);
      *(_DWORD *)__int128 buf = 136449282;
      v481 = "nw_endpoint_proxy_receive_report";
      __int16 v482 = 2082;
      uint64_t v483 = (uint64_t)id_str;
      __int16 v484 = 2082;
      uint64_t v485 = (uint64_t)v36;
      __int16 v486 = 2082;
      os_log_type_t v487 = v457;
      __int16 v488 = 2082;
      v489 = v455;
      __int16 v490 = 2082;
      os_log_type_t v491 = v452;
      __int16 v492 = 2114;
      id v493 = v32;
      __int16 v494 = 2082;
      *(void *)os_log_type_t v495 = id_string;
      *(_WORD *)&v495[8] = 2082;
      *(void *)&v495[10] = v34;
      *(_WORD *)&v495[18] = 2082;
      *(void *)&v495[20] = v37;
      *(_WORD *)&v495[28] = 2082;
      *(void *)&v495[30] = v39;
      __int16 v496 = 2082;
      os_log_type_t v497 = v40;
      __int16 v498 = 2114;
      id v499 = v41;
      os_log_type_t v15 = log;
      _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received child report: [C%{publ ic}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x84u);

      a5 = v450;
    }

    BOOL v9 = v474;
    a3 = v464;
  }

  id v42 = nw_endpoint_handler_copy_proxy(v471);
  os_log_type_t v43 = (id *)((char *)v42 + 32);
  os_log_t loga = v42;
  if (*((NWConcrete_nw_endpoint_handler **)v42 + 4) == v9)
  {
    nw_endpoint_handler_report(v471, v9, a4, v472);
    BOOL v48 = v471;
    v48->int state = a3;

    nw_endpoint_handler_report(v48, 0LL, a4, 0LL);
LABEL_218:

    uint64_t v27 = 1LL;
    goto LABEL_219;
  }

  if (a4 && v472 && (*a4 & 0xFFFE) == 2)
  {
    char v44 = v472;
    int v45 = v44[2];

    if (v45 == 2)
    {
      nw_endpoint_t v46 = (nw_path *)nw_endpoint_handler_copy_current_path(v474);
      __int16 v47 = v46;
      if (v46
        && nw_path_has_dns(v46)
        && (nw_path_has_ipv4(v47)
         || nw_path_is_eligible_for_CrazyIvan46(v47) && nw_path_has_nat64_prefixes(v47)))
      {
        objc_storeStrong((id *)v42 + 10, a5);
      }
    }

    else
    {
      nw_endpoint_t v49 = v44;
      __int16 v47 = (nw_path *)*((void *)v42 + 10);
      *((void *)v42 + 10) = v49;
    }

    BOOL v9 = v474;
    a3 = v464;
  }

  memset(uu, 0, sizeof(uu));
  id v50 = nw_endpoint_handler_copy_parameters(v9);
  os_log_type_t v456 = v50;
  if (v50)
  {
    __int16 v51 = (id *)v50;
    id v461 = v51[23];

    int v52 = v461;
    if (v461)
    {
      id v53 = (unsigned __int8 *)v461;
      __int16 v55 = v53 + 170;
      unsigned int v54 = v53[170];

      nw_protocol_options_t v56 = v53;
      unsigned int v57 = *v55;

      id v58 = v56;
      *(_OWORD *)uu = *(_OWORD *)(v58 + 56);

      int v59 = (v54 >> 1) & 1;
      if (v59)
      {
        if ((*((_BYTE *)v42 + 96) & 2) != 0) {
          int v59 = 0;
        }
        LODWORD(v449) = v59;
      }

      else
      {
        LODWORD(v449) = 0;
      }

      id v71 = v58;
      unsigned int v72 = v71[171];

      id v73 = v71;
      int v74 = 1;
      switch(*((_DWORD *)v73 + 38))
      {
        case 1:
          int v74 = *((_DWORD *)v73 + 39);
          break;
        case 2:
          int v74 = 1002;
          break;
        case 3:
          int v74 = 1001;
          break;
        case 4:
          break;
        default:
          int v74 = 0;
          break;
      }

      int v458 = v54 & 1;
      HIDWORD(v449) = (v57 >> 2) & 1;
      int v451 = (v72 >> 6) & 1;
      BOOL v453 = v74 == 1;
      int v52 = v461;
    }

    else
    {
      uint64_t v449 = 0LL;
      BOOL v453 = 0;
      int v458 = 0;
      int v451 = 0;
    }

    BOOL v9 = v474;
    a3 = v464;
    if (v464 == 3)
    {
LABEL_86:
      if ((v451 | v458) == 1) {
        nw_endpoint_proxy_record_result(v9, 1);
      }
      if (v453)
      {
        if ((*((_BYTE *)v42 + 100) & 2) != 0)
        {
          char v75 = 2;
        }

        else
        {
          if ((*((_BYTE *)v42 + 100) & 1) == 0) {
            goto LABEL_96;
          }
          if ((*((_BYTE *)v42 + 100) & 4) != 0) {
            char v75 = 4;
          }
          else {
            char v75 = 3;
          }
        }
      }

      else
      {
        char v75 = 1;
      }

      *((_BYTE *)v42 + 99) = v75;
LABEL_96:
      if (v458)
      {
        BOOL v76 = v471;
        int privacy_stance = v76->privacy_stance;

        BOOL v9 = v474;
        a3 = v464;
        if (privacy_stance == 2) {
          goto LABEL_163;
        }
        if (nw_endpoint_handler_get_minimize_logging(v76))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v80 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            v317 = nw_endpoint_handler_get_id_string(v76);
            v318 = nw_endpoint_handler_dry_run_string(v76);
            nw_endpoint_t v319 = nw_endpoint_handler_copy_endpoint(v76);
            os_log_type_t v320 = nw_endpoint_get_logging_description(v319);
            v321 = nw_endpoint_handler_state_string(v76);
            v322 = nw_endpoint_handler_mode_string(v76);
            id v323 = nw_endpoint_handler_copy_current_path(v76);
            BOOL v324 = nw_endpoint_handler_get_id_string(v474);
            *(_DWORD *)__int128 buf = 136448258;
            v481 = "nw_endpoint_proxy_receive_report";
            __int16 v482 = 2082;
            uint64_t v483 = (uint64_t)v317;
            __int16 v484 = 2082;
            uint64_t v485 = (uint64_t)v318;
            __int16 v486 = 2082;
            os_log_type_t v487 = v320;
            __int16 v488 = 2082;
            v489 = v321;
            __int16 v490 = 2082;
            os_log_type_t v491 = v322;
            __int16 v492 = 2114;
            id v493 = v323;
            __int16 v494 = 2082;
            *(void *)os_log_type_t v495 = v324;
            *(_WORD *)&v495[8] = 2114;
            *(void *)&v495[10] = v461;
            _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Privacy proxy used ([C%{p ublic}s] %{public}@)",  buf,  0x5Cu);
          }
        }

        else
        {
          BOOL v78 = v76;
          BOOL v79 = (*((_BYTE *)v471 + 268) & 0x20) == 0;

          if (!v79)
          {
LABEL_105:
            if ((v449 & 0x100000000LL) == 0)
            {
              os_log_type_t v89 = v76;
              v76->int privacy_stance = 2;
            }

            BOOL v9 = v474;
            id v42 = loga;
            a3 = v464;
            if (uuid_is_null(uu)) {
              goto LABEL_163;
            }
            id v90 = nw_endpoint_handler_copy_current_path(v76);
            nw_path_report_error_to_agent(v90, uu, 0);

            goto LABEL_162;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v80 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v81 = nw_endpoint_handler_get_id_string(v78);
            uint64_t v82 = nw_endpoint_handler_dry_run_string(v78);
            nw_endpoint_t v83 = nw_endpoint_handler_copy_endpoint(v78);
            nw_endpoint_t v84 = nw_endpoint_get_logging_description(v83);
            nw_endpoint_t v85 = nw_endpoint_handler_state_string(v78);
            uint64_t v86 = nw_endpoint_handler_mode_string(v78);
            id v87 = nw_endpoint_handler_copy_current_path(v78);
            id v88 = nw_endpoint_handler_get_id_string(v474);
            *(_DWORD *)__int128 buf = 136448258;
            v481 = "nw_endpoint_proxy_receive_report";
            __int16 v482 = 2082;
            uint64_t v483 = (uint64_t)v81;
            __int16 v484 = 2082;
            uint64_t v485 = (uint64_t)v82;
            __int16 v486 = 2082;
            os_log_type_t v487 = v84;
            __int16 v488 = 2082;
            v489 = v85;
            __int16 v490 = 2082;
            os_log_type_t v491 = v86;
            __int16 v492 = 2114;
            id v493 = v87;
            __int16 v494 = 2082;
            *(void *)os_log_type_t v495 = v88;
            *(_WORD *)&v495[8] = 2114;
            *(void *)&v495[10] = v461;
            _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Privacy proxy used ([C%{p ublic}s] %{public}@)",  buf,  0x5Cu);
          }
        }

        goto LABEL_105;
      }

      if ((*((_BYTE *)v42 + 96) & 1) == 0)
      {
        a3 = v464;
        if ((v449 & 0x100000000LL) != 0) {
          goto LABEL_163;
        }
        os_log_type_t v91 = v471;
        v91->int privacy_stance = 1;

        goto LABEL_162;
      }

      os_log_type_t v92 = v471;
      int v93 = v92->privacy_stance;

      BOOL v9 = v474;
      a3 = v464;
      if (v93 == 4) {
        goto LABEL_163;
      }
      int minimize_logging = nw_endpoint_handler_get_minimize_logging(v92);
      char logging_disabled = nw_endpoint_handler_get_logging_disabled(v92);
      if (minimize_logging)
      {
        if ((logging_disabled & 1) != 0) {
          goto LABEL_120;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v96 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v448 = nw_endpoint_handler_get_id_string(v92);
          v325 = nw_endpoint_handler_dry_run_string(v92);
          nw_endpoint_t v326 = nw_endpoint_handler_copy_endpoint(v92);
          v327 = nw_endpoint_get_logging_description(v326);
          v328 = nw_endpoint_handler_state_string(v92);
          v329 = nw_endpoint_handler_mode_string(v92);
          id v330 = nw_endpoint_handler_copy_current_path(v92);
          *(_DWORD *)__int128 buf = 136447746;
          v481 = "nw_endpoint_proxy_receive_report";
          __int16 v482 = 2082;
          uint64_t v483 = (uint64_t)v448;
          __int16 v484 = 2082;
          uint64_t v485 = (uint64_t)v325;
          __int16 v486 = 2082;
          os_log_type_t v487 = v327;
          __int16 v488 = 2082;
          v489 = v328;
          __int16 v490 = 2082;
          os_log_type_t v491 = v329;
          __int16 v492 = 2114;
          id v493 = v330;
          _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Privacy proxy not used, connected directly",  buf,  0x48u);
        }
      }

      else
      {
        if ((logging_disabled & 1) != 0)
        {
LABEL_120:
          if ((v449 & 0x100000000LL) == 0)
          {
            id v104 = v92;
            v92->int privacy_stance = 4;

            BOOL v9 = v474;
            id v42 = loga;
          }

          a3 = v464;
          if (uuid_is_null(uu)) {
            goto LABEL_163;
          }
          id v105 = nw_endpoint_handler_copy_current_path(v92);
          nw_path_report_error_to_agent(v105, uu, 1300);

          goto LABEL_162;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v96 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
        {
          os_log_type_t v97 = nw_endpoint_handler_get_id_string(v92);
          BOOL v98 = nw_endpoint_handler_dry_run_string(v92);
          os_log_type_t v446 = v96;
          nw_endpoint_t v99 = nw_endpoint_handler_copy_endpoint(v92);
          __int16 v100 = nw_endpoint_get_logging_description(v99);
          nw_endpoint_t v101 = nw_endpoint_handler_state_string(v92);
          BOOL v102 = nw_endpoint_handler_mode_string(v92);
          id v103 = nw_endpoint_handler_copy_current_path(v92);
          *(_DWORD *)__int128 buf = 136447746;
          v481 = "nw_endpoint_proxy_receive_report";
          __int16 v482 = 2082;
          uint64_t v483 = (uint64_t)v97;
          __int16 v484 = 2082;
          uint64_t v485 = (uint64_t)v98;
          __int16 v486 = 2082;
          os_log_type_t v487 = v100;
          __int16 v488 = 2082;
          v489 = v101;
          __int16 v490 = 2082;
          os_log_type_t v491 = v102;
          __int16 v492 = 2114;
          id v493 = v103;
          _os_log_impl( &dword_181A5C000,  v446,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Privacy proxy not used, connected directly",  buf,  0x48u);

          int v96 = v446;
        }
      }

      BOOL v9 = v474;
      id v42 = loga;
      goto LABEL_120;
    }
  }

  else
  {
    uint64_t v449 = 0LL;
    id v461 = 0LL;
    BOOL v453 = 0;
    int v458 = 0;
    int v451 = 0;
    if (a3 == 3) {
      goto LABEL_86;
    }
  }

  if (a3 != 2 || !a4 || *a4 != 3) {
    goto LABEL_163;
  }
  int v60 = (unsigned __int16)a4[1];
  if (v60 == 5)
  {
LABEL_52:
    if (!v453) {
      *((_BYTE *)v42 + 100) |= 4u;
    }
    if ((*((_BYTE *)v42 + 97) & 4) != 0) {
      goto LABEL_163;
    }
    *((_BYTE *)v42 + 97) |= 4u;
    int v61 = v451;
    if (!*((void *)v42 + 11)) {
      int v61 = 0;
    }
    if (v61 == 1)
    {
      unint64_t v62 = v9;
      __int16 v63 = v62;
      if (v62)
      {
        __int16 v64 = v62;
        if (v62 != v471)
        {
          while (1)
          {
            uint64_t v65 = *((void *)v42 + 1);
            BOOL v66 = !v65 || v64 == 0LL;
            if (!v66)
            {
              nw_endpoint_t v68 = *(id **)(v65 + 16);
              id v67 = *(id **)(v65 + 24);
              if (v68 != v67)
              {
                while (*v68 != v64)
                {
                  if (++v68 == v67)
                  {
                    nw_endpoint_t v68 = v67;
                    break;
                  }
                }
              }

              if (v68 != v67) {
                break;
              }
            }

            id v69 = v64;
            __int16 v64 = (NWConcrete_nw_endpoint_handler *)v69[9];

            if (v64) {
              BOOL v70 = v64 == v471;
            }
            else {
              BOOL v70 = 1;
            }
            id v42 = loga;
            if (v70) {
              goto LABEL_154;
            }
          }

          __int16 v64 = v64;

          __int16 v63 = v64;
          id v42 = loga;
        }
      }

      else
      {
        __int16 v64 = 0LL;
      }

                    _os_log_impl(&dword_181A5C000, v226, v227, v228, buf, 0xCu);
                    goto LABEL_356;
                  }

                  if ((*(_BYTE *)(v63 + 276) & 0x10) != 0) {
                    goto LABEL_223;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  nw_endpoint_t v141 = (os_log_s *)gLogObj;
                  if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_223;
                  }
                  id v142 = *(void *)(v63 + 88);
                  if (v142) {
                    id v143 = *(_DWORD *)(v142 + 460);
                  }
                  else {
                    id v143 = -1;
                  }
                  time_t v166 = *(void *)(v63 + 64);
                  *(_DWORD *)__int128 buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&_BYTE buf[22] = 2080;
                  __int16 v531 = (uint64_t)" ";
                  *(_WORD *)int v532 = 1024;
                  *(_DWORD *)&v532[2] = v143;
                  *(_WORD *)&v532[6] = 2048;
                  *(void *)&v532[8] = v166;
                  _os_log_impl( &dword_181A5C000,  v141,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream",  buf,  0x30u);
                  if ((*(_BYTE *)(v63 + 276) & 8) != 0) {
                    goto LABEL_244;
                  }
LABEL_224:
                  nw_protocol_set_output_handler(v63, 0LL);
                  *(void *)(v63 + 56) = 0LL;
                  if (!*(void *)(v109 + 376))
                  {
                    if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                    {
                      id v159 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
                      {
                        os_log_type_t v160 = *(void *)(v63 + 88);
                        if (v160) {
                          nw_protocol_options_t v161 = *(_DWORD *)(v160 + 460);
                        }
                        else {
                          nw_protocol_options_t v161 = -1;
                        }
                        id v170 = *(void *)(v63 + 64);
                        *(_DWORD *)__int128 buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&_BYTE buf[22] = 2080;
                        __int16 v531 = (uint64_t)" ";
                        *(_WORD *)int v532 = 1024;
                        *(_DWORD *)&v532[2] = v161;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v170;
                        uint64_t v171 = v159;
                        char v172 = "%{public}s %{public}s%s<i%u:s%lld> no http connection metadata when attempting to start w"
                               "ebtransport http3 stream";
LABEL_377:
                        _os_log_impl(&dword_181A5C000, v171, OS_LOG_TYPE_ERROR, v172, buf, 0x30u);
                      }
                    }

void sub_181FF3CB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, void *a25, uint64_t a26, void *a27, uint64_t a28, void *a29)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_proxy_record_result(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v32 = "nw_endpoint_proxy_record_result";
    char v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v14, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v32 = "nw_endpoint_proxy_record_result";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null child_handler", buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)__int128 buf = 136446466;
            id v32 = "nw_endpoint_proxy_record_result";
            __int16 v33 = 2082;
            BOOL v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null child_handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }

        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v32 = "nw_endpoint_proxy_record_result";
          _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null child_handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v32 = "nw_endpoint_proxy_record_result";
          _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null child_handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181FF46E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_protocol_copy_proxy_definition(void)
{
  return (id)nw_protocol_copy_proxy_definition(void)::proxy_definition;
}

BOOL ___ZL32nw_endpoint_proxy_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke( uint64_t a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  unint64_t v7 = *(unsigned int *)(*(void *)(a1 + 32) + 24LL);
  if (v7 > a2 && *(id *)(a1 + 40) != v5) {
    nw_endpoint_handler_cancel(v5, 0LL, 0);
  }

  return v7 > a2;
}

void sub_181FF47C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL40nw_endpoint_proxy_has_unresolved_proxiesP30NWConcrete_nw_endpoint_handlerPb_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  int mode = nw_proxy_config_get_mode(a3);
  if ((mode & 0xFFFFFFFE) == 2)
  {
    uint64_t v5 = a1 + 32;
LABEL_5:
    *(_BYTE *)(*(void *)(*(void *)v5 + 8LL) + 24LL) = 1;
    return 1LL;
  }

  if (mode)
  {
    uint64_t v5 = a1 + 40;
    goto LABEL_5;
  }

  return 1LL;
}

void ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_140( uint64_t a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = v5[29];

    if ((_DWORD)v6 == 3)
    {
      if ((int)nw_endpoint_handler_get_state(*(void **)(a1 + 32)) <= 2)
      {
        BOOL v7 = nw_array_create();
        uint64_t v8 = *(void **)(a1 + 48);
        uint64_t v9 = *(unsigned __int8 **)(*(void *)(a1 + 40) + 56LL);
        v21[0] = MEMORY[0x1895F87A8];
        v21[1] = 3221225472LL;
        v21[2] = ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_141;
        v21[3] = &unk_189BC6DB0;
        id v22 = v8;
        id v23 = v3;
        id v10 = (id)v7;
        id v24 = v10;
        nw_array_apply(v9, (uint64_t)v21);
        objc_storeStrong((id *)(*(void *)(a1 + 40) + 56LL), (id)v7);
        nw_endpoint_proxy_complete_resolve(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        else {
          uint64_t v12 = off_189BBBBC0[v6];
        }
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        __int16 v29 = 2082;
        int v30 = (void *)v12;
        __int16 v31 = 2082;
        id v32 = "proxy";
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    goto LABEL_11;
  }

  __nwlog_obj();
  os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
  char v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v14, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
          __int16 v29 = 2082;
          int v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FF4C18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_144( uint64_t a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = v5[29];

    if ((_DWORD)v6 == 3)
    {
      if ((int)nw_endpoint_handler_get_state(*(void **)(a1 + 32)) <= 2)
      {
        BOOL v7 = nw_array_create();
        uint64_t v8 = *(void **)(a1 + 48);
        uint64_t v9 = *(unsigned __int8 **)(*(void *)(a1 + 40) + 56LL);
        v21[0] = MEMORY[0x1895F87A8];
        v21[1] = 3221225472LL;
        v21[2] = ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_145;
        v21[3] = &unk_189BC6DB0;
        id v22 = v8;
        id v23 = v3;
        id v10 = (id)v7;
        id v24 = v10;
        nw_array_apply(v9, (uint64_t)v21);
        objc_storeStrong((id *)(*(void *)(a1 + 40) + 56LL), (id)v7);
        nw_endpoint_proxy_complete_resolve(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        else {
          uint64_t v12 = off_189BBBBC0[v6];
        }
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        __int16 v29 = 2082;
        int v30 = (void *)v12;
        __int16 v31 = 2082;
        id v32 = "proxy";
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    goto LABEL_11;
  }

  __nwlog_obj();
  os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
  char v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v14, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
          __int16 v29 = 2082;
          int v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181FF5038( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_145( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (*(id *)(a1 + 32) == v4)
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_2_146;
    v7[3] = &unk_189BC85B0;
    uint64_t v5 = *(unsigned __int8 **)(a1 + 40);
    id v8 = *(id *)(a1 + 48);
    nw_array_apply(v5, (uint64_t)v7);
  }

  else
  {
    nw_array_append(*(void *)(a1 + 48), v4);
  }

  return 1LL;
}

uint64_t ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_2_146( uint64_t a1, int a2, void *object)
{
  return 1LL;
}

uint64_t ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_141( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (*(id *)(a1 + 32) == v4)
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_2;
    v7[3] = &unk_189BC85B0;
    uint64_t v5 = *(unsigned __int8 **)(a1 + 40);
    id v8 = *(id *)(a1 + 48);
    nw_array_apply(v5, (uint64_t)v7);
  }

  else
  {
    nw_array_append(*(void *)(a1 + 48), v4);
  }

  return 1LL;
}

uint64_t ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_2( uint64_t a1, int a2, void *object)
{
  return 1LL;
}

void nw_endpoint_proxy_add_config_if_applicable(void *a1, void *a2, void *a3, void *a4, void *a5, char a6)
{
  uint64_t v188 = *MEMORY[0x1895F89C0];
  os_log_type_t v11 = a1;
  id v12 = a2;
  id v13 = a3;
  uint64_t object = a4;
  id v158 = a5;
  id v156 = v12;
  if (v13)
  {
    char v152 = a6;
    *(void *)os_log_type_t type = 0LL;
    id v165 = type;
    uint64_t v166 = 0x3032000000LL;
    __int16 v167 = __Block_byref_object_copy__26348;
    uint64_t v168 = __Block_byref_object_dispose__26349;
    id v169 = v13;
    char v14 = nw_endpoint_handler_copy_proxy(v11);
    if (*((void *)v14 + 7))
    {
      nw_endpoint_t v154 = nw_endpoint_handler_copy_endpoint(v11);
      id v155 = nw_endpoint_handler_copy_current_path(v11);
      if (!nw_proxy_config_supports_connection(*((void **)v165 + 5), v154, v12, v155))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v11) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v39 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            id v144 = v14;
            id_string = nw_endpoint_handler_get_id_string(v11);
            id v41 = nw_endpoint_handler_dry_run_string(v11);
            nw_endpoint_t v42 = nw_endpoint_handler_copy_endpoint(v11);
            logging_description = nw_endpoint_get_logging_description(v42);
            char v44 = nw_endpoint_handler_state_string(v11);
            int v45 = nw_endpoint_handler_mode_string(v11);
            id v46 = nw_endpoint_handler_copy_current_path(v11);
            __int16 v47 = (const char *)*((void *)v165 + 5);
            *(_DWORD *)__int128 buf = 136448002;
            __int16 v173 = "nw_endpoint_proxy_add_config_if_applicable";
            __int16 v174 = 2082;
            __int16 v175 = (void *)id_string;
            __int16 v176 = 2082;
            __int16 v177 = v41;
            __int16 v178 = 2082;
            __int16 v179 = logging_description;
            __int16 v180 = 2082;
            uint64_t v181 = v44;
            __int16 v182 = 2082;
            __int16 v183 = v45;
            __int16 v184 = 2114;
            id v185 = v46;
            __int16 v186 = 2114;
            __int16 v187 = v47;
            _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping proxy %{public}@, not eligible",  buf,  0x52u);

            char v14 = v144;
          }
        }

        goto LABEL_153;
      }

      int v15 = nw_proxy_config_get_type(*((void **)v165 + 5));
      int is_opaque = nw_parameters_get_https_proxy_is_opaque(v12);
      if (v15 == 4001)
      {
        int v17 = is_opaque;
        if (nw_parameters_get_https_proxy_over_tls(v12))
        {
          int minimize_logging = nw_endpoint_handler_get_minimize_logging(v11);
          char logging_disabled = nw_endpoint_handler_get_logging_disabled(v11);
          if (minimize_logging)
          {
            if ((logging_disabled & 1) != 0)
            {
LABEL_13:
              uint64_t v28 = nw_proxy_config_copy(*((void **)v165 + 5));
              __int16 v29 = (void *)*((void *)v165 + 5);
              *((void *)v165 + 5) = v28;

              nw_proxy_config_set_type(*((void **)v165 + 5), 4002);
              *(_DWORD *)char v163 = 4;
              int v30 = (void *)*((void *)v165 + 5);
              id v31 = (id)g_tcp_definition;
              id v32 = nw_proxy_config_copy_protocol_stack(v30, v31, v163);

              id v33 = v156;
              if (v33)
              {
                BOOL v34 = (void *)nw_protocol_boringssl_copy_definition();
                nw_protocol_options_t options = nw_protocol_create_options(v34);

                uint64_t v36 = v33;
                if ((os_variant_allows_internal_security_policies() & 1) != 0)
                {
                  BOOL v37 = (v36[12] & 0x200000000000LL) == 0;

                  if (!v37)
                  {
                    uint64_t v38 = options;
                    sec_protocol_options_set_peer_authentication_required(v38, 0);

                    nw_protocol_options_t options = (NWConcrete_nw_protocol_options *)v38;
                  }
                }

                else
                {
                }

void sub_181FF6838( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, uint64_t a20, void *a21, void *a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, id a37)
{
  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL42nw_endpoint_proxy_add_config_if_applicableP30NWConcrete_nw_endpoint_handlerPU27objcproto16OS_nw_parameters8NSObjectPU29objcproto18OS_nw_proxy_configS1_PU22objcproto11OS_nw_arrayS1_S5_b_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  merged = nw_proxy_config_create_merged(*(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), v4);
  nw_array_append(*(void *)(*(void *)(a1 + 32) + 56LL), merged);
  if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40)) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v6 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
      id v8 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
      nw_endpoint_t v9 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
      logging_description = nw_endpoint_get_logging_description(v9);
      os_log_type_t v11 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
      id v12 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
      id v13 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
      int v15 = 136448002;
      os_log_type_t v16 = "nw_endpoint_proxy_add_config_if_applicable_block_invoke";
      __int16 v17 = 2082;
      os_log_type_t v18 = id_string;
      __int16 v19 = 2082;
      os_log_type_t v20 = v8;
      __int16 v21 = 2082;
      id v22 = logging_description;
      __int16 v23 = 2082;
      id v24 = v11;
      __int16 v25 = 2082;
      time_t v26 = v12;
      __int16 v27 = 2114;
      id v28 = v13;
      __int16 v29 = 2114;
      int v30 = merged;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding merged proxy %{public}@",  (uint8_t *)&v15,  0x52u);
    }
  }

  return 1LL;
}

void sub_181FF6BD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_proxy_copy_synthesized_url_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  identifier = nw_protocol_definition_get_identifier(a3);
  uint64_t v5 = (void *)nw_protocol_boringssl_identifier();
  if (!v5) {
    return 1LL;
  }
  BOOL v6 = nw_protocols_are_equal(identifier, v5);
  uint64_t result = 1LL;
  if (v6)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

void sub_181FF6DF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_proxy_match_pattern_to_endpoint(void *a1, const char *a2)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst) = 16;
    LOBYTE(v54) = 0;
    if (__dst == 17)
    {
      __nwlog_obj();
      uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = __dst;
      if (os_log_type_enabled(v39, (os_log_type_t)__dst))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
        _os_log_impl(&dword_181A5C000, v39, v40, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_104;
    }

    if (!(_BYTE)v54)
    {
      __nwlog_obj();
      uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v51 = __dst;
      if (os_log_type_enabled(v39, (os_log_type_t)__dst))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
        _os_log_impl( &dword_181A5C000,  v39,  v51,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v44 = __dst;
    BOOL v45 = os_log_type_enabled(v39, (os_log_type_t)__dst);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
        _os_log_impl(&dword_181A5C000, v39, v44, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_104;
    }

    if (v45)
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v39,  v44,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_84;
  }

  if (!a2)
  {
    __nwlog_obj();
    id v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst) = 16;
    LOBYTE(v54) = 0;
    if (__dst == 17)
    {
      __nwlog_obj();
      uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = __dst;
      if (os_log_type_enabled(v39, (os_log_type_t)__dst))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
        _os_log_impl(&dword_181A5C000, v39, v42, "%{public}s called with null pattern", buf, 0xCu);
      }

void sub_181FF7778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_181FF7804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_proxy_string_matches_pattern(const char *cStr, const char *a2)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  id v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x8000100u);
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v16 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
    __int16 v87 = 2082;
    os_log_type_t v88 = cStr;
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (__nwlog_fault(v17, &type, &v83))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_43;
        }
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        __int16 v87 = 2082;
        os_log_type_t v88 = cStr;
        int v20 = "%{public}s CFStringCreateWithCString(%{public}s) failed";
LABEL_41:
        os_log_type_t v42 = v18;
        os_log_type_t v43 = v19;
        goto LABEL_42;
      }

      if (!v83)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_43;
        }
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        __int16 v87 = 2082;
        os_log_type_t v88 = cStr;
        int v20 = "%{public}s CFStringCreateWithCString(%{public}s) failed, backtrace limit exceeded";
        goto LABEL_41;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = (os_log_s *)(id)gLogObj;
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (!v28)
        {
LABEL_43:

          if (!v17) {
            return 0LL;
          }
          goto LABEL_23;
        }

        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        __int16 v87 = 2082;
        os_log_type_t v88 = cStr;
        int v20 = "%{public}s CFStringCreateWithCString(%{public}s) failed, no backtrace";
        os_log_type_t v42 = v18;
        os_log_type_t v43 = v27;
LABEL_42:
        _os_log_impl(&dword_181A5C000, v42, v43, v20, buf, 0x16u);
        goto LABEL_43;
      }

      if (v28)
      {
        *(_DWORD *)__int128 buf = 136446722;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        __int16 v87 = 2082;
        os_log_type_t v88 = cStr;
        __int16 v89 = 2082;
        id v90 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v18,  v27,  "%{public}s CFStringCreateWithCString(%{public}s) failed, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
    }

    if (!v17) {
      return 0LL;
    }
LABEL_23:
    free(v17);
    return 0LL;
  }

  int v6 = v5;
  CFStringRef v7 = CFStringCreateWithCString(v4, a2, 0x8000100u);
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v21 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
    __int16 v87 = 2082;
    os_log_type_t v88 = a2;
    uint64_t v22 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (!__nwlog_fault((const char *)v22, &type, &v83))
    {
LABEL_61:
      if (v22) {
        free(v22);
      }
      CFRelease(v6);
      return 0LL;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v23 = (os_log_s *)(id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        __int16 v87 = 2082;
        os_log_type_t v88 = a2;
        __int16 v25 = "%{public}s CFStringCreateWithCString(%{public}s) failed";
LABEL_58:
        os_log_type_t v52 = v23;
        os_log_type_t v53 = v24;
LABEL_59:
        _os_log_impl(&dword_181A5C000, v52, v53, v25, buf, 0x16u);
      }
    }

    else
    {
      if (v83)
      {
        uint64_t v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v23 = (os_log_s *)(id)gLogObj;
        os_log_type_t v40 = type;
        BOOL v41 = os_log_type_enabled(v23, type);
        if (v39)
        {
          if (v41)
          {
            *(_DWORD *)__int128 buf = 136446722;
            os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
            __int16 v87 = 2082;
            os_log_type_t v88 = a2;
            __int16 v89 = 2082;
            id v90 = v39;
            _os_log_impl( &dword_181A5C000,  v23,  v40,  "%{public}s CFStringCreateWithCString(%{public}s) failed, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v39);
          goto LABEL_61;
        }

        if (!v41) {
          goto LABEL_60;
        }
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        __int16 v87 = 2082;
        os_log_type_t v88 = a2;
        __int16 v25 = "%{public}s CFStringCreateWithCString(%{public}s) failed, no backtrace";
        os_log_type_t v52 = v23;
        os_log_type_t v53 = v40;
        goto LABEL_59;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v23 = (os_log_s *)(id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        __int16 v87 = 2082;
        os_log_type_t v88 = a2;
        __int16 v25 = "%{public}s CFStringCreateWithCString(%{public}s) failed, backtrace limit exceeded";
        goto LABEL_58;
      }
    }

BOOL __nw_endpoint_proxy_handler_should_use_proxy_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  BOOL v4 = nw_proxy_config_supports_connection(a3, *(void **)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48));
  if (v4) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
  }
  return !v4;
}

uint64_t network_proxy_get_type(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v14 = "network_proxy_get_type";
    CFStringRef v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v14 = "network_proxy_get_type";
      id v8 = "%{public}s called with null proxy";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v14 = "network_proxy_get_type";
          __int16 v15 = 2082;
          id v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null proxy, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (v5)
        {
          free(v5);
          return 0xFFFFFFFFLL;
        }

        return 0xFFFFFFFFLL;
      }

      if (!v10) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v14 = "network_proxy_get_type";
      id v8 = "%{public}s called with null proxy, no backtrace";
    }

    else
    {
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v14 = "network_proxy_get_type";
      id v8 = "%{public}s called with null proxy, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_34;
  }

  id v1 = a1;
  if (v1[38] != 1)
  {

    return 0xFFFFFFFFLL;
  }

  int v2 = v1[39];

  if (v2 > 3000) {
    return (v2 - 3003) < 4 || (v2 - 4001) < 2 || (v2 - 3001) <= 1;
  }
  if (v2 <= 2000)
  {
    return 0xFFFFFFFFLL;
  }

  if (v2 == 2002) {
    unsigned int v4 = 3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v2 == 2001) {
    return 2LL;
  }
  else {
    return v4;
  }
}

xpc_object_t network_proxy_copy_host(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v20 = "network_proxy_copy_host";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v20 = "network_proxy_copy_host";
      id v13 = "%{public}s called with null proxy";
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v20 = "network_proxy_copy_host";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null proxy, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (!v15)
      {
LABEL_23:
        if (v10) {
          free(v10);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      int v20 = "network_proxy_copy_host";
      id v13 = "%{public}s called with null proxy, no backtrace";
    }

    else
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v20 = "network_proxy_copy_host";
      id v13 = "%{public}s called with null proxy, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_23;
  }

  id v1 = a1;
  id v2 = v1[5];

  if (!v2) {
    return 0LL;
  }
  id v3 = v2;
  int v4 = [v3 type];

  if ((v4 == 2 || (id v5 = v3, v6 = [v5 type], v5, v6 == 1))
    && (id v7 = v3, v8 = (const char *)[v7 hostname], v7, v8))
  {
    xpc_object_t v9 = xpc_string_create(v8);
  }

  else
  {
    xpc_object_t v9 = 0LL;
  }

  os_release(v3);
  return v9;
}

void sub_181FF8E88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t network_proxy_get_port(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v19 = "network_proxy_get_port";
    xpc_object_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v19 = "network_proxy_get_port";
      os_log_type_t v12 = "%{public}s called with null proxy";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v19 = "network_proxy_get_port";
          __int16 v20 = 2082;
          __int16 v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null proxy, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (!v14)
      {
LABEL_22:
        if (v9) {
          free(v9);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v19 = "network_proxy_get_port";
      os_log_type_t v12 = "%{public}s called with null proxy, no backtrace";
    }

    else
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v19 = "network_proxy_get_port";
      os_log_type_t v12 = "%{public}s called with null proxy, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_22;
  }

  id v1 = a1;
  id v2 = v1[5];

  if (!v2) {
    return 0LL;
  }
  id v3 = v2;
  int v4 = [v3 type];

  if (v4 == 2 || (id v5 = v3, v6 = [v5 type], v5, v6 == 1))
  {
    id v7 = v3;
    uint64_t v8 = [v7 port];
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  os_release(v3);
  return v8;
}

void sub_181FF9140(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_proxy_is_transparent(void *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v1 = a1;
    BOOL v2 = v1[38] != 1 || (v1[39] - 2003) < 0xFFFFFFFE;

    return v2;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  id v13 = "network_proxy_is_transparent";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v13 = "network_proxy_is_transparent";
        id v7 = "%{public}s called with null proxy";
LABEL_20:
        _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v13 = "network_proxy_is_transparent";
          __int16 v14 = 2082;
          BOOL v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null proxy, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v13 = "network_proxy_is_transparent";
        id v7 = "%{public}s called with null proxy, no backtrace";
        goto LABEL_20;
      }
    }

    else
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v13 = "network_proxy_is_transparent";
        id v7 = "%{public}s called with null proxy, backtrace limit exceeded";
        goto LABEL_20;
      }
    }
  }

void sub_181FFAA78(_Unwind_Exception *a1)
{
}

void sub_181FFAB8C(_Unwind_Exception *exception_object)
{
}

void sub_181FFB0F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_181FFB3DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __Block_byref_object_copy__26786(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__26787(uint64_t a1)
{
}

id nw_shoes_copy_udp_framer_definition()
{
  if (nw_shoes_copy_udp_framer_definition::onceToken != -1) {
    dispatch_once(&nw_shoes_copy_udp_framer_definition::onceToken, &__block_literal_global_26826);
  }
  return (id)nw_shoes_copy_udp_framer_definition::definition;
}

void __nw_shoes_copy_udp_framer_definition_block_invoke()
{
  nw_protocol_definition_t definition = nw_framer_create_definition("lv", 0, &__block_literal_global_3);
  id v1 = (void *)nw_shoes_copy_udp_framer_definition::definition;
  nw_shoes_copy_udp_framer_definition::nw_protocol_definition_t definition = (uint64_t)definition;
}

uint64_t __nw_shoes_copy_udp_framer_definition_block_invoke_2(uint64_t a1, void *a2)
{
  BOOL v2 = a2;
  nw_framer_set_input_handler(v2, &__block_literal_global_5_26828);
  nw_framer_set_output_handler(v2, &__block_literal_global_9_26829);

  return 1LL;
}

void __nw_shoes_copy_udp_framer_definition_block_invoke_7(uint64_t a1, void *a2, uint64_t a3, size_t a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  os_log_type_t v6 = v5;
  if (a4 < 0x10000)
  {
    *(_WORD *)output_buffer = bswap32(a4) >> 16;
    nw_framer_write_output(v5, output_buffer, 2uLL);
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v11 = "nw_shoes_copy_udp_framer_definition_block_invoke";
        __int16 v12 = 1024;
        LODWORD(v13) = a4;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s Shoes LV: Writing frame of length %u",  buf,  0x12u);
      }
    }

    nw_framer_write_output_no_copy(v6, a4);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v11 = "nw_shoes_copy_udp_framer_definition_block_invoke";
      __int16 v12 = 2048;
      size_t v13 = a4;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s Message length exceeds maximum: %zu",  buf,  0x16u);
    }
  }
}

void sub_181FFC1E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_shoes_copy_udp_framer_definition_block_invoke_3(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  BOOL v2 = a2;
  uint64_t v3 = MEMORY[0x1895F87A8];
  uint64_t v4 = 2LL;
  while (1)
  {
    *(_WORD *)temp_buffer = 0;
    uint64_t v11 = 0LL;
    __int16 v12 = &v11;
    uint64_t v13 = 0x2020000000LL;
    __int16 v14 = 0;
    parse[0] = v3;
    parse[1] = 3221225472LL;
    parse[2] = __nw_shoes_copy_udp_framer_definition_block_invoke_4;
    parse[3] = &unk_189BBA008;
    parse[4] = &v11;
    if (!nw_framer_parse_input(v2, 2uLL, 2uLL, temp_buffer, parse)) {
      break;
    }
    if (gLogDatapath)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v8 = *((unsigned __int16 *)v12 + 12);
        *(_DWORD *)__int128 buf = 136446466;
        char v17 = "nw_shoes_copy_udp_framer_definition_block_invoke_3";
        __int16 v18 = 1024;
        int v19 = v8;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s Shoes LV: Reading frame of length %u",  buf,  0x12u);
      }
    }

    id v5 = nw_framer_message_create(v2);
    BOOL v6 = nw_framer_deliver_input_no_copy(v2, *((unsigned __int16 *)v12 + 12), v5, 1);

    if (!v6)
    {
      uint64_t v4 = 0LL;
      break;
    }

    _Block_object_dispose(&v11, 8);
  }

  _Block_object_dispose(&v11, 8);

  return v4;
}

void sub_181FFC3C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_shoes_copy_udp_framer_definition_block_invoke_4( uint64_t a1, unsigned __int16 *a2, unint64_t a3)
{
  uint64_t result = 0LL;
  if (a2)
  {
    if (a3 >= 2)
    {
      *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = bswap32(*a2) >> 16;
      return 2LL;
    }
  }

  return result;
}

void nw_shoes_tlv_parser(unsigned __int8 *a1, unsigned int a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (a2 >= 3)
  {
    unsigned __int16 v6 = 0;
    id v7 = a1;
    while (1)
    {
      unsigned __int16 v8 = a2 - v6;
      if ((unsigned __int16)(a2 - v6) <= 2u)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (os_log_s *)(id)gLogObj;
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          goto LABEL_12;
        }
        int v12 = *a1;
        int v17 = 136446978;
        __int16 v18 = "nw_shoes_tlv_parser";
        __int16 v19 = 1024;
        int v20 = v8;
        __int16 v21 = 2048;
        uint64_t v22 = 3LL;
        __int16 v23 = 1024;
        int v24 = v12;
        uint64_t v13 = "%{public}s Incomplete tlv buffer (%u < %zu) type %u";
        __int16 v14 = v11;
        uint32_t v15 = 34;
        goto LABEL_11;
      }

      uint64_t v9 = bswap32(*(unsigned __int16 *)(v7 + 1)) >> 16;
      uint64_t v10 = v9 + 3;
      ((void (**)(id, unsigned __int8 *))v5)[2](v5, v7);
      v7 += v10;
      v6 += v10;
      if (a2 <= v6) {
        goto LABEL_13;
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    int v16 = *a1;
    int v17 = 136447234;
    __int16 v18 = "nw_shoes_tlv_parser";
    __int16 v19 = 1024;
    int v20 = v8;
    __int16 v21 = 2048;
    uint64_t v22 = 3LL;
    __int16 v23 = 1024;
    int v24 = v9;
    __int16 v25 = 1024;
    int v26 = v16;
    uint64_t v13 = "%{public}s Invalid tlv buffer (%u < %zu + %u) type %u";
    __int16 v14 = v11;
    uint32_t v15 = 40;
LABEL_11:
    _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v17, v15);
LABEL_12:
  }

void sub_181FFC64C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_shoes_add_tlv(uint64_t a1, unsigned int a2, unsigned int a3, size_t __n, void *__src)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    int v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v23 = "nw_shoes_add_tlv";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v23 = "nw_shoes_add_tlv";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null buffer", buf, 0xCu);
        }
      }

      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v23 = "nw_shoes_add_tlv";
            __int16 v24 = 2082;
            __int16 v25 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null buffer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v18)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v23 = "nw_shoes_add_tlv";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null buffer, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v23 = "nw_shoes_add_tlv";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null buffer, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_shoes_server_set_outer_connection_handler(void *a1, const void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  if (v3)
  {
    uint64_t v4 = _Block_copy(a2);
    id v5 = (void *)v3[12];
    v3[12] = v4;

    goto LABEL_3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v17 = "nw_socks5_server_set_outer_connection_handler";
  unsigned __int16 v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_socks5_server_set_outer_connection_handler";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v17 = "nw_socks5_server_set_outer_connection_handler";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_socks5_server_set_outer_connection_handler";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_socks5_server_set_outer_connection_handler";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null server, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_frame_cache_init(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v23 = "nw_frame_cache_init";
    unsigned __int16 v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null frame_cache";
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v23 = "nw_frame_cache_init";
          __int16 v24 = 2082;
          __int16 v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null frame_cache, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_62:
        if (!v7) {
          return;
        }
        goto LABEL_63;
      }

      if (!v14) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null frame_cache, no backtrace";
    }

    else
    {
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null frame_cache, backtrace limit exceeded";
    }

    goto LABEL_61;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v23 = "nw_frame_cache_init";
    unsigned __int16 v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        unsigned int v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_62;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v23 = "nw_frame_cache_init";
        uint64_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_61;
      }

      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (!v15)
      {
        if (!v16) {
          goto LABEL_62;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v23 = "nw_frame_cache_init";
        uint64_t v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_61;
      }

      if (!v16) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v23 = "nw_frame_cache_init";
      __int16 v24 = 2082;
      __int16 v25 = v15;
      os_log_type_t v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    unsigned int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_62;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v23 = "nw_frame_cache_init";
    uint64_t v10 = "%{public}s called with null protocol";
LABEL_61:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_62;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v23 = "nw_frame_cache_init";
    unsigned __int16 v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null max_frame_count";
      goto LABEL_61;
    }

    if (!v20)
    {
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null max_frame_count, backtrace limit exceeded";
      goto LABEL_61;
    }

    os_log_type_t v15 = (char *)__nw_create_backtrace_string();
    unsigned int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v18 = os_log_type_enabled(v8, type);
    if (!v15)
    {
      if (!v18) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null max_frame_count, no backtrace";
      goto LABEL_61;
    }

    if (!v18) {
      goto LABEL_43;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v23 = "nw_frame_cache_init";
    __int16 v24 = 2082;
    __int16 v25 = v15;
    os_log_type_t v17 = "%{public}s called with null max_frame_count, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_181A5C000, v8, v9, v17, buf, 0x16u);
    goto LABEL_43;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v23 = "nw_frame_cache_init";
    unsigned __int16 v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null max_byte_count";
      goto LABEL_61;
    }

    if (!v20)
    {
      unsigned int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null max_byte_count, backtrace limit exceeded";
      goto LABEL_61;
    }

    os_log_type_t v15 = (char *)__nw_create_backtrace_string();
    unsigned int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v19 = os_log_type_enabled(v8, type);
    if (!v15)
    {
      if (!v19) {
        goto LABEL_62;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_init";
      uint64_t v10 = "%{public}s called with null max_byte_count, no backtrace";
      goto LABEL_61;
    }

    if (v19)
    {
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v23 = "nw_frame_cache_init";
      __int16 v24 = 2082;
      __int16 v25 = v15;
      os_log_type_t v17 = "%{public}s called with null max_byte_count, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

void nw_frame_cache_remove_all(uint64_t *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (gLogDatapath)
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        int v10 = *((_DWORD *)a1 + 6);
        uint64_t v11 = a1[2];
        uint64_t v12 = "<null>";
        if (v11)
        {
          os_log_type_t v13 = *(const char **)(v11 + 16);
          if (v13) {
            uint64_t v12 = v13;
          }
        }

        *(_DWORD *)__int128 buf = 136446978;
        __int16 v23 = "nw_frame_cache_remove_all";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = v10;
        *(_WORD *)&void v25[4] = 2048;
        *(void *)&v25[6] = a1;
        __int16 v26 = 2080;
        uint64_t v27 = v12;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s purging %u frames from frame cache %p for protocol %s",  buf,  0x26u);
      }
    }

    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 0x40000000LL;
    os_log_type_t v17 = __nw_frame_cache_remove_all_block_invoke;
    BOOL v18 = &__block_descriptor_tmp_26881;
    BOOL v19 = a1;
    uint64_t v2 = *a1;
    do
    {
      if (!v2) {
        break;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      char v4 = ((uint64_t (*)(void *))v17)(v16);
      uint64_t v2 = v3;
    }

    while ((v4 & 1) != 0);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v23 = "nw_frame_cache_remove_all";
  id v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v5, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_remove_all";
      unsigned int v8 = "%{public}s called with null frame_cache";
      goto LABEL_25;
    }

    if (!v20)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_remove_all";
      unsigned int v8 = "%{public}s called with null frame_cache, backtrace limit exceeded";
      goto LABEL_25;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v15 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v23 = "nw_frame_cache_remove_all";
        __int16 v24 = 2082;
        *(void *)__int16 v25 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null frame_cache, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_26;
    }

    if (v15)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v23 = "nw_frame_cache_remove_all";
      unsigned int v8 = "%{public}s called with null frame_cache, no backtrace";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    }
  }

BOOL __nw_frame_cache_remove_all_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
    {
      int v4 = 0;
      uint64_t v5 = 0LL;
    }

    else
    {
      int v4 = *(_DWORD *)(a2 + 48);
      uint64_t v5 = *(void *)(a2 + 112);
    }

    if (gLogDatapath)
    {
      os_log_type_t v13 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446978;
        os_log_type_t v17 = "nw_frame_cache_remove_all_block_invoke";
        __int16 v18 = 2048;
        BOOL v19 = (char *)a2;
        __int16 v20 = 2048;
        uint64_t v21 = v5;
        __int16 v22 = 1024;
        int v23 = v4;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s destroying frame %p (buffer: %p, length %u)",  buf,  0x26u);
      }
    }

    frame_cache_remove_from_cache(*(void *)(a1 + 32), (void *)a2);
    return a2 != 0;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v17 = "nw_frame_cache_remove_all_block_invoke";
  id v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v6, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_frame_cache_remove_all_block_invoke";
      os_log_type_t v9 = "%{public}s foreach gave null empty_frame";
      goto LABEL_21;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_frame_cache_remove_all_block_invoke";
      os_log_type_t v9 = "%{public}s foreach gave null empty_frame, backtrace limit exceeded";
      goto LABEL_21;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v17 = "nw_frame_cache_remove_all_block_invoke";
        __int16 v18 = 2082;
        BOOL v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s foreach gave null empty_frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_22;
    }

    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v17 = "nw_frame_cache_remove_all_block_invoke";
      os_log_type_t v9 = "%{public}s foreach gave null empty_frame, no backtrace";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

void frame_cache_remove_from_cache(uint64_t a1, void *a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    finalizer_context = (void *)nw_frame_get_finalizer_context((uint64_t)a2);
    if (finalizer_context) {
      free(finalizer_context);
    }
    uint64_t v5 = a2[2];
    id v6 = (void *)a2[3];
    if (v5)
    {
      *(void *)(v5 + 24) = v6;
      id v6 = (void *)a2[3];
    }

    else
    {
      *(void *)(a1 + _Block_object_dispose(va, 8) = v6;
    }

    void *v6 = v5;
    a2[2] = 0LL;
    a2[3] = 0LL;
    int v7 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 24) = v7 - 1;
    if (v7) {
      goto LABEL_25;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = *(unsigned int *)(a1 + 24);
    *(_DWORD *)__int128 buf = 136446978;
    unsigned int v29 = "frame_cache_remove_from_cache";
    __int16 v30 = 2082;
    int v31 = "frame_cache->empty_frames_count";
    __int16 v32 = 2048;
    uint64_t v33 = 1LL;
    __int16 v34 = 2048;
    uint64_t v35 = v8;
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v9, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = (os_log_s *)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v12 = *(unsigned int *)(a1 + 24);
          *(_DWORD *)__int128 buf = 136446978;
          unsigned int v29 = "frame_cache_remove_from_cache";
          __int16 v30 = 2082;
          int v31 = "frame_cache->empty_frames_count";
          __int16 v32 = 2048;
          uint64_t v33 = 1LL;
          __int16 v34 = 2048;
          uint64_t v35 = v12;
          os_log_type_t v13 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_21:
          _os_log_impl(&dword_181A5C000, v10, v11, v13, buf, 0x2Au);
        }
      }

      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = (os_log_s *)gLogObj;
        os_log_type_t v11 = type;
        BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v15)
          {
            uint64_t v16 = *(unsigned int *)(a1 + 24);
            *(_DWORD *)__int128 buf = 136447234;
            unsigned int v29 = "frame_cache_remove_from_cache";
            __int16 v30 = 2082;
            int v31 = "frame_cache->empty_frames_count";
            __int16 v32 = 2048;
            uint64_t v33 = 1LL;
            __int16 v34 = 2048;
            uint64_t v35 = v16;
            __int16 v36 = 2082;
            os_log_type_t v37 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }

        if (v15)
        {
          uint64_t v18 = *(unsigned int *)(a1 + 24);
          *(_DWORD *)__int128 buf = 136446978;
          unsigned int v29 = "frame_cache_remove_from_cache";
          __int16 v30 = 2082;
          int v31 = "frame_cache->empty_frames_count";
          __int16 v32 = 2048;
          uint64_t v33 = 1LL;
          __int16 v34 = 2048;
          uint64_t v35 = v18;
          os_log_type_t v13 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_21;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = (os_log_s *)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v17 = *(unsigned int *)(a1 + 24);
          *(_DWORD *)__int128 buf = 136446978;
          unsigned int v29 = "frame_cache_remove_from_cache";
          __int16 v30 = 2082;
          int v31 = "frame_cache->empty_frames_count";
          __int16 v32 = 2048;
          uint64_t v33 = 1LL;
          __int16 v34 = 2048;
          uint64_t v35 = v17;
          os_log_type_t v13 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_21;
        }
      }
    }

void nw_frame_cache_destroy(uint64_t *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (gLogDatapath)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = a1[2];
        uint64_t v8 = "<null>";
        if (v7)
        {
          os_log_type_t v9 = *(const char **)(v7 + 16);
          if (v9) {
            uint64_t v8 = v9;
          }
        }

        *(_DWORD *)__int128 buf = 136446722;
        BOOL v15 = "nw_frame_cache_destroy";
        __int16 v16 = 2048;
        uint64_t v17 = a1;
        __int16 v18 = 2080;
        BOOL v19 = v8;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s destroying frame cache %p for protocol %s",  buf,  0x20u);
      }
    }

    nw_frame_cache_remove_all(a1);
    a1[2] = 0LL;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v15 = "nw_frame_cache_destroy";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v2, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v15 = "nw_frame_cache_destroy";
      uint64_t v5 = "%{public}s called with null frame_cache";
      goto LABEL_23;
    }

    if (!v12)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v15 = "nw_frame_cache_destroy";
      uint64_t v5 = "%{public}s called with null frame_cache, backtrace limit exceeded";
      goto LABEL_23;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v11 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v15 = "nw_frame_cache_destroy";
        __int16 v16 = 2082;
        uint64_t v17 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame_cache, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_24;
    }

    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v15 = "nw_frame_cache_destroy";
      uint64_t v5 = "%{public}s called with null frame_cache, no backtrace";
LABEL_23:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

BOOL nw_frame_cache_create_frame(uint64_t *a1, size_t __size)
{
  uint64_t v77 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    int buf = 136446210;
    BOOL v68 = "nw_frame_cache_create_frame";
    os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();
    v63[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v59) = 0;
    if (__nwlog_fault(v40, v63, &v59))
    {
      if (v63[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v41 = (os_log_s *)__nwlog_obj();
        os_log_type_t v42 = v63[0];
        if (os_log_type_enabled(v41, v63[0]))
        {
          int buf = 136446210;
          BOOL v68 = "nw_frame_cache_create_frame";
          os_log_type_t v43 = "%{public}s called with null frame_cache";
LABEL_85:
          _os_log_impl(&dword_181A5C000, v41, v42, v43, (uint8_t *)&buf, 0xCu);
        }
      }

      else if ((_BYTE)v59)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v41 = (os_log_s *)__nwlog_obj();
        os_log_type_t v42 = v63[0];
        BOOL v46 = os_log_type_enabled(v41, v63[0]);
        if (backtrace_string)
        {
          if (v46)
          {
            int buf = 136446466;
            BOOL v68 = "nw_frame_cache_create_frame";
            __int16 v69 = 2082;
            uint64_t v70 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s called with null frame_cache, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_86;
        }

        if (v46)
        {
          int buf = 136446210;
          BOOL v68 = "nw_frame_cache_create_frame";
          os_log_type_t v43 = "%{public}s called with null frame_cache, no backtrace";
          goto LABEL_85;
        }
      }

      else
      {
        BOOL v41 = (os_log_s *)__nwlog_obj();
        os_log_type_t v42 = v63[0];
        if (os_log_type_enabled(v41, v63[0]))
        {
          int buf = 136446210;
          BOOL v68 = "nw_frame_cache_create_frame";
          os_log_type_t v43 = "%{public}s called with null frame_cache, backtrace limit exceeded";
          goto LABEL_85;
        }
      }
    }

BOOL __nw_frame_cache_create_frame_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
    char v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      BOOL v15 = "%{public}s foreach gave null candidate_frame";
    }

    else if (v52)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
          __int16 v56 = 2082;
          *(void *)CFIndex v57 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s foreach gave null candidate_frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_59;
      }

      if (!v17)
      {
LABEL_59:
        if (v12) {
          free(v12);
        }
        return 0LL;
      }

      *(_DWORD *)int buf = 136446210;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      BOOL v15 = "%{public}s foreach gave null candidate_frame, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      BOOL v15 = "%{public}s foreach gave null candidate_frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_59;
  }

  if ((*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
    unsigned int v4 = 0;
    uint64_t v5 = 0LL;
  }

  else
  {
    unsigned int v4 = *(_DWORD *)(a2 + 48);
    uint64_t v5 = *(void *)(a2 + 112);
  }

  if (gLogDatapath)
  {
    BOOL v46 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446978;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      __int16 v56 = 2048;
      *(void *)CFIndex v57 = a2;
      *(_WORD *)&v57[8] = 2048;
      uint64_t v58 = v5;
      __int16 v59 = 1024;
      LODWORD(v60) = v4;
      _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s existing frame %p found, buffer %p, length %u",  buf,  0x26u);
    }
  }

  int v6 = *(_DWORD *)(a2 + 52);
  if (v6) {
    v6 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
  }
  if (v6 != v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      BOOL v11 = "%{public}s candidate frame is not fully unclaimed, destroying";
      goto LABEL_70;
    }

    if (!v52)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      BOOL v11 = "%{public}s candidate frame is not fully unclaimed, destroying, backtrace limit exceeded";
      goto LABEL_70;
    }

    uint32_t v20 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v20)
    {
      if (!v21) {
        goto LABEL_71;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      BOOL v11 = "%{public}s candidate frame is not fully unclaimed, destroying, no backtrace";
      goto LABEL_70;
    }

    if (v21)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      __int16 v56 = 2082;
      *(void *)CFIndex v57 = v20;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s candidate frame is not fully unclaimed, destroying, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v20);
    goto LABEL_71;
  }

  if (!v5 && v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446722;
      __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
      __int16 v56 = 2048;
      *(void *)CFIndex v57 = a2;
      *(_WORD *)&v57[8] = 1024;
      LODWORD(v5_Block_object_dispose(va, 8) = v4;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s candidate frame %p has length %u, but buffer is NULL, removing",  buf,  0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (__nwlog_fault(v8, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_71;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
        BOOL v11 = "%{public}s candidate frame has length > 0, but buffer is NULL";
        goto LABEL_70;
      }

      if (!v52)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_71;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
        BOOL v11 = "%{public}s candidate frame has length > 0, but buffer is NULL, backtrace limit exceeded";
        goto LABEL_70;
      }

      uint64_t v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      BOOL v25 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v24)
      {
        if (v25)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
          __int16 v56 = 2082;
          *(void *)CFIndex v57 = v24;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s candidate frame has length > 0, but buffer is NULL, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v24);
        if (!v8) {
          goto LABEL_73;
        }
        goto LABEL_72;
      }

      if (v25)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v55 = "nw_frame_cache_create_frame_block_invoke";
        BOOL v11 = "%{public}s candidate frame has length > 0, but buffer is NULL, no backtrace";
LABEL_70:
        _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      }
    }

void nw_frame_cache_return_frame(uint64_t a1, uint64_t a2)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v76 = "nw_frame_cache_return_frame";
    uint64_t v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_125;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v76 = "nw_frame_cache_return_frame";
      uint64_t v63 = "%{public}s called with null frame_cache";
    }

    else if (v73)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      BOOL v69 = os_log_type_enabled(v61, type);
      if (backtrace_string)
      {
        if (v69)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v76 = "nw_frame_cache_return_frame";
          __int16 v77 = 2082;
          *(void *)os_log_type_t v78 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v61,  v62,  "%{public}s called with null frame_cache, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_125:
        if (!v60) {
          return;
        }
LABEL_126:
        free(v60);
        return;
      }

      if (!v69) {
        goto LABEL_125;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v76 = "nw_frame_cache_return_frame";
      uint64_t v63 = "%{public}s called with null frame_cache, no backtrace";
    }

    else
    {
      __int16 v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_125;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v76 = "nw_frame_cache_return_frame";
      uint64_t v63 = "%{public}s called with null frame_cache, backtrace limit exceeded";
    }

uint64_t nw_masque_listener_add_client_demux_pattern(void *a1, uint64_t a2, const unsigned __int8 *a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!nw_protocol_metadata_is_masque_listener(a1))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_listener_add_client_demux_pattern";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    out[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v22) = 0;
    if (out[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = out[0];
      if (!os_log_type_enabled(v10, out[0])) {
        goto LABEL_27;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_add_client_demux_pattern";
      uint64_t v12 = "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata)";
    }

    else if ((_BYTE)v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = out[0];
      BOOL v14 = os_log_type_enabled(v10, out[0]);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_add_client_demux_pattern";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (!v14)
      {
LABEL_27:
        if (v9) {
          free(v9);
        }
        return 0LL;
      }

      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_add_client_demux_pattern";
      uint64_t v12 = "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata), no backtrace";
    }

    else
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = out[0];
      if (!os_log_type_enabled(v10, out[0])) {
        goto LABEL_27;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_add_client_demux_pattern";
      uint64_t v12 = "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata), backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_27;
  }

  if (a2 && !uuid_is_null(a3))
  {
    memset(out, 0, 37);
    uuid_unparse(a3, (char *)out);
    uint64_t v22 = 0LL;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2000000000LL;
    uint64_t v25 = 0LL;
    uint64_t v6 = MEMORY[0x1895F87A8];
    v21[0] = MEMORY[0x1895F87A8];
    v21[1] = 0x40000000LL;
    v21[2] = __nw_masque_listener_add_client_demux_pattern_block_invoke;
    v21[3] = &unk_189BBA0B8;
    void v21[4] = &v22;
    void v21[5] = out;
    nw_protocol_metadata_access_handle((uint64_t)a1, (uint64_t)v21);
    uint64_t v7 = v23[3];
    if (!v7)
    {
LABEL_7:
      _Block_object_dispose(&v22, 8);
      return 0LL;
    }

    if (nw_protocol_metadata_is_masque_listener(a1))
    {
      *(void *)int buf = v6;
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL49nw_masque_listener_add_demux_pattern_for_endpointP20nw_protocol_metadataP19nw_protocol_optionsP11nw_endpoint_block_invoke;
      int v30 = &__block_descriptor_tmp_29_27008;
      uint64_t v31 = a2;
      uint64_t v32 = v7;
      nw_protocol_metadata_access_handle((uint64_t)a1, (uint64_t)buf);
      goto LABEL_7;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_listener_add_demux_pattern_for_endpoint";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v15, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v16 = (os_log_s *)__nwlog_obj();
        os_log_type_t v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_39;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_listener_add_demux_pattern_for_endpoint";
        uint64_t v18 = "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata)";
        goto LABEL_38;
      }

      if (!v26)
      {
        os_log_type_t v16 = (os_log_s *)__nwlog_obj();
        os_log_type_t v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_39;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_listener_add_demux_pattern_for_endpoint";
        uint64_t v18 = "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata), backtrace limit exceeded";
        goto LABEL_38;
      }

      BOOL v19 = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (v19)
      {
        if (v20)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_add_demux_pattern_for_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v19;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        goto LABEL_39;
      }

      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_listener_add_demux_pattern_for_endpoint";
        uint64_t v18 = "%{public}s called with null nw_protocol_metadata_is_masque_listener(metadata), no backtrace";
LABEL_38:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      }
    }

BOOL nw_protocol_metadata_is_masque_listener(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v1 = a1;
    id v2 = v1[1];

    else {
      uint64_t v3 = 0LL;
    }
    return nw_protocol_definition_is_equal_unsafe((uint64_t)v2, (uint64_t)v3);
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v14 = "nw_protocol_metadata_is_masque_listener";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v14 = "nw_protocol_metadata_is_masque_listener";
        uint64_t v8 = "%{public}s called with null metadata";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v14 = "nw_protocol_metadata_is_masque_listener";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v14 = "nw_protocol_metadata_is_masque_listener";
        uint64_t v8 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v14 = "nw_protocol_metadata_is_masque_listener";
        uint64_t v8 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }

uint64_t __nw_masque_listener_add_client_demux_pattern_block_invoke(uint64_t a1, os_unfair_lock_s *a2)
{
  uint64_t v4 = a2 + 2;
  os_unfair_lock_lock(a2 + 2);
  uint64_t v5 = *(void *)(*(void *)&a2->_os_unfair_lock_opaque + 488LL);
  if (v5) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = nw_dictionary_copy_value(v5, *(void *)(a1 + 40));
  }
  os_unfair_lock_unlock(v4);
  return 1LL;
}

BOOL ___ZL49nw_masque_listener_add_demux_pattern_for_endpointP20nw_protocol_metadataP19nw_protocol_optionsP11nw_endpoint_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 8));
  uint64_t v5 = *(void *)a2;
  uint64_t v37 = 0LL;
  int v38 = &v37;
  uint64_t v39 = 0x2000000000LL;
  uint64_t v40 = 0LL;
  uint64_t v6 = *(void **)(a1 + 32);
  v36[0] = MEMORY[0x1895F87A8];
  v36[1] = 0x40000000LL;
  v36[2] = ___ZL49nw_masque_listener_add_demux_pattern_for_endpointP20nw_protocol_metadataP19nw_protocol_optionsP11nw_endpoint_block_invoke_2;
  v36[3] = &unk_189BBA290;
  void v36[4] = &v37;
  nw_demux_options_enumerate_patterns(v6, (uint64_t)v36);
  uint64_t v7 = v38[3];
  if (!v7)
  {
LABEL_26:
    _Block_object_dispose(&v37, 8);
    return 1LL;
  }

  address = nw_endpoint_get_address(*(nw_endpoint_t *)(a1 + 40));
  int sa_family = address->sa_family;
  uint64_t v10 = 28LL;
  if (sa_family != 30) {
    uint64_t v10 = 0LL;
  }
  if (sa_family == 2) {
    size_t v11 = 16LL;
  }
  else {
    size_t v11 = v10;
  }
  int v12 = v7 + v11;
  size_t v13 = v7 + v11 + 8;
  if (v7 + v11 == -8LL)
  {
    int v30 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v42 = "strict_calloc";
    uint64_t v31 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v31);
    if (result) {
      goto LABEL_31;
    }
    free(v31);
  }

  BOOL v14 = (char *)calloc(1uLL, v13);
  if (v14) {
    goto LABEL_9;
  }
  uint64_t v32 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  os_log_type_t v42 = "strict_calloc";
  __int16 v43 = 2048;
  uint64_t v44 = 1LL;
  __int16 v45 = 2048;
  int v46 = (const char *)v13;
  uint64_t v33 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v33);
  if (!result)
  {
    free(v33);
LABEL_9:
    v35[0] = 0LL;
    v35[1] = v35;
    v35[2] = 0x2000000000LL;
    *(_WORD *)BOOL v14 = bswap32(v12 + 6) >> 16;
    v14[2] = 2;
    *(_WORD *)(v14 + 3) = (_WORD)v11 << 8;
    memcpy(v14 + 5, address, v11);
    __int16 v15 = &v14[v11 + 5];
    *__int16 v15 = 1;
    *(_WORD *)(v15 + 1) = bswap32(*((unsigned __int16 *)v38 + 12)) >> 16;
    v35[3] = v15 + 3;
    os_log_type_t v16 = *(void **)(a1 + 32);
    v34[0] = MEMORY[0x1895F87A8];
    v34[1] = 0x40000000LL;
    v34[2] = ___ZL49nw_masque_listener_add_demux_pattern_for_endpointP20nw_protocol_metadataP19nw_protocol_optionsP11nw_endpoint_block_invoke_3;
    v34[3] = &unk_189BBA2B8;
    void v34[4] = v35;
    nw_demux_options_enumerate_patterns(v16, (uint64_t)v34);
    dispatch_data_t v17 = dispatch_data_create(v14, v13, 0LL, 0LL);
    metadata_for_capsule = nw_http_create_metadata_for_capsule(16770306LL, v17);
    char v19 = nw_masque_send_metadata(v5, (uint64_t)metadata_for_capsule, *(void *)(v5 + 32));
    int v20 = *(_DWORD *)(v5 + 527);
    if ((v19 & 1) != 0)
    {
      if ((v20 & 0x10000) != 0) {
        goto LABEL_21;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v21 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_21;
      }
      uint64_t v22 = *(void *)(a1 + 40);
      *(_DWORD *)int buf = 136446978;
      os_log_type_t v42 = "nw_masque_listener_add_demux_pattern_for_endpoint_block_invoke";
      __int16 v43 = 2082;
      uint64_t v44 = v5 + 531;
      __int16 v45 = 2080;
      int v46 = " ";
      __int16 v47 = 2112;
      uint64_t v48 = v22;
      uint64_t v23 = "%{public}s %{public}s%sSent REGISTER_LISTENER_DEMUX_PATTERN capsule for endpoint %@";
      uint64_t v24 = (os_log_s *)v21;
      os_log_type_t v25 = OS_LOG_TYPE_DEBUG;
      uint32_t v26 = 42;
    }

    else
    {
      if ((v20 & 0x10000) != 0) {
        goto LABEL_21;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v27 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_21;
      }
      int v28 = *(const char **)(a1 + 40);
      *(_DWORD *)int buf = 136446722;
      os_log_type_t v42 = (const char *)(v5 + 531);
      __int16 v43 = 2080;
      uint64_t v44 = (uint64_t)" ";
      __int16 v45 = 2112;
      int v46 = v28;
      uint64_t v23 = "%{public}s%sFailed to send REGISTER_LISTENER_DEMUX_PATTERN capsule for endpoint %@";
      uint64_t v24 = (os_log_s *)v27;
      os_log_type_t v25 = OS_LOG_TYPE_ERROR;
      uint32_t v26 = 32;
    }

    _os_log_impl(&dword_181A5C000, v24, v25, v23, buf, v26);
LABEL_21:
    free(v14);
    if (v17) {
      dispatch_release(v17);
    }
    if (metadata_for_capsule) {
      os_release(metadata_for_capsule);
    }
    os_unfair_lock_unlock(v4);
    _Block_object_dispose(v35, 8);
    goto LABEL_26;
  }

uint64_t ___ZL49nw_masque_listener_add_demux_pattern_for_endpointP20nw_protocol_metadataP19nw_protocol_optionsP11nw_endpoint_block_invoke_2( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a2 + 4LL;
  if (a5) {
    uint64_t v5 = a2 + 1LL;
  }
  else {
    uint64_t v5 = 1LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
  return 1LL;
}

uint64_t ___ZL49nw_masque_listener_add_demux_pattern_for_endpointP20nw_protocol_metadataP19nw_protocol_optionsP11nw_endpoint_block_invoke_3( uint64_t a1, size_t __n, __int16 a3, void *__src, const void *a5)
{
  **(_WORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = __n;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += 2LL;
  **(_WORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a3;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += 2LL;
  size_t v7 = __n;
  memcpy(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), __src, __n);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v7;
  uint64_t v8 = *(_BYTE **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (a5)
  {
    *uint64_t v8 = 1;
    memcpy((void *)++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a5, v7);
  }

  else
  {
    *uint64_t v8 = 0;
    size_t v7 = 1LL;
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v7;
  return 1LL;
}

uint64_t nw_masque_send_metadata(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_send_metadata";
    size_t v11 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_27;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_send_metadata";
      BOOL v14 = "%{public}s called with null masque";
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type[0];
      BOOL v17 = os_log_type_enabled(v12, type[0]);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_send_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (!v17)
      {
LABEL_27:
        if (v11) {
          free(v11);
        }
        return 0LL;
      }

      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_send_metadata";
      BOOL v14 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      int v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type[0];
      if (!os_log_type_enabled(v12, type[0])) {
        goto LABEL_27;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_send_metadata";
      BOOL v14 = "%{public}s called with null masque, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_27;
  }

  *(void *)os_log_type_t type = 0LL;
  uint64_t v27 = type;
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, os_log_type_t *))(*(void *)(a3 + 24)
                                                                                             + 88LL))( a3,  a1,  0LL,  0LL,  1LL,  type);
  if ((*(_BYTE *)(a1 + 529) & 1) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    __int16 v15 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_masque_send_metadata";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 531;
      *(_WORD *)&_BYTE buf[22] = 2080;
      int v30 = " ";
      __int16 v31 = 1024;
      int v32 = v6;
      _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sGot %u output frames", buf, 0x26u);
    }
  }

  if (!v6) {
    return 0LL;
  }
  *(void *)int buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  LOBYTE(v30) = 0;
  v19[0] = MEMORY[0x1895F87A8];
  v19[1] = 0x40000000LL;
  int v20 = ___ZL23nw_masque_send_metadataP9nw_masqueP20nw_protocol_metadataP11nw_protocol_block_invoke;
  uint64_t v21 = &unk_189BBA300;
  uint64_t v22 = buf;
  uint64_t v23 = type;
  uint64_t v24 = a1;
  uint64_t v25 = a2;
  uint64_t v7 = *(void *)type;
  do
  {
    if (!v7) {
      break;
    }
    uint64_t v8 = *(void *)(v7 + 32);
    char v9 = ((uint64_t (*)(void *))v20)(v19);
    uint64_t v7 = v8;
  }

  while ((v9 & 1) != 0);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, os_log_type_t *))(*(void *)(a3 + 24) + 96LL))(a3, type);
  _Block_object_dispose(buf, 8);
  return v10;
}

uint64_t ___ZL23nw_masque_send_metadataP9nw_masqueP20nw_protocol_metadataP11nw_protocol_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    nw_frame_finalize(a2);
    uint64_t v4 = *(void *)(a2 + 32);
    uint64_t v5 = *(void **)(a2 + 40);
    if (v4)
    {
      *(void *)(v4 + 40) = v5;
      uint64_t v5 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(*(void *)(a1 + 40) + 8LL) = v5;
    }

    *uint64_t v5 = v4;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    uint64_t v6 = *(void *)(a1 + 48);
    if ((!v6 || (*(_BYTE *)(v6 + 529) & 1) == 0) && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v8 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = *(void *)(a1 + 48);
        uint64_t v10 = "";
        BOOL v11 = v9 == 0;
        if (v9) {
          int v12 = (const char *)(v9 + 531);
        }
        else {
          int v12 = "";
        }
        int v13 = 136446722;
        BOOL v14 = "nw_masque_send_metadata_block_invoke";
        if (!v11) {
          uint64_t v10 = " ";
        }
        __int16 v15 = 2082;
        os_log_type_t v16 = v12;
        __int16 v17 = 2080;
        uint64_t v18 = v10;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDropping unneeded output frame",  (uint8_t *)&v13,  0x20u);
      }
    }
  }

  else
  {
    nw_frame_collapse(a2);
    nw_frame_set_metadata(a2, *(nw_protocol_metadata **)(a1 + 56), 0, 0);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  return 1LL;
}

BOOL ___ZL42nw_protocol_masque_listener_get_definitionv_block_invoke()
{
  nw_protocol_masque_listener_get_definition(void)::nw_protocol_definition_t definition = (uint64_t)nw_protocol_definition_create_with_identifier(&nw_protocol_masque_listener_identifier(void)::g_masque_protocol_identifier);
  nw_protocol_definition_set_is_proxy((void *)nw_protocol_masque_listener_get_definition(void)::definition);
  nw_protocol_definition_set_globals_allocator( (void *)nw_protocol_masque_listener_get_definition(void)::definition,  nw_masque_allocate_globals,  nw_masque_deallocate_globals);
  nw_protocol_definition_set_options_allocator( (void *)nw_protocol_masque_listener_get_definition(void)::definition,  (uint64_t)nw_masque_allocate_options,  (uint64_t)nw_masque_copy_options,  (uint64_t)nw_masque_deallocate_options);
  nw_protocol_definition_set_options_equality_check( (void *)nw_protocol_masque_listener_get_definition(void)::definition,  (uint64_t)nw_masque_option_is_equal);
  nw_protocol_definition_set_options_serializer( (void *)nw_protocol_masque_listener_get_definition(void)::definition,  0,  (uint64_t)nw_masque_serialize_options,  (uint64_t)nw_masque_deserialize_options);
  nw_protocol_definition_set_metadata_allocator( (void *)nw_protocol_masque_listener_get_definition(void)::definition,  (uint64_t)nw_masque_listener_allocate_metadata,  (uint64_t)nw_masque_listener_deallocate_metadata);
  nw_protocol_definition_set_metadata_comparator( (void *)nw_protocol_masque_listener_get_definition(void)::definition,  (uint64_t)nw_masque_listener_compare_metadata);
  return nw_protocol_register_handle( (uint64_t)&nw_protocol_masque_listener_identifier(void)::g_masque_protocol_identifier,  (void *)nw_protocol_masque_listener_get_definition(void)::definition,  (uint64_t)nw_protocol_masque_listener_create,  (uint64_t)nw_protocol_masque_listener_accept);
}

BOOL nw_masque_allocate_globals(nw_protocol_definition *a1)
{
  id v1 = calloc(1uLL, 0xCuLL);
  if (v1) {
    return (BOOL)v1;
  }
  uint64_t v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }

  __break(1u);
  return result;
}

void nw_masque_deallocate_globals(nw_protocol_definition *a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_masque_allocate_options(nw_protocol_definition *a1)
{
  id v1 = calloc(1uLL, 0x28uLL);
  if (v1) {
    return (BOOL)v1;
  }
  uint64_t v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }

  __break(1u);
  return result;
}

BOOL nw_masque_copy_options(nw_protocol_definition *a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v19 = "nw_masque_copy_options";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_masque_copy_options";
          BOOL v11 = "%{public}s called with null existing_handle";
LABEL_27:
          _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v19 = "nw_masque_copy_options";
            __int16 v20 = 2082;
            uint64_t v21 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v15)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_masque_copy_options";
          BOOL v11 = "%{public}s called with null existing_handle, no backtrace";
          goto LABEL_27;
        }
      }

      else
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v19 = "nw_masque_copy_options";
          BOOL v11 = "%{public}s called with null existing_handle, backtrace limit exceeded";
          goto LABEL_27;
        }
      }
    }

void nw_masque_deallocate_options(nw_protocol_definition *a1, void **a2)
{
  if (*a2)
  {
    os_release(*a2);
    *a2 = 0LL;
  }

  uint64_t v3 = a2[1];
  if (v3)
  {
    xpc_release(v3);
    a2[1] = 0LL;
  }

  uint64_t v4 = a2[2];
  if (v4) {
    xpc_release(v4);
  }
  free(a2);
}

uint64_t nw_masque_option_is_equal(nw_protocol_definition *a1, xpc_object_t *a2, xpc_object_t *a3)
{
  if (*((_DWORD *)a2 + 6) == *((_DWORD *)a3 + 6)
    && *((_DWORD *)a2 + 7) == *((_DWORD *)a3 + 7)
    && *((unsigned __int8 *)a2 + 32) == *((unsigned __int8 *)a3 + 32)
    && *((unsigned __int8 *)a2 + 33) == *((unsigned __int8 *)a3 + 33)
    && nw_endpoint_is_equal(*a2, *a3, 0LL)
    && nw_unordered_xpc_array_is_equal(a2[1], a3[1]))
  {
    return nw_unordered_xpc_array_is_equal(a2[2], a3[2]);
  }

  else
  {
    return 0LL;
  }

BOOL nw_masque_serialize_options(nw_protocol_definition *a1, void *a2, unint64_t *a3)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v62 = "nw_masque_serialize_options";
    uint64_t v49 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v49, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint32_t v50 = (os_log_s *)__nwlog_obj();
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v50, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v62 = "nw_masque_serialize_options";
          int v52 = "%{public}s called with null existing_handle";
LABEL_77:
          _os_log_impl(&dword_181A5C000, v50, v51, v52, buf, 0xCu);
        }
      }

      else if (v59)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint32_t v50 = (os_log_s *)__nwlog_obj();
        os_log_type_t v51 = type;
        BOOL v56 = os_log_type_enabled(v50, type);
        if (backtrace_string)
        {
          if (v56)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v62 = "nw_masque_serialize_options";
            __int16 v63 = 2082;
            uint64_t v64 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_78;
        }

        if (v56)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v62 = "nw_masque_serialize_options";
          int v52 = "%{public}s called with null existing_handle, no backtrace";
          goto LABEL_77;
        }
      }

      else
      {
        uint32_t v50 = (os_log_s *)__nwlog_obj();
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v50, type))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v62 = "nw_masque_serialize_options";
          int v52 = "%{public}s called with null existing_handle, backtrace limit exceeded";
          goto LABEL_77;
        }
      }
    }

void sub_182002E7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_masque_deserialize_options(nw_protocol_definition *a1, const char *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_masque_deserialize_options";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_masque_deserialize_options";
        char v16 = "%{public}s called with null serialized_bytes";
LABEL_48:
        _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      }

BOOL nw_masque_listener_allocate_metadata(nw_protocol_definition *a1)
{
  id v1 = calloc(1uLL, 0x10uLL);
  if (v1) {
    return (BOOL)v1;
  }
  uint64_t v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }

  __break(1u);
  return result;
}

void nw_masque_listener_deallocate_metadata(nw_protocol_definition *a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_masque_listener_compare_metadata(uint64_t a1, void *a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if (a3) {
      return *a2 == *a3;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v15 = "nw_masque_listener_compare_metadata";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_listener_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle2";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v12)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_listener_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle2, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_listener_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle2, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v11)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v15 = "nw_masque_listener_compare_metadata";
      __int16 v16 = 2082;
      __int16 v17 = backtrace_string;
      size_t v10 = "%{public}s called with null handle2, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v15 = "nw_masque_listener_compare_metadata";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_listener_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle1, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_listener_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle1, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v9)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v15 = "nw_masque_listener_compare_metadata";
      __int16 v16 = 2082;
      __int16 v17 = backtrace_string;
      size_t v10 = "%{public}s called with null handle1, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    }

BOOL nw_protocol_masque_listener_create( const nw_protocol_identifier *a1, nw_object *a2, nw_endpoint *a3, nw_parameters *a4)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  __memptr = 0LL;
  if (posix_memalign(&__memptr, 8uLL, 0x270uLL) || (os_log_type_t v6 = (char *)__memptr) == 0LL)
  {
    size_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v18 = 136446722;
    *(void *)&v18[4] = "strict_memalign";
    *(_WORD *)&v18[12] = 2048;
    *(void *)&v18[14] = 8LL;
    *(_WORD *)&v18[22] = 2048;
    uint64_t v19 = 624LL;
    os_log_type_t v15 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v15);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v15);
    os_log_type_t v6 = (char *)__memptr;
  }

  bzero(v6, 0x270uLL);
  *(void *)uint64_t v18 = 0LL;
  *(void *)&v18[8] = v18;
  *(void *)&v18[16] = 0x2000000000LL;
  uint64_t v7 = MEMORY[0x1895F87A8];
  uint64_t v19 = (uint64_t)v6;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 0x40000000LL;
  aBlock[2] = ___ZL34nw_protocol_masque_listener_createPK22nw_protocol_identifierP9nw_objectP11nw_endpointP13nw_parameters_block_invoke;
  aBlock[3] = &unk_189BBAB90;
  void aBlock[4] = v18;
  *((void *)v6 + 62) = _Block_copy(aBlock);
  _Block_object_dispose(v18, 8);
  *((void *)v6 + 2) = &nw_protocol_masque_listener_identifier(void)::g_masque_protocol_identifier;
  *((void *)v6 + 3) = &nw_protocol_masque_listener_get_callbacks(void)::g_masque_listener_callbacks;
  *((void *)v6 + 5) = v6;
  *((void *)v6 + 32) = 0LL;
  *((void *)v6 + 33) = v6 + 256;
  if (a3) {
    size_t v8 = os_retain(a3);
  }
  else {
    size_t v8 = 0LL;
  }
  *((void *)v6 + 3_Block_object_dispose(va, 8) = v8;
  *((_DWORD *)v6 + 12_Block_object_dispose(va, 8) = 0;
  *((void *)v6 + 63) = 1LL;
  *(_DWORD *)(v6 + 527) |= 0x10u;
  if (!*((void *)v6 + 60))
  {
    uint64_t internal = nw_hash_table_create_internal( 5u,  24,  (const void *(*)(const void *, unsigned int *))nw_protocol_get_key,  (unsigned int (*)(const void *, unsigned int))nw_protocol_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_matches_key,  0LL);
    *((void *)v6 + 60) = internal;
  }

  else {
    int v10 = 0;
  }
  *(_DWORD *)(v6 + 527) = *(_DWORD *)(v6 + 527) & 0xFFFEFFFF | v10;
  BOOL v11 = (void *)nw_protocol_masque_listener_get_definition(void)::definition;
  singleton = nw_protocol_metadata_create_singleton(v11);
  *((void *)v6 + 5_Block_object_dispose(va, 8) = singleton;
  *(void *)uint64_t v18 = v7;
  *(void *)&v18[8] = 0x40000000LL;
  *(void *)&v18[16] = ___ZL32nw_masque_listener_set_callbacksP20nw_protocol_metadataPv_block_invoke;
  uint64_t v19 = (uint64_t)&__block_descriptor_tmp_56;
  BOOL v20 = v6;
  nw_protocol_metadata_access_handle((uint64_t)singleton, (uint64_t)v18);
  return (BOOL)v6;
}

uint64_t nw_protocol_masque_listener_accept(nw_protocol *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v17 = "nw_protocol_masque_listener_accept";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v17 = "nw_protocol_masque_listener_accept";
      uint64_t v7 = "%{public}s called with null many_to_one_handler";
LABEL_45:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      goto LABEL_46;
    }

    if (!v14)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v17 = "nw_protocol_masque_listener_accept";
      uint64_t v7 = "%{public}s called with null many_to_one_handler, backtrace limit exceeded";
      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v17 = "nw_protocol_masque_listener_accept";
      uint64_t v7 = "%{public}s called with null many_to_one_handler, no backtrace";
      goto LABEL_45;
    }

    if (v9)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v17 = "nw_protocol_masque_listener_accept";
      __int16 v18 = 2082;
      uint64_t v19 = backtrace_string;
      int v10 = "%{public}s called with null many_to_one_handler, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    }

uint64_t ___ZL34nw_protocol_masque_listener_createPK22nw_protocol_identifierP9nw_objectP11nw_endpointP13nw_parameters_block_invoke( uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t ___ZL32nw_masque_listener_set_callbacksP20nw_protocol_metadataPv_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 8));
  *(void *)a2 = *(void *)(a1 + 32);
  os_unfair_lock_unlock(v4);
  return 1LL;
}

void ___ZL41nw_protocol_masque_listener_get_callbacksv_block_invoke()
{
  qword_18C5A3450 = (uint64_t)nw_protocol_default_reset;
  unk_18C5A3458 = nw_protocol_default_input_flush;
  qword_18C5A33E0 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C5A33E8 = nw_protocol_default_unregister_notification;
  nw_protocol_masque_listener_get_callbacks(void)::g_masque_listener_callbacks = (uint64_t)nw_protocol_masque_listener_add_input_handler;
  *(void *)algn_18C5A3358 = nw_protocol_masque_remove_input_handler;
  qword_18C5A3360 = (uint64_t)nw_protocol_masque_replace_input_handler;
  unk_18C5A3368 = nw_protocol_masque_connect;
  qword_18C5A3370 = (uint64_t)nw_protocol_masque_disconnect;
  unk_18C5A3378 = nw_protocol_masque_connected;
  qword_18C5A3380 = (uint64_t)nw_protocol_masque_disconnected;
  unk_18C5A3388 = nw_protocol_masque_error;
  qword_18C5A3420 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C5A3428 = nw_protocol_masque_waiting_for_output;
  qword_18C5A33B0 = (uint64_t)nw_protocol_masque_listener_finalize_output_frames;
  unk_18C5A33B8 = nw_protocol_default_link_state;
  qword_18C5A33A0 = (uint64_t)nw_protocol_masque_listener_get_input_frames;
  unk_18C5A33A8 = nw_protocol_masque_listener_get_output_frames;
  qword_18C5A3390 = (uint64_t)nw_protocol_masque_input_available;
  unk_18C5A3398 = nw_protocol_default_output_available;
  qword_18C5A3400 = (uint64_t)nw_protocol_masque_supports_external_data;
  unk_18C5A3408 = nw_protocol_masque_input_finished;
  qword_18C5A33D0 = (uint64_t)nw_protocol_default_get_local;
  unk_18C5A33D8 = nw_protocol_masque_get_remote_endpoint;
  qword_18C5A33C0 = (uint64_t)nw_protocol_masque_get_parameters;
  unk_18C5A33C8 = nw_protocol_default_get_path;
  qword_18C5A3410 = (uint64_t)nw_protocol_default_output_finished;
  unk_18C5A3418 = nw_protocol_masque_get_output_local_endpoint;
  qword_18C5A33F0 = (uint64_t)nw_protocol_masque_notify;
  unk_18C5A33F8 = nw_protocol_default_updated_path;
  qword_18C5A3430 = (uint64_t)nw_protocol_masque_copy_info;
  unk_18C5A3438 = nw_protocol_masque_add_listen_handler;
  qword_18C5A3440 = (uint64_t)nw_protocol_masque_remove_listen_handler;
  unk_18C5A3448 = nw_protocol_default_get_message_properties;
}

uint64_t nw_protocol_masque_listener_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_protocol_masque_listener_add_input_handler";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        __int16 v17 = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_60;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_protocol_masque_listener_add_input_handler";
        uint64_t v19 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_59;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (!v21) {
          goto LABEL_60;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_protocol_masque_listener_add_input_handler";
        uint64_t v19 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_59;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v28 = "nw_protocol_masque_listener_add_input_handler";
        __int16 v29 = 2082;
        uint64_t v30 = backtrace_string;
        BOOL v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_45:
        _os_log_impl(&dword_181A5C000, v17, v18, v22, buf, 0x16u);
      }

uint64_t nw_protocol_masque_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v40 = "nw_protocol_masque_replace_input_handler";
    __int16 v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v37)
      {
        uint64_t v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v40 = "nw_protocol_masque_replace_input_handler";
          uint64_t v30 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_93;
        }

        goto LABEL_94;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v32 = os_log_type_enabled(v28, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v40 = "nw_protocol_masque_replace_input_handler";
          uint64_t v30 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_93;
        }

        goto LABEL_94;
      }

      if (!v32) {
        goto LABEL_76;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v40 = "nw_protocol_masque_replace_input_handler";
      __int16 v41 = 2082;
      uint64_t v42 = backtrace_string;
      uint64_t v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

    uint64_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    if (!os_log_type_enabled(v28, type)) {
      goto LABEL_94;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v40 = "nw_protocol_masque_replace_input_handler";
    uint64_t v30 = "%{public}s called with null protocol";
LABEL_93:
    _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
    goto LABEL_94;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v40 = "nw_protocol_masque_replace_input_handler";
    __int16 v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v37)
      {
        uint64_t v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v40 = "nw_protocol_masque_replace_input_handler";
          uint64_t v30 = "%{public}s called with null masque, backtrace limit exceeded";
          goto LABEL_93;
        }

        goto LABEL_94;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v34 = os_log_type_enabled(v28, type);
      if (!backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v40 = "nw_protocol_masque_replace_input_handler";
          uint64_t v30 = "%{public}s called with null masque, no backtrace";
          goto LABEL_93;
        }

        goto LABEL_94;
      }

      if (!v34) {
        goto LABEL_76;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v40 = "nw_protocol_masque_replace_input_handler";
      __int16 v41 = 2082;
      uint64_t v42 = backtrace_string;
      uint64_t v33 = "%{public}s called with null masque, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

    uint64_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    if (!os_log_type_enabled(v28, type)) {
      goto LABEL_94;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v40 = "nw_protocol_masque_replace_input_handler";
    uint64_t v30 = "%{public}s called with null masque";
    goto LABEL_93;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v40 = "nw_protocol_masque_replace_input_handler";
    __int16 v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v40 = "nw_protocol_masque_replace_input_handler";
      uint64_t v30 = "%{public}s called with null old_input_handler";
      goto LABEL_93;
    }

    if (!v37)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v40 = "nw_protocol_masque_replace_input_handler";
        uint64_t v30 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v35 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v40 = "nw_protocol_masque_replace_input_handler";
        uint64_t v30 = "%{public}s called with null old_input_handler, no backtrace";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    if (!v35) {
      goto LABEL_76;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v40 = "nw_protocol_masque_replace_input_handler";
    __int16 v41 = 2082;
    uint64_t v42 = backtrace_string;
    uint64_t v33 = "%{public}s called with null old_input_handler, dumping backtrace:%{public}s";
LABEL_75:
    _os_log_impl(&dword_181A5C000, v28, v29, v33, buf, 0x16u);
    goto LABEL_76;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v40 = "nw_protocol_masque_replace_input_handler";
    __int16 v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v40 = "nw_protocol_masque_replace_input_handler";
        uint64_t v30 = "%{public}s called with null new_input_handler";
        goto LABEL_93;
      }

uint64_t nw_protocol_masque_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v51 = "nw_protocol_masque_remove_input_handler";
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v48)
      {
        os_log_type_t v29 = (os_log_s *)__nwlog_obj();
        os_log_type_t v30 = type;
        if (!os_log_type_enabled(v29, type)) {
          goto LABEL_83;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v51 = "nw_protocol_masque_remove_input_handler";
        __int16 v31 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_82;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v34 = os_log_type_enabled(v29, type);
      if (!backtrace_string)
      {
        if (!v34) {
          goto LABEL_83;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v51 = "nw_protocol_masque_remove_input_handler";
        __int16 v31 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_82;
      }

      if (v34)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v51 = "nw_protocol_masque_remove_input_handler";
        __int16 v52 = 2082;
        int v53 = backtrace_string;
        BOOL v35 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_63:
        _os_log_impl(&dword_181A5C000, v29, v30, v35, buf, 0x16u);
      }

uint64_t nw_protocol_masque_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)uuid_string_t out = 136446210;
    *(void *)&out[4] = "nw_protocol_masque_connect";
    unsigned int v19 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    char v59 = 0;
    if (uu != 17)
    {
      if (!v59)
      {
        uint64_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = uu;
        if (!os_log_type_enabled(v20, (os_log_type_t)uu)) {
          goto LABEL_99;
        }
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_protocol_masque_connect";
        BOOL v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_98;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = uu;
      BOOL v35 = os_log_type_enabled(v20, (os_log_type_t)uu);
      if (!backtrace_string)
      {
        if (!v35) {
          goto LABEL_99;
        }
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = "nw_protocol_masque_connect";
        BOOL v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_98;
      }

      if (v35)
      {
        *(_DWORD *)uuid_string_t out = 136446466;
        *(void *)&out[4] = "nw_protocol_masque_connect";
        *(_WORD *)&out[12] = 2082;
        *(void *)&out[14] = backtrace_string;
        BOOL v36 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_57:
        _os_log_impl(&dword_181A5C000, v20, v21, v36, (uint8_t *)out, 0x16u);
      }

void nw_protocol_masque_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v116 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    applier[0] = 16;
    LOBYTE(v106) = 0;
    if (applier[0] == 17)
    {
      uint32_t v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = applier[0];
      if (!os_log_type_enabled(v58, (os_log_type_t)applier[0])) {
        goto LABEL_162;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
      uint64_t v60 = "%{public}s called with null protocol";
      goto LABEL_161;
    }

    if (!(_BYTE)v106)
    {
      uint32_t v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = applier[0];
      if (!os_log_type_enabled(v58, (os_log_type_t)applier[0])) {
        goto LABEL_162;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
      uint64_t v60 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_161;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v58 = (os_log_s *)__nwlog_obj();
    os_log_type_t v59 = applier[0];
    BOOL v62 = os_log_type_enabled(v58, (os_log_type_t)applier[0]);
    if (!backtrace_string)
    {
      if (!v62) {
        goto LABEL_162;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
      uint64_t v60 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_161;
    }

    if (v62)
    {
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
      WORD6(buf[0]) = 2082;
      *(void *)((char *)buf + 14) = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
    }

    free(backtrace_string);
LABEL_162:
    if (!v57) {
      return;
    }
    goto LABEL_163;
  }

  handle = (nw_protocol *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    applier[0] = 16;
    LOBYTE(v106) = 0;
    if (applier[0] == 17)
    {
      uint32_t v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = applier[0];
      if (!os_log_type_enabled(v58, (os_log_type_t)applier[0])) {
        goto LABEL_162;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
      uint64_t v60 = "%{public}s called with null masque";
      goto LABEL_161;
    }

    if (!(_BYTE)v106)
    {
      uint32_t v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = applier[0];
      if (!os_log_type_enabled(v58, (os_log_type_t)applier[0])) {
        goto LABEL_162;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
      uint64_t v60 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_161;
    }

    __int16 v63 = (char *)__nw_create_backtrace_string();
    uint32_t v58 = (os_log_s *)__nwlog_obj();
    os_log_type_t v59 = applier[0];
    BOOL v64 = os_log_type_enabled(v58, (os_log_type_t)applier[0]);
    if (v63)
    {
      if (v64)
      {
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
        WORD6(buf[0]) = 2082;
        *(void *)((char *)buf + 14) = v63;
        _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s called with null masque, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
      }

      free(v63);
      if (!v57) {
        return;
      }
LABEL_163:
      free(v57);
      return;
    }

    if (v64)
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
      uint64_t v60 = "%{public}s called with null masque, no backtrace";
LABEL_161:
      _os_log_impl(&dword_181A5C000, v58, v59, v60, (uint8_t *)buf, 0xCu);
      goto LABEL_162;
    }

    goto LABEL_162;
  }

  if (&handle[1] == a1)
  {
    if ((BYTE1(handle[8].identifier) & 1) == 0 && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      __int16 v65 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
        WORD6(buf[0]) = 2082;
        *(void *)((char *)buf + 14) = (char *)handle + 531;
        WORD3(buf[1]) = 2080;
        *((void *)&buf[1] + 1) = " ";
        _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived connected event for server connect",  (uint8_t *)buf,  0x20u);
      }
    }

    if (*(_DWORD *)handle[8].flow_id) {
      return;
    }
    uint64_t output_handler_context = handle[4].output_handler_context;
    if (output_handler_context)
    {
      if (*(void *)&handle[6].flow_id[8])
      {
        nw_endpoint_t v101 = 0LL;
        id v31 = output_handler_context;
        int v32 = [v31 type];

        else {
          uint64_t v33 = "%s:%u";
        }
        hostname = nw_endpoint_get_hostname((nw_endpoint_t)handle[4].output_handler_context);
        unsigned int port = nw_endpoint_get_port((nw_endpoint_t)handle[4].output_handler_context);
        asprintf(&v101, v33, hostname, port);
        BOOL v36 = (void *)_nw_http_request_create("CONNECT-UDP", "https", v101, "/");
        if (v101)
        {
          free(v101);
          nw_endpoint_t v101 = 0LL;
        }

        if (v36)
        {
          id v37 = v36;
          _nw_http_fields_append(v37, "Datagram-Flow-Id", (char *)&handle[9].output_handler + 7);

          size_t v38 = (dispatch_data_s *)dispatch_data_create_with_transform();
          memset((char *)buf + 1, 0, 63);
          LOBYTE(buf[0]) = 58;
          if (dispatch_data_get_size(v38) <= 0x3D)
          {
            for (i = (const char *)buf; ; i = v43 + 1)
            {
              BOOL v43 = strchr(i, 43);
              if (!v43) {
                break;
              }
              char *v43 = 45;
            }

            for (j = (const char *)buf; ; j = v45 + 1)
            {
              __int16 v45 = strchr(j, 47);
              if (!v45) {
                break;
              }
              char *v45 = 95;
            }

            uint64_t v106 = 0LL;
            int v107 = &v106;
            uint64_t v108 = 0x2000000000LL;
            uint64_t v109 = 0LL;
            *(void *)os_log_type_t type = 0LL;
            id v103 = type;
            uint64_t v104 = 0x2000000000LL;
            id v105 = (char *)buf + 1;
            if (v38)
            {
              *(void *)applier = MEMORY[0x1895F87A8];
              *(void *)&applier[8] = 0x40000000LL;
              *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
              BOOL v112 = (const char *)&unk_189BBF598;
              BOOL v114 = type;
              uint64_t v115 = 61LL;
              nw_endpoint_t v113 = &v106;
              dispatch_data_apply(v38, applier);
              uint64_t v46 = v107[3];
            }

            else
            {
              uint64_t v46 = 0LL;
            }

            _Block_object_dispose(type, 8);
            _Block_object_dispose(&v106, 8);
            *(_WORD *)((char *)buf + v46 + 1) = 58;
            id v54 = v37;
            _nw_http_fields_append(v54, "Server-Connection-Id", buf);

            if (v38) {
              dispatch_release(v38);
            }
            metadata_for_request = nw_http_create_metadata_for_request(v54);
            if (nw_masque_send_metadata( (uint64_t)handle,  (uint64_t)metadata_for_request,  (uint64_t)handle[1].output_handler))
            {
              if ((BYTE1(handle[8].identifier) & 1) == 0)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                uint64_t v56 = (os_log_s *)gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)applier = 136446722;
                  *(void *)&applier[4] = "nw_masque_send_server_connect";
                  *(_WORD *)&applier[12] = 2082;
                  *(void *)&applier[14] = (char *)handle + 531;
                  *(_WORD *)&applier[22] = 2080;
                  BOOL v112 = " ";
                  _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSent CONNECT-UDP request for server CID",  applier,  0x20u);
                }
              }

              *(_DWORD *)handle[8].uint64_t flow_id = 2;
            }

            if (metadata_for_request) {
              os_release(metadata_for_request);
            }
          }

          else
          {
            if ((BYTE1(handle[8].identifier) & 1) == 0)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              os_log_type_t v39 = (os_log_s *)gprivacy_proxyLogObj;
              if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
              {
                size_t size = dispatch_data_get_size(v38);
                *(_DWORD *)applier = 136446722;
                *(void *)&applier[4] = (char *)handle + 531;
                *(_WORD *)&applier[12] = 2080;
                *(void *)&applier[14] = " ";
                *(_WORD *)&applier[22] = 2048;
                BOOL v112 = (const char *)size;
                _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s%sBase64 data is too large: %zu",  applier,  0x20u);
              }
            }

            if (v38) {
              dispatch_release(v38);
            }
          }

          os_release(v37);
        }

        else if ((BYTE1(handle[8].identifier) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          __int16 v41 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = (char *)handle + 531;
            WORD6(buf[0]) = 2080;
            *(void *)((char *)buf + 14) = " ";
            _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_ERROR,  "%{public}s%sFailed to create HTTP message",  (uint8_t *)buf,  0x16u);
          }
        }
      }

      goto LABEL_5;
    }

    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_masque_send_server_connect";
    size_t v66 = (char *)_os_log_send_and_compose_impl();
    applier[0] = 16;
    LOBYTE(v106) = 0;
    if (applier[0] == 17)
    {
      uint64_t v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = applier[0];
      if (!os_log_type_enabled(v67, (os_log_type_t)applier[0])) {
        goto LABEL_197;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_masque_send_server_connect";
      BOOL v69 = "%{public}s called with null masque->target_endpoint";
    }

    else if ((_BYTE)v106)
    {
      uint64_t v70 = (char *)__nw_create_backtrace_string();
      uint64_t v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = applier[0];
      BOOL v71 = os_log_type_enabled(v67, (os_log_type_t)applier[0]);
      if (v70)
      {
        if (v71)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "nw_masque_send_server_connect";
          WORD6(buf[0]) = 2082;
          *(void *)((char *)buf + 14) = v70;
          _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s called with null masque->target_endpoint, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
        }

        free(v70);
        goto LABEL_197;
      }

      if (!v71)
      {
LABEL_197:
        if (v66) {
          free(v66);
        }
        goto LABEL_5;
      }

      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_masque_send_server_connect";
      BOOL v69 = "%{public}s called with null masque->target_endpoint, no backtrace";
    }

    else
    {
      uint64_t v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = applier[0];
      if (!os_log_type_enabled(v67, (os_log_type_t)applier[0])) {
        goto LABEL_197;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_masque_send_server_connect";
      BOOL v69 = "%{public}s called with null masque->target_endpoint, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v67, v68, v69, (uint8_t *)buf, 0xCu);
    goto LABEL_197;
  }

  if (handle != a1) {
    return;
  }
LABEL_5:
  uint64_t v5 = &qword_18C593000;
  if ((BYTE1(handle[8].identifier) & 1) == 0)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    os_log_type_t v6 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
    {
      int output_handler_context_high = HIDWORD(handle[7].output_handler_context);
      LODWORD(buf[0]) = 136446722;
      *(void *)((char *)buf + 4) = (char *)handle + 531;
      WORD6(buf[0]) = 2080;
      *(void *)((char *)buf + 14) = " ";
      WORD3(buf[1]) = 1024;
      DWORD2(buf[1]) = output_handler_context_high;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived connected event with state %u",  (uint8_t *)buf,  0x1Cu);
    }
  }

  uint64_t v8 = &handle[8].flow_id[15];
  uint64_t v9 = *(void **)&handle[7].flow_id[8];
  if (!v9)
  {
    output_handler = a1->output_handler;
    if (!output_handler) {
      goto LABEL_228;
    }
    callbacks = output_handler->callbacks;
    if (!callbacks) {
      goto LABEL_228;
    }
    copy_info = (uint64_t (*)(nw_protocol *, uint64_t))callbacks->copy_info;
    if (!copy_info) {
      goto LABEL_228;
    }
    BOOL v13 = (unsigned __int8 *)copy_info(output_handler, 255LL);
    *(void *)applier = 0LL;
    *(void *)&applier[8] = applier;
    *(void *)&applier[16] = 0x2000000000LL;
    BOOL v112 = 0LL;
    *(void *)&buf[0] = MEMORY[0x1895F87A8];
    *((void *)&buf[0] + 1) = 0x40000000LL;
    *(void *)&buf[1] = ___ZL34nw_masque_save_connection_metadataP9nw_masqueP11nw_protocol_block_invoke;
    *((void *)&buf[1] + 1) = &unk_189BBA550;
    *(void *)&buf[2] = applier;
    nw_array_apply(v13, (uint64_t)buf);
    uint64_t v14 = *(void **)(*(void *)&applier[8] + 24LL);
    if (v14)
    {
      *(void *)&handle[7].flow_id[8] = os_retain(v14);
      nw_protocol_register_notification((uint64_t)a1, (uint64_t)a1->output_handler, 5);
    }

    if (v13) {
      os_release(v13);
    }
    _Block_object_dispose(applier, 8);
    uint64_t v9 = *(void **)&handle[7].flow_id[8];
    if (!v9) {
      goto LABEL_228;
    }
  }

  if (!nw_http_connection_metadata_get_secondary_certificate_count(v9)
    || *(_DWORD *)&handle[8].flow_id[4]
    || HIDWORD(handle[7].output_handler_context))
  {
    goto LABEL_228;
  }

  if ((BYTE1(handle[8].identifier) & 1) == 0)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v15 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = (char *)handle + 531;
      WORD6(buf[0]) = 2080;
      *(void *)((char *)buf + 14) = " ";
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s%sJoined HTTP with secondary certificates, checking for trusted endpoints",  (uint8_t *)buf,  0x16u);
    }
  }

  if ((nw_masque_setup_reverse_proxy((uint64_t)handle) & 1) == 0)
  {
LABEL_228:
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      uint64_t v17 = default_input_handler->callbacks;
      if (v17)
      {
        connected = (void (*)(nw_protocol *, nw_protocol *))v17->connected;
        if (connected) {
          connected(default_input_handler, a2);
        }
      }
    }

    if (a1->output_handler == a2 && !HIDWORD(handle[7].output_handler_context))
    {
      unsigned int v19 = *(void **)&handle[7].flow_id[8];
      if (!v19) {
        goto LABEL_51;
      }
      *(_DWORD *)applier = 0;
      LODWORD(v106) = 0;
      id v20 = v19;
      id v21 = *((id *)v20 + 1);

      if (nw_protocol_copy_http_connection_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_connection_definition_onceToken, &__block_literal_global_62);
      }
      BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v21,  nw_protocol_copy_http_connection_definition_definition);

      if (is_equal_unsafe)
      {
        *(void *)&buf[0] = MEMORY[0x1895F87A8];
        *((void *)&buf[0] + 1) = 3221225472LL;
        *(void *)&buf[1] = __nw_http_connection_metadata_get_message_counts_block_invoke;
        *((void *)&buf[1] + 1) = &__block_descriptor_48_e9_B16__0_v8l;
        *(void *)&buf[2] = applier;
        *((void *)&buf[2] + 1) = &v106;
        uint64_t v23 = *((void *)v20 + 4);
        if (v23) {
          __nw_http_connection_metadata_get_message_counts_block_invoke((uint64_t)buf, v23);
        }
LABEL_40:

        if (!(_DWORD)v106)
        {
          int v24 = *(_DWORD *)v8;
          *(_DWORD *)v8 |= 2u;
          if ((v24 & 0x10000) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            char v25 = (os_log_s *)v5[198];
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(buf[0]) = 136446978;
              *(void *)((char *)buf + 4) = "nw_protocol_masque_connected";
              WORD6(buf[0]) = 2082;
              *(void *)((char *)buf + 14) = (char *)handle + 531;
              WORD3(buf[1]) = 2080;
              *((void *)&buf[1] + 1) = " ";
              LOWORD(buf[2]) = 1024;
              *(_DWORD *)((char *)&buf[2] + 2) = *(_DWORD *)applier;
              _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNew request, no responses received on connection yet (%u requests)",  (uint8_t *)buf,  0x26u);
            }
          }
        }

        if ((*(_DWORD *)v8 & 0x10003) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint64_t v26 = (os_log_s *)v5[198];
          if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
          {
            LODWORD(buf[0]) = 136446722;
            *(void *)((char *)buf + 4) = (char *)handle + 531;
            WORD6(buf[0]) = 2080;
            *(void *)((char *)buf + 14) = " ";
            WORD3(buf[1]) = 1024;
            DWORD2(buf[1]) = *(_DWORD *)applier;
            _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_INFO,  "%{public}s%sRequest blocked on getting new streams after %u requests",  (uint8_t *)buf,  0x1Cu);
          }
        }

void sub_182007BCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_masque_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v23 = "nw_protocol_masque_disconnect";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v23 = "nw_protocol_masque_disconnect";
      uint64_t v15 = "%{public}s called with null protocol";
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v23 = "nw_protocol_masque_disconnect";
          __int16 v24 = 2082;
          char v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_46:
        if (!v12) {
          return;
        }
LABEL_47:
        free(v12);
        return;
      }

      if (!v17) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v23 = "nw_protocol_masque_disconnect";
      uint64_t v15 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v23 = "nw_protocol_masque_disconnect";
      uint64_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_masque_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v29 = "nw_protocol_masque_disconnected";
    BOOL v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_69;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_protocol_masque_disconnected";
      char v20 = "%{public}s called with null protocol";
      goto LABEL_68;
    }

    if (!v26)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_69;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_protocol_masque_disconnected";
      char v20 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_68;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v22 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v22) {
        goto LABEL_69;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_protocol_masque_disconnected";
      char v20 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_68;
    }

    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v29 = "nw_protocol_masque_disconnected";
      __int16 v30 = 2082;
      id v31 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_69:
    if (!v17) {
      return;
    }
    goto LABEL_70;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v29 = "nw_protocol_masque_disconnected";
    BOOL v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_69;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_protocol_masque_disconnected";
      char v20 = "%{public}s called with null masque";
      goto LABEL_68;
    }

    if (!v26)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_69;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_protocol_masque_disconnected";
      char v20 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_68;
    }

    uint64_t v23 = (char *)__nw_create_backtrace_string();
    uint64_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v24 = os_log_type_enabled(v18, type);
    if (v23)
    {
      if (v24)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v29 = "nw_protocol_masque_disconnected";
        __int16 v30 = 2082;
        id v31 = v23;
        _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v23);
      if (!v17) {
        return;
      }
LABEL_70:
      free(v17);
      return;
    }

    if (v24)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_protocol_masque_disconnected";
      char v20 = "%{public}s called with null masque, no backtrace";
LABEL_68:
      _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
      goto LABEL_69;
    }

    goto LABEL_69;
  }

  if (*((nw_protocol **)handle + 54) == a2)
  {
    if ((handle[529] & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v8 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v29 = handle + 531;
        __int16 v30 = 2080;
        id v31 = " ";
        _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_INFO, "%{public}s%sDemux protocol disconnected", buf, 0x16u);
      }
    }

    uint64_t v9 = *((void *)handle + 62);
    uint64_t v10 = (void *)*((void *)handle + 41);
    v25[0] = MEMORY[0x1895F87A8];
    v25[1] = 0x40000000LL;
    v25[2] = ___ZL31nw_protocol_masque_disconnectedP11nw_protocolS0__block_invoke;
    v25[3] = &unk_189BBA700;
    void v25[4] = v9;
    nw_queue_context_async(v10, v25);
  }

  else
  {
    if (*((nw_protocol **)handle + 4) != a2 || *((_DWORD *)handle + 127) == 5) {
      return;
    }
    if ((handle[529] & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v4 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        logging_description = nw_endpoint_get_logging_description(*((void **)handle + 39));
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v29 = handle + 531;
        __int16 v30 = 2080;
        id v31 = " ";
        __int16 v32 = 2082;
        uint64_t v33 = logging_description;
        _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_INFO, "%{public}s%sDisconnected from %{public}s", buf, 0x20u);
      }
    }

    nw_protocol_remove_instance((uint64_t)a1);
    if (*((_DWORD *)handle + 127) == 2)
    {
      int v6 = *((_DWORD *)handle + 130);
      if (v6)
      {
        if (v6 != 57)
        {
          if (v6 == 35)
          {
            if ((handle[529] & 1) == 0)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              uint64_t v7 = (os_log_s *)gprivacy_proxyLogObj;
              if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)int buf = 136446466;
                os_log_type_t v29 = handle + 531;
                __int16 v30 = 2080;
                id v31 = " ";
                _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s%sConnection needs to retry, asking to rebuild",  buf,  0x16u);
              }
            }

            *((_DWORD *)handle + 127) = 0;
            nw_protocol_notify(*((void **)handle + 6), (uint64_t)handle, 19);
            return;
          }

          if ((handle[529] & 1) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            uint64_t v11 = (os_log_s *)gprivacy_proxyLogObj;
            if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
            {
              uint64_t v12 = nw_endpoint_get_logging_description(*((void **)handle + 39));
              *(_DWORD *)int buf = 136446722;
              os_log_type_t v29 = handle + 531;
              __int16 v30 = 2080;
              id v31 = " ";
              __int16 v32 = 2082;
              uint64_t v33 = v12;
              _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s%sConnection disconnected from %{public}s without a reply",  buf,  0x20u);
            }
          }

          if ((*(_DWORD *)(handle + 527) & 4) != 0) {
            int v13 = 1200;
          }
          else {
            int v13 = 1100;
          }
          nw_masque_report_error_to_proxy_agent((uint64_t)handle, v13);
        }
      }
    }

    *((_DWORD *)handle + 127) = 5;
    uint64_t v14 = *((void *)handle + 6);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 24);
      if (v15)
      {
        int v16 = *(void (**)(void))(v15 + 48);
        if (v16) {
          v16();
        }
      }
    }
  }

void nw_protocol_masque_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v26 = "nw_protocol_masque_error";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_58;
      }
      *(_DWORD *)int buf = 136446210;
      char v26 = "nw_protocol_masque_error";
      BOOL v17 = "%{public}s called with null protocol";
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          char v26 = "nw_protocol_masque_error";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v14) {
          return;
        }
        goto LABEL_59;
      }

      if (!v19) {
        goto LABEL_58;
      }
      *(_DWORD *)int buf = 136446210;
      char v26 = "nw_protocol_masque_error";
      BOOL v17 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_58;
      }
      *(_DWORD *)int buf = 136446210;
      char v26 = "nw_protocol_masque_error";
      BOOL v17 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_masque_supports_external_data(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = (unsigned __int8 *)a1->handle;
    if (handle) {
      return (handle[527] >> 6) & 1;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "nw_protocol_masque_supports_external_data";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_masque_supports_external_data";
        int v6 = "%{public}s called with null masque";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_masque_supports_external_data";
        int v6 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_masque_supports_external_data";
        int v6 = "%{public}s called with null masque, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v14 = "nw_protocol_masque_supports_external_data";
      __int16 v15 = 2082;
      os_log_type_t v16 = backtrace_string;
      uint64_t v9 = "%{public}s called with null masque, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_protocol_masque_supports_external_data";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_masque_supports_external_data";
        int v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_masque_supports_external_data";
        int v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v14 = "nw_protocol_masque_supports_external_data";
      __int16 v15 = 2082;
      os_log_type_t v16 = backtrace_string;
      uint64_t v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

BOOL nw_protocol_masque_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[127] == 1;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v15 = "nw_protocol_masque_waiting_for_output";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_masque_waiting_for_output";
        int v7 = "%{public}s called with null masque";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v12)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_masque_waiting_for_output";
        int v7 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_masque_waiting_for_output";
        int v7 = "%{public}s called with null masque, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v11)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v15 = "nw_protocol_masque_waiting_for_output";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null masque, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v15 = "nw_protocol_masque_waiting_for_output";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_masque_waiting_for_output";
        int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_masque_waiting_for_output";
        int v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v9)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v15 = "nw_protocol_masque_waiting_for_output";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    }

uint64_t nw_protocol_masque_listener_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
    __int16 v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null protocol";
      goto LABEL_97;
    }

    if (!v53)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v36 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_97;
    }

    if (!v36) {
      goto LABEL_73;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    id v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_72:
    _os_log_impl(&dword_181A5C000, v28, v29, v37, buf, 0x16u);
    goto LABEL_73;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
    __int16 v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque";
      goto LABEL_97;
    }

    if (!v53)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v38 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v38) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque, no backtrace";
      goto LABEL_97;
    }

    if (!v38) {
      goto LABEL_73;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    id v37 = "%{public}s called with null masque, dumping backtrace:%{public}s";
    goto LABEL_72;
  }

  if ((handle[527] & 0x10) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
    __int16 v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque->listen_udp";
      goto LABEL_97;
    }

    if (!v53)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque->listen_udp, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v39 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v39) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque->listen_udp, no backtrace";
      goto LABEL_97;
    }

    if (!v39) {
      goto LABEL_73;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    id v37 = "%{public}s called with null masque->listen_udp, dumping backtrace:%{public}s";
    goto LABEL_72;
  }

  uint64_t v8 = *((void *)handle + 60);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
    __int16 v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque->listener_flows";
      goto LABEL_97;
    }

    if (!v53)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
      __int16 v30 = "%{public}s called with null masque->listener_flows, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v40 = os_log_type_enabled(v28, type);
    if (backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_get_output_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        id v37 = "%{public}s called with null masque->listener_flows, dumping backtrace:%{public}s";
        goto LABEL_72;
      }

uint64_t nw_protocol_masque_listener_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v25 = "nw_protocol_masque_listener_finalize_output_frames";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v23 = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = v23;
      if (!os_log_type_enabled(v10, v23)) {
        goto LABEL_35;
      }
      *(_DWORD *)int buf = 136446210;
      char v25 = "nw_protocol_masque_listener_finalize_output_frames";
      char v12 = "%{public}s called with null protocol";
      goto LABEL_34;
    }

    if (!v22)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = v23;
      if (!os_log_type_enabled(v10, v23)) {
        goto LABEL_35;
      }
      *(_DWORD *)int buf = 136446210;
      char v25 = "nw_protocol_masque_listener_finalize_output_frames";
      char v12 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = v23;
    BOOL v14 = os_log_type_enabled(v10, v23);
    if (!backtrace_string)
    {
      if (!v14) {
        goto LABEL_35;
      }
      *(_DWORD *)int buf = 136446210;
      char v25 = "nw_protocol_masque_listener_finalize_output_frames";
      char v12 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_34;
    }

    if (v14)
    {
      *(_DWORD *)int buf = 136446466;
      char v25 = "nw_protocol_masque_listener_finalize_output_frames";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_35:
    if (!v9) {
      return 0LL;
    }
LABEL_36:
    free(v9);
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v25 = "nw_protocol_masque_listener_finalize_output_frames";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v23 = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = v23;
      if (!os_log_type_enabled(v10, v23)) {
        goto LABEL_35;
      }
      *(_DWORD *)int buf = 136446210;
      char v25 = "nw_protocol_masque_listener_finalize_output_frames";
      char v12 = "%{public}s called with null masque";
      goto LABEL_34;
    }

    if (!v22)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = v23;
      if (!os_log_type_enabled(v10, v23)) {
        goto LABEL_35;
      }
      *(_DWORD *)int buf = 136446210;
      char v25 = "nw_protocol_masque_listener_finalize_output_frames";
      char v12 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_34;
    }

    __int16 v15 = (char *)__nw_create_backtrace_string();
    BOOL v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = v23;
    BOOL v16 = os_log_type_enabled(v10, v23);
    if (v15)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446466;
        char v25 = "nw_protocol_masque_listener_finalize_output_frames";
        __int16 v26 = 2082;
        __int16 v27 = v15;
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v15);
      if (!v9) {
        return 0LL;
      }
      goto LABEL_36;
    }

    if (v16)
    {
      *(_DWORD *)int buf = 136446210;
      char v25 = "nw_protocol_masque_listener_finalize_output_frames";
      char v12 = "%{public}s called with null masque, no backtrace";
LABEL_34:
      _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
      goto LABEL_35;
    }

    goto LABEL_35;
  }

  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 0x40000000LL;
  uint64_t v18 = (uint64_t (*)(void *))___ZL50nw_protocol_masque_listener_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  BOOL v19 = &__block_descriptor_tmp_202;
  int v20 = a1;
  BOOL v21 = handle;
  tqh_first = a2->tqh_first;
  do
  {
    if (!tqh_first) {
      break;
    }
    os_log_type_t v6 = (nw_frame *)*((void *)tqh_first + 4);
    char v7 = v18(v17);
    tqh_first = v6;
  }

  while ((v7 & 1) != 0);
  return nw_protocol_finalize_output_frames((uint64_t)a1->output_handler, (uint64_t)a2);
}

uint64_t nw_protocol_masque_listener_get_input_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
      int v13 = "%{public}s called with null protocol";
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
          __int16 v24 = 2082;
          char v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10) {
          return 0LL;
        }
LABEL_56:
        free(v10);
        return 0LL;
      }

      if (!v15) {
        goto LABEL_55;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
      int v13 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
      int v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_54;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        os_log_type_t v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_55;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
        int v13 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_54;
      }

      BOOL v16 = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!v16)
      {
        if (!v17) {
          goto LABEL_55;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
        int v13 = "%{public}s called with null masque, no backtrace";
        goto LABEL_54;
      }

      if (v17)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v23 = "nw_protocol_masque_listener_get_input_frames";
        __int16 v24 = 2082;
        char v25 = v16;
        uint64_t v18 = "%{public}s called with null masque, dumping backtrace:%{public}s";
LABEL_39:
        _os_log_impl(&dword_181A5C000, v11, v12, v18, buf, 0x16u);
      }

void nw_protocol_masque_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v93 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v83) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      uint64_t v26 = "%{public}s called with null protocol";
      goto LABEL_96;
    }

    if (!(_BYTE)v83)
    {
      __int16 v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      uint64_t v26 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_96;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v38 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v38) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      uint64_t v26 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_96;
    }

    if (v38)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_97:
    if (!v23) {
      return;
    }
    goto LABEL_98;
  }

  handle = (nw_protocol *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v83) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      uint64_t v26 = "%{public}s called with null masque";
      goto LABEL_96;
    }

    if (!(_BYTE)v83)
    {
      __int16 v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      uint64_t v26 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_96;
    }

    BOOL v39 = (char *)__nw_create_backtrace_string();
    __int16 v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v40 = os_log_type_enabled(v24, type[0]);
    if (v39)
    {
      if (v40)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v39;
        _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v39);
      if (!v23) {
        return;
      }
LABEL_98:
      free(v23);
      return;
    }

    if (v40)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      uint64_t v26 = "%{public}s called with null masque, no backtrace";
LABEL_96:
      _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
      goto LABEL_97;
    }

    goto LABEL_97;
  }

  uint64_t v4 = handle + 1;
  if (&handle[1] == a1) {
    uint64_t v5 = 512LL;
  }
  else {
    uint64_t v5 = 508LL;
  }
  uint64_t v6 = 32LL;
  if (&handle[1] == a1) {
    uint64_t v6 = 96LL;
  }
  int v7 = *(_DWORD *)&handle->flow_id[v5];
  if (v7 == 4)
  {
    if ((handle[8].flow_id[15] & 0x10) != 0)
    {
      nw_protocol_masque_listener_read_input((uint64_t)a1->handle, 0LL, 0LL, 1LL, 0xFFFFFFFFLL, 0xFFFFFFFFLL);
      return;
    }

    default_input_handler = handle->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_available = (void (*)(void))callbacks->input_available;
        if (input_available)
        {
          input_available();
          return;
        }
      }
    }

    __nwlog_obj();
    __int16 v27 = handle->default_input_handler;
    uint64_t v28 = "invalid";
    if (v27)
    {
      name = v27->identifier->name;
      if (name) {
        uint64_t v28 = name;
      }
    }

    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v28;
    __int16 v30 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v83) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v31 = (os_log_s *)__nwlog_obj();
      os_log_type_t v32 = type[0];
      if (!os_log_type_enabled(v31, type[0])) {
        goto LABEL_105;
      }
      os_log_type_t v33 = handle->default_input_handler;
      uint64_t v34 = "invalid";
      if (v33)
      {
        BOOL v35 = v33->identifier->name;
        if (v35) {
          uint64_t v34 = v35;
        }
      }

      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v34;
      BOOL v36 = "%{public}s protocol %{public}s has invalid input_available callback";
    }

    else if ((_BYTE)v83)
    {
      __int16 v41 = (char *)__nw_create_backtrace_string();
      id v31 = (os_log_s *)__nwlog_obj();
      os_log_type_t v32 = type[0];
      BOOL v42 = os_log_type_enabled(v31, type[0]);
      if (v41)
      {
        if (v42)
        {
          BOOL v43 = handle->default_input_handler;
          BOOL v44 = "invalid";
          if (v43)
          {
            __int16 v45 = v43->identifier->name;
            if (v45) {
              BOOL v44 = v45;
            }
          }

          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v44;
          *(_WORD *)&_BYTE buf[22] = 2082;
          os_log_type_t v92 = v41;
          _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v41);
        goto LABEL_105;
      }

      if (!v42)
      {
LABEL_105:
        if (v30) {
          free(v30);
        }
        return;
      }

      os_log_type_t v59 = handle->default_input_handler;
      uint64_t v60 = "invalid";
      if (v59)
      {
        __int16 v61 = v59->identifier->name;
        if (v61) {
          uint64_t v60 = v61;
        }
      }

      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v60;
      BOOL v36 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
    }

    else
    {
      id v31 = (os_log_s *)__nwlog_obj();
      os_log_type_t v32 = type[0];
      if (!os_log_type_enabled(v31, type[0])) {
        goto LABEL_105;
      }
      int v56 = handle->default_input_handler;
      uint64_t v57 = "invalid";
      if (v56)
      {
        uint32_t v58 = v56->identifier->name;
        if (v58) {
          uint64_t v57 = v58;
        }
      }

      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v57;
      BOOL v36 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v31, v32, v36, buf, 0x16u);
    goto LABEL_105;
  }

  if ((v7 & 0xFFFFFFFE) != 2) {
    return;
  }
  uint64_t v11 = *(void *)&handle->flow_id[v6];
  BOOL v12 = v4 == a1;
  uint64_t v13 = MEMORY[0x1895F87A8];
  if (v4 != a1)
  {
    while (1)
    {
      uint64_t v83 = 0LL;
      nw_endpoint_t v84 = &v83;
      if (!(*(unsigned int (**)(uint64_t, nw_protocol *, void, void, uint64_t, uint64_t *))(*(void *)(v11 + 24) + 80LL))( v11,  a1,  0LL,  0LL,  1LL,  &v83)) {
        return;
      }
      *(void *)int buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      LOBYTE(v92) = 0;
      uint64_t v75 = v13;
      uint64_t v76 = 0x40000000LL;
      os_log_type_t v77 = (uint64_t (*)(uint64_t *))___ZL34nw_protocol_masque_input_availableP11nw_protocolS0__block_invoke;
      os_log_type_t v78 = &unk_189BBA8F0;
      BOOL v79 = buf;
      uint64_t v80 = handle;
      BOOL v82 = v12;
      int v81 = v7;
      uint64_t v14 = v83;
      do
      {
        if (!v14) {
          break;
        }
        uint64_t v15 = *(void *)(v14 + 32);
        char v16 = v77(&v75);
        uint64_t v14 = v15;
      }

      while ((v16 & 1) != 0);
      int v7 = *(_DWORD *)&handle->flow_id[v5];
      if (v7 == 4) {
        break;
      }
      _Block_object_dispose(buf, 8);
      if ((v7 & 0xFFFFFFFE) != 2) {
        return;
      }
    }

    char v20 = handle->default_input_handler;
    if (v20)
    {
      BOOL v21 = v20->callbacks;
      if (v21)
      {
        char v22 = (void (*)(void))v21->input_available;
        if (v22)
        {
          v22();
LABEL_34:
          _Block_object_dispose(buf, 8);
          return;
        }
      }
    }

    __nwlog_obj();
    uint64_t v46 = handle->default_input_handler;
    BOOL v47 = "invalid";
    if (v46)
    {
      char v48 = v46->identifier->name;
      if (v48) {
        BOOL v47 = v48;
      }
    }

    *(_DWORD *)os_log_type_t type = 136446466;
    os_log_type_t v86 = "nw_protocol_masque_input_available";
    __int16 v87 = 2082;
    os_log_type_t v88 = v47;
    __int16 v49 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v74 = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (__nwlog_fault(v49, &v74, &v73))
    {
      if (v74 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v50 = (os_log_s *)__nwlog_obj();
        os_log_type_t v51 = v74;
        if (!os_log_type_enabled(v50, v74)) {
          goto LABEL_126;
        }
        char v52 = handle->default_input_handler;
        char v53 = "invalid";
        if (v52)
        {
          id v54 = v52->identifier->name;
          if (v54) {
            char v53 = v54;
          }
        }

        *(_DWORD *)os_log_type_t type = 136446466;
        os_log_type_t v86 = "nw_protocol_masque_input_available";
        __int16 v87 = 2082;
        os_log_type_t v88 = v53;
        int v55 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_125;
      }

      if (!v73)
      {
        uint64_t v50 = (os_log_s *)__nwlog_obj();
        os_log_type_t v51 = v74;
        if (!os_log_type_enabled(v50, v74)) {
          goto LABEL_126;
        }
        uint64_t v67 = handle->default_input_handler;
        os_log_type_t v68 = "invalid";
        if (v67)
        {
          BOOL v69 = v67->identifier->name;
          if (v69) {
            os_log_type_t v68 = v69;
          }
        }

        *(_DWORD *)os_log_type_t type = 136446466;
        os_log_type_t v86 = "nw_protocol_masque_input_available";
        __int16 v87 = 2082;
        os_log_type_t v88 = v68;
        int v55 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_125;
      }

      BOOL v62 = (char *)__nw_create_backtrace_string();
      uint64_t v50 = (os_log_s *)__nwlog_obj();
      os_log_type_t v51 = v74;
      BOOL v63 = os_log_type_enabled(v50, v74);
      if (v62)
      {
        if (v63)
        {
          BOOL v64 = handle->default_input_handler;
          __int16 v65 = "invalid";
          if (v64)
          {
            size_t v66 = v64->identifier->name;
            if (v66) {
              __int16 v65 = v66;
            }
          }

          *(_DWORD *)os_log_type_t type = 136446722;
          os_log_type_t v86 = "nw_protocol_masque_input_available";
          __int16 v87 = 2082;
          os_log_type_t v88 = v65;
          __int16 v89 = 2082;
          id v90 = v62;
          _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  (uint8_t *)type,  0x20u);
        }

        free(v62);
        goto LABEL_126;
      }

      if (v63)
      {
        uint64_t v70 = handle->default_input_handler;
        BOOL v71 = "invalid";
        if (v70)
        {
          uint64_t v72 = v70->identifier->name;
          if (v72) {
            BOOL v71 = v72;
          }
        }

        *(_DWORD *)os_log_type_t type = 136446466;
        os_log_type_t v86 = "nw_protocol_masque_input_available";
        __int16 v87 = 2082;
        os_log_type_t v88 = v71;
        int v55 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_125:
        _os_log_impl(&dword_181A5C000, v50, v51, v55, (uint8_t *)type, 0x16u);
      }
    }

void nw_protocol_masque_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v42 = "nw_protocol_masque_input_finished";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_input_finished";
      uint64_t v11 = "%{public}s called with null protocol";
LABEL_67:
      __int16 v30 = v9;
      os_log_type_t v31 = v10;
      uint32_t v32 = 12;
LABEL_79:
      _os_log_impl(&dword_181A5C000, v30, v31, v11, buf, v32);
      goto LABEL_80;
    }

    if (!v39)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_input_finished";
      uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_67;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v22) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_input_finished";
      uint64_t v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_67;
    }

    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v42 = "nw_protocol_masque_input_finished";
      __int16 v43 = 2082;
      BOOL v44 = backtrace_string;
      os_log_type_t v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_48:
      _os_log_impl(&dword_181A5C000, v9, v10, v23, buf, 0x16u);
    }

nw_protocol *nw_protocol_masque_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_protocol_masque_get_remote_endpoint";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_masque_get_remote_endpoint";
      uint64_t v15 = "%{public}s called with null protocol";
    }

    else
    {
      if (!v20)
      {
        uint64_t v13 = (os_log_s *)__nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_48;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_protocol_masque_get_remote_endpoint";
        uint64_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_47;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v23 = "nw_protocol_masque_get_remote_endpoint";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v12) {
          return 0LL;
        }
        goto LABEL_49;
      }

      if (!v17) {
        goto LABEL_48;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_masque_get_remote_endpoint";
      uint64_t v15 = "%{public}s called with null protocol, no backtrace";
    }

uint64_t nw_protocol_masque_get_parameters(nw_protocol *a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v48 = "nw_protocol_masque_get_parameters";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)int buf = 136446210;
      char v48 = "nw_protocol_masque_get_parameters";
      os_log_type_t v29 = "%{public}s called with null protocol";
      goto LABEL_78;
    }

    if (!v45)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)int buf = 136446210;
      char v48 = "nw_protocol_masque_get_parameters";
      os_log_type_t v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_78;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v31 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v31) {
        goto LABEL_79;
      }
      *(_DWORD *)int buf = 136446210;
      char v48 = "nw_protocol_masque_get_parameters";
      os_log_type_t v29 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_78;
    }

    if (v31)
    {
      *(_DWORD *)int buf = 136446466;
      char v48 = "nw_protocol_masque_get_parameters";
      __int16 v49 = 2082;
      uint64_t v50 = backtrace_string;
      uint32_t v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_64:
      _os_log_impl(&dword_181A5C000, v27, v28, v32, buf, 0x16u);
    }

void sub_18200CB8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_masque_get_output_local_endpoint(nw_protocol *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v15 = "nw_protocol_masque_get_output_local_endpoint";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v15 = "nw_protocol_masque_get_output_local_endpoint";
      int v7 = "%{public}s called with null protocol";
    }

    else
    {
      if (!v12)
      {
        int v5 = (os_log_s *)__nwlog_obj();
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_34;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v15 = "nw_protocol_masque_get_output_local_endpoint";
        int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_33;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v15 = "nw_protocol_masque_get_output_local_endpoint";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v4) {
          return 0LL;
        }
        goto LABEL_35;
      }

      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v15 = "nw_protocol_masque_get_output_local_endpoint";
      int v7 = "%{public}s called with null protocol, no backtrace";
    }

uint64_t nw_protocol_masque_copy_info(uint64_t a1, int a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "nw_protocol_masque_copy_info";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        __int16 v16 = (os_log_s *)__nwlog_obj();
        os_log_type_t v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_56;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_masque_copy_info";
        uint64_t v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_55;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (!v20) {
          goto LABEL_56;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v26 = "nw_protocol_masque_copy_info";
        uint64_t v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_55;
      }

      if (v20)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v26 = "nw_protocol_masque_copy_info";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        BOOL v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_45:
        _os_log_impl(&dword_181A5C000, v16, v17, v21, buf, 0x16u);
      }

void nw_protocol_masque_notify(nw_protocol *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v41 = "nw_protocol_masque_notify";
    __int16 v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v41 = "nw_protocol_masque_notify";
      __int16 v30 = "%{public}s called with null protocol";
    }

    else if (v38)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v32 = os_log_type_enabled(v28, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v41 = "nw_protocol_masque_notify";
          __int16 v42 = 2082;
          nw_protocol_stack_t v43 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_101:
        if (!v27) {
          return;
        }
        goto LABEL_102;
      }

      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v41 = "nw_protocol_masque_notify";
      __int16 v30 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v41 = "nw_protocol_masque_notify";
      __int16 v30 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_100;
  }

  uint64_t handle = (uint64_t)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v41 = "nw_protocol_masque_notify";
    __int16 v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v38)
      {
        os_log_type_t v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v41 = "nw_protocol_masque_notify";
        __int16 v30 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_100;
      }

      BOOL v33 = (char *)__nw_create_backtrace_string();
      os_log_type_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v34 = os_log_type_enabled(v28, type);
      if (!v33)
      {
        if (!v34) {
          goto LABEL_101;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v41 = "nw_protocol_masque_notify";
        __int16 v30 = "%{public}s called with null masque, no backtrace";
        goto LABEL_100;
      }

      if (v34)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v41 = "nw_protocol_masque_notify";
        __int16 v42 = 2082;
        nw_protocol_stack_t v43 = v33;
        BOOL v35 = "%{public}s called with null masque, dumping backtrace:%{public}s";
LABEL_85:
        _os_log_impl(&dword_181A5C000, v28, v29, v35, buf, 0x16u);
      }

BOOL nw_protocol_masque_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v23 = "nw_protocol_masque_add_listen_handler";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        uint64_t v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_52;
        }
        *(_DWORD *)int buf = 136446210;
        char v23 = "nw_protocol_masque_add_listen_handler";
        uint64_t v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16) {
          goto LABEL_52;
        }
        *(_DWORD *)int buf = 136446210;
        char v23 = "nw_protocol_masque_add_listen_handler";
        uint64_t v13 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446466;
        char v23 = "nw_protocol_masque_add_listen_handler";
        __int16 v24 = 2082;
        BOOL v25 = backtrace_string;
        int v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A5C000, v11, v12, v17, buf, 0x16u);
      }

uint64_t nw_protocol_masque_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      if ((handle[529] & 1) == 0 && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        BOOL v9 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446978;
          BOOL v18 = "nw_protocol_masque_remove_listen_handler";
          __int16 v19 = 2082;
          char v20 = handle + 531;
          __int16 v21 = 2080;
          BOOL v22 = " ";
          __int16 v23 = 2048;
          __int16 v24 = a2;
          _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalled with listen_protocol %p",  buf,  0x2Au);
        }
      }

      if (*((nw_listen_protocol **)handle + 55) == a2)
      {
        *((void *)handle + 55) = 0LL;
        a2->protocol_handler = 0LL;
      }

      uint64_t result = 1LL;
      if ((handle[529] & 1) == 0 && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v10 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446722;
          BOOL v18 = "nw_protocol_masque_remove_listen_handler";
          __int16 v19 = 2082;
          char v20 = handle + 531;
          __int16 v21 = 2080;
          BOOL v22 = " ";
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sremoved protocol listen handler",  buf,  0x20u);
        }

        return 1LL;
      }

      return result;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_protocol_masque_remove_listen_handler";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_masque_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null masque";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    if (!v15)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_masque_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v14 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_masque_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null masque, no backtrace";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    if (v14)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v18 = "nw_protocol_masque_remove_listen_handler";
      __int16 v19 = 2082;
      char v20 = backtrace_string;
      uint64_t v13 = "%{public}s called with null masque, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

    goto LABEL_36;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v18 = "nw_protocol_masque_remove_listen_handler";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_masque_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v12 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_masque_remove_listen_handler";
        uint64_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    if (v12)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v18 = "nw_protocol_masque_remove_listen_handler";
      __int16 v19 = 2082;
      char v20 = backtrace_string;
      uint64_t v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v6, v7, v13, buf, 0x16u);
    }

void nw_protocol_masque_reset_demux_protocol(nw_protocol *a1)
{
  v25[3] = *MEMORY[0x1895F89C0];
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_reset_demux_protocol";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_reset_demux_protocol";
      BOOL v16 = "%{public}s called with null masque";
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_masque_reset_demux_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_48;
      }

      if (!v18)
      {
LABEL_48:
        if (v13) {
          free(v13);
        }
        return;
      }

      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_reset_demux_protocol";
      BOOL v16 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_reset_demux_protocol";
      BOOL v16 = "%{public}s called with null masque, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_48;
  }

  output_handler = a1->output_handler;
  if (!output_handler) {
    return;
  }
  int v3 = 0;
  while (1)
  {
    identifier = output_handler->identifier;
    if (nw_protocol_demux_identifier::onceToken[0] != -1) {
      dispatch_once(nw_protocol_demux_identifier::onceToken, &__block_literal_global_25762);
    }
    if (nw_protocols_are_equal(identifier, &g_demux_protocol_identifier)) {
      break;
    }
    name = output_handler->identifier->name;
    if (!strcmp(name, "quic"))
    {
      if ((v3 & 1) != 0) {
        return;
      }
      int v3 = 1;
      output_handler = output_handler->output_handler;
      if (!output_handler) {
        return;
      }
    }

    else
    {
      BOOL v6 = strcmp(name, "quic-connection") == 0;
      if ((v6 & v3 & 1) != 0) {
        return;
      }
      v3 |= v6;
      output_handler = output_handler->output_handler;
      if (!output_handler) {
        return;
      }
    }
  }

  if ((v3 & 1) != 0)
  {
    *((void *)handle + 54) = output_handler;
    if ((handle[529] & 1) == 0 && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      __int16 v19 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_reset_demux_protocol";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 531;
        *(_WORD *)&_BYTE buf[22] = 2080;
        __int16 v24 = " ";
        LOWORD(v25[0]) = 2048;
        *(void *)((char *)v25 + 2) = output_handler;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound demux protocol %p",  buf,  0x2Au);
      }
    }

    id v7 = nw_parameters_copy_channel_demux_options(*((void **)handle + 40));
    if (v7)
    {
      uint64_t v8 = v7;
      if (nw_protocol_demux_copy_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
      }
      if (nw_protocol_demux_copy_definition::definition)
      {
        BOOL v9 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
        BOOL v10 = nw_protocol_options_matches_definition(v8, v9);
        BOOL v11 = v10;
        if (v9)
        {
          os_release(v9);
          if (!v11) {
            return;
          }
        }

        else if (!v10)
        {
          return;
        }
      }

      else if (!nw_protocol_options_matches_definition(v8, 0LL))
      {
        return;
      }

      v20[0] = MEMORY[0x1895F87A8];
      v20[1] = 0x40000000LL;
      v20[2] = ___ZL39nw_protocol_masque_reset_demux_protocolP11nw_protocol_block_invoke;
      v20[3] = &__block_descriptor_tmp_69_27144;
      void v20[4] = handle;
      void v20[5] = v8;
      *(void *)int buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __nw_demux_options_enumerate_patterns_block_invoke;
      __int16 v24 = (const char *)&unk_189BB9D20;
      v25[0] = v20;
      nw_protocol_options_access_handle(v8, buf);
    }
  }

  else if ((handle[529] & 1) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    BOOL v12 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_reset_demux_protocol";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 531;
      *(_WORD *)&_BYTE buf[22] = 2080;
      __int16 v24 = " ";
      LOWORD(v25[0]) = 2048;
      *(void *)((char *)v25 + 2) = output_handler;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound demux protocol %p, but no QUIC found. Ignoring.",  buf,  0x2Au);
    }
  }

uint64_t nw_masque_setup_demux(uint64_t a1, int a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v21 = "nw_masque_setup_demux";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)int buf = 136446210;
      char v21 = "nw_masque_setup_demux";
      os_log_type_t v15 = "%{public}s called with null masque";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          char v21 = "nw_masque_setup_demux";
          __int16 v22 = 2082;
          __int16 v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }

      if (!v17)
      {
LABEL_43:
        if (v12) {
          free(v12);
        }
        return 0LL;
      }

      *(_DWORD *)int buf = 136446210;
      char v21 = "nw_masque_setup_demux";
      os_log_type_t v15 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)int buf = 136446210;
      char v21 = "nw_masque_setup_demux";
      os_log_type_t v15 = "%{public}s called with null masque, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_43;
  }

  if ((*(_BYTE *)(a1 + 530) & 2) != 0) {
    return 1LL;
  }
  uint64_t result = *(void *)(a1 + 432);
  if (!result) {
    return result;
  }
  if (a2)
  {
    if (*(void *)(a1 + 384)) {
      goto LABEL_9;
    }
  }

  else if (*(void *)(a1 + 392))
  {
    goto LABEL_9;
  }

  if (!*(void *)(a1 + 448)) {
    return 0LL;
  }
LABEL_9:
  int v5 = *(uint64_t (***)(void))(result + 24);
  if (!v5) {
    return 0LL;
  }
  BOOL v6 = *v5;
  if (!v6) {
    return 0LL;
  }
  char v7 = v6();
  int v8 = *(_DWORD *)(a1 + 527);
  if ((v7 & 1) == 0)
  {
    if ((v8 & 0x10000) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      BOOL v11 = (os_log_s *)gprivacy_proxyLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result) {
        return result;
      }
      *(_DWORD *)int buf = 136446466;
      char v21 = (const char *)(a1 + 531);
      __int16 v22 = 2080;
      __int16 v23 = " ";
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, "%{public}s%sFailed to add demux protocol", buf, 0x16u);
    }

    return 0LL;
  }

  uint64_t result = 1LL;
  if ((v8 & 0x10000) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    BOOL v9 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446978;
      char v21 = "nw_masque_setup_demux";
      __int16 v22 = 2082;
      __int16 v23 = (const char *)(a1 + 531);
      __int16 v24 = 2080;
      uint64_t v25 = " ";
      if (a2) {
        BOOL v10 = "input";
      }
      else {
        BOOL v10 = "output";
      }
      __int16 v26 = 2082;
      __int16 v27 = v10;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAdded %{public}s demux protocol",  buf,  0x2Au);
    }

    return 1LL;
  }

  return result;
}

uint64_t nw_masque_setup_reverse_proxy(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  int v2 = *(_DWORD *)(a1 + 527);
  if ((v2 & 0x1000000) == 0)
  {
    if ((v2 & 0x10000) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      int v3 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = a1 + 531;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s%sHave certificates, but no HTTP in the stack identified for forwarding",  buf,  0x16u);
      }
    }

    return 0LL;
  }

  uint64_t v5 = a1;
  while (1)
  {
    BOOL v6 = *(void **)(v5 + 16);
    if (nw_protocol_http_messaging_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_76181);
    }
    BOOL v7 = nw_protocols_are_equal(v6, nw_protocol_http_messaging_identifier::protocol_identifier);
    if (v7) {
      break;
    }
    uint64_t v5 = *(void *)(v5 + 48);
    if (!v5) {
      goto LABEL_17;
    }
  }

  if ((*(_BYTE *)(a1 + 529) & 1) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    __int16 v42 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_masque_setup_reverse_proxy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 531;
      *(_WORD *)&_BYTE buf[22] = 2080;
      char v53 = " ";
      __int16 v54 = 2048;
      uint64_t v55 = v5;
      _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound HTTP Messaging protocol %p",  buf,  0x2Au);
    }
  }

void sub_18200FAD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_masque_report_error_to_proxy_agent(uint64_t a1, int a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    uu[0] = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (uu[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = uu[0];
      if (!os_log_type_enabled(v13, uu[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
      char v15 = "%{public}s called with null masque";
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = uu[0];
      BOOL v17 = os_log_type_enabled(v13, uu[0]);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
          __int16 v23 = 2082;
          int v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_46:
        if (!v12) {
          return;
        }
LABEL_47:
        free(v12);
        return;
      }

      if (!v17) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
      char v15 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = uu[0];
      if (!os_log_type_enabled(v13, uu[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v22 = "nw_masque_report_error_to_proxy_agent";
      char v15 = "%{public}s called with null masque, backtrace limit exceeded";
    }

uint64_t ___ZL29nw_masque_setup_reverse_proxyP9nw_masque_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 40);
  if ((!v4 || (*(_BYTE *)(v4 + 529) & 1) == 0) && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    BOOL v7 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      BOOL v9 = v8 == 0;
      if (v8) {
        BOOL v10 = (const char *)(v8 + 531);
      }
      else {
        BOOL v10 = "";
      }
      int v12 = 136446978;
      uint64_t v13 = "nw_masque_setup_reverse_proxy_block_invoke";
      __int16 v14 = 2082;
      char v15 = v10;
      if (v9) {
        uint64_t v11 = "";
      }
      else {
        uint64_t v11 = " ";
      }
      __int16 v16 = 2080;
      BOOL v17 = v11;
      __int16 v18 = 2112;
      BOOL v19 = a2;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sChecking secondary certificate %@ to join for reverse-proxying",  (uint8_t *)&v12,  0x2Au);
    }
  }

  int is_equal = nw_endpoint_is_equal(a2, *(void **)(a1 + 48), 0LL);
  if (is_equal) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return is_equal ^ 1u;
}

void ___ZL29nw_masque_setup_reverse_proxyP9nw_masque_block_invoke_67(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v1 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (v1)
  {
    uint64_t v2 = v1;
    if ((*(_BYTE *)(v1 + 529) & 1) == 0 && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      int v3 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v4 = 136446722;
        uint64_t v5 = "nw_masque_setup_reverse_proxy_block_invoke";
        __int16 v6 = 2082;
        uint64_t v7 = v2 + 531;
        __int16 v8 = 2080;
        BOOL v9 = " ";
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRestarting HTTP request stack for reverse proxy",  (uint8_t *)&v4,  0x20u);
      }
    }

    nw_protocol_notify(*(void **)(v2 + 48), v2, 25);
  }

BOOL ___ZL39nw_protocol_masque_reset_demux_protocolP11nw_protocol_block_invoke(uint64_t a1, int a2)
{
  if (a2) {
    *(void *)(*(void *)(a1 + 32) + 448LL) = nw_protocol_options_copy(*(void **)(a1 + 40));
  }
  return a2 == 0;
}

BOOL ___ZL33nw_protocol_masque_get_definitionv_block_invoke()
{
  nw_protocol_masque_get_definition(void)::nw_protocol_definition_t definition = (uint64_t)nw_protocol_definition_create_with_identifier((__int128 *)nw_protocol_masque_identifier(void)::g_masque_protocol_identifier);
  nw_protocol_definition_set_is_proxy((void *)nw_protocol_masque_get_definition(void)::definition);
  nw_protocol_definition_set_globals_allocator( (void *)nw_protocol_masque_get_definition(void)::definition,  nw_masque_allocate_globals,  nw_masque_deallocate_globals);
  nw_protocol_definition_set_options_allocator( (void *)nw_protocol_masque_get_definition(void)::definition,  (uint64_t)nw_masque_allocate_options,  (uint64_t)nw_masque_copy_options,  (uint64_t)nw_masque_deallocate_options);
  nw_protocol_definition_set_options_equality_check( (void *)nw_protocol_masque_get_definition(void)::definition,  (uint64_t)nw_masque_option_is_equal);
  nw_protocol_definition_set_options_serializer( (void *)nw_protocol_masque_get_definition(void)::definition,  0,  (uint64_t)nw_masque_serialize_options,  (uint64_t)nw_masque_deserialize_options);
  nw_protocol_definition_set_metadata_allocator( (void *)nw_protocol_masque_get_definition(void)::definition,  (uint64_t)nw_masque_allocate_metadata,  (uint64_t)nw_masque_deallocate_metadata);
  nw_protocol_definition_set_metadata_comparator( (void *)nw_protocol_masque_get_definition(void)::definition,  (uint64_t)nw_masque_compare_metadata);
  return nw_protocol_register_handle( (uint64_t)nw_protocol_masque_identifier(void)::g_masque_protocol_identifier,  (void *)nw_protocol_masque_get_definition(void)::definition,  (uint64_t)nw_protocol_masque_create,  0LL);
}

BOOL nw_masque_allocate_metadata(nw_protocol_definition *a1)
{
  uint64_t v1 = calloc(1uLL, 0x10uLL);
  if (v1) {
    return (BOOL)v1;
  }
  int v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  int v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }

  __break(1u);
  return result;
}

void nw_masque_deallocate_metadata(nw_protocol_definition *a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_masque_compare_metadata(uint64_t a1, void *a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if (a3) {
      return *a2 == *a3;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v15 = "nw_masque_compare_metadata";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v15 = "nw_masque_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle2";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v12)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v15 = "nw_masque_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle2, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        char v15 = "nw_masque_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle2, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v11)
    {
      *(_DWORD *)int buf = 136446466;
      char v15 = "nw_masque_compare_metadata";
      __int16 v16 = 2082;
      BOOL v17 = backtrace_string;
      uint64_t v10 = "%{public}s called with null handle2, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  char v15 = "nw_masque_compare_metadata";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v15 = "nw_masque_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle1, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        char v15 = "nw_masque_compare_metadata";
        uint64_t v7 = "%{public}s called with null handle1, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v9)
    {
      *(_DWORD *)int buf = 136446466;
      char v15 = "nw_masque_compare_metadata";
      __int16 v16 = 2082;
      BOOL v17 = backtrace_string;
      uint64_t v10 = "%{public}s called with null handle1, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    }

BOOL nw_protocol_masque_create( const nw_protocol_identifier *a1, nw_object *a2, nw_endpoint *a3, nw_parameters *a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  __memptr = 0LL;
  if (posix_memalign(&__memptr, 8uLL, 0x270uLL) || (os_log_type_t v6 = (char *)__memptr) == 0LL)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    *(_DWORD *)BOOL v17 = 136446722;
    *(void *)&void v17[4] = "strict_memalign";
    *(_WORD *)&v17[12] = 2048;
    *(void *)&v17[14] = 8LL;
    *(_WORD *)&v17[22] = 2048;
    uint64_t v18 = 624LL;
    __int16 v14 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v14);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v14);
    os_log_type_t v6 = (char *)__memptr;
  }

  bzero(v6, 0x270uLL);
  *(void *)BOOL v17 = 0LL;
  *(void *)&v17[8] = v17;
  *(void *)&v17[16] = 0x2000000000LL;
  uint64_t v7 = MEMORY[0x1895F87A8];
  uint64_t v18 = (uint64_t)v6;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 0x40000000LL;
  aBlock[2] = ___ZL25nw_protocol_masque_createPK22nw_protocol_identifierP9nw_objectP11nw_endpointP13nw_parameters_block_invoke;
  aBlock[3] = &unk_189BBA3F8;
  void aBlock[4] = v17;
  *((void *)v6 + 62) = _Block_copy(aBlock);
  _Block_object_dispose(v17, 8);
  *((void *)v6 + 2) = nw_protocol_masque_identifier(void)::g_masque_protocol_identifier;
  *((void *)v6 + 3) = &nw_protocol_masque_get_callbacks(void)::g_masque_protocol_callbacks;
  *((void *)v6 + 5) = v6;
  *((void *)v6 + 1_Block_object_dispose(va, 8) = nw_protocol_masque_identifier(void)::g_masque_protocol_identifier;
  *((void *)v6 + 19) = &nw_protocol_masque_get_callbacks(void)::g_masque_protocol_callbacks;
  *((void *)v6 + 21) = v6;
  *((void *)v6 + 26) = nw_protocol_masque_identifier(void)::g_masque_protocol_identifier;
  *((void *)v6 + 27) = &nw_protocol_masque_get_callbacks(void)::g_masque_protocol_callbacks;
  *((void *)v6 + 29) = v6;
  *((void *)v6 + 10) = nw_protocol_masque_identifier(void)::g_masque_protocol_identifier;
  *((void *)v6 + 11) = &nw_protocol_masque_get_callbacks(void)::g_masque_protocol_callbacks;
  *((void *)v6 + 13) = v6;
  *((void *)v6 + 32) = 0LL;
  *((void *)v6 + 33) = v6 + 256;
  if (a3) {
    __int16 v8 = os_retain(a3);
  }
  else {
    __int16 v8 = 0LL;
  }
  *((void *)v6 + 3_Block_object_dispose(va, 8) = v8;
  *((_DWORD *)v6 + 12_Block_object_dispose(va, 8) = 0;
  *((void *)v6 + 63) = 1LL;
  else {
    int v9 = 0;
  }
  *(_DWORD *)(v6 + 527) = *(_DWORD *)(v6 + 527) & 0xFFFEFFFF | v9;
  uint64_t v10 = (void *)nw_protocol_masque_get_definition(void)::definition;
  singleton = nw_protocol_metadata_create_singleton(v10);
  *((void *)v6 + 59) = singleton;
  *(void *)BOOL v17 = v7;
  *(void *)&v17[8] = 0x40000000LL;
  *(void *)&v17[16] = ___ZL23nw_masque_set_callbacksP20nw_protocol_metadataPv_block_invoke;
  uint64_t v18 = (uint64_t)&__block_descriptor_tmp_192;
  BOOL v19 = v6;
  nw_protocol_metadata_access_handle((uint64_t)singleton, (uint64_t)v17);
  return (BOOL)v6;
}

uint64_t ___ZL25nw_protocol_masque_createPK22nw_protocol_identifierP9nw_objectP11nw_endpointP13nw_parameters_block_invoke( uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t ___ZL23nw_masque_set_callbacksP20nw_protocol_metadataPv_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4 = (os_unfair_lock_s *)(a2 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 8));
  *(void *)a2 = *(void *)(a1 + 32);
  os_unfair_lock_unlock(v4);
  return 1LL;
}

void ___ZL32nw_protocol_masque_get_callbacksv_block_invoke()
{
  qword_18C5938E8 = (uint64_t)nw_protocol_default_reset;
  unk_18C5938F0 = nw_protocol_default_input_flush;
  qword_18C593878 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C593880 = nw_protocol_default_unregister_notification;
  qword_18C5938D8 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_18C5938E0 = nw_protocol_default_get_message_properties;
  nw_protocol_masque_get_callbacks(void)::g_masque_protocol_callbacks = (uint64_t)nw_protocol_masque_add_input_handler;
  unk_18C5937F0 = nw_protocol_masque_remove_input_handler;
  qword_18C5937F8 = (uint64_t)nw_protocol_masque_replace_input_handler;
  unk_18C593800 = nw_protocol_masque_connect;
  qword_18C593808 = (uint64_t)nw_protocol_masque_disconnect;
  unk_18C593810 = nw_protocol_masque_connected;
  qword_18C593818 = (uint64_t)nw_protocol_masque_disconnected;
  unk_18C593820 = nw_protocol_masque_error;
  qword_18C5938B8 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C5938C0 = nw_protocol_masque_waiting_for_output;
  qword_18C593848 = (uint64_t)nw_protocol_masque_finalize_output_frames;
  unk_18C593850 = nw_protocol_default_link_state;
  qword_18C593838 = (uint64_t)nw_protocol_masque_get_input_frames;
  unk_18C593840 = nw_protocol_masque_get_output_frames;
  qword_18C593828 = (uint64_t)nw_protocol_masque_input_available;
  unk_18C593830 = nw_protocol_default_output_available;
  qword_18C593898 = (uint64_t)nw_protocol_masque_supports_external_data;
  unk_18C5938A0 = nw_protocol_masque_input_finished;
  qword_18C593868 = (uint64_t)nw_protocol_default_get_local;
  unk_18C593870 = nw_protocol_masque_get_remote_endpoint;
  qword_18C593858 = (uint64_t)nw_protocol_masque_get_parameters;
  unk_18C593860 = nw_protocol_default_get_path;
  qword_18C5938A8 = (uint64_t)nw_protocol_default_output_finished;
  unk_18C5938B0 = nw_protocol_masque_get_output_local_endpoint;
  qword_18C5938C8 = (uint64_t)nw_protocol_masque_copy_info;
  unk_18C5938D0 = nw_protocol_default_add_listen_handler;
  qword_18C593888 = (uint64_t)nw_protocol_masque_notify;
  unk_18C593890 = nw_protocol_default_updated_path;
}

uint64_t nw_protocol_masque_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v127 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_add_input_handler";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v111) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_53;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_add_input_handler";
      __int16 v8 = "%{public}s called with null protocol";
      goto LABEL_99;
    }

    if ((_BYTE)v111)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type[0];
      BOOL v40 = os_log_type_enabled(v37, type[0]);
      if (backtrace_string)
      {
        if (!v40) {
          goto LABEL_85;
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v41 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_84;
      }

      if (!v40) {
        goto LABEL_53;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_add_input_handler";
      __int16 v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_53;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_add_input_handler";
      __int16 v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void sub_18201263C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_masque_get_output_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v42 = "nw_protocol_masque_get_output_frames";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_get_output_frames";
      nw_protocol_stack_t v34 = "%{public}s called with null protocol";
      goto LABEL_77;
    }

    if (!v39)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_get_output_frames";
      nw_protocol_stack_t v34 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v32 = (os_log_s *)__nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v36 = os_log_type_enabled(v32, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_get_output_frames";
      nw_protocol_stack_t v34 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_77;
    }

    if (v36)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v42 = "nw_protocol_masque_get_output_frames";
      __int16 v43 = 2082;
      __int16 v44 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_78:
    if (!v31) {
      return 0LL;
    }
LABEL_79:
    free(v31);
    return 0LL;
  }

  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v42 = "nw_protocol_masque_get_output_frames";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_get_output_frames";
      nw_protocol_stack_t v34 = "%{public}s called with null masque";
      goto LABEL_77;
    }

    if (!v39)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_get_output_frames";
      nw_protocol_stack_t v34 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_77;
    }

    uint64_t v37 = (char *)__nw_create_backtrace_string();
    uint64_t v32 = (os_log_s *)__nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v38 = os_log_type_enabled(v32, type);
    if (v37)
    {
      if (v38)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v42 = "nw_protocol_masque_get_output_frames";
        __int16 v43 = 2082;
        __int16 v44 = v37;
        _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v37);
      if (!v31) {
        return 0LL;
      }
      goto LABEL_79;
    }

    if (v38)
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v42 = "nw_protocol_masque_get_output_frames";
      nw_protocol_stack_t v34 = "%{public}s called with null masque, no backtrace";
LABEL_77:
      _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
      goto LABEL_78;
    }

    goto LABEL_78;
  }

  int v9 = handle[127];
  if (v9 == 1) {
    goto LABEL_20;
  }
  if (v9 == 2)
  {
    int v19 = *(_DWORD *)((char *)handle + 527);
    if ((v19 & 0x600000) != 0x200000) {
      goto LABEL_30;
    }
LABEL_20:
    if (!*((void *)handle + 32))
    {
      if ((*((_BYTE *)handle + 527) & 0x28) != 0) {
        unsigned int v20 = a3;
      }
      else {
        unsigned int v20 = a4;
      }
      if (v20 >= 0x7D0) {
        size_t v21 = 2000LL;
      }
      else {
        size_t v21 = v20;
      }
      if ((_DWORD)v21)
      {
        BOOL v22 = nw_calloc_type<unsigned char>(v21);
        int v23 = v21;
      }

      else
      {
        BOOL v22 = 0LL;
        int v23 = 0;
      }

      uint64_t v27 = nw_frame_create(0, v22, v23, (uint64_t)nw_protocol_masque_frame_finalizer, (uint64_t)handle);
      uint64_t v16 = 1LL;
      nw_frame_set_buffer_used_malloc(v27, 1);
      *(void *)(v27 + 16) = 0LL;
      os_log_type_t v28 = (uint64_t *)*((void *)handle + 33);
      *(void *)(v27 + 24) = v28;
      *os_log_type_t v28 = v27;
      *((void *)handle + 33) = v27 + 16;
      *(void *)(v27 + 32) = 0LL;
      tqh_last = a6->tqh_last;
      *(void *)(v27 + 40) = tqh_last;
      *tqh_last = (nw_frame *)v27;
      a6->tqh_last = (nw_frame **)(v27 + 32);
      if ((*((_BYTE *)handle + 529) & 1) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v30 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446978;
          BOOL v42 = "nw_protocol_masque_get_output_frames";
          __int16 v43 = 2082;
          __int16 v44 = (char *)handle + 531;
          __int16 v45 = 2080;
          __int16 v46 = " ";
          __int16 v47 = 1024;
          int v48 = v21;
          _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sMASQUE waiting for early data, returning 1 frame with %u bytes",  buf,  0x26u);
        }
      }

      return v16;
    }

    return 0LL;
  }

  if (v9 != 4)
  {
    int v19 = *(_DWORD *)((char *)handle + 527);
LABEL_30:
    if ((v19 & 0x10000) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      int v24 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446722;
        BOOL v42 = "nw_protocol_masque_get_output_frames";
        __int16 v43 = 2082;
        __int16 v44 = (char *)handle + 531;
        __int16 v45 = 2080;
        __int16 v46 = " ";
        _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sMASQUE not yet connected, returning 0 frames",  buf,  0x20u);
      }
    }

    return 0LL;
  }

  int v10 = *(_DWORD *)((char *)handle + 527);
  if ((v10 & 0x800000) != 0)
  {
    char v12 = (nw_protocol *)*((void *)handle + 28);
LABEL_38:
    if (v12) {
      output_handler = v12;
    }
    else {
      output_handler = a1->output_handler;
    }
    return ((uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))output_handler->callbacks->get_output_frames)( output_handler,  a1,  a3,  a4,  a5,  a6);
  }

  BOOL v11 = (v10 & 0x500) == 0 || (v10 & 0x100000) == 0;
  if (!v11 || handle[128] == 4)
  {
    char v12 = (nw_protocol *)*((void *)handle + 28);
    if (v12)
    {
      if (*((void *)handle + 32))
      {
        else {
          size_t v13 = a3;
        }
        BOOL v14 = nw_calloc_type<unsigned char>(v13);
        uint64_t v15 = nw_frame_create(0, v14, v13, (uint64_t)nw_protocol_masque_frame_finalizer, (uint64_t)handle);
        uint64_t v16 = 1LL;
        nw_frame_set_buffer_used_malloc(v15, 1);
        *(void *)(v15 + 16) = 0LL;
        BOOL v17 = (uint64_t *)*((void *)handle + 33);
        *(void *)(v15 + 24) = v17;
        *BOOL v17 = v15;
        *((void *)handle + 33) = v15 + 16;
        *(void *)(v15 + 32) = 0LL;
        uint64_t v18 = a6->tqh_last;
        *(void *)(v15 + 40) = v18;
        void *v18 = (nw_frame *)v15;
        a6->tqh_last = (nw_frame **)(v15 + 32);
        return v16;
      }

      *(_DWORD *)((char *)handle + 527) = v10 | 0x800000;
      goto LABEL_38;
    }
  }

  output_handler = a1->output_handler;
  return ((uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))output_handler->callbacks->get_output_frames)( output_handler,  a1,  a3,  a4,  a5,  a6);
}

uint64_t nw_protocol_masque_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      uint64_t v37 = 0LL;
      BOOL v38 = &v37;
      tqh_first = a2->tqh_first;
      if (a2->tqh_first)
      {
        *((void *)tqh_first + 5) = &v37;
        tqh_last = a2->tqh_last;
        uint64_t v37 = tqh_first;
        BOOL v38 = tqh_last;
        a2->tqh_first = 0LL;
        a2->tqh_last = &a2->tqh_first;
      }

      uint64_t v6 = MEMORY[0x1895F87A8];
      if (*((void *)handle + 32))
      {
        int v7 = handle[127];
        if (v7 == 1 || v7 == 2 && (*(_DWORD *)((char *)handle + 527) & 0x600000) == 0x200000)
        {
          *(void *)int buf = 0LL;
          *(void *)&buf[8] = buf;
          *(void *)&buf[16] = 0x2000000000LL;
          char v40 = 0;
          v31[0] = MEMORY[0x1895F87A8];
          v31[1] = 0x40000000LL;
          uint64_t v32 = (uint64_t (*)(void *))___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
          os_log_type_t v33 = &unk_189BBA748;
          nw_protocol_stack_t v34 = buf;
          BOOL v35 = handle;
          BOOL v36 = a1;
          do
          {
            __int16 v8 = v37;
            if (!v37) {
              break;
            }
            uint64_t v9 = *((void *)v37 + 4);
            int v10 = (void *)*((void *)v37 + 5);
            if (v9)
            {
              *(void *)(v9 + 40) = v10;
              int v10 = (void *)*((void *)v8 + 5);
            }

            else
            {
              BOOL v38 = (nw_frame **)*((void *)v37 + 5);
            }

            void *v10 = v9;
            *((void *)v8 + 4) = 0LL;
            *((void *)v8 + 5) = 0LL;
          }

          while ((v32(v31) & 1) != 0);
          _Block_object_dispose(buf, 8);
        }
      }

      *(void *)int buf = 0LL;
      *(void *)&buf[8] = buf;
      v30[0] = 0LL;
      v30[1] = v30;
      v23[0] = v6;
      v23[1] = 0x40000000LL;
      int v24 = ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_126;
      os_log_type_t v25 = &__block_descriptor_tmp_131;
      BOOL v26 = handle;
      uint64_t v27 = buf;
      os_log_type_t v28 = a1;
      uint32_t v29 = v30;
      do
      {
        char v12 = v37;
        if (!v37) {
          break;
        }
        uint64_t v13 = *((void *)v37 + 4);
        BOOL v11 = (void *)*((void *)v37 + 5);
        if (v13)
        {
          *(void *)(v13 + 40) = v11;
          BOOL v11 = (void *)*((void *)v12 + 5);
        }

        else
        {
          BOOL v38 = (nw_frame **)*((void *)v37 + 5);
        }

        void *v11 = v13;
        *((void *)v12 + 4) = 0LL;
        *((void *)v12 + 5) = 0LL;
      }

      while ((((uint64_t (*)(void *))v24)(v23) & 1) != 0);
      if (v30[0]) {
        (*(void (**)(void))(*(void *)(*((void *)handle + 28) + 24LL) + 96LL))();
      }
      if (*(void *)buf) {
        ((void (*)(void))a1->output_handler->callbacks->finalize_output_frames)();
      }
      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v37) = 16;
    LOBYTE(v30[0]) = 0;
    if (v37 == 17)
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = v37;
      if (os_log_type_enabled(v16, (os_log_type_t)v37))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null masque";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    if (!LOBYTE(v30[0]))
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = v37;
      if (os_log_type_enabled(v16, (os_log_type_t)v37))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = v37;
    BOOL v22 = os_log_type_enabled(v16, (os_log_type_t)v37);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null masque, no backtrace";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      size_t v21 = "%{public}s called with null masque, dumping backtrace:%{public}s";
      goto LABEL_44;
    }

    goto LABEL_45;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
  uint64_t v15 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v37) = 16;
  LOBYTE(v30[0]) = 0;
  if (v37 != 17)
  {
    if (!LOBYTE(v30[0]))
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = v37;
      if (os_log_type_enabled(v16, (os_log_type_t)v37))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = v37;
    BOOL v20 = os_log_type_enabled(v16, (os_log_type_t)v37);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_54;
      }

      goto LABEL_55;
    }

    if (v20)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      size_t v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v16, v17, v21, buf, 0x16u);
    }

uint64_t nw_protocol_masque_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v77 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v70 = "nw_protocol_masque_get_input_frames";
    BOOL v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v56) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v56)
      {
        uint64_t v37 = (os_log_s *)__nwlog_obj();
        os_log_type_t v38 = type[0];
        if (!os_log_type_enabled(v37, type[0])) {
          goto LABEL_86;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v70 = "nw_protocol_masque_get_input_frames";
        char v39 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_85;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type[0];
      BOOL v41 = os_log_type_enabled(v37, type[0]);
      if (!backtrace_string)
      {
        if (!v41) {
          goto LABEL_86;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v70 = "nw_protocol_masque_get_input_frames";
        char v39 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_85;
      }

      if (v41)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v70 = "nw_protocol_masque_get_input_frames";
        __int16 v71 = 2082;
        uint64_t v72 = backtrace_string;
        BOOL v42 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_68:
        _os_log_impl(&dword_181A5C000, v37, v38, v42, buf, 0x16u);
      }

uint64_t ___ZL35nw_protocol_masque_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  int v4 = nw_frame_copy_metadata_for_protocol(a2, a1[5]);
  if (v4)
  {
    uint64_t v5 = v4;
    BOOL is_capsule = nw_http_metadata_is_capsule(v4);
    uint64_t v7 = a1[6];
    if (is_capsule)
    {
      nw_masque_handle_capsule(a1[6], v5);
      uint64_t v8 = *(void *)(a2 + 32);
      uint64_t v9 = *(void **)(a2 + 40);
      if (v8)
      {
        *(void *)(v8 + 40) = v9;
        uint64_t v9 = *(void **)(a2 + 40);
      }

      else
      {
        *(void *)(a1[7] + 8LL) = v9;
      }

      *uint64_t v9 = v8;
      *(void *)(a2 + 32) = 0LL;
      *(void *)(a2 + 40) = 0LL;
      uint64_t v25 = *(void *)(a1[4] + 8LL);
      int v26 = *(_DWORD *)(v25 + 24);
      *(_DWORD *)(v25 + 24) = v26 - 1;
      if (v26)
      {
LABEL_65:
        nw_frame_finalize(a2);
        goto LABEL_66;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
      *(_DWORD *)int buf = 136446978;
      uint64_t v56 = "nw_protocol_masque_get_input_frames_block_invoke";
      __int16 v57 = 2082;
      uint32_t v58 = "count";
      __int16 v59 = 2048;
      uint64_t v60 = 1LL;
      __int16 v61 = 2048;
      uint64_t v62 = v27;
      int v28 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v53 = 0;
      if (__nwlog_fault(v28, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v29 = (os_log_s *)gLogObj;
          os_log_type_t v30 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v31 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
            *(_DWORD *)int buf = 136446978;
            uint64_t v56 = "nw_protocol_masque_get_input_frames_block_invoke";
            __int16 v57 = 2082;
            uint32_t v58 = "count";
            __int16 v59 = 2048;
            uint64_t v60 = 1LL;
            __int16 v61 = 2048;
            uint64_t v62 = v31;
            uint64_t v32 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_61:
            _os_log_impl(&dword_181A5C000, v29, v30, v32, buf, 0x2Au);
          }
        }

        else if (v53)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v29 = (os_log_s *)gLogObj;
          os_log_type_t v30 = type;
          BOOL v37 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v37)
            {
              uint64_t v38 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
              *(_DWORD *)int buf = 136447234;
              uint64_t v56 = "nw_protocol_masque_get_input_frames_block_invoke";
              __int16 v57 = 2082;
              uint32_t v58 = "count";
              __int16 v59 = 2048;
              uint64_t v60 = 1LL;
              __int16 v61 = 2048;
              uint64_t v62 = v38;
              __int16 v63 = 2082;
              BOOL v64 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(backtrace_string);
            goto LABEL_62;
          }

          if (v37)
          {
            uint64_t v43 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
            *(_DWORD *)int buf = 136446978;
            uint64_t v56 = "nw_protocol_masque_get_input_frames_block_invoke";
            __int16 v57 = 2082;
            uint32_t v58 = "count";
            __int16 v59 = 2048;
            uint64_t v60 = 1LL;
            __int16 v61 = 2048;
            uint64_t v62 = v43;
            uint64_t v32 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_61;
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v29 = (os_log_s *)gLogObj;
          os_log_type_t v30 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v42 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
            *(_DWORD *)int buf = 136446978;
            uint64_t v56 = "nw_protocol_masque_get_input_frames_block_invoke";
            __int16 v57 = 2082;
            uint32_t v58 = "count";
            __int16 v59 = 2048;
            uint64_t v60 = 1LL;
            __int16 v61 = 2048;
            uint64_t v62 = v42;
            uint64_t v32 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_61;
          }
        }
      }

void nw_masque_setup_server_connect(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!*(void *)(a1 + 320))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint32_t v24 = "nw_masque_setup_server_connect";
    id v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)int buf = 136446210;
      uint32_t v24 = "nw_masque_setup_server_connect";
      uint64_t v15 = "%{public}s called with null masque->parameters";
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          uint32_t v24 = "nw_masque_setup_server_connect";
          __int16 v25 = 2082;
          int v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null masque->parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_54;
      }

      if (!v17)
      {
LABEL_54:
        if (v12) {
          free(v12);
        }
        return;
      }

      *(_DWORD *)int buf = 136446210;
      uint32_t v24 = "nw_masque_setup_server_connect";
      uint64_t v15 = "%{public}s called with null masque->parameters, no backtrace";
    }

    else
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)int buf = 136446210;
      uint32_t v24 = "nw_masque_setup_server_connect";
      uint64_t v15 = "%{public}s called with null masque->parameters, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_54;
  }

  if (!*(void *)(a1 + 392) || *(_DWORD *)(a1 + 512)) {
    return;
  }
  uint64_t v2 = (void *)a1;
  while (1)
  {
    uint64_t v2 = (void *)v2[4];
    if (!v2) {
      break;
    }
    int v3 = (void *)v2[2];
    if (nw_protocol_http3_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http3_identifier::onceToken, &__block_literal_global_10);
    }
    if (!nw_protocols_are_equal(v3, &nw_protocol_http3_identifier::http3_protocol_identifier))
    {
      int v4 = (void *)v2[2];
      if (nw_protocol_http2_identifier::onceToken != -1) {
        dispatch_once(&nw_protocol_http2_identifier::onceToken, &__block_literal_global_83570);
      }
      if (!nw_protocols_are_equal(v4, &nw_protocol_http2_identifier::http2_protocol_identifier)) {
        continue;
      }
    }

    if ((*(_BYTE *)(a1 + 529) & 1) == 0 && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      unint64_t v18 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446978;
        uint32_t v24 = "nw_masque_setup_server_connect";
        __int16 v25 = 2082;
        int v26 = (const char *)(a1 + 531);
        __int16 v27 = 2080;
        int v28 = " ";
        __int16 v29 = 2048;
        os_log_type_t v30 = v2;
        _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound HTTP protocol %p",  buf,  0x2Au);
      }
    }

    uint64_t v5 = (void *)v2[3];
    if (v5 && *v5 && v5[3])
    {
      if (!*(void *)(a1 + 416) && v5[14])
      {
        id v6 = (id)nw_protocol_get_parameters((uint64_t)v2);
        BOOL v7 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v6,  0,  1);

        *(void *)(a1 + 416) = v7;
      }

      nw_protocol_set_input_handler(a1 + 64, *(void *)(a1 + 48));
      *(_OWORD *)(a1 + 64) = *(_OWORD *)a1;
      char v8 = (*(uint64_t (**)(void *, uint64_t))v2[3])(v2, a1 + 64);
      int v9 = *(_DWORD *)(a1 + 527);
      if ((v8 & 1) != 0)
      {
        if ((v9 & 0x10000) == 0 && gLogDatapath)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint64_t v19 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v20 = *(void *)(a1 + 96);
            *(_DWORD *)int buf = 136447234;
            uint32_t v24 = "nw_masque_setup_server_connect";
            __int16 v25 = 2082;
            int v26 = (const char *)(a1 + 531);
            __int16 v27 = 2080;
            int v28 = " ";
            __int16 v29 = 2048;
            os_log_type_t v30 = (void *)(a1 + 64);
            __int16 v31 = 2048;
            uint64_t v32 = v20;
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sserver_connect_protocol %p output_handler %p",  buf,  0x34u);
          }
        }

        (*(void (**)(void))(*(void *)(*(void *)(a1 + 96) + 24LL) + 24LL))();
        return;
      }

      if ((v9 & 0x10000) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        int v10 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446466;
          uint32_t v24 = (const char *)(a1 + 531);
          __int16 v25 = 2080;
          int v26 = " ";
          id v11 = "%{public}s%sFailed to add server connect stream";
          goto LABEL_35;
        }
      }
    }

    return;
  }

  if ((*(_BYTE *)(a1 + 529) & 1) == 0)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    int v10 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      uint32_t v24 = (const char *)(a1 + 531);
      __int16 v25 = 2080;
      int v26 = " ";
      id v11 = "%{public}s%sFailed to find HTTP protocol";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0x16u);
    }
  }

void sub_182014D14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_masque_create_connection_id_capsule(dispatch_data_s *a1, dispatch_data_s *a2, dispatch_data_s *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  size_t size = dispatch_data_get_size(a1);
  size_t v5 = size;
  unint64_t __src = 0LL;
  if (size > 0x3F)
  {
    if (size >> 14)
    {
      if (size >> 30)
      {
        if (size >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "_http_vle_encode";
          *(_WORD *)&applier[12] = 2048;
          *(void *)&applier[14] = v5;
          BOOL v7 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v7);
          if (result)
          {
            __break(1u);
            return result;
          }

          free(v7);
          size_t v6 = 0LL;
        }

        else
        {
          unint64_t __src = bswap64(size | 0xC000000000000000LL);
          size_t v6 = 8LL;
        }
      }

      else
      {
        unint64_t __src = bswap32(size | 0x80000000);
        size_t v6 = 4LL;
      }
    }

    else
    {
      unint64_t __src = bswap32(size | 0x4000) >> 16;
      size_t v6 = 2LL;
    }
  }

  else
  {
    unint64_t __src = size;
    size_t v6 = 1LL;
  }

  alloc = (dispatch_object_s *)dispatch_data_create_alloc();
  memcpy(0LL, &__src, v6);
  v13[0] = 0LL;
  v13[1] = v13;
  v13[2] = 0x2000000000LL;
  v13[3] = 0LL;
  v12[0] = 0LL;
  v12[1] = v12;
  v12[2] = 0x2000000000LL;
  v12[3] = v6;
  if (a1)
  {
    *(void *)applier = MEMORY[0x1895F87A8];
    *(void *)&applier[8] = 0x40000000LL;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    uint64_t v15 = &unk_189BBF598;
    BOOL v17 = v12;
    size_t v18 = v5;
    uint64_t v16 = v13;
    dispatch_data_apply(a1, applier);
  }

  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v13, 8);
  *(_BYTE *)(v6 + v5) = 0;
  metadata_for_capsule = nw_http_create_metadata_for_capsule(16770049LL, alloc);
  if (alloc) {
    dispatch_release(alloc);
  }
  return (BOOL)metadata_for_capsule;
}

uint64_t ___ZL35nw_protocol_masque_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_142( uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  unsigned int v20 = 0;
  uint64_t v3 = nw_frame_unclaimed_bytes(a2, &v20);
  if (v3)
  {
    unint64_t v4 = v20;
    if (v20)
    {
      size_t v5 = (_BYTE *)v3;
      uint64_t v6 = *(void *)(a1 + 32);
      BOOL v7 = *(dispatch_data_s **)(v6 + 384);
      if (v7)
      {
        char v8 = *(dispatch_data_s **)(v6 + 400);
        if (v8)
        {
          size_t size = dispatch_data_get_size(v7);
          if (size + 1 < v4)
          {
            size_t v10 = size;
            if (dispatch_data_get_size(v8) == size && (*v5 & 0xC0) == 0x40)
            {
              uint64_t v11 = (uint64_t)(v5 + 1);
              id v12 = dispatch_data_create(v5 + 1, v10, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A98]);
              if (nw_dispatch_data_is_equal(v12, *(dispatch_data_s **)(*(void *)(a1 + 32) + 400LL)))
              {
                nw_dispatch_data_copyout(*(dispatch_data_s **)(*(void *)(a1 + 32) + 384LL), v11, v10);
                uint64_t v13 = *(void *)(a1 + 32);
                if (!v13 || (*(_BYTE *)(v13 + 529) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                    }
                    uint64_t v15 = (os_log_s *)gprivacy_proxyLogObj;
                    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v16 = *(void *)(a1 + 32);
                      BOOL v17 = "";
                      BOOL v18 = v16 == 0;
                      if (v16) {
                        uint64_t v19 = (const char *)(v16 + 531);
                      }
                      else {
                        uint64_t v19 = "";
                      }
                      *(_DWORD *)int buf = 136446722;
                      unint64_t v22 = "nw_protocol_masque_get_input_frames_block_invoke";
                      if (!v18) {
                        BOOL v17 = " ";
                      }
                      __int16 v23 = 2082;
                      uint32_t v24 = v19;
                      __int16 v25 = 2080;
                      int v26 = v17;
                      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReplacing with real client CID before processing",  buf,  0x20u);
                    }
                  }
                }
              }

              if (v12) {
                dispatch_release(v12);
              }
            }
          }
        }
      }
    }
  }

  return 1LL;
}

void nw_masque_handle_capsule(uint64_t a1, void *a2)
{
  uint64_t v111 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    os_log_type_t v85 = (char *)_os_log_send_and_compose_impl();
    length[0].os_log_type_t sa_len = 16;
    LOBYTE(address) = 0;
    if (length[0].sa_len != 17)
    {
      if (!(_BYTE)address)
      {
        os_log_type_t v86 = (os_log_s *)__nwlog_obj();
        os_log_type_t sa_len = length[0].sa_len;
        if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
          goto LABEL_327;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
        os_log_type_t v88 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_326;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v86 = (os_log_s *)__nwlog_obj();
      os_log_type_t sa_len = length[0].sa_len;
      BOOL v90 = os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len);
      if (!backtrace_string)
      {
        if (!v90) {
          goto LABEL_327;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
        os_log_type_t v88 = "%{public}s called with null masque, no backtrace";
        goto LABEL_326;
      }

      if (v90)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v86,  sa_len,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_327:
      if (v85) {
        goto LABEL_328;
      }
      return;
    }

    os_log_type_t v86 = (os_log_s *)__nwlog_obj();
    os_log_type_t sa_len = length[0].sa_len;
    if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
      goto LABEL_327;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    os_log_type_t v88 = "%{public}s called with null masque";
    goto LABEL_326;
  }

  if (!nw_protocol_metadata_is_http(a2))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    os_log_type_t v85 = (char *)_os_log_send_and_compose_impl();
    length[0].os_log_type_t sa_len = 16;
    LOBYTE(address) = 0;
    if (length[0].sa_len != 17)
    {
      if (!(_BYTE)address)
      {
        os_log_type_t v86 = (os_log_s *)__nwlog_obj();
        os_log_type_t sa_len = length[0].sa_len;
        if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
          goto LABEL_327;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
        os_log_type_t v88 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_326;
      }

      int v91 = (char *)__nw_create_backtrace_string();
      os_log_type_t v86 = (os_log_s *)__nwlog_obj();
      os_log_type_t sa_len = length[0].sa_len;
      BOOL v92 = os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len);
      if (!v91)
      {
        if (!v92) {
          goto LABEL_327;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
        os_log_type_t v88 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
        goto LABEL_326;
      }

      if (!v92) {
        goto LABEL_308;
      }
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v91;
      uint64_t v93 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s";
      goto LABEL_307;
    }

    os_log_type_t v86 = (os_log_s *)__nwlog_obj();
    os_log_type_t sa_len = length[0].sa_len;
    if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
      goto LABEL_327;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    os_log_type_t v88 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
LABEL_326:
    _os_log_impl(&dword_181A5C000, v86, sa_len, v88, buf, 0xCu);
    goto LABEL_327;
  }

  if (!nw_http_metadata_is_capsule(a2))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    os_log_type_t v85 = (char *)_os_log_send_and_compose_impl();
    length[0].os_log_type_t sa_len = 16;
    LOBYTE(address) = 0;
    if (length[0].sa_len == 17)
    {
      os_log_type_t v86 = (os_log_s *)__nwlog_obj();
      os_log_type_t sa_len = length[0].sa_len;
      if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
        goto LABEL_327;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
      os_log_type_t v88 = "%{public}s called with null nw_http_metadata_is_capsule(metadata)";
      goto LABEL_326;
    }

    if (!(_BYTE)address)
    {
      os_log_type_t v86 = (os_log_s *)__nwlog_obj();
      os_log_type_t sa_len = length[0].sa_len;
      if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
        goto LABEL_327;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
      os_log_type_t v88 = "%{public}s called with null nw_http_metadata_is_capsule(metadata), backtrace limit exceeded";
      goto LABEL_326;
    }

    int v91 = (char *)__nw_create_backtrace_string();
    os_log_type_t v86 = (os_log_s *)__nwlog_obj();
    os_log_type_t sa_len = length[0].sa_len;
    BOOL v94 = os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len);
    if (!v91)
    {
      if (!v94) {
        goto LABEL_327;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
      os_log_type_t v88 = "%{public}s called with null nw_http_metadata_is_capsule(metadata), no backtrace";
      goto LABEL_326;
    }

    if (!v94) {
      goto LABEL_308;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v91;
    uint64_t v93 = "%{public}s called with null nw_http_metadata_is_capsule(metadata), dumping backtrace:%{public}s";
LABEL_307:
    _os_log_impl(&dword_181A5C000, v86, sa_len, v93, buf, 0x16u);
    goto LABEL_308;
  }

  capsule_os_log_type_t type = nw_http_metadata_get_capsule_type(a2);
  size_t v5 = (dispatch_data_s *)nw_http_metadata_copy_capsule_data(a2);
  if (v5)
  {
    uint64_t v6 = v5;
    if (capsule_type > 16770303)
    {
      if (capsule_type == 16770304)
      {
        if ((*(_BYTE *)(a1 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint64_t v11 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = a1 + 531;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = " ";
            id v12 = "%{public}s%sReceived unexpected REGISTER_DEMUX_PATTERN capsule";
LABEL_26:
            _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, v12, buf, 0x16u);
          }
        }

void nw_masque_mark_failed_with_error(uint64_t a1, int a2)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (*(_DWORD *)(a1 + 508) == 5) {
      return;
    }
    if ((*(_BYTE *)(a1 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      unint64_t v4 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446722;
        nw_endpoint_t v46 = (const char *)(a1 + 531);
        __int16 v47 = 2080;
        int v48 = " ";
        __int16 v49 = 1024;
        LODWORD(v50) = a2;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s%sClosing connection with error %{darwin.errno}d",  buf,  0x1Cu);
      }
    }

    *(_DWORD *)(a1 + 50_Block_object_dispose(va, 8) = 5;
    uint64_t v5 = *(void *)(a1 + 256);
    if (v5)
    {
      do
      {
        uint64_t v6 = *(void *)(v5 + 16);
        nw_frame_finalize(v5);
        uint64_t v5 = v6;
      }

      while (v6);
    }

    uint64_t v7 = *(void *)(a1 + 48);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 24);
      if (v8)
      {
        int v9 = *(void (**)(void))(v8 + 56);
        if (!v9 || (v9(), (v10 = *(void *)(a1 + 48)) != 0) && (uint64_t v8 = *(void *)(v10 + 24)) != 0)
        {
          uint64_t v11 = *(void (**)(void))(v8 + 48);
          if (v11) {
            v11();
          }
        }
      }
    }

    uint64_t v12 = *(void *)(a1 + 32);
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 24);
      if (v13)
      {
        os_log_type_t v14 = *(void (**)(void))(v13 + 32);
        if (v14)
        {
          v14();
          return;
        }
      }
    }

    __nwlog_obj();
    uint64_t v15 = *(void *)(a1 + 32);
    uint64_t v16 = "invalid";
    if (v15)
    {
      BOOL v17 = *(const char **)(v15 + 16);
      if (v17) {
        uint64_t v16 = v17;
      }
    }

    *(_DWORD *)int buf = 136446466;
    nw_endpoint_t v46 = "nw_masque_mark_failed_with_error";
    __int16 v47 = 2082;
    int v48 = v16;
    uint64_t v18 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v18, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_62;
        }
        uint64_t v21 = *(void *)(a1 + 32);
        unint64_t v22 = "invalid";
        if (v21)
        {
          int v23 = *(const char **)(v21 + 16);
          if (v23) {
            unint64_t v22 = v23;
          }
        }

        *(_DWORD *)int buf = 136446466;
        nw_endpoint_t v46 = "nw_masque_mark_failed_with_error";
        __int16 v47 = 2082;
        int v48 = v22;
        size_t v24 = "%{public}s protocol %{public}s has invalid disconnect callback";
LABEL_61:
        _os_log_impl(&dword_181A5C000, v19, v20, v24, buf, 0x16u);
        goto LABEL_62;
      }

      if (!v43)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_62;
        }
        uint64_t v36 = *(void *)(a1 + 32);
        size_t v37 = "invalid";
        if (v36)
        {
          size_t v38 = *(const char **)(v36 + 16);
          if (v38) {
            size_t v37 = v38;
          }
        }

        *(_DWORD *)int buf = 136446466;
        nw_endpoint_t v46 = "nw_masque_mark_failed_with_error";
        __int16 v47 = 2082;
        int v48 = v37;
        size_t v24 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        goto LABEL_61;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v30 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (!v30) {
          goto LABEL_62;
        }
        uint64_t v39 = *(void *)(a1 + 32);
        dispatch_data_t v40 = "invalid";
        if (v39)
        {
          unint64_t v41 = *(const char **)(v39 + 16);
          if (v41) {
            dispatch_data_t v40 = v41;
          }
        }

        *(_DWORD *)int buf = 136446466;
        nw_endpoint_t v46 = "nw_masque_mark_failed_with_error";
        __int16 v47 = 2082;
        int v48 = v40;
        size_t v24 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
        goto LABEL_61;
      }

      if (v30)
      {
        uint64_t v31 = *(void *)(a1 + 32);
        size_t v32 = "invalid";
        if (v31)
        {
          uint64_t v33 = *(const char **)(v31 + 16);
          if (v33) {
            size_t v32 = v33;
          }
        }

        *(_DWORD *)int buf = 136446722;
        nw_endpoint_t v46 = "nw_masque_mark_failed_with_error";
        __int16 v47 = 2082;
        int v48 = v32;
        __int16 v49 = 2082;
        nw_endpoint_t v50 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
    }

BOOL ___ZL24nw_masque_handle_capsuleP9nw_masqueP20nw_protocol_metadata_block_invoke( uint64_t a1, unsigned int a2, unsigned int a3, const void *a4, const void *a5)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  unsigned __int16 v46 = 0;
  nw_dispatch_data_copyout_from_offset( *(dispatch_data_s **)(a1 + 40),  (uint64_t)&v46,  2LL,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  if (v46 != a2)
  {
    uint64_t v18 = *(void *)(a1 + 48);
    if (v18 && (*(_BYTE *)(v18 + 529) & 1) != 0) {
      return 0LL;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v19 = gprivacy_proxyLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v20 = *(void *)(a1 + 48);
    uint64_t v21 = (const char *)(v20 + 531);
    unint64_t v22 = "";
    if (!v20) {
      uint64_t v21 = "";
    }
    *(_DWORD *)int buf = 136446978;
    if (v20) {
      unint64_t v22 = " ";
    }
    int v48 = v21;
    __int16 v49 = 2080;
    nw_endpoint_t v50 = v22;
    __int16 v51 = 1024;
    int v52 = v46;
    __int16 v53 = 1024;
    unsigned int v54 = a2;
    int v23 = "%{public}s%sReceived pattern length (%u bytes) does not match actual pattern length (%u bytes)";
    goto LABEL_37;
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += 2LL;
  unsigned __int16 v45 = 0;
  nw_dispatch_data_copyout_from_offset( *(dispatch_data_s **)(a1 + 40),  (uint64_t)&v45,  2LL,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  if (v45 != a3)
  {
    uint64_t v24 = *(void *)(a1 + 48);
    if (v24 && (*(_BYTE *)(v24 + 529) & 1) != 0) {
      return 0LL;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v19 = gprivacy_proxyLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v25 = *(void *)(a1 + 48);
    int v26 = (const char *)(v25 + 531);
    os_log_type_t v27 = "";
    if (!v25) {
      int v26 = "";
    }
    *(_DWORD *)int buf = 136446978;
    if (v25) {
      os_log_type_t v27 = " ";
    }
    int v48 = v26;
    __int16 v49 = 2080;
    nw_endpoint_t v50 = v27;
    __int16 v51 = 1024;
    int v52 = v45;
    __int16 v53 = 1024;
    unsigned int v54 = a3;
    int v23 = "%{public}s%sReceived pattern offset (%u bytes) does not match actual pattern offset (%u bytes)";
LABEL_37:
    int v28 = (os_log_s *)v19;
    uint32_t v29 = 34;
LABEL_72:
    _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_ERROR, v23, buf, v29);
    return 0LL;
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += 2LL;
  subrange = dispatch_data_create_subrange( *(dispatch_data_t *)(a1 + 40),  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  a2);
  uint64_t v11 = (void *)*MEMORY[0x1895F8A98];
  uint64_t v12 = dispatch_data_create(a4, a2, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A98]);
  BOOL is_equal = nw_dispatch_data_is_equal(subrange, v12);
  if (subrange) {
    dispatch_release(subrange);
  }
  if (v12) {
    dispatch_release(v12);
  }
  if (is_equal)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a2;
    char v44 = 0;
    nw_dispatch_data_copyout_from_offset( *(dispatch_data_s **)(a1 + 40),  (uint64_t)&v44,  1LL,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    if (v44 == (a5 != 0LL))
    {
      ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (!a5) {
        return 1LL;
      }
      os_log_type_t v14 = dispatch_data_create_subrange( *(dispatch_data_t *)(a1 + 40),  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  a2);
      uint64_t v15 = dispatch_data_create(a5, a2, 0LL, v11);
      BOOL v16 = nw_dispatch_data_is_equal(v14, v15);
      if (v14) {
        dispatch_release(v14);
      }
      if (v15) {
        dispatch_release(v15);
      }
      if (v16)
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a2;
        return 1LL;
      }

      uint64_t v41 = *(void *)(a1 + 48);
      if (v41 && (*(_BYTE *)(v41 + 529) & 1) != 0) {
        return 0LL;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v31 = gprivacy_proxyLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        uint64_t v42 = *(void *)(a1 + 48);
        BOOL v43 = v42 == 0;
        if (v42) {
          uint64_t v39 = (const char *)(v42 + 531);
        }
        else {
          uint64_t v39 = "";
        }
        dispatch_data_t v40 = " ";
        if (v43) {
          dispatch_data_t v40 = "";
        }
LABEL_70:
        *(_DWORD *)int buf = 136446466;
        int v48 = v39;
        __int16 v49 = 2080;
        nw_endpoint_t v50 = v40;
        int v23 = "%{public}s%sReceived pattern mask does not match actual pattern mask";
LABEL_71:
        int v28 = (os_log_s *)v31;
        uint32_t v29 = 22;
        goto LABEL_72;
      }
    }

    else
    {
      uint64_t v36 = *(void *)(a1 + 48);
      if (v36 && (*(_BYTE *)(v36 + 529) & 1) != 0) {
        return 0LL;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v31 = gprivacy_proxyLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        uint64_t v37 = *(void *)(a1 + 48);
        BOOL v38 = v37 == 0;
        if (v37) {
          uint64_t v39 = (const char *)(v37 + 531);
        }
        else {
          uint64_t v39 = "";
        }
        dispatch_data_t v40 = " ";
        if (v38) {
          dispatch_data_t v40 = "";
        }
        goto LABEL_70;
      }
    }
  }

  else
  {
    uint64_t v30 = *(void *)(a1 + 48);
    if (v30 && (*(_BYTE *)(v30 + 529) & 1) != 0) {
      return 0LL;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v31 = gprivacy_proxyLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v32 = *(void *)(a1 + 48);
      BOOL v33 = v32 == 0;
      if (v32) {
        nw_protocol_stack_t v34 = (const char *)(v32 + 531);
      }
      else {
        nw_protocol_stack_t v34 = "";
      }
      BOOL v35 = " ";
      if (v33) {
        BOOL v35 = "";
      }
      *(_DWORD *)int buf = 136446466;
      int v48 = v34;
      __int16 v49 = 2080;
      nw_endpoint_t v50 = v35;
      int v23 = "%{public}s%sReceived pattern does not match actual pattern";
      goto LABEL_71;
    }
  }

  return result;
}

void nw_masque_mark_connected(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  int v2 = *(_DWORD *)(a1 + 508);
  if (v2 == 5)
  {
    if ((*(_BYTE *)(a1 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      unint64_t v4 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        int v19 = 136446466;
        uint64_t v20 = (const char *)(a1 + 531);
        __int16 v21 = 2080;
        unint64_t v22 = " ";
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s%sAlready in the disconnected state",  (uint8_t *)&v19,  0x16u);
      }
    }
  }

  else
  {
    if (v2 == 4)
    {
      if ((*(_BYTE *)(a1 + 529) & 1) == 0 && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v3 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v19 = 136446722;
          uint64_t v20 = "nw_masque_mark_connected";
          __int16 v21 = 2082;
          unint64_t v22 = (const char *)(a1 + 531);
          __int16 v23 = 2080;
          uint64_t v24 = " ";
          _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAlready in the connected state",  (uint8_t *)&v19,  0x20u);
        }
      }

      return;
    }

    uint64_t v5 = (_DWORD *)(a1 + 527);
    int v6 = *(_DWORD *)(a1 + 527);
    if ((v6 & 0x20) != 0 && (!*(void *)(a1 + 360) || !*(void *)(a1 + 368) || !*(void *)(a1 + 376)))
    {
      if ((v6 & 0x10000) != 0) {
        goto LABEL_53;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v8 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_53;
      }
      int v19 = 136446466;
      uint64_t v20 = (const char *)(a1 + 531);
      __int16 v21 = 2080;
      unint64_t v22 = " ";
      int v9 = "%{public}s%sCONNECT-IP waiting for addresses, not marking ready yet";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_INFO, v9, (uint8_t *)&v19, 0x16u);
LABEL_53:
      *(_DWORD *)(a1 + 50_Block_object_dispose(va, 8) = 3;
      return;
    }

    if ((v6 & 8) != 0 && (v6 & 0x200) == 0)
    {
      BOOL v16 = *(void **)(a1 + 448);
      if (v16)
      {
        goto LABEL_53;
      }
    }

    if ((v6 & 0x100000) != 0 && ((v6 & 0x8000080) == 0x8000000 || (v6 & 0x4000100) == 0x4000000))
    {
      if ((v6 & 0x10000) != 0) {
        goto LABEL_53;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v8 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_53;
      }
      int v19 = 136446466;
      uint64_t v20 = (const char *)(a1 + 531);
      __int16 v21 = 2080;
      unint64_t v22 = " ";
      int v9 = "%{public}s%swaiting for ACK capsules, not marking ready yet";
      goto LABEL_35;
    }

    *(_DWORD *)(a1 + 50_Block_object_dispose(va, 8) = 4;
    if ((v6 & 0x10000) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v10 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        int v19 = 136446466;
        uint64_t v20 = (const char *)(a1 + 531);
        __int16 v21 = 2080;
        unint64_t v22 = " ";
        _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_INFO, "%{public}s%smarking connected", (uint8_t *)&v19, 0x16u);
      }
    }

    if ((*(_BYTE *)(a1 + 529) & 0x40) != 0)
    {
      uint64_t v17 = *(void *)(a1 + 256);
      if (v17)
      {
        do
        {
          uint64_t v18 = *(void *)(v17 + 16);
          nw_frame_finalize(v17);
          uint64_t v17 = v18;
        }

        while (v18);
      }
    }

    uint64_t v11 = *(void *)(a1 + 48);
    if (v11)
    {
      uint64_t v12 = *(void *)(v11 + 24);
      if (v12)
      {
        uint64_t v13 = *(void (**)(void))(v12 + 40);
        if (!v13 || (v13(), (uint64_t v14 = *(void *)(a1 + 48)) != 0) && (v12 = *(void *)(v14 + 24)) != 0)
        {
          uint64_t v15 = *(void (**)(void))(v12 + 72);
          if (v15) {
            v15();
          }
        }
      }
    }
  }

uint64_t nw_masque_send_demux_options(uint64_t a1, void *a2, char a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_send_demux_options";
    __int16 v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v30[0]) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v30[0]))
      {
        unint64_t v22 = (os_log_s *)__nwlog_obj();
        os_log_type_t v23 = type[0];
        if (!os_log_type_enabled(v22, type[0])) {
          goto LABEL_62;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_send_demux_options";
        uint64_t v24 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_61;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type[0];
      BOOL v26 = os_log_type_enabled(v22, type[0]);
      if (!backtrace_string)
      {
        if (!v26) {
          goto LABEL_62;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_send_demux_options";
        uint64_t v24 = "%{public}s called with null masque, no backtrace";
        goto LABEL_61;
      }

      if (v26)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_masque_send_demux_options";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        os_log_type_t v27 = "%{public}s called with null masque, dumping backtrace:%{public}s";
LABEL_51:
        _os_log_impl(&dword_181A5C000, v22, v23, v27, buf, 0x16u);
      }

uint64_t ___ZL28nw_masque_send_demux_optionsP9nw_masqueP19nw_protocol_optionsb_block_invoke( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a2 + 4LL;
  if (a5) {
    uint64_t v5 = a2 + 1LL;
  }
  else {
    uint64_t v5 = 1LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
  return 1LL;
}

uint64_t ___ZL28nw_masque_send_demux_optionsP9nw_masqueP19nw_protocol_optionsb_block_invoke_2( uint64_t a1, size_t __n, __int16 a3, void *__src, const void *a5)
{
  **(_WORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = __n;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += 2LL;
  **(_WORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a3;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += 2LL;
  size_t v7 = __n;
  memcpy(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), __src, __n);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v7;
  int v8 = *(_BYTE **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (a5)
  {
    *int v8 = 1;
    memcpy((void *)++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a5, v7);
  }

  else
  {
    *int v8 = 0;
    size_t v7 = 1LL;
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v7;
  return 1LL;
}

uint64_t ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v122 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    uint64_t v4 = a1[5];
    goto LABEL_4;
  }

  uint64_t finalizer_context = nw_frame_get_finalizer_context(a2);
  uint64_t v4 = a1[5];
  if (finalizer_context != v4)
  {
LABEL_4:
    if (!v4 || (*(_BYTE *)(v4 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      int v6 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = a1[5];
        BOOL v8 = v7 == 0;
        if (v7) {
          uint64_t v9 = (const char *)(v7 + 531);
        }
        else {
          uint64_t v9 = "";
        }
        uint64_t v10 = " ";
        if (v8) {
          uint64_t v10 = "";
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v10;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s%sReceived invalid early output frame",  buf,  0x16u);
      }
    }

    uint64_t v11 = a2;
    goto LABEL_16;
  }

  *(_DWORD *)(finalizer_context + 527) |= 0x200000u;
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
  unsigned int v103 = 0;
  int v13 = (unsigned __int8 *)nw_frame_unclaimed_bytes(a2, &v103);
  uint64_t v14 = a1[5];
  if (*(_DWORD *)(v14 + 508) == 1)
  {
    if ((*(_BYTE *)(v14 + 528) & 8) == 0) {
      goto LABEL_85;
    }
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
    }
    id v15 = (id)nw_protocol_copy_http_definition_http_definition;
    BOOL v16 = nw_frame_copy_metadata_for_protocol(a2, (uint64_t)v15);
    if (v15) {
      os_release(v15);
    }
    uint64_t v14 = a1[5];
    if (!v16) {
      goto LABEL_85;
    }
    if ((!v14 || (*(_BYTE *)(v14 + 529) & 1) == 0) && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      int v79 = (os_log_s *)gprivacy_proxyLogObj;
      BOOL v80 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
      uint64_t v14 = a1[5];
      if (v80)
      {
        id v81 = (const char *)(v14 + 531);
        if (!v14) {
          id v81 = "";
        }
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v81;
        if (v14) {
          id v82 = " ";
        }
        else {
          id v82 = "";
        }
        *(_WORD *)&_BYTE buf[22] = 2080;
        uint64_t v118 = (uint64_t (*)(uint64_t, uint64_t))v82;
        LOWORD(v119) = 1024;
        *(_DWORD *)((char *)&v119 + 2) = v103;
        _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived HTTP message to proxy, with %u bytes",  buf,  0x26u);
        uint64_t v14 = a1[5];
      }
    }

    *(_DWORD *)(v14 + 527) |= 0x1000u;
    uint64_t v17 = a1[5];
    if (v17)
    {
      uint64_t v18 = mach_continuous_time();
      if (v18 <= 1) {
        uint64_t v19 = 1LL;
      }
      else {
        uint64_t v19 = v18;
      }
      *(void *)(v17 + 28_Block_object_dispose(va, 8) = v19;
      id v20 = nw_http_metadata_copy_request(v16);
      if (!v20)
      {
        if ((*(_BYTE *)(v17 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint32_t v29 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = v17 + 531;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s%sHTTP message is not a request",  buf,  0x16u);
          }
        }

        nw_masque_mark_failed_with_error(v17, 22);
        goto LABEL_84;
      }

      __int16 v21 = v20;
      if (!nw_http_request_has_method(v20, (uint64_t)"POST"))
      {
        if ((*(_BYTE *)(v17 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint64_t v30 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = v17 + 531;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_ERROR, "%{public}s%sUnsupported method", buf, 0x16u);
          }
        }

        nw_masque_mark_failed_with_error(v17, 45);
        goto LABEL_83;
      }

      if (*(void *)(v17 + 320))
      {
        unint64_t v22 = *(void **)(v17 + 344);
        if (v22)
        {
          os_log_type_t v23 = (nw_endpoint *)nw_protocol_options_copy_proxy_endpoint(v22);
          if (v23)
          {
            uint64_t v24 = v23;
            if (nw_endpoint_get_type(v23) == 4)
            {
              id v25 = nw_parameters_copy_url_endpoint(*(void **)(v17 + 320));
              if (v25)
              {
                BOOL v26 = v25;
                uint64_t v110 = 0LL;
                hostname = nw_endpoint_get_hostname(v24);
                int port = nw_endpoint_get_port(v24);
                asprintf(&v110, "%s:%u", hostname, port);
                uint64_t v109 = 0LL;
                nw_endpoint_get_url_path(v24);
                nw_endpoint_get_url_path(v26);
                int v89 = nw_endpoint_get_port((nw_endpoint_t)v26);
                BOOL object = nw_endpoint_copy_host_port_endpoint_for_url(v24);
                BOOL v91 = nw_endpoint_copy_host_port_endpoint_for_url(v26);
                if (nw_endpoint_is_equal((void *)object, (void *)v91, 0LL))
                {
                  asprintf(&v109, "%s");
                }

                else
                {
                  nw_endpoint_get_hostname((nw_endpoint_t)v26);
                  if (v89 == 443) {
                    asprintf(&v109, "%s?targethost=%s&targetpath=%s");
                  }
                  else {
                    asprintf(&v109, "%s?targethost=%s:%u&targetpath=%s");
                  }
                }

                uint64_t url_scheme = nw_endpoint_get_url_scheme(v26);
                *(void *)int buf = 0LL;
                *(void *)&buf[8] = buf;
                *(void *)&buf[16] = 0x3802000000LL;
                uint64_t v118 = __Block_byref_object_copy__27338;
                __int16 v119 = __Block_byref_object_dispose__27339;
                uint64_t v120 = _nw_http_request_create("POST", url_scheme, v110, v109);
                v121 |= 1u;
                if (v110)
                {
                  free(v110);
                  uint64_t v110 = 0LL;
                }

                if (v109)
                {
                  free(v109);
                  uint64_t v109 = 0LL;
                }

                if (object) {
                  os_release((void *)object);
                }
                if (v91) {
                  os_release((void *)v91);
                }
                os_release(v26);
                os_release(v24);
                *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
                uint64_t v105 = 0x40000000LL;
                uint64_t v106 = ___ZL30nw_masque_send_proxied_messageP9nw_masqueP20nw_protocol_metadata_block_invoke;
                uint64_t v107 = &unk_189BBA7E0;
                uint64_t v108 = buf;
                nw_http_request_access_extended_connect_protocol(v21, type);
                nw_http_request_set_header_fields(*(void **)(*(void *)&buf[8] + 40LL), v21);
                if (nw_masque_add_extra_headers_to_request(v17, *(void **)(*(void *)&buf[8] + 40LL)))
                {
                  nw_http_metadata_set_request(v16, *(void **)(*(void *)&buf[8] + 40LL));
                  if ((nw_masque_send_metadata(v17, (uint64_t)v16, *(void *)(v17 + 32)) & 1) != 0)
                  {
                    if ((*(_BYTE *)(v17 + 529) & 1) == 0)
                    {
                      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                      }
                      uint64_t v65 = (os_log_s *)gprivacy_proxyLogObj;
                      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)uint64_t v111 = 136446722;
                        BOOL v112 = "nw_masque_send_proxied_message";
                        __int16 v113 = 2082;
                        uint64_t v114 = v17 + 531;
                        __int16 v115 = 2080;
                        uint64_t v116 = " ";
                        _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSent request",  v111,  0x20u);
                      }
                    }

                    nw_masque_mark_connected(v17);
                  }

                  else
                  {
                    nw_masque_mark_failed_with_error(v17, 12);
                  }
                }

                _Block_object_dispose(buf, 8);
                if ((v121 & 1) == 0) {
                  goto LABEL_83;
                }
                uint64_t v39 = (void *)v120;
                if (!v120) {
                  goto LABEL_83;
                }
                goto LABEL_82;
              }

              if ((*(_BYTE *)(v17 + 529) & 1) != 0) {
                goto LABEL_81;
              }
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              uint64_t v38 = gprivacy_proxyLogObj;
              if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
              {
LABEL_81:
                nw_masque_mark_failed_with_error(v17, 22);
                uint64_t v39 = v24;
LABEL_82:
                os_release(v39);
                goto LABEL_83;
              }

              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = v17 + 531;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = " ";
              uint64_t v35 = "%{public}s%sURL endpoint not found";
              uint64_t v36 = (os_log_s *)v38;
              uint32_t v37 = 22;
            }

            else
            {
              if ((*(_BYTE *)(v17 + 529) & 1) != 0) {
                goto LABEL_81;
              }
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              uint64_t v33 = gprivacy_proxyLogObj;
              if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
                goto LABEL_81;
              }
              logging_description = nw_endpoint_get_logging_description(v24);
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = v17 + 531;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&_BYTE buf[22] = 2082;
              uint64_t v118 = (uint64_t (*)(uint64_t, uint64_t))logging_description;
              uint64_t v35 = "%{public}s%sProxy endpoint %{public}s is not of type URL";
              uint64_t v36 = (os_log_s *)v33;
              uint32_t v37 = 32;
            }

            _os_log_impl(&dword_181A5C000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
            goto LABEL_81;
          }

          if ((*(_BYTE *)(v17 + 529) & 1) != 0) {
            goto LABEL_69;
          }
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint64_t v31 = (os_log_s *)gprivacy_proxyLogObj;
          if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
LABEL_69:
            nw_masque_mark_failed_with_error(v17, 22);
LABEL_83:
            os_release(v21);
LABEL_84:
            os_release(v16);
            uint64_t v14 = a1[5];
LABEL_85:
            int v40 = *(_DWORD *)(v14 + 527);
            if ((v40 & 0x1000) == 0)
            {
              if ((v40 & 0x10000) == 0 && gLogDatapath)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                size_t v66 = (os_log_s *)gprivacy_proxyLogObj;
                BOOL v67 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
                uint64_t v14 = a1[5];
                if (v67)
                {
                  int v68 = (const char *)(v14 + 531);
                  if (!v14) {
                    int v68 = "";
                  }
                  *(_DWORD *)int buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v68;
                  if (v14) {
                    int v69 = " ";
                  }
                  else {
                    int v69 = "";
                  }
                  *(_WORD *)&_BYTE buf[22] = 2080;
                  uint64_t v118 = (uint64_t (*)(uint64_t, uint64_t))v69;
                  LOWORD(v119) = 1024;
                  *(_DWORD *)((char *)&v119 + 2) = v103;
                  _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived early output %u bytes",  buf,  0x26u);
                  uint64_t v14 = a1[5];
                }
              }

              if (v103 >= 7 && !*(void *)(v14 + 384))
              {
                unsigned int v58 = *v13;
                if (v58 >= 0xC0 && (v58 & 0x30) == 0)
                {
                  unint64_t v59 = v13[5];
                  if (v59 <= 0x14)
                  {
                    unint64_t v60 = v59 + 7;
                    if (v59 + 7 < v103)
                    {
                      dispatch_data_t v61 = &v13[v59];
                      size_t v62 = v61[6];
                      if ((v62 - 1) <= 0x13 && v60 + v62 < v103)
                      {
                        *(void *)(a1[5] + 384LL) = dispatch_data_create(v61 + 7, v61[6], 0LL, 0LL);
                        uint64_t v63 = a1[5];
                        if (*(_DWORD *)(v63 + 504) == 2
                          && (*(void *)int buf = 0LL,
                              *(void *)(a1[5] + 400LL) = dispatch_data_create_alloc(),
                              arc4random_buf(*(void **)buf, v62),
                              (uint64_t v63 = a1[5]) == 0)
                          || (*(_BYTE *)(v63 + 529) & 1) == 0)
                        {
                          if (gLogDatapath)
                          {
                            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                            }
                            os_log_type_t v85 = (os_log_s *)gprivacy_proxyLogObj;
                            BOOL v86 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
                            uint64_t v63 = a1[5];
                            if (v86)
                            {
                              uint64_t v87 = (const char *)(v63 + 531);
                              if (!v63) {
                                uint64_t v87 = "";
                              }
                              *(_DWORD *)int buf = 136446978;
                              *(void *)&uint8_t buf[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
                              *(_WORD *)&buf[12] = 2082;
                              *(void *)&buf[14] = v87;
                              os_log_type_t v88 = " ";
                              if (!v63) {
                                os_log_type_t v88 = "";
                              }
                              *(_WORD *)&_BYTE buf[22] = 2080;
                              uint64_t v118 = (uint64_t (*)(uint64_t, uint64_t))v88;
                              LOWORD(v119) = 1024;
                              *(_DWORD *)((char *)&v119 + 2) = v62;
                              _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDetected a client CID of length %u",  buf,  0x26u);
                              uint64_t v63 = a1[5];
                            }
                          }
                        }

                        nw_masque_setup_demux(v63, 1);
                        uint64_t v14 = a1[5];
                      }
                    }
                  }
                }
              }

              nw_masque_send_connect(v14);
              uint64_t v14 = a1[5];
            }

            goto LABEL_91;
          }

          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = v17 + 531;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = " ";
          uint64_t v32 = "%{public}s%sProxy endpoint not found";
        }

        else
        {
          if ((*(_BYTE *)(v17 + 529) & 1) != 0) {
            goto LABEL_69;
          }
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          uint64_t v31 = (os_log_s *)gprivacy_proxyLogObj;
          if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_69;
          }
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = v17 + 531;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = " ";
          uint64_t v32 = "%{public}s%sOptions not found";
        }
      }

      else
      {
        if ((*(_BYTE *)(v17 + 529) & 1) != 0) {
          goto LABEL_69;
        }
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v31 = (os_log_s *)gprivacy_proxyLogObj;
        if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_69;
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v17 + 531;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        uint64_t v32 = "%{public}s%sParameters not found";
      }

      _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_ERROR, v32, buf, 0x16u);
      goto LABEL_69;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_send_proxied_message";
    __int16 v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v111[0] = 0;
    if (__nwlog_fault(v75, type, v111))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v76 = (os_log_s *)__nwlog_obj();
        os_log_type_t v77 = type[0];
        if (!os_log_type_enabled(v76, type[0])) {
          goto LABEL_199;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_send_proxied_message";
        os_log_type_t v78 = "%{public}s called with null masque";
        goto LABEL_198;
      }

      if (!v111[0])
      {
        int v76 = (os_log_s *)__nwlog_obj();
        os_log_type_t v77 = type[0];
        if (!os_log_type_enabled(v76, type[0])) {
          goto LABEL_199;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_send_proxied_message";
        os_log_type_t v78 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_198;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v76 = (os_log_s *)__nwlog_obj();
      os_log_type_t v77 = type[0];
      BOOL v84 = os_log_type_enabled(v76, type[0]);
      if (backtrace_string)
      {
        if (v84)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_send_proxied_message";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_199;
      }

      if (v84)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_send_proxied_message";
        os_log_type_t v78 = "%{public}s called with null masque, no backtrace";
LABEL_198:
        _os_log_impl(&dword_181A5C000, v76, v77, v78, buf, 0xCu);
      }
    }

uint64_t ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_126( uint64_t a1, uint64_t a2)
{
  uint64_t v165 = *MEMORY[0x1895F89C0];
  unsigned int v139 = 0;
  uint64_t v4 = (_BYTE *)nw_frame_unclaimed_bytes(a2, &v139);
  uint64_t finalizer_context = nw_frame_get_finalizer_context(a2);
  uint64_t v6 = *(void *)(a1 + 32);
  if (finalizer_context == v6)
  {
    uint64_t v22 = finalizer_context;
    *(void *)id v157 = 0LL;
    *(void *)&v157[8] = v157;
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(*(void *)(a1 + 48) + 32LL);
    if (*(void *)(finalizer_context + 224))
    {
      id v25 = *(dispatch_data_s **)(finalizer_context + 392);
      if (v25)
      {
        size_t size = dispatch_data_get_size(v25);
        if (size + 1 < v139)
        {
          size_t v27 = size;
          BOOL v28 = *(dispatch_data_s **)(v22 + 408);
          if ((!v28 || dispatch_data_get_size(v28) == v27) && (*v4 & 0xC0) == 0x40)
          {
            uint32_t v29 = dispatch_data_create(v4 + 1, v27, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A98]);
            if (nw_dispatch_data_is_equal(v29, *(dispatch_data_s **)(*(void *)(a1 + 32) + 392LL)))
            {
              uint64_t v30 = *(void *)(a1 + 32);
              if ((!v30 || (*(_BYTE *)(v30 + 529) & 1) == 0) && gLogDatapath)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                BOOL v91 = (os_log_s *)gprivacy_proxyLogObj;
                BOOL v92 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
                uint64_t v30 = *(void *)(a1 + 32);
                if (v92)
                {
                  BOOL v93 = v30 == 0;
                  if (v30) {
                    BOOL v94 = (const char *)(v30 + 531);
                  }
                  else {
                    BOOL v94 = "";
                  }
                  *(_DWORD *)os_log_type_t v160 = 136446978;
                  *(void *)&v160[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
                  *(_WORD *)&v160[12] = 2082;
                  *(void *)&v160[14] = v94;
                  if (v93) {
                    uint64_t v95 = "";
                  }
                  else {
                    uint64_t v95 = " ";
                  }
                  *(_WORD *)&v160[22] = 2080;
                  nw_protocol_options_t v161 = (uint64_t (*)(uint64_t, uint64_t))v95;
                  LOWORD(v162) = 1024;
                  *(_DWORD *)((char *)&v162 + 2) = v139;
                  _os_log_impl( &dword_181A5C000,  v91,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDetected packet of length %u to forward directly to demux",  v160,  0x26u);
                  uint64_t v30 = *(void *)(a1 + 32);
                }
              }

              uint64_t v31 = *(dispatch_data_s **)(v30 + 408);
              if (v31)
              {
                nw_dispatch_data_copyout(v31, (uint64_t)(v4 + 1), v27);
                uint64_t v30 = *(void *)(a1 + 32);
                if (!v30 || (*(_BYTE *)(v30 + 529) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                    }
                    uint64_t v106 = (os_log_s *)gprivacy_proxyLogObj;
                    BOOL v107 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
                    uint64_t v30 = *(void *)(a1 + 32);
                    if (v107)
                    {
                      uint64_t v108 = "";
                      BOOL v109 = v30 == 0;
                      if (v30) {
                        uint64_t v110 = (const char *)(v30 + 531);
                      }
                      else {
                        uint64_t v110 = "";
                      }
                      *(_DWORD *)os_log_type_t v160 = 136446722;
                      *(void *)&v160[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
                      if (!v109) {
                        uint64_t v108 = " ";
                      }
                      *(_WORD *)&v160[12] = 2082;
                      *(void *)&v160[14] = v110;
                      *(_WORD *)&v160[22] = 2080;
                      nw_protocol_options_t v161 = (uint64_t (*)(uint64_t, uint64_t))v108;
                      _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReplacing with virtual CID before forwarding",  v160,  0x20u);
                      uint64_t v30 = *(void *)(a1 + 32);
                    }
                  }
                }
              }

              uint64_t v24 = *(void *)(v30 + 224);
              uint64_t v23 = *(void *)(a1 + 56);
            }

            if (v29) {
              dispatch_release(v29);
            }
          }
        }
      }

      else if ((*(_BYTE *)(v22 + 528) & 4) != 0)
      {
        uint64_t v44 = *(void **)(v22 + 448);
        if (v44)
        {
          if (v4)
          {
            if (v139)
            {
              *(void *)os_log_type_t type = 0LL;
              uint64_t v141 = (uint64_t)type;
              uint64_t v142 = 0x2000000000LL;
              LOBYTE(v143) = 0;
              *(void *)os_log_type_t v160 = MEMORY[0x1895F87A8];
              *(void *)&v160[8] = 0x40000000LL;
              *(void *)&v160[16] = ___ZL29nw_masque_match_demux_patternPKhmP19nw_protocol_options_block_invoke;
              nw_protocol_options_t v161 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BBA808;
              unint64_t v163 = v139;
              id v164 = v4;
              int v162 = type;
              nw_demux_options_enumerate_patterns(v44, (uint64_t)v160);
              int v45 = *(unsigned __int8 *)(v141 + 24);
              _Block_object_dispose(type, 8);
              if (v45)
              {
                uint64_t v46 = *(void *)(a1 + 32);
                if ((!v46 || (*(_BYTE *)(v46 + 529) & 1) == 0) && gLogDatapath)
                {
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  char v101 = (os_log_s *)gprivacy_proxyLogObj;
                  BOOL v102 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
                  uint64_t v46 = *(void *)(a1 + 32);
                  if (v102)
                  {
                    BOOL v103 = v46 == 0;
                    if (v46) {
                      uint64_t v104 = (const char *)(v46 + 531);
                    }
                    else {
                      uint64_t v104 = "";
                    }
                    *(_DWORD *)os_log_type_t v160 = 136446978;
                    *(void *)&v160[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
                    *(_WORD *)&v160[12] = 2082;
                    *(void *)&v160[14] = v104;
                    if (v103) {
                      uint64_t v105 = "";
                    }
                    else {
                      uint64_t v105 = " ";
                    }
                    *(_WORD *)&v160[22] = 2080;
                    nw_protocol_options_t v161 = (uint64_t (*)(uint64_t, uint64_t))v105;
                    LOWORD(v162) = 1024;
                    *(_DWORD *)((char *)&v162 + 2) = v139;
                    _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDetected packet of length %u to forward directly to demux (fast path)",  v160,  0x26u);
                    uint64_t v46 = *(void *)(a1 + 32);
                  }
                }

                uint64_t v24 = *(void *)(v46 + 224);
                uint64_t v23 = *(void *)(a1 + 56);
              }
            }
          }
        }
      }
    }

    if ((*(unsigned int (**)(uint64_t, void, void, void, uint64_t, _BYTE *))(*(void *)(v24 + 24) + 88LL))( v24,  *(void *)(a1 + 48),  v139,  v139,  1LL,  v157))
    {
      *(void *)os_log_type_t v160 = 0LL;
      *(void *)&v160[8] = v160;
      *(void *)&v160[16] = 0x2000000000LL;
      LOBYTE(v161) = 0;
      v129[0] = MEMORY[0x1895F87A8];
      v129[1] = 0x40000000LL;
      BOOL v130 = ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_127;
      nw_endpoint_t v131 = &unk_189BBA770;
      unsigned int v138 = v139;
      uint64_t v47 = *(void *)(a1 + 32);
      os_log_type_t v132 = v160;
      nw_endpoint_t v133 = v157;
      uint64_t v134 = v47;
      id v135 = v4;
      uint64_t v136 = *(void *)(a1 + 48);
      uint64_t v137 = v23;
      uint64_t v48 = *(void *)v157;
      do
      {
        if (!v48) {
          break;
        }
        uint64_t v49 = *(void *)(v48 + 32);
        char v50 = ((uint64_t (*)(void *))v130)(v129);
        uint64_t v48 = v49;
      }

      while ((v50 & 1) != 0);
      goto LABEL_102;
    }

    uint64_t v51 = *(void *)(a1 + 32);
    if (v51 && (*(_BYTE *)(v51 + 529) & 1) != 0) {
      goto LABEL_114;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v52 = (os_log_s *)gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_114;
    }
    uint64_t v53 = *(void *)(a1 + 32);
    BOOL v54 = "";
    BOOL v55 = v53 == 0;
    if (v53) {
      uint64_t v56 = (const char *)(v53 + 531);
    }
    else {
      uint64_t v56 = "";
    }
    unsigned int v57 = v139;
    *(_DWORD *)os_log_type_t v160 = 136446722;
    if (!v55) {
      BOOL v54 = " ";
    }
LABEL_113:
    *(void *)&v160[4] = v56;
    *(_WORD *)&v160[12] = 2080;
    *(void *)&v160[14] = v54;
    *(_WORD *)&v160[22] = 1024;
    LODWORD(v161) = v57;
    _os_log_impl(&dword_181A5C000, v52, OS_LOG_TYPE_ERROR, "%{public}s%sUnable to send %u bytes", v160, 0x1Cu);
    goto LABEL_114;
  }

  int v7 = *(_DWORD *)(v6 + 527);
  if ((v7 & 0x800000) == 0)
  {
    if ((*(_DWORD *)(v6 + 527) & 0x6000) != 0x2000) {
      goto LABEL_156;
    }
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
    }
    id v8 = (id)nw_protocol_copy_http_definition_http_definition;
    uint64_t v9 = nw_frame_copy_metadata_for_protocol(a2, (uint64_t)v8);
    if (v8) {
      os_release(v8);
    }
    if (!v9) {
      goto LABEL_156;
    }
    uint64_t v10 = *(void *)(a1 + 32);
    if ((!v10 || (*(_BYTE *)(v10 + 529) & 1) == 0) && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      BOOL v84 = (os_log_s *)gprivacy_proxyLogObj;
      BOOL v85 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
      uint64_t v10 = *(void *)(a1 + 32);
      if (v85)
      {
        BOOL v86 = "";
        BOOL v87 = v10 == 0;
        if (v10) {
          os_log_type_t v88 = (const char *)(v10 + 531);
        }
        else {
          os_log_type_t v88 = "";
        }
        *(_DWORD *)os_log_type_t v160 = 136446722;
        *(void *)&v160[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
        if (!v87) {
          BOOL v86 = " ";
        }
        *(_WORD *)&v160[12] = 2082;
        *(void *)&v160[14] = v88;
        *(_WORD *)&v160[22] = 2080;
        nw_protocol_options_t v161 = (uint64_t (*)(uint64_t, uint64_t))v86;
        _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSending oblivious HTTP message to proxy",  v160,  0x20u);
        uint64_t v10 = *(void *)(a1 + 32);
      }
    }

    *(_DWORD *)(v10 + 527) |= 0x4000u;
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      uint64_t v12 = mach_continuous_time();
      if (v12 <= 1) {
        uint64_t v13 = 1LL;
      }
      else {
        uint64_t v13 = v12;
      }
      *(void *)(v11 + 28_Block_object_dispose(va, 8) = v13;
      id v14 = nw_http_metadata_copy_request(v9);
      if (!v14)
      {
        if ((*(_BYTE *)(v11 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          nw_endpoint_t v70 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_log_type_t v160 = 136446466;
            *(void *)&v160[4] = v11 + 531;
            *(_WORD *)&v160[12] = 2080;
            *(void *)&v160[14] = " ";
            _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_ERROR,  "%{public}s%sHTTP message is not a request",  v160,  0x16u);
          }
        }

        nw_masque_mark_failed_with_error(v11, 22);
        goto LABEL_155;
      }

      id v15 = v14;
      char has_method = _nw_http_request_has_method((uint64_t)v15);

      if ((has_method & 1) == 0)
      {
        if ((*(_BYTE *)(v11 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          BOOL v71 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_log_type_t v160 = 136446466;
            *(void *)&v160[4] = v11 + 531;
            *(_WORD *)&v160[12] = 2080;
            *(void *)&v160[14] = " ";
            _os_log_impl(&dword_181A5C000, v71, OS_LOG_TYPE_ERROR, "%{public}s%sUnsupported method", v160, 0x16u);
          }
        }

        nw_masque_mark_failed_with_error(v11, 45);
        goto LABEL_154;
      }

      uint64_t v17 = *(void **)(v11 + 344);
      if (v17)
      {
        uint64_t v18 = (nw_endpoint *)nw_protocol_options_copy_proxy_endpoint(v17);
        if (v18)
        {
          uint64_t v19 = v18;
          if (nw_endpoint_get_type(v18) == 4)
          {
            *(void *)os_log_type_t v160 = 0LL;
            *(void *)&v160[8] = v160;
            *(void *)&v160[16] = 0x3802000000LL;
            nw_protocol_options_t v161 = __Block_byref_object_copy__27338;
            int v162 = (os_log_type_t *)__Block_byref_object_dispose__27339;
            unint64_t v163 = 0LL;
            LOBYTE(v164) = -1;
            uint64_t v147 = 0LL;
            uint64_t v148 = &v147;
            uint64_t v149 = 0x2000000000LL;
            char v150 = 0;
            uint64_t v20 = MEMORY[0x1895F87A8];
            *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
            uint64_t v141 = 0x40000000LL;
            uint64_t v142 = (uint64_t)___ZL42nw_masque_modify_proxied_oblivious_messageP9nw_masqueP20nw_protocol_metadata_block_invoke;
            id v143 = &unk_189BBA830;
            id v145 = v160;
            uint64_t v146 = v19;
            id v144 = &v147;
            nw_http_request_access_path(v15, type);
            if (*((_BYTE *)v148 + 24))
            {
              *(void *)id v157 = v20;
              *(void *)&v157[8] = 0x40000000LL;
              *(void *)&v157[16] = ___ZL42nw_masque_modify_proxied_oblivious_messageP9nw_masqueP20nw_protocol_metadata_block_invoke_138;
              id v158 = &unk_189BBA858;
              id v159 = v160;
              nw_http_request_access_extended_connect_protocol(v15, v157);
              nw_http_request_set_header_fields(*(void **)(*(void *)&v160[8] + 40LL), v15);
              if (nw_masque_add_extra_headers_to_request(v11, *(void **)(*(void *)&v160[8] + 40LL)))
              {
                nw_http_metadata_set_request(v9, *(void **)(*(void *)&v160[8] + 40LL));
                os_release(v19);
                if ((*(_BYTE *)(v11 + 529) & 1) == 0)
                {
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  __int16 v21 = (os_log_s *)gprivacy_proxyLogObj;
                  if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)int buf = 136446722;
                    char v152 = "nw_masque_modify_proxied_oblivious_message";
                    __int16 v153 = 2082;
                    uint64_t v154 = v11 + 531;
                    __int16 v155 = 2080;
                    id v156 = " ";
                    _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sModified oblivious request",  buf,  0x20u);
                  }
                }
              }
            }

            else
            {
              if ((*(_BYTE *)(v11 + 529) & 1) == 0)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                os_log_type_t v77 = (os_log_s *)gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)id v157 = 136446466;
                  *(void *)&v157[4] = v11 + 531;
                  *(_WORD *)&v157[12] = 2080;
                  *(void *)&v157[14] = " ";
                  _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_ERROR,  "%{public}s%sPath missing from message",  v157,  0x16u);
                }
              }

              nw_masque_mark_failed_with_error(v11, 22);
              os_release(v19);
            }

            _Block_object_dispose(&v147, 8);
            _Block_object_dispose(v160, 8);
            int v76 = (nw_endpoint *)v163;
            if (!v163) {
              goto LABEL_154;
            }
          }

          else
          {
            if ((*(_BYTE *)(v11 + 529) & 1) == 0)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              os_log_type_t v74 = (os_log_s *)gprivacy_proxyLogObj;
              if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
              {
                logging_description = nw_endpoint_get_logging_description(v19);
                *(_DWORD *)os_log_type_t v160 = 136446722;
                *(void *)&v160[4] = v11 + 531;
                *(_WORD *)&v160[12] = 2080;
                *(void *)&v160[14] = " ";
                *(_WORD *)&v160[22] = 2082;
                nw_protocol_options_t v161 = (uint64_t (*)(uint64_t, uint64_t))logging_description;
                _os_log_impl( &dword_181A5C000,  v74,  OS_LOG_TYPE_ERROR,  "%{public}s%sProxy endpoint %{public}s is not of type URL",  v160,  0x20u);
              }
            }

            nw_masque_mark_failed_with_error(v11, 22);
            int v76 = v19;
          }

          os_release(v76);
LABEL_154:
          os_release(v15);
LABEL_155:
          os_release(v9);
LABEL_156:
          uint64_t v61 = *(void *)(a1 + 40);
LABEL_157:
          *(void *)(a2 + 32) = 0LL;
          os_log_type_t v78 = *(uint64_t **)(v61 + 8);
          *(void *)(a2 + 40) = v78;
          *os_log_type_t v78 = a2;
          *(void *)(v61 + _Block_object_dispose(va, 8) = a2 + 32;
          return 1LL;
        }

        if ((*(_BYTE *)(v11 + 529) & 1) != 0) {
          goto LABEL_138;
        }
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        BOOL v72 = (os_log_s *)gprivacy_proxyLogObj;
        if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
        {
LABEL_138:
          nw_masque_mark_failed_with_error(v11, 22);
          goto LABEL_154;
        }

        *(_DWORD *)os_log_type_t v160 = 136446466;
        *(void *)&v160[4] = v11 + 531;
        *(_WORD *)&v160[12] = 2080;
        *(void *)&v160[14] = " ";
        __int16 v73 = "%{public}s%sProxy endpoint not found";
      }

      else
      {
        if ((*(_BYTE *)(v11 + 529) & 1) != 0) {
          goto LABEL_138;
        }
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        BOOL v72 = (os_log_s *)gprivacy_proxyLogObj;
        if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_138;
        }
        *(_DWORD *)os_log_type_t v160 = 136446466;
        *(void *)&v160[4] = v11 + 531;
        *(_WORD *)&v160[12] = 2080;
        *(void *)&v160[14] = " ";
        __int16 v73 = "%{public}s%sOptions not found";
      }

      _os_log_impl(&dword_181A5C000, v72, OS_LOG_TYPE_ERROR, v73, v160, 0x16u);
      goto LABEL_138;
    }

    __nwlog_obj();
    *(_DWORD *)os_log_type_t v160 = 136446210;
    *(void *)&v160[4] = "nw_masque_modify_proxied_oblivious_message";
    BOOL v80 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v157[0] = 0;
    if (__nwlog_fault(v80, type, v157))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v81 = (os_log_s *)__nwlog_obj();
        os_log_type_t v82 = type[0];
        if (!os_log_type_enabled(v81, type[0])) {
          goto LABEL_192;
        }
        *(_DWORD *)os_log_type_t v160 = 136446210;
        *(void *)&v160[4] = "nw_masque_modify_proxied_oblivious_message";
        uint64_t v83 = "%{public}s called with null masque";
        goto LABEL_191;
      }

      if (!v157[0])
      {
        id v81 = (os_log_s *)__nwlog_obj();
        os_log_type_t v82 = type[0];
        if (!os_log_type_enabled(v81, type[0])) {
          goto LABEL_192;
        }
        *(_DWORD *)os_log_type_t v160 = 136446210;
        *(void *)&v160[4] = "nw_masque_modify_proxied_oblivious_message";
        uint64_t v83 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_191;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v81 = (os_log_s *)__nwlog_obj();
      os_log_type_t v82 = type[0];
      BOOL v90 = os_log_type_enabled(v81, type[0]);
      if (backtrace_string)
      {
        if (v90)
        {
          *(_DWORD *)os_log_type_t v160 = 136446466;
          *(void *)&v160[4] = "nw_masque_modify_proxied_oblivious_message";
          *(_WORD *)&v160[12] = 2082;
          *(void *)&v160[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v81,  v82,  "%{public}s called with null masque, dumping backtrace:%{public}s",  v160,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_192;
      }

      if (v90)
      {
        *(_DWORD *)os_log_type_t v160 = 136446210;
        *(void *)&v160[4] = "nw_masque_modify_proxied_oblivious_message";
        uint64_t v83 = "%{public}s called with null masque, no backtrace";
LABEL_191:
        _os_log_impl(&dword_181A5C000, v81, v82, v83, v160, 0xCu);
      }
    }

uint64_t ___ZL29nw_masque_match_demux_patternPKhmP19nw_protocol_options_block_invoke( void *a1, unsigned int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  uint64_t v5 = a2;
  if (a2)
  {
    int v7 = (unsigned __int8 *)a1[6];
    if (a5)
    {
      while (1)
      {
        int v9 = *v7++;
        int v8 = v9;
        int v11 = *a5++;
        int v10 = v11;
        int v12 = *a4++;
        int v13 = (v8 ^ v12) & v10;
        BOOL v14 = v13 != 0;
        if (v13) {
          break;
        }
        if (!--v5) {
          goto LABEL_7;
        }
      }
    }

    else
    {
      while (1)
      {
        int v17 = *v7++;
        int v16 = v17;
        int v18 = *a4++;
        BOOL v19 = v16 == v18;
        BOOL v14 = v16 != v18;
        if (!v19) {
          break;
        }
        if (!--v5) {
          goto LABEL_7;
        }
      }
    }

    char v15 = 0;
  }

  else
  {
LABEL_7:
    BOOL v14 = 0LL;
    char v15 = 1;
  }

  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = v15;
  return v14;
}

uint64_t ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_127( uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  unsigned int v21 = 0;
  uint64_t v4 = (void *)nw_frame_unclaimed_bytes(a2, &v21);
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v6 = *(void **)(a2 + 40);
  int v7 = (void *)(a2 + 32);
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    uint64_t v6 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 40) + 8LL) = v6;
  }

  void *v6 = v5;
  *int v7 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  size_t v8 = *(unsigned int *)(a1 + 80);
  if (v21 >= v8 && v4)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    memcpy(v4, *(const void **)(a1 + 56), v8);
    nw_frame_claim(a2, v9, *(_DWORD *)(a1 + 80), 0);
    nw_frame_collapse(a2);
    nw_frame_unclaim(a2, v10, *(_DWORD *)(a1 + 80), 0);
    uint64_t v11 = *(void *)(a1 + 72);
    *(void *)(a2 + 32) = 0LL;
    int v12 = *(uint64_t **)(v11 + 8);
    *(void *)(a2 + 40) = v12;
    uint64_t *v12 = a2;
    *(void *)(v11 + _Block_object_dispose(va, 8) = v7;
  }

  else
  {
    uint64_t v13 = *(void *)(a1 + 48);
    if (!v13 || (*(_BYTE *)(v13 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      BOOL v14 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v15 = *(void *)(a1 + 48);
        int v16 = (const char *)(v15 + 531);
        BOOL v17 = v15 == 0;
        int v18 = " ";
        int v19 = *(_DWORD *)(a1 + 80);
        if (v17)
        {
          int v16 = "";
          int v18 = "";
        }

        *(_DWORD *)int buf = 136446978;
        uint64_t v23 = v16;
        __int16 v24 = 2080;
        id v25 = v18;
        __int16 v26 = 1024;
        int v27 = v19;
        __int16 v28 = 1024;
        unsigned int v29 = v21;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s%sUnable to send %u bytes, only received %u bytes",  buf,  0x22u);
      }
    }

    nw_frame_finalize(a2);
  }

  return 1LL;
}

uint64_t ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_129( uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  unsigned int v21 = 0;
  uint64_t v4 = (void *)nw_frame_unclaimed_bytes(a2, &v21);
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v6 = *(void **)(a2 + 40);
  int v7 = (void *)(a2 + 32);
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    uint64_t v6 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 40) + 8LL) = v6;
  }

  void *v6 = v5;
  *int v7 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  size_t v8 = *(unsigned int *)(a1 + 80);
  if (v21 >= v8 && v4)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    memcpy(v4, *(const void **)(a1 + 56), v8);
    nw_frame_claim(a2, v9, *(_DWORD *)(a1 + 80), 0);
    nw_frame_collapse(a2);
    nw_frame_unclaim(a2, v10, *(_DWORD *)(a1 + 80), 0);
    uint64_t v11 = *(void *)(a1 + 72);
    *(void *)(a2 + 32) = 0LL;
    int v12 = *(uint64_t **)(v11 + 8);
    *(void *)(a2 + 40) = v12;
    uint64_t *v12 = a2;
    *(void *)(v11 + _Block_object_dispose(va, 8) = v7;
  }

  else
  {
    uint64_t v13 = *(void *)(a1 + 48);
    if (!v13 || (*(_BYTE *)(v13 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      BOOL v14 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v15 = *(void *)(a1 + 48);
        int v16 = (const char *)(v15 + 531);
        BOOL v17 = v15 == 0;
        int v18 = " ";
        int v19 = *(_DWORD *)(a1 + 80);
        if (v17)
        {
          int v16 = "";
          int v18 = "";
        }

        *(_DWORD *)int buf = 136446978;
        uint64_t v23 = v16;
        __int16 v24 = 2080;
        id v25 = v18;
        __int16 v26 = 1024;
        int v27 = v19;
        __int16 v28 = 1024;
        unsigned int v29 = v21;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s%sUnable to send %u bytes, only received %u bytes",  buf,  0x22u);
      }
    }

    nw_frame_finalize(a2);
  }

  return 1LL;
}

uint64_t __Block_byref_object_copy__27338(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(va, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__27339(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    int v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL42nw_masque_modify_proxied_oblivious_messageP9nw_masqueP20nw_protocol_metadata_block_invoke( uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    uint64_t v13 = 0LL;
    int port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 48));
    if (port == 443)
    {
      hostname = (void *)nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 48));
    }

    else
    {
      int v6 = port;
      int v7 = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 48));
      asprintf(&v13, "%s:%u", v7, v6);
      hostname = v13;
    }

    uint64_t url_scheme = nw_endpoint_get_url_scheme(*(void **)(a1 + 48));
    uint64_t v9 = _nw_http_request_create("POST", url_scheme, hostname, a2);
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
    char v11 = *(_BYTE *)(v10 + 48);
    if ((v11 & 1) != 0)
    {
      int v12 = *(void **)(v10 + 40);
      if (v12)
      {
        os_release(v12);
        char v11 = *(_BYTE *)(v10 + 48);
      }
    }

    *(void *)(v10 + 40) = v9;
    *(_BYTE *)(v10 + 4_Block_object_dispose(va, 8) = v11 | 1;
    if (v13) {
      free(v13);
    }
  }

void ___ZL42nw_masque_modify_proxied_oblivious_messageP9nw_masqueP20nw_protocol_metadata_block_invoke_138( uint64_t a1, uint64_t a2)
{
}

BOOL nw_masque_add_extra_headers_to_request(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    *(void *)os_log_type_t type = 0LL;
    int v18 = type;
    uint64_t v19 = 0x2000000000LL;
    char v20 = 0;
    uint64_t v4 = *(void **)(a1 + 344);
    if (v4)
    {
      v16[0] = MEMORY[0x1895F87A8];
      v16[1] = 0x40000000LL;
      void v16[2] = ___ZL38nw_masque_add_extra_headers_to_requestP9nw_masqueP14nw_http_fields_block_invoke;
      void v16[3] = &unk_189BBA648;
      void v16[4] = type;
      v16[5] = a1;
      void v16[6] = a2;
      *(void *)int buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL41nw_masque_options_enumerate_extra_headersP19nw_protocol_optionsU13block_pointerFbPKcS2_E_block_invoke;
      uint64_t v23 = &unk_189BBA670;
      __int16 v24 = v16;
      nw_protocol_options_access_handle(v4, buf);
    }

    uint64_t v5 = *(void **)(a1 + 336);
    if (!v5) {
      goto LABEL_11;
    }
    int v6 = v5;
    if (nw_path_network_is_satisfied_update_reason(v6, 0LL))
    {
      int effective_traffic_class = v6->effective_traffic_class;
      if (!effective_traffic_class) {
        int effective_traffic_class = nw_parameters_get_traffic_class(v6->parameters);
      }

      int v6 = a2;
      _nw_http_fields_append(v6, "Sec-CH-Background", "?1");
    }

LABEL_11:
    BOOL v8 = *((_BYTE *)v18 + 24) == 0;
    _Block_object_dispose(type, 8);
    return v8;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v10, type, &v21))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request";
        uint64_t v13 = "%{public}s called with null request";
LABEL_26:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      BOOL v15 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request";
        uint64_t v13 = "%{public}s called with null request, no backtrace";
        goto LABEL_26;
      }
    }

    else
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request";
        uint64_t v13 = "%{public}s called with null request, backtrace limit exceeded";
        goto LABEL_26;
      }
    }
  }

void sub_18201BFB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL38nw_masque_add_extra_headers_to_requestP9nw_masqueP14nw_http_fields_block_invoke( uint64_t a1, const char *a2, char *__big)
{
  uint64_t v3 = __big;
  uint64_t v207 = *MEMORY[0x1895F89C0];
  int v6 = strstr(__big, "<token=");
  if (v6)
  {
    int v7 = v6;
    size_t v192 = strlen(v3);
    BOOL v8 = v7 + 7;
    uint64_t v9 = strchr(v7 + 7, 62);
    uint64_t v10 = strstr(v3, "{domain=");
    char v11 = strstr(v3, "[type=");
    __int128 uu = 0uLL;
    if ((unint64_t)v10 | (unint64_t)v11)
    {
      if (v10 && (os_log_type_t v12 = v11) != 0LL)
      {
        uint64_t v13 = v10 + 8;
        BOOL v14 = strchr(v13, 125);
        BOOL v15 = v12 + 6;
        int v16 = strchr(v15, 93);
        if (v14 && v16)
        {
          size_t v17 = v14 - v13;
          int64_t v18 = v16 - v15;
          BOOL v21 = v17 > 0x20 || v18 < 0 || v18 > 32;
          if (v21)
          {
            uint64_t v22 = *(void *)(a1 + 40);
            if (!v22 || (*(_BYTE *)(v22 + 529) & 1) == 0)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              uint64_t v23 = (os_log_s *)gprivacy_proxyLogObj;
              BOOL v24 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
              uint64_t v22 = *(void *)(a1 + 40);
              if (v24)
              {
                uint64_t v25 = (const char *)(v22 + 531);
                if (!v22) {
                  uint64_t v25 = "";
                }
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = v25;
                *(_WORD *)&buf[12] = 2080;
                __int16 v26 = " ";
                if (!v22) {
                  __int16 v26 = "";
                }
                *(void *)&buf[14] = v26;
                *(_WORD *)&_BYTE buf[22] = 2048;
                *(void *)&_BYTE buf[24] = v17;
                *(_WORD *)&_BYTE buf[32] = 2048;
                *(void *)&buf[34] = v18;
                _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s%sInvalid agent domain/type length (%zu/%zu)",  buf,  0x2Au);
                uint64_t v22 = *(void *)(a1 + 40);
              }
            }

            goto LABEL_27;
          }

          char v201 = 0;
          __int128 v200 = 0u;
          *(_OWORD *)uint64_t __dst = 0u;
          char v198 = 0;
          __int128 v196 = 0u;
          __int128 v197 = 0u;
          memcpy(__dst, v13, v17);
          memcpy(&v196, v15, v18);
          uint64_t v99 = *(void *)(a1 + 40);
          if (!v99 || (*(_BYTE *)(v99 + 529) & 1) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            unsigned int v100 = (os_log_s *)gprivacy_proxyLogObj;
            BOOL v101 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
            uint64_t v99 = *(void *)(a1 + 40);
            if (v101)
            {
              BOOL v102 = "";
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request_block_invoke";
              BOOL v103 = v99 == 0;
              if (v99) {
                uint64_t v104 = (const char *)(v99 + 531);
              }
              else {
                uint64_t v104 = "";
              }
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v104;
              *(_WORD *)&_BYTE buf[22] = 2080;
              if (!v103) {
                BOOL v102 = " ";
              }
              *(void *)&_BYTE buf[24] = v102;
              *(_WORD *)&_BYTE buf[32] = 2080;
              *(void *)&buf[34] = __dst;
              *(_WORD *)&buf[42] = 2080;
              *(void *)&buf[44] = &v196;
              _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinding token agent with domain '%s' type '%s'",  buf,  0x34u);
              uint64_t v99 = *(void *)(a1 + 40);
            }
          }

          uint64_t v105 = *(void *)(v99 + 336);
          if (v105)
          {
            uint64_t v106 = *(void **)(v105 + 224);
            if (v106)
            {
              id v107 = v106;
              applier[0] = MEMORY[0x1895F87A8];
              applier[1] = 0x40000000LL;
              applier[2] = ___ZL38nw_masque_add_extra_headers_to_requestP9nw_masqueP14nw_http_fields_block_invoke_98;
              applier[3] = &__block_descriptor_tmp_101_27363;
              applier[4] = __dst;
              applier[5] = &v196;
              void applier[6] = *(void *)(a1 + 40);
              applier[7] = &uu;
              xpc_dictionary_apply(v107, applier);
              xpc_release(v107);
            }
          }

          *(_OWORD *)(*(void *)(a1 + 40) + 272LL) = uu;
          goto LABEL_42;
        }

        uint64_t v22 = *(void *)(a1 + 40);
        if (v22 && (*(_BYTE *)(v22 + 529) & 1) != 0) {
          goto LABEL_27;
        }
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        int v45 = (os_log_s *)gprivacy_proxyLogObj;
        BOOL v68 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
        uint64_t v22 = *(void *)(a1 + 40);
        if (!v68) {
          goto LABEL_27;
        }
        BOOL v69 = (const char *)(v22 + 531);
        nw_endpoint_t v70 = "";
        if (v22) {
          nw_endpoint_t v70 = " ";
        }
        else {
          BOOL v69 = "";
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v69;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v70;
        uint64_t v49 = "%{public}s%sInvalid agent type suffix";
      }

      else
      {
        uint64_t v22 = *(void *)(a1 + 40);
        if (v22 && (*(_BYTE *)(v22 + 529) & 1) != 0) {
          goto LABEL_27;
        }
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        int v45 = (os_log_s *)gprivacy_proxyLogObj;
        BOOL v46 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
        uint64_t v22 = *(void *)(a1 + 40);
        if (!v46) {
          goto LABEL_27;
        }
        uint64_t v47 = (const char *)(v22 + 531);
        uint64_t v48 = "";
        if (v22) {
          uint64_t v48 = " ";
        }
        else {
          uint64_t v47 = "";
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v47;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v48;
        uint64_t v49 = "%{public}s%sInvalid agent type configuration";
      }

      _os_log_impl(&dword_181A5C000, v45, OS_LOG_TYPE_ERROR, v49, buf, 0x16u);
      uint64_t v22 = *(void *)(a1 + 40);
LABEL_27:
      nw_masque_mark_failed_with_error(v22, 22);
      return 0LL;
    }

    if (!v9 || v9 - v8 != 36)
    {
      uint64_t v50 = *(void *)(a1 + 40);
      if (!v50 || (*(_BYTE *)(v50 + 529) & 1) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v51 = (os_log_s *)gprivacy_proxyLogObj;
        BOOL v52 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
        uint64_t v50 = *(void *)(a1 + 40);
        if (v52)
        {
          uint64_t v53 = (const char *)(v50 + 531);
          if (!v50) {
            uint64_t v53 = "";
          }
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = v53;
          *(_WORD *)&buf[12] = 2080;
          BOOL v54 = " ";
          if (!v50) {
            BOOL v54 = "";
          }
          *(void *)&buf[14] = v54;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)&_BYTE buf[24] = "<token=";
          *(_WORD *)&_BYTE buf[32] = 2082;
          *(void *)&buf[34] = v3;
          _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_ERROR,  "%{public}s%sValue included %{public}s, but token UUID cannot be read: %{public}s",  buf,  0x2Au);
          uint64_t v50 = *(void *)(a1 + 40);
        }
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      nw_masque_mark_failed_with_error(v50, 22);
      return 1LL;
    }

    buf[36] = 0;
    __int128 v36 = *(_OWORD *)v8;
    __int128 v37 = *(_OWORD *)(v7 + 23);
    *(_DWORD *)&_BYTE buf[32] = *(_DWORD *)(v7 + 39);
    *(_OWORD *)int buf = v36;
    *(_OWORD *)&buf[16] = v37;
    uuid_parse(buf, (unsigned __int8 *)(*(void *)(a1 + 40) + 272LL));
LABEL_42:
    *(void *)uint64_t v205 = 0LL;
    unsigned __int8 v194 = 0;
    uint64_t v38 = *(void *)(a1 + 40);
    uint64_t v39 = *(void **)(v38 + 456);
    if (!v39)
    {
      uint64_t v44 = 0LL;
LABEL_140:
      if ((*(_BYTE *)(v38 + 527) & 2) != 0 || v44 || (_DWORD)v39)
      {
        if (!v44)
        {
          uint64_t v44 = nw_path_copy_token_from_agent(*(void **)(v38 + 336), (const unsigned __int8 *)(v38 + 272), v205);
          uint64_t v38 = *(void *)(a1 + 40);
        }

        if (v44 && *(void *)v205)
        {
          if (!v38 || (*(_BYTE *)(v38 + 529) & 1) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            uint64_t v83 = (os_log_s *)gprivacy_proxyLogObj;
            BOOL v84 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
            uint64_t v38 = *(void *)(a1 + 40);
            if (v84)
            {
              BOOL v85 = (const char *)(v38 + 531);
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request_block_invoke";
              if (!v38) {
                BOOL v85 = "";
              }
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v85;
              *(_WORD *)&_BYTE buf[22] = 2080;
              BOOL v86 = " ";
              if (!v38) {
                BOOL v86 = "";
              }
              *(void *)&_BYTE buf[24] = v86;
              *(_WORD *)&_BYTE buf[32] = 1042;
              *(_DWORD *)&buf[34] = 16;
              *(_WORD *)&buf[38] = 2098;
              *(void *)&uint8_t buf[40] = v38 + 272;
              _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFetched token from %{public, uuid_t}.16P",  buf,  0x30u);
              uint64_t v38 = *(void *)(a1 + 40);
            }
          }

          BOOL v87 = *(void **)(v38 + 456);
          size_t v88 = *(void *)v205;
          if (v87)
          {
            nw_http_connection_metadata_set_cached_token(v87, v44, *(uint64_t *)v205);
            size_t v88 = *(void *)v205;
          }

          int v89 = &v3[v192];
          dispatch_data_t v90 = dispatch_data_create((const void *)v44, v88, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A88]);
          BOOL v91 = (dispatch_data_s *)dispatch_data_create_with_transform();
          if (v90) {
            dispatch_release(v90);
          }
          BOOL v92 = v9 + 1;
          char v193 = &v3[v192];
          size_t size = dispatch_data_get_size(v91);
          size_t __n = v89 - (v9 + 1);
          BOOL v94 = nw_calloc_type<unsigned char>(v7 - v3 + v89 - v9 + size);
          __dst[0] = 0LL;
          __dst[1] = (char *)__dst;
          __int128 v200 = 0x2000000000uLL;
          *(void *)&__int128 v196 = 0LL;
          *((void *)&v196 + 1) = &v196;
          *(void *)&__int128 v197 = 0x2000000000LL;
          *((void *)&v197 + 1) = v94 + v7 - v3;
          if (v91)
          {
            *(void *)int buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
            *(void *)&_BYTE buf[24] = &unk_189BBF598;
            *(void *)&uint8_t buf[40] = &v196;
            *(void *)&buf[48] = size;
            *(void *)&_BYTE buf[32] = __dst;
            dispatch_data_apply(v91, buf);
            _Block_object_dispose(&v196, 8);
            _Block_object_dispose(__dst, 8);
            dispatch_release(v91);
          }

          else
          {
            _Block_object_dispose(&v196, 8);
            _Block_object_dispose(__dst, 8);
          }

          for (i = (const char *)(v94 + v7 - v3); ; i = v121 + 1)
          {
            char v121 = strchr(i, 43);
            if (!v121) {
              break;
            }
            char *v121 = 45;
          }

          for (j = (const char *)(v94 + v7 - v3); ; j = v123 + 1)
          {
            os_log_type_t v123 = strchr(j, 47);
            if (!v123) {
              break;
            }
            char *v123 = 95;
          }

          if (v7 != v3) {
            memcpy((void *)v94, v3, v7 - v3);
          }
          if (v193 != v92) {
            memcpy((void *)(v94 + v7 - v3 + size), v92, __n);
          }
          nw_http_fields_append(*(void **)(a1 + 48), (uint64_t)a2, v94);
          if (v94) {
            free((void *)v94);
          }
        }

        else
        {
          if (!v38 || (*(_BYTE *)(v38 + 529) & 1) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            uint64_t v95 = (os_log_s *)gprivacy_proxyLogObj;
            BOOL v96 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
            uint64_t v38 = *(void *)(a1 + 40);
            if (v96)
            {
              BOOL v97 = "";
              BOOL v98 = (const char *)(v38 + 531);
              if (!v38) {
                BOOL v98 = "";
              }
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = v98;
              *(_WORD *)&buf[12] = 2080;
              if (v38) {
                BOOL v97 = " ";
              }
              *(void *)&buf[14] = v97;
              *(_WORD *)&_BYTE buf[22] = 1042;
              *(_DWORD *)&_BYTE buf[24] = 16;
              *(_WORD *)&buf[28] = 2098;
              *(void *)&buf[30] = v38 + 272;
              _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_ERROR,  "%{public}s%sFailed to fetch token from %{public, uuid_t}.16P",  buf,  0x26u);
              uint64_t v38 = *(void *)(a1 + 40);
            }
          }

          nw_path_report_error_to_agent(*(void **)(v38 + 336), (const unsigned __int8 *)(v38 + 272), 81);
          *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
          nw_masque_mark_failed_with_error(*(void *)(a1 + 40), 2);
        }
      }

      return 1LL;
    }

    int v40 = v39;
    uint64_t v41 = nw_protocol_metadata_copy_definition((nw_protocol_metadata_t)v40);
    if (nw_protocol_copy_http_connection_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_connection_definition_onceToken, &__block_literal_global_62);
    }
    BOOL is_equal = nw_protocol_definition_is_equal( v41,  (nw_protocol_definition_t)nw_protocol_copy_http_connection_definition_definition);

    if (is_equal)
    {
      __dst[0] = 0LL;
      __dst[1] = (char *)__dst;
      __int128 v200 = 0x2020000000uLL;
      *(void *)int buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_http_connection_metadata_copy_cached_token_block_invoke;
      *(void *)&_BYTE buf[24] = &unk_189BC6778;
      *(void *)&_BYTE buf[32] = __dst;
      *(void *)&uint8_t buf[40] = &v194;
      *(void *)&buf[48] = v205;
      uint64_t v43 = v40[4];
      if (v43)
      {
        __nw_http_connection_metadata_copy_cached_token_block_invoke((uint64_t)buf, v43);
        uint64_t v44 = *((void *)__dst[1] + 3);
      }

      else
      {
        uint64_t v44 = 0LL;
      }

      _Block_object_dispose(__dst, 8);
LABEL_139:

      uint64_t v38 = *(void *)(a1 + 40);
      LODWORD(v39) = v194;
      goto LABEL_140;
    }

    __nwlog_obj();
    os_log_type_t v160 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_copy_cached_token";
    nw_protocol_options_t v161 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst[0]) = 16;
    LOBYTE(v196) = 0;
    if (__nwlog_fault(v161, __dst, &v196))
    {
      if (LOBYTE(__dst[0]) == 17)
      {
        __nwlog_obj();
        int v162 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v163 = (os_log_type_t)__dst[0];
        if (os_log_type_enabled(v162, (os_log_type_t)__dst[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_copy_cached_token";
          _os_log_impl(&dword_181A5C000, v162, v163, "%{public}s metadata must be http_connection", buf, 0xCu);
        }
      }

      else if ((_BYTE)v196)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v162 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t type = (os_log_type_t)__dst[0];
        BOOL v170 = os_log_type_enabled(v162, (os_log_type_t)__dst[0]);
        if (backtrace_string)
        {
          if (v170)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_copy_cached_token";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v162,  type,  "%{public}s metadata must be http_connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_403;
        }

        if (v170)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_copy_cached_token";
          _os_log_impl( &dword_181A5C000,  v162,  type,  "%{public}s metadata must be http_connection, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v162 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v180 = (os_log_type_t)__dst[0];
        if (os_log_type_enabled(v162, (os_log_type_t)__dst[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_copy_cached_token";
          _os_log_impl( &dword_181A5C000,  v162,  v180,  "%{public}s metadata must be http_connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_236:
        if (!*v3) {
          return 1LL;
        }
        goto LABEL_237;
      }
    }

    else
    {
      uint64_t v56 = *(void *)(a1 + 40);
    }

    if (v56)
    {
      BOOL v118 = *(void **)(v56 + 328);
      if (v118)
      {
        else {
          __int16 v119 = 0LL;
        }
        uint64_t globals_for_protocol = nw_context_get_globals_for_protocol(v118, v119);
        if (globals_for_protocol)
        {
          uint64_t v3 = (const char *)(globals_for_protocol + 4);
          *(_BYTE *)(globals_for_protocol + 10) = 0;
          uint64_t v125 = *(void *)(a1 + 40);
          if (v125) {
            goto LABEL_233;
          }
          goto LABEL_234;
        }

        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_get_cached_geohash_value";
        os_log_type_t v171 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(__dst[0]) = 16;
        LOBYTE(v196) = 0;
        if (!__nwlog_fault((const char *)v171, __dst, &v196))
        {
LABEL_422:
          if (v171) {
            free(v171);
          }
          uint64_t v3 = 0LL;
          uint64_t v125 = *(void *)(a1 + 40);
          if (v125)
          {
LABEL_233:
            if ((*(_BYTE *)(v125 + 529) & 1) != 0) {
              goto LABEL_235;
            }
          }

              uint64_t v63 = *(void *)(v13 + 328);
              if (!v63) {
                goto LABEL_720;
              }
              goto LABEL_237;
            }

            uint64_t v109 = *(void *)(v63 + 88);
            if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v110 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
              {
                BOOL v111 = *(void *)(v63 + 88);
                if (v111) {
                  uint64_t v112 = *(_DWORD *)(v111 + 460);
                }
                else {
                  uint64_t v112 = -1;
                }
                __int16 v119 = *(void *)(v63 + 64);
                *(_DWORD *)int buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v63 + 192;
                *(_WORD *)&_BYTE buf[22] = 2080;
                __int16 v531 = (uint64_t)" ";
                *(_WORD *)int v532 = 1024;
                *(_DWORD *)&v532[2] = v112;
                *(_WORD *)&v532[6] = 2048;
                *(void *)&v532[8] = v119;
                *(_WORD *)&v532[16] = 2048;
                *(void *)&v532[18] = v63;
                *(_WORD *)&v532[26] = 1024;
                *(_DWORD *)&v532[28] = v64;
                _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP3 stream with protocol: %p, peer_initiated: %u",  buf,  0x40u);
              }
            }

            if (*(void *)(v109 + 416) == v63)
            {
              if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v129 = (os_log_s *)gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v130 = *(void *)(v63 + 88);
                  if (v130) {
                    unint64_t v131 = *(_DWORD *)(v130 + 460);
                  }
                  else {
                    unint64_t v131 = -1;
                  }
                  uint64_t v144 = *(void *)(v63 + 64);
                  *(_DWORD *)int buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&_BYTE buf[22] = 2080;
                  __int16 v531 = (uint64_t)" ";
                  *(_WORD *)int v532 = 1024;
                  *(_DWORD *)&v532[2] = v131;
                  *(_WORD *)&v532[6] = 2048;
                  *(void *)&v532[8] = v144;
                  _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Returning connected without more reconfiguration for placeholder stream",  buf,  0x30u);
                }
              }

              nw_protocol_connected(*(void **)(v63 + 48), v63);
              uint64_t v63 = *(void *)(v13 + 328);
              if (!v63) {
                goto LABEL_720;
              }
            }

            else
            {
              uint64_t v120 = nw_parameters_copy_protocol_options_legacy(*(void **)(v63 + 144), (nw_protocol *)v63);
              if (v120)
              {
                char v121 = v120;
                if (nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken != -1) {
                  dispatch_once( &nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken,  &__block_literal_global_42);
                }
                *(void *)(v63 + 24) = &nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks;
                if (!v64)
                {
                  if (nw_protocol_options_is_webtransport(v121))
                  {
                    *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xFC | 1;
                    if (nw_webtransport_options_get_is_datagram(v121)) {
                      uint64_t v122 = 8;
                    }
                    else {
                      uint64_t v122 = 0;
                    }
                    *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xF7 | v122;
                    os_log_type_t v123 = nw_webtransport_options_get_is_unidirectional(v121);
                    nw_endpoint_t v124 = *(_BYTE *)(v63 + 276);
                    if (v123) {
                      uint64_t v125 = 4;
                    }
                    else {
                      uint64_t v125 = 0;
                    }
                    *(_BYTE *)(v63 + 276) = v124 & 0xFB | v125;
                    if ((v124 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      BOOL v126 = (os_log_s *)gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v127 = *(void *)(v63 + 88);
                        if (v127) {
                          unsigned int v128 = *(_DWORD *)(v127 + 460);
                        }
                        else {
                          unsigned int v128 = -1;
                        }
                        uint64_t v157 = *(void *)(v63 + 64);
                        unint64_t v158 = *(unsigned __int8 *)(v63 + 276);
                        *(_DWORD *)int buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&_BYTE buf[22] = 2080;
                        __int16 v531 = (uint64_t)" ";
                        *(_WORD *)int v532 = 1024;
                        *(_DWORD *)&v532[2] = v128;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v157;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v158 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v158 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v158 >> 2) & 1;
                        _os_log_impl( &dword_181A5C000,  v126,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagr am: %u, unidirectional: %u",  buf,  0x42u);
                      }
                    }

                    nw_webtransport_metadata_set_is_peer_initiated( *(void **)(v63 + 160),  (*(_BYTE *)(v63 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional( *(void **)(v63 + 160),  (*(_BYTE *)(v63 + 276) & 4) != 0);
LABEL_223:
                    if ((*(_BYTE *)(v63 + 276) & 8) == 0) {
                      goto LABEL_224;
                    }
LABEL_244:
                    nw_protocol_connected((void *)v63, v109);
LABEL_270:
                    __int16 v186 = *(void *)(v109 + 32);
                    if (v186)
                    {
                      if ((*(_BYTE *)(v109 + 548) & 0x40) == 0)
                      {
                        uint64_t v64 = v520;
LABEL_300:
                        if (*(void *)(v63 + 32))
                        {
                          uint64_t v207 = *(void *)(v63 + 176);
                          int v208 = *(void **)(v109 + 392);
                          *(void *)int buf = MEMORY[0x1895F87A8];
                          *(void *)&buf[8] = 0x40000000LL;
                          *(void *)&buf[16] = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
                          __int16 v531 = (uint64_t)&unk_189BBC5E0;
                          *(void *)int v532 = v207;
                          nw_queue_context_async(v208, buf);
                          goto LABEL_379;
                        }

                  if (v140) {
                    free(v140);
                  }
                  LODWORD(v137) = -1;
                  *(_DWORD *)(v8 + 356) = -1;
LABEL_239:
                  *((_DWORD *)v86 + 106) = v137;
                  if ((v86[158] & 1) == 0)
                  {
                    if (gLogDatapath)
                    {
                      uint64_t v299 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v299, OS_LOG_TYPE_DEBUG))
                      {
                        v300 = *((void *)v86 + 32);
                        v301 = *(_DWORD *)(*((void *)v86 + 31) + 372LL);
                        if (v300) {
                          LODWORD(v300) = *(_DWORD *)(v300 + 860);
                        }
                        id v302 = *((_DWORD *)v86 + 106);
                        char v303 = *(_DWORD *)(v8 + 344);
                        *(_DWORD *)id aBlock = 136448258;
                        *(void *)&void aBlock[4] = "nw_http1_add_stream";
                        *(_WORD *)&aBlock[12] = 2082;
                        *(void *)&aBlock[14] = v86 + 74;
                        *(_WORD *)&aBlock[22] = 2080;
                        id v385 = (uint64_t)" ";
                        *(_WORD *)int v386 = 1024;
                        *(_DWORD *)&v386[2] = v301;
                        *(_WORD *)&v386[6] = 1024;
                        *(_DWORD *)&v386[8] = v300;
                        *(_WORD *)&v386[12] = 1024;
                        *(_DWORD *)&v386[14] = v302;
                        *(_WORD *)&v386[18] = 1024;
                        *(_DWORD *)&v386[20] = v302;
                        *(_WORD *)&v386[24] = 2048;
                        *(void *)&v386[26] = v86;
                        *(_WORD *)&v386[34] = 1024;
                        *(_DWORD *)&v386[36] = v303;
                        _os_log_impl( &dword_181A5C000,  v299,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> added stream %u (%p), now have %u streams",  aBlock,  0x48u);
                      }
                    }
                  }

                  nw_protocol_plugin_name_set_name((uint64_t)(v86 + 64), (uint64_t)v86, v109);
                  if (buf[0])
                  {
                    uint64_t v13 = v373;
                    if ((*(_BYTE *)(v8 + 158) & 1) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      uint64_t v150 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
                      {
                        unint64_t v151 = *(_DWORD *)(v8 + 372);
                        int v152 = *(_DWORD *)(v8 + 344);
                        *(_DWORD *)id aBlock = 136447746;
                        *(void *)&void aBlock[4] = "nw_http1_stream_add_input_handler";
                        *(_WORD *)&aBlock[12] = 2082;
                        *(void *)&aBlock[14] = v8 + 74;
                        *(_WORD *)&aBlock[22] = 2080;
                        id v385 = (uint64_t)" ";
                        *(_WORD *)int v386 = 1024;
                        *(_DWORD *)&v386[2] = v151;
                        *(_WORD *)&v386[6] = 2048;
                        *(void *)&v386[8] = v376;
                        *(_WORD *)&v386[16] = 2082;
                        *(void *)&v386[18] = buf;
                        *(_WORD *)&v386[26] = 1024;
                        *(_DWORD *)&v386[28] = v152;
                        unint64_t v153 = "%{public}s %{public}s%s<i%u> added input handler %p from %{public}s, now have %u input handlers";
                        uint64_t v154 = (os_log_s *)v150;
                        unint64_t v155 = 64;
LABEL_248:
                        _os_log_impl(&dword_181A5C000, v154, OS_LOG_TYPE_DEFAULT, v153, aBlock, v155);
                      }
                    }
                  }

                  else
                  {
                    uint64_t v13 = v373;
                    if ((*(_BYTE *)(v8 + 158) & 1) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      id v156 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v157 = *(_DWORD *)(v8 + 372);
                        unint64_t v158 = *(_DWORD *)(v8 + 344);
                        *(_DWORD *)id aBlock = 136447490;
                        *(void *)&void aBlock[4] = "nw_http1_stream_add_input_handler";
                        *(_WORD *)&aBlock[12] = 2082;
                        *(void *)&aBlock[14] = v8 + 74;
                        *(_WORD *)&aBlock[22] = 2080;
                        id v385 = (uint64_t)" ";
                        *(_WORD *)int v386 = 1024;
                        *(_DWORD *)&v386[2] = v157;
                        *(_WORD *)&v386[6] = 2048;
                        *(void *)&v386[8] = v376;
                        *(_WORD *)&v386[16] = 1024;
                        *(_DWORD *)&v386[18] = v158;
                        unint64_t v153 = "%{public}s %{public}s%s<i%u> added input handler %p, now have %u input handlers";
                        uint64_t v154 = (os_log_s *)v156;
                        unint64_t v155 = 54;
                        goto LABEL_248;
                      }
                    }
                  }

                  if (v115) {
                    os_release(v115);
                  }
LABEL_251:
                  int v159 = 0;
                  goto LABEL_252;
                }

                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v126 = *(unsigned int *)(v8 + 344);
                *(_DWORD *)id aBlock = 136446978;
                *(void *)&void aBlock[4] = "nw_http1_add_stream";
                *(_WORD *)&aBlock[12] = 2082;
                *(void *)&aBlock[14] = "http1->streams_count";
                *(_WORD *)&aBlock[22] = 2048;
                id v385 = 1LL;
                *(_WORD *)int v386 = 2048;
                *(void *)&v386[2] = v126;
                uint64_t v127 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t type = OS_LOG_TYPE_ERROR;
                id v378 = 0;
                if (__nwlog_fault(v127, &type, &v378))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    unsigned int v128 = (os_log_s *)gLogObj;
                    id v129 = type;
                    if (os_log_type_enabled((os_log_t)gLogObj, type))
                    {
                      uint64_t v130 = *(unsigned int *)(v8 + 344);
                      *(_DWORD *)id aBlock = 136446978;
                      *(void *)&void aBlock[4] = "nw_http1_add_stream";
                      *(_WORD *)&aBlock[12] = 2082;
                      *(void *)&aBlock[14] = "http1->streams_count";
                      *(_WORD *)&aBlock[22] = 2048;
                      id v385 = 1LL;
                      *(_WORD *)int v386 = 2048;
                      *(void *)&v386[2] = v130;
                      unint64_t v131 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_216:
                      _os_log_impl(&dword_181A5C000, v128, v129, v131, aBlock, 0x2Au);
                    }
                  }

                  else if (v378)
                  {
                    os_log_type_t v132 = (char *)__nw_create_backtrace_string();
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    unsigned int v128 = (os_log_s *)gLogObj;
                    id v129 = type;
                    uint64_t v133 = os_log_type_enabled((os_log_t)gLogObj, type);
                    if (v132)
                    {
                      if (v133)
                      {
                        int v134 = *(unsigned int *)(v8 + 344);
                        *(_DWORD *)id aBlock = 136447234;
                        *(void *)&void aBlock[4] = "nw_http1_add_stream";
                        *(_WORD *)&aBlock[12] = 2082;
                        *(void *)&aBlock[14] = "http1->streams_count";
                        *(_WORD *)&aBlock[22] = 2048;
                        id v385 = 1LL;
                        *(_WORD *)int v386 = 2048;
                        *(void *)&v386[2] = v134;
                        *(_WORD *)&v386[10] = 2082;
                        *(void *)&v386[12] = v132;
                        _os_log_impl( &dword_181A5C000,  v128,  v129,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  aBlock,  0x34u);
                      }

                      free(v132);
                      goto LABEL_217;
                    }

                    if (v133)
                    {
                      uint64_t v136 = *(unsigned int *)(v8 + 344);
                      *(_DWORD *)id aBlock = 136446978;
                      *(void *)&void aBlock[4] = "nw_http1_add_stream";
                      *(_WORD *)&aBlock[12] = 2082;
                      *(void *)&aBlock[14] = "http1->streams_count";
                      *(_WORD *)&aBlock[22] = 2048;
                      id v385 = 1LL;
                      *(_WORD *)int v386 = 2048;
                      *(void *)&v386[2] = v136;
                      unint64_t v131 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                      goto LABEL_216;
                    }
                  }

                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    unsigned int v128 = (os_log_s *)gLogObj;
                    id v129 = type;
                    if (os_log_type_enabled((os_log_t)gLogObj, type))
                    {
                      unint64_t v135 = *(unsigned int *)(v8 + 344);
                      *(_DWORD *)id aBlock = 136446978;
                      *(void *)&void aBlock[4] = "nw_http1_add_stream";
                      *(_WORD *)&aBlock[12] = 2082;
                      *(void *)&aBlock[14] = "http1->streams_count";
                      *(_WORD *)&aBlock[22] = 2048;
                      id v385 = 1LL;
                      *(_WORD *)int v386 = 2048;
                      *(void *)&v386[2] = v135;
                      unint64_t v131 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                      goto LABEL_216;
                    }
                  }
                }

                nw_frame_claim(v11, v75, 0, v130);
                goto LABEL_237;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)int buf = 136446978;
              v364 = "nw_http1_connection_drain_outbound_frames";
              id v365 = 2082;
              *(void *)v366 = "unused_bytes";
              *(_WORD *)&v366[8] = 2048;
              *(void *)&v366[10] = v129;
              nw_endpoint_t v367 = 2048;
              *(void *)v368 = v99 + v129;
              unint64_t v131 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(__len[1]) = 16;
              type[0] = OS_LOG_TYPE_DEFAULT;
              char v11 = v89;
              if (__nwlog_fault(v131, &__len[1], type))
              {
                if (LOBYTE(__len[1]) == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v132 = gLogObj;
                  uint64_t v133 = __len[1];
                  if (os_log_type_enabled((os_log_t)gLogObj, __len[1]))
                  {
                    *(_DWORD *)int buf = 136446978;
                    v364 = "nw_http1_connection_drain_outbound_frames";
                    id v365 = 2082;
                    *(void *)v366 = "unused_bytes";
                    *(_WORD *)&v366[8] = 2048;
                    *(void *)&v366[10] = v129;
                    nw_endpoint_t v367 = 2048;
                    *(void *)v368 = v130;
                    int v134 = (os_log_s *)v132;
                    unint64_t v135 = v133;
                    uint64_t v136 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_232:
                    _os_log_impl(&dword_181A5C000, v134, v135, v136, buf, 0x2Au);
                  }
                }

                else if (type[0])
                {
                  uint64_t v137 = v89;
                  int v138 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  unsigned int v139 = (os_log_s *)gLogObj;
                  unint64_t v140 = __len[1];
                  uint64_t v141 = os_log_type_enabled((os_log_t)gLogObj, __len[1]);
                  if (v138)
                  {
                    if (v141)
                    {
                      *(_DWORD *)int buf = 136447234;
                      v364 = "nw_http1_connection_drain_outbound_frames";
                      id v365 = 2082;
                      *(void *)v366 = "unused_bytes";
                      *(_WORD *)&v366[8] = 2048;
                      *(void *)&v366[10] = v129;
                      nw_endpoint_t v367 = 2048;
                      *(void *)v368 = v130;
                      *(_WORD *)&v368[8] = 2082;
                      v369 = v138;
                      _os_log_impl( &dword_181A5C000,  v139,  v140,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                    }

                    free(v138);
                    char v11 = v137;
                    goto LABEL_233;
                  }

                  char v11 = v137;
                  if (v141)
                  {
                    *(_DWORD *)int buf = 136446978;
                    v364 = "nw_http1_connection_drain_outbound_frames";
                    id v365 = 2082;
                    *(void *)v366 = "unused_bytes";
                    *(_WORD *)&v366[8] = 2048;
                    *(void *)&v366[10] = v129;
                    nw_endpoint_t v367 = 2048;
                    *(void *)v368 = v130;
                    int v134 = v139;
                    unint64_t v135 = v140;
                    uint64_t v136 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                    goto LABEL_232;
                  }
                }

                else
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v142 = gLogObj;
                  id v143 = __len[1];
                  if (os_log_type_enabled((os_log_t)gLogObj, __len[1]))
                  {
                    *(_DWORD *)int buf = 136446978;
                    v364 = "nw_http1_connection_drain_outbound_frames";
                    id v365 = 2082;
                    *(void *)v366 = "unused_bytes";
                    *(_WORD *)&v366[8] = 2048;
                    *(void *)&v366[10] = v129;
                    nw_endpoint_t v367 = 2048;
                    *(void *)v368 = v130;
                    int v134 = (os_log_s *)v142;
                    unint64_t v135 = v143;
                    uint64_t v136 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                    goto LABEL_232;
                  }
                }
              }

      free(v54);
      goto LABEL_237;
    }

    if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v84 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s The kernel does not support MPTCP, using regular TCP",  buf,  0x16u);
      }
    }
  }

  uint64_t v83 = socket((int)v29, v11, 0);
  *(_DWORD *)&a1[4].flow_id[12] = v83;
  if (v83 < 0) {
    goto LABEL_206;
  }
LABEL_184:
  BOOL v85 = (nw_protocol *)nw_fd_wrapper_create(v83);
  uint64_t handle = (char)a1[2].handle;
  if ((handle & 1) != 0)
  {
    output_handler = a1[2].output_handler;
    if (output_handler)
    {
      os_release(output_handler);
      uint64_t handle = (char)a1[2].handle;
    }
  }

  a1[2].output_handler = v85;
  LOBYTE(a1[2].handle) = handle | 1;
  if ((nw_socket_set_common_sockopts(a1) & 1) != 0)
  {
    size_t v88 = &a1[6].flow_id[13];
    if ((*(_WORD *)&a1[6].flow_id[13] & 0x100) == 0) {
      goto LABEL_250;
    }
    memset(type, 0, sizeof(type));
    nw_protocol_get_flow_id(a1, type);
    int v138 = -106;
    *(_OWORD *)uuid_string_t out = *(_OWORD *)type;
    if ((*(_WORD *)v88 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v89 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&_BYTE buf[22] = 1042;
        *(_DWORD *)&_BYTE buf[24] = 16;
        *(_WORD *)&buf[28] = 2098;
        *(void *)&buf[30] = type;
        _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s Setting UUID %{public,uuid_t}.16P for multilayer packet logging",  buf,  0x26u);
      }
    }

    if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4386, out, 0x11u))
    {
      if (!identifier) {
        goto LABEL_303;
      }
      uint64_t v108 = *(void *)&identifier->name[24];
      if (!v108) {
        goto LABEL_303;
      }
      uint64_t v109 = *(uint64_t (**)(nw_protocol_identifier *))(v108 + 112);
      if (!v109) {
        goto LABEL_303;
      }
LABEL_250:
      if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
      {
        BOOL v111 = *(void *)&identifier[2].name[8];
        if (v111) {
          *(void *)&identifier[2].name[8] = v111 + 1;
        }
        uint64_t v110 = (void *)v109(identifier);
        if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
        {
          char v121 = *(void *)&identifier[2].name[8];
          if (v121)
          {
            uint64_t v122 = v121 - 1;
            *(void *)&identifier[2].name[8] = v122;
            if (!v122)
            {
              os_log_type_t v123 = *(void (***)(void))&identifier[1].name[24];
              if (v123)
              {
                *(void *)&identifier[1].name[24] = 0LL;
                v123[2](v123);
                _Block_release(v123);
              }

              if ((identifier[1].level & 1) != 0)
              {
                nw_endpoint_t v124 = *(const void **)&identifier[1].name[24];
                if (v124) {
                  _Block_release(v124);
                }
              }

              free(identifier);
            }
          }
        }
      }

      else
      {
        uint64_t v110 = (void *)v109(identifier);
      }

      if (v110
        && (uint64_t v112 = v110, v113 = (*(_WORD *)(v112[13] + 100LL) & 0x10) == 0, v112, v113))
      {
        if ((nw_fd_wrapper_guard(a1[2].output_handler) & 1) != 0 || (*(_WORD *)v88 & 0x80) != 0) {
          return 1LL;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v114 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
          return 1LL;
        }
        uint64_t v115 = *(_DWORD *)&a1[4].flow_id[12];
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&_BYTE buf[24] = v115;
        uint64_t v116 = "%{public}s %{public}s Failed to guard socket fd %d";
        __int16 v117 = (os_log_s *)v114;
        BOOL v118 = OS_LOG_TYPE_ERROR;
      }

      else
      {
LABEL_303:
        if ((*(_WORD *)v88 & 0x80) != 0) {
          return 1LL;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v119 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT)) {
          return 1LL;
        }
        uint64_t v120 = *(_DWORD *)&a1[4].flow_id[12];
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&_BYTE buf[24] = v120;
        uint64_t v116 = "%{public}s %{public}s Not guarding fd %d";
        __int16 v117 = (os_log_s *)v119;
        BOOL v118 = OS_LOG_TYPE_DEFAULT;
      }

      _os_log_impl(&dword_181A5C000, v117, v118, v116, buf, 0x1Cu);
      return 1LL;
    }

    dispatch_data_t v90 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v91 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = (char *)a1 + 404;
      *(_WORD *)&_BYTE buf[22] = 1024;
      *(_DWORD *)&_BYTE buf[24] = v90;
      _os_log_impl( &dword_181A5C000,  v91,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d",  buf,  0x1Cu);
    }

    BOOL v92 = (os_log_s *)__nwlog_obj();
    BOOL v93 = v92;
    if (v90 == 22)
    {
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 22;
        _os_log_impl( &dword_181A5C000,  v93,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d",  buf,  0x12u);
      }

      goto LABEL_250;
    }

    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v90;
    BOOL v102 = (char *)_os_log_send_and_compose_impl();
    uint64_t v133 = OS_LOG_TYPE_ERROR;
    os_log_type_t v132 = 0;
    if (__nwlog_fault(v102, &v133, &v132))
    {
      if (v133 == OS_LOG_TYPE_FAULT)
      {
        BOOL v103 = (os_log_s *)__nwlog_obj();
        uint64_t v104 = v133;
        if (!os_log_type_enabled(v103, v133)) {
          goto LABEL_248;
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v90;
        uint64_t v105 = "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d";
        goto LABEL_247;
      }

      if (!v132)
      {
        BOOL v103 = (os_log_s *)__nwlog_obj();
        uint64_t v104 = v133;
        if (!os_log_type_enabled(v103, v133)) {
          goto LABEL_248;
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v90;
        uint64_t v105 = "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_247;
      }

      uint64_t v106 = (char *)__nw_create_backtrace_string();
      BOOL v103 = (os_log_s *)__nwlog_obj();
      uint64_t v104 = v133;
      id v107 = os_log_type_enabled(v103, v133);
      if (v106)
      {
        if (v107)
        {
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v90;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v106;
          _os_log_impl( &dword_181A5C000,  v103,  v104,  "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v106);
        goto LABEL_248;
      }

      if (v107)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v90;
        uint64_t v105 = "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d, no backtrace";
LABEL_247:
        _os_log_impl(&dword_181A5C000, v103, v104, v105, buf, 0x12u);
      }
    }

  __int16 v210 = *((_BYTE *)v11 + 35);
  if ((v210 & 0x18) == 8)
  {
    *((_BYTE *)v11 + 35) = v210 & 0xF7;
    nw_endpoint_flow_start_child(v280);
    uint64_t v137 = v281;
    uint64_t v60 = *((void *)v11 + 116) != 0LL;
    goto LABEL_238;
  }

    free(backtrace_string);
    goto LABEL_272;
  }

  uint64_t handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle) {
    uint64_t v9 = &a1[1].output_handler;
  }
  else {
    uint64_t v9 = 0LL;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
    id v143 = (char *)_os_log_send_and_compose_impl();
    v323[0] = 16;
    v330[0] = 0;
    if (v323[0] == 17)
    {
      unint64_t v140 = (os_log_s *)__nwlog_obj();
      uint64_t v141 = v323[0];
      if (os_log_type_enabled(v140, (os_log_type_t)v323[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        uint64_t v142 = "%{public}s called with null test";
        goto LABEL_271;
      }

      goto LABEL_272;
    }

    if (!v330[0])
    {
      unint64_t v140 = (os_log_s *)__nwlog_obj();
      uint64_t v141 = v323[0];
      if (os_log_type_enabled(v140, (os_log_type_t)v323[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        uint64_t v142 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_271;
      }

      goto LABEL_272;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v140 = (os_log_s *)__nwlog_obj();
    uint64_t v141 = v323[0];
    uint64_t v150 = os_log_type_enabled(v140, (os_log_type_t)v323[0]);
    if (!backtrace_string)
    {
      if (v150)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        uint64_t v142 = "%{public}s called with null test, no backtrace";
        goto LABEL_271;
      }

      goto LABEL_272;
    }

    if (v150)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v147 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_235;
    }

    goto LABEL_236;
  }

  char v11 = *p_output_handler;
  if ((*p_output_handler & 0x400) != 0)
  {
    if (a3 <= 0xA) {
      BOOL v14 = 10LL;
    }
    else {
      BOOL v14 = a3;
    }
    BOOL v15 = malloc(v14);
    if (v15)
    {
      int v16 = (uint64_t)v15;
    }

    else
    {
      unint64_t v148 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v148, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "strict_malloc";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v14;
      uint64_t v149 = (void *)_os_log_send_and_compose_impl();
      BOOL result = __nwlog_abort((uint64_t)v149);
      if ((_DWORD)result) {
        goto LABEL_479;
      }
      free(v149);
      int v16 = 0LL;
    }

    size_t v17 = nw_frame_create(0, v16, v14, (uint64_t)__nw_frame_malloc_finalizer, 0LL);
    int64_t v18 = 1LL;
    nw_frame_set_buffer_used_malloc(v17, 1);
    *(void *)(v17 + 32) = 0LL;
    tqh_last = a6->tqh_last;
    *(void *)(v17 + 40) = tqh_last;
    *tqh_last = (nw_frame *)v17;
    a6->tqh_last = (nw_frame **)(v17 + 32);
    if (gLogDatapath)
    {
      char v20 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 2;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Returning input frame of length 10 with empty metadata",  buf,  0x16u);
      }
    }

    return v18;
  }

  if ((v11 & 0x800) == 0)
  {
    if ((v11 & 2) != 0)
    {
      if (gLogDatapath)
      {
        uint64_t v168 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 2;
          *(_WORD *)&_BYTE buf[22] = 1024;
          LODWORD(v327) = a4;
          _os_log_impl( &dword_181A5C000,  v168,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Overriding max bytes of %u to UINT32_MAX",  buf,  0x1Cu);
        }
      }
    }

    else if ((v11 & 0x40) != 0)
    {
      if (gLogDatapath)
      {
        uint64_t v181 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v181, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 2;
          *(_WORD *)&_BYTE buf[22] = 1024;
          LODWORD(v327) = a4;
          _os_log_impl( &dword_181A5C000,  v181,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Overriding max bytes of %u to 1",  buf,  0x1Cu);
        }
      }
    }

    *(void *)int buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3802000000LL;
    v327 = __Block_byref_object_copy__24;
    v328 = __Block_byref_object_dispose__25;
    v329[0] = 0LL;
    v329[1] = v329;
    int v31 = *p_output_handler;
    v279 = a4;
    if ((*p_output_handler & 4) != 0)
    {
      if (!gLogDatapath) {
        goto LABEL_37;
      }
      int v33 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_37;
      }
      *(_DWORD *)id v323 = 136446466;
      *(void *)&v323[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v323[12] = 2082;
      *(void *)&v323[14] = a1 + 2;
      int v34 = "%{public}s %{public}s Splitting incoming frames";
    }

    else if ((v31 & 0x10) != 0)
    {
      if (!gLogDatapath) {
        goto LABEL_37;
      }
      int v33 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_37;
      }
      *(_DWORD *)id v323 = 136446466;
      *(void *)&v323[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v323[12] = 2082;
      *(void *)&v323[14] = a1 + 2;
      int v34 = "%{public}s %{public}s Using custom frame allocator on incoming frames";
    }

    else
    {
      int v32 = a6;
      if ((v31 & 0x20) == 0) {
        goto LABEL_38;
      }
      if (!gLogDatapath || (int v33 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)))
      {
LABEL_37:
        int v32 = (nw_frame_array_s *)(*(void *)&buf[8] + 40LL);
LABEL_38:
        output_handler = a1->output_handler;
        v281 = output_handler;
        if (!output_handler)
        {
          __int128 v36 = 0LL;
          __int128 v37 = &v315;
          os_log_type_t v315 = 0LL;
          id v316 = &v315;
          v318 = 0;
          v317 = 0x2000000000LL;
          goto LABEL_62;
        }

        if (output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          os_log_type_t v315 = 0LL;
          __int128 v36 = 255LL;
        }

        else
        {
          __int128 v36 = 0LL;
          os_log_type_t v315 = 0LL;
        }

        __int128 v37 = &v315;
        v318 = 0;
        id v316 = &v315;
        v317 = 0x2000000000LL;
        uint64_t v39 = output_handler->callbacks;
        if (!v39)
        {
LABEL_62:
          uint64_t v48 = *p_output_handler;
          uint64_t v49 = MEMORY[0x1895F87A8];
          if ((*p_output_handler & 4) != 0)
          {
            *((_DWORD *)v37 + 6) = 0;
            v308[0] = v49;
            v308[1] = 0x40000000LL;
            os_log_type_t v309 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v310 = &unk_189BC8420;
            os_log_type_t v313 = p_output_handler;
            BOOL v314 = a6;
            int v311 = buf;
            uint32_t v312 = &v315;
            uint64_t v51 = *(void *)(*(void *)&buf[8] + 40LL);
            do
            {
              if (!v51) {
                break;
              }
              BOOL v52 = *(void *)(v51 + 32);
              uint64_t v53 = v309(v308);
              uint64_t v51 = v52;
            }

            while ((v53 & 1) != 0);
          }

          else if ((v48 & 0x10) != 0)
          {
            *((_DWORD *)v37 + 6) = 0;
            v301[0] = v49;
            v301[1] = 0x40000000LL;
            id v302 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_28;
            char v303 = &unk_189BC8448;
            int v306 = p_output_handler;
            v307 = a6;
            v304 = buf;
            uint64_t v305 = &v315;
            BOOL v54 = *(void *)(*(void *)&buf[8] + 40LL);
            do
            {
              if (!v54) {
                break;
              }
              BOOL v55 = *(void *)(v54 + 32);
              uint64_t v56 = v302(v301);
              BOOL v54 = v55;
            }

            while ((v56 & 1) != 0);
          }

          else
          {
            if ((v48 & 0x20) == 0)
            {
              if ((v48 & 0x1000) == 0) {
                goto LABEL_137;
              }
              if (a2)
              {
                if (a2->handle == &nw_protocol_ref_counted_handle)
                {
                  BOOL v68 = a2[1].callbacks;
                  if (v68) {
                    a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v68->add_input_handler + 1);
                  }
                  *(void *)id v330 = a2;
                  uint64_t v50 = v330[8] | 1;
                }

                else
                {
                  *(void *)id v330 = a2;
                  uint64_t v50 = v330[8] & 0xFE;
                }

                v330[8] = v50;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  nw_endpoint_t v70 = a1[1].callbacks;
                  if (v70) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v70->add_input_handler + 1);
                  }
                  *(void *)v321 = a1;
                  BOOL v69 = v322 | 1;
                }

                else
                {
                  *(void *)v321 = a1;
                  BOOL v69 = v322 & 0xFE;
                }

                v322 = v69;
                uint64_t v71 = a2->callbacks;
                if (v71)
                {
                  error = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v71->error;
                  if (error)
                  {
                    error(a2, a1, 14LL);
                    goto LABEL_108;
                  }
                }

                __int16 v191 = v36;
                __nwlog_obj();
                identifier = a2->identifier;
                *(_DWORD *)id v323 = 136446722;
                *(void *)&v323[4] = "__nw_protocol_error";
                if (!identifier) {
                  identifier = (nw_protocol_identifier *)"invalid";
                }
                *(_WORD *)&v323[12] = 2082;
                *(void *)&v323[14] = identifier;
                *(_WORD *)&v323[22] = 2048;
                *(void *)BOOL v324 = a2;
                char v193 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t v320 = OS_LOG_TYPE_ERROR;
                nw_endpoint_t v319 = 0;
                if (__nwlog_fault(v193, &v320, &v319))
                {
                  if (v320 == OS_LOG_TYPE_FAULT)
                  {
                    unsigned __int8 v194 = (os_log_s *)__nwlog_obj();
                    v195 = v320;
                    if (os_log_type_enabled(v194, v320))
                    {
                      __int128 v196 = a2->identifier;
                      if (!v196) {
                        __int128 v196 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)id v323 = 136446722;
                      *(void *)&v323[4] = "__nw_protocol_error";
                      *(_WORD *)&v323[12] = 2082;
                      *(void *)&v323[14] = v196;
                      *(_WORD *)&v323[22] = 2048;
                      *(void *)BOOL v324 = a2;
                      __int128 v197 = "%{public}s protocol %{public}s (%p) has invalid error callback";
LABEL_411:
                      int v253 = v194;
LABEL_412:
                      _os_log_impl(&dword_181A5C000, v253, v195, v197, v323, 0x20u);
                    }
                  }

                  else if (v319)
                  {
                    nw_endpoint_t v232 = (char *)__nw_create_backtrace_string();
                    uint64_t v233 = (os_log_s *)__nwlog_obj();
                    v195 = v320;
                    nw_endpoint_t v274 = v233;
                    uint64_t v234 = os_log_type_enabled(v233, v320);
                    if (v232)
                    {
                      if (v234)
                      {
                        v235 = a2->identifier;
                        if (!v235) {
                          v235 = (nw_protocol_identifier *)"invalid";
                        }
                        *(_DWORD *)id v323 = 136446978;
                        *(void *)&v323[4] = "__nw_protocol_error";
                        *(_WORD *)&v323[12] = 2082;
                        *(void *)&v323[14] = v235;
                        *(_WORD *)&v323[22] = 2048;
                        *(void *)BOOL v324 = a2;
                        *(_WORD *)&v324[8] = 2082;
                        *(void *)&v324[10] = v232;
                        _os_log_impl( &dword_181A5C000,  v274,  v195,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  v323,  0x2Au);
                      }

                      free(v232);
                      goto LABEL_413;
                    }

                    if (v234)
                    {
                      uint64_t v258 = a2->identifier;
                      if (!v258) {
                        uint64_t v258 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)id v323 = 136446722;
                      *(void *)&v323[4] = "__nw_protocol_error";
                      *(_WORD *)&v323[12] = 2082;
                      *(void *)&v323[14] = v258;
                      *(_WORD *)&v323[22] = 2048;
                      *(void *)BOOL v324 = a2;
                      __int128 v197 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
                      int v253 = v274;
                      goto LABEL_412;
                    }
                  }

                  else
                  {
                    unsigned __int8 v194 = (os_log_s *)__nwlog_obj();
                    v195 = v320;
                    if (os_log_type_enabled(v194, v320))
                    {
                      id v252 = a2->identifier;
                      if (!v252) {
                        id v252 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)id v323 = 136446722;
                      *(void *)&v323[4] = "__nw_protocol_error";
                      *(_WORD *)&v323[12] = 2082;
                      *(void *)&v323[14] = v252;
                      *(_WORD *)&v323[22] = 2048;
                      *(void *)BOOL v324 = a2;
                      __int128 v197 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
                      goto LABEL_411;
                    }
                  }
                }

LABEL_429:
            __break(1u);
            return result;
          }
        }

        else
        {
          __int16 v186 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v186, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v205 = 136446210;
          *(void *)&v205[4] = "_strict_strlcat";
          __int16 v187 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v187);
          if ((_DWORD)result) {
            goto LABEL_429;
          }
          free(v187);
          uint64_t v133 = 0LL;
          int v134 = 1;
          if (v135) {
            goto LABEL_286;
          }
        }
      }

      else
      {
        uint64_t v133 = *((void *)__dst[1] + 3);
        if (!v133)
        {
          if (!v111)
          {
            if (v114)
            {
LABEL_328:
              unint64_t v155 = *(void *)(*((void *)&uu + 1) + 24LL);
              if (v155)
              {
                id v156 = v129;
                while (*v156)
                {
                  ++v156;
                  if (!--v155) {
                    goto LABEL_339;
                  }
                }

                if (v155 < 2)
                {
LABEL_338:
                  _BYTE *v156 = 0;
                }

                else
                {
                  uint64_t v157 = 0LL;
                  unint64_t v158 = v155 - 1;
                  while (1)
                  {
                    int v159 = v117[v157];
                    v156[v157] = v159;
                    if (!v159) {
                      break;
                    }
                    if (v158 == ++v157)
                    {
                      v156 += v157;
                      goto LABEL_338;
                    }
                  }
                }
              }
            }

      if (v172) {
        free(v172);
      }
      *(_DWORD *)(v9 + 340) = 0;
      goto LABEL_432;
    }
  }

  if ((*(_BYTE *)(v9 + 158) & 1) == 0)
  {
    if (*((_BYTE *)v10 + 1537))
    {
      v568 = v10;
      v569 = (os_log_s *)__nwlog_obj();
      v570 = os_log_type_enabled(v569, OS_LOG_TYPE_DEBUG);
      uint64_t v10 = v568;
      if (v570)
      {
        v571 = *(_DWORD *)(v9 + 372);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_get_next_idle_connection";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v9 + 74;
        *(_WORD *)&_BYTE buf[22] = 2080;
        v783 = (uint64_t)" ";
        *(_WORD *)v784 = 1024;
        *(_DWORD *)&v784[2] = v571;
        _os_log_impl( &dword_181A5C000,  v569,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> no idle connections",  buf,  0x26u);
        uint64_t v10 = v568;
      }
    }
  }

  if (*(void *)(v15 + 256))
  {
    if ((*(_BYTE *)(v15 + 158) & 1) == 0)
    {
      BOOL v94 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v95 = *(void *)(v15 + 256);
        BOOL v96 = *(_DWORD *)(*(void *)(v15 + 248) + 372LL);
        if (v95) {
          LODWORD(v95) = *(_DWORD *)(v95 + 860);
        }
        BOOL v97 = *(_DWORD *)(v15 + 424);
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v15 + 74;
        *(_WORD *)&_BYTE buf[22] = 2080;
        v783 = (uint64_t)" ";
        *(_WORD *)v784 = 1024;
        *(_DWORD *)&v784[2] = v96;
        *(_WORD *)&v784[6] = 1024;
        *(_DWORD *)&v784[8] = v95;
        *(_WORD *)&v784[12] = 1024;
        *(_DWORD *)&v784[14] = v97;
        BOOL v98 = "%{public}s %{public}s%s<i%u:c%u:s%u> stream already has current connection, ignoring";
        uint64_t v99 = v94;
        unsigned int v100 = 50;
LABEL_144:
        _os_log_impl(&dword_181A5C000, v99, OS_LOG_TYPE_DEBUG, v98, buf, v100);
        goto LABEL_145;
      }
    }

    goto LABEL_145;
  }

  if ((*(_WORD *)(v15 + 428) & 8) != 0)
  {
    if (!*(void *)(v15 + 32))
    {
      if (!(*(_BYTE *)(v15 + 158) & 1 | (*((_BYTE *)v10 + 1537) == 0)))
      {
        int v244 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v244, OS_LOG_TYPE_DEBUG))
        {
          char v245 = *(void *)(v15 + 256);
          int v246 = *(_DWORD *)(*(void *)(v15 + 248) + 372LL);
          if (v245) {
            LODWORD(v245) = *(_DWORD *)(v245 + 860);
          }
          v247 = *(_DWORD *)(v15 + 424);
          *(_DWORD *)int buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v15 + 74;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v783 = (uint64_t)" ";
          *(_WORD *)v784 = 1024;
          *(_DWORD *)&v784[2] = v246;
          *(_WORD *)&v784[6] = 1024;
          *(_DWORD *)&v784[8] = v245;
          *(_WORD *)&v784[12] = 1024;
          *(_DWORD *)&v784[14] = v247;
          *(_WORD *)&v784[18] = 2048;
          *(void *)&v784[20] = v15;
          BOOL v98 = "%{public}s %{public}s%s<i%u:c%u:s%u> Stream %p still awaiting new output handler";
          uint64_t v99 = v244;
          unsigned int v100 = 60;
          goto LABEL_144;
        }
      }

      goto LABEL_145;
    }

    if (!(*(_BYTE *)(v15 + 158) & 1 | (*((_BYTE *)v10 + 1537) == 0)))
    {
      v617 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v617, OS_LOG_TYPE_DEBUG))
      {
        v618 = *(void *)(v15 + 256);
        v619 = *(_DWORD *)(*(void *)(v15 + 248) + 372LL);
        if (v618) {
          LODWORD(v61_Block_object_dispose(va, 8) = *(_DWORD *)(v618 + 860);
        }
        v620 = *(_DWORD *)(v15 + 424);
        v621 = *(void *)(v15 + 32);
        *(_DWORD *)int buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v15 + 74;
        *(_WORD *)&_BYTE buf[22] = 2080;
        v783 = (uint64_t)" ";
        *(_WORD *)v784 = 1024;
        *(_DWORD *)&v784[2] = v619;
        *(_WORD *)&v784[6] = 1024;
        *(_DWORD *)&v784[8] = v618;
        *(_WORD *)&v784[12] = 1024;
        *(_DWORD *)&v784[14] = v620;
        *(_WORD *)&v784[18] = 2048;
        *(void *)&v784[20] = v15;
        *(_WORD *)&v784[28] = 2048;
        *(void *)&v784[30] = v621;
        _os_log_impl( &dword_181A5C000,  v617,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> creating connection for stream %p with new output_handler %p",  buf,  0x46u);
      }
    }

    v751 = *(_OWORD **)(v15 + 32);
    if (v751)
    {
      uint64_t v133 = *(void **)(v15 + 336);
      if (v133)
      {
        int v134 = *(void **)(v15 + 320);
        if (v134)
        {
          unint64_t v135 = calloc(1uLL, 0x370uLL);
          if (!v135)
          {
            v622 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v622, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int buf = 136446722;
            *(void *)&uint8_t buf[4] = "strict_calloc";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = 1LL;
            *(_WORD *)&_BYTE buf[22] = 2048;
            v783 = 880LL;
            v623 = (void *)_os_log_send_and_compose_impl();
            BOOL result = __nwlog_abort((uint64_t)v623);
            if (result) {
              goto LABEL_1391;
            }
            free(v623);
          }

          bzero(v135, 0x370uLL);
          if (nw_protocol_http1_identifier::onceToken != -1) {
            dispatch_once(&nw_protocol_http1_identifier::onceToken, &__block_literal_global_39881);
          }
          *((void *)v135 + 2) = &nw_protocol_http1_identifier::http1_protocol_identifier;
          *((void *)v135 + 3) = &nw_protocol_http1_get_callbacks(void)::http1_protocol_callbacks;
          *((_DWORD *)v135 + 46) = 3;
          *((void *)v135 + 22) = v135;
          *((void *)v135 + 5) = v135 + 10;
          *((void *)v135 + 60) = v9;
          nw_protocol_set_output_handler((uint64_t)v135, (uint64_t)v751);
          *(void *)int buf = os_retain(v133);
          nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v135 + 47), buf);
          *(void *)int buf = os_retain(v134);
          nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v135 + 46), buf);
          *(void *)int buf = nw_parameters_copy_context(v134);
          nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v135 + 31), buf);
          *((void *)v135 + 24) = *(void *)(v9 + 192);
          uint64_t v136 = MEMORY[0x1895F87A8];
          uint64_t v137 = (void *)*((void *)v135 + 62);
          *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
          v767 = 0x40000000LL;
          v768 = (uint64_t)___ZL26nw_http1_connection_createP11nw_protocolP17nw_protocol_http1P11nw_endpointP13nw_parameters_block_invoke;
          v769 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_40_39882;
          v770 = (void (*)(uint64_t))v135;
          *(void *)int buf = nw_http_connection_create_metadata(v137, type, 0LL);
          nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v135 + 48), buf);
          nw_http_connection_metadata_set_version(*((void **)v135 + 96), 3);
          nw_http_connection_metadata_set_shared_connection_pool_metadata(*((void **)v135 + 96), *(void **)(v9 + 312));
          *((void *)v135 + 77) = 0LL;
          *((void *)v135 + 7_Block_object_dispose(va, 8) = (char *)v135 + 616;
          *((void *)v135 + 79) = 0LL;
          *((void *)v135 + 80) = (char *)v135 + 632;
          *((void *)v135 + 81) = 0LL;
          *((void *)v135 + 82) = (char *)v135 + 648;
          *((void *)v135 + 83) = 0LL;
          *((void *)v135 + 84) = (char *)v135 + 664;
          *((void *)v135 + 86) = (char *)v135 + 680;
          *((void *)v135 + 85) = 0LL;
          nw_frame_cache_init((uint64_t)v135 + 696, (uint64_t)v135, 256, 0x40000, 16);
          int v138 = *((void *)v135 + 60);
          if (v138)
          {
            *(_OWORD *)((char *)v135 + 360) = 0u;
            *(_OWORD *)((char *)v135 + 376) = 0u;
            *(_OWORD *)((char *)v135 + 392) = 0u;
            *(_OWORD *)((char *)v135 + 40_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)((char *)v135 + 424) = 0u;
            *(_OWORD *)((char *)v135 + 440) = 0u;
            *(_OWORD *)((char *)v135 + 32_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)((char *)v135 + 344) = 0u;
            *((void *)v135 + 59) = nw_http1_on_reset;
            *((void *)v135 + 37) = nw_http1_on_message_begin;
            *((void *)v135 + 3_Block_object_dispose(va, 8) = nw_http1_on_url;
            *((void *)v135 + 4_Block_object_dispose(va, 8) = nw_http1_on_message_complete;
            *((void *)v135 + 49) = nw_http1_on_url_complete;
            *((void *)v135 + 39) = nw_http1_on_status;
            *((void *)v135 + 40) = nw_http1_on_method;
            *((void *)v135 + 50) = nw_http1_on_status_complete;
            *((void *)v135 + 51) = nw_http1_on_method_complete;
            *((void *)v135 + 42) = nw_http1_on_header_field;
            *((void *)v135 + 43) = nw_http1_on_header_value;
            *((void *)v135 + 53) = nw_http1_on_header_field_complete;
            *((void *)v135 + 54) = nw_http1_on_header_value_complete;
            *((void *)v135 + 46) = nw_http1_on_headers_complete;
            *((void *)v135 + 47) = nw_http1_on_body;
            *((void *)v135 + 57) = nw_http1_on_chunk_header;
            *((void *)v135 + 5_Block_object_dispose(va, 8) = nw_http1_on_chunk_complete;
            unsigned int v139 = *(_BYTE *)(v138 + 376);
            *(_OWORD *)((char *)v135 + 24_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)((char *)v135 + 200) = 0u;
            *(_OWORD *)((char *)v135 + 264) = 0u;
            *(_OWORD *)((char *)v135 + 232) = 0u;
            *(_OWORD *)((char *)v135 + 216) = 0u;
            if ((v139 & 1) != 0) {
              unint64_t v140 = 1;
            }
            else {
              unint64_t v140 = 2;
            }
            *((_BYTE *)v135 + 272) = v140;
            *((void *)v135 + 35) = 0LL;
            *((void *)v135 + 36) = (char *)v135 + 296;
            *((_WORD *)v135 + 139) = 16131;
            *((void *)v135 + 31) = v135;
            *((void *)v135 + 32) = 238LL;
            if ((*((_BYTE *)v135 + 158) & 1) == 0)
            {
              uint64_t v141 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v142 = *((void *)v135 + 61);
                id v143 = *(_DWORD *)(*((void *)v135 + 60) + 372LL);
                uint64_t v144 = *((_DWORD *)v135 + 215);
                if (v142) {
                  LODWORD(v142) = *(_DWORD *)(v142 + 424);
                }
                *(_DWORD *)int buf = 136448258;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_log_parser_version";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = (char *)v135 + 74;
                *(_WORD *)&_BYTE buf[22] = 2080;
                v783 = (uint64_t)" ";
                *(_WORD *)v784 = 1024;
                *(_DWORD *)&v784[2] = v143;
                *(_WORD *)&v784[6] = 1024;
                *(_DWORD *)&v784[8] = v144;
                *(_WORD *)&v784[12] = 1024;
                *(_DWORD *)&v784[14] = v142;
                *(_WORD *)&v784[18] = 1024;
                *(_DWORD *)&v784[20] = 9;
                *(_WORD *)&v784[24] = 1024;
                *(_DWORD *)&v784[26] = 2;
                *(_WORD *)&v784[30] = 1024;
                *(_DWORD *)&v784[32] = 1;
                _os_log_impl( &dword_181A5C000,  v141,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> using http parser v%u.%u.%u",  buf,  0x44u);
              }
            }

            goto LABEL_208;
          }

          __nwlog_obj();
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
          v624 = (char *)_os_log_send_and_compose_impl();
          v777[0] = 16;
          LOBYTE(v758[0]) = 0;
          if (__nwlog_fault(v624, v777, v758))
          {
            if (v777[0] == 17)
            {
              v625 = (os_log_s *)__nwlog_obj();
              v626 = v777[0];
              if (!os_log_type_enabled(v625, (os_log_type_t)v777[0])) {
                goto LABEL_1299;
              }
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
              v627 = "%{public}s called with null http1_connection->protocol_http1";
              goto LABEL_1298;
            }

            if (!LOBYTE(v758[0]))
            {
              v625 = (os_log_s *)__nwlog_obj();
              v626 = v777[0];
              if (!os_log_type_enabled(v625, (os_log_type_t)v777[0])) {
                goto LABEL_1299;
              }
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
              v627 = "%{public}s called with null http1_connection->protocol_http1, backtrace limit exceeded";
              goto LABEL_1298;
            }

            v694 = (char *)__nw_create_backtrace_string();
            v625 = (os_log_s *)__nwlog_obj();
            v626 = v777[0];
            v695 = os_log_type_enabled(v625, (os_log_type_t)v777[0]);
            if (v694)
            {
              if (v695)
              {
                *(_DWORD *)int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v694;
                _os_log_impl( &dword_181A5C000,  v625,  v626,  "%{public}s called with null http1_connection->protocol_http1, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v694);
              goto LABEL_1299;
            }

            if (v695)
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
              v627 = "%{public}s called with null http1_connection->protocol_http1, no backtrace";
LABEL_1298:
              _os_log_impl(&dword_181A5C000, v625, v626, v627, buf, 0xCu);
            }
          }

          uint64_t v106 = v939;
          if (v117) {
            free(v117);
          }
          uint64_t v25 = v940;
          id v107 = v116;
          uint64_t v115 = (_WORD *)(v110 + 872);
          goto LABEL_476;
        }

        uint64_t v141 = *(void *)(v110 + 592);
        uint64_t v142 = *(void **)(v110 + 600);
        if (v141)
        {
          *(void *)(v141 + 600) = v142;
          uint64_t v142 = *(void **)(v110 + 600);
        }

        else
        {
          *(void *)(v25 + 216) = v142;
        }

        *uint64_t v142 = v141;
        *(void *)(v110 + 592) = 0LL;
        *(void *)(v110 + 600) = 0LL;
        BOOL v182 = *(_DWORD *)(v25 + 340);
        *(_DWORD *)(v25 + 340) = v182 - 1;
        if (v182)
        {
LABEL_470:
          v284 = (unsigned __int16)*v115;
          v285 = (v284 | (*(unsigned __int8 *)(v110 + 874) << 16)) & 0xFFF7FFFF;
          os_log_s *v115 = v284;
          *(_BYTE *)(v110 + 874) = BYTE2(v285);
          if ((*(_BYTE *)(v110 + 158) & 1) == 0)
          {
            if (*((_BYTE *)v107 + 1537))
            {
              v662 = v107;
              v663 = (os_log_s *)__nwlog_obj();
              v664 = os_log_type_enabled(v663, OS_LOG_TYPE_DEBUG);
              id v107 = v662;
              uint64_t v25 = v940;
              if (v664)
              {
                v665 = *(void *)(v110 + 488);
                v666 = *(_DWORD *)(*(void *)(v110 + 480) + 372LL);
                v667 = *(_DWORD *)(v110 + 860);
                if (v665) {
                  LODWORD(v665) = *(_DWORD *)(v665 + 424);
                }
                v668 = *(_DWORD *)(v940 + 340);
                *(_DWORD *)int buf = 136448002;
                *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v110 + 74;
                *(_WORD *)&_BYTE buf[22] = 2080;
                v961 = (uint64_t)" ";
                *(_WORD *)v962 = 1024;
                *(_DWORD *)&v962[2] = v666;
                *(_WORD *)&v962[6] = 1024;
                *(_DWORD *)&v962[8] = v667;
                *(_WORD *)&v962[12] = 1024;
                *(_DWORD *)&v962[14] = v665;
                *(_WORD *)&v962[18] = 2048;
                *(void *)&v962[20] = v110;
                *(_WORD *)&v962[28] = 1024;
                *(_DWORD *)&v962[30] = v668;
                _os_log_impl( &dword_181A5C000,  v663,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed idle connection %p, now have %u idle connections",  buf,  0x42u);
                uint64_t v25 = v940;
                uint64_t v106 = v939;
                id v107 = v662;
              }
            }
          }

          if (*(void *)(v110 + 784))
          {
            if ((*(_BYTE *)(v110 + 158) & 1) == 0)
            {
              if (*((_BYTE *)v107 + 1537))
              {
                v684 = v107;
                v685 = (os_log_s *)__nwlog_obj();
                v686 = os_log_type_enabled(v685, OS_LOG_TYPE_DEBUG);
                id v107 = v684;
                if (v686)
                {
                  v687 = *(void *)(v110 + 488);
                  v688 = *(_DWORD *)(*(void *)(v110 + 480) + 372LL);
                  v689 = *(_DWORD *)(v110 + 860);
                  if (v687) {
                    LODWORD(v687) = *(_DWORD *)(v687 + 424);
                  }
                  *(_DWORD *)int buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v110 + 74;
                  *(_WORD *)&_BYTE buf[22] = 2080;
                  v961 = (uint64_t)" ";
                  *(_WORD *)v962 = 1024;
                  *(_DWORD *)&v962[2] = v688;
                  *(_WORD *)&v962[6] = 1024;
                  *(_DWORD *)&v962[8] = v689;
                  *(_WORD *)&v962[12] = 1024;
                  *(_DWORD *)&v962[14] = v687;
                  *(_WORD *)&v962[18] = 2048;
                  *(void *)&v962[20] = v110;
                  _os_log_impl( &dword_181A5C000,  v685,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> deactivating destroy timer for connection %p",  buf,  0x3Cu);
                  uint64_t v106 = v939;
                  id v107 = v684;
                }
              }
            }

            os_log_type_t v286 = v107;
            nw_queue_cancel_source(*(void *)(v110 + 784), v24);
            id v107 = v286;
            *(void *)(v110 + 784) = 0LL;
            uint64_t v25 = v940;
          }

      uint32_t v250 = v283 + *(_DWORD *)(v68 + 192);
      int v251 = *(_DWORD *)(v68 + 196) + v228 + v311;
      *(_DWORD *)(v68 + 192) = v250;
      *(_DWORD *)(v68 + 196) = v251;
      if (v251 >= 0x80000001)
      {
        *(_DWORD *)(v68 + 192) = (int)(float)((float)((float)v250 * 1000.0) / (float)v251);
        *(_DWORD *)(v68 + 196) = 1000;
        id v252 = *(FILE **)(v68 + 200);
        if (v252)
        {
          fwrite("qenc: debug: ", 0xDuLL, 1uLL, v252);
          int v253 = *(FILE **)(v68 + 200);
          char v254 = *(_DWORD *)(v68 + 192);
          if (v254)
          {
            int v255 = (float)*(unsigned int *)(v68 + 196) / (float)v254;
            if (v253)
            {
              fwrite("qenc: debug: ", 0xDuLL, 1uLL, *(FILE **)(v68 + 200));
              fprintf( *(FILE **)(v68 + 200),  "bytes out: %u; bytes in: %u, ratio: %.3f",
                *(_DWORD *)(v68 + 196),
                *(_DWORD *)(v68 + 192),
                v255);
              fputc(10, *(FILE **)(v68 + 200));
            }
          }

          else
          {
            int v255 = 0.0;
          }

          fprintf(v253, "reset bytes in/out counters, ratio: %.3f", v255);
          fputc(10, *(FILE **)(v68 + 200));
        }
      }

      *(void *)(*(void *)(*v290 + 8LL) + 24LL) += v311;
      *(void *)(*(void *)(*v286 + 8LL) + 24LL) += v228;
      return;
    case 3uLL:
      id v164 = v293;
      *uint64_t v293 = v268;
      if (v292 <= 0) {
        goto LABEL_440;
      }
      if (v82 > 0xE)
      {
        *uint64_t v293 = v264;
        uint64_t v204 = v293 + 1;
        uint64_t v205 = v82 - 15LL;
        os_log_type_t v173 = v291;
        if (v205 >= 0x80)
        {
          while ((unint64_t)v204 < v291)
          {
            *v204++ = v205 | 0x80;
            uint64_t v206 = v205 >> 7;
            uint64_t v207 = v205 >> 14;
            v205 >>= 7;
            if (!v207) {
              goto LABEL_331;
            }
          }

              if (!v83)
              {
LABEL_431:
                int v76 = v272;
                goto LABEL_432;
              }

LABEL_339:
            nw_http_fields_append(v108, (uint64_t)"Prohibit-Interface", (uint64_t)v129);
            free(v129);
LABEL_340:
            _Block_object_dispose(&uu, 8);
            _Block_object_dispose(&v196, 8);
            _Block_object_dispose(__dst, 8);
            return 1LL;
          }

          goto LABEL_308;
        }

        int v134 = 0;
        unint64_t v135 = *(void *)(*((void *)&uu + 1) + 24LL);
        if (v135) {
          goto LABEL_286;
        }
      }

  __break(1u);
  return result;
}

      if (v109) {
        free(v109);
      }
      goto LABEL_223;
    }

    uint64_t v67 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    BOOL v68 = v64;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v69 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)BOOL v177 = 136446722;
      *(void *)&v177[4] = "nw_socket_get_input_frames";
      *(_WORD *)&v177[12] = 2080;
      *(void *)&v177[14] = (char *)a1 + 404;
      *(_WORD *)&v177[22] = 1024;
      *(_DWORD *)&v177[24] = v67;
      _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_ERROR,  "%{public}s %s getsockopt SO_NREAD failed %{darwin.errno}d",  v177,  0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)BOOL v177 = 136446466;
    *(void *)&v177[4] = "nw_socket_get_input_frames";
    *(_WORD *)&v177[12] = 1024;
    *(_DWORD *)&v177[14] = v67;
    nw_endpoint_t v70 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v168.msg_name) = 16;
    LOBYTE(v190) = 0;
    if (__nwlog_fault(v70, &v168, &v190))
    {
      if (LOBYTE(v168.msg_name) == 17)
      {
        uint64_t v71 = (os_log_s *)__nwlog_obj();
        msg_name = (os_log_type_t)v168.msg_name;
        if (os_log_type_enabled(v71, (os_log_type_t)v168.msg_name))
        {
          *(_DWORD *)BOOL v177 = 136446466;
          *(void *)&v177[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v177[12] = 1024;
          *(_DWORD *)&v177[14] = v67;
          __int16 v73 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d";
LABEL_174:
          _os_log_impl(&dword_181A5C000, v71, msg_name, v73, v177, 0x12u);
        }
      }

      else if ((_BYTE)v190)
      {
        uint64_t v79 = (char *)__nw_create_backtrace_string();
        uint64_t v71 = (os_log_s *)__nwlog_obj();
        msg_name = (os_log_type_t)v168.msg_name;
        BOOL v80 = os_log_type_enabled(v71, (os_log_type_t)v168.msg_name);
        if (v79)
        {
          if (v80)
          {
            *(_DWORD *)BOOL v177 = 136446722;
            *(void *)&v177[4] = "nw_socket_get_input_frames";
            *(_WORD *)&v177[12] = 1024;
            *(_DWORD *)&v177[14] = v67;
            *(_WORD *)&v177[18] = 2082;
            *(void *)&v177[20] = v79;
            _os_log_impl( &dword_181A5C000,  v71,  msg_name,  "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, dumping backtrace:%{public}s",  v177,  0x1Cu);
          }

          free(v79);
          goto LABEL_175;
        }

        if (v80)
        {
          *(_DWORD *)BOOL v177 = 136446466;
          *(void *)&v177[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v177[12] = 1024;
          *(_DWORD *)&v177[14] = v67;
          __int16 v73 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, no backtrace";
          goto LABEL_174;
        }
      }

      else
      {
        uint64_t v71 = (os_log_s *)__nwlog_obj();
        msg_name = (os_log_type_t)v168.msg_name;
        if (os_log_type_enabled(v71, (os_log_type_t)v168.msg_name))
        {
          *(_DWORD *)BOOL v177 = 136446466;
          *(void *)&v177[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v177[12] = 1024;
          *(_DWORD *)&v177[14] = v67;
          __int16 v73 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_174;
        }
      }
    }

void sub_18201DFA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

uint64_t ___ZL41nw_masque_options_enumerate_extra_headersP19nw_protocol_optionsU13block_pointerFbPKcS2_E_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 8);
  if (!v4)
  {
    size_t count = 0LL;
    int v6 = *(void **)(a2 + 16);
    if (!v6) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  size_t count = xpc_array_get_count(v4);
  int v6 = *(void **)(a2 + 16);
  if (v6) {
LABEL_3:
  }
    int v6 = (void *)xpc_array_get_count(v6);
LABEL_4:
  if (count && (void *)count == v6)
  {
    size_t v7 = 0LL;
    size_t v8 = count - 1;
    do
    {
      uint64_t v9 = *(void *)(a1 + 32);
      string = xpc_array_get_string(*(xpc_object_t *)(a2 + 8), v7);
      char v11 = xpc_array_get_string(*(xpc_object_t *)(a2 + 16), v7);
      else {
        BOOL v12 = 1;
      }
      ++v7;
    }

    while (!v12);
  }

  return 1LL;
}

__n128 ___ZL38nw_masque_add_extra_headers_to_requestP9nw_masqueP14nw_http_fields_block_invoke_98( uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  size_t length = 0LL;
  data = (__n128 *)xpc_dictionary_get_data(xdict, "data", &length);
  if (!strcmp((const char *)&data[1], *(const char **)(a1 + 32))
    && !strcmp((const char *)&data[3], *(const char **)(a1 + 40)))
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (!v6 || (*(_BYTE *)(v6 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      size_t v7 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *(void *)(a1 + 48);
        BOOL v9 = v8 == 0;
        *(_DWORD *)int buf = 136447234;
        BOOL v14 = "nw_masque_add_extra_headers_to_request_block_invoke";
        if (v8) {
          uint64_t v10 = (const char *)(v8 + 531);
        }
        else {
          uint64_t v10 = "";
        }
        __int16 v15 = 2082;
        int v16 = v10;
        if (v9) {
          char v11 = "";
        }
        else {
          char v11 = " ";
        }
        __int16 v17 = 2080;
        int64_t v18 = v11;
        __int16 v19 = 1042;
        int v20 = 16;
        __int16 v21 = 2098;
        uint64_t v22 = data;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound token agent %{public, uuid_t}.16P",  buf,  0x30u);
      }
    }

    __n128 result = *data;
    *(__n128 *)*(void *)(a1 + 56) = *data;
  }

  return result;
}

uint64_t ___ZL50nw_masque_add_prohibit_interface_header_to_requestP9nw_masqueP14nw_http_fields_block_invoke( uint64_t a1, int a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = a1 + 32;
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v8 = *(void *)(v7 + 24);
    if (v8) {
      *(void *)(v7 + 24) = v8 + 1;
    }
    uint64_t v5 = a1 + 48;
    uint64_t v6 = "cellular";
    goto LABEL_9;
  }

  if (a2 == 1)
  {
    uint64_t v2 = a1 + 32;
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v4 = *(void *)(v3 + 24);
    if (v4) {
      *(void *)(v3 + 24) = v4 + 1;
    }
    uint64_t v5 = a1 + 40;
    uint64_t v6 = "wifi";
LABEL_9:
    *(void *)(*(void *)(*(void *)v5 + 8LL) + 24LL) = v6;
  }

  return 1LL;
}

void nw_masque_add_client_application_header_to_request(void *a1, void *a2)
{
  uint64_t effective_bundle_id = nw_parameters_get_effective_bundle_id(a1);
  if (effective_bundle_id) {
    goto LABEL_5;
  }
  if (nw_utilities_get_self_bundle_id::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_7);
  }
  uint64_t effective_bundle_id = nw_utilities_get_self_bundle_id::bundle_identifier_string;
  if (nw_utilities_get_self_bundle_id::bundle_identifier_string) {
LABEL_5:
  }
    nw_http_fields_append(a2, (uint64_t)"Client-Application", effective_bundle_id);
}

void nw_masque_add_multipath_header_to_request(uint64_t a1, void *a2)
{
  if (nw_parameters_get_multipath(*(void **)(a1 + 320)))
  {
    if (nw_masque_is_multipath_allowed(void)::isAllowed == 1)
    {
      BOOL v4 = nw_endpoint_copy_proxy_original_endpoint(*(void **)(a1 + 312));
      uint64_t v6 = 0LL;
      alternate_int port = nw_endpoint_get_alternate_port((void *)v4);
      asprintf(&v6, "%s;port=%u", "interactive", alternate_port);
      nw_http_fields_append(a2, (uint64_t)"Multipath", (uint64_t)v6);
      if (v6) {
        free(v6);
      }
    }
  }

void nw_masque_add_listener_association_header_to_request(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  __int128 uu = 0uLL;
  BOOL v4 = *(void **)(a1 + 320);
  if (!v4)
  {
    BOOL v4 = *(void **)(a1 + 48);
    if (v4)
    {
      uint64_t v5 = v4[3];
      if (v5 && (uint64_t v6 = *(void (**)(void))(v5 + 112)) != 0LL)
      {
        v6();
        BOOL v4 = *(void **)(a1 + 320);
      }

      else
      {
        BOOL v4 = 0LL;
      }
    }
  }

  nw_parameters_get_listener_uuid(v4, &uu);
  if (!uuid_is_null((const unsigned __int8 *)&uu))
  {
    memset(out, 0, 37);
    uuid_unparse((const unsigned __int8 *)&uu, out);
    nw_http_fields_append(a2, (uint64_t)"Listener-Association", (uint64_t)out);
    if ((*(_BYTE *)(a1 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v7 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        char v8 = *(_DWORD *)(a1 + 527);
        int v10 = 136446978;
        uint64_t v11 = a1 + 531;
        __int16 v12 = 2080;
        uint64_t v13 = " ";
        if ((v8 & 0x10) != 0) {
          BOOL v9 = " (listener)";
        }
        else {
          BOOL v9 = "";
        }
        __int16 v14 = 2080;
        __int16 v15 = out;
        __int16 v16 = 2080;
        __int16 v17 = v9;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s%sadded association uuid %s%s",  (uint8_t *)&v10,  0x2Au);
      }
    }
  }

void ___ZL30nw_masque_is_multipath_allowedv_block_invoke()
{
  id v0 = (void *)nw_utilities_copy_local_entitlement_value("com.apple.developer.networking.multipath_extended");
  if (v0)
  {
    uint64_t v1 = v0;
    if (object_getClass(v0) == (Class)MEMORY[0x1895F9228] && xpc_BOOL_get_value(v1)) {
      nw_masque_is_multipath_allowed(void)::isAllowed = 1;
    }
    xpc_release(v1);
  }

void ___ZL30nw_masque_send_proxied_messageP9nw_masqueP20nw_protocol_metadata_block_invoke( uint64_t a1, uint64_t a2)
{
}

void nw_masque_send_connect(uint64_t a1)
{
  uint64_t v149 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)&buf[0].os_log_type_t sa_len = 136446210;
    *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
    uint64_t v130 = (char *)_os_log_send_and_compose_impl();
    address[0] = 16;
    LOBYTE(v145) = 0;
    if (address[0] == 17)
    {
      unint64_t v131 = (os_log_s *)__nwlog_obj();
      os_log_type_t v132 = address[0];
      if (!os_log_type_enabled(v131, (os_log_type_t)address[0])) {
        goto LABEL_293;
      }
      *(_DWORD *)&buf[0].os_log_type_t sa_len = 136446210;
      *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
      uint64_t v133 = "%{public}s called with null masque";
    }

    else if ((_BYTE)v145)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v131 = (os_log_s *)__nwlog_obj();
      os_log_type_t v132 = address[0];
      BOOL v135 = os_log_type_enabled(v131, (os_log_type_t)address[0]);
      if (backtrace_string)
      {
        if (v135)
        {
          *(_DWORD *)&buf[0].os_log_type_t sa_len = 136446466;
          *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
          *(_WORD *)&buf[0].sa_data[10] = 2082;
          *(void *)&buf[0].sa_data[12] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v131,  v132,  "%{public}s called with null masque, dumping backtrace:%{public}s",  &buf[0].sa_len,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_293;
      }

      if (!v135)
      {
LABEL_293:
        if (v130) {
          free(v130);
        }
        return;
      }

      *(_DWORD *)&buf[0].os_log_type_t sa_len = 136446210;
      *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
      uint64_t v133 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      unint64_t v131 = (os_log_s *)__nwlog_obj();
      os_log_type_t v132 = address[0];
      if (!os_log_type_enabled(v131, (os_log_type_t)address[0])) {
        goto LABEL_293;
      }
      *(_DWORD *)&buf[0].os_log_type_t sa_len = 136446210;
      *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
      uint64_t v133 = "%{public}s called with null masque, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v131, v132, v133, &buf[0].sa_len, 0xCu);
    goto LABEL_293;
  }

  uint64_t v2 = mach_continuous_time();
  if (v2 <= 1) {
    uint64_t v3 = 1LL;
  }
  else {
    uint64_t v3 = v2;
  }
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = v3;
  BOOL v4 = *(void **)(a1 + 344);
  if (!v4) {
    goto LABEL_7;
  }
  *(void *)uint64_t address = 0LL;
  *(void *)&address[8] = address;
  *(void *)&address[16] = 0x2000000000LL;
  size_t v148 = 0LL;
  *(void *)&buf[0].os_log_type_t sa_len = MEMORY[0x1895F87A8];
  *(void *)&buf[0].sa_data[6] = 0x40000000LL;
  *(void *)&buf[1].os_log_type_t sa_len = __nw_masque_options_copy_target_endpoint_block_invoke;
  *(void *)&buf[1].sa_data[6] = &unk_189BBA160;
  *(void *)&buf[2].os_log_type_t sa_len = address;
  nw_protocol_options_access_handle(v4, buf);
  uint64_t v5 = *(void **)(*(void *)&address[8] + 24LL);
  _Block_object_dispose(address, 8);
  if (!v5)
  {
LABEL_7:
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6 && (uint64_t v7 = *(void *)(v6 + 24)) != 0 && (v8 = *(uint64_t (**)(void))(v7 + 136)) != 0LL)
    {
      BOOL v9 = (void *)v8();
      if (!v9) {
        goto LABEL_109;
      }
    }

    else
    {
      BOOL v9 = *(void **)(a1 + 304);
      if (!v9) {
        goto LABEL_109;
      }
    }

    uint64_t v5 = os_retain(v9);
    if (!v5) {
      goto LABEL_109;
    }
  }

  int v10 = *(void **)(a1 + 312);
  if (v10)
  {
    os_release(v10);
    *(void *)(a1 + 312) = 0LL;
  }

  *(void *)(a1 + 312) = nw_endpoint_copy_original_endpoint(v5, 2LL);
  os_release(v5);
  if (nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 312)) == nw_endpoint_type_address)
  {
    uint64_t v11 = nw_endpoint_get_address(*(nw_endpoint_t *)(a1 + 312));
    if (v11->sa_family == 30)
    {
      __int16 v12 = v11;
      int v145 = 0LL;
      int v13 = nw_nat64_copy_prefixes(0LL, &v145);
      if (v13 >= 1)
      {
        uint64_t v14 = 0LL;
        uint64_t v15 = 16LL * v13;
        while (1)
        {
          LODWORD(v144) = 0;
          v14 += 16LL;
          if (v15 == v14) {
            goto LABEL_29;
          }
        }

        *(_WORD *)uint64_t address = 528;
        *(_WORD *)&address[2] = *(_WORD *)v12->sa_data;
        *(_DWORD *)&address[4] = (_DWORD)v144;
        *(void *)&address[8] = 0LL;
        nw_endpoint_t v16 = nw_endpoint_create_address((const sockaddr *)address);
        if ((*(_BYTE *)(a1 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          __int16 v17 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            logging_description = nw_endpoint_get_logging_description(v16);
            __int16 v19 = nw_endpoint_get_logging_description(*(void **)(a1 + 312));
            *(_DWORD *)&buf[0].os_log_type_t sa_len = 136447234;
            *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
            *(void *)&buf[0].sa_data[12] = a1 + 531;
            *(_WORD *)&buf[1].sa_data[4] = 2080;
            *(_WORD *)&buf[0].sa_data[10] = 2082;
            *(void *)&buf[1].sa_data[6] = " ";
            *(_WORD *)&buf[2].os_log_type_t sa_len = 2082;
            *(void *)buf[2].sa_data = logging_description;
            *(_WORD *)&buf[2].sa_data[8] = 2082;
            *(void *)&buf[2].sa_data[10] = v19;
            _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sExtracted address %{public}s from %{public}s",  &buf[0].sa_len,  0x34u);
          }
        }

        uint64_t v20 = *(void **)(a1 + 312);
        if (v20) {
          os_release(v20);
        }
        *(void *)(a1 + 312) = v16;
      }
    }
  }

void sub_1820201C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_123( uint64_t a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!nw_frame_uses_external_data(a2))
  {
    unsigned int v30 = 0;
    uint64_t v15 = (void *)nw_frame_unclaimed_bytes(a2, &v30);
    size_t v16 = *(unsigned int *)(a1 + 72);
    if (v30 < v16 || v15 == 0LL)
    {
      uint64_t v18 = *(void *)(a1 + 32);
      if (v18 && (*(_BYTE *)(v18 + 529) & 1) != 0) {
        goto LABEL_27;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v19 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      uint64_t v20 = *(void *)(a1 + 32);
      __int16 v21 = (const char *)(v20 + 531);
      BOOL v12 = v20 == 0;
      int v22 = " ";
      int v23 = *(_DWORD *)(a1 + 72);
      if (v12)
      {
        __int16 v21 = "";
        int v22 = "";
      }

      *(_DWORD *)int buf = 136446978;
      uint64_t v32 = v21;
      __int16 v33 = 2080;
      unsigned int v34 = v22;
      __int16 v35 = 1024;
      int v36 = v23;
      __int16 v37 = 1024;
      unsigned int v38 = v30;
      uint64_t v14 = (os_log_s *)v19;
      goto LABEL_26;
    }

    memcpy(v15, *(const void **)(a1 + 48), v16);
LABEL_31:
    nw_frame_claim(a2, v27, *(_DWORD *)(a1 + 72), 0);
    nw_frame_collapse(a2);
    nw_frame_unclaim(a2, v28, *(_DWORD *)(a1 + 72), 0);
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0x7F | ((*(_BYTE *)(a1 + 76) != 0) << 7);
    nw_frame_set_metadata(a2, 0LL, 0, *(unsigned __int8 *)(a1 + 77));
    return 1LL;
  }

  unsigned int v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  size_t v5 = *(unsigned int *)(a1 + 72);
  if (v4 >= v5)
  {
    __int16 v26 = dispatch_data_create(*(const void **)(a1 + 48), v5, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A88]);
    nw_frame_will_free_buffer_externally(*(void *)(a1 + 56));
    nw_frame_set_external_data(a2, v26, 0LL);
    if (v26) {
      os_release(v26);
    }
    goto LABEL_31;
  }

  unsigned int v6 = v4;
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7 && (*(_BYTE *)(v7 + 529) & 1) != 0) {
    goto LABEL_27;
  }
  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
  }
  uint64_t v8 = gprivacy_proxyLogObj;
  if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
    goto LABEL_27;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  int v10 = (const char *)(v9 + 531);
  uint64_t v11 = "";
  BOOL v12 = v9 == 0;
  int v13 = *(_DWORD *)(a1 + 72);
  if (v12) {
    int v10 = "";
  }
  *(_DWORD *)int buf = 136446978;
  if (!v12) {
    uint64_t v11 = " ";
  }
  uint64_t v32 = v10;
  __int16 v33 = 2080;
  unsigned int v34 = v11;
  __int16 v35 = 1024;
  int v36 = v13;
  __int16 v37 = 1024;
  unsigned int v38 = v6;
  uint64_t v14 = (os_log_s *)v8;
LABEL_26:
  _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s%sUnable to send %u early bytes, only received %u bytes",  buf,  0x22u);
LABEL_27:
  uint64_t v24 = *(void *)(a2 + 32);
  uint64_t v25 = *(void **)(a2 + 40);
  if (v24)
  {
    *(void *)(v24 + 40) = v25;
    uint64_t v25 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 40) + 8LL) = v25;
  }

  *uint64_t v25 = v24;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

uint64_t __nw_masque_options_copy_target_endpoint_block_invoke(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = os_retain(v3);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
  return 1LL;
}

char *nw_masque_change_base64_to_base64url(char *a1)
{
  uint64_t v1 = a1;
  while (1)
  {
    uint64_t v2 = strchr(a1, 43);
    if (!v2) {
      break;
    }
    char *v2 = 45;
    a1 = v2 + 1;
  }

  while (1)
  {
    __n128 result = strchr(v1, 47);
    if (!result) {
      break;
    }
    *__n128 result = 95;
    uint64_t v1 = result + 1;
  }

  return result;
}

BOOL nw_masque_create_virtual_connection_id_capsule( dispatch_data_s *a1, dispatch_data_s *a2, dispatch_data_s *a3, dispatch_data_s *a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  size_t size = dispatch_data_get_size(a1);
  size_t v7 = size;
  unint64_t __src = 0LL;
  if (size > 0x3F)
  {
    if (size >> 14)
    {
      if (size >> 30)
      {
        if (size >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "_http_vle_encode";
          *(_WORD *)&applier[12] = 2048;
          *(void *)&applier[14] = v7;
          uint64_t v9 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v9);
          if (result) {
            goto LABEL_28;
          }
          free(v9);
          size_t v8 = 0LL;
        }

        else
        {
          unint64_t __src = bswap64(size | 0xC000000000000000LL);
          size_t v8 = 8LL;
        }
      }

      else
      {
        unint64_t __src = bswap32(size | 0x80000000);
        size_t v8 = 4LL;
      }
    }

    else
    {
      unint64_t __src = bswap32(size | 0x4000) >> 16;
      size_t v8 = 2LL;
    }
  }

  else
  {
    unint64_t __src = size;
    size_t v8 = 1LL;
  }

  size_t v11 = dispatch_data_get_size(a2);
  size_t v12 = v11;
  unint64_t v19 = 0LL;
  if (v11 > 0x3F)
  {
    if (!(v11 >> 14))
    {
      unint64_t v19 = bswap32(v11 | 0x4000) >> 16;
      size_t v13 = 2LL;
      goto LABEL_21;
    }

    if (!(v11 >> 30))
    {
      unint64_t v19 = bswap32(v11 | 0x80000000);
      size_t v13 = 4LL;
      goto LABEL_21;
    }

    if (!(v11 >> 62))
    {
      unint64_t v19 = bswap64(v11 | 0xC000000000000000LL);
      size_t v13 = 8LL;
      goto LABEL_21;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446466;
    *(void *)&applier[4] = "_http_vle_encode";
    *(_WORD *)&applier[12] = 2048;
    *(void *)&applier[14] = v12;
    uint64_t v14 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v14);
    if (!result)
    {
      free(v14);
      size_t v13 = 0LL;
      goto LABEL_21;
    }

void nw_protocol_masque_frame_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0LL);
  if (buffer) {
    free(buffer);
  }
  uint64_t v6 = *((void *)a1 + 2);
  size_t v7 = (void *)*((void *)a1 + 3);
  if (v6)
  {
    *(void *)(v6 + 24) = v7;
    size_t v7 = (void *)*((void *)a1 + 3);
  }

  else
  {
    a3[33] = v7;
  }

  *size_t v7 = v6;
  *((void *)a1 + 2) = 0LL;
  *((void *)a1 + 3) = 0LL;
  os_release(a1);
}

uint64_t nw_masque_options_get_version(void *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)int buf = 0LL;
    *(void *)&buf[8] = buf;
    int v13 = 1;
    *(void *)&buf[16] = 0x2000000000LL;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 0x40000000LL;
    v9[2] = __nw_masque_options_get_version_block_invoke;
    v9[3] = &unk_189BBA228;
    void v9[4] = buf;
    nw_protocol_options_access_handle(a1, v9);
    uint64_t v1 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    return v1;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_options_get_version";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_get_version";
        uint64_t v6 = "%{public}s called with null options";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_options_get_version";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v8)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_get_version";
        uint64_t v6 = "%{public}s called with null options, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_get_version";
        uint64_t v6 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_masque_options_get_forced_protocol(nw_protocol_options *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)int buf = 0LL;
    *(void *)&buf[8] = buf;
    int v13 = 0;
    *(void *)&buf[16] = 0x2000000000LL;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 0x40000000LL;
    v9[2] = ___ZL37nw_masque_options_get_forced_protocolP19nw_protocol_options_block_invoke;
    v9[3] = &unk_189BBA480;
    void v9[4] = buf;
    nw_protocol_options_access_handle(a1, v9);
    uint64_t v1 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    return v1;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_options_get_forced_protocol";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_get_forced_protocol";
        uint64_t v6 = "%{public}s called with null options";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_options_get_forced_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v8)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_get_forced_protocol";
        uint64_t v6 = "%{public}s called with null options, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      unsigned int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_get_forced_protocol";
        uint64_t v6 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void ___ZL46nw_masque_enable_spin_bit_for_ft_p2p_if_neededP9nw_masque_block_invoke( void *a1, nw_protocol_options_t options)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    if (!*(void *)(*(void *)(a1[5] + 8LL) + 24LL)
      && (nw_protocol_options_is_quic(options)
       || nw_protocol_options_is_quic_connection(options)
       || nw_protocol_options_is_quic_stream(options)))
    {
      *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = options;
      uint64_t v4 = a1[6];
      if (!v4 || (*(_BYTE *)(v4 + 529) & 1) == 0)
      {
        if (gLogDatapath)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          os_log_type_t v5 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v6 = a1[6];
            BOOL v7 = v6 == 0;
            if (v6) {
              BOOL v8 = (const char *)(v6 + 531);
            }
            else {
              BOOL v8 = "";
            }
            uint64_t v9 = " ";
            if (v7) {
              uint64_t v9 = "";
            }
            uint64_t v10 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
            int v11 = 136446978;
            size_t v12 = "nw_masque_enable_spin_bit_for_ft_p2p_if_needed_block_invoke";
            __int16 v13 = 2082;
            uint64_t v14 = v8;
            __int16 v15 = 2080;
            uint64_t v16 = v9;
            __int16 v17 = 2048;
            uint64_t v18 = v10;
            _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sfound quic as application protocol: %p",  (uint8_t *)&v11,  0x2Au);
          }
        }
      }
    }
  }

  else if (nw_protocol_options_get_protocol_handle(options) == a1[6])
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
  }

uint64_t ___ZL38nw_masque_options_get_allow_connect_ipP19nw_protocol_options_block_invoke( uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a2 + 32);
}

uint64_t ___ZL37nw_masque_options_get_forced_protocolP19nw_protocol_options_block_invoke( uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 28);
  return 1LL;
}

BOOL ___ZL37nw_masque_options_has_target_endpointP19nw_protocol_options_block_invoke(uint64_t a1, void *a2)
{
  return *a2 != 0LL;
}

uint64_t __nw_masque_options_get_version_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 24);
  if (v2) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v2;
  }
  return 1LL;
}

double ___ZL29nw_protocol_masque_identifierv_block_invoke()
{
  unk_18C5940C7 = 0LL;
  unk_18C5940BF = 0LL;
  byte_18C5940D7 = 0;
  unk_18C5940CF = 0LL;
  strcpy((char *)nw_protocol_masque_identifier(void)::g_masque_protocol_identifier, "masque");
  *(void *)&double result = 0x100000005LL;
  qword_18C5940D8 = 0x100000005LL;
  return result;
}

uint64_t ___ZL34nw_protocol_masque_input_availableP11nw_protocolS0__block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v215 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4 || (*(_BYTE *)(v4 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      os_log_type_t v5 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v6 = *(void *)(a1 + 40);
        BOOL v7 = v6 == 0;
        if (v6) {
          BOOL v8 = (const char *)(v6 + 531);
        }
        else {
          BOOL v8 = "";
        }
        uint64_t v9 = " ";
        if (v7) {
          uint64_t v9 = "";
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v8;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v9;
        uint64_t v10 = "%{public}s%sReceived unexpected input frame when not waiting for a response";
LABEL_13:
        _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, v10, buf, 0x16u);
        goto LABEL_242;
      }
    }

    goto LABEL_242;
  }

  int v11 = nw_frame_unclaimed_length(a2);
  if (v11)
  {
    int v12 = v11;
    uint64_t v13 = *(void *)(a1 + 40);
    if (!v13 || (*(_BYTE *)(v13 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v14 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v15 = *(void *)(a1 + 40);
        BOOL v16 = v15 == 0;
        if (v15) {
          __int16 v17 = (const char *)(v15 + 531);
        }
        else {
          __int16 v17 = "";
        }
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = v17;
        uint64_t v18 = " ";
        if (v16) {
          uint64_t v18 = "";
        }
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v18;
        *(_WORD *)&_BYTE buf[22] = 1024;
        LODWORD(v203) = v12;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s%sReceived unexpected input frame of length %u",  buf,  0x1Cu);
      }
    }
  }

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  id v19 = (id)nw_protocol_copy_http_definition_http_definition;
  uint64_t v20 = nw_frame_copy_metadata_for_protocol((uint64_t)a2, (uint64_t)v19);
  if (v19) {
    os_release(v19);
  }
  if (v20)
  {
    if (*(_BYTE *)(a1 + 52))
    {
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21)
      {
        if (nw_protocol_metadata_is_http(v20))
        {
          id v22 = nw_http_metadata_copy_response(v20);
          if (v22)
          {
            id v23 = v22;
            int status_code = _nw_http_response_get_status_code();

            if (!status_code) {
              goto LABEL_240;
            }
            if (status_code == 200)
            {
              id v25 = v23;
              char have_field_with_name = _nw_http_fields_have_field_with_name( (uint64_t)v25,  (unint64_t)"Server-Connection-Id");

              *(void *)size_t v192 = 0LL;
              *(void *)&v192[8] = v192;
              *(void *)&v192[16] = 0x2000000000LL;
              v193[0] = 0;
              *(void *)os_log_type_t type = 0LL;
              uint64_t v160 = (uint64_t)type;
              uint64_t v161 = 0x2000000000LL;
              LOBYTE(v162) = 0;
              *(void *)int buf = MEMORY[0x1895F87A8];
              *(void *)&buf[8] = 0x40000000LL;
              *(void *)&buf[16] = ___ZL40nw_masque_handle_server_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke;
              uint64_t v203 = &unk_189BBA9B0;
              uint64_t v204 = (os_log_type_t *)v192;
              uint64_t v205 = type;
              uint64_t v206 = (os_log_type_t *)v21;
              id v27 = v25;
              uint64_t v28 = buf;
              _nw_http_fields_access_value_by_name((uint64_t)v27, (unint64_t)"Datagram-Flow-Id", v28);

              if ((have_field_with_name & 1) != 0)
              {
                if (*(_BYTE *)(*(void *)&v192[8] + 24LL))
                {
                  int v29 = *(_DWORD *)(v21 + 527);
                  if (*(_BYTE *)(v160 + 24))
                  {
                    if ((v29 & 0x10000) == 0)
                    {
                      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                      }
                      unsigned int v30 = (os_log_s *)gprivacy_proxyLogObj;
                      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
                      {
                        *(_DWORD *)__int16 v211 = 136446466;
                        *(void *)&v211[4] = v21 + 531;
                        *(_WORD *)&v211[12] = 2080;
                        *(void *)&v211[14] = " ";
                        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived 200 OK, forwarding allowed",  v211,  0x16u);
                      }
                    }

                    *(_DWORD *)(v21 + 512) = 4;
                    goto LABEL_143;
                  }

                  if ((v29 & 0x10000) != 0) {
                    goto LABEL_142;
                  }
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  uint64_t v50 = (os_log_s *)gprivacy_proxyLogObj;
                  if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                  {
LABEL_142:
                    nw_masque_mark_failed_with_error(v21, 94);
LABEL_143:
                    _Block_object_dispose(type, 8);
                    os_log_type_t v74 = (os_log_type_t *)v192;
LABEL_239:
                    _Block_object_dispose(v74, 8);
                    goto LABEL_240;
                  }

                  *(_DWORD *)__int16 v211 = 136446466;
                  *(void *)&v211[4] = v21 + 531;
                  *(_WORD *)&v211[12] = 2080;
                  *(void *)&v211[14] = " ";
                  id v51 = "%{public}s%sReceived response without invalid datagram flow ID";
                }

                else
                {
                  if ((*(_BYTE *)(v21 + 529) & 1) != 0) {
                    goto LABEL_142;
                  }
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  uint64_t v50 = (os_log_s *)gprivacy_proxyLogObj;
                  if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_142;
                  }
                  *(_DWORD *)__int16 v211 = 136446466;
                  *(void *)&v211[4] = v21 + 531;
                  *(_WORD *)&v211[12] = 2080;
                  *(void *)&v211[14] = " ";
                  id v51 = "%{public}s%sReceived response without datagram flow ID";
                }
              }

              else
              {
                if ((*(_BYTE *)(v21 + 529) & 1) != 0) {
                  goto LABEL_142;
                }
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                uint64_t v50 = (os_log_s *)gprivacy_proxyLogObj;
                if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_142;
                }
                *(_DWORD *)__int16 v211 = 136446466;
                *(void *)&v211[4] = v21 + 531;
                *(_WORD *)&v211[12] = 2080;
                *(void *)&v211[14] = " ";
                id v51 = "%{public}s%sReceived response without server Connection ID";
              }

              _os_log_impl(&dword_181A5C000, v50, OS_LOG_TYPE_ERROR, v51, v211, 0x16u);
              goto LABEL_142;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v37 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
LABEL_240:
              os_release(v23);
              goto LABEL_241;
            }

            *(_DWORD *)size_t v192 = 136446466;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            *(_WORD *)&v192[12] = 1024;
            *(_DWORD *)&v192[14] = status_code;
            unsigned int v38 = "%{public}s Received response code %u, forwarding not allowed";
            uint64_t v39 = (os_log_s *)v37;
            os_log_type_t v40 = OS_LOG_TYPE_ERROR;
            uint32_t v41 = 18;
LABEL_61:
            _os_log_impl(&dword_181A5C000, v39, v40, v38, v192, v41);
            goto LABEL_240;
          }

          __nwlog_obj();
          *(_DWORD *)size_t v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
          uint64_t v109 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v211[0] = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v110 = (os_log_s *)__nwlog_obj();
            os_log_type_t v111 = type[0];
            if (!os_log_type_enabled(v110, type[0])) {
              goto LABEL_367;
            }
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            size_t v112 = "%{public}s called with null response";
            goto LABEL_366;
          }

          if (!v211[0])
          {
            uint64_t v110 = (os_log_s *)__nwlog_obj();
            os_log_type_t v111 = type[0];
            if (!os_log_type_enabled(v110, type[0])) {
              goto LABEL_367;
            }
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            size_t v112 = "%{public}s called with null response, backtrace limit exceeded";
            goto LABEL_366;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v110 = (os_log_s *)__nwlog_obj();
          os_log_type_t v111 = type[0];
          BOOL v118 = os_log_type_enabled(v110, type[0]);
          if (!backtrace_string)
          {
            if (!v118) {
              goto LABEL_367;
            }
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            size_t v112 = "%{public}s called with null response, no backtrace";
            goto LABEL_366;
          }

          if (v118)
          {
            *(_DWORD *)size_t v192 = 136446466;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            *(_WORD *)&v192[12] = 2082;
            *(void *)&v192[14] = backtrace_string;
            __int16 v117 = "%{public}s called with null response, dumping backtrace:%{public}s";
            goto LABEL_303;
          }

          goto LABEL_304;
        }

        __nwlog_obj();
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
        uint64_t v109 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v211[0] = 0;
        if (type[0] != OS_LOG_TYPE_FAULT)
        {
          if (!v211[0])
          {
            uint64_t v110 = (os_log_s *)__nwlog_obj();
            os_log_type_t v111 = type[0];
            if (!os_log_type_enabled(v110, type[0])) {
              goto LABEL_367;
            }
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            size_t v112 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
            goto LABEL_366;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v110 = (os_log_s *)__nwlog_obj();
          os_log_type_t v111 = type[0];
          BOOL v116 = os_log_type_enabled(v110, type[0]);
          if (!backtrace_string)
          {
            if (!v116) {
              goto LABEL_367;
            }
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            size_t v112 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
            goto LABEL_366;
          }

          if (v116)
          {
            *(_DWORD *)size_t v192 = 136446466;
            *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
            *(_WORD *)&v192[12] = 2082;
            *(void *)&v192[14] = backtrace_string;
            __int16 v117 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s";
LABEL_303:
            _os_log_impl(&dword_181A5C000, v110, v111, v117, v192, 0x16u);
          }

LABEL_304:
          free(backtrace_string);
          if (!v109) {
            goto LABEL_241;
          }
          goto LABEL_368;
        }

        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = type[0];
        if (!os_log_type_enabled(v110, type[0])) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
        size_t v112 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
      }

      else
      {
        __nwlog_obj();
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
        uint64_t v109 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v211[0] = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v110 = (os_log_s *)__nwlog_obj();
          os_log_type_t v111 = type[0];
          if (!os_log_type_enabled(v110, type[0])) {
            goto LABEL_367;
          }
          *(_DWORD *)size_t v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
          size_t v112 = "%{public}s called with null masque";
        }

        else if (v211[0])
        {
          __int16 v113 = (char *)__nw_create_backtrace_string();
          uint64_t v110 = (os_log_s *)__nwlog_obj();
          os_log_type_t v111 = type[0];
          BOOL v114 = os_log_type_enabled(v110, type[0]);
          if (v113)
          {
            if (v114)
            {
              *(_DWORD *)size_t v192 = 136446466;
              *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
              *(_WORD *)&v192[12] = 2082;
              *(void *)&v192[14] = v113;
              _os_log_impl( &dword_181A5C000,  v110,  v111,  "%{public}s called with null masque, dumping backtrace:%{public}s",  v192,  0x16u);
            }

            free(v113);
LABEL_367:
            if (!v109) {
              goto LABEL_241;
            }
LABEL_368:
            free(v109);
            goto LABEL_241;
          }

          if (!v114) {
            goto LABEL_367;
          }
          *(_DWORD *)size_t v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
          size_t v112 = "%{public}s called with null masque, no backtrace";
        }

        else
        {
          uint64_t v110 = (os_log_s *)__nwlog_obj();
          os_log_type_t v111 = type[0];
          if (!os_log_type_enabled(v110, type[0])) {
            goto LABEL_367;
          }
          *(_DWORD *)size_t v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_server_connect_response";
          size_t v112 = "%{public}s called with null masque, backtrace limit exceeded";
        }
      }

        _os_log_impl(&dword_181A5C000, v150, v151, v152, buf, 0xCu);
        goto LABEL_305;
      }

      free(v186);
      goto LABEL_305;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_encoding_get_content_type";
    uint64_t v186 = (char *)_os_log_send_and_compose_impl();
    v227[0] = 16;
    LOBYTE(v224[0]) = 0;
    if (v227[0] == 17)
    {
      char v187 = (os_log_s *)__nwlog_obj();
      uint64_t v188 = v227[0];
      if (!os_log_type_enabled(v187, (os_log_type_t)v227[0])) {
        goto LABEL_303;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_encoding_get_content_type";
      __int16 v189 = "%{public}s called with null http_metadata";
    }

    else
    {
      if (!LOBYTE(v224[0]))
      {
        char v187 = (os_log_s *)__nwlog_obj();
        uint64_t v188 = v227[0];
        if (!os_log_type_enabled(v187, (os_log_type_t)v227[0])) {
          goto LABEL_303;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_encoding_get_content_type";
        __int16 v189 = "%{public}s called with null http_metadata, backtrace limit exceeded";
        goto LABEL_302;
      }

      __int16 v196 = (char *)__nw_create_backtrace_string();
      char v187 = (os_log_s *)__nwlog_obj();
      uint64_t v188 = v227[0];
      __int128 v197 = os_log_type_enabled(v187, (os_log_type_t)v227[0]);
      if (v196)
      {
        if (v197)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_encoding_get_content_type";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v196;
          _os_log_impl( &dword_181A5C000,  v187,  v188,  "%{public}s called with null http_metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v196);
        if (!v186) {
          goto LABEL_305;
        }
        goto LABEL_304;
      }

      if (!v197) {
        goto LABEL_303;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_encoding_get_content_type";
      __int16 v189 = "%{public}s called with null http_metadata, no backtrace";
    }

LABEL_366:
      _os_log_impl(&dword_181A5C000, v110, v111, v112, v192, 0xCu);
      goto LABEL_367;
    }

    uint64_t v36 = *(void *)(a1 + 40);
    if (*(_DWORD *)(a1 + 48) == 3)
    {
      nw_masque_handle_capsule(*(void *)(a1 + 40), v20);
LABEL_241:
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      os_release(v20);
      goto LABEL_242;
    }

    if (!v36)
    {
      __nwlog_obj();
      *(_DWORD *)size_t v192 = 136446210;
      *(void *)&v192[4] = "nw_masque_handle_connect_response";
      uint64_t v109 = (char *)_os_log_send_and_compose_impl();
      v184[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v180) = 0;
      if (v184[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = v184[0];
        if (!os_log_type_enabled(v110, v184[0])) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null masque";
        goto LABEL_366;
      }

      if (!(_BYTE)v180)
      {
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = v184[0];
        if (!os_log_type_enabled(v110, v184[0])) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_366;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v110 = (os_log_s *)__nwlog_obj();
      os_log_type_t v111 = v184[0];
      BOOL v119 = os_log_type_enabled(v110, v184[0]);
      if (!backtrace_string)
      {
        if (!v119) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null masque, no backtrace";
        goto LABEL_366;
      }

      if (v119)
      {
        *(_DWORD *)size_t v192 = 136446466;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        *(_WORD *)&v192[12] = 2082;
        *(void *)&v192[14] = backtrace_string;
        __int16 v117 = "%{public}s called with null masque, dumping backtrace:%{public}s";
        goto LABEL_303;
      }

      goto LABEL_304;
    }

    if (!nw_protocol_metadata_is_http(v20))
    {
      __nwlog_obj();
      *(_DWORD *)size_t v192 = 136446210;
      *(void *)&v192[4] = "nw_masque_handle_connect_response";
      uint64_t v109 = (char *)_os_log_send_and_compose_impl();
      v184[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v180) = 0;
      if (v184[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = v184[0];
        if (!os_log_type_enabled(v110, v184[0])) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
        goto LABEL_366;
      }

      if (!(_BYTE)v180)
      {
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = v184[0];
        if (!os_log_type_enabled(v110, v184[0])) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_366;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v110 = (os_log_s *)__nwlog_obj();
      os_log_type_t v111 = v184[0];
      BOOL v120 = os_log_type_enabled(v110, v184[0]);
      if (!backtrace_string)
      {
        if (!v120) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
        goto LABEL_366;
      }

      if (v120)
      {
        *(_DWORD *)size_t v192 = 136446466;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        *(_WORD *)&v192[12] = 2082;
        *(void *)&v192[14] = backtrace_string;
        __int16 v117 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s";
        goto LABEL_303;
      }

      goto LABEL_304;
    }

    id v42 = nw_http_metadata_copy_response(v20);
    if (!v42)
    {
      __nwlog_obj();
      *(_DWORD *)size_t v192 = 136446210;
      *(void *)&v192[4] = "nw_masque_handle_connect_response";
      uint64_t v109 = (char *)_os_log_send_and_compose_impl();
      v184[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v180) = 0;
      if (v184[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = v184[0];
        if (!os_log_type_enabled(v110, v184[0])) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null response";
        goto LABEL_366;
      }

      if (!(_BYTE)v180)
      {
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        os_log_type_t v111 = v184[0];
        if (!os_log_type_enabled(v110, v184[0])) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null response, backtrace limit exceeded";
        goto LABEL_366;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v110 = (os_log_s *)__nwlog_obj();
      os_log_type_t v111 = v184[0];
      BOOL v121 = os_log_type_enabled(v110, v184[0]);
      if (!backtrace_string)
      {
        if (!v121) {
          goto LABEL_367;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        size_t v112 = "%{public}s called with null response, no backtrace";
        goto LABEL_366;
      }

      if (v121)
      {
        *(_DWORD *)size_t v192 = 136446466;
        *(void *)&v192[4] = "nw_masque_handle_connect_response";
        *(_WORD *)&v192[12] = 2082;
        *(void *)&v192[14] = backtrace_string;
        __int16 v117 = "%{public}s called with null response, dumping backtrace:%{public}s";
        goto LABEL_303;
      }

      goto LABEL_304;
    }

    id v23 = v42;
    int v43 = _nw_http_response_get_status_code();

    if ((v43 - 200) <= 0x63)
    {
      id v44 = (int *)(v36 + 527);
      int v45 = *(_DWORD *)(v36 + 527);
      if ((v45 & 8) != 0)
      {
        uint64_t v46 = MEMORY[0x1895F87A8];
        v190[0] = MEMORY[0x1895F87A8];
        v190[1] = 0x40000000LL;
        v190[2] = ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke;
        v190[3] = &__block_descriptor_tmp_154;
        v190[4] = v36;
        nw_http_fields_access_value_by_name(v23, (unint64_t)"Datagram-Flow-Id", v190);
        if (nw_http_fields_have_field_with_name(v23, (unint64_t)"Client-Connection-Id"))
        {
          int v47 = *v44;
          *v44 |= 0x100080u;
          if ((v47 & 0x10000) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            uint64_t v48 = (os_log_s *)gprivacy_proxyLogObj;
            if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)size_t v192 = 136446466;
              *(void *)&v192[4] = v36 + 531;
              *(_WORD *)&v192[12] = 2080;
              *(void *)&v192[14] = " ";
              _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived acked client CID, server supports forwarding",  v192,  0x16u);
            }
          }
        }

        v189[0] = v46;
        v189[1] = 0x40000000LL;
        v189[2] = ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_155;
        v189[3] = &__block_descriptor_tmp_156;
        v189[4] = v36;
        nw_http_fields_access_value_by_name(v23, (unint64_t)"Proxy-QUIC-Forwarding", v189);
        if (*(_DWORD *)(v36 + 504) == 1)
        {
          int v45 = *v44;
          if (!*(_BYTE *)(v36 + 615))
          {
            if ((v45 & 0x10000) == 0)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              uint64_t v49 = (os_log_s *)gprivacy_proxyLogObj;
              if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)size_t v192 = 136446466;
                *(void *)&v192[4] = v36 + 531;
                *(_WORD *)&v192[12] = 2080;
                *(void *)&v192[14] = " ";
                _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_ERROR,  "%{public}s%sReceived response without datagram flow ID",  v192,  0x16u);
              }
            }

            nw_masque_mark_failed_with_error(v36, 94);
            goto LABEL_240;
          }
        }

        else
        {
          int v45 = *v44;
        }
      }

      if ((v45 & 0x40000) != 0)
      {
        v188[0] = MEMORY[0x1895F87A8];
        v188[1] = 0x40000000LL;
        v188[2] = ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_157;
        v188[3] = &__block_descriptor_tmp_158;
        void v188[4] = v36;
        nw_http_fields_access_value_by_name(v23, (unint64_t)"Capsule-Protocol", v188);
      }

      *(void *)BOOL v184 = 0LL;
      BOOL v185 = v184;
      uint64_t v186 = 0x2000000000LL;
      char v187 = 0;
      uint64_t v180 = 0LL;
      uint64_t v181 = &v180;
      uint64_t v182 = 0x2000000000LL;
      char v183 = 0;
      uint64_t v176 = 0LL;
      BOOL v177 = &v176;
      int v179 = 0;
      uint64_t v178 = 0x2000000000LL;
      uint64_t v172 = 0LL;
      os_log_type_t v173 = &v172;
      uint64_t v174 = 0x2000000000LL;
      uint64_t v175 = 0LL;
      uint64_t v168 = 0LL;
      id v169 = &v168;
      uint64_t v170 = 0x2000000000LL;
      uint64_t v171 = 0LL;
      uint64_t v75 = MEMORY[0x1895F87A8];
      *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
      uint64_t v160 = 0x40000000LL;
      uint64_t v161 = (uint64_t)___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_2;
      int v162 = &unk_189BBAA38;
      os_log_type_t v163 = v184;
      id v164 = &v180;
      BOOL v166 = &v168;
      uint64_t v167 = v36;
      uint64_t v165 = &v172;
      nw_http_fields_access_value_by_name(v23, (unint64_t)"Proxy-Status", type);
      v158[0] = v75;
      v158[1] = 0x40000000LL;
      v158[2] = ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_3;
      v158[3] = &__block_descriptor_tmp_162;
      void v158[4] = v36;
      nw_http_fields_access_value_by_name(v23, (unint64_t)"Client-Geohash", v158);
      *(void *)__int16 v211 = v75;
      *(void *)&v211[8] = 0x40000000LL;
      *(void *)&v211[16] = ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_4;
      nw_endpoint_t v212 = &unk_189BBAA80;
      id v213 = &v176;
      uint64_t v214 = v36;
      nw_http_fields_access_value_by_name(v23, (unint64_t)"Proxy-Config-Epoch", v211);
      int v76 = (_BYTE *)(v36 + 527);
      if (v173[3] && (*(_BYTE *)(v36 + 529) & 1) == 0 && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v130 = (os_log_s *)gprivacy_proxyLogObj;
        int v76 = (_BYTE *)(v36 + 527);
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v131 = v173[3];
          *(_DWORD *)size_t v192 = 136446978;
          *(void *)&v192[4] = "nw_masque_handle_connect_response";
          *(_WORD *)&v192[12] = 2082;
          *(void *)&v192[14] = v36 + 531;
          *(_WORD *)&v192[22] = 2080;
          *(void *)char v193 = " ";
          *(_WORD *)&v193[8] = 2112;
          *(void *)&v193[10] = v131;
          _os_log_impl( &dword_181A5C000,  v130,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived next hop: %@",  v192,  0x2Au);
        }
      }

      if (v169[3] && (v76[2] & 1) == 0 && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        os_log_type_t v132 = (os_log_s *)gprivacy_proxyLogObj;
        int v76 = (_BYTE *)(v36 + 527);
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v133 = v169[3];
          *(_DWORD *)size_t v192 = 136446978;
          *(void *)&v192[4] = "nw_masque_handle_connect_response";
          *(_WORD *)&v192[12] = 2082;
          *(void *)&v192[14] = v36 + 531;
          *(_WORD *)&v192[22] = 2080;
          *(void *)char v193 = " ";
          *(_WORD *)&v193[8] = 2112;
          *(void *)&v193[10] = v133;
          _os_log_impl( &dword_181A5C000,  v132,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived next hop aliases: %@",  v192,  0x2Au);
        }
      }

      uint64_t v77 = *(void **)(v36 + 312);
      if (v77)
      {
        os_log_type_t v78 = (void *)v169[3];
        uint64_t v79 = v173[3];
        if (v78)
        {
          if (v79)
          {
            nw_array_append(v169[3], (void *)v173[3]);
            uint64_t v77 = *(void **)(v36 + 312);
            os_log_type_t v78 = (void *)v169[3];
          }

          nw_endpoint_set_cname_array(v77, v78);
        }

        else if (v79)
        {
          BOOL v84 = nw_array_create();
          nw_array_append(v84, (void *)v173[3]);
          nw_endpoint_set_cname_array(*(void **)(v36 + 312), (void *)v84);
          if (v84) {
            os_release((void *)v84);
          }
        }
      }

      size_t v80 = (void *)v173[3];
      if (v80)
      {
        os_release(v80);
        v173[3] = 0LL;
      }

      unsigned int v81 = (void *)v169[3];
      if (v81)
      {
        os_release(v81);
        v169[3] = 0LL;
      }

      if (!*((_BYTE *)v185 + 24))
      {
LABEL_174:
        if (*((_BYTE *)v181 + 24)) {
          nw_masque_report_error_to_proxy_agent(v36, 1303);
        }
        unsigned int v86 = *((_DWORD *)v177 + 6);
        if (!v86)
        {
LABEL_201:
          if ((*v76 & 2) == 0)
          {
LABEL_209:
            uint64_t v94 = *(void *)(v36 + 288);
            uint64_t v95 = mach_continuous_time();
            if (v95 <= 1) {
              uint64_t v96 = 1LL;
            }
            else {
              uint64_t v96 = v95;
            }
            unint64_t v97 = nw_delta_nanos(v94, v96);
            uint64_t v98 = (v97 / 0xF4240);
            if (v97 > 0xF423FFFFFFFFFLL) {
              uint64_t v98 = 0xFFFFFFFFLL;
            }
            *(void *)(v36 + 296) = v98;
            if ((v76[2] & 1) == 0)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              uint64_t v99 = (os_log_s *)gprivacy_proxyLogObj;
              if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
              {
                logging_description = nw_endpoint_get_logging_description(*(void **)(v36 + 312));
                *(_DWORD *)size_t v192 = 136446722;
                *(void *)&v192[4] = v36 + 531;
                *(_WORD *)&v192[12] = 2080;
                *(void *)&v192[14] = " ";
                *(_WORD *)&v192[22] = 2082;
                *(void *)char v193 = logging_description;
                _os_log_impl( &dword_181A5C000,  v99,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived 200 OK, connected to %{public}s",  v192,  0x20u);
              }
            }

            if (*(_DWORD *)(v36 + 516) && (v76[2] & 1) == 0 && gLogDatapath)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              int v134 = (os_log_s *)gprivacy_proxyLogObj;
              if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v135 = *(_DWORD *)(v36 + 516);
                *(_DWORD *)size_t v192 = 136446978;
                *(void *)&v192[4] = "nw_masque_clear_reverse_proxy_state";
                *(_WORD *)&v192[12] = 2082;
                *(void *)&v192[14] = v36 + 531;
                *(_WORD *)&v192[22] = 2080;
                *(void *)char v193 = " ";
                *(_WORD *)&v193[8] = 1024;
                *(_DWORD *)&v193[10] = v135;
                _os_log_impl( &dword_181A5C000,  v134,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sClearing reverse proxy state from %u",  v192,  0x26u);
              }
            }

            *(_DWORD *)(v36 + 516) = 0;
            uint64_t v101 = *(void *)(v36 + 32);
            if (v101)
            {
              uint64_t v102 = *(void *)(v101 + 24);
              if (v102)
              {
                BOOL v103 = *(void (**)(uint64_t, uint64_t))(v102 + 152);
                if (v103) {
                  v103(v101, v36);
                }
              }
            }

            nw_masque_mark_connected(v36);
            goto LABEL_238;
          }

      if (v202) {
        free(v202);
      }
LABEL_311:
      __int16 v189 = (void *)*((void *)v272 + 5);
      if (!v189)
      {
LABEL_332:
        nw_http3_fail_all_streams(a1, 262LL);
        uint64_t v186 = v279;
        goto LABEL_333;
      }

      while (1)
      {
        id v190 = (void (*)(void *, uint64_t, uint64_t))v189[10];
        char v191 = (void *)v189[4];
        if (!v190) {
          break;
        }
        size_t v192 = v189[11];
        v189[10] = 0LL;
        v189[11] = 0LL;
        v190(v189, 1LL, v192);
LABEL_314:
        __int16 v189 = v191;
        if (!v191) {
          goto LABEL_332;
        }
      }

      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      char v193 = (const char *)_os_log_send_and_compose_impl();
      LOBYTE(error) = 16;
      char v278 = 0;
      char v254 = (char *)v193;
      if (__nwlog_fault(v193, &error, &v278))
      {
        if (error == 17)
        {
          v247 = (os_log_s *)__nwlog_obj();
          logl = error;
          if (!os_log_type_enabled(v247, (os_log_type_t)error)) {
            goto LABEL_330;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          __int16 v194 = v247;
          v195 = logl;
          __int16 v196 = "%{public}s called with null frame->finalizer";
          goto LABEL_329;
        }

        if (!v278)
        {
          os_log_type_t v249 = (os_log_s *)__nwlog_obj();
          logn = error;
          if (!os_log_type_enabled(v249, (os_log_type_t)error)) {
            goto LABEL_330;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          __int16 v194 = v249;
          v195 = logn;
          __int16 v196 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_329;
        }

        nw_endpoint_t v248 = (char *)__nw_create_backtrace_string();
        logm = (os_log_s *)__nwlog_obj();
        char v218 = error;
        __int128 v197 = os_log_type_enabled(logm, (os_log_type_t)error);
        if (v248)
        {
          if (v197)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v248;
            _os_log_impl( &dword_181A5C000,  logm,  v218,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v248);
          goto LABEL_330;
        }

        if (v197)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          __int16 v194 = logm;
          v195 = v218;
          __int16 v196 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_329:
          _os_log_impl(&dword_181A5C000, v194, v195, v196, buf, 0xCu);
        }
      }

    if (v107) {
      free(v107);
    }
    LODWORD(v12) = 0;
LABEL_369:
    LODWORD(v_Block_object_dispose(va, 8) = v105 + v8;
    uint64_t v171 = *(void *)(a1 + 104);
    if ((!v171 || (*(__int16 *)(v171 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_endpoint_t v239 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v240 = *(void *)(a1 + 104);
        uint64_t v241 = "";
        int v242 = v240 == 0;
        id v243 = *(_DWORD *)(v240 + 368);
        int v244 = (const char *)(v240 + 390);
        int v256 = "send_data_callback_block_invoke";
        char v257 = 2082;
        if (v242) {
          int v244 = "";
        }
        *(_DWORD *)int buf = 136447234;
        if (!v242) {
          uint64_t v241 = " ";
        }
        uint64_t v258 = v244;
        v259 = 2080;
        int v260 = (size_t)v241;
        nw_endpoint_t v261 = 1024;
        *(_DWORD *)int v262 = v243;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = v105;
        _os_log_impl( &dword_181A5C000,  v239,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule body",  buf,  0x2Cu);
      }
    }

    goto LABEL_181;
  }

LABEL_374:
            free(v140);
            goto LABEL_397;
          }

          if (!v142) {
            goto LABEL_397;
          }
          *(_DWORD *)size_t v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
          uint64_t v129 = "%{public}s called with null masque->context, no backtrace";
        }

        uint64_t v149 = loga;
        goto LABEL_396;
      }

      int v82 = *(void **)(v36 + 328);
      if (v82)
      {
        else {
          uint64_t v83 = 0LL;
        }
        uint64_t v85 = nw_context_get_globals_for_protocol(v82, v83);
        if (v85)
        {
          *(_DWORD *)(v85 + 7) = 0;
          *(_DWORD *)(v85 + 4) = 0;
          goto LABEL_174;
        }

        __nwlog_obj();
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
        char v122 = (char *)_os_log_send_and_compose_impl();
        v154[0] = OS_LOG_TYPE_ERROR;
        char v191 = 0;
        if (v154[0] == OS_LOG_TYPE_FAULT)
        {
          int v123 = (os_log_s *)__nwlog_obj();
          os_log_type_t v124 = v154[0];
          if (os_log_type_enabled(v123, v154[0]))
          {
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
            uint64_t v125 = "%{public}s called with null globals";
            goto LABEL_381;
          }

          goto LABEL_383;
        }

        if (!v191)
        {
          int v123 = (os_log_s *)__nwlog_obj();
          os_log_type_t v124 = v154[0];
          if (os_log_type_enabled(v123, v154[0]))
          {
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
            uint64_t v125 = "%{public}s called with null globals, backtrace limit exceeded";
            goto LABEL_381;
          }

          goto LABEL_383;
        }

        uint64_t v136 = (char *)__nw_create_backtrace_string();
        uint64_t v144 = (os_log_s *)__nwlog_obj();
        os_log_type_t v124 = v154[0];
        os_log_type_t log = v144;
        BOOL v145 = os_log_type_enabled(v144, v154[0]);
        if (v136)
        {
          if (v145)
          {
            *(_DWORD *)size_t v192 = 136446466;
            *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
            *(_WORD *)&v192[12] = 2082;
            *(void *)&v192[14] = v136;
            unsigned int v139 = "%{public}s called with null globals, dumping backtrace:%{public}s";
            goto LABEL_358;
          }

          goto LABEL_359;
        }

        if (!v145) {
          goto LABEL_383;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
        uint64_t v125 = "%{public}s called with null globals, no backtrace";
      }

      else
      {
        __nwlog_obj();
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
        char v122 = (char *)_os_log_send_and_compose_impl();
        v154[0] = OS_LOG_TYPE_ERROR;
        char v191 = 0;
        if (v154[0] == OS_LOG_TYPE_FAULT)
        {
          int v123 = (os_log_s *)__nwlog_obj();
          os_log_type_t v124 = v154[0];
          if (os_log_type_enabled(v123, v154[0]))
          {
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
            uint64_t v125 = "%{public}s called with null masque->context";
LABEL_381:
            size_t v148 = v123;
LABEL_382:
            _os_log_impl(&dword_181A5C000, v148, v124, v125, v192, 0xCu);
          }

      if (v138) {
        free(v138);
      }
      int v2 = v305;
      goto LABEL_70;
    }

    if (((v29 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        id v237 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v237, OS_LOG_TYPE_DEBUG))
        {
          v238 = *(_DWORD *)(v2 + 1280);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v2 + 1289;
          *(_WORD *)&_BYTE buf[22] = 2080;
          os_log_type_t v309 = " ";
          LOWORD(v310) = 1024;
          *(_DWORD *)((char *)&v310 + 2) = v238;
          _os_log_impl( &dword_181A5C000,  v237,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> stopping control stream",  buf,  0x26u);
        }
      }
    }

    unsigned int v30 = *(void *)(v2 + 1088);
    if (v30)
    {
      if (*(void *)v30)
      {
        uint64_t v31 = *(void (**)(uint64_t, uint64_t))(*(void *)v30 + 8LL);
        if (v31) {
          v31(v30, v2);
        }
      }
    }

    uint64_t v32 = *(void *)(v2 + 32);
    if (v32)
    {
      BOOL v33 = *(void *)(v32 + 24);
      if (v33)
      {
        uint64_t v34 = *(void (**)(uint64_t, uint64_t))(v33 + 240);
        if (v34)
        {
          v34(v32, v2 + 136);
          __int16 v35 = *(void *)(v2 + 32);
          if (!v35) {
            goto LABEL_424;
          }
LABEL_49:
          uint64_t v36 = *(void *)(v35 + 24);
          if (v36)
          {
            uint64_t v37 = *(void (**)(uint64_t, uint64_t))(v36 + 8);
            if (v37)
            {
              v37(v35, v2);
              goto LABEL_52;
            }
          }

    goto LABEL_375;
  }

  *a3 = -1;
  BOOL v7 = v5;
  BOOL v8 = (nw_endpoint *)*(id *)(v7[13] + 160LL);

  required_int address_family = nw_parameters_get_required_address_family(v7);
  if (!v8)
  {
    endpoint = 0LL;
    uint64_t v14 = 0;
    goto LABEL_21;
  }

  uint64_t v10 = nw_endpoint_get_address(v8);
  if ((nw_endpoint_is_multicast(v8) & 1) != 0)
  {
    endpoint = v8;
    int sa_family = v10->sa_family;
    required_int address_family = sa_family;
    if (sa_family != 30)
    {
LABEL_6:
      if (sa_family != 2) {
        goto LABEL_29;
      }
      int v12 = *(_DWORD *)&v10->sa_data[2];
LABEL_8:
      if (v12) {
        uint64_t v13 = endpoint == 0LL;
      }
      else {
        uint64_t v13 = 0;
      }
      if (!v13) {
        goto LABEL_20;
      }
LABEL_13:
      endpoint = 0LL;
      goto LABEL_29;
    }
  }

  else
  {
    endpoint = 0LL;
    int sa_family = v10->sa_family;
    if (sa_family != 30) {
      goto LABEL_6;
    }
  }

  if (!*(_DWORD *)&v10->sa_data[6] && !*(_DWORD *)&v10->sa_data[10] && !*(_DWORD *)&v10[1].sa_len)
  {
    int v12 = *(_DWORD *)&v10[1].sa_data[2];
    goto LABEL_8;
  }

    goto LABEL_375;
  }

  id v51 = v49;
  uint64_t v52 = v51[1];

  if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
  }
  uint64_t v53 = nw_protocol_definition_is_equal_unsafe( (uint64_t)v52,  nw_protocol_copy_http_cookie_definition_http_cookie_definition);

  if (!v53)
  {
    __nwlog_obj();
    unint64_t v158 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_cookie_partition_identifier";
    LODWORD(v389) = 12;
    nw_endpoint_t v388 = buf;
    BOOL v145 = (char *)_os_log_send_and_compose_impl();

    v427 = OS_LOG_TYPE_ERROR;
    v426 = 0;
    if (v427 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v146 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v159 = v427;
      if (os_log_type_enabled(v146, v427))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_cookie_partition_identifier";
        _os_log_impl(&dword_181A5C000, v146, v159, "%{public}s protocol options are not http_cookie", buf, 0xCu);
      }
    }

    else if (v426)
    {
      char v191 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v146 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v192 = v427;
      char v193 = os_log_type_enabled(v146, v427);
      if (v191)
      {
        if (v193)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_cookie_partition_identifier";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v191;
          _os_log_impl( &dword_181A5C000,  v146,  v192,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v191);
        if (!v145) {
          goto LABEL_46;
        }
        goto LABEL_376;
      }

      if (v193)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_cookie_partition_identifier";
        _os_log_impl( &dword_181A5C000,  v146,  v192,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v146 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v231 = v427;
      if (os_log_type_enabled(v146, v427))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_cookie_partition_identifier";
        _os_log_impl( &dword_181A5C000,  v146,  v231,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_374;
  }

  *(void *)int buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = v2;
  *(void *)&buf[16] = __nw_http_cookie_options_set_cookie_partition_identifier_block_invoke;
  *(void *)&nw_endpoint_t v434 = &__block_descriptor_40_e9_B16__0_v8l;
  *((void *)&v434 + 1) = v48;
  nw_protocol_options_access_handle(v51, buf);
LABEL_46:

LABEL_47:
LABEL_48:
  id v54 = *(void *)(a1 + 40);
  if (!v54) {
    goto LABEL_73;
  }
  if ([*(id *)(v54 + 32) _allowOnlyPartitionedCookies])
  {
    unsigned int v55 = v35;
    unsigned int v56 = v55;
    if (v55)
    {
      unsigned int v57 = v55;
      uint64_t v58 = v57[1];

      if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
      }
      BOOL v59 = nw_protocol_definition_is_equal_unsafe( (uint64_t)v58,  nw_protocol_copy_http_cookie_definition_http_cookie_definition);

      if (v59)
      {
        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = v2;
        *(void *)&buf[16] = __nw_http_cookie_options_set_allow_only_partitioned_cookies_block_invoke;
        *(void *)&nw_endpoint_t v434 = &__block_descriptor_33_e9_B16__0_v8l;
        BYTE8(v434) = 1;
        nw_protocol_options_access_handle(v57, buf);
LABEL_55:

        goto LABEL_56;
      }

      __nwlog_obj();
      uint64_t v172 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
      LODWORD(v389) = 12;
      nw_endpoint_t v388 = buf;
      uint64_t v165 = (char *)_os_log_send_and_compose_impl();

      v427 = OS_LOG_TYPE_ERROR;
      v426 = 0;
      if (v427 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v173 = v427;
        if (os_log_type_enabled(v166, v427))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
          _os_log_impl(&dword_181A5C000, v166, v173, "%{public}s protocol options are not http_cookie", buf, 0xCu);
        }
      }

      else if (v426)
      {
        uint64_t v214 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v215 = v427;
        id v216 = os_log_type_enabled(v166, v427);
        if (v214)
        {
          if (v216)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v214;
            _os_log_impl( &dword_181A5C000,  v166,  v215,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v214);
          if (!v165) {
            goto LABEL_55;
          }
          goto LABEL_397;
        }

        if (v216)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
          _os_log_impl( &dword_181A5C000,  v166,  v215,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v236 = v427;
        if (os_log_type_enabled(v166, v427))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
          _os_log_impl( &dword_181A5C000,  v166,  v236,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      id v164 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
      LODWORD(v389) = 12;
      nw_endpoint_t v388 = buf;
      uint64_t v165 = (char *)_os_log_send_and_compose_impl();

      v427 = OS_LOG_TYPE_ERROR;
      v426 = 0;
      if (v427 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v167 = v427;
        if (os_log_type_enabled(v166, v427))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
          _os_log_impl(&dword_181A5C000, v166, v167, "%{public}s called with null options", buf, 0xCu);
        }
      }

      else if (v426)
      {
        uint64_t v206 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v207 = v427;
        int v208 = os_log_type_enabled(v166, v427);
        if (v206)
        {
          if (v208)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v206;
            _os_log_impl( &dword_181A5C000,  v166,  v207,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v206);
LABEL_396:
          if (!v165) {
            goto LABEL_55;
          }
LABEL_397:
          free(v165);
          goto LABEL_55;
        }

        if (v208)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
          _os_log_impl(&dword_181A5C000, v166, v207, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v234 = v427;
        if (os_log_type_enabled(v166, v427))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_allow_only_partitioned_cookies";
          _os_log_impl( &dword_181A5C000,  v166,  v234,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_396;
  }

    if (v224) {
      free(v224);
    }
    int v43 = 0LL;
    goto LABEL_42;
  }

  if (nw_protocol_definition_is_proxy(v8))
  {
    if (a2 && *(_BYTE *)(a1 + 136) && !*(_BYTE *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL))
    {
      id v22 = nw_endpoint_flow_add_one_protocol( *(void **)(a1 + 32),  *(__int128 **)(a1 + 120),  0LL,  0LL,  *(void **)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL),  *(void **)(a1 + 40),  *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL));
      if (!v22)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unsigned int v81 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
        {
          int v82 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          uint64_t v83 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          BOOL v84 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          uint64_t v85 = nw_endpoint_get_logging_description(v84);
          unsigned int v86 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          BOOL v87 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          int v88 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          int v89 = *(char **)(a1 + 120);
          *(_DWORD *)int buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
          v300 = 2082;
          v301 = (uint64_t)v82;
          id v302 = 2082;
          char v303 = v83;
          v304 = 2082;
          uint64_t v305 = (void *)v85;
          int v306 = 2082;
          v307 = v86;
          uint64_t v308 = 2082;
          os_log_type_t v309 = v87;
          v310 = 2114;
          int v311 = v88;
          uint32_t v312 = 2082;
          os_log_type_t v313 = v89;
          _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach filter pro tocol %{public}s",  buf,  0x52u);
        }

LABEL_191:
        uint64_t v9 = v293;
        goto LABEL_192;
      }

      *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = v22;
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v23 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v24 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          id v25 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          v289 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          __int16 v26 = nw_endpoint_get_logging_description(v289);
          id v27 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          uint64_t v28 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          int v29 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          unsigned int v30 = *(char **)(a1 + 120);
          *(_DWORD *)int buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
          v300 = 2082;
          v301 = (uint64_t)v24;
          id v302 = 2082;
          char v303 = v25;
          v304 = 2082;
          uint64_t v305 = (void *)v26;
          int v306 = 2082;
          v307 = v27;
          uint64_t v308 = 2082;
          os_log_type_t v309 = v28;
          v310 = 2114;
          int v311 = v29;
          uint32_t v312 = 2082;
          os_log_type_t v313 = v30;
          _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached filter protocol: %{public}s",  buf,  0x52u);
        }

        uint64_t v9 = v293;
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL) = 1;
    }

    else {
      uint64_t v31 = nw_endpoint_copy_without_proxy_parent(*(void **)(a1 + 48));
    }
    __int16 v35 = *(void *)(*(void *)(a1 + 88) + 8LL);
    uint64_t v36 = *(void **)(v35 + 40);
    *(void *)(v35 + 40) = v31;

    uint64_t v37 = nw_endpoint_handler_copy_context(*(void **)(a1 + 32));
    unsigned int v38 = *(void **)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL);
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 24LL)) {
      uint64_t v39 = 1;
    }
    else {
      uint64_t v39 = nw_parameters_get_use_enhanced_privacy_mode(*(void **)(a1 + 40)) ^ 1;
    }
    id v44 = nw_context_copy_registered_endpoint_internal(v37, v38, v39);
    int v45 = *(void *)(*(void *)(a1 + 88) + 8LL);
    uint64_t v46 = *(void **)(v45 + 40);
    *(void *)(v45 + 40) = v44;

    *(_BYTE *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 24LL) = 1;
    *(_BYTE *)(*(void *)(a1 + 56) + 35LL) |= 0x20u;

    BOOL v8 = v294;
  }

  identifier = nw_protocol_definition_get_identifier(v8);
  registered_endpoint = *(void *)(a1 + 128);
  uint64_t v49 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 24LL);
  id v51 = *(void **)(a1 + 40);
  uint64_t v50 = *(void **)(a1 + 48);
  uint64_t v52 = *(void **)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL);
  uint64_t v53 = *(id *)(a1 + 32);
  nw_endpoint_t v287 = v50;
  os_log_type_t v286 = v52;
  uint64_t v290 = v51;
  v285 = v53;
  if (!v53)
  {
    __nwlog_obj();
    nw_endpoint_t v232 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    uint64_t v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    nw_endpoint_t v298 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v234 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v233, v234, "%{public}s called with null handler", buf, 0xCu);
      }

      goto LABEL_399;
    }

    if (v298 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      uint64_t v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v266 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl( &dword_181A5C000,  v233,  v266,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_399;
    }

    v247 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    nw_endpoint_t v248 = type[0];
    os_log_type_t v249 = os_log_type_enabled(v72, type[0]);
    if (!v247)
    {
      if (v249)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v72, v248, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (v249)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v300 = 2082;
      v301 = (uint64_t)v247;
      _os_log_impl( &dword_181A5C000,  v72,  v248,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_369;
  }

  id v54 = (unsigned int *)v53;
  unsigned int v55 = v54[29];

  if ((_DWORD)v55 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v64 = (id)gLogObj;
    else {
      uint64_t v65 = off_189BBBBC0[v55];
    }
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v300 = 2082;
    v301 = (uint64_t)v65;
    id v302 = 2082;
    char v303 = "flow";
    uint64_t v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    nw_endpoint_t v298 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v71, type, &v298))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v73 = type[0];
        if (os_log_type_enabled(v72, type[0]))
        {
          else {
            os_log_type_t v74 = off_189BBBBC0[v55];
          }
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v300 = 2082;
          v301 = (uint64_t)v74;
          id v302 = 2082;
          char v303 = "flow";
          _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }

        goto LABEL_118;
      }

      if (v298 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v79 = type[0];
        if (os_log_type_enabled(v72, type[0]))
        {
          else {
            size_t v80 = off_189BBBBC0[v55];
          }
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v300 = 2082;
          v301 = (uint64_t)v80;
          id v302 = 2082;
          char v303 = "flow";
          _os_log_impl( &dword_181A5C000,  v72,  v79,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }

        goto LABEL_118;
      }

      uint64_t v75 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v76 = type[0];
      uint64_t v77 = os_log_type_enabled(v72, type[0]);
      if (!v75)
      {
        if (v77)
        {
          else {
            dispatch_data_t v90 = off_189BBBBC0[v55];
          }
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v300 = 2082;
          v301 = (uint64_t)v90;
          id v302 = 2082;
          char v303 = "flow";
          _os_log_impl( &dword_181A5C000,  v72,  v76,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }

        goto LABEL_118;
      }

      if (v77)
      {
        else {
          os_log_type_t v78 = off_189BBBBC0[v55];
        }
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        v300 = 2082;
        v301 = (uint64_t)v78;
        id v302 = 2082;
        char v303 = "flow";
        v304 = 2082;
        uint64_t v305 = v75;
        _os_log_impl( &dword_181A5C000,  v72,  v76,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v75);
    }

LABEL_383:
          if (v122) {
            free(v122);
          }
          int v76 = (_BYTE *)(v36 + 527);
          goto LABEL_174;
        }

        if (!v191)
        {
          int v123 = (os_log_s *)__nwlog_obj();
          os_log_type_t v124 = v154[0];
          if (os_log_type_enabled(v123, v154[0]))
          {
            *(_DWORD *)size_t v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
            uint64_t v125 = "%{public}s called with null masque->context, backtrace limit exceeded";
            goto LABEL_381;
          }

          goto LABEL_383;
        }

        uint64_t v136 = (char *)__nw_create_backtrace_string();
        uint64_t v137 = (os_log_s *)__nwlog_obj();
        os_log_type_t v124 = v154[0];
        os_log_type_t log = v137;
        BOOL v138 = os_log_type_enabled(v137, v154[0]);
        if (v136)
        {
          if (v138)
          {
            *(_DWORD *)size_t v192 = 136446466;
            *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
            *(_WORD *)&v192[12] = 2082;
            *(void *)&v192[14] = v136;
            unsigned int v139 = "%{public}s called with null masque->context, dumping backtrace:%{public}s";
LABEL_358:
            _os_log_impl(&dword_181A5C000, log, v124, v139, v192, 0x16u);
          }

                        _os_log_impl(&dword_181A5C000, v241, v242, v243, v535, 0xCu);
                        goto LABEL_384;
                      }

                      __nwlog_obj();
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      nw_endpoint_t v232 = (char *)_os_log_send_and_compose_impl();
                      type[0] = OS_LOG_TYPE_ERROR;
                      v535[0] = 0;
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        uint64_t v233 = (os_log_s *)__nwlog_obj();
                        uint64_t v234 = type[0];
                        if (os_log_type_enabled(v233, type[0]))
                        {
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                          v235 = v233;
                          id v236 = v234;
                          id v237 = "%{public}s called with null parameters";
                          goto LABEL_367;
                        }

                        goto LABEL_368;
                      }

                      if (v535[0])
                      {
                        nw_endpoint_t v248 = (char *)__nw_create_backtrace_string();
                        os_log_type_t v249 = (os_log_s *)__nwlog_obj();
                        uint32_t v250 = type[0];
                        int v251 = os_log_type_enabled(v249, type[0]);
                        if (v248)
                        {
                          if (v251)
                          {
                            *(_DWORD *)int buf = 136446466;
                            *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&buf[14] = v248;
                            _os_log_impl( &dword_181A5C000,  v249,  v250,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                          }

                          free(v248);
                          goto LABEL_368;
                        }

                        if (!v251)
                        {
LABEL_368:
                          if (v232) {
                            free(v232);
                          }
                          int v64 = v520;
                          BOOL v121 = v517;
                          goto LABEL_371;
                        }

                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v235 = v249;
                        id v236 = v250;
                        id v237 = "%{public}s called with null parameters, no backtrace";
                      }

                      else
                      {
                        int v260 = (os_log_s *)__nwlog_obj();
                        nw_endpoint_t v261 = type[0];
                        if (!os_log_type_enabled(v260, type[0])) {
                          goto LABEL_368;
                        }
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v235 = v260;
                        id v236 = v261;
                        id v237 = "%{public}s called with null parameters, backtrace limit exceeded";
                      }

        if ((*(_BYTE *)(v12 + 158) & 1) == 0)
        {
          if (gLogDatapath)
          {
            id v226 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v226, OS_LOG_TYPE_DEBUG))
            {
              int v227 = *(void *)(v12 + 488);
              char v228 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
              uint64_t v229 = *(_DWORD *)(v12 + 860);
              if (v227) {
                LODWORD(v227) = *(_DWORD *)(v227 + 424);
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_http1_parser_signal_eof_if_needed";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 74;
              *(_WORD *)&_BYTE buf[22] = 2080;
              *(void *)&_BYTE buf[24] = " ";
              *(_WORD *)&_BYTE buf[32] = 1024;
              *(_DWORD *)&buf[34] = v228;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&uint8_t buf[40] = v229;
              LOWORD(v265) = 1024;
              *(_DWORD *)((char *)&v265 + 2) = v227;
              _os_log_impl( &dword_181A5C000,  v226,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> signaled eof and terminated message successfully",  buf,  0x32u);
              uint64_t v13 = (unsigned __int16 *)(v12 + 872);
            }
          }
        }

        *((_BYTE *)v13 + 2) = (*v13 | (*((unsigned __int8 *)v13 + 2) << 16) | 0x10000u) >> 16;
        goto LABEL_134;
      }

      char v122 = llhttp_finish(v12 + 200);
      if ((*v259 & 4) != 0) {
        goto LABEL_383;
      }
      __int16 v117 = v122;
      if (!v122) {
        goto LABEL_383;
      }
      if (v122 != 14) {
        goto LABEL_208;
      }
      int v123 = *(void *)(v12 + 488);
      if (v123)
      {
        __int16 v117 = 14;
        if ((*v259 & 1) != 0
          && (*(_WORD *)(v123 + 428) & 1) == 0
          && !*(_DWORD *)(v12 + 848)
          && !*(_DWORD *)(v12 + 852)
          && !*(_DWORD *)(v12 + 856))
        {
          if ((*v259 & 2) != 0 && *(void *)(v12 + 800))
          {
            if (!*(void *)(v12 + 808))
            {
              int v208 = strdup("");
              if (!v208)
              {
                int v256 = (os_log_s *)__nwlog_obj();
                os_log_type_enabled(v256, OS_LOG_TYPE_ERROR);
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "strict_strdup";
                char v257 = (void *)_os_log_send_and_compose_impl();
                if (__nwlog_abort((uint64_t)v257))
                {
                  __break(1u);
                  return;
                }

                free(v257);
              }

              *(void *)(v12 + 80_Block_object_dispose(va, 8) = v208;
            }

            nw_http1_on_header_value_complete(v12 + 200);
          }

          nw_http1_on_headers_complete(v12 + 200);
          nw_http1_on_message_complete(v12 + 200);
          uint64_t v13 = (unsigned __int16 *)(v12 + 872);
          goto LABEL_383;
        }

            if (v147) {
              free(v147);
            }
            int v2 = v305;
            goto LABEL_76;
          }
        }
      }

      __nwlog_obj();
      int v135 = *(void *)(*(void *)(v305 + 1048) + 32LL);
      uint64_t v136 = "invalid";
      if (v135)
      {
        uint64_t v137 = *(const char **)(v135 + 16);
        if (v137) {
          uint64_t v136 = v137;
        }
      }

      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v136;
      BOOL v138 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v306 = 0;
      if (__nwlog_fault(v138, &type, &v306))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          unsigned int v139 = (os_log_s *)__nwlog_obj();
          unint64_t v140 = type;
          if (os_log_type_enabled(v139, type))
          {
            uint64_t v141 = *(void *)(*(void *)(v305 + 1048) + 32LL);
            BOOL v142 = "invalid";
            if (v141)
            {
              id v143 = *(const char **)(v141 + 16);
              if (v143) {
                BOOL v142 = v143;
              }
            }

            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v142;
            _os_log_impl( &dword_181A5C000,  v139,  v140,  "%{public}s protocol %{public}s has invalid remove_input_handler callback",  buf,  0x16u);
          }

          goto LABEL_374;
        }

        if (v306)
        {
          char v199 = (char *)__nw_create_backtrace_string();
          __int16 v200 = (os_log_s *)__nwlog_obj();
          char v201 = type;
          char v202 = os_log_type_enabled(v200, type);
          if (v199)
          {
            if (v202)
            {
              uint64_t v203 = *(void *)(*(void *)(v305 + 1048) + 32LL);
              uint64_t v204 = "invalid";
              if (v203)
              {
                uint64_t v205 = *(const char **)(v203 + 16);
                if (v205) {
                  uint64_t v204 = v205;
                }
              }

              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v204;
              *(_WORD *)&_BYTE buf[22] = 2082;
              os_log_type_t v309 = v199;
              _os_log_impl( &dword_181A5C000,  v200,  v201,  "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x20u);
              uint64_t v39 = (void *)&unk_182665000;
            }

            free(v199);
            goto LABEL_374;
          }

          if (v202)
          {
            uint64_t v258 = *(void *)(*(void *)(v305 + 1048) + 32LL);
            v259 = "invalid";
            if (v258)
            {
              int v260 = *(const char **)(v258 + 16);
              if (v260) {
                v259 = v260;
              }
            }

            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v259;
            int v242 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_373:
            _os_log_impl(&dword_181A5C000, v200, v201, v242, buf, 0x16u);
            uint64_t v39 = (void *)&unk_182665000;
          }
        }

        else
        {
          __int16 v200 = (os_log_s *)__nwlog_obj();
          char v201 = type;
          if (os_log_type_enabled(v200, type))
          {
            nw_endpoint_t v239 = *(void *)(*(void *)(v305 + 1048) + 32LL);
            int v240 = "invalid";
            if (v239)
            {
              uint64_t v241 = *(const char **)(v239 + 16);
              if (v241) {
                int v240 = v241;
              }
            }

            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v240;
            int v242 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
            goto LABEL_373;
          }
        }
      }

LABEL_359:
          free(v136);
          goto LABEL_383;
        }

        if (!v138) {
          goto LABEL_383;
        }
        *(_DWORD *)size_t v192 = 136446210;
        *(void *)&v192[4] = "nw_masque_clear_cached_geohash_value";
        uint64_t v125 = "%{public}s called with null masque->context, no backtrace";
      }

      size_t v148 = log;
      goto LABEL_382;
    }

    if (!v43)
    {
      if ((*(_BYTE *)(v36 + 529) & 1) != 0) {
        goto LABEL_240;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v71 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_240;
      }
      *(_DWORD *)size_t v192 = 136446722;
      *(void *)&v192[4] = "nw_masque_handle_connect_response";
      *(_WORD *)&v192[12] = 2082;
      *(void *)&v192[14] = v36 + 531;
      *(_WORD *)&v192[22] = 2080;
      *(void *)char v193 = " ";
      unsigned int v38 = "%{public}s %{public}s%sReceived no response code, ignoring";
      uint64_t v39 = (os_log_s *)v71;
      os_log_type_t v40 = OS_LOG_TYPE_DEBUG;
      uint32_t v41 = 32;
      goto LABEL_61;
    }

    *(void *)BOOL v184 = 0LL;
    BOOL v185 = v184;
    uint64_t v186 = 0x2000000000LL;
    char v187 = 0;
    uint64_t v180 = 0LL;
    uint64_t v181 = &v180;
    uint64_t v182 = 0x2000000000LL;
    char v183 = 0;
    uint64_t v176 = 0LL;
    BOOL v177 = &v176;
    uint64_t v178 = 0x2000000000LL;
    LOBYTE(v179) = 0;
    uint64_t v172 = 0LL;
    os_log_type_t v173 = &v172;
    uint64_t v174 = 0x2000000000LL;
    LOBYTE(v175) = 0;
    uint64_t v168 = 0LL;
    id v169 = &v168;
    uint64_t v170 = 0x2000000000LL;
    LOBYTE(v171) = 0;
    *(void *)uint64_t v154 = 0LL;
    unint64_t v155 = v154;
    int v157 = 0;
    uint64_t v52 = MEMORY[0x1895F87A8];
    uint64_t v156 = 0x2000000000LL;
    *(void *)int buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_164;
    uint64_t v203 = &unk_189BBAAA8;
    uint64_t v204 = v184;
    uint64_t v205 = (os_log_type_t *)&v172;
    uint64_t v210 = v36;
    uint64_t v206 = v154;
    uint64_t v207 = &v180;
    int v208 = &v168;
    char v209 = &v176;
    nw_http_fields_access_value_by_name(v23, (unint64_t)"Proxy-Status", buf);
    if (*((_BYTE *)v185 + 24)) {
      nw_masque_report_error_to_proxy_agent(v36, 1303);
    }
    if ((*(_BYTE *)(v36 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v53 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        id v54 = nw_endpoint_get_logging_description(*(void **)(v36 + 312));
        unsigned int v55 = "";
        if (*((_BYTE *)v169 + 24)) {
          unsigned int v56 = ", attempt to reverse proxy with certificates";
        }
        else {
          unsigned int v56 = "";
        }
        if (*((_BYTE *)v181 + 24)) {
          unsigned int v57 = ", unreachable through proxy";
        }
        else {
          unsigned int v57 = "";
        }
        if (*((_BYTE *)v177 + 24)) {
          uint64_t v58 = ", origin server failed";
        }
        else {
          uint64_t v58 = "";
        }
        if (*((_BYTE *)v173 + 24)) {
          BOOL v59 = ", has received status";
        }
        else {
          BOOL v59 = "";
        }
        int v60 = *((_DWORD *)v155 + 6);
        *(_DWORD *)size_t v192 = 136448258;
        if (v60) {
          unsigned int v55 = ", has dns failure reason";
        }
        *(void *)&v192[4] = v36 + 531;
        uint64_t v52 = MEMORY[0x1895F87A8];
        *(_WORD *)&v192[12] = 2080;
        *(void *)&v192[14] = " ";
        *(_WORD *)&v192[22] = 1024;
        *(_DWORD *)char v193 = v43;
        *(_WORD *)&v193[4] = 2082;
        *(void *)&v193[6] = v54;
        *(_WORD *)&v193[14] = 2082;
        *(void *)&v193[16] = v56;
        __int16 v194 = 2082;
        v195 = v57;
        __int16 v196 = 2082;
        __int128 v197 = v58;
        __int16 v198 = 2082;
        char v199 = v59;
        __int16 v200 = 2082;
        char v201 = v55;
        _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_ERROR,  "%{public}s%sReceived response code %u for %{public}s%{public}s%{public}s%{public}s%{public}s%{public}s",  v192,  0x58u);
      }
    }

    int v61 = *((_DWORD *)v155 + 6);
    if (v61)
    {
      uint64_t v62 = *(void **)(v36 + 312);
      if (v62)
      {
        uint64_t v63 = v62;
        v63[56] = v61;
      }
    }

    int v64 = (_DWORD *)(v36 + 527);
    if ((v43 - 400) <= 0x63 && *((_BYTE *)v169 + 24))
    {
      if (!nw_http_connection_metadata_get_secondary_certificate_count(*(void **)(v36 + 456))
        || (nw_masque_setup_reverse_proxy(v36) & 1) == 0)
      {
        if ((*(_BYTE *)(v36 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          char v66 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)size_t v192 = 136446466;
            *(void *)&v192[4] = v36 + 531;
            *(_WORD *)&v192[12] = 2080;
            *(void *)&v192[14] = " ";
            _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_INFO,  "%{public}s%sCONNECT response indicates that secondary certificates will be sent, waiting",  v192,  0x16u);
          }
        }

        *(_DWORD *)(v36 + 516) = 1;
        uint64_t v67 = *(void *)(v36 + 352);
        if (v67) {
          nw_queue_cancel_source(v67, v65);
        }
        v152[0] = v52;
        v152[1] = 0x40000000LL;
        v152[2] = ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_180;
        v152[3] = &__block_descriptor_tmp_181;
        v152[4] = v36;
        __int16 v153 = v43;
        BOOL source = nw_queue_context_create_source(0LL, 2, 3, 0, v152, 0LL);
        *(void *)(v36 + 352) = source;
        dispatch_time_t v69 = dispatch_time(0x8000000000000000LL, 10000000000LL);
        nw_queue_set_timer_values(source, v69, 0xFFFFFFFFFFFFFFFFLL, 0x989680uLL);
        nw_queue_activate_source(*(void *)(v36 + 352), v70);
      }

      goto LABEL_237;
    }

    if ((v43 - 500) > 0x63)
    {
      if (v43 == 401)
      {
        if (!*((_BYTE *)v173 + 24) && !uuid_is_null((const unsigned __int8 *)(v36 + 272)))
        {
          int v89 = *(void **)(v36 + 456);
          if (v89) {
            nw_http_connection_metadata_mark_cached_token_failed(v89);
          }
          nw_path_report_error_to_agent(*(void **)(v36 + 336), (const unsigned __int8 *)(v36 + 272), 80);
          goto LABEL_235;
        }

        goto LABEL_230;
      }
    }

    else
    {
      if (*((_BYTE *)v181 + 24))
      {
        uint64_t v72 = v36;
        int v73 = 65;
LABEL_236:
        nw_masque_mark_failed_with_error(v72, v73);
LABEL_237:
        _Block_object_dispose(v154, 8);
LABEL_238:
        _Block_object_dispose(&v168, 8);
        _Block_object_dispose(&v172, 8);
        _Block_object_dispose(&v176, 8);
        _Block_object_dispose(&v180, 8);
        os_log_type_t v74 = v184;
        goto LABEL_239;
      }

      if (*((_BYTE *)v177 + 24))
      {
        uint64_t v72 = v36;
        int v73 = 64;
        goto LABEL_236;
      }
    }

    if ((v43 - 400) > 0x63)
    {
      if (v43 == 502)
      {
        BOOL v104 = (*v64 & 4) == 0;
        int v105 = 1207;
        int v106 = 1107;
      }

      else
      {
        BOOL v104 = (*v64 & 4) == 0;
        if ((v43 - 500) > 0x63)
        {
          int v105 = 1201;
          int v106 = 1101;
        }

        else
        {
          int v105 = 1205;
          int v106 = 1105;
        }
      }

  char v183 = v169;
  BOOL v184 = v183;
  if (v183->policy_result.routing_result == 4)
  {
    BOOL v185 = v183->policy_result.routing_result_parameter.tunnel_interface_index == 0xFFFFFFF;

    if (v185)
    {
      buf[0] = 0;
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      uint64_t v186 = (id)nw_context_copy_implicit_context::implicit_context;
      bridged_flow_director = nw_path_create_bridged_flow_director(v186, buf);

      if (buf[0]) {
        uint64_t v188 = bridged_flow_director;
      }
      else {
        uint64_t v188 = 0;
      }
      if (v188 == 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v189 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(length[0]) = 136446210;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_snapshot_path";
          id v190 = "%{public}s In-process flow divert director created due to path result";
          char v191 = v189;
          size_t v192 = OS_LOG_TYPE_DEFAULT;
          goto LABEL_376;
        }

        goto LABEL_377;
      }

      if ((bridged_flow_director & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v189 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
        {
          LODWORD(length[0]) = 136446210;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_snapshot_path";
          id v190 = "%{public}s Failed to create in-process flow divert director due to path result";
          char v191 = v189;
          size_t v192 = OS_LOG_TYPE_ERROR;
LABEL_376:
          _os_log_impl(&dword_181A5C000, v191, v192, v190, (uint8_t *)length, 0xCu);
        }

        size_t v112 = (char *)v352;
LABEL_360:
        if (v112) {
          free(v112);
        }
        int v61 = 0;
        if ((v57 & 1) != 0) {
          goto LABEL_122;
        }
LABEL_123:
        if ((v374 & 1) != 0)
        {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v373);
          if ((v376 & 1) == 0)
          {
LABEL_125:
            if ((v61 & 1) == 0) {
              goto LABEL_542;
            }
            goto LABEL_129;
          }
        }

        else if ((v376 & 1) == 0)
        {
          goto LABEL_125;
        }

        nw::release_if_needed<nw_protocol *>((uint64_t *)v375);
        if ((v61 & 1) == 0)
        {
LABEL_542:
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v214 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
            goto LABEL_600;
          }
          goto LABEL_546;
        }

LABEL_242:
  nw_frame_finalize((uint64_t)a2);
  return 1LL;
}

            *(_BYTE *)(v17 + 22_Block_object_dispose(va, 8) = v90 | 0x20;
            goto LABEL_270;
          }

          size_t v115 = v60;
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v116 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_parse_binary_http_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              v285 = (uint64_t)" ";
              _os_log_impl( &dword_181A5C000,  v116,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sUnable to parse metadata",  buf,  0x20u);
            }
          }

        free(v132);
      }
    }

uint64_t nw_protocol_masque_listener_read_input( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 527) & 0x10) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_read_input";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v40[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type[0];
      if (!os_log_type_enabled(v19, type[0])) {
        goto LABEL_35;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_read_input";
      uint64_t v21 = "%{public}s called with null (masque->listen_udp)";
    }

    else if (LOBYTE(v40[0]))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type[0];
      BOOL v23 = os_log_type_enabled(v19, type[0]);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_read_input";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null (masque->listen_udp), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (!v23)
      {
LABEL_35:
        if (v18) {
          free(v18);
        }
        return 0LL;
      }

      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_read_input";
      uint64_t v21 = "%{public}s called with null (masque->listen_udp), no backtrace";
    }

    else
    {
      id v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type[0];
      if (!os_log_type_enabled(v19, type[0])) {
        goto LABEL_35;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_masque_listener_read_input";
      uint64_t v21 = "%{public}s called with null (masque->listen_udp), backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
    goto LABEL_35;
  }

  if (*(_DWORD *)(a1 + 508) != 4) {
    return 0LL;
  }
  int v7 = a6;
  int v8 = a5;
  v40[0] = 0LL;
  v40[1] = v40;
  nw_protocol_get_input_frames(*(void *)(a1 + 32), a1, a4, a5, a6, (uint64_t)v40);
  if (!v40[0]) {
    return 0LL;
  }
  *(void *)int buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  char v42 = 0;
  *(void *)os_log_type_t type = 0LL;
  uint64_t v37 = type;
  int v39 = 0;
  uint64_t v38 = 0x2000000000LL;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  id v11 = (id)nw_protocol_copy_http_definition_http_definition;
  uint64_t v12 = MEMORY[0x1895F87A8];
  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 0x40000000LL;
  id v27 = ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke;
  uint64_t v28 = &unk_189BBA968;
  id v31 = v11;
  uint64_t v32 = a1;
  BOOL v33 = v40;
  uint64_t v34 = a2;
  uint64_t v35 = a3;
  int v29 = type;
  unsigned int v30 = buf;
  uint64_t v13 = v40[0];
  do
  {
    if (!v13) {
      break;
    }
    uint64_t v14 = *(void *)(v13 + 32);
    char v15 = ((uint64_t (*)(void *))v27)(v26);
    uint64_t v13 = v14;
  }

  while ((v15 & 1) != 0);
  if (v11) {
    os_release(v11);
  }
  if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
  {
    BOOL v16 = *(char **)(a1 + 480);
    v25[0] = v12;
    v25[1] = 0x40000000LL;
    v25[2] = ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_151;
    v25[3] = &__block_descriptor_tmp_152;
    void v25[4] = a1;
    nw_hash_table_apply(v16, (uint64_t)v25);
  }

  if (a2)
  {
    uint64_t v17 = *((unsigned int *)v37 + 6);
    if (!(_DWORD)v17)
    {
      if (*(_BYTE *)(*(void *)&buf[8] + 24LL) && *(void *)(a2 + 32)) {
        uint64_t v17 = nw_frame_array_fill_from_pending_array((void *)(a2 + 32), a3, v8, v7);
      }
      else {
        uint64_t v17 = 0LL;
      }
    }
  }

  else
  {
    uint64_t v17 = *((unsigned int *)v37 + 6);
  }

  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v17;
}

uint64_t ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v92 = *MEMORY[0x1895F89C0];
  uint64_t v4 = nw_frame_copy_metadata_for_protocol(a2, *(void *)(a1 + 48));
  if (v4)
  {
    os_log_type_t v5 = v4;
    if (nw_http_metadata_is_capsule(v4))
    {
      uint64_t v6 = *(void *)(a1 + 56);
      if (!v6 || (*(_BYTE *)(v6 + 529) & 1) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        int v7 = (os_log_s *)gprivacy_proxyLogObj;
        BOOL v8 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO);
        uint64_t v6 = *(void *)(a1 + 56);
        if (v8)
        {
          uint64_t v9 = (const char *)(v6 + 531);
          uint64_t v10 = "";
          if (v6) {
            uint64_t v10 = " ";
          }
          else {
            uint64_t v9 = "";
          }
          *(_DWORD *)int buf = 136446466;
          *(void *)BOOL v87 = v9;
          *(_WORD *)&os_log_type_t v87[8] = 2080;
          *(void *)&v87[10] = v10;
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived HTTP Capsule for listener",  buf,  0x16u);
          uint64_t v6 = *(void *)(a1 + 56);
        }
      }

      nw_masque_handle_capsule(v6, v5);
      uint64_t v11 = *(void *)(a2 + 32);
      uint64_t v12 = *(void **)(a2 + 40);
      if (v11)
      {
        *(void *)(v11 + 40) = v12;
        uint64_t v12 = *(void **)(a2 + 40);
      }

      else
      {
        *(void *)(*(void *)(a1 + 64) + 8LL) = v12;
      }

      void *v12 = v11;
      *(void *)(a2 + 32) = 0LL;
      *(void *)(a2 + 40) = 0LL;
      nw_frame_finalize(a2);
    }

    os_release(v5);
    return 1LL;
  }

  unsigned int v85 = 0;
  uint64_t v13 = (unsigned __int8 *)nw_frame_unclaimed_bytes(a2, &v85);
  uint64_t v14 = *(void *)(a2 + 32);
  char v15 = *(void **)(a2 + 40);
  if (v14)
  {
    *(void *)(v14 + 40) = v15;
    char v15 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 64) + 8LL) = v15;
  }

  *char v15 = v14;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  if (!v85)
  {
    uint64_t v21 = *(void *)(a1 + 56);
    if (v21 && (*(_BYTE *)(v21 + 529) & 1) != 0) {
      goto LABEL_79;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    id v22 = (os_log_s *)gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_79;
    }
    uint64_t v23 = *(void *)(a1 + 56);
    uint64_t v24 = "";
    BOOL v25 = v23 == 0;
    if (v23) {
      __int16 v26 = (const char *)(v23 + 531);
    }
    else {
      __int16 v26 = "";
    }
    *(_DWORD *)int buf = 136446722;
    if (!v25) {
      uint64_t v24 = " ";
    }
    *(void *)BOOL v87 = v26;
    *(_WORD *)&os_log_type_t v87[8] = 2080;
    *(void *)&v87[10] = v24;
    *(_WORD *)&v87[18] = 1024;
    *(_DWORD *)&v87[20] = v85;
    id v27 = "%{public}s%sReceived datagram is too short (length %u)";
LABEL_77:
    int v47 = buf;
LABEL_78:
    _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_INFO, v27, v47, 0x1Cu);
    goto LABEL_79;
  }

  int v16 = *v13;
  if (v16 != 6)
  {
    if (v16 == 4)
    {
      *(void *)&address[8] = 0LL;
      if (v85 > 6)
      {
        *(_WORD *)uint64_t address = 528;
        *(_DWORD *)&address[4] = *(_DWORD *)(v13 + 1);
        *(_WORD *)&address[2] = *(_WORD *)(v13 + 5);
        nw_endpoint_t v18 = nw_endpoint_create_address((const sockaddr *)address);
        uint64_t v19 = a2;
        int v20 = 7;
        goto LABEL_38;
      }

      uint64_t v42 = *(void *)(a1 + 56);
      if (v42 && (*(_BYTE *)(v42 + 529) & 1) != 0) {
        goto LABEL_79;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      id v22 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
LABEL_79:
        nw_frame_finalize(a2);
        return 1LL;
      }

      uint64_t v43 = *(void *)(a1 + 56);
      id v44 = "";
      BOOL v45 = v43 == 0;
      if (v43) {
        uint64_t v46 = (const char *)(v43 + 531);
      }
      else {
        uint64_t v46 = "";
      }
      *(_DWORD *)int buf = 136446722;
      if (!v45) {
        id v44 = " ";
      }
      *(void *)BOOL v87 = v46;
      *(_WORD *)&os_log_type_t v87[8] = 2080;
      *(void *)&v87[10] = v44;
      *(_WORD *)&v87[18] = 1024;
      *(_DWORD *)&v87[20] = v85;
      id v27 = "%{public}s%sReceived datagram is too short for IPv4 (length %u)";
    }

    else
    {
      uint64_t v37 = *(void *)(a1 + 56);
      if (v37 && (*(_BYTE *)(v37 + 529) & 1) != 0) {
        goto LABEL_79;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      id v22 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_79;
      }
      uint64_t v38 = *(void *)(a1 + 56);
      BOOL v39 = v38 == 0;
      if (v38) {
        os_log_type_t v40 = (const char *)(v38 + 531);
      }
      else {
        os_log_type_t v40 = "";
      }
      *(_DWORD *)int buf = 136446722;
      *(void *)BOOL v87 = v40;
      uint32_t v41 = " ";
      if (v39) {
        uint32_t v41 = "";
      }
      *(_WORD *)&os_log_type_t v87[8] = 2080;
      *(void *)&v87[10] = v41;
      *(_WORD *)&v87[18] = 1024;
      *(_DWORD *)&v87[20] = v16;
      id v27 = "%{public}s%sReceived datagram with unsupported IP version %u";
    }

    goto LABEL_77;
  }

  memset(v87, 0, 24);
  if (v85 <= 0x12)
  {
    uint64_t v49 = *(void *)(a1 + 56);
    if (v49 && (*(_BYTE *)(v49 + 529) & 1) != 0) {
      goto LABEL_79;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    id v22 = (os_log_s *)gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_79;
    }
    uint64_t v50 = *(void *)(a1 + 56);
    id v51 = "";
    BOOL v52 = v50 == 0;
    if (v50) {
      uint64_t v53 = (const char *)(v50 + 531);
    }
    else {
      uint64_t v53 = "";
    }
    *(_DWORD *)uint64_t address = 136446722;
    if (!v52) {
      id v51 = " ";
    }
    *(void *)&address[4] = v53;
    *(_WORD *)&address[12] = 2080;
    *(void *)&address[14] = v51;
    *(_WORD *)&address[22] = 1024;
    unsigned int v91 = v85;
    id v27 = "%{public}s%sReceived datagram is too short for IPv6 (length %u)";
    int v47 = address;
    goto LABEL_78;
  }

  *(_WORD *)int buf = 7708;
  *(_OWORD *)&v87[4] = *(_OWORD *)(v13 + 1);
  *(_WORD *)&buf[2] = *(_WORD *)(v13 + 17);
  nw_endpoint_t v18 = nw_endpoint_create_address((const sockaddr *)buf);
  uint64_t v19 = a2;
  int v20 = 19;
LABEL_38:
  nw_frame_claim(v19, v17, v20, 0);
  *(void *)uint64_t address = 0LL;
  *(void *)&address[8] = address;
  *(void *)&address[16] = 0x2000000000LL;
  LOBYTE(v91) = 0;
  uint64_t v28 = *(void *)(a1 + 56);
  int v29 = *(char **)(v28 + 480);
  uint64_t v30 = MEMORY[0x1895F87A8];
  v79[0] = MEMORY[0x1895F87A8];
  v79[1] = 0x40000000LL;
  v79[2] = ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_146;
  v79[3] = &unk_189BBA918;
  v79[4] = address;
  __int128 v82 = *(_OWORD *)(a1 + 72);
  nw_endpoint_t v81 = v18;
  uint64_t v83 = a2;
  uint64_t v84 = v28;
  __int128 v80 = *(_OWORD *)(a1 + 32);
  nw_hash_table_apply(v29, (uint64_t)v79);
  if (!*(_BYTE *)(*(void *)&address[8] + 24LL))
  {
    uint64_t v54 = *(void *)(a1 + 56);
    unsigned int v55 = *(void ***)(v54 + 440);
    if (v55 && (unsigned int v56 = *v55) != 0LL && *v56)
    {
      if ((*(_BYTE *)(v54 + 529) & 1) == 0 && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        int v73 = (os_log_s *)gprivacy_proxyLogObj;
        BOOL v74 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
        uint64_t v54 = *(void *)(a1 + 56);
        if (v74)
        {
          BOOL v75 = v54 == 0;
          if (v54) {
            int v76 = (const char *)(v54 + 531);
          }
          else {
            int v76 = "";
          }
          *(_DWORD *)int buf = 136446978;
          *(void *)BOOL v87 = "nw_protocol_masque_listener_read_input_block_invoke";
          *(_WORD *)&os_log_type_t v87[8] = 2082;
          *(void *)&v87[10] = v76;
          uint64_t v77 = " ";
          if (v75) {
            uint64_t v77 = "";
          }
          *(_WORD *)&v87[18] = 2080;
          *(void *)&v87[20] = v77;
          __int16 v88 = 2112;
          nw_endpoint_t v89 = v18;
          _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound new frame for %@, creating a new flow",  buf,  0x2Au);
          uint64_t v54 = *(void *)(a1 + 56);
        }
      }

      nw_parameters_t v57 = nw_parameters_copy(*(nw_parameters_t *)(v54 + 320));
      char v58 = (***(uint64_t (****)(void, nw_endpoint_t, nw_parameters_t))(*(void *)(a1 + 56) + 440LL))( *(void *)(*(void *)(a1 + 56) + 440LL),  v18,  v57);
      if (v57) {
        os_release(v57);
      }
      if ((v58 & 1) != 0)
      {
        *(_BYTE *)(*(void *)&address[8] + 24LL) = 0;
        uint64_t v59 = *(void *)(a1 + 56);
        int v60 = *(char **)(v59 + 480);
        v78[0] = v30;
        v78[1] = 0x40000000LL;
        void v78[2] = ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_148;
        v78[3] = &unk_189BBA940;
        v78[6] = v18;
        v78[7] = a2;
        v78[8] = v59;
        uint64_t v61 = *(void *)(a1 + 40);
        v78[4] = address;
        v78[5] = v61;
        nw_hash_table_apply(v60, (uint64_t)v78);
        goto LABEL_39;
      }

      uint64_t v68 = *(void *)(a1 + 56);
      if (v68 && (*(_BYTE *)(v68 + 529) & 1) != 0) {
        goto LABEL_39;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v62 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_39;
      }
      uint64_t v69 = *(void *)(a1 + 56);
      BOOL v70 = v69 == 0;
      if (v69) {
        uint64_t v71 = (const char *)(v69 + 531);
      }
      else {
        uint64_t v71 = "";
      }
      uint64_t v72 = " ";
      if (v70) {
        uint64_t v72 = "";
      }
      *(_DWORD *)int buf = 136446466;
      *(void *)BOOL v87 = v71;
      *(_WORD *)&os_log_type_t v87[8] = 2080;
      *(void *)&v87[10] = v72;
      uint64_t v67 = "%{public}s%sFailed to accept new flow";
    }

    else
    {
      if ((*(_BYTE *)(v54 + 529) & 1) != 0) {
        goto LABEL_39;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v62 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_39;
      }
      uint64_t v63 = *(void *)(a1 + 56);
      BOOL v64 = v63 == 0;
      if (v63) {
        uint64_t v65 = (const char *)(v63 + 531);
      }
      else {
        uint64_t v65 = "";
      }
      char v66 = " ";
      if (v64) {
        char v66 = "";
      }
      *(_DWORD *)int buf = 136446466;
      *(void *)BOOL v87 = v65;
      *(_WORD *)&os_log_type_t v87[8] = 2080;
      *(void *)&v87[10] = v66;
      uint64_t v67 = "%{public}s%sReceived datagram for new flow, but no listen protocol is able to receive the new flow";
    }

    _os_log_impl(&dword_181A5C000, v62, OS_LOG_TYPE_ERROR, v67, buf, 0x16u);
  }

uint64_t ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_151( uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!*(void *)nw_hash_node_get_extra(a2)) {
    return 1LL;
  }
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v5 = object;
  if (object)
  {
    uint64_t v6 = *(void *)(object + 24);
    if (v6)
    {
      int v7 = *(void (**)(uint64_t, void))(v6 + 64);
      if (v7)
      {
        v7(object, *(void *)(a1 + 32));
        return 1LL;
      }
    }

    __nwlog_obj();
    uint64_t v9 = *(const char **)(v5 + 16);
    if (!v9) {
      uint64_t v9 = "invalid";
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v9 = "invalid";
  }

  *(_DWORD *)int buf = 136446466;
  uint64_t v23 = "nw_protocol_masque_listener_read_input_block_invoke";
  __int16 v24 = 2082;
  BOOL v25 = v9;
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v10, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_37;
      }
      uint64_t v13 = "invalid";
      if (v5 && *(void *)(v5 + 16)) {
        uint64_t v13 = *(const char **)(v5 + 16);
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v23 = "nw_protocol_masque_listener_read_input_block_invoke";
      __int16 v24 = 2082;
      BOOL v25 = v13;
      uint64_t v14 = "%{public}s protocol %{public}s has invalid input_available callback";
      goto LABEL_36;
    }

    if (!v20)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_37;
      }
      nw_endpoint_t v18 = "invalid";
      if (v5 && *(void *)(v5 + 16)) {
        nw_endpoint_t v18 = *(const char **)(v5 + 16);
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v23 = "nw_protocol_masque_listener_read_input_block_invoke";
      __int16 v24 = 2082;
      BOOL v25 = v18;
      uint64_t v14 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v16 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v16)
      {
        uint64_t v17 = "invalid";
        if (v5 && *(void *)(v5 + 16)) {
          uint64_t v17 = *(const char **)(v5 + 16);
        }
        *(_DWORD *)int buf = 136446722;
        uint64_t v23 = "nw_protocol_masque_listener_read_input_block_invoke";
        __int16 v24 = 2082;
        BOOL v25 = v17;
        __int16 v26 = 2082;
        id v27 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_37;
    }

    if (v16)
    {
      uint64_t v19 = "invalid";
      if (v5 && *(void *)(v5 + 16)) {
        uint64_t v19 = *(const char **)(v5 + 16);
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v23 = "nw_protocol_masque_listener_read_input_block_invoke";
      __int16 v24 = 2082;
      BOOL v25 = v19;
      uint64_t v14 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_36:
      _os_log_impl(&dword_181A5C000, v11, v12, v14, buf, 0x16u);
    }
  }

BOOL ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_146( uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t v5 = *(void **)(extra + 16);
  if (v5)
  {
    uint64_t v6 = extra;
    if (nw_endpoint_is_equal(*(void **)(a1 + 56), v5, 0LL))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      if (*(void *)(a1 + 64) == a2)
      {
        uint64_t v10 = *(void *)(a1 + 72);
        uint64_t v11 = *(void *)(a1 + 80);
        *(void *)(v11 + 32) = 0LL;
        os_log_type_t v12 = *(void **)(v10 + 8);
        *(void *)(v11 + 40) = v12;
        void *v12 = v11;
        *(void *)(v10 + _Block_object_dispose(va, 8) = v11 + 32;
        uint64_t v13 = *(void *)(a1 + 88);
        if ((!v13 || (*(_BYTE *)(v13 + 529) & 1) == 0) && gLogDatapath)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          char v20 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v21 = *(void *)(a1 + 88);
            id v22 = "";
            BOOL v23 = v21 == 0;
            if (v21) {
              __int16 v24 = (const char *)(v21 + 531);
            }
            else {
              __int16 v24 = "";
            }
            int v25 = 136446722;
            __int16 v26 = "nw_protocol_masque_listener_read_input_block_invoke";
            if (!v23) {
              id v22 = " ";
            }
            __int16 v27 = 2082;
            uint64_t v28 = v24;
            __int16 v29 = 2080;
            uint64_t v30 = v22;
            _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound frame matching remote address",  (uint8_t *)&v25,  0x20u);
          }
        }

        ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      }

      else
      {
        uint64_t v7 = *(void *)(a1 + 80);
        *(void *)(v7 + 32) = 0LL;
        BOOL v8 = *(void **)(v6 + 8);
        *(void *)(v7 + 40) = v8;
        *BOOL v8 = v7;
        *(void *)(v6 + _Block_object_dispose(va, 8) = v7 + 32;
        uint64_t v9 = *(void *)(a1 + 88);
        if ((!v9 || (*(_BYTE *)(v9 + 529) & 1) == 0) && gLogDatapath)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          char v15 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v16 = *(void *)(a1 + 88);
            uint64_t v17 = "";
            BOOL v18 = v16 == 0;
            if (v16) {
              uint64_t v19 = (const char *)(v16 + 531);
            }
            else {
              uint64_t v19 = "";
            }
            int v25 = 136446722;
            __int16 v26 = "nw_protocol_masque_listener_read_input_block_invoke";
            if (!v18) {
              uint64_t v17 = " ";
            }
            __int16 v27 = 2082;
            uint64_t v28 = v19;
            __int16 v29 = 2080;
            uint64_t v30 = v17;
            _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound frame matching remote address, pending",  (uint8_t *)&v25,  0x20u);
          }
        }

        *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
      }
    }
  }

  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

BOOL ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_148( uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t v4 = *(void **)(extra + 16);
  if (v4)
  {
    uint64_t v5 = extra;
    if (nw_endpoint_is_equal(*(void **)(a1 + 48), v4, 0LL))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      uint64_t v6 = *(void *)(a1 + 56);
      *(void *)(v6 + 32) = 0LL;
      uint64_t v7 = *(void **)(v5 + 8);
      *(void *)(v6 + 40) = v7;
      *uint64_t v7 = v6;
      *(void *)(v5 + _Block_object_dispose(va, 8) = v6 + 32;
      uint64_t v8 = *(void *)(a1 + 64);
      if ((!v8 || (*(_BYTE *)(v8 + 529) & 1) == 0) && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v10 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v11 = *(void *)(a1 + 64);
          os_log_type_t v12 = "";
          BOOL v13 = v11 == 0;
          if (v11) {
            uint64_t v14 = (const char *)(v11 + 531);
          }
          else {
            uint64_t v14 = "";
          }
          int v15 = 136446722;
          uint64_t v16 = "nw_protocol_masque_listener_read_input_block_invoke";
          if (!v13) {
            os_log_type_t v12 = " ";
          }
          __int16 v17 = 2082;
          BOOL v18 = v14;
          __int16 v19 = 2080;
          char v20 = v12;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound new flow matching remote address, pending",  (uint8_t *)&v15,  0x20u);
        }
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
    }
  }

  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

unint64_t ___ZL40nw_masque_handle_server_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke( unint64_t result, char *__s)
{
  if (__s)
  {
    uint64_t v3 = (void *)result;
    double result = strlen(__s);
    if (result <= 7)
    {
      *(_BYTE *)(*(void *)(v3[4] + 8LL) + 24LL) = 1;
      double result = strcmp((const char *)(v3[6] + 615LL), __s);
      *(_BYTE *)(*(void *)(v3[5] + 8LL) + 24LL) = (_DWORD)result == 0;
    }
  }

  return result;
}

size_t ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke( size_t result, char *__s)
{
  if (__s)
  {
    uint64_t v3 = result;
    double result = strlen(__s);
    if (result <= 7)
    {
      uint64_t v4 = *(_BYTE **)(v3 + 32);
      int v5 = *__s;
      v4[615] = v5;
      if (v5)
      {
        int v6 = __s[1];
        v4[616] = v6;
        if (v6)
        {
          int v7 = __s[2];
          v4[617] = v7;
          if (v7)
          {
            int v8 = __s[3];
            v4[618] = v8;
            if (v8)
            {
              int v9 = __s[4];
              v4[619] = v9;
              if (v9)
              {
                int v10 = __s[5];
                v4[620] = v10;
                if (v10)
                {
                  int v11 = __s[6];
                  v4[621] = v11;
                  if (v11) {
                    v4[622] = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

void ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_155( uint64_t a1, char *__s1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (__s1 && !strcmp(__s1, "?1"))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3 || (*(_BYTE *)(v3 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v4 = (os_log_s *)gprivacy_proxyLogObj;
      BOOL v5 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO);
      uint64_t v3 = *(void *)(a1 + 32);
      if (v5)
      {
        BOOL v6 = v3 == 0;
        if (v3) {
          int v7 = (const char *)(v3 + 531);
        }
        else {
          int v7 = "";
        }
        int v8 = " ";
        if (v6) {
          int v8 = "";
        }
        int v9 = 136446466;
        int v10 = v7;
        __int16 v11 = 2080;
        os_log_type_t v12 = v8;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s%sServer supports forwarding",  (uint8_t *)&v9,  0x16u);
        uint64_t v3 = *(void *)(a1 + 32);
      }
    }

    *(_DWORD *)(v3 + 527) |= 0x100000u;
  }

uint64_t ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_157( uint64_t result, char *__s1)
{
  uint64_t v2 = result;
  if (__s1)
  {
    double result = strcmp(__s1, "?1");
    int v3 = ((_DWORD)result == 0) << 19;
  }

  else
  {
    int v3 = 0;
  }

  *(_DWORD *)(*(void *)(v2 + 32) + 527LL) = *(_DWORD *)(*(void *)(v2 + 32) + 527LL) & 0xFFF7FFFF | v3;
  return result;
}

void ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_2( void *a1, char *__big)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  if (__big)
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = strstr(__big, "invalid geohash") != 0LL;
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = strstr(__big, "expired routing") != 0LL;
    unsigned int v4 = strlen(__big);
    unsigned int v5 = v4;
    uint64_t v6 = a1[8];
    if (v6)
    {
      if (*(void *)(v6 + 312))
      {
        uint64_t v7 = v4;
        int v8 = strnstr(__big, "next-hop=", v4);
        int v9 = v8;
        if (v8)
        {
          int v10 = ";";
          uint64_t v11 = 10LL;
        }

        else
        {
          int v8 = strnstr(__big, "next-hop=", v5);
          if (!v8) {
            goto LABEL_38;
          }
          int v10 = ";";
          uint64_t v11 = 9LL;
        }

        BOOL v12 = v9 != 0LL;
        uint64_t v13 = &v8[v11];
        uint64_t v14 = &__big[v7];
        int v15 = strnstr(&v8[v11], v10, v14 - &v8[v11]);
        if (v15) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = &v14[-v12];
        }
        size_t v17 = v16 - v13;
        if (v16 > v13)
        {
          if (*v13 == 91 || (int v25 = strnstr(v13, ":", v16 - v13)) != 0LL && !strnstr(v25 + 1, ":", v16 - (v25 + 1)))
          {
            __int128 v64 = xmmword_1826672EC;
            __int128 v65 = unk_1826672FC;
            __int128 v66 = xmmword_18266730C;
            __int128 v67 = unk_18266731C;
            __int128 v60 = xmmword_1826672AC;
            __int128 v61 = unk_1826672BC;
            __int128 v62 = xmmword_1826672CC;
            __int128 v63 = unk_1826672DC;
            __int128 v56 = xmmword_18266726C;
            __int128 v57 = unk_18266727C;
            __int128 v58 = xmmword_18266728C;
            __int128 v59 = unk_18266729C;
            *(_OWORD *)__s = *(_OWORD *)"https://";
            *(_OWORD *)&__s[16] = unk_18266723C;
            __int128 v54 = xmmword_18266724C;
            __int128 v55 = unk_18266725C;
            size_t v18 = strlen(__s);
            if (v18 + v17 <= 0xFF)
            {
              memcpy(&__s[v18], v13, v17);
              nw_endpoint_t url = nw_endpoint_create_url(__s);
              if (url)
              {
                nw_endpoint_t v20 = url;
                url_unsigned int port = nw_endpoint_get_url_port(url, 0);
                id v22 = v20;
                BOOL v23 = (const char *)-[nw_endpoint hostname](v22, "hostname");

                if (!url_port) {
                  url_unsigned int port = nw_endpoint_get_port(*(nw_endpoint_t *)(v6 + 312));
                }
                host_with_numeric_unsigned int port = nw_endpoint_create_host_with_numeric_port(v23, url_port);
                os_release(v22);
LABEL_39:
                *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = host_with_numeric_port;
                uint64_t v33 = a1[8];
                if (v33)
                {
                  if (*(void *)(v33 + 312))
                  {
                    BOOL v34 = strnstr(__big, "next-hop-aliases=", v5);
                    if (v34)
                    {
                      uint64_t v35 = v34 + 18;
                      uint64_t v36 = strnstr(v34 + 18, "", &__big[v5] - (v34 + 18));
                      if (v36)
                      {
                        uint64_t v37 = v36;
                        BOOL v38 = 0LL;
                        do
                        {
                          if (v35 >= v37) {
                            break;
                          }
                          __int128 v66 = 0u;
                          __int128 v67 = 0u;
                          __int128 v64 = 0u;
                          __int128 v65 = 0u;
                          __int128 v62 = 0u;
                          __int128 v63 = 0u;
                          __int128 v60 = 0u;
                          __int128 v61 = 0u;
                          __int128 v58 = 0u;
                          __int128 v59 = 0u;
                          __int128 v56 = 0u;
                          __int128 v57 = 0u;
                          __int128 v54 = 0u;
                          __int128 v55 = 0u;
                          size_t v39 = v37 - v35;
                          memset(__s, 0, sizeof(__s));
                          os_log_type_t v40 = strnstr(v35, ",", v37 - v35);
                          uint32_t v41 = v40;
                          if (v40) {
                            size_t v39 = v40 - v35;
                          }
                          if (v39 - 1 <= 0xFE)
                          {
                            if (!v38) {
                              BOOL v38 = nw_array_create();
                            }
                            memcpy(__s, v35, v39);
                            unsigned int port = nw_endpoint_get_port(*(nw_endpoint_t *)(v33 + 312));
                            BOOL v43 = nw_endpoint_create_host_with_numeric_port(__s, port);
                            if (v43)
                            {
                              id v44 = (void *)v43;
                              nw_array_append(v38, (void *)v43);
                              os_release(v44);
                            }
                          }

                          uint64_t v35 = v41 + 1;
                        }

                        while (v41);
                        goto LABEL_70;
                      }
                    }
                  }

void sub_182025784(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_3( uint64_t a1, char *__s)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!__s || strlen(__s) > 6) {
    return;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
    int v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      size_t v18 = "%{public}s called with null masque";
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v21 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_66:
        if (!v15) {
          return;
        }
        goto LABEL_67;
      }

      if (!v21) {
        goto LABEL_66;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      size_t v18 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      size_t v18 = "%{public}s called with null masque, backtrace limit exceeded";
    }

    goto LABEL_65;
  }

  unsigned int v5 = *(void **)(v4 + 328);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
    int v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        uint64_t v16 = (os_log_s *)__nwlog_obj();
        os_log_type_t v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_66;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
        size_t v18 = "%{public}s called with null masque->context, backtrace limit exceeded";
        goto LABEL_65;
      }

      id v22 = (char *)__nw_create_backtrace_string();
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v23 = os_log_type_enabled(v16, type);
      if (!v22)
      {
        if (!v23) {
          goto LABEL_66;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
        size_t v18 = "%{public}s called with null masque->context, no backtrace";
        goto LABEL_65;
      }

      if (v23)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
        __int16 v30 = 2082;
        uint64_t v31 = v22;
        __int16 v24 = "%{public}s called with null masque->context, dumping backtrace:%{public}s";
LABEL_50:
        _os_log_impl(&dword_181A5C000, v16, v17, v24, buf, 0x16u);
      }

void ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_4( uint64_t a1, char *__s)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  *(void *)os_log_type_t v17 = 0LL;
  if (__s && strlen(__s) <= 7)
  {
    v17[0] = *__s;
    if (v17[0])
    {
      v17[1] = __s[1];
      if (v17[1])
      {
        void v17[2] = __s[2];
        if (v17[2])
        {
          v17[3] = __s[3];
          if (v17[3])
          {
            void v17[4] = __s[4];
            if (v17[4])
            {
              void v17[5] = __s[5];
              if (v17[5])
              {
                void v17[6] = __s[6];
                if (v17[6]) {
                  v17[7] = 0;
                }
              }
            }
          }
        }
      }
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = atoi(v17);
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4 || (*(_BYTE *)(v4 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      unsigned int v5 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v6 = "";
        uint64_t v7 = *(void *)(a1 + 40);
        BOOL v8 = v7 == 0;
        if (v7) {
          int v9 = (const char *)(v7 + 531);
        }
        else {
          int v9 = "";
        }
        if (!v8) {
          uint64_t v6 = " ";
        }
        int v10 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        int v11 = 136446722;
        int v12 = v9;
        __int16 v13 = 2080;
        int v14 = v6;
        __int16 v15 = 1024;
        int v16 = v10;
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived epoch value of %d",  (uint8_t *)&v11,  0x1Cu);
      }
    }
  }

char *___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_164( char *result, char *__big)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!__big) {
    return result;
  }
  int v3 = result;
  *(_BYTE *)(*(void *)(*((void *)result + 4) + 8LL) + 24LL) = strstr(__big, "expired routing") != 0LL;
  *(_BYTE *)(*(void *)(*((void *)v3 + 5) + 8LL) + 24LL) = strstr(__big, "received-status=") != 0LL;
  if (!*((void *)v3 + 10))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v17 = "nw_masque_get_dns_failure_reason_from_proxy_status";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v17 = "nw_masque_get_dns_failure_reason_from_proxy_status";
      int v9 = "%{public}s called with null masque";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v17 = "nw_masque_get_dns_failure_reason_from_proxy_status";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (!v11)
      {
LABEL_25:
        if (v6) {
          free(v6);
        }
        goto LABEL_27;
      }

      *(_DWORD *)int buf = 136446210;
      os_log_type_t v17 = "nw_masque_get_dns_failure_reason_from_proxy_status";
      int v9 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v17 = "nw_masque_get_dns_failure_reason_from_proxy_status";
      int v9 = "%{public}s called with null masque, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_25;
  }

  size_t v4 = strlen(__big);
  if (!strnstr(__big, "error=dns_error", v4))
  {
LABEL_27:
    int v5 = 0;
    goto LABEL_28;
  }

  if (strnstr(__big, "info-code=15", v4))
  {
    int v5 = 1;
  }

  else if (strnstr(__big, "info-code=16", v4))
  {
    int v5 = 2;
  }

  else if (strnstr(__big, "info-code=17", v4))
  {
    int v5 = 3;
  }

  else
  {
    int v5 = 0;
  }

void ___ZL33nw_masque_handle_connect_responseP9nw_masqueP20nw_protocol_metadata_block_invoke_180(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(_BYTE *)(v2 + 529) & 1) == 0)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    int v3 = (os_log_s *)gprivacy_proxyLogObj;
    BOOL v4 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
    uint64_t v2 = *(void *)(a1 + 32);
    if (v4)
    {
      int v5 = (const char *)(v2 + 531);
      if (!v2) {
        int v5 = "";
      }
      int v6 = *(unsigned __int16 *)(a1 + 40);
      int v8 = 136446722;
      int v9 = v5;
      uint64_t v7 = " ";
      if (!v2) {
        uint64_t v7 = "";
      }
      __int16 v10 = 2080;
      BOOL v11 = v7;
      __int16 v12 = 1024;
      int v13 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s%sCONNECT response %u timed out waiting for certificates, failing",  (uint8_t *)&v8,  0x1Cu);
      uint64_t v2 = *(void *)(a1 + 32);
    }
  }

  nw_masque_mark_failed_with_error(v2, 61);
}

uint64_t ___ZL50nw_protocol_masque_listener_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( uint64_t a1, _DWORD *a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  int v4 = nw_frame_unclaimed_length(a2);
  int v31 = 0;
  nw_frame_get_buffer((uint64_t)a2, &v31);
  unsigned int v6 = v31 - v4;
  if (v31 - v4 == 19 || v6 == 7)
  {
    nw_frame_unclaim((uint64_t)a2, v5, v6, 0);
    return 1LL;
  }

  if (!nw_frame_unclaim((uint64_t)a2, v5, 7u, 0))
  {
    uint64_t v19 = *(void *)(a1 + 40);
    if (v19 && (*(_BYTE *)(v19 + 529) & 1) != 0) {
      return 1LL;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v20 = gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
      return 1LL;
    }
    uint64_t v21 = *(void *)(a1 + 40);
    if (v21) {
      id v22 = (const char *)(v21 + 531);
    }
    else {
      id v22 = "";
    }
    if (v21) {
      BOOL v23 = " ";
    }
    else {
      BOOL v23 = "";
    }
    int v24 = nw_frame_unclaimed_length(a2);
    *(_DWORD *)int buf = 136446722;
    uint64_t v33 = v22;
    __int16 v34 = 2080;
    uint64_t v35 = v23;
    __int16 v36 = 1024;
    int v37 = v24;
    int v16 = "%{public}s%sFrame is too short for header (%u)";
LABEL_47:
    os_log_type_t v17 = (os_log_s *)v20;
    uint32_t v18 = 28;
LABEL_48:
    _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
    return 1LL;
  }

  int v30 = 0;
  if (!nw_frame_unclaim((uint64_t)a2, v9, 0xCu, 0))
  {
    uint64_t v25 = *(void *)(a1 + 40);
    if (v25 && (*(_BYTE *)(v25 + 529) & 1) != 0) {
      return 1LL;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v20 = gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
      return 1LL;
    }
    uint64_t v26 = *(void *)(a1 + 40);
    if (v26) {
      __int16 v27 = (const char *)(v26 + 531);
    }
    else {
      __int16 v27 = "";
    }
    if (v26) {
      uint64_t v28 = " ";
    }
    else {
      uint64_t v28 = "";
    }
    int v29 = nw_frame_unclaimed_length(a2);
    *(_DWORD *)int buf = 136446722;
    uint64_t v33 = v27;
    __int16 v34 = 2080;
    uint64_t v35 = v28;
    __int16 v36 = 1024;
    int v37 = v29;
    int v16 = "%{public}s%sFrame did not contain expected IP version, too short for IPv6 (%u)";
    goto LABEL_47;
  }

  if (*(_BYTE *)nw_frame_unclaimed_bytes((uint64_t)a2, &v30) != 6)
  {
    uint64_t v10 = *(void *)(a1 + 40);
    if (!v10 || (*(_BYTE *)(v10 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v11 = gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = *(void *)(a1 + 40);
        BOOL v13 = v12 == 0;
        if (v12) {
          uint64_t v14 = (const char *)(v12 + 531);
        }
        else {
          uint64_t v14 = "";
        }
        __int16 v15 = " ";
        if (v13) {
          __int16 v15 = "";
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v33 = v14;
        __int16 v34 = 2080;
        uint64_t v35 = v15;
        int v16 = "%{public}s%sFrame did not contain expected IP version";
        os_log_type_t v17 = (os_log_s *)v11;
        uint32_t v18 = 22;
        goto LABEL_48;
      }
    }
  }

  return 1LL;
}

uint64_t ___ZL45nw_protocol_masque_listener_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  unsigned int v28 = 0;
  int v4 = (_BYTE *)nw_frame_unclaimed_bytes(a2, &v28);
  uint64_t v5 = v4;
  int v6 = *(unsigned __int8 *)(a1 + 72);
  if (v6 == 2)
  {
    if (v28 <= 6)
    {
      uint64_t v14 = *(void *)(a1 + 40);
      if (v14 && (*(_BYTE *)(v14 + 529) & 1) != 0) {
        goto LABEL_38;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      int v8 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_38;
      }
      uint64_t v15 = *(void *)(a1 + 40);
      uint64_t v10 = "";
      BOOL v16 = v15 == 0;
      if (v15) {
        uint64_t v12 = (const char *)(v15 + 531);
      }
      else {
        uint64_t v12 = "";
      }
      unsigned int v13 = v28;
      *(_DWORD *)int buf = 136446722;
      if (!v16) {
        uint64_t v10 = " ";
      }
      goto LABEL_37;
    }

    _BYTE *v4 = 4;
    uint64_t address = nw_endpoint_get_address(*(nw_endpoint_t *)(*(void *)(a1 + 56) + 16LL));
    *(_DWORD *)(v5 + 1) = *(_DWORD *)&address->sa_data[2];
    *(_WORD *)(v5 + 5) = *(_WORD *)address->sa_data;
    uint64_t v24 = a2;
    int v25 = 7;
LABEL_44:
    nw_frame_claim(v24, v23, v25, 0);
    return 1LL;
  }

  if (v6 != 30)
  {
    uint64_t v17 = *(void *)(a1 + 40);
    if (v17 && (*(_BYTE *)(v17 + 529) & 1) != 0) {
      goto LABEL_38;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    int v8 = (os_log_s *)gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    uint64_t v18 = *(void *)(a1 + 40);
    uint64_t v10 = "";
    BOOL v19 = v18 == 0;
    if (v18) {
      uint64_t v12 = (const char *)(v18 + 531);
    }
    else {
      uint64_t v12 = "";
    }
    unsigned int v13 = v28;
    *(_DWORD *)int buf = 136446722;
    if (!v19) {
      uint64_t v10 = " ";
    }
    goto LABEL_37;
  }

  if (v28 > 0x12)
  {
    _BYTE *v4 = 6;
    id v22 = nw_endpoint_get_address(*(nw_endpoint_t *)(*(void *)(a1 + 56) + 16LL));
    *(sockaddr *)(v5 + 1) = *(sockaddr *)&v22->sa_data[6];
    *(_WORD *)(v5 + 17) = *(_WORD *)v22->sa_data;
    uint64_t v24 = a2;
    int v25 = 19;
    goto LABEL_44;
  }

  uint64_t v7 = *(void *)(a1 + 40);
  if (v7 && (*(_BYTE *)(v7 + 529) & 1) != 0) {
    goto LABEL_38;
  }
  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
  }
  int v8 = (os_log_s *)gprivacy_proxyLogObj;
  if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
    goto LABEL_38;
  }
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = "";
  BOOL v11 = v9 == 0;
  if (v9) {
    uint64_t v12 = (const char *)(v9 + 531);
  }
  else {
    uint64_t v12 = "";
  }
  unsigned int v13 = v28;
  *(_DWORD *)int buf = 136446722;
  if (!v11) {
    uint64_t v10 = " ";
  }
LABEL_37:
  int v30 = v12;
  __int16 v31 = 2080;
  __int16 v32 = v10;
  __int16 v33 = 1024;
  unsigned int v34 = v13;
  _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s%sFrame is too short for header (%u)", buf, 0x1Cu);
LABEL_38:
  uint64_t v20 = *(void *)(a2 + 32);
  uint64_t v21 = *(void **)(a2 + 40);
  if (v20)
  {
    *(void *)(v20 + 40) = v21;
    uint64_t v21 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 48) + 8LL) = v21;
  }

  *uint64_t v21 = v20;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  --*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  return 1LL;
}

uint64_t ___ZL31nw_protocol_masque_disconnectedP11nw_protocolS0__block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 160);
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 24);
      if (v4)
      {
        uint64_t v5 = *(void (**)(void))(v4 + 8);
        if (v5) {
          v5();
        }
      }
    }

    uint64_t result = *(void *)(v2 + 224);
    if (result)
    {
      uint64_t v6 = *(void *)(result + 24);
      if (v6)
      {
        uint64_t v7 = *(uint64_t (**)(void))(v6 + 8);
        if (v7) {
          return v7();
        }
      }
    }
  }

  return result;
}

uint64_t ___ZL34nw_masque_save_connection_metadataP9nw_masqueP11nw_protocol_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  if (nw_protocol_metadata_is_http_connection(a3)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a3;
  }
  return 1LL;
}

uint64_t ___ZL31nw_masque_options_get_fast_openP19nw_protocol_options_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a2 + 33);
}

void nw_masque_protocol_destroy(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (*(void *)(a1 + 40) != a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_protocol_destroy";
    uint64_t v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v2))
    {
      __break(1u);
LABEL_63:
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      goto LABEL_60;
    }

    free(v2);
  }

  if ((*(_BYTE *)(a1 + 529) & 1) != 0 || !gLogDatapath) {
    goto LABEL_6;
  }
  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
    goto LABEL_63;
  }
LABEL_60:
  unsigned int v34 = (os_log_s *)gprivacy_proxyLogObj;
  if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_masque_protocol_destroy";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 531;
    *(_WORD *)&_BYTE buf[22] = 2080;
    int v37 = " ";
    _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDestroying protocol", buf, 0x20u);
  }

uint64_t ___ZL26nw_masque_protocol_destroyP9nw_masque_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t extra = (uint64_t *)nw_hash_node_get_extra(a2);
  uint64_t v3 = *extra;
  if (*extra)
  {
    do
    {
      uint64_t v4 = *(void *)(v3 + 32);
      nw_frame_finalize(v3);
      uint64_t v3 = v4;
    }

    while (v4);
  }

  uint64_t v5 = (void *)extra[2];
  if (v5)
  {
    os_release(v5);
    extra[2] = 0LL;
  }

  return 1LL;
}

double ___ZL38nw_protocol_masque_listener_identifierv_block_invoke()
{
  qword_18C5941A0 = 0LL;
  unk_18C5941A8 = 0LL;
  strcpy((char *)&nw_protocol_masque_listener_identifier(void)::g_masque_protocol_identifier, "masque_listener");
  *(void *)&double result = 0x200000005LL;
  qword_18C5941B0 = 0x200000005LL;
  return result;
}

BOOL nw_masque_add_additional_demux_pattern(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  BOOL is_masque = nw_protocol_metadata_is_masque(a1);
  if (is_masque)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 0x40000000LL;
    v12[2] = __nw_masque_add_additional_demux_pattern_block_invoke;
    v12[3] = &__block_descriptor_tmp_10_28077;
    void v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)a1, (uint64_t)v12);
    return is_masque;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_masque_add_additional_demux_pattern";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v16 = "nw_masque_add_additional_demux_pattern";
      uint64_t v9 = "%{public}s called with null nw_protocol_metadata_is_masque(metadata)";
      goto LABEL_17;
    }

    if (!v13)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v16 = "nw_masque_add_additional_demux_pattern";
      uint64_t v9 = "%{public}s called with null nw_protocol_metadata_is_masque(metadata), backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v16 = "nw_masque_add_additional_demux_pattern";
        __int16 v17 = 2082;
        uint64_t v18 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null nw_protocol_metadata_is_masque(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v11)
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v16 = "nw_masque_add_additional_demux_pattern";
      uint64_t v9 = "%{public}s called with null nw_protocol_metadata_is_masque(metadata), no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

BOOL nw_protocol_metadata_is_masque(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = a1;
    id v2 = v1[1];

    else {
      uint64_t v3 = 0LL;
    }
    return nw_protocol_definition_is_equal_unsafe((uint64_t)v2, (uint64_t)v3);
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_protocol_metadata_is_masque";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_metadata_is_masque";
        os_log_type_t v8 = "%{public}s called with null metadata";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_protocol_metadata_is_masque";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_metadata_is_masque";
        os_log_type_t v8 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_metadata_is_masque";
        os_log_type_t v8 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }

uint64_t __nw_masque_add_additional_demux_pattern_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 8));
  uint64_t v5 = *(void *)a2;
  nw_masque_send_demux_options(v5, *(void **)(a1 + 32), 0);
  uint64_t v6 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(v5 + 320));
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  v9[2] = __nw_masque_add_additional_demux_pattern_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_9_28078;
  uint64_t v7 = *(void *)(a1 + 32);
  void v9[4] = v5;
  void v9[5] = v7;
  nw_protocol_stack_iterate_application_protocols(v6, v9);
  os_unfair_lock_unlock(v4);
  return 1LL;
}

void __nw_masque_add_additional_demux_pattern_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  protocol_uint64_t handle = nw_protocol_options_get_protocol_handle(a2);
  uint64_t v5 = *(void *)(a1 + 32);
  if (protocol_handle == *(void *)(v5 + 432))
  {
    if ((*(_BYTE *)(v5 + 529) & 1) == 0)
    {
      uint64_t v6 = protocol_handle;
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      uint64_t v7 = (os_log_s *)gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v8 = *(void *)(a1 + 32);
        BOOL v9 = v8 == 0;
        if (v8) {
          BOOL v10 = (const char *)(v8 + 531);
        }
        else {
          BOOL v10 = "";
        }
        *(_DWORD *)int buf = 136446722;
        __int16 v15 = v10;
        char v11 = " ";
        if (v9) {
          char v11 = "";
        }
        __int16 v16 = 2080;
        uint64_t v17 = v11;
        __int16 v18 = 2048;
        uint64_t v19 = v6;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s%sFound lower demux protocol %p, registering options",  buf,  0x20u);
      }
    }

    uint64_t v12 = *(void **)(a1 + 40);
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 0x40000000LL;
    v13[2] = __nw_masque_add_additional_demux_pattern_block_invoke_5;
    v13[3] = &__block_descriptor_tmp_7_28080;
    void v13[4] = a2;
    nw_demux_options_enumerate_patterns(v12, (uint64_t)v13);
  }

uint64_t __nw_masque_add_additional_demux_pattern_block_invoke_5( uint64_t a1, unsigned int a2, __int16 a3, uint64_t a4, uint64_t a5)
{
  return 1LL;
}

void *nw_protocol_masque_copy_definition()
{
  if (nw_protocol_masque_get_definition(void)::definition
    && (id v0 = os_retain((void *)nw_protocol_masque_get_definition(void)::definition)) != 0LL)
  {
    return os_retain(v0);
  }

  else
  {
    return 0LL;
  }

void *nw_protocol_masque_listener_copy_definition()
{
  if (nw_protocol_masque_listener_get_definition(void)::definition
    && (id v0 = os_retain((void *)nw_protocol_masque_listener_get_definition(void)::definition)) != 0LL)
  {
    return os_retain(v0);
  }

  else
  {
    return 0LL;
  }

BOOL nw_protocol_options_is_masque(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    else {
      id v2 = 0LL;
    }
    if (nw_protocol_options_matches_definition(a1, v2)) {
      return 1LL;
    }
    else {
      uint64_t v4 = 0LL;
    }
    return nw_protocol_options_matches_definition(a1, v4);
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_protocol_options_is_masque";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_options_is_masque";
        uint64_t v8 = "%{public}s called with null options";
LABEL_28:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_protocol_options_is_masque";
          __int16 v15 = 2082;
          __int16 v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_options_is_masque";
        uint64_t v8 = "%{public}s called with null options, no backtrace";
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v14 = "nw_protocol_options_is_masque";
        uint64_t v8 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_28;
      }
    }
  }

BOOL nw_protocol_options_is_masque_listener(void *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    else {
      id v2 = 0LL;
    }
    return nw_protocol_options_matches_definition(a1, v2);
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  char v13 = "nw_protocol_options_is_masque_listener";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v13 = "nw_protocol_options_is_masque_listener";
        os_log_type_t v7 = "%{public}s called with null options";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          char v13 = "nw_protocol_options_is_masque_listener";
          __int16 v14 = 2082;
          __int16 v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        char v13 = "nw_protocol_options_is_masque_listener";
        os_log_type_t v7 = "%{public}s called with null options, no backtrace";
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v13 = "nw_protocol_options_is_masque_listener";
        os_log_type_t v7 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }

void nw_masque_options_set_target_endpoint(void *a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    v8[2] = __nw_masque_options_set_target_endpoint_block_invoke;
    void v8[3] = &__block_descriptor_tmp_11_28105;
    v8[4] = a2;
    nw_protocol_options_access_handle(a1, v8);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v12 = "nw_masque_options_set_target_endpoint";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v10 = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v2, &v10, &v9))
  {
    if (v10 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v10;
      if (!os_log_type_enabled(v3, v10)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v12 = "nw_masque_options_set_target_endpoint";
      uint64_t v5 = "%{public}s called with null options";
      goto LABEL_17;
    }

    if (!v9)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v10;
      if (!os_log_type_enabled(v3, v10)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v12 = "nw_masque_options_set_target_endpoint";
      uint64_t v5 = "%{public}s called with null options, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = v10;
    BOOL v7 = os_log_type_enabled(v3, v10);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v12 = "nw_masque_options_set_target_endpoint";
        __int16 v13 = 2082;
        __int16 v14 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v12 = "nw_masque_options_set_target_endpoint";
      uint64_t v5 = "%{public}s called with null options, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t __nw_masque_options_set_target_endpoint_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3) {
    uint64_t v3 = os_retain(v3);
  }
  *a2 = v3;
  return 1LL;
}

uint64_t nw_masque_options_copy_target_endpoint(void *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)int buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000LL;
    uint64_t v13 = 0LL;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 0x40000000LL;
    v9[2] = __nw_masque_options_copy_target_endpoint_block_invoke;
    v9[3] = &unk_189BBA160;
    void v9[4] = buf;
    nw_protocol_options_access_handle(a1, v9);
    uint64_t v1 = *(void *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    return v1;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_options_copy_target_endpoint";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_copy_target_endpoint";
        os_log_type_t v6 = "%{public}s called with null options";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_options_copy_target_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v8)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_copy_target_endpoint";
        os_log_type_t v6 = "%{public}s called with null options, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_options_copy_target_endpoint";
        os_log_type_t v6 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void nw_masque_options_set_forced_protocol(void *a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    v8[2] = __nw_masque_options_set_forced_protocol_block_invoke;
    void v8[3] = &__block_descriptor_tmp_13_28116;
    int v9 = a2;
    nw_protocol_options_access_handle(a1, v8);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v13 = "nw_masque_options_set_forced_protocol";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v11 = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v2, &v11, &v10))
  {
    if (v11 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v11;
      if (!os_log_type_enabled(v3, v11)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_forced_protocol";
      os_log_type_t v5 = "%{public}s called with null options";
      goto LABEL_17;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v11;
      if (!os_log_type_enabled(v3, v11)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_forced_protocol";
      os_log_type_t v5 = "%{public}s called with null options, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = v11;
    BOOL v7 = os_log_type_enabled(v3, v11);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v13 = "nw_masque_options_set_forced_protocol";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_forced_protocol";
      os_log_type_t v5 = "%{public}s called with null options, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t __nw_masque_options_set_forced_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 2_Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

void nw_masque_options_set_allow_connect_ip(void *a1, char a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    v8[2] = __nw_masque_options_set_allow_connect_ip_block_invoke;
    void v8[3] = &__block_descriptor_tmp_14_28122;
    char v9 = a2;
    nw_protocol_options_access_handle(a1, v8);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v13 = "nw_masque_options_set_allow_connect_ip";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v11 = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v2, &v11, &v10))
  {
    if (v11 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v11;
      if (!os_log_type_enabled(v3, v11)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_allow_connect_ip";
      os_log_type_t v5 = "%{public}s called with null options";
      goto LABEL_17;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v11;
      if (!os_log_type_enabled(v3, v11)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_allow_connect_ip";
      os_log_type_t v5 = "%{public}s called with null options, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = v11;
    BOOL v7 = os_log_type_enabled(v3, v11);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v13 = "nw_masque_options_set_allow_connect_ip";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_allow_connect_ip";
      os_log_type_t v5 = "%{public}s called with null options, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t __nw_masque_options_set_allow_connect_ip_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 32) = *(_BYTE *)(a1 + 32);
  return 1LL;
}

void nw_masque_options_set_fast_open(void *a1, char a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    v8[2] = __nw_masque_options_set_fast_open_block_invoke;
    void v8[3] = &__block_descriptor_tmp_15_28128;
    char v9 = a2;
    nw_protocol_options_access_handle(a1, v8);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v13 = "nw_masque_options_set_fast_open";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v11 = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v2, &v11, &v10))
  {
    if (v11 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v11;
      if (!os_log_type_enabled(v3, v11)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_fast_open";
      os_log_type_t v5 = "%{public}s called with null options";
      goto LABEL_17;
    }

    if (!v10)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v11;
      if (!os_log_type_enabled(v3, v11)) {
        goto LABEL_18;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_fast_open";
      os_log_type_t v5 = "%{public}s called with null options, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = v11;
    BOOL v7 = os_log_type_enabled(v3, v11);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v13 = "nw_masque_options_set_fast_open";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v13 = "nw_masque_options_set_fast_open";
      os_log_type_t v5 = "%{public}s called with null options, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t __nw_masque_options_set_fast_open_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 33) = *(_BYTE *)(a1 + 32);
  return 1LL;
}

void nw_masque_options_add_extra_header(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v17 = "nw_masque_options_add_extra_header";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v15 = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (v15 != OS_LOG_TYPE_FAULT)
    {
      if (!v14)
      {
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = v15;
        if (!os_log_type_enabled(v4, v15)) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_masque_options_add_extra_header";
        os_log_type_t v6 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_46;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = v15;
      BOOL v8 = os_log_type_enabled(v4, v15);
      if (!backtrace_string)
      {
        if (!v8) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_masque_options_add_extra_header";
        os_log_type_t v6 = "%{public}s called with null options, no backtrace";
        goto LABEL_46;
      }

      if (v8)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v17 = "nw_masque_options_add_extra_header";
        __int16 v18 = 2082;
        uint64_t v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_47;
    }

    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = v15;
    if (!os_log_type_enabled(v4, v15)) {
      goto LABEL_47;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v17 = "nw_masque_options_add_extra_header";
    os_log_type_t v6 = "%{public}s called with null options";
LABEL_46:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_47;
  }

  if (a2)
  {
    if (a3)
    {
      v13[0] = MEMORY[0x1895F87A8];
      v13[1] = 0x40000000LL;
      v13[2] = __nw_masque_options_add_extra_header_block_invoke;
      v13[3] = &__block_descriptor_tmp_16_28144;
      void v13[4] = a2;
      void v13[5] = a3;
      nw_protocol_options_access_handle(a1, v13);
      return;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v17 = "nw_masque_options_add_extra_header";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v15 = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v3, &v15, &v14))
    {
      if (v15 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = v15;
        if (!os_log_type_enabled(v4, v15)) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_masque_options_add_extra_header";
        os_log_type_t v6 = "%{public}s called with null value";
        goto LABEL_46;
      }

      if (!v14)
      {
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = v15;
        if (!os_log_type_enabled(v4, v15)) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_masque_options_add_extra_header";
        os_log_type_t v6 = "%{public}s called with null value, backtrace limit exceeded";
        goto LABEL_46;
      }

      char v9 = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = v15;
      BOOL v12 = os_log_type_enabled(v4, v15);
      if (!v9)
      {
        if (!v12) {
          goto LABEL_47;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v17 = "nw_masque_options_add_extra_header";
        os_log_type_t v6 = "%{public}s called with null value, no backtrace";
        goto LABEL_46;
      }

      if (v12)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v17 = "nw_masque_options_add_extra_header";
        __int16 v18 = 2082;
        uint64_t v19 = v9;
        os_log_type_t v11 = "%{public}s called with null value, dumping backtrace:%{public}s";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

uint64_t __nw_masque_options_add_extra_header_block_invoke(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = *(xpc_object_t *)(a2 + 8);
  if (!v4)
  {
    xpc_object_t v4 = xpc_array_create(0LL, 0LL);
    *(void *)(a2 + _Block_object_dispose(va, 8) = v4;
    if (*(void *)(a2 + 16)) {
      goto LABEL_3;
    }
LABEL_5:
    *(void *)(a2 + 16) = xpc_array_create(0LL, 0LL);
    xpc_object_t v4 = *(xpc_object_t *)(a2 + 8);
    goto LABEL_3;
  }

  if (!*(void *)(a2 + 16)) {
    goto LABEL_5;
  }
LABEL_3:
  xpc_array_set_string(v4, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 32));
  xpc_array_set_string(*(xpc_object_t *)(a2 + 16), 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 40));
  return 1LL;
}

void nw_masque_options_set_version(void *a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if ((a2 - 3) > 0xFFFFFFFD)
    {
      v10[0] = MEMORY[0x1895F87A8];
      v10[1] = 0x40000000LL;
      v10[2] = __nw_masque_options_set_version_block_invoke;
      v10[3] = &__block_descriptor_tmp_17_28155;
      int v11 = a2;
      nw_protocol_options_access_handle(a1, v10);
      return;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v15 = "nw_masque_options_set_version";
    id v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v13 = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (__nwlog_fault(v2, &v13, &v12))
    {
      if (v13 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = v13;
        if (!os_log_type_enabled(v3, v13)) {
          goto LABEL_33;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_options_set_version";
        os_log_type_t v5 = "%{public}s called with null (version == nw_masque_version_draft_03 || version == nw_masque_version_rfc9298)";
        goto LABEL_32;
      }

      if (!v12)
      {
        uint64_t v3 = (os_log_s *)__nwlog_obj();
        os_log_type_t v4 = v13;
        if (!os_log_type_enabled(v3, v13)) {
          goto LABEL_33;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_options_set_version";
        os_log_type_t v5 = "%{public}s called with null (version == nw_masque_version_draft_03 || version == nw_masque_version_rfc9298)"
             ", backtrace limit exceeded";
        goto LABEL_32;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v13;
      BOOL v9 = os_log_type_enabled(v3, v13);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v15 = "nw_masque_options_set_version";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null (version == nw_masque_version_draft_03 || version == nw_masque_version_rfc9298), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }

      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v15 = "nw_masque_options_set_version";
        os_log_type_t v5 = "%{public}s called with null (version == nw_masque_version_draft_03 || version == nw_masque_version_rfc9298), no backtrace";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v15 = "nw_masque_options_set_version";
    id v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v13 = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (v13 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v13;
      if (!os_log_type_enabled(v3, v13)) {
        goto LABEL_33;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_masque_options_set_version";
      os_log_type_t v5 = "%{public}s called with null options";
      goto LABEL_32;
    }

    if (!v12)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = v13;
      if (!os_log_type_enabled(v3, v13)) {
        goto LABEL_33;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_masque_options_set_version";
      os_log_type_t v5 = "%{public}s called with null options, backtrace limit exceeded";
      goto LABEL_32;
    }

    os_log_type_t v6 = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = v13;
    BOOL v7 = os_log_type_enabled(v3, v13);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v15 = "nw_masque_options_set_version";
      os_log_type_t v5 = "%{public}s called with null options, no backtrace";
      goto LABEL_32;
    }

    if (v7)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v15 = "nw_masque_options_set_version";
      __int16 v16 = 2082;
      uint64_t v17 = v6;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v6);
  }

uint64_t __nw_masque_options_set_version_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

NWConcrete_nw_protocol_options *nw_masque_options_copy_listener_options(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v2 = (void *)nw_protocol_masque_listener_get_definition(void)::definition;
    if (nw_protocol_masque_listener_get_definition(void)::definition)
    {
      id v2 = os_retain((void *)nw_protocol_masque_listener_get_definition(void)::definition);
      if (v2) {
        id v2 = os_retain(v2);
      }
    }

    nw_protocol_options_t options = nw_proxy_create_options(v2);
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 0x40000000LL;
    v15[2] = __nw_masque_options_copy_listener_options_block_invoke;
    v15[3] = &__block_descriptor_tmp_20_28161;
    void v15[4] = options;
    nw_protocol_options_access_handle(a1, v15);
    os_log_type_t v4 = a1;
    id v5 = v4[3];

    os_log_type_t v6 = v4;
    if (v4[3]) {
      char v7 = *((_BYTE *)v6 + 152) != 0;
    }
    else {
      char v7 = 0;
    }

    nw_protocol_options_set_proxy_endpoint(options, v5, v7);
    return options;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v19 = "nw_masque_options_copy_listener_options";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = v17;
      if (os_log_type_enabled(v10, v17))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v19 = "nw_masque_options_copy_listener_options";
        char v12 = "%{public}s called with null options";
LABEL_25:
        _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = v17;
      BOOL v14 = os_log_type_enabled(v10, v17);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v19 = "nw_masque_options_copy_listener_options";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v19 = "nw_masque_options_copy_listener_options";
        char v12 = "%{public}s called with null options, no backtrace";
        goto LABEL_25;
      }
    }

    else
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = v17;
      if (os_log_type_enabled(v10, v17))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v19 = "nw_masque_options_copy_listener_options";
        char v12 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_25;
      }
    }
  }

uint64_t __nw_masque_options_copy_listener_options_block_invoke(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = __nw_masque_options_copy_listener_options_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_19_28162;
  void v4[4] = a2;
  return nw_protocol_options_access_handle(v2, v4);
}

uint64_t __nw_masque_options_copy_listener_options_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  os_log_type_t v4 = *(void **)v3;
  if (*(void *)v3) {
    os_log_type_t v4 = os_retain(v4);
  }
  *(void *)a2 = v4;
  id v5 = *(void **)(v3 + 8);
  if (v5) {
    *(void *)(a2 + _Block_object_dispose(va, 8) = xpc_copy(v5);
  }
  os_log_type_t v6 = *(void **)(v3 + 16);
  if (v6) {
    *(void *)(a2 + 16) = xpc_copy(v6);
  }
  *(void *)(a2 + 24) = *(void *)(v3 + 24);
  *(_WORD *)(a2 + 32) = *(_WORD *)(v3 + 32);
  return 1LL;
}

void sub_182029B54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182029C10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182029E2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182029FB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18202B6EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18202B78C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18202B834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18202B8D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__28306(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__28307(uint64_t a1)
{
}

void sub_18202CE80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_18202D1E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL nw_protocol_http_security_create(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v5 = (char *)calloc(1uLL, 0x278uLL);
  if (!v5)
  {
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    char v16 = "strict_calloc";
    __int16 v17 = 2048;
    uint64_t v18 = 1LL;
    __int16 v19 = 2048;
    uint64_t v20 = 632LL;
    uint64_t v13 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v13);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v13);
  }

  bzero(v5, 0x278uLL);
  if (gLogDatapath)
  {
    BOOL v14 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446722;
      char v16 = "nw_protocol_http_security_create";
      __int16 v17 = 2082;
      uint64_t v18 = (uint64_t)(v5 + 114);
      __int16 v19 = 2080;
      uint64_t v20 = (uint64_t)" ";
      _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
    }
  }

  if (nw_protocol_http_security_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http_security_identifier::onceToken, &__block_literal_global_28437);
  }
  *((void *)v5 + 2) = nw_protocol_http_security_identifier::protocol_identifier;
  *((void *)v5 + 3) = &nw_protocol_http_security_get_callbacks(void)::protocol_callbacks;
  *((void *)v5 + 5) = v5;
  id v6 = nw_parameters_copy_context(a4);
  char v7 = v5[616];
  if ((v7 & 1) != 0)
  {
    BOOL v8 = (void *)*((void *)v5 + 76);
    if (v8)
    {
      os_release(v8);
      char v7 = v5[616];
    }
  }

  *((void *)v5 + 76) = v6;
  v5[616] = v7 | 1;
  char server_mode = nw_parameters_get_server_mode(a4);
  *((void *)v5 + 25) = 0LL;
  v5[624] = v5[624] & 0xFE | server_mode;
  *((void *)v5 + 9) = v5 + 200;
  *((void *)v5 + 26) = v5 + 200;
  *((void *)v5 + 27) = 0LL;
  *((void *)v5 + 2_Block_object_dispose(va, 8) = v5 + 216;
  *((void *)v5 + 29) = 0LL;
  *((void *)v5 + 30) = v5 + 232;
  v5[340] = 2;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  id v10 = (id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_plugin_metadata_set_callbacks( (uint64_t)v5,  v10,  (uint64_t)nw_protocol_http_security_create::$_0::__invoke,  (uint64_t)nw_protocol_http_security_create::$_1::__invoke);
  if (v10) {
    os_release(v10);
  }
  *((void *)v5 + 11) = v5 + 344;
  nw_protocol_plugin_retry_set_callbacks( (uint64_t)v5,  (uint64_t)nw_protocol_http_security_create::$_2::__invoke,  (uint64_t)nw_protocol_http_security_create::$_3::__invoke,  (uint64_t)nw_protocol_http_security_create::$_4::__invoke,  (uint64_t)nw_protocol_http_security_create::$_5::__invoke);
  *((void *)v5 + _Block_object_dispose(va, 8) = v5 + 104;
  nw_protocol_plugin_name_set_callbacks((uint64_t)v5, (uint64_t)nw_protocol_http_security_create::$_6::__invoke);
  return (BOOL)v5;
}

void nw_protocol_http_security_create::$_0::__invoke( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "operator()";
    int v29 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v81) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v81 != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        int v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = v81;
        if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
          goto LABEL_119;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "operator()";
        __int16 v32 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_118;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = v81;
      BOOL v34 = os_log_type_enabled(v30, (os_log_type_t)v81);
      if (!backtrace_string)
      {
        if (!v34) {
          goto LABEL_119;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "operator()";
        __int16 v32 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_118;
      }

      if (v34)
      {
        *(_DWORD *)block = 136446466;
        *(void *)&void block[4] = "operator()";
        *(_WORD *)&block[12] = 2082;
        *(void *)&block[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  block,  0x16u);
      }

      free(backtrace_string);
LABEL_119:
      if (v29) {
        goto LABEL_120;
      }
      return;
    }

    int v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = v81;
    if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
      goto LABEL_119;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "operator()";
    __int16 v32 = "%{public}s called with null protocol";
    goto LABEL_118;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "operator()";
    int v29 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v81) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v81 != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        int v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = v81;
        if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
          goto LABEL_119;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "operator()";
        __int16 v32 = "%{public}s called with null http_security, backtrace limit exceeded";
        goto LABEL_118;
      }

      uint64_t v35 = (char *)__nw_create_backtrace_string();
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = v81;
      BOOL v36 = os_log_type_enabled(v30, (os_log_type_t)v81);
      if (!v35)
      {
        if (!v36) {
          goto LABEL_119;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "operator()";
        __int16 v32 = "%{public}s called with null http_security, no backtrace";
        goto LABEL_118;
      }

      if (!v36) {
        goto LABEL_94;
      }
      *(_DWORD *)block = 136446466;
      *(void *)&void block[4] = "operator()";
      *(_WORD *)&block[12] = 2082;
      *(void *)&block[14] = v35;
      int v37 = "%{public}s called with null http_security, dumping backtrace:%{public}s";
      goto LABEL_93;
    }

    int v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = v81;
    if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
      goto LABEL_119;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "operator()";
    __int16 v32 = "%{public}s called with null http_security";
LABEL_118:
    _os_log_impl(&dword_181A5C000, v30, v31, v32, block, 0xCu);
    goto LABEL_119;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "operator()";
    int v29 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v81) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v81 != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        int v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = v81;
        if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
          goto LABEL_119;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "operator()";
        __int16 v32 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_118;
      }

      uint64_t v35 = (char *)__nw_create_backtrace_string();
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = v81;
      BOOL v38 = os_log_type_enabled(v30, (os_log_type_t)v81);
      if (!v35)
      {
        if (!v38) {
          goto LABEL_119;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "operator()";
        __int16 v32 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_118;
      }

      if (!v38) {
        goto LABEL_94;
      }
      *(_DWORD *)block = 136446466;
      *(void *)&void block[4] = "operator()";
      *(_WORD *)&block[12] = 2082;
      *(void *)&block[14] = v35;
      int v37 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_93;
    }

    int v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = v81;
    if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
      goto LABEL_119;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "operator()";
    __int16 v32 = "%{public}s called with null other_protocol";
    goto LABEL_118;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "operator()";
    int v29 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v81) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v81 == 17)
    {
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = v81;
      if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
        goto LABEL_119;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&void block[4] = "operator()";
      __int16 v32 = "%{public}s called with null metadata";
      goto LABEL_118;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = v81;
      if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
        goto LABEL_119;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&void block[4] = "operator()";
      __int16 v32 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_118;
    }

    uint64_t v35 = (char *)__nw_create_backtrace_string();
    int v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = v81;
    BOOL v39 = os_log_type_enabled(v30, (os_log_type_t)v81);
    if (!v35)
    {
      if (!v39) {
        goto LABEL_119;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&void block[4] = "operator()";
      __int16 v32 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_118;
    }

    if (!v39) {
      goto LABEL_94;
    }
    *(_DWORD *)block = 136446466;
    *(void *)&void block[4] = "operator()";
    *(_WORD *)&block[12] = 2082;
    *(void *)&block[14] = v35;
    int v37 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_93:
    _os_log_impl(&dword_181A5C000, v30, v31, v37, block, 0x16u);
    goto LABEL_94;
  }

  if (a5)
  {
    if ((*(_BYTE *)(v5 + 624) & 1) != 0) {
      goto LABEL_50;
    }
    if ((*(_BYTE *)(v5 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint32_t v41 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)block = 136446722;
          *(void *)&void block[4] = "nw_http_security_process_response";
          *(_WORD *)&block[12] = 2082;
          *(void *)&block[14] = v5 + 114;
          *(_WORD *)&block[22] = 2080;
          nw_endpoint_t v89 = " ";
          _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", block, 0x20u);
        }
      }
    }

    uint64_t v81 = 0LL;
    __int128 v82 = &v81;
    uint64_t v83 = 0x3802000000LL;
    uint64_t v84 = __Block_byref_object_copy__28532;
    unsigned int v85 = __Block_byref_object_dispose__28533;
    id v86 = nw_http_metadata_copy_response(a3);
    v87 |= 1u;
    BOOL v8 = (void *)v82[5];
    if (v8)
    {
      id v9 = v8;
      int have_field_with_name = _nw_http_fields_have_field_with_name( (uint64_t)v9,  (unint64_t)"Strict-Transport-Security");

      if (!have_field_with_name)
      {
LABEL_34:
        BOOL v18 = nw_http_fields_copy_value_by_name((void *)v82[5], (uint64_t)"Alt-Svc");
        if (!v18) {
          goto LABEL_47;
        }
        __int16 v19 = (const char *)v18;
        if (*(void *)(v5 + 592))
        {
          uint64_t remote_endpoint = (void *)nw_protocol_get_remote_endpoint(v5);
          else {
            uint64_t v21 = 0LL;
          }
          hostname = nw_endpoint_get_hostname(v21);
          unsigned int port = nw_endpoint_get_port(v21);
          parameters = (void *)nw_protocol_get_parameters(v5);
          main_document_nw_endpoint_t url = nw_parameters_get_main_document_url(parameters);
          *(void *)__int128 v61 = 0LL;
          __int128 v62 = v61;
          uint64_t v63 = 0x2000000000LL;
          __int128 v64 = 0LL;
          uint64_t v26 = (unsigned __int8 *)nw_protocol_copy_info(*(void *)(v5 + 32), 255);
          *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
          uint64_t v75 = 0x40000000LL;
          uint64_t v76 = (uint64_t)___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_29;
          uint64_t v77 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BBAFD8;
          os_log_type_t v78 = v61;
          nw_array_apply(v26, (uint64_t)type);
          __int16 v27 = (void *)*((void *)v62 + 3);
          if (v27) {
            nw_http_alt_svc_parse_and_set(*(void **)(v5 + 592), hostname, port, v19, main_document_url, v27);
          }
          if (v26) {
            os_release(v26);
          }
          _Block_object_dispose(v61, 8);
          if (v21) {
            os_release(v21);
          }
        }

        unsigned int v28 = (char *)v19;
        goto LABEL_46;
      }

      uint64_t v11 = (void *)nw_protocol_get_parameters(v5);
      if ((nw_parameters_is_third_party_web_content(v11) & 1) != 0) {
        goto LABEL_47;
      }
      uint64_t v12 = (unsigned __int8 *)nw_protocol_copy_info(*(void *)(v5 + 32), 255);
      *(void *)os_log_type_t type = 0LL;
      uint64_t v75 = (uint64_t)type;
      uint64_t v76 = 0x3802000000LL;
      uint64_t v77 = __Block_byref_object_copy__12_28539;
      os_log_type_t v78 = (os_log_type_t *)__Block_byref_object_dispose__13_28540;
      uint64_t v79 = 0LL;
      uint64_t v13 = MEMORY[0x1895F87A8];
      v80 |= 1u;
      v73[0] = MEMORY[0x1895F87A8];
      v73[1] = 0x40000000LL;
      v73[2] = ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke;
      v73[3] = &unk_189BBAF18;
      v73[4] = type;
      nw_array_apply(v12, (uint64_t)v73);
      if (!*(void *)(v75 + 40)) {
        goto LABEL_27;
      }
      BOOL v14 = nw_parameters_copy_protocol_options_legacy(v11, (nw_protocol *)v5);
      if (v14)
      {
        os_log_type_t v15 = v14;
        v68[0] = v13;
        v68[1] = 0x40000000LL;
        uint64_t v69 = ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_16;
        BOOL v70 = &unk_189BBAF60;
        uint64_t v71 = &v81;
        uint64_t v72 = v5;
        if (nw_http_security_options_get_save_hsts_with_untrusted_root_cert(v14))
        {
          v69((uint64_t)v68);
        }

        else
        {
          *(void *)__int128 v61 = 0LL;
          __int128 v62 = v61;
          uint64_t v63 = 0x3802000000LL;
          __int128 v64 = __Block_byref_object_copy__20;
          __int128 v65 = __Block_byref_object_dispose__21;
          __int128 v66 = (void *)sec_protocol_metadata_copy_sec_trust();
          v67 |= 1u;
          if (*((void *)v62 + 5))
          {
            uint64_t v54 = 0LL;
            __int128 v55 = &v54;
            uint64_t v56 = 0x3802000000LL;
            __int128 v57 = __Block_byref_object_copy__22;
            __int128 v58 = __Block_byref_object_dispose__23;
            dispatch_object_t object = dispatch_queue_create("http_security", 0LL);
            v60 |= 1u;
            nw_queue_context_target_dispatch_queue(*(void **)(v5 + 608), (void *)v55[5]);
            nw_protocol_plugin_retry_begin_async(v5 + 344);
            char v16 = (dispatch_queue_s *)v55[5];
            *(void *)block = v13;
            *(void *)&block[8] = 0x40000000LL;
            *(void *)&block[16] = ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_24;
            nw_endpoint_t v89 = (const char *)&unk_189BBAFB0;
            dispatch_data_t v90 = v68;
            unsigned int v91 = v61;
            uint64_t v92 = &v54;
            uint64_t v93 = v5;
            dispatch_async(v16, block);
            _Block_object_dispose(&v54, 8);
            if ((v60 & 1) != 0)
            {
              if (object) {
                dispatch_release(object);
              }
            }
          }

          _Block_object_dispose(v61, 8);
          if ((v67 & 1) != 0 && v66) {
            os_release(v66);
          }
        }

        os_release(v15);
LABEL_27:
        int v17 = 1;
        goto LABEL_28;
      }

      __nwlog_obj();
      *(_DWORD *)block = 136446210;
      *(void *)&void block[4] = "nw_http_security_process_response";
      uint64_t v48 = (char *)_os_log_send_and_compose_impl();
      v61[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v54) = 0;
      if (__nwlog_fault(v48, v61, &v54))
      {
        if (v61[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v49 = (os_log_s *)__nwlog_obj();
          os_log_type_t v50 = v61[0];
          if (os_log_type_enabled(v49, v61[0]))
          {
            *(_DWORD *)block = 136446210;
            *(void *)&void block[4] = "nw_http_security_process_response";
            char v51 = "%{public}s called with null protocol_options";
LABEL_150:
            _os_log_impl(&dword_181A5C000, v49, v50, v51, block, 0xCu);
          }
        }

        else if ((_BYTE)v54)
        {
          BOOL v52 = (char *)__nw_create_backtrace_string();
          uint64_t v49 = (os_log_s *)__nwlog_obj();
          os_log_type_t v50 = v61[0];
          BOOL v53 = os_log_type_enabled(v49, v61[0]);
          if (v52)
          {
            if (v53)
            {
              *(_DWORD *)block = 136446466;
              *(void *)&void block[4] = "nw_http_security_process_response";
              *(_WORD *)&block[12] = 2082;
              *(void *)&block[14] = v52;
              _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s called with null protocol_options, dumping backtrace:%{public}s",  block,  0x16u);
            }

            free(v52);
            goto LABEL_151;
          }

          if (v53)
          {
            *(_DWORD *)block = 136446210;
            *(void *)&void block[4] = "nw_http_security_process_response";
            char v51 = "%{public}s called with null protocol_options, no backtrace";
            goto LABEL_150;
          }
        }

        else
        {
          uint64_t v49 = (os_log_s *)__nwlog_obj();
          os_log_type_t v50 = v61[0];
          if (os_log_type_enabled(v49, v61[0]))
          {
            *(_DWORD *)block = 136446210;
            *(void *)&void block[4] = "nw_http_security_process_response";
            char v51 = "%{public}s called with null protocol_options, backtrace limit exceeded";
            goto LABEL_150;
          }
        }
      }

void nw_protocol_http_security_create::$_1::__invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        id v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v19 = "operator()";
        BOOL v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_58;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v10) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v19 = "operator()";
        BOOL v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_58;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v19 = "operator()";
        __int16 v20 = 2082;
        uint64_t v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_59:
      if (!v5) {
        return;
      }
      goto LABEL_60;
    }

    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    BOOL v8 = "%{public}s called with null protocol";
    goto LABEL_58;
  }

  if (!*(void *)(a1 + 40))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        id v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v19 = "operator()";
        BOOL v8 = "%{public}s called with null http_security, backtrace limit exceeded";
        goto LABEL_58;
      }

      uint64_t v11 = (char *)__nw_create_backtrace_string();
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (!v11)
      {
        if (!v12) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v19 = "operator()";
        BOOL v8 = "%{public}s called with null http_security, no backtrace";
        goto LABEL_58;
      }

      if (!v12) {
        goto LABEL_40;
      }
      *(_DWORD *)int buf = 136446466;
      __int16 v19 = "operator()";
      __int16 v20 = 2082;
      uint64_t v21 = v11;
      uint64_t v13 = "%{public}s called with null http_security, dumping backtrace:%{public}s";
      goto LABEL_39;
    }

    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    BOOL v8 = "%{public}s called with null http_security";
LABEL_58:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_59;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v19 = "operator()";
      BOOL v8 = "%{public}s called with null metadata";
      goto LABEL_58;
    }

    if (!v16)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v19 = "operator()";
      BOOL v8 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_58;
    }

    uint64_t v11 = (char *)__nw_create_backtrace_string();
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v14 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v14) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v19 = "operator()";
      BOOL v8 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_58;
    }

    if (!v14) {
      goto LABEL_40;
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v19 = "operator()";
    __int16 v20 = 2082;
    uint64_t v21 = v11;
    uint64_t v13 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v6, v7, v13, buf, 0x16u);
    goto LABEL_40;
  }

  if (a5)
  {
    (*(void (**)(uint64_t, uint64_t))(a5 + 16))(a5, 1LL);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v19 = "operator()";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    BOOL v8 = "%{public}s called with null completion";
    goto LABEL_58;
  }

  if (!v16)
  {
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    BOOL v8 = "%{public}s called with null completion, backtrace limit exceeded";
    goto LABEL_58;
  }

  uint64_t v11 = (char *)__nw_create_backtrace_string();
  id v6 = (os_log_s *)__nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v15 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v15) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v19 = "operator()";
    BOOL v8 = "%{public}s called with null completion, no backtrace";
    goto LABEL_58;
  }

  if (v15)
  {
    *(_DWORD *)int buf = 136446466;
    __int16 v19 = "operator()";
    __int16 v20 = 2082;
    uint64_t v21 = v11;
    uint64_t v13 = "%{public}s called with null completion, dumping backtrace:%{public}s";
    goto LABEL_39;
  }

uint64_t nw_protocol_http_security_create::$_2::__invoke( nw_protocol_http_security_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 0LL;
}

uint64_t nw_protocol_http_security_create::$_3::__invoke( nw_protocol_http_security_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v133 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    char v51 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v106[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = type[0];
      if (!os_log_type_enabled(v52, type[0])) {
        goto LABEL_162;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v54 = "%{public}s called with null protocol";
LABEL_161:
      _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
      goto LABEL_162;
    }

    if (v106[0] == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = type[0];
      if (os_log_type_enabled(v52, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v54 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_161;
      }

      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v52 = (os_log_s *)__nwlog_obj();
    os_log_type_t v53 = type[0];
    BOOL v56 = os_log_type_enabled(v52, type[0]);
    if (!backtrace_string)
    {
      if (v56)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v54 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_161;
      }

      goto LABEL_162;
    }

    if (!v56) {
      goto LABEL_118;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "operator()";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    __int128 v57 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_117:
    _os_log_impl(&dword_181A5C000, v52, v53, v57, buf, 0x16u);
    goto LABEL_118;
  }

  uint64_t v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    char v51 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v106[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = type[0];
      if (!os_log_type_enabled(v52, type[0])) {
        goto LABEL_162;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      uint64_t v54 = "%{public}s called with null http_security";
      goto LABEL_161;
    }

    if (v106[0] == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = type[0];
      if (os_log_type_enabled(v52, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v54 = "%{public}s called with null http_security, backtrace limit exceeded";
        goto LABEL_161;
      }

      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v52 = (os_log_s *)__nwlog_obj();
    os_log_type_t v53 = type[0];
    BOOL v58 = os_log_type_enabled(v52, type[0]);
    if (!backtrace_string)
    {
      if (v58)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v54 = "%{public}s called with null http_security, no backtrace";
        goto LABEL_161;
      }

      goto LABEL_162;
    }

    if (!v58) {
      goto LABEL_118;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "operator()";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    __int128 v57 = "%{public}s called with null http_security, dumping backtrace:%{public}s";
    goto LABEL_117;
  }

  if (a2)
  {
    if ((*(_BYTE *)(v3 + 624) & 2) != 0) {
      return 1LL;
    }
    *(_BYTE *)(v3 + 624) |= 2u;
    parameters = (void *)nw_protocol_get_parameters((uint64_t)a2);
    *(void *)os_log_type_t type = 0LL;
    BOOL v114 = type;
    uint64_t v115 = 0x3802000000LL;
    BOOL v116 = __Block_byref_object_copy__31;
    __int16 v117 = __Block_byref_object_dispose__32;
    BOOL v118 = nw_parameters_copy_url_endpoint(parameters);
    v119 |= 1u;
    uint64_t v5 = (void *)*((void *)v114 + 5);
    if (v5)
    {
      CFTypeRef v6 = nw_endpoint_copy_cfurl(v5);
      char v7 = *(_BYTE *)(v3 + 568);
      if ((v7 & 1) != 0)
      {
        BOOL v8 = *(const void **)(v3 + 560);
        if (v8)
        {
          CFRelease(v8);
          char v7 = *(_BYTE *)(v3 + 568);
        }
      }

      *(void *)(v3 + 560) = v6;
      *(_BYTE *)(v3 + 56_Block_object_dispose(va, 8) = v7 | 1;
      cStr = nw_endpoint_get_hostname(*((nw_endpoint_t *)v114 + 5));
      uint64_t url_scheme = (const char *)nw_endpoint_get_url_scheme(*((void **)v114 + 5));
      if (!strcasecmp(url_scheme, "https")
        || (BOOL v10 = (const char *)nw_endpoint_get_url_scheme(*((void **)v114 + 5)), !strcasecmp(v10, "wss")))
      {
        char v11 = 1;
        goto LABEL_15;
      }
    }

    else
    {
      cStr = 0LL;
    }

    char v11 = 0;
LABEL_15:
    uint64_t v13 = nw_parameters_copy_protocol_options_legacy(parameters, (nw_protocol *)v3);
    if (v13)
    {
      BOOL v14 = v13;
      BOOL v15 = nw_protocol_options_copy_definition(v14);
      if (nw_protocol_copy_http_security_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_security_definition_onceToken, &__block_literal_global_33_73355);
      }
      BOOL is_equal = nw_protocol_definition_is_equal( v15,  (nw_protocol_definition_t)nw_protocol_copy_http_security_definition_http_security_definition);

      if (is_equal)
      {
        *(void *)int buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3032000000LL;
        int v123 = __Block_byref_object_copy__4;
        os_log_type_t v124 = __Block_byref_object_dispose__5;
        uint64_t v125 = 0LL;
        *(void *)int v106 = MEMORY[0x1895F87A8];
        uint64_t v107 = 3221225472LL;
        uint64_t v108 = (uint64_t)__nw_http_security_options_copy_hsts_storage_block_invoke;
        uint64_t v109 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BC60A8;
        uint64_t v110 = (void (*)(uint64_t))buf;
        nw_protocol_options_access_handle(v14, v106);
        id v17 = *(id *)(*(void *)&buf[8] + 40LL);
        _Block_object_dispose(buf, 8);

        goto LABEL_20;
      }

      __nwlog_obj();
      __int128 v64 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_hsts_storage";
      uint64_t v99 = (const char *)_os_log_send_and_compose_impl();

      v106[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(iterate_block[0]) = 0;
      __int128 v65 = (char *)v99;
      if (!__nwlog_fault(v99, v106, iterate_block))
      {
LABEL_188:
        if (v65) {
          free(v65);
        }
        id v17 = 0LL;
LABEL_20:

        char v18 = *(_BYTE *)(v3 + 584);
        if ((v18 & 1) != 0)
        {
          __int16 v19 = *(void **)(v3 + 576);
          if (v19)
          {
            os_release(v19);
            char v18 = *(_BYTE *)(v3 + 584);
          }
        }

        *(void *)(v3 + 576) = v17;
        *(_BYTE *)(v3 + 584) = v18 | 1;
        __int16 v20 = v14;
        uint64_t v21 = nw_protocol_options_copy_definition(v20);
        if (nw_protocol_copy_http_security_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_security_definition_onceToken, &__block_literal_global_33_73355);
        }
        BOOL v22 = nw_protocol_definition_is_equal( v21,  (nw_protocol_definition_t)nw_protocol_copy_http_security_definition_http_security_definition);

        if (v22)
        {
          *(void *)int buf = 0LL;
          *(void *)&buf[8] = buf;
          *(void *)&buf[16] = 0x3032000000LL;
          int v123 = __Block_byref_object_copy__4;
          os_log_type_t v124 = __Block_byref_object_dispose__5;
          uint64_t v125 = 0LL;
          *(void *)int v106 = MEMORY[0x1895F87A8];
          uint64_t v107 = 3221225472LL;
          uint64_t v108 = (uint64_t)__nw_http_security_options_copy_alt_svc_storage_block_invoke;
          uint64_t v109 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BC60A8;
          uint64_t v110 = (void (*)(uint64_t))buf;
          nw_protocol_options_access_handle(v20, v106);
          id v23 = *(id *)(*(void *)&buf[8] + 40LL);
          _Block_object_dispose(buf, 8);

          goto LABEL_27;
        }

        __nwlog_obj();
        uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_alt_svc_storage";
        uint64_t v69 = (char *)_os_log_send_and_compose_impl();

        v106[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(iterate_block[0]) = 0;
        if (__nwlog_fault(v69, v106, iterate_block))
        {
          if (v106[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            BOOL v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v71 = v106[0];
            if (os_log_type_enabled(v70, v106[0]))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_alt_svc_storage";
              _os_log_impl(&dword_181A5C000, v70, v71, "%{public}s protocol options are not http security", buf, 0xCu);
            }
          }

          else if (LOBYTE(iterate_block[0]))
          {
            uint64_t v76 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v77 = v106[0];
            BOOL v78 = os_log_type_enabled(v70, v106[0]);
            if (v76)
            {
              if (v78)
              {
                *(_DWORD *)int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_alt_svc_storage";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v76;
                _os_log_impl( &dword_181A5C000,  v70,  v77,  "%{public}s protocol options are not http security, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v76);
              goto LABEL_194;
            }

            if (v78)
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_alt_svc_storage";
              _os_log_impl( &dword_181A5C000,  v70,  v77,  "%{public}s protocol options are not http security, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            BOOL v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v84 = v106[0];
            if (os_log_type_enabled(v70, v106[0]))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_alt_svc_storage";
              _os_log_impl( &dword_181A5C000,  v70,  v84,  "%{public}s protocol options are not http security, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

void sub_182030BB0(_Unwind_Exception *a1)
{
}

uint64_t nw_protocol_http_security_create::$_4::__invoke( nw_protocol_http_security_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_security_create::$_5::__invoke( nw_protocol_http_security_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_security_create::$_6::__invoke( nw_protocol_http_security_create::$_6 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t __Block_byref_object_copy__31(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__32(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t __Block_byref_object_copy__35(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__36(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke( void *a1, void *a2)
{
  protocol_uint64_t handle = nw_protocol_options_get_protocol_handle(a2);
  if (!*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL)) {
    goto LABEL_11;
  }
  if (nw_protocol_options_is_tls(a2))
  {
    sec_protocol_options_t v5 = a2;
  }

  else
  {
    if (!nw_protocol_options_is_quic((nw_protocol_options_t)a2))
    {
      if (!nw_protocol_options_is_tcp(a2) && !nw_protocol_options_is_masque(a2)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }

    sec_protocol_options_t v5 = nw_quic_copy_sec_protocol_options((nw_protocol_options_t)a2);
  }

  sec_protocol_options_t v6 = v5;
  uint64_t v7 = *(void *)(a1[5] + 8LL);
  id v9 = (char *)(v7 + 48);
  char v8 = *(_BYTE *)(v7 + 48);
  if ((v8 & 1) != 0)
  {
    BOOL v10 = *(void **)(v7 + 40);
    if (v10)
    {
      os_release(v10);
      char v8 = *v9;
    }
  }

  *(void *)(v7 + 40) = v6;
  *id v9 = v8 | 1;
LABEL_10:
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
LABEL_11:
  if (a1[6] == protocol_handle) {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
  }
}

uint64_t __Block_byref_object_copy__39(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__40(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(const void **)(a1 + 40);
    if (v2) {
      _Block_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_41( uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_54;
  void v4[4] = *(void *)(a1 + 48);
  return (*(uint64_t (**)(void, void, void, void *))(*(void *)(v1 + 40) + 16LL))( *(void *)(v1 + 40),  *(void *)(v2 + 40),  *(unsigned __int8 *)(a1 + 56),  v4);
}

void ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  os_log_type_t v4 = *(void **)(v3 + 608);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  v5[2] = ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_3;
  v5[3] = &__block_descriptor_tmp_52_28470;
  void v5[4] = v3;
  v5[5] = a2;
  v5[6] = a3;
  nw_queue_context_async_if_needed(v4, v5);
}

void ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_3(uint64_t *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (nw_protocol_plugin_retry_end_async(a1[4] + 344))
  {
    uint64_t v2 = (void *)a1[5];
    if (v2 && (uint64_t v3 = (void *)a1[6]) != 0LL)
    {
      uint64_t v4 = a1[4];
      sec_protocol_options_t v5 = *(void **)(v4 + 608);
      v9[0] = MEMORY[0x1895F87A8];
      v9[1] = 0x40000000LL;
      v9[2] = ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_3_50;
      v9[3] = &__block_descriptor_tmp_51_28472;
      void v9[4] = v4;
      nw_protocol_plugin_retry_reissue_output_frames( v4 + 344,  v4,  v5,  v2,  v3,  2,  0,  &__block_literal_global_45,  &__block_literal_global_49_28473,  (uint64_t)v9);
    }

    else
    {
      nw_protocol_error(*(void **)(a1[4] + 48), a1[4]);
      nw_protocol_disconnected(*(void **)(a1[4] + 48), a1[4]);
    }
  }

  else
  {
    uint64_t v6 = a1[4];
    if ((*(_BYTE *)(v6 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
        uint64_t v6 = a1[4];
        if (v8)
        {
          *(_DWORD *)int buf = 136446722;
          char v11 = "nw_http_security_connect_block_invoke_3";
          __int16 v12 = 2082;
          uint64_t v13 = v6 + 114;
          __int16 v14 = 2080;
          BOOL v15 = " ";
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDeferred destroy when coming back from callout",  buf,  0x20u);
          uint64_t v6 = a1[4];
        }
      }
    }

    nw_http_security_destroy(v6);
  }

void nw_http_security_destroy(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 136446722;
        __int16 v12 = "nw_http_security_destroy";
        __int16 v13 = 2082;
        uint64_t v14 = a1 + 114;
        __int16 v15 = 2080;
        uint64_t v16 = " ";
        _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", (uint8_t *)&v11, 0x20u);
      }
    }
  }

  if (*(_DWORD *)(a1 + 552))
  {
    *(_BYTE *)(a1 + 556) |= 0x40u;
    if ((*(_BYTE *)(a1 + 198) & 1) == 0 && gLogDatapath)
    {
      uint64_t v2 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 136446722;
        __int16 v12 = "nw_http_security_destroy";
        __int16 v13 = 2082;
        uint64_t v14 = a1 + 114;
        __int16 v15 = 2080;
        uint64_t v16 = " ";
        _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sdeferring destroy because the request is being reissued",  (uint8_t *)&v11,  0x20u);
      }
    }
  }

  else
  {
    if ((*(_BYTE *)(a1 + 616) & 1) != 0)
    {
      uint64_t v3 = *(void **)(a1 + 608);
      if (v3) {
        os_release(v3);
      }
    }

    *(void *)(a1 + 60_Block_object_dispose((const void *)(v1 - 176), 8) = 0LL;
    if ((*(_BYTE *)(a1 + 600) & 1) != 0)
    {
      uint64_t v4 = *(void **)(a1 + 592);
      if (v4) {
        os_release(v4);
      }
    }

    *(void *)(a1 + 592) = 0LL;
    if ((*(_BYTE *)(a1 + 584) & 1) != 0)
    {
      sec_protocol_options_t v5 = *(void **)(a1 + 576);
      if (v5) {
        os_release(v5);
      }
    }

    *(void *)(a1 + 576) = 0LL;
    if ((*(_BYTE *)(a1 + 568) & 1) != 0)
    {
      uint64_t v6 = *(const void **)(a1 + 560);
      if (v6) {
        CFRelease(v6);
      }
    }

    *(void *)(a1 + 560) = 0LL;
    nw_protocol_plugin_retry::~nw_protocol_plugin_retry((nw_protocol_plugin_retry *)(a1 + 344));
    if ((*(_BYTE *)(a1 + 288) & 1) != 0)
    {
      uint64_t v7 = *(void **)(a1 + 280);
      if (v7) {
        os_release(v7);
      }
    }

    *(void *)(a1 + 280) = 0LL;
    if ((*(_BYTE *)(a1 + 272) & 1) != 0)
    {
      BOOL v8 = *(void **)(a1 + 264);
      if (v8) {
        os_release(v8);
      }
    }

    *(void *)(a1 + 264) = 0LL;
    if ((*(_BYTE *)(a1 + 256) & 1) != 0)
    {
      id v9 = *(void **)(a1 + 248);
      if (v9) {
        os_release(v9);
      }
    }

    free((void *)a1);
  }

void ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_3_50(uint64_t a1)
{
}

uint64_t ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_2_46()
{
  return 1LL;
}

uint64_t ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_42()
{
  return 1LL;
}

uint64_t __Block_byref_object_copy__28532(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__28533(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t __Block_byref_object_copy__12_28539(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__13_28540(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke( uint64_t a1, int a2, nw_protocol_metadata_t metadata)
{
  BOOL is_tls = nw_protocol_metadata_is_tls(metadata);
  uint64_t v6 = metadata;
  sec_protocol_metadata_t v7 = v6;
  if (!is_tls)
  {
    if (nw_protocol_metadata_is_quic_connection(v6))
    {
    }

    else
    {
      BOOL is_quic_stream = nw_protocol_metadata_is_quic_stream(v7);

      if (!is_quic_stream) {
        return 1LL;
      }
    }

    sec_protocol_metadata_t v7 = nw_quic_copy_sec_protocol_metadata(v7);
  }

  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
  int v11 = (char *)(v9 + 48);
  char v10 = *(_BYTE *)(v9 + 48);
  if ((v10 & 1) != 0)
  {
    __int16 v12 = *(void **)(v9 + 40);
    if (v12)
    {
      os_release(v12);
      char v10 = *v11;
    }
  }

  *(void *)(v9 + 40) = v7;
  uint64_t result = 0LL;
  char *v11 = v10 | 1;
  return result;
}

void sub_182031440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_16( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_18_28555;
  void v4[4] = v1;
  return nw_http_fields_enumerate_by_name(v2, (unint64_t)"Strict-Transport-Security", v4);
}

uint64_t __Block_byref_object_copy__20(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t __Block_byref_object_copy__22(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__23(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(dispatch_object_s **)(a1 + 40);
    if (v2) {
      dispatch_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_24( void *a1)
{
  uint64_t v2 = sec_trust_copy_ref(*(sec_trust_t *)(*(void *)(a1[5] + 8LL) + 40LL));
  uint64_t v3 = a1[7];
  uint64_t v4 = *(void *)(a1[6] + 8LL);
  v6[0] = MEMORY[0x1895F87A8];
  v6[2] = ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_2_25;
  v6[3] = &unk_189BBAF88;
  sec_protocol_options_t v5 = *(dispatch_queue_s **)(v4 + 40);
  v6[1] = 0x40000000LL;
  void v6[4] = a1[4];
  v6[5] = v3;
  SecTrustEvaluateAsyncWithError(v2, v5, v6);
  if (v2) {
    os_release(v2);
  }
}

BOOL ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_29( uint64_t a1, int a2, nw_protocol_metadata_t metadata)
{
  BOOL is_tls = nw_protocol_metadata_is_tls(metadata);
  if (is_tls) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = metadata;
  }
  return !is_tls;
}

void ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_2_25( uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a3) {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
  if (!nw_protocol_plugin_retry_end_async(*(void *)(a1 + 40) + 344LL))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if ((*(_BYTE *)(v4 + 198) & 1) == 0 && gLogDatapath)
    {
      sec_protocol_options_t v5 = (os_log_s *)__nwlog_obj();
      BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
      uint64_t v4 = *(void *)(a1 + 40);
      if (v6)
      {
        int v7 = 136446722;
        BOOL v8 = "nw_http_security_process_response_block_invoke_2";
        __int16 v9 = 2082;
        uint64_t v10 = v4 + 114;
        __int16 v11 = 2080;
        __int16 v12 = " ";
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDeferred destroy when coming back from callout",  (uint8_t *)&v7,  0x20u);
        uint64_t v4 = *(void *)(a1 + 40);
      }
    }

    nw_http_security_destroy(v4);
  }

uint64_t ___ZL33nw_http_security_process_responseP25nw_protocol_http_securityP20nw_protocol_metadata_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(v5 + 560);
  int v7 = (id *)*(id *)(v5 + 576);
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
    __int16 v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
          uint64_t v14 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_40;
        }

        goto LABEL_42;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
          __int16 v30 = 2082;
          char v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v18,  "%{public}s called with null storage, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v11) {
          goto LABEL_5;
        }
LABEL_44:
        free(v11);
        goto LABEL_5;
      }

      if (!v19) {
        goto LABEL_42;
      }
      *(_DWORD *)int buf = 136446210;
      sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
      uint64_t v14 = "%{public}s called with null storage, no backtrace";
      goto LABEL_51;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    os_log_type_t v13 = type;
    if (!os_log_type_enabled(v12, type)) {
      goto LABEL_42;
    }
    *(_DWORD *)int buf = 136446210;
    sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
    uint64_t v14 = "%{public}s called with null storage";
    goto LABEL_40;
  }

  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
    __int16 v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)int buf = 136446210;
          sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
          uint64_t v14 = "%{public}s called with null url, backtrace limit exceeded";
          goto LABEL_40;
        }

        goto LABEL_42;
      }

      __int16 v20 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v18 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (v20)
      {
        if (!v21) {
          goto LABEL_32;
        }
        *(_DWORD *)int buf = 136446466;
        sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
        __int16 v30 = 2082;
        char v31 = v20;
        BOOL v22 = "%{public}s called with null url, dumping backtrace:%{public}s";
        goto LABEL_31;
      }

      if (!v21) {
        goto LABEL_42;
      }
      *(_DWORD *)int buf = 136446210;
      sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
      uint64_t v14 = "%{public}s called with null url, no backtrace";
LABEL_51:
      char v24 = v12;
      os_log_type_t v25 = v18;
      goto LABEL_41;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    os_log_type_t v13 = type;
    if (!os_log_type_enabled(v12, type)) {
      goto LABEL_42;
    }
    *(_DWORD *)int buf = 136446210;
    sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
    uint64_t v14 = "%{public}s called with null url";
LABEL_40:
    char v24 = v12;
    os_log_type_t v25 = v13;
LABEL_41:
    _os_log_impl(&dword_181A5C000, v24, v25, v14, buf, 0xCu);
    goto LABEL_42;
  }

  if (!a4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v16 = (id)gLogObj;
    *(_DWORD *)int buf = 136446210;
    sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
    __int16 v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        sec_protocol_options_t v29 = "nw_hsts_storage_parse_and_set";
        uint64_t v14 = "%{public}s called with null sts_header";
        goto LABEL_40;
      }

void ___ZL39nw_protocol_http_security_get_callbacksv_block_invoke()
{
  qword_18C592EC8 = (uint64_t)nw_protocol_common_get_input_frames;
  unk_18C592ED0 = nw_protocol_common_get_output_frames;
  qword_18C592EE8 = (uint64_t)nw_protocol_common_get_parameters;
  unk_18C592EF0 = nw_protocol_common_get_path;
  qword_18C592EF8 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_18C592F00 = nw_protocol_common_get_remote_endpoint;
  qword_18C592E88 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_18C592E90 = nw_protocol_common_connect;
  qword_18C592E98 = (uint64_t)nw_protocol_common_disconnect;
  unk_18C592EA0 = nw_protocol_common_connected;
  qword_18C592EB8 = (uint64_t)nw_protocol_common_input_available;
  unk_18C592EC0 = nw_protocol_common_output_available;
  qword_18C592F38 = (uint64_t)nw_protocol_common_output_finished;
  unk_18C592F40 = nw_protocol_common_get_output_local_endpoint;
  qword_18C592F80 = (uint64_t)nw_protocol_common_input_flush;
  qword_18C592EA8 = (uint64_t)nw_protocol_common_disconnected;
  unk_18C592EB0 = nw_protocol_common_error;
  qword_18C592F70 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_18C592F78 = nw_protocol_common_reset;
  qword_18C592F58 = (uint64_t)nw_protocol_common_copy_info;
  qword_18C592F28 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_18C592F30 = nw_protocol_common_input_finished;
  qword_18C592F48 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_18C592F50 = nw_protocol_common_waiting_for_output;
  qword_18C592F08 = (uint64_t)nw_protocol_common_register_notification;
  unk_18C592F10 = nw_protocol_common_unregister_notification;
  qword_18C592F18 = (uint64_t)nw_protocol_common_notify;
  unk_18C592F20 = nw_protocol_common_updated_path;
  qword_18C592ED8 = (uint64_t)nw_protocol_common_finalize_output_frames;
  unk_18C592EE0 = nw_protocol_common_link_state;
  nw_protocol_http_security_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  unk_18C592E80 = nw_protocol_http_security_remove_input_handler;
}

uint64_t nw_protocol_http_security_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      if ((handle[198] & 1) == 0 && gLogDatapath)
      {
        __int16 v12 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446722;
          BOOL v23 = "nw_protocol_http_security_remove_input_handler";
          __int16 v24 = 2082;
          os_log_type_t v25 = handle + 114;
          __int16 v26 = 2080;
          nw_protocol_options_t v27 = " ";
          _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }

      v19[0] = MEMORY[0x1895F87A8];
      v19[1] = 0x40000000LL;
      void v19[2] = ___ZL46nw_protocol_http_security_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v19[3] = &__block_descriptor_tmp_58;
      void v19[4] = handle;
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 0x40000000LL;
      void v17[2] = ___ZL46nw_protocol_http_security_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
      v17[3] = &__block_descriptor_tmp_59;
      char v18 = a3;
      void v17[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v19, (uint64_t)v17);
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v23 = "nw_protocol_http_security_remove_input_handler";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      __int16 v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v21;
      if (os_log_type_enabled(v9, v21))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v23 = "nw_protocol_http_security_remove_input_handler";
        __int16 v11 = "%{public}s called with null http_security";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (!v20)
    {
      __int16 v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v21;
      if (os_log_type_enabled(v9, v21))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v23 = "nw_protocol_http_security_remove_input_handler";
        __int16 v11 = "%{public}s called with null http_security, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v21;
    BOOL v16 = os_log_type_enabled(v9, v21);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v23 = "nw_protocol_http_security_remove_input_handler";
        __int16 v11 = "%{public}s called with null http_security, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v16)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v23 = "nw_protocol_http_security_remove_input_handler";
      __int16 v24 = 2082;
      os_log_type_t v25 = backtrace_string;
      id v15 = "%{public}s called with null http_security, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v23 = "nw_protocol_http_security_remove_input_handler";
  BOOL v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v21 = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (v21 != OS_LOG_TYPE_FAULT)
  {
    if (!v20)
    {
      __int16 v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v21;
      if (os_log_type_enabled(v9, v21))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v23 = "nw_protocol_http_security_remove_input_handler";
        __int16 v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v21;
    BOOL v14 = os_log_type_enabled(v9, v21);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v23 = "nw_protocol_http_security_remove_input_handler";
        __int16 v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v14)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v23 = "nw_protocol_http_security_remove_input_handler";
      __int16 v24 = 2082;
      os_log_type_t v25 = backtrace_string;
      id v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v9, v10, v15, buf, 0x16u);
    }

void ___ZL46nw_protocol_http_security_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (gLogDatapath)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v8 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v9 = 136446210;
      os_log_type_t v10 = "nw_protocol_plugin_metadata_teardown";
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v9, 0xCu);
    }
  }

  nw_protocol_plugin_metadata_reset((uint64_t *)(v2 + 200));
  *(void *)(v2 + 32_Block_object_dispose((const void *)(v1 - 176), 8) = 0LL;
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = *(_BYTE *)(v3 + 464);
  if ((v4 & 1) != 0)
  {
    uint64_t v5 = *(const void **)(v3 + 456);
    if (v5)
    {
      _Block_release(v5);
      char v4 = *(_BYTE *)(v3 + 464);
    }
  }

  *(void *)(v3 + 456) = 0LL;
  *(_BYTE *)(v3 + 464) = v4 | 1;
  char v6 = *(_BYTE *)(v3 + 512);
  if ((v6 & 1) != 0)
  {
    int v7 = *(const void **)(v3 + 504);
    if (v7)
    {
      _Block_release(v7);
      char v6 = *(_BYTE *)(v3 + 512);
    }
  }

  *(void *)(v3 + 504) = 0LL;
  *(_BYTE *)(v3 + 512) = v6 | 1;
}

void ___ZL46nw_protocol_http_security_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40)) {
    nw_http_security_destroy(*(void *)(a1 + 32));
  }
}

double __nw_protocol_http_security_identifier_block_invoke()
{
  *(void *)&double result = 0x100000005LL;
  qword_18C592828 = 0x100000005LL;
  return result;
}

double __nw_protocol_oblivious_http_identifier_block_invoke()
{
  *(void *)&double result = 0x100000004LL;
  qword_18C594150 = 0x100000004LL;
  return result;
}

double __nw_protocol_oblivious_http_contexts_identifier_block_invoke()
{
  *(void *)&double result = 0x200000004LL;
  qword_18C594180 = 0x200000004LL;
  return result;
}

BOOL nw_protocol_oblivious_http_create(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "nw_protocol_oblivious_http_create";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v19 = "nw_protocol_oblivious_http_create";
          uint64_t v11 = "%{public}s called with null parameters";
LABEL_31:
          _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v19 = "nw_protocol_oblivious_http_create";
            __int16 v20 = 2082;
            uint64_t v21 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v15)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v19 = "nw_protocol_oblivious_http_create";
          uint64_t v11 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_31;
        }
      }

      else
      {
        int v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v19 = "nw_protocol_oblivious_http_create";
          uint64_t v11 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_31;
        }
      }
    }

void ___ZL31nw_protocol_ohttp_get_callbacksv_block_invoke()
{
  qword_18C5A34F0 = (uint64_t)nw_protocol_common_get_parameters;
  unk_18C5A34F8 = nw_protocol_common_get_path;
  qword_18C5A3500 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_18C5A3508 = nw_protocol_common_get_remote_endpoint;
  qword_18C5A3540 = (uint64_t)nw_protocol_common_output_finished;
  unk_18C5A3548 = nw_protocol_common_get_output_local_endpoint;
  qword_18C5A3580 = (uint64_t)nw_protocol_common_reset;
  unk_18C5A3588 = nw_protocol_common_input_flush;
  qword_18C5A3578 = (uint64_t)nw_protocol_common_get_message_properties;
  qword_18C5A3550 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_18C5A3558 = nw_protocol_common_waiting_for_output;
  qword_18C5A3510 = (uint64_t)nw_protocol_common_register_notification;
  unk_18C5A3518 = nw_protocol_common_unregister_notification;
  qword_18C5A3520 = (uint64_t)nw_protocol_common_notify;
  unk_18C5A3528 = nw_protocol_common_updated_path;
  nw_protocol_ohttp_get_callbacks(void)::ohttp_protocol_callbacks = (uint64_t)nw_protocol_ohttp_add_input_handler;
  *(void *)algn_18C5A3488 = nw_protocol_ohttp_remove_input_handler;
  qword_18C5A3530 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_18C5A3538 = nw_protocol_ohttp_input_finished;
  qword_18C5A34D0 = (uint64_t)nw_protocol_ohttp_get_input_frames;
  unk_18C5A34D8 = nw_protocol_ohttp_get_output_frames;
  qword_18C5A34E0 = (uint64_t)nw_protocol_ohttp_finalize_output_frames;
  unk_18C5A34E8 = nw_protocol_common_link_state;
  qword_18C5A34C0 = (uint64_t)nw_protocol_ohttp_input_available;
  unk_18C5A34C8 = nw_protocol_ohttp_output_available;
  qword_18C5A3560 = (uint64_t)nw_protocol_ohttp_copy_info;
  qword_18C5A3490 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_18C5A3498 = nw_protocol_ohttp_connect;
  qword_18C5A34A0 = (uint64_t)nw_protocol_ohttp_disconnect;
  unk_18C5A34A8 = nw_protocol_ohttp_connected;
  qword_18C5A34B0 = (uint64_t)nw_protocol_ohttp_disconnected;
  unk_18C5A34B8 = nw_protocol_ohttp_error;
}

BOOL nw_protocol_ohttp_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      char v47 = "%{public}s called with null protocol";
      goto LABEL_162;
    }

    if (!v62)
    {
      BOOL v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      char v47 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v45 = (os_log_s *)__nwlog_obj();
    os_log_type_t v46 = type[0];
    BOOL v49 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (!v49) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      char v47 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_162;
    }

    if (!v49) {
      goto LABEL_79;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    os_log_type_t v50 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_78:
    _os_log_impl(&dword_181A5C000, v45, v46, v50, buf, 0x16u);
    goto LABEL_79;
  }

  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      char v47 = "%{public}s called with null ohttp";
      goto LABEL_162;
    }

    if (!v62)
    {
      BOOL v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      char v47 = "%{public}s called with null ohttp, backtrace limit exceeded";
      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v45 = (os_log_s *)__nwlog_obj();
    os_log_type_t v46 = type[0];
    BOOL v51 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (!v51) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      char v47 = "%{public}s called with null ohttp, no backtrace";
      goto LABEL_162;
    }

    if (!v51) {
      goto LABEL_79;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    os_log_type_t v50 = "%{public}s called with null ohttp, dumping backtrace:%{public}s";
    goto LABEL_78;
  }

  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    if ((nw_protocol_common_add_input_handler((uint64_t)a1, (uint64_t)a2) & 1) == 0)
    {
      if ((handle[348] & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v33 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 349;
          *(_WORD *)&_BYTE buf[22] = 2080;
          uint64_t v68 = " ";
          _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sfailed to add input handler",  buf,  0x20u);
        }
      }

      return 0LL;
    }

    *((_DWORD *)handle + 86) = 0;
    *((_DWORD *)handle + 72) = 0;
    uint64_t parameters = nw_protocol_get_parameters((uint64_t)a2);
    if (!parameters)
    {
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v62 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type[0];
        if (!os_log_type_enabled(v45, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        char v47 = "%{public}s called with null parameters";
        goto LABEL_162;
      }

      if (!v62)
      {
        BOOL v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type[0];
        if (!os_log_type_enabled(v45, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        char v47 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_162;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v56 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (!v56) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        char v47 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_162;
      }

      if (!v56) {
        goto LABEL_79;
      }
LABEL_117:
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      os_log_type_t v50 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_78;
    }

    uint64_t v17 = (void *)parameters;
    handle[348] = handle[348] & 0xFE | nw_path_parameters_get_logging_disabled(*(void *)(parameters + 104));
    char v18 = nw_parameters_copy_protocol_options_legacy(v17, a1);
    if (!v18)
    {
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v62 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type[0];
        if (!os_log_type_enabled(v45, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        char v47 = "%{public}s called with null ohttp_options";
        goto LABEL_162;
      }

      if (!v62)
      {
        BOOL v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type[0];
        if (!os_log_type_enabled(v45, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        char v47 = "%{public}s called with null ohttp_options, backtrace limit exceeded";
        goto LABEL_162;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v57 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (!v57) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        char v47 = "%{public}s called with null ohttp_options, no backtrace";
        goto LABEL_162;
      }

      if (v57)
      {
LABEL_121:
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        os_log_type_t v50 = "%{public}s called with null ohttp_options, dumping backtrace:%{public}s";
        goto LABEL_78;
      }

uint64_t nw_protocol_ohttp_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_remove_input_handler";
    char v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_53;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_remove_input_handler";
        BOOL v19 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (!v21) {
          goto LABEL_53;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_remove_input_handler";
        BOOL v19 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_40:
        _os_log_impl(&dword_181A5C000, v17, v18, v22, buf, 0x16u);
      }

uint64_t nw_protocol_ohttp_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
    BOOL v52 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null protocol";
      goto LABEL_97;
    }

    if (!v62)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v53 = (os_log_s *)__nwlog_obj();
    os_log_type_t v54 = type;
    BOOL v57 = os_log_type_enabled(v53, type);
    if (!backtrace_string)
    {
      if (!v57) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_97;
    }

    if (!v57) {
      goto LABEL_84;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
    __int16 v66 = 2082;
    os_log_type_t v67 = backtrace_string;
    BOOL v58 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_83:
    _os_log_impl(&dword_181A5C000, v53, v54, v58, buf, 0x16u);
    goto LABEL_84;
  }

  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
    BOOL v52 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null ohttp";
      goto LABEL_97;
    }

    if (!v62)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null ohttp, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v53 = (os_log_s *)__nwlog_obj();
    os_log_type_t v54 = type;
    BOOL v59 = os_log_type_enabled(v53, type);
    if (!backtrace_string)
    {
      if (!v59) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null ohttp, no backtrace";
      goto LABEL_97;
    }

    if (!v59) {
      goto LABEL_84;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
    __int16 v66 = 2082;
    os_log_type_t v67 = backtrace_string;
    BOOL v58 = "%{public}s called with null ohttp, dumping backtrace:%{public}s";
    goto LABEL_83;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
    BOOL v52 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null return_array";
      goto LABEL_97;
    }

    if (!v62)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
      BOOL v55 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v53 = (os_log_s *)__nwlog_obj();
    os_log_type_t v54 = type;
    BOOL v60 = os_log_type_enabled(v53, type);
    if (backtrace_string)
    {
      if (v60)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
        __int16 v66 = 2082;
        os_log_type_t v67 = backtrace_string;
        BOOL v58 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_83;
      }

void nw_protocol_ohttp_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "nw_protocol_ohttp_input_available";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_protocol_ohttp_input_available";
      char v6 = "%{public}s called with null protocol";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      goto LABEL_32;
    }

    if (!v11)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_protocol_ohttp_input_available";
      char v6 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (!v8) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_protocol_ohttp_input_available";
      char v6 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_31;
    }

    if (v8)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v14 = "nw_protocol_ohttp_input_available";
      __int16 v15 = 2082;
      BOOL v16 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_32:
    if (!v3) {
      return;
    }
    goto LABEL_33;
  }

  uint64_t handle = a1->handle;
  if (handle)
  {
    nw_protocol_ohttp_read_response((uint64_t)handle);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v14 = "nw_protocol_ohttp_input_available";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "nw_protocol_ohttp_input_available";
    char v6 = "%{public}s called with null ohttp";
    goto LABEL_31;
  }

  if (!v11)
  {
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "nw_protocol_ohttp_input_available";
    char v6 = "%{public}s called with null ohttp, backtrace limit exceeded";
    goto LABEL_31;
  }

  uint64_t v9 = (char *)__nw_create_backtrace_string();
  char v4 = (os_log_s *)__nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v10 = os_log_type_enabled(v4, type);
  if (!v9)
  {
    if (!v10) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "nw_protocol_ohttp_input_available";
    char v6 = "%{public}s called with null ohttp, no backtrace";
    goto LABEL_31;
  }

  if (v10)
  {
    *(_DWORD *)int buf = 136446466;
    uint64_t v14 = "nw_protocol_ohttp_input_available";
    __int16 v15 = 2082;
    BOOL v16 = v9;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v3) {
LABEL_33:
  }
    free(v3);
}

void nw_protocol_ohttp_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v17 = "nw_protocol_ohttp_input_finished";
    char v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v17 = "nw_protocol_ohttp_input_finished";
      int v7 = "%{public}s called with null protocol";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v17 = "nw_protocol_ohttp_input_finished";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v4) {
          return;
        }
LABEL_42:
        free(v4);
        return;
      }

      if (!v9) {
        goto LABEL_41;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v17 = "nw_protocol_ohttp_input_finished";
      int v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v17 = "nw_protocol_ohttp_input_finished";
      int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_ohttp_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v30 = "nw_protocol_ohttp_get_output_frames";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null protocol";
      goto LABEL_50;
    }

    if (!v27)
    {
      __int16 v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_50;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v22 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v22) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_50;
    }

    if (!v22) {
      goto LABEL_37;
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v30 = "nw_protocol_ohttp_get_output_frames";
    __int16 v31 = 2082;
    uint64_t v32 = backtrace_string;
    int v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v18, v19, v23, buf, 0x16u);
    goto LABEL_37;
  }

  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v30 = "nw_protocol_ohttp_get_output_frames";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null ohttp";
      goto LABEL_50;
    }

    if (!v27)
    {
      __int16 v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null ohttp, backtrace limit exceeded";
      goto LABEL_50;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v24 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v24) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null ohttp, no backtrace";
      goto LABEL_50;
    }

    if (!v24) {
      goto LABEL_37;
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v30 = "nw_protocol_ohttp_get_output_frames";
    __int16 v31 = 2082;
    uint64_t v32 = backtrace_string;
    int v23 = "%{public}s called with null ohttp, dumping backtrace:%{public}s";
    goto LABEL_36;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v30 = "nw_protocol_ohttp_get_output_frames";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null return_array";
      goto LABEL_50;
    }

    if (!v27)
    {
      __int16 v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v30 = "nw_protocol_ohttp_get_output_frames";
      __int16 v20 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_50;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v25 = os_log_type_enabled(v18, type);
    if (backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v30 = "nw_protocol_ohttp_get_output_frames";
        __int16 v31 = 2082;
        uint64_t v32 = backtrace_string;
        int v23 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_36;
      }

uint64_t nw_protocol_ohttp_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 0x40000000LL;
      BOOL v16 = (uint64_t (*)(void *))___ZL40nw_protocol_ohttp_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
      uint64_t v17 = &__block_descriptor_tmp_31_28972;
      __int16 v18 = a2;
      os_log_type_t v19 = handle;
      tqh_first = a2->tqh_first;
      do
      {
        if (!tqh_first) {
          break;
        }
        char v4 = (nw_frame *)*((void *)tqh_first + 4);
        char v5 = v16(v15);
        tqh_first = v4;
      }

      while ((v5 & 1) != 0);
      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v23 = "nw_protocol_ohttp_finalize_output_frames";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      size_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v21;
      if (os_log_type_enabled(v8, v21))
      {
        *(_DWORD *)int buf = 136446210;
        int v23 = "nw_protocol_ohttp_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null ohttp";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (!v20)
    {
      size_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v21;
      if (os_log_type_enabled(v8, v21))
      {
        *(_DWORD *)int buf = 136446210;
        int v23 = "nw_protocol_ohttp_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null ohttp, backtrace limit exceeded";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = v21;
    BOOL v14 = os_log_type_enabled(v8, v21);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        int v23 = "nw_protocol_ohttp_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null ohttp, no backtrace";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v14)
    {
      *(_DWORD *)int buf = 136446466;
      int v23 = "nw_protocol_ohttp_finalize_output_frames";
      __int16 v24 = 2082;
      BOOL v25 = backtrace_string;
      uint64_t v13 = "%{public}s called with null ohttp, dumping backtrace:%{public}s";
      goto LABEL_24;
    }

    goto LABEL_25;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  int v23 = "nw_protocol_ohttp_finalize_output_frames";
  int v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v21 = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (v21 != OS_LOG_TYPE_FAULT)
  {
    if (!v20)
    {
      size_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v21;
      if (os_log_type_enabled(v8, v21))
      {
        *(_DWORD *)int buf = 136446210;
        int v23 = "nw_protocol_ohttp_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = v21;
    BOOL v12 = os_log_type_enabled(v8, v21);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        int v23 = "nw_protocol_ohttp_finalize_output_frames";
        uint64_t v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v12)
    {
      *(_DWORD *)int buf = 136446466;
      int v23 = "nw_protocol_ohttp_finalize_output_frames";
      __int16 v24 = 2082;
      BOOL v25 = backtrace_string;
      uint64_t v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v8, v9, v13, buf, 0x16u);
    }

void nw_protocol_ohttp_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v14 = "nw_protocol_ohttp_output_available";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_output_available";
      os_log_type_t v6 = "%{public}s called with null protocol";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      goto LABEL_32;
    }

    if (!v11)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_output_available";
      os_log_type_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (!v8) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_output_available";
      os_log_type_t v6 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_31;
    }

    if (v8)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v14 = "nw_protocol_ohttp_output_available";
      __int16 v15 = 2082;
      BOOL v16 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_32:
    if (!v3) {
      return;
    }
    goto LABEL_33;
  }

  uint64_t handle = a1->handle;
  if (handle)
  {
    nw_protocol_ohttp_send_request((uint64_t)handle);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v14 = "nw_protocol_ohttp_output_available";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v14 = "nw_protocol_ohttp_output_available";
    os_log_type_t v6 = "%{public}s called with null ohttp";
    goto LABEL_31;
  }

  if (!v11)
  {
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v14 = "nw_protocol_ohttp_output_available";
    os_log_type_t v6 = "%{public}s called with null ohttp, backtrace limit exceeded";
    goto LABEL_31;
  }

  os_log_type_t v9 = (char *)__nw_create_backtrace_string();
  char v4 = (os_log_s *)__nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v10 = os_log_type_enabled(v4, type);
  if (!v9)
  {
    if (!v10) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v14 = "nw_protocol_ohttp_output_available";
    os_log_type_t v6 = "%{public}s called with null ohttp, no backtrace";
    goto LABEL_31;
  }

  if (v10)
  {
    *(_DWORD *)int buf = 136446466;
    BOOL v14 = "nw_protocol_ohttp_output_available";
    __int16 v15 = 2082;
    BOOL v16 = v9;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v3) {
LABEL_33:
  }
    free(v3);
}

uint64_t nw_protocol_ohttp_copy_info(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v14 = "nw_protocol_ohttp_copy_info";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_copy_info";
      os_log_type_t v6 = "%{public}s called with null protocol";
      goto LABEL_33;
    }

    if (!v11)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_copy_info";
      os_log_type_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (!v8) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_copy_info";
      os_log_type_t v6 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_33;
    }

    if (v8)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v14 = "nw_protocol_ohttp_copy_info";
      __int16 v15 = 2082;
      BOOL v16 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_34:
    if (!v3) {
      return 0LL;
    }
LABEL_35:
    free(v3);
    return 0LL;
  }

  if (!*(void *)(a1 + 40))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v14 = "nw_protocol_ohttp_copy_info";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_copy_info";
      os_log_type_t v6 = "%{public}s called with null ohttp";
      goto LABEL_33;
    }

    if (!v11)
    {
      char v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_copy_info";
      os_log_type_t v6 = "%{public}s called with null ohttp, backtrace limit exceeded";
      goto LABEL_33;
    }

    os_log_type_t v9 = (char *)__nw_create_backtrace_string();
    char v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (v9)
    {
      if (v10)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v14 = "nw_protocol_ohttp_copy_info";
        __int16 v15 = 2082;
        BOOL v16 = v9;
        _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v9);
      if (!v3) {
        return 0LL;
      }
      goto LABEL_35;
    }

    if (v10)
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v14 = "nw_protocol_ohttp_copy_info";
      os_log_type_t v6 = "%{public}s called with null ohttp, no backtrace";
LABEL_33:
      _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      goto LABEL_34;
    }

    goto LABEL_34;
  }

  if (a2 == 253) {
    return 0LL;
  }
  return nw_protocol_common_copy_info(a1, a2);
}

uint64_t nw_protocol_ohttp_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      if ((handle[348] & 8) == 0) {
        return nw_protocol_connect((uint64_t)a1->output_handler, (uint64_t)a1);
      }
      nw_protocol_connected(a2, (uint64_t)a1);
      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v15 = "nw_protocol_ohttp_connect";
    char v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_ohttp_connect";
        int v7 = "%{public}s called with null ohttp";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v12)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_ohttp_connect";
        int v7 = "%{public}s called with null ohttp, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_ohttp_connect";
        int v7 = "%{public}s called with null ohttp, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v11)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v15 = "nw_protocol_ohttp_connect";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null ohttp, dumping backtrace:%{public}s";
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  __int16 v15 = "nw_protocol_ohttp_connect";
  char v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_ohttp_connect";
        int v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v15 = "nw_protocol_ohttp_connect";
        int v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v9)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v15 = "nw_protocol_ohttp_connect";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_23:
      _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    }

void nw_protocol_ohttp_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v18 = "nw_protocol_ohttp_connected";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v16 = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      int v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = v16;
      if (!os_log_type_enabled(v7, v16)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v18 = "nw_protocol_ohttp_connected";
      BOOL v9 = "%{public}s called with null protocol";
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = v16;
      BOOL v11 = os_log_type_enabled(v7, v16);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v18 = "nw_protocol_ohttp_connected";
          __int16 v19 = 2082;
          char v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v6) {
          return;
        }
LABEL_37:
        free(v6);
        return;
      }

      if (!v11) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v18 = "nw_protocol_ohttp_connected";
      BOOL v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = v16;
      if (!os_log_type_enabled(v7, v16)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v18 = "nw_protocol_ohttp_connected";
      BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_ohttp_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v13 = "nw_protocol_ohttp_disconnect";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v13 = "nw_protocol_ohttp_disconnect";
      os_log_type_t v5 = "%{public}s called with null protocol";
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v13 = "nw_protocol_ohttp_disconnect";
          __int16 v14 = 2082;
          char v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v2) {
          return;
        }
LABEL_35:
        free(v2);
        return;
      }

      if (!v7) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v13 = "nw_protocol_ohttp_disconnect";
      os_log_type_t v5 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v13 = "nw_protocol_ohttp_disconnect";
      os_log_type_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_ohttp_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v17 = "nw_protocol_ohttp_disconnected";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v15 = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (v15 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v15;
      if (!os_log_type_enabled(v6, v15)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v17 = "nw_protocol_ohttp_disconnected";
      os_log_type_t v8 = "%{public}s called with null protocol";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v15;
      BOOL v10 = os_log_type_enabled(v6, v15);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v17 = "nw_protocol_ohttp_disconnected";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v5) {
          return;
        }
LABEL_35:
        free(v5);
        return;
      }

      if (!v10) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v17 = "nw_protocol_ohttp_disconnected";
      os_log_type_t v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v15;
      if (!os_log_type_enabled(v6, v15)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v17 = "nw_protocol_ohttp_disconnected";
      os_log_type_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_ohttp_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "nw_protocol_ohttp_error";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v18 = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v18;
      if (!os_log_type_enabled(v8, v18)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_protocol_ohttp_error";
      BOOL v10 = "%{public}s called with null protocol";
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v18;
      BOOL v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v20 = "nw_protocol_ohttp_error";
          __int16 v21 = 2082;
          BOOL v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v7) {
          return;
        }
LABEL_35:
        free(v7);
        return;
      }

      if (!v12) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_protocol_ohttp_error";
      BOOL v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v18;
      if (!os_log_type_enabled(v8, v18)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_protocol_ohttp_error";
      BOOL v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t ___ZL23nw_protocol_ohttp_errorP11nw_protocolS0_i_block_invoke(uint64_t a1, uint64_t a2)
{
  dispatch_object_t object = (void *)nw_hash_node_get_object(a2);
  nw_protocol_error(object, *(void *)(a1 + 32));
  return 1LL;
}

uint64_t ___ZL30nw_protocol_ohttp_disconnectedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  dispatch_object_t object = (void *)nw_hash_node_get_object(a2);
  nw_protocol_disconnected(object, *(void *)(a1 + 32));
  return 1LL;
}

uint64_t ___ZL27nw_protocol_ohttp_connectedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  dispatch_object_t object = (void *)nw_hash_node_get_object(a2);
  nw_protocol_connected(object, *(void *)(a1 + 32));
  return 1LL;
}

void nw_protocol_ohttp_send_request(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 320);
  if (!v2)
  {
LABEL_6:
    if (*(_DWORD *)(a1 + 288) != 1 || (nw_protocol_ohttp_context_send_request(a1, a1 + 64), !*(void *)(a1 + 320)))
    {
      os_log_type_t v5 = *(char **)(a1 + 296);
      if (v5)
      {
        v7[0] = MEMORY[0x1895F87A8];
        v7[1] = 0x40000000LL;
        v7[2] = ___ZL30nw_protocol_ohttp_send_requestP17nw_protocol_ohttp_block_invoke;
        v7[3] = &__block_descriptor_tmp_38_28669;
        void v7[4] = a1;
        nw_hash_table_apply(v5, (uint64_t)v7);
      }
    }

    return;
  }

  if (a1 + 64 == v2)
  {
    if (*(void *)(a1 + 48))
    {
LABEL_5:
      nw_protocol_ohttp_context_send_request(a1, *(void *)(a1 + 320));
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v3 = *(char **)(a1 + 296);
    if (v3)
    {
      uint64_t v8 = 0LL;
      os_log_type_t v9 = &v8;
      uint64_t v10 = 0x2000000000LL;
      uint64_t v11 = 0LL;
      *(void *)int buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL42nw_protocol_ohttp_get_protocol_for_contextP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke;
      BOOL v13 = (const char *)&unk_189BBB378;
      BOOL v14 = &v8;
      uint64_t v15 = v2;
      nw_hash_table_apply(v3, (uint64_t)buf);
      uint64_t v4 = v9[3];
      _Block_object_dispose(&v8, 8);
      if (v4) {
        goto LABEL_5;
      }
    }
  }

  if ((*(_BYTE *)(a1 + 348) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_send_request";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 349;
      *(_WORD *)&_BYTE buf[22] = 2080;
      BOOL v13 = " ";
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sPending request context is no longer valid",  buf,  0x20u);
    }
  }

  nw_ohttp_mark_failed_with_error(a1, 22);
}

void nw_ohttp_mark_failed_with_error(uint64_t a1, int a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 344) != 2)
  {
    if ((*(_BYTE *)(a1 + 348) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 136446978;
        char v17 = "nw_ohttp_mark_failed_with_error";
        __int16 v18 = 2082;
        uint64_t v19 = a1 + 349;
        __int16 v20 = 2080;
        __int16 v21 = " ";
        __int16 v22 = 1024;
        int v23 = a2;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sFailing connection with error %{darwin.errno}d",  buf,  0x26u);
      }
    }

    *(_DWORD *)(a1 + 344) = 2;
    *(_DWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 176), 8) = 6;
    os_log_type_t v5 = *(char **)(a1 + 296);
    if (v5)
    {
      v14[0] = MEMORY[0x1895F87A8];
      v14[1] = 0x40000000LL;
      v14[2] = ___ZL31nw_ohttp_mark_failed_with_errorP17nw_protocol_ohttpi_block_invoke;
      v14[3] = &__block_descriptor_tmp_28_28944;
      void v14[4] = a1;
      int v15 = a2;
      nw_hash_table_apply(v5, (uint64_t)v14);
    }

    path = (void *)nw_protocol_get_path(a1);
    if (path)
    {
      os_log_type_t v7 = path;
      id v8 = v7[2];

      if (v8)
      {
        memset(uu, 0, 16);
        os_log_type_t v9 = (id *)v8;
        id v10 = v9[23];

        if (v10)
        {
          uint64_t v11 = (char *)v10;
          *(_OWORD *)__int128 uu = *(_OWORD *)(v11 + 56);

          os_release(v11);
        }

        os_release(v9);
        if (uuid_is_null(uu))
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v12 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446978;
              char v17 = "nw_ohttp_report_error_to_proxy_agent";
              __int16 v18 = 2082;
              uint64_t v19 = a1 + 349;
              __int16 v20 = 2080;
              __int16 v21 = " ";
              __int16 v22 = 1024;
              int v23 = a2;
              _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sCannot report error %d, no proxy agent",  buf,  0x26u);
            }
          }
        }

        else
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v13 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)int buf = 136447490;
              char v17 = "nw_ohttp_report_error_to_proxy_agent";
              __int16 v18 = 2082;
              uint64_t v19 = a1 + 349;
              __int16 v20 = 2080;
              __int16 v21 = " ";
              __int16 v22 = 1024;
              int v23 = a2;
              __int16 v24 = 1042;
              int v25 = 16;
              __int16 v26 = 2098;
              char v27 = uu;
              _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sReporting error %d to proxy agent %{public, uuid_t}.16P",  buf,  0x36u);
            }
          }

          nw_path_report_error_to_agent(v7, uu, a2);
        }
      }
    }

    nw_protocol_error(*(void **)(a1 + 48), a1);
    nw_protocol_disconnected(*(void **)(a1 + 48), a1);
    nw_protocol_disconnect(*(void **)(a1 + 32), a1);
  }

void nw_protocol_ohttp_context_send_request(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v51 = "nw_protocol_ohttp_context_send_request";
    __int16 v18 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v46) = 16;
    LOBYTE(v42) = 0;
    if (v46 == 17)
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = v46;
      if (!os_log_type_enabled(v19, (os_log_type_t)v46)) {
        goto LABEL_71;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v51 = "nw_protocol_ohttp_context_send_request";
      __int16 v21 = "%{public}s called with null ohttp";
    }

    else if ((_BYTE)v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = v46;
      BOOL v23 = os_log_type_enabled(v19, (os_log_type_t)v46);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v51 = "nw_protocol_ohttp_context_send_request";
          __int16 v52 = 2082;
          os_log_type_t v53 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_71;
      }

      if (!v23)
      {
LABEL_71:
        if (v18) {
          free(v18);
        }
        return;
      }

      *(_DWORD *)int buf = 136446210;
      uint64_t v51 = "nw_protocol_ohttp_context_send_request";
      __int16 v21 = "%{public}s called with null ohttp, no backtrace";
    }

    else
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = v46;
      if (!os_log_type_enabled(v19, (os_log_type_t)v46)) {
        goto LABEL_71;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v51 = "nw_protocol_ohttp_context_send_request";
      __int16 v21 = "%{public}s called with null ohttp, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
    goto LABEL_71;
  }

  uint64_t v4 = *(void *)(a1 + 320);
  if (v4) {
    BOOL v5 = v4 == a2;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if (*(void *)(a2 + 136) == *(void *)(a2 + 144))
    {
      if ((*(_BYTE *)(a1 + 348) & 1) == 0)
      {
        if (gLogDatapath)
        {
          os_log_type_t v6 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446722;
            uint64_t v51 = "nw_protocol_ohttp_context_send_request";
            __int16 v52 = 2082;
            os_log_type_t v53 = (char *)(a1 + 349);
            __int16 v54 = 2080;
            BOOL v55 = " ";
            os_log_type_t v7 = "%{public}s %{public}s%signoring write, no pending bytes";
LABEL_16:
            _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, v7, buf, 0x20u);
          }
        }
      }
    }

    else
    {
      uint64_t v27 = a1 + 349;
      uint64_t v46 = 0LL;
      uint64_t v47 = &v46;
      uint64_t v48 = 0x2000000000LL;
      char v49 = 0;
      uint64_t v42 = 0LL;
      BOOL v43 = &v42;
      uint64_t v44 = 0x2000000000LL;
      char v45 = 0;
      while (1)
      {
        if (*(_DWORD *)(a2 + 224) != 1)
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            if (gLogDatapath)
            {
              __int16 v24 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
              {
                int v25 = *(_DWORD *)(a2 + 224);
                *(_DWORD *)int buf = 136446978;
                uint64_t v51 = "nw_protocol_ohttp_context_send_request";
                __int16 v52 = 2082;
                os_log_type_t v53 = (char *)v27;
                __int16 v54 = 2080;
                BOOL v55 = " ";
                __int16 v56 = 1024;
                int v57 = v25;
                _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sskipping, state %u",  buf,  0x26u);
              }
            }
          }

          goto LABEL_55;
        }

        v40[0] = 0LL;
        v40[1] = v40;
        void v40[2] = 0x2000000000LL;
        int v8 = *(_DWORD *)(a2 + 136);
        int v9 = *(_DWORD *)(a2 + 144);
        int v41 = v8 - v9;
        if (v8 == v9) {
          break;
        }
        v39[0] = 0LL;
        v39[1] = v39;
        int output_frames = nw_protocol_get_output_frames( *(void *)(a1 + 32),  a1,  1LL,  (v8 - v9),  0xFFFFFFFFLL,  (uint64_t)v39);
        if ((*(_BYTE *)(a1 + 348) & 1) == 0)
        {
          if (gLogDatapath)
          {
            os_log_type_t log = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446978;
              uint64_t v51 = "nw_protocol_ohttp_context_send_request";
              __int16 v52 = 2082;
              os_log_type_t v53 = (char *)v27;
              __int16 v54 = 2080;
              BOOL v55 = " ";
              __int16 v56 = 1024;
              int v57 = output_frames;
              _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sGot %u output frames",  buf,  0x26u);
            }
          }
        }

        if (!output_frames) {
          break;
        }
        v29[0] = MEMORY[0x1895F87A8];
        v29[1] = 0x40000000LL;
        __int16 v30 = (uint64_t (*)(void *))___ZL38nw_protocol_ohttp_context_send_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke;
        __int16 v31 = &unk_189BBB4E0;
        uint64_t v32 = &v46;
        uint64_t v33 = v40;
        uint64_t v36 = a1;
        uint64_t v37 = a2;
        uint64_t v38 = a1;
        uint64_t v34 = &v42;
        uint32_t v35 = v39;
        uint64_t v11 = v39[0];
        do
        {
          if (!v11) {
            break;
          }
          uint64_t v12 = *(void *)(v11 + 32);
          char v13 = v30(v29);
          uint64_t v11 = v12;
        }

        while ((v13 & 1) != 0);
        nw_protocol_finalize_output_frames(*(void *)(a1 + 32), (uint64_t)v39);
        if (*((_BYTE *)v43 + 24) && !*(_DWORD *)(a1 + 344))
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v14 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446722;
              uint64_t v51 = "nw_protocol_ohttp_context_send_request";
              __int16 v52 = 2082;
              os_log_type_t v53 = (char *)v27;
              __int16 v54 = 2080;
              BOOL v55 = " ";
              _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSent outer request",  buf,  0x20u);
            }
          }

          *(_DWORD *)(a1 + 344) = 1;
        }

        _Block_object_dispose(v40, 8);
        if (*((_BYTE *)v47 + 24)) {
          goto LABEL_36;
        }
      }

      _Block_object_dispose(v40, 8);
LABEL_36:
      if (*(void *)(a2 + 136) == *(void *)(a2 + 144))
      {
        *(void *)(a2 + 136) = 0LL;
        *(void *)(a2 + 144) = 0LL;
        int v15 = *(void **)(a2 + 128);
        if (v15)
        {
          free(v15);
          *(void *)(a2 + 12_Block_object_dispose((const void *)(v1 - 176), 8) = 0LL;
        }
      }

      if (*((_BYTE *)v47 + 24))
      {
        if ((*(_BYTE *)(a1 + 348) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v16 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446722;
            uint64_t v51 = "nw_protocol_ohttp_context_send_request";
            __int16 v52 = 2082;
            os_log_type_t v53 = (char *)v27;
            __int16 v54 = 2080;
            BOOL v55 = " ";
            _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSent complete request",  buf,  0x20u);
          }
        }

        *(void *)(a1 + 320) = 0LL;
        if ((*(_BYTE *)(a2 + 228) & 0x82) == 2) {
          *(_DWORD *)(a2 + 224) = 2;
        }
      }

      else
      {
        if (!*((_BYTE *)v43 + 24)) {
          goto LABEL_55;
        }
        *(void *)(a1 + 320) = a2;
      }

      nw_protocol_ohttp_read_response(a1);
      if (*((_BYTE *)v43 + 24))
      {
        if (*(void *)a2)
        {
          if ((*(_BYTE *)(a2 + 228) & 1) == 0 && (*(_BYTE *)(a1 + 348) & 0x20) == 0)
          {
            *(_BYTE *)(a1 + 348) |= 0x20u;
            char v17 = *(char **)(a1 + 296);
            if (v17)
            {
              v28[0] = MEMORY[0x1895F87A8];
              v28[1] = 0x40000000LL;
              v28[2] = ___ZL38nw_protocol_ohttp_context_send_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke_40;
              v28[3] = &__block_descriptor_tmp_41;
              void v28[4] = a1;
              nw_hash_table_apply(v17, (uint64_t)v28);
            }
          }
        }
      }

BOOL ___ZL30nw_protocol_ohttp_send_requestP17nw_protocol_ohttp_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  BOOL result = 1;
  if (*(_DWORD *)(extra + 224) == 1)
  {
    nw_protocol_ohttp_context_send_request(*(void *)(a1 + 32), extra);
    if (*(void *)(*(void *)(a1 + 32) + 320LL)) {
      return 0;
    }
  }

  return result;
}

uint64_t ___ZL38nw_protocol_ohttp_context_send_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    nw_frame_finalize(a2);
    uint64_t v4 = *(void *)(a2 + 32);
    BOOL v5 = *(void **)(a2 + 40);
    if (v4)
    {
      *(void *)(v4 + 40) = v5;
      BOOL v5 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(a1[7] + 8LL) = v5;
    }

    *BOOL v5 = v4;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    uint64_t v13 = a1[8];
    if (!v13 || (*(_BYTE *)(v13 + 348) & 1) == 0)
    {
      if (gLogDatapath)
      {
        BOOL v14 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v15 = a1[8];
          uint64_t v16 = "";
          BOOL v17 = v15 == 0;
          if (v15) {
            __int16 v18 = (const char *)(v15 + 349);
          }
          else {
            __int16 v18 = "";
          }
          unsigned int v20 = 136446722;
          __int16 v21 = "nw_protocol_ohttp_context_send_request_block_invoke";
          if (!v17) {
            uint64_t v16 = " ";
          }
          __int16 v22 = 2082;
          BOOL v23 = v18;
          __int16 v24 = 2080;
          int v25 = v16;
          _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDropping unneeded output frame",  (uint8_t *)&v20,  0x20u);
        }
      }
    }
  }

  else
  {
    unsigned int v20 = 0;
    os_log_type_t v6 = (void *)nw_frame_unclaimed_bytes(a2, &v20);
    unsigned int v7 = *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
    if (v20 >= v7) {
      size_t v8 = v7;
    }
    else {
      size_t v8 = v20;
    }
    memcpy(v6, (const void *)(*(void *)(a1[9] + 128LL) + *(void *)(a1[9] + 144LL)), v8);
    nw_frame_claim(a2, v9, v8, 0);
    *(void *)(a1[9] + 144LL) += v8;
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) -= v8;
    nw_frame_collapse(a2);
    nw_frame_unclaim(a2, v10, v8, 0);
    BOOL v11 = 0;
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) == 0;
    uint64_t v12 = a1[8];
    if ((*(_BYTE *)(v12 + 348) & 4) == 0)
    {
      if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL)) {
        BOOL v11 = (*(_BYTE *)(a1[9] + 228LL) & 0x82) == 2;
      }
      else {
        BOOL v11 = 0;
      }
    }

    *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
    nw_frame_set_metadata(a2, *(nw_protocol_metadata **)(v12 + 304), 0, v11);
  }

  return 1LL;
}

void nw_protocol_ohttp_read_response(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v2 = a1 + 349;
  uint64_t v3 = MEMORY[0x1895F87A8];
  while (*(_DWORD *)(a1 + 344) == 1)
  {
    v16[0] = 0LL;
    v16[1] = v16;
    int input_frames = nw_protocol_get_input_frames(*(void *)(a1 + 32), a1, 1LL, 0xFFFFFFFFLL, 0xFFFFFFFFLL, (uint64_t)v16);
    if ((*(_BYTE *)(a1 + 348) & 1) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t log = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446978;
          __int16 v18 = "nw_protocol_ohttp_read_response";
          __int16 v19 = 2082;
          uint64_t v20 = v2;
          __int16 v21 = 2080;
          __int16 v22 = " ";
          __int16 v23 = 1024;
          int v24 = input_frames;
          _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sGot %u input frames",  buf,  0x26u);
        }
      }
    }

    if (input_frames)
    {
      v11[0] = v3;
      v11[1] = 0x40000000LL;
      uint64_t v12 = ___ZL31nw_protocol_ohttp_read_responseP17nw_protocol_ohttp_block_invoke;
      uint64_t v13 = &__block_descriptor_tmp_20_28804;
      BOOL v14 = v16;
      uint64_t v15 = a1;
      uint64_t v5 = v16[0];
      do
      {
        if (!v5) {
          break;
        }
        uint64_t v6 = *(void *)(v5 + 32);
        char v7 = ((uint64_t (*)(void *))v12)(v11);
        uint64_t v5 = v6;
      }

      while ((v7 & 1) != 0);
      if ((*(_BYTE *)(a1 + 348) & 0x10) == 0) {
        continue;
      }
    }

    if (*(void *)(a1 + 312))
    {
      if ((*(_BYTE *)(a1 + 348) & 0x12) != 0) {
        nw_protocol_ohttp_process_response(a1);
      }
    }

    return;
  }

  if ((*(_BYTE *)(a1 + 348) & 1) == 0)
  {
    if (gLogDatapath)
    {
      size_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *(_DWORD *)(a1 + 344);
        *(_DWORD *)int buf = 136446978;
        __int16 v18 = "nw_protocol_ohttp_read_response";
        __int16 v19 = 2082;
        uint64_t v20 = v2;
        __int16 v21 = 2080;
        __int16 v22 = " ";
        __int16 v23 = 1024;
        int v24 = v9;
        _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sskipping, state %u", buf, 0x26u);
      }
    }
  }

uint64_t ___ZL38nw_protocol_ohttp_context_send_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke_40( uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  return 1LL;
}

void nw_protocol_ohttp_prepare_request(uint64_t a1, uint64_t a2)
{
  uint64_t v145 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
    BOOL v78 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v13_Block_object_dispose((const void *)(v1 - 176), 8) = 16;
    LOBYTE(v137) = 0;
    if (v138 == 17)
    {
      uint64_t v79 = (os_log_s *)__nwlog_obj();
      os_log_type_t v80 = v138;
      if (!os_log_type_enabled(v79, (os_log_type_t)v138)) {
        goto LABEL_155;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
      uint64_t v81 = "%{public}s called with null ohttp";
    }

    else if ((_BYTE)v137)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v79 = (os_log_s *)__nwlog_obj();
      os_log_type_t v80 = v138;
      BOOL v83 = os_log_type_enabled(v79, (os_log_type_t)v138);
      if (backtrace_string)
      {
        if (v83)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v79,  v80,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_155;
      }

      if (!v83)
      {
LABEL_155:
        if (v78) {
          free(v78);
        }
        return;
      }

      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
      uint64_t v81 = "%{public}s called with null ohttp, no backtrace";
    }

    else
    {
      uint64_t v79 = (os_log_s *)__nwlog_obj();
      os_log_type_t v80 = v138;
      if (!os_log_type_enabled(v79, (os_log_type_t)v138)) {
        goto LABEL_155;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
      uint64_t v81 = "%{public}s called with null ohttp, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v79, v80, v81, buf, 0xCu);
    goto LABEL_155;
  }

  int v4 = *(unsigned __int8 *)(a1 + 348);
  unsigned int v5 = *(_DWORD *)(a2 + 224);
  if ((v4 & 2) != 0)
  {
    if (v5 >= 2) {
      goto LABEL_4;
    }
  }

  else if (v5)
  {
LABEL_4:
    if ((v4 & 1) == 0 && gLogDatapath)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        int v7 = *(_DWORD *)(a2 + 224);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 349;
        *(_WORD *)&_BYTE buf[22] = 2080;
        uint64_t v140 = (uint64_t)" ";
        __int16 v141 = 1024;
        LODWORD(v142) = v7;
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sskipping, state %u", buf, 0x26u);
      }
    }

    return;
  }

  if (!*(void *)(a2 + 72) && !*(void *)(a2 + 216) && (*(_BYTE *)(a2 + 228) & 1) == 0)
  {
    if ((v4 & 1) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 349;
    *(_WORD *)&_BYTE buf[22] = 2080;
    uint64_t v140 = (uint64_t)" ";
    int v9 = "%{public}s %{public}s%sskipping, request doesn't have necessary metadata";
    uint64_t v10 = (os_log_s *)v8;
    os_log_type_t v11 = OS_LOG_TYPE_ERROR;
LABEL_15:
    _os_log_impl(&dword_181A5C000, v10, v11, v9, buf, 0x20u);
    return;
  }

  if (((*(unsigned __int8 *)(a2 + 228) | v4) & 2) == 0)
  {
    if ((v4 & 1) != 0) {
      return;
    }
    if (!gLogDatapath) {
      return;
    }
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 349;
    *(_WORD *)&_BYTE buf[22] = 2080;
    uint64_t v140 = (uint64_t)" ";
    int v9 = "%{public}s %{public}s%sskipping, request not ready";
LABEL_21:
    uint64_t v10 = v12;
    os_log_type_t v11 = OS_LOG_TYPE_DEBUG;
    goto LABEL_15;
  }

  size_t length = xpc_data_get_length(*(xpc_object_t *)(a2 + 88));
  bytes_ptr = (unsigned __int16 *)xpc_data_get_bytes_ptr(*(xpc_object_t *)(a2 + 88));
  uint64_t v15 = (uint64_t *)(a2 + 24);
  *(_DWORD *)int buf = 0;
  nw_frame_array_get_frame_count((uint64_t *)(a2 + 24), 0, buf);
  size_t v16 = *(unsigned int *)buf;
  size_t v116 = *(unsigned int *)buf;
  if ((*(_BYTE *)(a2 + 228) & 1) == 0 || (*(_BYTE *)(a1 + 348) & 0x20) != 0)
  {
    *(_BYTE *)(a2 + 228) &= ~0x80u;
  }

  else
  {
    unint64_t int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_ohttp_standalone_aead_threshold,  3000LL);
    unint64_t v18 = *(void *)(a2 + 152);
    if (v18 + v16 > int64_with_default)
    {
      *(_BYTE *)(a2 + 228) |= 0x80u;
      size_t v16 = int64_with_default - v18;
      if (int64_with_default <= v18)
      {
        if ((*(_BYTE *)(a1 + 348) & 1) != 0) {
          return;
        }
        if (!gLogDatapath) {
          return;
        }
        uint64_t v12 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
          return;
        }
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 349;
        *(_WORD *)&_BYTE buf[22] = 2080;
        uint64_t v140 = (uint64_t)" ";
        int v9 = "%{public}s %{public}s%sskipping, nothing to send, hit threshold";
        goto LABEL_21;
      }
    }
  }

  uint64_t v19 = *v15;
  if (v16 == nw_frame_unclaimed_length((_DWORD *)*v15))
  {
    uint64_t v20 = (const unsigned __int8 *)nw_frame_unclaimed_bytes(v19, 0LL);
LABEL_40:
    int v24 = 0LL;
    goto LABEL_41;
  }

  if (!v16)
  {
    uint64_t v20 = 0LL;
    goto LABEL_40;
  }

  uint64_t v20 = (const unsigned __int8 *)calloc(1uLL, v16);
  if (!v20)
  {
    BOOL v96 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v96, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = 1LL;
    *(_WORD *)&_BYTE buf[22] = 2048;
    uint64_t v140 = v16;
    os_log_type_t v97 = (void *)_os_log_send_and_compose_impl();
    free(v97);
  }

  *(void *)int buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  uint64_t v140 = 0LL;
  v129[0] = MEMORY[0x1895F87A8];
  v129[1] = 0x40000000LL;
  uint64_t v130 = (uint64_t (*)(void *))___ZL33nw_protocol_ohttp_prepare_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke;
  uint64_t v131 = &unk_189BBB450;
  char v132 = buf;
  size_t v133 = v16;
  int v134 = v20;
  uint64_t v21 = *v15;
  do
  {
    if (!v21) {
      break;
    }
    uint64_t v22 = *(void *)(v21 + 16);
    char v23 = v130(v129);
    uint64_t v21 = v22;
  }

  while ((v23 & 1) != 0);
  _Block_object_dispose(buf, 8);
  int v24 = (unsigned __int8 *)v20;
LABEL_41:
  size_t v128 = 0LL;
  unsigned int v25 = *(unsigned __int8 *)(a2 + 228);
  if ((v25 & 1) != 0)
  {
    if (bytes_ptr)
    {
      if (length)
      {
        BOOL v114 = v24;
        if (!v16 || v20)
        {
          unint64_t v27 = *(void *)a2;
          unint64_t v138 = 0LL;
          if (v27 > 0x3F)
          {
            if (v27 >> 14)
            {
              if (v27 >> 30)
              {
                if (v27 >> 62)
                {
                  uint64_t v28 = (os_log_s *)__nwlog_obj();
                  os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)int buf = 136446466;
                  *(void *)&uint8_t buf[4] = "_http_vle_encode";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = v27;
                  uint64_t v29 = (void *)_os_log_send_and_compose_impl();
                  free(v29);
                  size_t __n = 0LL;
                }

                else
                {
                  unint64_t v138 = bswap64(v27 | 0xC000000000000000LL);
                  size_t __n = 8LL;
                }
              }

              else
              {
                unint64_t v138 = bswap32(v27 | 0x80000000);
                size_t __n = 4LL;
              }
            }

            else
            {
              unint64_t v138 = bswap32(v27 | 0x4000) >> 16;
              size_t __n = 2LL;
            }
          }

          else
          {
            unint64_t v138 = v27;
            size_t __n = 1LL;
          }

          uint64_t v30 = *(void *)(a2 + 184);
          if (!v30)
          {
            cchpke_params_x25519_AESGCM128_HKDF_SHA256();
            size_t v31 = cchpke_params_sizeof_aead_nonce();
            *(void *)(a2 + 192) = v31;
            if (!v31)
            {
              __int16 v113 = (os_log_s *)__nwlog_obj();
              os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "strict_malloc";
              int v106 = (void *)_os_log_send_and_compose_impl();
              free(v106);
            }

            uint64_t v32 = malloc(v31);
            if (!v32)
            {
              uint64_t v107 = (os_log_s *)__nwlog_obj();
              os_log_type_enabled(v107, OS_LOG_TYPE_ERROR);
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "strict_malloc";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v31;
              uint64_t v108 = (void *)_os_log_send_and_compose_impl();
              free(v108);
              uint64_t v32 = 0LL;
            }

            *(void *)(a2 + 184) = v32;
            arc4random_buf(v32, *(void *)(a2 + 192));
            *(void *)(a2 + 200) = 0LL;
          }

          int v33 = v25 & 0x82;
          size_t v137 = 0LL;
          if (v16)
          {
            BOOL v34 = nw_http_encrypt_standalone_aead_chunk( (uint64_t)v20,  v16,  *(void *)(a2 + 200),  v33 == 2,  (uint64_t)bytes_ptr,  length,  *(const void **)(a2 + 184),  *(void *)(a2 + 192),  &v137);
            if (!v34)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint32_t v35 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http_create_standalone_aead_request";
                _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to fill out AEAD chunk",  buf,  0xCu);
              }

              uint64_t v26 = 0LL;
              int v24 = v114;
              goto LABEL_112;
            }
          }

          else
          {
            BOOL v34 = 0LL;
          }

          uint64_t v36 = *(void *)(a2 + 200);
          uint64_t v37 = v36 + 1;
          uint64_t v38 = v36 == -1;
          uint64_t v39 = v38 << 63 >> 63;
          *(void *)(a2 + 200) = v37;
          if (v39 == v38 && (v39 & 0x8000000000000000LL) == 0)
          {
LABEL_86:
            if (v30) {
              uint64_t v51 = 0LL;
            }
            else {
              uint64_t v51 = *(void *)(a2 + 192) + 2LL;
            }
            unint64_t v52 = v51 + __n + v137;
            unint64_t __src = 0LL;
            if (v52 > 0x3F)
            {
              if (v52 >> 14)
              {
                if (v52 >> 30)
                {
                  if (v52 >> 62)
                  {
                    __int16 v54 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "_http_vle_encode";
                    *(_WORD *)&buf[12] = 2048;
                    *(void *)&buf[14] = v52;
                    BOOL v55 = (void *)_os_log_send_and_compose_impl();
                    free(v55);
                    size_t v53 = 0LL;
                  }

                  else
                  {
                    unint64_t __src = bswap64(v52 | 0xC000000000000000LL);
                    size_t v53 = 8LL;
                  }
                }

                else
                {
                  unint64_t __src = bswap32(v52 | 0x80000000);
                  size_t v53 = 4LL;
                }
              }

              else
              {
                unint64_t __src = bswap32(v52 | 0x4000) >> 16;
                size_t v53 = 2LL;
              }
            }

            else
            {
              unint64_t __src = v51 + __n + v137;
              size_t v53 = 1LL;
            }

            if (v33 == 2) {
              unint64_t v56 = v52 + 1;
            }
            else {
              unint64_t v56 = v52;
            }
            size_t v57 = v56 + v53;
            size_t v128 = v56 + v53;
            if (!(v56 + v53))
            {
              os_log_type_t v92 = (os_log_s *)__nwlog_obj();
              os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "strict_calloc";
              os_log_type_t v93 = (void *)_os_log_send_and_compose_impl();
              free(v93);
            }

            uint64_t v26 = (char *)calloc(1uLL, v57);
            if (!v26)
            {
              uint64_t v94 = (os_log_s *)__nwlog_obj();
              os_log_type_enabled(v94, OS_LOG_TYPE_ERROR);
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "strict_calloc";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = 1LL;
              *(_WORD *)&_BYTE buf[22] = 2048;
              uint64_t v140 = v57;
              os_log_type_t v95 = (void *)_os_log_send_and_compose_impl();
              free(v95);
            }

            uint64_t v58 = v26;
            if (v33 == 2)
            {
              char *v26 = 0;
              uint64_t v58 = v26 + 1;
            }

            memcpy(v58, &__src, v53);
            BOOL v59 = &v58[v53];
            memcpy(v59, &v138, __n);
            BOOL v60 = &v59[__n];
            if (!v30)
            {
              *(_WORD *)BOOL v60 = 256;
              os_log_type_t v61 = v60 + 2;
              size_t v62 = *(void *)(a2 + 192);
              memcpy(v61, *(const void **)(a2 + 184), v62);
              BOOL v60 = &v61[v62];
            }

            int v24 = v114;
            if (v137) {
              memcpy(v60, (const void *)v34, v137);
            }
            if (v34) {
              free((void *)v34);
            }
            goto LABEL_112;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v40 = *(void *)(a2 + 200);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http_create_standalone_aead_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
          *(_WORD *)&_BYTE buf[22] = 2048;
          uint64_t v140 = 1LL;
          __int16 v141 = 2048;
          uint64_t v142 = v40;
          int v41 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(__src) = 16;
          char v136 = 0;
          if (__nwlog_fault(v41, &__src, &v136))
          {
            if (__src == 17)
            {
              uint64_t v42 = (os_log_s *)__nwlog_obj();
              os_log_type_t v43 = __src;
              if (os_log_type_enabled(v42, (os_log_type_t)__src))
              {
                uint64_t v44 = *(void *)(a2 + 200);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http_create_standalone_aead_request";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
                *(_WORD *)&_BYTE buf[22] = 2048;
                uint64_t v140 = 1LL;
                __int16 v141 = 2048;
                uint64_t v142 = v44;
                char v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_82:
                _os_log_impl(&dword_181A5C000, v42, v43, v45, buf, 0x2Au);
              }
            }

            else if (v136)
            {
              uint64_t v46 = (char *)__nw_create_backtrace_string();
              uint64_t v42 = (os_log_s *)__nwlog_obj();
              os_log_type_t v43 = __src;
              BOOL v47 = os_log_type_enabled(v42, (os_log_type_t)__src);
              if (v46)
              {
                if (v47)
                {
                  uint64_t v48 = *(void *)(a2 + 200);
                  *(_DWORD *)int buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_http_create_standalone_aead_request";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  uint64_t v140 = 1LL;
                  __int16 v141 = 2048;
                  uint64_t v142 = v48;
                  __int16 v143 = 2082;
                  uint64_t v144 = v46;
                  _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v46);
                goto LABEL_83;
              }

              if (v47)
              {
                uint64_t v50 = *(void *)(a2 + 200);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http_create_standalone_aead_request";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
                *(_WORD *)&_BYTE buf[22] = 2048;
                uint64_t v140 = 1LL;
                __int16 v141 = 2048;
                uint64_t v142 = v50;
                char v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_82;
              }
            }

            else
            {
              uint64_t v42 = (os_log_s *)__nwlog_obj();
              os_log_type_t v43 = __src;
              if (os_log_type_enabled(v42, (os_log_type_t)__src))
              {
                uint64_t v49 = *(void *)(a2 + 200);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http_create_standalone_aead_request";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
                *(_WORD *)&_BYTE buf[22] = 2048;
                uint64_t v140 = 1LL;
                __int16 v141 = 2048;
                uint64_t v142 = v49;
                char v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_82;
              }
            }
          }

BOOL ___ZL33nw_protocol_ohttp_prepare_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke( void *a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  uint64_t v3 = (const void *)nw_frame_unclaimed_bytes(a2, &__n);
  unint64_t v4 = a1[5];
  uint64_t v5 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  unint64_t v6 = v5 + __n;
  if (v6 <= v4)
  {
    memcpy((void *)(a1[6] + v5), v3, __n);
    uint64_t v7 = __n;
LABEL_5:
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += v7;
    return v6 <= v4;
  }

  uint64_t v7 = v4 - v5;
  if (v4 != v5)
  {
    memcpy((void *)(a1[6] + v5), v3, v4 - v5);
    goto LABEL_5;
  }

  return v6 <= v4;
}

BOOL nw_http_create_oblivious_request( uint64_t a1, int a2, int a3, const unsigned __int8 *a4, unint64_t a5, unsigned int a6, unsigned __int16 *a7, uint64_t a8, size_t *a9)
{
  uint64_t v131 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v126 = "nw_http_create_oblivious_request";
    char v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null ohttp_context";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null ohttp_context, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v77 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v77) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null ohttp_context, no backtrace";
      goto LABEL_313;
    }

    if (!v77) {
      goto LABEL_298;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v126 = "nw_http_create_oblivious_request";
    __int16 v127 = 2082;
    uint64_t v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null ohttp_context, dumping backtrace:%{public}s";
LABEL_297:
    _os_log_impl(&dword_181A5C000, v24, v25, v78, buf, 0x16u);
    goto LABEL_298;
  }

  uint64_t v10 = *(nw_protocol_metadata **)(a1 + 72);
  os_log_type_t v11 = *(const char **)(a1 + 216);
  if (!((unint64_t)v11 | (unint64_t)v10))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v126 = "nw_http_create_oblivious_request";
    char v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null metadata";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v86 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v86) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_313;
    }

    if (!v86) {
      goto LABEL_298;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v126 = "nw_http_create_oblivious_request";
    __int16 v127 = 2082;
    uint64_t v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
    goto LABEL_297;
  }

  uint64_t v12 = a8;
  uint64_t v13 = a7;
  size_t v15 = a5;
  size_t v16 = a4;
  unint64_t v19 = *(void *)a1;
  if ((a2 & 1) == 0 && (a6 & 1) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v126 = "nw_http_create_oblivious_request";
    char v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null is_complete";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null is_complete, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v87 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v87) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null is_complete, no backtrace";
      goto LABEL_313;
    }

    if (!v87) {
      goto LABEL_298;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v126 = "nw_http_create_oblivious_request";
    __int16 v127 = 2082;
    uint64_t v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null is_complete, dumping backtrace:%{public}s";
    goto LABEL_297;
  }

  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v126 = "nw_http_create_oblivious_request";
    char v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null oblivious_config_buffer";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null oblivious_config_buffer, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v79 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v79) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null oblivious_config_buffer, no backtrace";
      goto LABEL_313;
    }

    if (!v79) {
      goto LABEL_298;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v126 = "nw_http_create_oblivious_request";
    __int16 v127 = 2082;
    uint64_t v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null oblivious_config_buffer, dumping backtrace:%{public}s";
    goto LABEL_297;
  }

  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v126 = "nw_http_create_oblivious_request";
    char v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null oblivious_config_length";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null oblivious_config_length, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v80 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v80) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null oblivious_config_length, no backtrace";
      goto LABEL_313;
    }

    if (!v80) {
      goto LABEL_298;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v126 = "nw_http_create_oblivious_request";
    __int16 v127 = 2082;
    uint64_t v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null oblivious_config_length, dumping backtrace:%{public}s";
    goto LABEL_297;
  }

  uint64_t v20 = a9;
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v126 = "nw_http_create_oblivious_request";
    char v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null out_message_length";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null out_message_length, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v81 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v81) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null out_message_length, no backtrace";
      goto LABEL_313;
    }

    if (!v81) {
      goto LABEL_298;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v126 = "nw_http_create_oblivious_request";
    __int16 v127 = 2082;
    uint64_t v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null out_message_length, dumping backtrace:%{public}s";
    goto LABEL_297;
  }

  if (!a4 && a5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v126 = "nw_http_create_oblivious_request";
    char v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__n) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null body_content";
      goto LABEL_313;
    }

    if (!(_BYTE)__n)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null body_content, backtrace limit exceeded";
      goto LABEL_313;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type[0];
    BOOL v88 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v88) {
        goto LABEL_314;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      uint64_t v26 = "%{public}s called with null body_content, no backtrace";
      goto LABEL_313;
    }

    if (!v88) {
      goto LABEL_298;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v126 = "nw_http_create_oblivious_request";
    __int16 v127 = 2082;
    uint64_t v128 = (uint64_t)backtrace_string;
    BOOL v78 = "%{public}s called with null body_content, dumping backtrace:%{public}s";
    goto LABEL_297;
  }

  if (v11)
  {
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    if (!a5 && (a2 & 1) == 0)
    {
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      uint64_t v126 = "nw_http_create_oblivious_request";
      char v23 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(__n) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type[0];
        if (!os_log_type_enabled(v24, type[0])) {
          goto LABEL_314;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v126 = "nw_http_create_oblivious_request";
        uint64_t v26 = "%{public}s called with null body_length";
        goto LABEL_313;
      }

      if (!(_BYTE)__n)
      {
        int v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type[0];
        if (!os_log_type_enabled(v24, type[0])) {
          goto LABEL_314;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v126 = "nw_http_create_oblivious_request";
        uint64_t v26 = "%{public}s called with null body_length, backtrace limit exceeded";
        goto LABEL_313;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type[0];
      BOOL v93 = os_log_type_enabled(v24, type[0]);
      if (!backtrace_string)
      {
        if (!v93) {
          goto LABEL_314;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v126 = "nw_http_create_oblivious_request";
        uint64_t v26 = "%{public}s called with null body_length, no backtrace";
        goto LABEL_313;
      }

      if (v93)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v126 = "nw_http_create_oblivious_request";
        __int16 v127 = 2082;
        uint64_t v128 = (uint64_t)backtrace_string;
        BOOL v78 = "%{public}s called with null body_length, dumping backtrace:%{public}s";
        goto LABEL_297;
      }

BOOL ___ZL33nw_protocol_ohttp_prepare_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke_34( void *a1, uint64_t a2)
{
  int v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  unint64_t v6 = a1[5];
  int v7 = *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
  unint64_t v8 = (v7 + v4);
  if (v6 < v8)
  {
    int v9 = v6 - v7;
    nw_frame_claim(a2, v5, v6 - v7, 0);
  }

  else
  {
    int v9 = v4;
    uint64_t v10 = *(void *)(a2 + 16);
    os_log_type_t v11 = *(void **)(a2 + 24);
    if (v10)
    {
      *(void *)(v10 + 24) = v11;
      os_log_type_t v11 = *(void **)(a2 + 24);
    }

    else
    {
      *(void *)(a1[6] + 32LL) = v11;
    }

    void *v11 = v10;
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = 0LL;
    buffer = (void *)nw_frame_get_buffer(a2, 0LL);
    if (buffer) {
      free(buffer);
    }
    os_release((void *)a2);
  }

  BOOL result = v6 >= v8;
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) += v9;
  return result;
}

uint64_t ___ZL33nw_protocol_ohttp_prepare_requestP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke_2( uint64_t a1, void *a2)
{
  uint64_t v3 = a2[2];
  int v4 = (void *)a2[3];
  if (v3)
  {
    *(void *)(v3 + 24) = v4;
    int v4 = (void *)a2[3];
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 32LL) = v4;
  }

  void *v4 = v3;
  a2[2] = 0LL;
  a2[3] = 0LL;
  buffer = (void *)nw_frame_get_buffer((uint64_t)a2, 0LL);
  if (buffer) {
    free(buffer);
  }
  os_release(a2);
  return 1LL;
}

uint64_t ___ZL31nw_protocol_ohttp_read_responseP17nw_protocol_ohttp_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void **)(a2 + 40);
  unint64_t v6 = (void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    uint64_t v5 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v5;
  }

  *uint64_t v5 = v4;
  void *v6 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  uint64_t v7 = *(void *)(a1 + 40);
  if ((*(_BYTE *)(v7 + 348) & 0x10) == 0)
  {
    if (*(void *)(v7 + 312)) {
      goto LABEL_6;
    }
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
    }
    id v23 = (id)nw_protocol_copy_http_definition_http_definition;
    int v24 = nw_frame_copy_metadata_for_protocol(a2, (uint64_t)v23);
    if (v23) {
      os_release(v23);
    }
    if (v24)
    {
      id v25 = nw_http_metadata_copy_response(v24);
      if (v25)
      {
        id v26 = v25;
        int status_code = _nw_http_response_get_status_code();

        uint64_t v28 = *(void *)(a1 + 40);
        if (!v28 || (*(_BYTE *)(v28 + 348) & 1) == 0)
        {
          if (gLogDatapath)
          {
            BOOL v50 = (os_log_s *)__nwlog_obj();
            BOOL v51 = os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG);
            uint64_t v28 = *(void *)(a1 + 40);
            if (v51)
            {
              BOOL v52 = v28 == 0;
              if (v28) {
                size_t v53 = (const char *)(v28 + 349);
              }
              else {
                size_t v53 = "";
              }
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_read_response_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v53;
              __int16 v54 = " ";
              if (v52) {
                __int16 v54 = "";
              }
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v64 = v54;
              LOWORD(v65) = 1024;
              *(_DWORD *)((char *)&v65 + 2) = status_code;
              _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRecieved status %u",  buf,  0x26u);
              uint64_t v28 = *(void *)(a1 + 40);
            }
          }
        }

        if (status_code == 200)
        {
          *(void *)(v28 + 312) = v24;
          os_release(v26);
LABEL_6:
          int is_metadata_complete = nw_frame_is_metadata_complete(a2);
          uint64_t v9 = *(void *)(a1 + 40);
          if (!v9 || (*(_BYTE *)(v9 + 348) & 1) == 0)
          {
            if (gLogDatapath)
            {
              uint64_t v44 = (os_log_s *)__nwlog_obj();
              BOOL v45 = os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG);
              uint64_t v9 = *(void *)(a1 + 40);
              if (v45)
              {
                if (v9) {
                  uint64_t v46 = (const char *)(v9 + 349);
                }
                else {
                  uint64_t v46 = "";
                }
                if (v9) {
                  size_t v47 = " ";
                }
                else {
                  size_t v47 = "";
                }
                int v48 = nw_frame_unclaimed_length((_DWORD *)a2);
                *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_read_response_block_invoke";
                *(_WORD *)&buf[12] = 2082;
                unsigned int v49 = ", complete";
                *(_DWORD *)int buf = 136447234;
                if (!is_metadata_complete) {
                  unsigned int v49 = "";
                }
                *(void *)&buf[14] = v46;
                *(_WORD *)&_BYTE buf[22] = 2080;
                uint64_t v64 = v47;
                LOWORD(v65) = 1024;
                *(_DWORD *)((char *)&v65 + 2) = v48;
                HIWORD(v65) = 2080;
                size_t v66 = v49;
                _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived %u bytes%s",  buf,  0x30u);
                uint64_t v9 = *(void *)(a1 + 40);
              }
            }
          }

          *(void *)(a2 + 32) = 0LL;
          uint64_t v10 = *(uint64_t **)(v9 + 336);
          *(void *)(a2 + 40) = v10;
          uint64_t *v10 = a2;
          *(void *)(v9 + 336) = v6;
          if (is_metadata_complete)
          {
            *(_BYTE *)(*(void *)(a1 + 40) + 348LL) |= 0x10u;
            uint64_t v11 = *(void *)(a1 + 40);
            if (!v11 || (*(_BYTE *)(v11 + 348) & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v12 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v13 = *(void *)(a1 + 40);
                BOOL v14 = "";
                BOOL v15 = v13 == 0;
                if (v13) {
                  size_t v16 = (const char *)(v13 + 349);
                }
                else {
                  size_t v16 = "";
                }
                *(_DWORD *)int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_read_response_block_invoke";
                if (!v15) {
                  BOOL v14 = " ";
                }
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v16;
                *(_WORD *)&_BYTE buf[22] = 2080;
                uint64_t v64 = v14;
                BOOL v17 = "%{public}s %{public}s%sReceived complete response";
LABEL_19:
                _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, v17, buf, 0x20u);
                return 1LL;
              }
            }
          }

          return 1LL;
        }

        *(_BYTE *)(v28 + 348) |= 0x10u;
        uint64_t v41 = *(void *)(a1 + 40);
        if (v41)
        {
          *(void *)(v41 + 144) = os_retain(v24);
          *(_BYTE *)(v41 + 292) |= 4u;
          *(_DWORD *)(v41 + 28_Block_object_dispose((const void *)(v1 - 176), 8) = 4;
          nw_protocol_ohttp_deliver_response(v41, v41 + 64);
          uint64_t v42 = *(char **)(v41 + 296);
          if (v42)
          {
            *(void *)int buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&buf[16] = ___ZL41nw_protocol_ohttp_deliver_failure_messageP17nw_protocol_ohttpP20nw_protocol_metadata_block_invoke;
            uint64_t v64 = (const char *)&__block_descriptor_tmp_21_28923;
            uint64_t v65 = v41;
            size_t v66 = (const char *)v24;
            nw_hash_table_apply(v42, (uint64_t)buf);
          }

void nw_protocol_ohttp_process_response(uint64_t a1)
{
  uint64_t v288 = *MEMORY[0x1895F89C0];
  if (!*(void *)(a1 + 312) || (*(_BYTE *)(a1 + 348) & 0x12) == 0)
  {
    nw_ohttp_mark_failed_with_error(a1, 94);
    return;
  }

  if (*(void *)(a1 + 328))
  {
    uint64_t v2 = (uint64_t *)(a1 + 328);
    *(_DWORD *)int buf = 0;
    nw_frame_array_get_frame_count((uint64_t *)(a1 + 328), 1, buf);
    size_t v3 = *(unsigned int *)buf;
    uint64_t v4 = *v2;
    if (nw_frame_unclaimed_length((_DWORD *)*v2) == (_DWORD)v3)
    {
      uint64_t v5 = (char *)nw_frame_unclaimed_bytes(v4, 0LL);
      unint64_t v6 = 0LL;
      if ((*(_BYTE *)(a1 + 348) & 2) == 0) {
        goto LABEL_6;
      }
    }

    else
    {
      if (!(_DWORD)v3)
      {
        uint64_t v224 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v224, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "strict_calloc";
        int v225 = (void *)_os_log_send_and_compose_impl();
        free(v225);
      }

      uint64_t v5 = (char *)calloc(1uLL, v3);
      if (!v5)
      {
        id v226 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v226, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "strict_calloc";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 1LL;
        *(_WORD *)&_BYTE buf[22] = 2048;
        uint64_t v285 = v3;
        int v227 = (void *)_os_log_send_and_compose_impl();
        free(v227);
      }

      *(void *)int buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      uint64_t v285 = 0LL;
      v272[0] = MEMORY[0x1895F87A8];
      v272[1] = 0x40000000LL;
      nw_endpoint_t v273 = ___ZL34nw_protocol_ohttp_process_responseP17nw_protocol_ohttp_block_invoke;
      nw_endpoint_t v274 = &unk_189BBB3A0;
      v275 = buf;
      uint64_t v276 = v5;
      uint64_t v14 = *v2;
      do
      {
        if (!v14) {
          break;
        }
        uint64_t v15 = *(void *)(v14 + 32);
        char v16 = ((uint64_t (*)(void *))v273)(v272);
        uint64_t v14 = v15;
      }

      while ((v16 & 1) != 0);
      _Block_object_dispose(buf, 8);
      unint64_t v6 = v5;
      if ((*(_BYTE *)(a1 + 348) & 2) == 0)
      {
LABEL_6:
        uint64_t v7 = *(const char **)(a1 + 280);
        if (v7)
        {
          size_t v278 = 0LL;
          BOOL v8 = nw_http_decrypt_oblivious_response( v5,  v3,  v7,  *(void *)(a1 + 176),  *(void *)(a1 + 184),  *(const void **)(a1 + 160),  *(void *)(a1 + 168),  &v278);
          if (v8)
          {
            unint64_t v9 = v278;
            *(void *)(a1 + 224) = v8;
            *(void *)(a1 + 232) = v9;
LABEL_9:
            if ((*(_BYTE *)(a1 + 348) & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v10 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 349;
                *(_WORD *)&_BYTE buf[22] = 2080;
                uint64_t v285 = (uint64_t)" ";
                _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sProcessed response",  buf,  0x20u);
              }
            }

            *(_BYTE *)(a1 + 292) |= 4u;
            *(_DWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 176), 8) = 4;
            *(void *)(a1 + 240) = 0LL;
            nw_protocol_ohttp_deliver_response(a1, a1 + 64);
            if (gLogDatapath)
            {
              v230 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v230, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
                _os_log_impl(&dword_181A5C000, v230, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
              }
            }

            *(void *)int buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_28822;
            uint64_t v285 = (uint64_t)&__block_descriptor_tmp_15_28823;
            *(void *)os_log_type_t v286 = v2;
            v286[8] = 1;
            uint64_t v11 = *v2;
            do
            {
              if (!v11) {
                break;
              }
              uint64_t v12 = *(void *)(v11 + 32);
              char v13 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
              uint64_t v11 = v12;
            }

            while ((v13 & 1) != 0);
LABEL_461:
            if (v6) {
              free(v6);
            }
            return;
          }

          if ((*(_BYTE *)(a1 + 348) & 1) != 0) {
            goto LABEL_370;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v184 = (os_log_s *)gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_370;
          }
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 349;
          *(_WORD *)&_BYTE buf[22] = 2080;
          uint64_t v285 = (uint64_t)" ";
          BOOL v185 = "%{public}s %{public}s%sFailed to decrypt oblivious response";
LABEL_369:
          _os_log_impl(&dword_181A5C000, v184, OS_LOG_TYPE_ERROR, v185, buf, 0x20u);
          goto LABEL_370;
        }

        if (v5)
        {
          if ((_DWORD)v3)
          {
            uint64_t v172 = *(void *)(a1 + 176);
            if (v172)
            {
              uint64_t v173 = *(void *)(a1 + 184);
              if (v173)
              {
                uint64_t v174 = *(const void **)(a1 + 160);
                if (v174)
                {
                  size_t v175 = *(void *)(a1 + 168);
                  if (v175)
                  {
                    size_t v278 = 0LL;
                    BOOL v176 = nw_http_decrypt_oblivious_response(v5, v3, "message/bhttp", v172, v173, v174, v175, &v278);
                    if (v176)
                    {
                      BOOL v177 = (_DWORD *)v176;
                      if (v278)
                      {
                        __size[0] = 0LL;
                        uint64_t v178 = nw_http_copy_metadata_from_binary_message((_DWORD *)v176, v278, __size, 0LL);
                        if (!v178)
                        {
                          uint64_t v188 = (os_log_s *)__nwlog_obj();
                          if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)int buf = 136446210;
                            *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                            _os_log_impl( &dword_181A5C000,  v188,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to extract HTTP metadata",  buf,  0xCu);
                          }

                          free(v177);
                          goto LABEL_366;
                        }

                        int v179 = v178;
                        size_t v180 = __size[0];
                        if (!__size[0])
                        {
                          free(v177);
                          size_t v183 = 0LL;
                          uint64_t v181 = 0LL;
                          goto LABEL_352;
                        }

                        uint64_t v181 = (char *)calloc(1uLL, __size[0]);
                        if (v181)
                        {
                          BOOL v182 = nw_http_fillout_body_from_binary_message(v177, v278, v181, __size[0], __size);
                          free(v177);
                          if (v182)
                          {
LABEL_320:
                            size_t v183 = __size[0];
LABEL_352:
                            *(void *)(a1 + 224) = v181;
                            *(void *)(a1 + 232) = v183;
                            *(void *)(a1 + 144) = v179;
                            goto LABEL_9;
                          }

                          free(v181);
                          goto LABEL_363;
                        }

                        char v245 = (os_log_s *)__nwlog_obj();
                        os_log_type_enabled(v245, OS_LOG_TYPE_ERROR);
                        *(_DWORD *)int buf = 136446722;
                        *(void *)&uint8_t buf[4] = "strict_calloc";
                        *(_WORD *)&buf[12] = 2048;
                        *(void *)&buf[14] = 1LL;
                        *(_WORD *)&_BYTE buf[22] = 2048;
                        uint64_t v285 = v180;
                        int v246 = (void *)_os_log_send_and_compose_impl();
                        if (!__nwlog_abort((uint64_t)v246))
                        {
                          free(v246);
                          BOOL v247 = nw_http_fillout_body_from_binary_message(v177, v278, 0LL, __size[0], __size);
                          free(v177);
                          uint64_t v2 = (uint64_t *)(a1 + 328);
                          if (v247) {
                            goto LABEL_320;
                          }
LABEL_363:
                          os_release(v179);
                          uint64_t v186 = (os_log_s *)__nwlog_obj();
                          if (!os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_366;
                          }
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                          char v187 = "%{public}s Failed to fill out body content";
                          goto LABEL_365;
                        }

LABEL_365:
                    _os_log_impl(&dword_181A5C000, v186, OS_LOG_TYPE_ERROR, v187, buf, 0xCu);
                    goto LABEL_366;
                  }

                  __nwlog_obj();
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                  v231 = (char *)_os_log_send_and_compose_impl();
                  LOBYTE(v27_Block_object_dispose((const void *)(v1 - 176), 8) = 16;
                  LOBYTE(__size[0]) = 0;
                  if (__nwlog_fault(v231, &v278, __size))
                  {
                    if (v278 == 17)
                    {
                      nw_endpoint_t v232 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v233 = v278;
                      if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                        goto LABEL_524;
                      }
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                      uint64_t v234 = "%{public}s called with null request_enc_length";
                      goto LABEL_523;
                    }

                    if (!LOBYTE(__size[0]))
                    {
                      nw_endpoint_t v232 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v233 = v278;
                      if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                        goto LABEL_524;
                      }
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                      uint64_t v234 = "%{public}s called with null request_enc_length, backtrace limit exceeded";
                      goto LABEL_523;
                    }

                    backtrace_string = (char *)__nw_create_backtrace_string();
                    nw_endpoint_t v232 = (os_log_s *)__nwlog_obj();
                    os_log_type_t v233 = v278;
                    BOOL v244 = os_log_type_enabled(v232, (os_log_type_t)v278);
                    if (!backtrace_string)
                    {
                      if (!v244) {
                        goto LABEL_524;
                      }
                      *(_DWORD *)int buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                      uint64_t v234 = "%{public}s called with null request_enc_length, no backtrace";
                      goto LABEL_523;
                    }

                    if (v244)
                    {
                      *(_DWORD *)int buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = backtrace_string;
                      _os_log_impl( &dword_181A5C000,  v232,  v233,  "%{public}s called with null request_enc_length, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(backtrace_string);
                  }

  if (v159) {
    free(v159);
  }
  p_output_handler = v158;
  uint64_t v150 = v157;
  os_log_type_t v72 = v156;
LABEL_368:
  id v169 = v150;
  uint64_t v170 = ((*(unsigned __int16 *)(*((void *)v67 + 13) + 108LL) | (*(unsigned __int8 *)(*((void *)v67 + 13) + 110LL) << 16)) & 0x10000) == 0;

  if (v170 || (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4393, &v551, 4u) & 0x80000000) == 0) {
    goto LABEL_395;
  }
  uint64_t v171 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  uint64_t v172 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(void *)v555 = (char *)a1 + 404;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v171;
    _os_log_impl( &dword_181A5C000,  v172,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  uint64_t v173 = (os_log_s *)__nwlog_obj();
  uint64_t v174 = v173;
  if (v171 == 22)
  {
    if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      _os_log_impl( &dword_181A5C000,  v174,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d",  buf,  0x12u);
    }

    goto LABEL_395;
  }

  size_t v175 = v72;
  BOOL v176 = v150;
  BOOL v177 = p_output_handler;
  *(_DWORD *)int buf = 136446466;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v171;
  uint64_t v178 = (char *)_os_log_send_and_compose_impl();
  v548[0] = OS_LOG_TYPE_ERROR;
  v547[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v178, v548, v547))
  {
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      int v179 = (os_log_s *)__nwlog_obj();
      size_t v180 = v548[0];
      if (os_log_type_enabled(v179, v548[0]))
      {
        *(_DWORD *)int buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v171;
        uint64_t v181 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d";
LABEL_390:
        uint64_t v186 = v179;
        char v187 = v180;
LABEL_391:
        _os_log_impl(&dword_181A5C000, v186, v187, v181, buf, 0x12u);
      }
    }

    else if (v547[0])
    {
      BOOL v182 = (char *)__nw_create_backtrace_string();
      size_t v183 = (os_log_s *)__nwlog_obj();
      BOOL v184 = v548[0];
      BOOL v185 = os_log_type_enabled(v183, v548[0]);
      if (v182)
      {
        if (v185)
        {
          *(_DWORD *)int buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v171;
          *(_WORD *)&v555[4] = 2082;
          *(void *)&v555[6] = v182;
          _os_log_impl( &dword_181A5C000,  v183,  v184,  "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v182);
        goto LABEL_392;
      }

      if (v185)
      {
        *(_DWORD *)int buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v171;
        uint64_t v181 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, no backtrace";
        uint64_t v186 = v183;
        char v187 = v184;
        goto LABEL_391;
      }
    }

    else
    {
      int v179 = (os_log_s *)__nwlog_obj();
      size_t v180 = v548[0];
      if (os_log_type_enabled(v179, v548[0]))
      {
        *(_DWORD *)int buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v171;
        uint64_t v181 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_390;
      }
    }
  }

LABEL_524:
                  if (!v231) {
                    goto LABEL_366;
                  }
                  goto LABEL_525;
                }

                __nwlog_obj();
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                v231 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v27_Block_object_dispose((const void *)(v1 - 176), 8) = 16;
                LOBYTE(__size[0]) = 0;
                if (v278 == 17)
                {
                  nw_endpoint_t v232 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v233 = v278;
                  if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                    goto LABEL_524;
                  }
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                  uint64_t v234 = "%{public}s called with null request_enc";
                  goto LABEL_523;
                }

                if (!LOBYTE(__size[0]))
                {
                  nw_endpoint_t v232 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v233 = v278;
                  if (!os_log_type_enabled(v232, (os_log_type_t)v278)) {
                    goto LABEL_524;
                  }
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                  uint64_t v234 = "%{public}s called with null request_enc, backtrace limit exceeded";
                  goto LABEL_523;
                }

                id v236 = (char *)__nw_create_backtrace_string();
                nw_endpoint_t v232 = (os_log_s *)__nwlog_obj();
                os_log_type_t v233 = v278;
                BOOL v242 = os_log_type_enabled(v232, (os_log_type_t)v278);
                if (!v236)
                {
                  if (!v242) {
                    goto LABEL_524;
                  }
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                  uint64_t v234 = "%{public}s called with null request_enc, no backtrace";
                  goto LABEL_523;
                }

                if (v242)
                {
                  *(_DWORD *)int buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http_create_message_from_oblivious_response";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v236;
                  v238 = "%{public}s called with null request_enc, dumping backtrace:%{public}s";
                  goto LABEL_484;
                }

    _os_log_impl(&dword_181A5C000, v160, v161, v162, buf, 0xCu);
    goto LABEL_525;
  }

LABEL_523:
        _os_log_impl(&dword_181A5C000, v232, v233, v234, buf, 0xCu);
        goto LABEL_524;
      }
    }

    id v265 = v6;
    if (!v5 || !(_DWORD)v3) {
      goto LABEL_457;
    }
    uint64_t v17 = a1 + 64;
    dispatch_block_t destructor = (dispatch_block_t)*MEMORY[0x1895F8A88];
    char v266 = (uint64_t *)(a1 + 328);
    while (1)
    {
      char v18 = *(_BYTE *)(a1 + 348);
      if ((v18 & 4) != 0)
      {
        unsigned int v19 = *v5;
        if (v19 >= 0x40) {
          goto LABEL_52;
        }
      }

      else
      {
        if (*(void *)(a1 + 248))
        {
          unsigned int v19 = *v5;
          if (v19 < 0x40) {
            goto LABEL_31;
          }
LABEL_47:
          unsigned int v32 = v19 >> 6;
          if (v32 == 2)
          {
            if (v3 < 4) {
              goto LABEL_452;
            }
            unint64_t v20 = bswap32(*(_DWORD *)v5 & 0xFFFFFF7F);
            unint64_t v21 = 4LL;
          }

          else if (v32 == 1)
          {
            if (v3 < 2) {
              goto LABEL_452;
            }
            unint64_t v20 = bswap32(*(_WORD *)v5 & 0xFFBF) >> 16;
            unint64_t v21 = 2LL;
          }

          else
          {
            if (v3 < 8) {
              goto LABEL_452;
            }
            unint64_t v20 = bswap64(*(void *)v5 & 0xFFFFFFFFFFFFFF3FLL);
            unint64_t v21 = 8LL;
          }

          goto LABEL_75;
        }

        cchpke_params_x25519_AESGCM128_HKDF_SHA256();
        unint64_t v24 = cchpke_params_sizeof_aead_key();
        unint64_t v25 = cchpke_params_sizeof_aead_nonce();
        if (v24 <= v25) {
          size_t v26 = v25;
        }
        else {
          size_t v26 = v24;
        }
        BOOL v27 = v3 >= v26;
        v3 -= v26;
        if (!v27)
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            char v209 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v209, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              v195 = "%{public}s %{public}s%sNot enough bytes for nonce length";
              uint64_t v210 = v209;
              os_log_type_t v211 = OS_LOG_TYPE_ERROR;
              goto LABEL_456;
            }
          }

          goto LABEL_457;
        }

        if (!v26)
        {
          uint64_t v120 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v120, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "strict_calloc";
          os_log_type_t v121 = (void *)_os_log_send_and_compose_impl();
          free(v121);
          uint64_t v17 = a1 + 64;
        }

        uint64_t v28 = calloc(1uLL, v26);
        if (!v28)
        {
          size_t v122 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "strict_calloc";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = 1LL;
          *(_WORD *)&_BYTE buf[22] = 2048;
          uint64_t v285 = v26;
          int v123 = (void *)_os_log_send_and_compose_impl();
          free(v123);
          uint64_t v17 = a1 + 64;
        }

        *(void *)(a1 + 24_Block_object_dispose((const void *)(v1 - 176), 8) = v28;
        memcpy(v28, v5, v26);
        *(void *)(a1 + 256) = v26;
        size_t v278 = 0LL;
        v279 = &v278;
        uint64_t v280 = 0x2000000000LL;
        LODWORD(v281) = v26;
        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL45nw_protocol_finalize_partial_temp_frame_arrayP16nw_frame_array_sjP11nw_protocolb_block_invoke;
        uint64_t v285 = (uint64_t)&unk_189BBB408;
        *(void *)os_log_type_t v286 = &v278;
        *(void *)&v286[8] = v2;
        char v287 = 1;
        *(void *)&v286[16] = a1;
        uint64_t v29 = *(void *)(a1 + 328);
        do
        {
          if (!v29) {
            break;
          }
          uint64_t v30 = *(void *)(v29 + 32);
          char v31 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          uint64_t v29 = v30;
        }

        while ((v31 & 1) != 0);
        _Block_object_dispose(&v278, 8);
        if (!v3)
        {
          __nwlog_obj();
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_parse_chunk_length";
          uint64_t v220 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v27_Block_object_dispose((const void *)(v1 - 176), 8) = 16;
          LOBYTE(__size[0]) = 0;
          if (v278 == 17)
          {
            v221 = (os_log_s *)__nwlog_obj();
            os_log_type_t v222 = v278;
            if (os_log_type_enabled(v221, (os_log_type_t)v278))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_parse_chunk_length";
              v223 = "%{public}s called with null response_length";
              goto LABEL_448;
            }

            goto LABEL_449;
          }

          if (!LOBYTE(__size[0]))
          {
            v221 = (os_log_s *)__nwlog_obj();
            os_log_type_t v222 = v278;
            if (!os_log_type_enabled(v221, (os_log_type_t)v278)) {
              goto LABEL_449;
            }
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http_parse_chunk_length";
            v223 = "%{public}s called with null response_length, backtrace limit exceeded";
LABEL_448:
            _os_log_impl(&dword_181A5C000, v221, v222, v223, buf, 0xCu);
            goto LABEL_449;
          }

          char v228 = (char *)__nw_create_backtrace_string();
          v221 = (os_log_s *)__nwlog_obj();
          os_log_type_t v222 = v278;
          BOOL v229 = os_log_type_enabled(v221, (os_log_type_t)v278);
          if (v228)
          {
            if (v229)
            {
              *(_DWORD *)int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http_parse_chunk_length";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v228;
              _os_log_impl( &dword_181A5C000,  v221,  v222,  "%{public}s called with null response_length, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v228);
            goto LABEL_449;
          }

          if (v229)
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http_parse_chunk_length";
            v223 = "%{public}s called with null response_length, no backtrace";
            goto LABEL_448;
          }

LABEL_449:
          if (v220) {
            free(v220);
          }
          char v18 = *(_BYTE *)(a1 + 348);
LABEL_452:
          if ((v18 & 1) == 0)
          {
            __int16 v194 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              v195 = "%{public}s %{public}s%sFailed to parse chunk";
LABEL_455:
              uint64_t v210 = v194;
              os_log_type_t v211 = OS_LOG_TYPE_DEBUG;
LABEL_456:
              _os_log_impl(&dword_181A5C000, v210, v211, v195, buf, 0x20u);
            }
          }

          goto LABEL_457;
        }

        char v18 = *(_BYTE *)(a1 + 348);
        v5 += v26;
        unsigned int v19 = *v5;
        if ((v18 & 4) == 0)
        {
          if (v19 > 0x3F) {
            goto LABEL_47;
          }
LABEL_31:
          unint64_t v20 = v19;
          unint64_t v21 = 1LL;
LABEL_75:
          if (v20 > v3 - v21) {
            goto LABEL_452;
          }
          unint64_t v38 = 0LL;
          BOOL v267 = v20 == 0;
          goto LABEL_96;
        }

        if (v19 > 0x3F)
        {
LABEL_52:
          unsigned int v33 = v19 >> 6;
          if (v33 == 2)
          {
            if (v3 < 4) {
              goto LABEL_452;
            }
            unint64_t v22 = bswap32(*(_DWORD *)v5 & 0xFFFFFF7F);
            uint64_t v23 = 4LL;
          }

          else if (v33 == 1)
          {
            if (v3 < 2) {
              goto LABEL_452;
            }
            unint64_t v22 = bswap32(*(_WORD *)v5 & 0xFFBF) >> 16;
            uint64_t v23 = 2LL;
          }

          else
          {
            if (v3 < 8) {
              goto LABEL_452;
            }
            unint64_t v22 = bswap64(*(void *)v5 & 0xFFFFFFFFFFFFFF3FLL);
            uint64_t v23 = 8LL;
          }

          goto LABEL_60;
        }
      }

      unint64_t v22 = v19;
      uint64_t v23 = 1LL;
LABEL_60:
      unint64_t v34 = v3 - v23;
      if (v22 > v3 - v23) {
        goto LABEL_452;
      }
      size_t v35 = &v5[v23];
      if (v22)
      {
        BOOL v267 = 0;
        if (!v34) {
          goto LABEL_452;
        }
      }

      else
      {
        if (!v34) {
          goto LABEL_452;
        }
        unint64_t v22 = *v35;
        if (v22 > 0x3F)
        {
          unsigned int v37 = v22 >> 6;
          if (v37 == 2)
          {
            if (v34 < 4) {
              goto LABEL_452;
            }
            unint64_t v22 = bswap32(*(_DWORD *)v35 & 0xFFFFFF7F);
            uint64_t v36 = 4LL;
          }

          else if (v37 == 1)
          {
            if (v34 < 2) {
              goto LABEL_452;
            }
            unint64_t v22 = bswap32(*(_WORD *)v35 & 0xFFBF) >> 16;
            uint64_t v36 = 2LL;
          }

          else
          {
            if (v34 < 8) {
              goto LABEL_452;
            }
            unint64_t v22 = bswap64(*(void *)v35 & 0xFFFFFFFFFFFFFF3FLL);
            uint64_t v36 = 8LL;
          }
        }

        else
        {
          uint64_t v36 = 1LL;
        }

        v34 -= v36;
        if (v22 > v34) {
          goto LABEL_452;
        }
        v35 += v36;
        v23 += v36;
        BOOL v267 = 1;
        if (!v34) {
          goto LABEL_452;
        }
      }

      unint64_t v38 = *v35;
      if (v38 > 0x3F)
      {
        if (v38 >> 6 == 2)
        {
          if (v34 < 4) {
            goto LABEL_452;
          }
          unint64_t v38 = bswap32(*(_DWORD *)v35 & 0xFFFFFF7F);
          unint64_t v39 = 4LL;
        }

        else if (v38 >> 6 == 1)
        {
          if (v34 < 2) {
            goto LABEL_452;
          }
          unint64_t v38 = bswap32(*(_WORD *)v35 & 0xFFBF) >> 16;
          unint64_t v39 = 2LL;
        }

        else
        {
          if (v34 < 8) {
            goto LABEL_452;
          }
          unint64_t v38 = bswap64(*(void *)v35 & 0xFFFFFFFFFFFFFF3FLL);
          unint64_t v39 = 8LL;
        }
      }

      else
      {
        unint64_t v39 = 1LL;
      }

      unint64_t v20 = v22 - v39;
      if (v22 < v39 || v38 > v34 - v39) {
        goto LABEL_452;
      }
      unint64_t v21 = v39 + v23;
LABEL_96:
      if (v3 < v21)
      {
        if ((v18 & 1) == 0)
        {
          __int16 v189 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 349;
            *(_WORD *)&_BYTE buf[22] = 2080;
            uint64_t v285 = (uint64_t)" ";
            _os_log_impl( &dword_181A5C000,  v189,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to parse chunk (fatal)",  buf,  0x20u);
          }
        }

        if (gLogDatapath)
        {
          nw_endpoint_t v248 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v248, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            _os_log_impl(&dword_181A5C000, v248, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
          }
        }

        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_28822;
        uint64_t v285 = (uint64_t)&__block_descriptor_tmp_15_28823;
        *(void *)os_log_type_t v286 = v2;
        v286[8] = 1;
        uint64_t v190 = *v2;
        do
        {
          if (!v190) {
            break;
          }
          uint64_t v191 = *(void *)(v190 + 32);
          char v192 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          uint64_t v190 = v191;
        }

        while ((v192 & 1) != 0);
        if (v265)
        {
          char v193 = v265;
          goto LABEL_394;
        }

        goto LABEL_395;
      }

      if ((v18 & 4) == 0 && !v20)
      {
        if ((v18 & 0x10) == 0)
        {
          if ((v18 & 1) == 0)
          {
            __int16 v194 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              v195 = "%{public}s %{public}s%sNot enough bytes to parse final chunk";
              goto LABEL_455;
            }
          }

        if (v185) {
          free(v185);
        }
        char v13 = v184;
        if (!*(void *)(v12 + 488))
        {
LABEL_452:
          char v219 = *(void *)(v12 + 784);
          if (v219)
          {
            if (*(void *)v219)
            {
              dispatch_source_set_timer( *(dispatch_source_t *)v219,  0x8000000000000000LL,  0xFFFFFFFFFFFFFFFFLL,  0x3B9ACA00uLL);
            }

            else
            {
              *(_OWORD *)(v219 + 32) = xmmword_18272D790;
              if (*(_BYTE *)(v219 + 48) && *(_BYTE *)(v219 + 49)) {
                nw_queue_source_run_timer(v219, (uint64_t)a2);
              }
            }
          }

          else
          {
            if ((*(_BYTE *)(v12 + 158) & 1) == 0)
            {
              uint64_t v220 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v220, OS_LOG_TYPE_ERROR))
              {
                v221 = *(void *)(v12 + 488);
                os_log_type_t v222 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
                v223 = *(_DWORD *)(v12 + 860);
                if (v221) {
                  LODWORD(v221) = *(_DWORD *)(v221 + 424);
                }
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v12 + 74;
                *(_WORD *)&_BYTE buf[22] = 2080;
                *(void *)&_BYTE buf[24] = " ";
                *(_WORD *)&_BYTE buf[32] = 1024;
                *(_DWORD *)&buf[34] = v222;
                *(_WORD *)&buf[38] = 1024;
                *(_DWORD *)&uint8_t buf[40] = v223;
                LOWORD(v265) = 1024;
                *(_DWORD *)((char *)&v265 + 2) = v221;
                _os_log_impl( &dword_181A5C000,  v220,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> No destroy timer on HTTP/1 connection when closing",  buf,  0x32u);
              }
            }

            uint64_t v224 = *(void *)(v12 + 608);
            int v225 = *(void **)(v12 + 496);
            *(void *)int buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&buf[16] = ___ZL25nw_http1_connection_closeP19nw_http1_connection_block_invoke;
            *(void *)&_BYTE buf[24] = &unk_189BBD518;
            *(void *)&_BYTE buf[32] = v224;
            nw_queue_context_async(v225, buf);
          }
        }

        goto LABEL_237;
      }

      if (type)
      {
        uint64_t v199 = (char *)__nw_create_backtrace_string();
        uint64_t v186 = (os_log_s *)__nwlog_obj();
        char v187 = v260[0];
        char v215 = os_log_type_enabled(v186, v260[0]);
        if (v199)
        {
          if (v215)
          {
            *(_DWORD *)unsigned int v268 = 136446466;
            *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
            *(_WORD *)&v268[12] = 2082;
            *(void *)&v268[14] = v199;
            char v201 = "%{public}s called with null http1, dumping backtrace:%{public}s";
LABEL_401:
            uint64_t v202 = v268;
LABEL_402:
            _os_log_impl(&dword_181A5C000, v186, v187, v201, v202, 0x16u);
          }

          goto LABEL_403;
        }

        if (!v215) {
          goto LABEL_449;
        }
        *(_DWORD *)unsigned int v268 = 136446210;
        *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
        uint64_t v188 = "%{public}s called with null http1, no backtrace";
      }

      else
      {
        uint64_t v186 = (os_log_s *)__nwlog_obj();
        char v187 = v260[0];
        if (!os_log_type_enabled(v186, v260[0])) {
          goto LABEL_449;
        }
        *(_DWORD *)unsigned int v268 = 136446210;
        *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
        uint64_t v188 = "%{public}s called with null http1, backtrace limit exceeded";
      }
    }

    else
    {
      BOOL v184 = v13;
      __nwlog_obj();
      *(_DWORD *)unsigned int v268 = 136446210;
      *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
      BOOL v185 = (char *)_os_log_send_and_compose_impl();
      v260[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (v260[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v186 = (os_log_s *)__nwlog_obj();
        char v187 = v260[0];
        if (os_log_type_enabled(v186, v260[0]))
        {
          *(_DWORD *)unsigned int v268 = 136446210;
          *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
          uint64_t v188 = "%{public}s called with null http1_connection->context";
          goto LABEL_447;
        }

        goto LABEL_449;
      }

      if (type)
      {
        uint64_t v199 = (char *)__nw_create_backtrace_string();
        uint64_t v186 = (os_log_s *)__nwlog_obj();
        char v187 = v260[0];
        uint64_t v214 = os_log_type_enabled(v186, v260[0]);
        if (v199)
        {
          if (v214)
          {
            *(_DWORD *)unsigned int v268 = 136446466;
            *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
            *(_WORD *)&v268[12] = 2082;
            *(void *)&v268[14] = v199;
            char v201 = "%{public}s called with null http1_connection->context, dumping backtrace:%{public}s";
            goto LABEL_401;
          }

          goto LABEL_403;
        }

        if (!v214) {
          goto LABEL_449;
        }
        *(_DWORD *)unsigned int v268 = 136446210;
        *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
        uint64_t v188 = "%{public}s called with null http1_connection->context, no backtrace";
      }

      else
      {
        uint64_t v186 = (os_log_s *)__nwlog_obj();
        char v187 = v260[0];
        if (!os_log_type_enabled(v186, v260[0])) {
          goto LABEL_449;
        }
        *(_DWORD *)unsigned int v268 = 136446210;
        *(void *)&v268[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
        uint64_t v188 = "%{public}s called with null http1_connection->context, backtrace limit exceeded";
      }
    }

LABEL_395:
          nw_ohttp_mark_failed_with_error(a1, 22);
          return;
        }
      }

      if ((*(_BYTE *)(v17 + 228) & 1) != 0)
      {
        if ((v18 & 1) == 0)
        {
          __int16 v196 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v196, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 349;
            *(_WORD *)&_BYTE buf[22] = 2080;
            uint64_t v285 = (uint64_t)" ";
            *(_WORD *)os_log_type_t v286 = 2048;
            *(void *)&v286[2] = v38;
            _os_log_impl( &dword_181A5C000,  v196,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sContext ID %llu is used for standalone AEAD, cannot receive responses",  buf,  0x2Au);
          }
        }

        __int128 v197 = v265;
        if (gLogDatapath)
        {
          os_log_type_t v249 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v249, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            _os_log_impl(&dword_181A5C000, v249, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
          }
        }

        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_28822;
        uint64_t v285 = (uint64_t)&__block_descriptor_tmp_15_28823;
        *(void *)os_log_type_t v286 = a1 + 328;
        v286[8] = 1;
        uint64_t v198 = *v266;
        do
        {
          if (!v198) {
            break;
          }
          uint64_t v199 = *(void *)(v198 + 32);
          char v200 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          uint64_t v198 = v199;
        }

        while ((v200 & 1) != 0);
        goto LABEL_392;
      }

      if ((v18 & 4) != 0 && !*(void *)(v17 + 184))
      {
        if (*(void *)(v17 + 200))
        {
          if ((v18 & 1) == 0)
          {
            nw_endpoint_t v212 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              _os_log_impl( &dword_181A5C000,  v212,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sNo nonce parsed before non-initial chunk",  buf,  0x20u);
            }
          }

          __int128 v197 = v265;
          if (gLogDatapath)
          {
            id v252 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v252, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_181A5C000, v252, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }

          *(void *)int buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_28822;
          uint64_t v285 = (uint64_t)&__block_descriptor_tmp_15_28823;
          *(void *)os_log_type_t v286 = a1 + 328;
          v286[8] = 1;
          uint64_t v213 = *v266;
          do
          {
            if (!v213) {
              break;
            }
            uint64_t v214 = *(void *)(v213 + 32);
            char v215 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            uint64_t v213 = v214;
          }

          while ((v215 & 1) != 0);
          goto LABEL_392;
        }

        cchpke_params_x25519_AESGCM128_HKDF_SHA256();
        size_t v41 = v20;
        unint64_t v42 = cchpke_params_sizeof_aead_key();
        unint64_t v43 = cchpke_params_sizeof_aead_nonce();
        if (v42 <= v43) {
          size_t v44 = v43;
        }
        else {
          size_t v44 = v42;
        }
        BOOL v27 = v41 >= v44;
        unint64_t v45 = v41 - v44;
        if (!v27)
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            id v216 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v216, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              _os_log_impl( &dword_181A5C000,  v216,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sChunk is too small for nonce length",  buf,  0x20u);
            }
          }

          if (gLogDatapath)
          {
            int v253 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v253, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_181A5C000, v253, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }

          *(void *)int buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_28822;
          uint64_t v285 = (uint64_t)&__block_descriptor_tmp_15_28823;
          *(void *)os_log_type_t v286 = a1 + 328;
          v286[8] = 1;
          uint64_t v217 = *v266;
          do
          {
            if (!v217) {
              break;
            }
            uint64_t v218 = *(void *)(v217 + 32);
            char v219 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            uint64_t v217 = v218;
          }

          while ((v219 & 1) != 0);
          if (v265)
          {
            char v193 = v265;
LABEL_394:
            free(v193);
          }

          goto LABEL_395;
        }

        if (!v44)
        {
          __int16 v153 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v153, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "strict_calloc";
          uint64_t v154 = (void *)_os_log_send_and_compose_impl();
          free(v154);
        }

        uint64_t v46 = calloc(1uLL, v44);
        if (!v46)
        {
          unint64_t v155 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v155, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "strict_calloc";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = 1LL;
          *(_WORD *)&_BYTE buf[22] = 2048;
          uint64_t v285 = v44;
          uint64_t v156 = (void *)_os_log_send_and_compose_impl();
          free(v156);
        }

        *(void *)(v17 + 184) = v46;
        memcpy(v46, &v5[v21], v44);
        *(void *)(v17 + 192) = v44;
        v21 += v44;
        unint64_t v20 = v45;
      }

      if (v20)
      {
        if ((*(_BYTE *)(a1 + 348) & 1) == 0)
        {
          if (gLogDatapath)
          {
            uint64_t v119 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              *(_WORD *)os_log_type_t v286 = 2048;
              *(void *)&v286[2] = v20;
              *(_WORD *)&v286[10] = 2048;
              *(void *)&v286[12] = v38;
              _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sParsing chunk of length %llu for context %llu",  buf,  0x34u);
            }
          }
        }

        unint64_t v264 = v21;
        if (*(void *)(v17 + 216)) {
          size_t v47 = *(const char **)(v17 + 216);
        }
        else {
          size_t v47 = "message/bhttp";
        }
        size_t size = 0LL;
        BOOL v48 = nw_http_decrypt_chunked_oblivious_response_chunk( (uint64_t)&v5[v21],  v20,  v47,  *(void *)(v17 + 200),  v267,  *(void *)(v17 + 112),  *(void *)(v17 + 120),  *(const void **)(v17 + 96),  *(void *)(v17 + 104),  *(const void **)(v17 + 184),  *(void *)(v17 + 192),  &size);
        if (!v48)
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            char v201 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v201, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              _os_log_impl( &dword_181A5C000,  v201,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to decrypt oblivious response chunk",  buf,  0x20u);
            }
          }

          if (gLogDatapath)
          {
            uint32_t v250 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v250, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_181A5C000, v250, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }

          *(void *)int buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_28822;
          uint64_t v285 = (uint64_t)&__block_descriptor_tmp_15_28823;
          *(void *)os_log_type_t v286 = a1 + 328;
          v286[8] = 1;
          uint64_t v202 = *v266;
          do
          {
            if (!v202) {
              break;
            }
            uint64_t v203 = *(void *)(v202 + 32);
            char v204 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            uint64_t v202 = v203;
          }

          while ((v204 & 1) != 0);
          if (v265) {
            free(v265);
          }
LABEL_370:
          nw_ohttp_mark_failed_with_error(a1, 80);
          return;
        }

        unsigned int v49 = (_DWORD *)v48;
        if (size)
        {
          unint64_t v50 = v20;
          BOOL v51 = dispatch_data_create((const void *)v48, size, 0LL, destructor);
          BOOL v52 = v51;
          size_t v53 = *(dispatch_object_s **)(v17 + 208);
          if (v53)
          {
            *(void *)(v17 + 20_Block_object_dispose((const void *)(v1 - 176), 8) = dispatch_data_create_concat(*(dispatch_data_t *)(v17 + 208), v51);
            dispatch_release(v53);
            if (v52) {
              dispatch_release(v52);
            }
            int v54 = 0;
          }

          else
          {
            *(void *)(v17 + 20_Block_object_dispose((const void *)(v1 - 176), 8) = v51;
            int v54 = 1;
          }

          unint64_t v20 = v50;
        }

        else
        {
          if ((*(_BYTE *)(a1 + 348) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            size_t v55 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v285 = (uint64_t)" ";
              _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSuccessfully read empty chunk",  buf,  0x20u);
            }
          }

          free(v49);
          int v54 = 0;
          unsigned int v49 = 0LL;
        }

        uint64_t v56 = *(void *)(v17 + 200);
        uint64_t v57 = v56 + 1;
        uint64_t v58 = v56 == -1;
        uint64_t v59 = v58 << 63 >> 63;
        *(void *)(v17 + 200) = v57;
        if (v59 == v58 && (v59 & 0x8000000000000000LL) == 0)
        {
          if (v54) {
            goto LABEL_140;
          }
LABEL_171:
          BOOL v87 = *(dispatch_data_s **)(v17 + 208);
          if (v87)
          {
            size_t v61 = dispatch_data_get_size(v87);
            if (!v61)
            {
              os_log_type_t v124 = (os_log_s *)__nwlog_obj();
              os_log_type_enabled(v124, OS_LOG_TYPE_ERROR);
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "strict_malloc";
              size_t v125 = (void *)_os_log_send_and_compose_impl();
              free(v125);
            }

            BOOL v88 = malloc(v61);
            if (v88)
            {
              unsigned int v49 = v88;
              nw_endpoint_t v89 = *(dispatch_data_s **)(v17 + 208);
              size_t v278 = 0LL;
              v279 = &v278;
              uint64_t v280 = 0x2000000000LL;
              uint64_t v281 = 0LL;
              __size[0] = 0LL;
              __size[1] = (size_t)__size;
              __size[2] = 0x2000000000LL;
              __size[3] = (size_t)v49;
              if (v89)
              {
                *(void *)int buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 0x40000000LL;
                *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
                uint64_t v285 = (uint64_t)&unk_189BBF598;
                *(void *)&v286[8] = __size;
                *(void *)&v286[16] = v61;
                *(void *)os_log_type_t v286 = &v278;
                dispatch_data_apply(v89, buf);
              }

              _Block_object_dispose(__size, 8);
              _Block_object_dispose(&v278, 8);
              BOOL v60 = v49;
              if (!*(void *)(v17 + 216)) {
                goto LABEL_177;
              }
LABEL_141:
              size_t v62 = *(void **)(v17 + 160);
              if (v62)
              {
                if (v49)
                {
                  int v255 = v60;
                  size_t v63 = v61;
                  unint64_t v64 = v20;
                  uint64_t v65 = *(void *)(v17 + 168);
                  size_t v66 = v63;
                  size_t v67 = v65 + v63;
                  *(void *)(v17 + 16_Block_object_dispose((const void *)(v1 - 176), 8) = v65 + v63;
                  if (!(v65 + v63))
                  {
                    int v157 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v157, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)int buf = 136446210;
                    *(void *)&uint8_t buf[4] = "_strict_reallocf";
                    unint64_t v158 = (void *)_os_log_send_and_compose_impl();
                    free(v158);
                    size_t v62 = *(void **)(v17 + 160);
                  }

                  __int16 v68 = (char *)reallocf(v62, v67);
                  if (!v68)
                  {
                    int v262 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v262, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "_strict_reallocf";
                    *(_WORD *)&buf[12] = 2048;
                    *(void *)&buf[14] = v67;
                    int v159 = (void *)_os_log_send_and_compose_impl();
                    free(v159);
                  }

                  *(void *)(v17 + 160) = v68;
                  memcpy(&v68[v65], v49, v66);
                  unint64_t v20 = v64;
                  unint64_t v21 = v264;
                  BOOL v60 = v255;
                }

                else
                {
                  unint64_t v21 = v264;
                }
              }

              else
              {
                if (v60)
                {
                  *(void *)(v17 + 160) = v60;
                  *(void *)(v17 + 16_Block_object_dispose((const void *)(v1 - 176), 8) = v61;
                }

                else if (v49)
                {
                  *(void *)(v17 + 16_Block_object_dispose((const void *)(v1 - 176), 8) = v61;
                  if (!v61)
                  {
                    uint64_t v168 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v168, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)int buf = 136446210;
                    *(void *)&uint8_t buf[4] = "strict_malloc";
                    id v169 = (void *)_os_log_send_and_compose_impl();
                    free(v169);
                  }

                  unsigned int v85 = malloc(v61);
                  if (!v85)
                  {
                    unint64_t v263 = v20;
                    uint64_t v170 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v170, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "strict_malloc";
                    *(_WORD *)&buf[12] = 2048;
                    *(void *)&buf[14] = v61;
                    uint64_t v171 = (void *)_os_log_send_and_compose_impl();
                    free(v171);
                    unint64_t v20 = v263;
                  }

                  *(void *)(v17 + 160) = v85;
                  memcpy(v85, v49, v61);
                }

                BOOL v60 = 0LL;
                unint64_t v21 = v264;
              }

LABEL_266:
          _os_log_impl(&dword_181A5C000, v133, v134, v135, buf, 0xCu);
          goto LABEL_267;
        }

        unint64_t v259 = v20;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v69 = *(void *)(v17 + 200);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
        *(_WORD *)&_BYTE buf[22] = 2048;
        uint64_t v285 = 1LL;
        *(_WORD *)os_log_type_t v286 = 2048;
        *(void *)&v286[2] = v69;
        uint64_t v70 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v27_Block_object_dispose((const void *)(v1 - 176), 8) = 16;
        LOBYTE(__size[0]) = 0;
        if (__nwlog_fault(v70, &v278, __size))
        {
          if (v278 != 17)
          {
            if (LOBYTE(__size[0]))
            {
              BOOL v77 = (char *)__nw_create_backtrace_string();
              BOOL v78 = (os_log_s *)__nwlog_obj();
              os_log_type_t v79 = v278;
              BOOL v80 = os_log_type_enabled(v78, (os_log_type_t)v278);
              if (v77)
              {
                if (v80)
                {
                  uint64_t v81 = *(void *)(v17 + 200);
                  *(_DWORD *)int buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  uint64_t v285 = 1LL;
                  *(_WORD *)os_log_type_t v286 = 2048;
                  *(void *)&v286[2] = v81;
                  *(_WORD *)&v286[10] = 2082;
                  *(void *)&v286[12] = v77;
                  _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v77);
                goto LABEL_168;
              }

              if (!v80) {
                goto LABEL_168;
              }
              uint64_t v86 = *(void *)(v17 + 200);
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
              *(_WORD *)&_BYTE buf[22] = 2048;
              uint64_t v285 = 1LL;
              *(_WORD *)os_log_type_t v286 = 2048;
              *(void *)&v286[2] = v86;
              uint64_t v74 = v78;
              os_log_type_t v75 = v79;
              char v76 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            }

            else
            {
              os_log_type_t v82 = (os_log_s *)__nwlog_obj();
              os_log_type_t v83 = v278;
              if (!os_log_type_enabled(v82, (os_log_type_t)v278)) {
                goto LABEL_168;
              }
              uint64_t v84 = *(void *)(v17 + 200);
              *(_DWORD *)int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "ohttp_context->aead_chunk_index";
              *(_WORD *)&_BYTE buf[22] = 2048;
              uint64_t v285 = 1LL;
              *(_WORD *)os_log_type_t v286 = 2048;
              *(void *)&v286[2] = v84;
              uint64_t v74 = v82;
              os_log_type_t v75 = v83;
              char v76 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            }

    if (v121) {
      free(v121);
    }
LABEL_268:

    _Block_object_dispose(out, 8);
    int v115 = *v114;
    size_t v116 = lock;
  }

  if (v115 == 5)
  {
    *(void *)uuid_string_t out = 0LL;
    *(void *)&out[8] = out;
    *(void *)&out[16] = 0x3032000000LL;
    *(void *)&out[24] = __Block_byref_object_copy__79337;
    *(void *)&out[32] = __Block_byref_object_dispose__79338;
    *(void *)&char out[40] = 0LL;
    v380[0] = MEMORY[0x1895F87A8];
    v380[1] = 3221225472LL;
    nw_endpoint_t v381 = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_159;
    v382 = &unk_189BC9210;
    int v384 = out;
    v383 = v298;
    uint64_t v128 = v383;
    unint64_t v129 = v380;
    os_unfair_lock_lock(v116);
    v381((uint64_t)v129);
    os_unfair_lock_unlock(v116);

    size_t v130 = *(void *)(*(void *)&out[8] + 40LL);
    if (v130)
    {
      v378[0] = MEMORY[0x1895F87A8];
      v378[1] = 3221225472LL;
      v378[2] = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_160;
      v378[3] = &unk_189BC7758;
      v379 = v128;
      (*(void (**)(uint64_t, NWConcrete_nw_agent_client *, void *))(v130 + 16))(v130, v296, v378);

      goto LABEL_290;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v131 = (id)gLogObj;
    *(_DWORD *)v413 = 136446210;
    v414 = "nw_agent_read_message_on_queue";
    os_log_type_t v132 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v405 = 0;
    if (__nwlog_fault(v132, &type, &v405))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        size_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v134 = type;
        if (os_log_type_enabled(v133, type))
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_read_message_on_queue";
          _os_log_impl(&dword_181A5C000, v133, v134, "%{public}s No handler for TRIGGER", v413, 0xCu);
        }

        goto LABEL_287;
      }

      if (v405)
      {
        int v135 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        size_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v136 = type;
        size_t v137 = os_log_type_enabled(v133, type);
        if (v135)
        {
          if (v137)
          {
            *(_DWORD *)v413 = 136446466;
            v414 = "nw_agent_read_message_on_queue";
            nw_endpoint_t v415 = 2082;
            v416 = v135;
            _os_log_impl( &dword_181A5C000,  v133,  v136,  "%{public}s No handler for TRIGGER, dumping backtrace:%{public}s",  v413,  0x16u);
          }

          free(v135);
          goto LABEL_288;
        }

        if (v137)
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_read_message_on_queue";
          _os_log_impl(&dword_181A5C000, v133, v136, "%{public}s No handler for TRIGGER, no backtrace", v413, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        size_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v138 = type;
        if (os_log_type_enabled(v133, type))
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_read_message_on_queue";
          _os_log_impl( &dword_181A5C000,  v133,  v138,  "%{public}s No handler for TRIGGER, backtrace limit exceeded",  v413,  0xCu);
        }
      }

uint64_t ___ZL34nw_protocol_ohttp_process_responseP17nw_protocol_ohttp_block_invoke(uint64_t a1, uint64_t a2)
{
  LODWORD(__n) = 0;
  size_t v3 = (const void *)nw_frame_unclaimed_bytes(a2, &__n);
  memcpy( (void *)(*(void *)(a1 + 40) + *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)),  v3,  __n);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += __n;
  return 1LL;
}

BOOL ___ZL45nw_protocol_finalize_partial_temp_frame_arrayP16nw_frame_array_sjP11nw_protocolb_block_invoke( uint64_t a1, uint64_t a2)
{
  unsigned int v5 = nw_frame_unclaimed_length((_DWORD *)a2);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 24);
  if (v7 <= v5)
  {
    nw_frame_claim(a2, v4, *(_DWORD *)(v6 + 24), 0);
  }

  else
  {
    *(_DWORD *)(v6 + 24) = v7 - v5;
    uint64_t v8 = *(void *)(a2 + 32);
    unint64_t v9 = *(void **)(a2 + 40);
    if (v8)
    {
      *(void *)(v8 + 40) = v9;
      unint64_t v9 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(*(void *)(a1 + 40) + 8LL) = v9;
    }

    *unint64_t v9 = v8;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    nw_frame_finalize(a2);
  }

  return v7 > v5;
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_28822( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  size_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    size_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v3;
  }

  void *v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

void nw_protocol_ohttp_deliver_response(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
    char v13 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type[0];
      if (!os_log_type_enabled(v14, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
      char v16 = "%{public}s called with null ohttp";
      goto LABEL_45;
    }

    if (!v21)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type[0];
      if (!os_log_type_enabled(v14, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
      char v16 = "%{public}s called with null ohttp, backtrace limit exceeded";
      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type[0];
    BOOL v18 = os_log_type_enabled(v14, type[0]);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
      char v16 = "%{public}s called with null ohttp, no backtrace";
      goto LABEL_45;
    }

    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_46:
    if (!v13) {
      return;
    }
    goto LABEL_47;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
    char v13 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type[0];
      if (!os_log_type_enabled(v14, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
      char v16 = "%{public}s called with null ohttp_context";
      goto LABEL_45;
    }

    if (!v21)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type[0];
      if (!os_log_type_enabled(v14, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
      char v16 = "%{public}s called with null ohttp_context, backtrace limit exceeded";
      goto LABEL_45;
    }

    unsigned int v19 = (char *)__nw_create_backtrace_string();
    uint64_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type[0];
    BOOL v20 = os_log_type_enabled(v14, type[0]);
    if (v19)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v19;
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null ohttp_context, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v19);
      if (!v13) {
        return;
      }
LABEL_47:
      free(v13);
      return;
    }

    if (v20)
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
      char v16 = "%{public}s called with null ohttp_context, no backtrace";
LABEL_45:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      goto LABEL_46;
    }

    goto LABEL_46;
  }

  if (*(_DWORD *)(a2 + 224) == 4)
  {
    if (a1 + 64 == a2)
    {
      unsigned int v5 = *(void **)(a1 + 48);
      if (v5)
      {
LABEL_7:
        nw_protocol_input_available(v5, a1);
        return;
      }
    }

    else
    {
      uint64_t v4 = *(char **)(a1 + 296);
      if (v4)
      {
        *(void *)os_log_type_t type = 0LL;
        uint64_t v23 = type;
        uint64_t v24 = 0x2000000000LL;
        uint64_t v25 = 0LL;
        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL42nw_protocol_ohttp_get_protocol_for_contextP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke;
        BOOL v27 = (const char *)&unk_189BBB378;
        uint64_t v28 = type;
        uint64_t v29 = a2;
        nw_hash_table_apply(v4, (uint64_t)buf);
        unsigned int v5 = (void *)*((void *)v23 + 3);
        _Block_object_dispose(type, 8);
        if (v5) {
          goto LABEL_7;
        }
      }
    }

    if ((*(_BYTE *)(a1 + 348) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 349;
        *(_WORD *)&_BYTE buf[22] = 2080;
        BOOL v27 = " ";
        uint64_t v8 = "%{public}s %{public}s%sfailed to find protocol for delivering responses";
        unint64_t v9 = (os_log_s *)v12;
        os_log_type_t v10 = OS_LOG_TYPE_ERROR;
        uint32_t v11 = 32;
        goto LABEL_16;
      }
    }
  }

  else if ((*(_BYTE *)(a1 + 348) & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        int v7 = *(_DWORD *)(a2 + 224);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_deliver_response";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 349;
        *(_WORD *)&_BYTE buf[22] = 2080;
        BOOL v27 = " ";
        LOWORD(v2_Block_object_dispose((const void *)(v1 - 176), 8) = 1024;
        *(_DWORD *)((char *)&v28 + 2) = v7;
        uint64_t v8 = "%{public}s %{public}s%sskipping, state %u";
        unint64_t v9 = v6;
        os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
        uint32_t v11 = 38;
LABEL_16:
        _os_log_impl(&dword_181A5C000, v9, v10, v8, buf, v11);
      }
    }
  }

uint64_t ___ZL34nw_protocol_ohttp_process_responseP17nw_protocol_ohttp_block_invoke_26( uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  if ((*(_BYTE *)(extra + 228) & 0x20) != 0)
  {
    *(_BYTE *)(extra + 228) &= ~0x20u;
    nw_protocol_ohttp_deliver_response(*(void *)(a1 + 32), extra);
  }

  return 1LL;
}

BOOL ___ZL42nw_protocol_ohttp_get_protocol_for_contextP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5 == extra) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = nw_hash_node_get_object(a2);
  }
  return v5 != extra;
}

BOOL ___ZL44nw_protocol_ohttp_get_context_for_context_idP17nw_protocol_ohttpy_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t extra = (uint64_t *)nw_hash_node_get_extra(a2);
  uint64_t v4 = *extra;
  uint64_t v5 = *(void *)(a1 + 40);
  if (*extra == v5) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = extra;
  }
  return v4 != v5;
}

void nw_protocol_ohttp_context_deliver_failure_message(uint64_t a1, uint64_t a2, void *object)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
      uint64_t v8 = "%{public}s called with null ohttp_context";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      goto LABEL_32;
    }

    if (!v13)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
      uint64_t v8 = "%{public}s called with null ohttp_context, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (!v10) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
      uint64_t v8 = "%{public}s called with null ohttp_context, no backtrace";
      goto LABEL_31;
    }

    if (v10)
    {
      *(_DWORD *)int buf = 136446466;
      char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
      __int16 v17 = 2082;
      BOOL v18 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null ohttp_context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_32:
    if (!v5) {
      return;
    }
    goto LABEL_33;
  }

  if (object)
  {
    *(void *)(a2 + 80) = os_retain(object);
    *(_BYTE *)(a2 + 228) |= 4u;
    *(_DWORD *)(a2 + 224) = 4;
    nw_protocol_ohttp_deliver_response(a1, a2);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
    uint64_t v8 = "%{public}s called with null http_metadata";
    goto LABEL_31;
  }

  if (!v13)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
    uint64_t v8 = "%{public}s called with null http_metadata, backtrace limit exceeded";
    goto LABEL_31;
  }

  uint32_t v11 = (char *)__nw_create_backtrace_string();
  uint64_t v6 = (os_log_s *)__nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_32;
    }
    *(_DWORD *)int buf = 136446210;
    char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
    uint64_t v8 = "%{public}s called with null http_metadata, no backtrace";
    goto LABEL_31;
  }

  if (v12)
  {
    *(_DWORD *)int buf = 136446466;
    char v16 = "nw_protocol_ohttp_context_deliver_failure_message";
    __int16 v17 = 2082;
    BOOL v18 = v11;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null http_metadata, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v5) {
LABEL_33:
  }
    free(v5);
}

uint64_t ___ZL41nw_protocol_ohttp_deliver_failure_messageP17nw_protocol_ohttpP20nw_protocol_metadata_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  nw_protocol_ohttp_context_deliver_failure_message(*(void *)(a1 + 32), extra, *(void **)(a1 + 40));
  return 1LL;
}

uint64_t ___ZL31nw_ohttp_mark_failed_with_errorP17nw_protocol_ohttpi_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t extra = nw_hash_node_get_extra(a2);
  dispatch_object_t object = (void *)nw_hash_node_get_object(a2);
  *(_DWORD *)(extra + 224) = 6;
  nw_protocol_error(object, *(void *)(a1 + 32));
  nw_protocol_disconnected(object, *(void *)(a1 + 32));
  return 1LL;
}

uint64_t ___ZL40nw_protocol_ohttp_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a2[4];
  uint64_t v4 = (void *)a2[5];
  if (v3)
  {
    *(void *)(v3 + 40) = v4;
    uint64_t v4 = (void *)a2[5];
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v4;
  }

  void *v4 = v3;
  a2[4] = 0LL;
  a2[5] = 0LL;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    uint64_t v6 = a2[11];
    if (v6)
    {
      if (v5 + 64 == v6)
      {
        if (*(void *)(v5 + 48)) {
          goto LABEL_9;
        }
      }

      else
      {
        os_log_type_t v7 = *(char **)(v5 + 296);
        if (v7)
        {
          *(void *)__int128 uu = 0LL;
          *(void *)&uu[8] = uu;
          uint64_t v39 = 0x2000000000LL;
          uint64_t v40 = 0LL;
          *(void *)int buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL42nw_protocol_ohttp_get_protocol_for_contextP17nw_protocol_ohttpP16nw_ohttp_context_block_invoke;
          size_t v35 = (const char *)&unk_189BBB378;
          uint64_t v36 = uu;
          uint64_t v37 = v6;
          nw_hash_table_apply(v7, (uint64_t)buf);
          uint64_t v8 = *(void *)(*(void *)&uu[8] + 24LL);
          _Block_object_dispose(uu, 8);
          if (v8)
          {
LABEL_9:
            unsigned int v9 = *(_DWORD *)(v6 + 224);
            if ((*(_BYTE *)(v5 + 348) & 2) != 0)
            {
              if (v9 >= 2)
              {
LABEL_11:
                if ((*(_BYTE *)(v5 + 348) & 1) != 0) {
                  goto LABEL_20;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v10 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_20;
                }
                int v11 = *(_DWORD *)(v6 + 224);
                *(_DWORD *)int buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v5 + 349;
                *(_WORD *)&_BYTE buf[22] = 2080;
                size_t v35 = " ";
                LOWORD(v36) = 1024;
                *(_DWORD *)((char *)&v36 + 2) = v11;
                BOOL v12 = "%{public}s %{public}s%sState is not valid for sending: %u";
                char v13 = (os_log_s *)v10;
                uint32_t v14 = 38;
LABEL_19:
                _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
LABEL_20:
                nw_frame_finalize((uint64_t)a2);
                return 1LL;
              }
            }

            else if (v9)
            {
              goto LABEL_11;
            }

            char v17 = *(_BYTE *)(v6 + 228);
            if ((v17 & 2) != 0)
            {
              if ((*(_BYTE *)(v5 + 348) & 1) != 0) {
                goto LABEL_20;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v15 = (os_log_s *)gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                goto LABEL_20;
              }
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v5 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              size_t v35 = " ";
              BOOL v12 = "%{public}s %{public}s%sRequest is already complete";
            }

            else
            {
              memset(uu, 0, sizeof(uu));
              uint64_t v18 = a2[8];
              if (v18)
              {
                int v19 = (*(unsigned __int8 *)(v18 + 66) >> 6) & 1;
                if (*(void *)(v18 + 48)) {
                  *(_OWORD *)__int128 uu = *(_OWORD *)(v18 + 16);
                }
              }

              else
              {
                LOBYTE(v19) = 0;
              }

              if (*(void *)(v6 + 216) || (v17 & 1) != 0)
              {
LABEL_50:
                *(_BYTE *)(v6 + 22_Block_object_dispose((const void *)(v1 - 176), 8) = *(_BYTE *)(v6 + 228) & 0xFD | (2 * v19);
                uint64_t v24 = a2[2];
                uint64_t v25 = (void *)a2[3];
                uint64_t v23 = a2 + 2;
                if (v24)
                {
                  *(void *)(v24 + 24) = v25;
                  uint64_t v25 = (void *)a2[3];
                }

                else
                {
                  *(void *)(v6 + 16) = v25;
                }

                *uint64_t v25 = v24;
                *uint64_t v23 = 0LL;
                a2[3] = 0LL;
                size_t v26 = *(void **)(v6 + 32);
                a2[3] = v26;
                void *v26 = a2;
                *(void *)(v6 + 32) = v23;
                nw_protocol_ohttp_prepare_request(v5, v6);
                return 1LL;
              }

              if (uuid_is_null(uu))
              {
                if ((*(_BYTE *)(v5 + 348) & 1) != 0) {
                  goto LABEL_20;
                }
                os_log_type_t v15 = (os_log_s *)__nwlog_obj();
                if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_20;
                }
                *(_DWORD *)int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v5 + 349;
                *(_WORD *)&_BYTE buf[22] = 2080;
                size_t v35 = " ";
                BOOL v12 = "%{public}s %{public}s%sNo request UUID in output frame";
                goto LABEL_18;
              }

              id v20 = nw_protocol_copy_http_definition();
              char v21 = nw_frame_copy_metadata_for_protocol((uint64_t)a2, (uint64_t)v20);
              if (v20) {
                os_release(v20);
              }
              if (v21)
              {
                unint64_t v22 = *(void **)(v6 + 72);
                if (v22)
                {
                  os_release(v21);
                  if (v22 != v21 && !uuid_compare((const unsigned __int8 *)(v6 + 56), uu))
                  {
                    if ((*(_BYTE *)(v5 + 348) & 1) != 0) {
                      goto LABEL_20;
                    }
                    os_log_type_t v15 = (os_log_s *)__nwlog_obj();
                    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_20;
                    }
                    *(_DWORD *)int buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v5 + 349;
                    *(_WORD *)&_BYTE buf[22] = 2080;
                    size_t v35 = " ";
                    BOOL v12 = "%{public}s %{public}s%sInvalid request UUID in output frame";
                    goto LABEL_18;
                  }
                }

                else
                {
                  *(void *)(v6 + 72) = v21;
                  *(_OWORD *)(v6 + 56) = *(_OWORD *)uu;
                }

                goto LABEL_50;
              }

              if ((*(_BYTE *)(v5 + 348) & 1) != 0) {
                goto LABEL_20;
              }
              os_log_type_t v15 = (os_log_s *)__nwlog_obj();
              if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
                goto LABEL_20;
              }
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v5 + 349;
              *(_WORD *)&_BYTE buf[22] = 2080;
              size_t v35 = " ";
              BOOL v12 = "%{public}s %{public}s%sNo HTTP request in output frame";
            }

uint64_t nw_protocol_ohttp_get_context_for_protocol(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v16 = "nw_protocol_ohttp_get_context_for_protocol";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_get_context_for_protocol";
      uint64_t v10 = "%{public}s called with null input_protocol";
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_protocol_ohttp_get_context_for_protocol";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (!v12)
      {
LABEL_25:
        if (v7) {
          free(v7);
        }
        return 0LL;
      }

      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_get_context_for_protocol";
      uint64_t v10 = "%{public}s called with null input_protocol, no backtrace";
    }

    else
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_get_context_for_protocol";
      uint64_t v10 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_25;
  }

  if (*(void *)(a1 + 48) == a2) {
    return a1 + 64;
  }
  uint64_t result = *(void *)(a1 + 296);
  if (!result) {
    return result;
  }
  uint64_t node = nw_hash_table_get_node(result, a2, 8LL);
  if (node && *(void *)(a2 + 56) == node) {
    return node + 32;
  }
  if ((*(_BYTE *)(a1 + 348) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446722;
      char v16 = "nw_protocol_ohttp_get_context_for_protocol";
      __int16 v17 = 2082;
      uint64_t v18 = (char *)(a1 + 349);
      __int16 v19 = 2080;
      id v20 = " ";
      _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo valid node found", buf, 0x20u);
      return 0LL;
    }
  }

  return 0LL;
}

void nw_protocol_ohttp_output_frame_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v4 = *((void *)a1 + 2);
  uint64_t v5 = (void *)*((void *)a1 + 3);
  if (v4)
  {
    *(void *)(v4 + 24) = v5;
    uint64_t v5 = (void *)*((void *)a1 + 3);
  }

  else
  {
    a3[2] = v5;
  }

  *uint64_t v5 = v4;
  *((void *)a1 + 2) = 0LL;
  *((void *)a1 + 3) = 0LL;
  buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0LL);
  if (buffer) {
    free(buffer);
  }
  os_release(a1);
}

void nw_protocol_ohttp_input_frame_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v4 = *((void *)a1 + 2);
  uint64_t v5 = (void *)*((void *)a1 + 3);
  if (v4)
  {
    *(void *)(v4 + 24) = v5;
    uint64_t v5 = (void *)*((void *)a1 + 3);
  }

  else
  {
    a3[6] = v5;
  }

  *uint64_t v5 = v4;
  *((void *)a1 + 2) = 0LL;
  *((void *)a1 + 3) = 0LL;
  buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0LL);
  if (buffer) {
    free(buffer);
  }
  os_release(a1);
}

void nw_protocol_ohttp_destroy(void *a1)
{
  uint64_t v2 = (void *)a1[38];
  if (v2)
  {
    os_release(v2);
    a1[38] = 0LL;
  }

  uint64_t v3 = (void *)a1[39];
  if (v3)
  {
    os_release(v3);
    a1[39] = 0LL;
  }

  uint64_t v4 = (char *)a1[37];
  if (v4)
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    v7[2] = ___ZL25nw_protocol_ohttp_destroyP17nw_protocol_ohttp_block_invoke;
    v7[3] = &__block_descriptor_tmp_16_29100;
    void v7[4] = a1;
    nw_hash_table_apply(v4, (uint64_t)v7);
    uint64_t v6 = (os_unfair_lock_s *)a1[37];
    if (v6)
    {
      _nw_hash_table_release(v6, v5);
      a1[37] = 0LL;
    }
  }

  nw_protocol_ohttp_context_destroy(a1 + 8);
  free(a1);
}

uint64_t ___ZL38nw_protocol_ohttp_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1, uint64_t a2)
{
  dispatch_object_t object = (void *)nw_hash_node_get_object(a2);
  nw_protocol_disconnected(object, *(void *)(a1 + 32));
  return 1LL;
}

void nw_protocol_ohttp_context_destroy_node(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    char v16 = "nw_protocol_ohttp_context_destroy_node";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_context_destroy_node";
      uint64_t v8 = "%{public}s called with null ohttp";
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          char v16 = "nw_protocol_ohttp_context_destroy_node";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v5) {
          return;
        }
LABEL_37:
        free(v5);
        return;
      }

      if (!v10) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_context_destroy_node";
      uint64_t v8 = "%{public}s called with null ohttp, no backtrace";
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446210;
      char v16 = "nw_protocol_ohttp_context_destroy_node";
      uint64_t v8 = "%{public}s called with null ohttp, backtrace limit exceeded";
    }

void nw_protocol_ohttp_context_destroy(void *a1)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = (void *)a1[11];
    if (v2)
    {
      xpc_release(v2);
      a1[11] = 0LL;
    }

    uint64_t v3 = (void *)a1[16];
    if (v3)
    {
      free(v3);
      a1[16] = 0LL;
    }

    uint64_t v4 = (void *)a1[20];
    if (v4)
    {
      free(v4);
      a1[20] = 0LL;
    }

    uint64_t v5 = (void *)a1[12];
    if (v5)
    {
      free(v5);
      a1[12] = 0LL;
    }

    uint64_t v6 = (void *)a1[14];
    if (v6)
    {
      free(v6);
      a1[14] = 0LL;
    }

    os_log_type_t v7 = (void *)a1[23];
    if (v7)
    {
      free(v7);
      a1[23] = 0LL;
    }

    uint64_t v8 = (void *)a1[9];
    if (v8)
    {
      os_release(v8);
      a1[9] = 0LL;
    }

    os_log_type_t v9 = (void *)a1[10];
    if (v9)
    {
      os_release(v9);
      a1[10] = 0LL;
    }

    BOOL v10 = (dispatch_object_s *)a1[26];
    if (v10)
    {
      dispatch_release(v10);
      a1[26] = 0LL;
    }

    int v11 = (void *)a1[27];
    if (v11)
    {
      free(v11);
      a1[27] = 0LL;
    }

    if (gLogDatapath)
    {
      size_t v26 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_master_frame_array";
        _os_log_impl(&dword_181A5C000, v26, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }

    uint64_t v12 = MEMORY[0x1895F87A8];
    *(void *)int buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke;
    size_t v53 = &__block_descriptor_tmp_18_29088;
    char v54 = 0;
    uint64_t v13 = a1[1];
    do
    {
      if (!v13) {
        break;
      }
      uint64_t v14 = *(void *)(v13 + 16);
      char v15 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      uint64_t v13 = v14;
    }

    while ((v15 & 1) != 0);
    if (!a1[1])
    {
LABEL_27:
      if (gLogDatapath)
      {
        char v31 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_master_frame_array";
          _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }

      *(void *)int buf = v12;
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke;
      size_t v53 = &__block_descriptor_tmp_18_29088;
      char v54 = 0;
      uint64_t v16 = a1[5];
      do
      {
        if (!v16) {
          break;
        }
        uint64_t v17 = *(void *)(v16 + 16);
        char v18 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        uint64_t v16 = v17;
      }

      while ((v18 & 1) != 0);
      if (!a1[5]) {
        goto LABEL_32;
      }
      __nwlog_obj();
      *(_DWORD *)os_log_type_t type = 136446210;
      unsigned int v49 = "nw_protocol_finalize_master_frame_array";
      BOOL v32 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v47 = OS_LOG_TYPE_ERROR;
      char v46 = 0;
      if (__nwlog_fault(v32, &v47, &v46))
      {
        if (v47 == OS_LOG_TYPE_FAULT)
        {
          char v33 = (os_log_s *)__nwlog_obj();
          os_log_type_t v34 = v47;
          if (!os_log_type_enabled(v33, v47)) {
            goto LABEL_86;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          unsigned int v49 = "nw_protocol_finalize_master_frame_array";
          size_t v35 = "%{public}s frame array is not empty after finalize";
          goto LABEL_85;
        }

        if (!v46)
        {
          char v33 = (os_log_s *)__nwlog_obj();
          os_log_type_t v34 = v47;
          if (!os_log_type_enabled(v33, v47)) {
            goto LABEL_86;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          unsigned int v49 = "nw_protocol_finalize_master_frame_array";
          size_t v35 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
          goto LABEL_85;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        char v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = v47;
        BOOL v41 = os_log_type_enabled(v33, v47);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            unsigned int v49 = "nw_protocol_finalize_master_frame_array";
            __int16 v50 = 2082;
            BOOL v51 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_86;
        }

        if (v41)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          unsigned int v49 = "nw_protocol_finalize_master_frame_array";
          size_t v35 = "%{public}s frame array is not empty after finalize, no backtrace";
LABEL_85:
          _os_log_impl(&dword_181A5C000, v33, v34, v35, (uint8_t *)type, 0xCu);
        }
      }

uint64_t ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke( uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t ___ZL33nw_protocol_ohttp_context_destroyP16nw_ohttp_context_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = a2[2];
  uint64_t v4 = (void *)a2[3];
  if (v3)
  {
    *(void *)(v3 + 24) = v4;
    uint64_t v4 = (void *)a2[3];
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 32LL) = v4;
  }

  void *v4 = v3;
  a2[2] = 0LL;
  a2[3] = 0LL;
  buffer = (void *)nw_frame_get_buffer((uint64_t)a2, 0LL);
  if (buffer) {
    free(buffer);
  }
  os_release(a2);
  return 1LL;
}

uint64_t ___ZL25nw_protocol_ohttp_destroyP17nw_protocol_ohttp_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

void sub_182043AD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_masque_connection_pair;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_masque_connection_pair_cancel_waiting_timer(NWConcrete_nw_masque_connection_pair *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (*((void *)v1 + 36))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v3 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = (char *)*((void *)v2 + 2);
        uint64_t v5 = *((void *)v2 + 6);
        *(_DWORD *)int buf = 136446722;
        char v18 = "nw_masque_connection_pair_cancel_waiting_timer";
        __int16 v19 = 2114;
        uint64_t v20 = v4;
        __int16 v21 = 2112;
        uint64_t v22 = v5;
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ cancelling wait timer for %@",  buf,  0x20u);
      }

      dispatch_source_cancel(*((dispatch_source_t *)v2 + 36));
      uint64_t v6 = (void *)*((void *)v2 + 36);
      *((void *)v2 + 36) = 0LL;
    }

    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  char v18 = "nw_masque_connection_pair_cancel_waiting_timer";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v18 = "nw_masque_connection_pair_cancel_waiting_timer";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)int buf = 136446466;
          char v18 = "nw_masque_connection_pair_cancel_waiting_timer";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        char v18 = "nw_masque_connection_pair_cancel_waiting_timer";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        char v18 = "nw_masque_connection_pair_cancel_waiting_timer";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void sub_182043FA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_masque_listener_pair;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_18204445C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_masque_connection_start_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v1 = (nw_connection_t *)*(id *)(a1 + 32);
  nw_connection_t v2 = v1[6];
  uint64_t v3 = MEMORY[0x1895F87A8];
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  v12[2] = ___ZL35nw_masque_connection_start_on_queueP31NWConcrete_nw_masque_connection_block_invoke;
  v12[3] = &unk_189BC93A0;
  uint64_t v4 = v1;
  BOOL v13 = v4;
  nw_connection_set_read_close_handler(v2, v12);
  uint64_t v5 = v1[6];
  v10[0] = v3;
  v10[1] = 3221225472LL;
  v10[2] = ___ZL35nw_masque_connection_start_on_queueP31NWConcrete_nw_masque_connection_block_invoke_189;
  v10[3] = &unk_189BC9318;
  uint64_t v6 = v4;
  int v11 = v6;
  nw_connection_set_state_changed_handler(v5, v10);
  nw_connection_set_queue(v1[6], v6[4]);
  os_log_type_t v7 = v6;
  nw_connection_t v8 = v1[6];
  *(void *)int buf = v3;
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke;
  char v15 = &unk_189BBF198;
  uint64_t v16 = v7;
  nw_connection_receive_internal(v8, 0LL, 0, 0, buf);

  nw_connection_start(v1[6]);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v9 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_masque_connection_start_on_queue";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v7;
    _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}@ started connection", buf, 0x16u);
  }
}

void sub_1820447CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

void ___ZL35nw_masque_connection_start_on_queueP31NWConcrete_nw_masque_connection_block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  nw_connection_t v2 = *(unsigned __int8 **)(a1 + 32);
  int v3 = v2[112];
  if (v3 == 200)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        int v8 = 136446466;
        os_log_type_t v9 = "nw_masque_connection_start_on_queue_block_invoke";
        __int16 v10 = 2114;
        uint64_t v11 = v7;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ ignoring in connection read close event",  (uint8_t *)&v8,  0x16u);
      }
    }
  }

  else if (v3 != 255)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        int v8 = 136446466;
        os_log_type_t v9 = "nw_masque_connection_start_on_queue_block_invoke";
        __int16 v10 = 2114;
        uint64_t v11 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ in connection read close before proxy connection ready, cancelling",  (uint8_t *)&v8,  0x16u);
      }

      nw_connection_t v2 = *(unsigned __int8 **)(a1 + 32);
    }

    nw_masque_connection_cancel_on_queue(v2, 0LL);
  }

void ___ZL35nw_masque_connection_start_on_queueP31NWConcrete_nw_masque_connection_block_invoke_189( uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (*(unsigned __int8 *)(*(void *)(a1 + 32) + 112LL) != 255)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      if (a2 > 5) {
        uint64_t v7 = "unknown";
      }
      else {
        uint64_t v7 = off_189BB9C00[a2];
      }
      uint64_t v8 = *(void *)(a1 + 32);
      int v12 = 136446722;
      BOOL v13 = "nw_masque_connection_start_on_queue_block_invoke";
      __int16 v14 = 2114;
      uint64_t v15 = v8;
      __int16 v16 = 2082;
      uint64_t v17 = v7;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ in connection event %{public}s",  (uint8_t *)&v12,  0x20u);
    }

    if (a2 == 3)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      if (*(_BYTE *)(v9 + 112) == 1)
      {
        *(_BYTE *)(v9 + 112) = 2;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v10 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          uint64_t v11 = *(void *)(a1 + 32);
          int v12 = 136446466;
          BOOL v13 = "nw_masque_connection_start_on_queue_block_invoke";
          __int16 v14 = 2114;
          uint64_t v15 = v11;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ connection masque connected",  (uint8_t *)&v12,  0x16u);
        }
      }
    }

    else if (a2 == 4)
    {
      nw_masque_connection_cancel_on_queue(*(void **)(a1 + 32), v5);
    }
  }
}

void sub_182044B60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke( uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v290 = *MEMORY[0x1895F89C0];
  id v200 = a2;
  uint64_t v7 = a3;
  id v8 = a5;
  nw_content_context_t context = v7;
  if (!v7 || v8) {
    goto LABEL_37;
  }
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  uint64_t v9 = (nw_protocol_definition *)(id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_metadata_t v10 = nw_content_context_copy_protocol_metadata(v7, v9);

  nw_protocol_metadata_t v198 = v10;
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v40 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
    {
      uint64_t v41 = *(void *)(a1 + 32);
      uint64_t v42 = *(void *)(v41 + 48);
      *(_DWORD *)applier = 136446722;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v41;
      *(_WORD *)&applier[22] = 2112;
      *(void *)os_log_type_t v286 = v42;
      _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ Received non-HTTP message, cancelling %@",  applier,  0x20u);
    }

    nw_masque_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
    goto LABEL_36;
  }

  id v11 = nw_http_metadata_copy_request(v10);
  __int16 v196 = v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v43 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      uint64_t v44 = *(void *)(a1 + 32);
      uint64_t v45 = *(void *)(v44 + 48);
      *(_DWORD *)applier = 136446722;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v44;
      *(_WORD *)&applier[22] = 2112;
      *(void *)os_log_type_t v286 = v45;
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ Received non-request HTTP message, cancelling %@",  applier,  0x20u);
    }

    nw_masque_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
    goto LABEL_35;
  }

  v277[0] = MEMORY[0x1895F87A8];
  v277[1] = 3221225472LL;
  v277[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_191;
  v277[3] = &unk_189BC5CF8;
  id v278 = *(id *)(a1 + 32);
  id v12 = v11;
  BOOL v13 = v277;
  _nw_http_request_access_method((uint64_t)v12, v13);

  uint64_t v271 = 0LL;
  v272 = &v271;
  uint64_t v273 = 0x3032000000LL;
  nw_endpoint_t v274 = __Block_byref_object_copy__29392;
  v275 = __Block_byref_object_dispose__29393;
  id v276 = 0LL;
  uint64_t v265 = 0LL;
  char v266 = &v265;
  uint64_t v267 = 0x3032000000LL;
  unsigned int v268 = __Block_byref_object_copy__29392;
  int v269 = __Block_byref_object_dispose__29393;
  id v270 = 0LL;
  uint64_t v259 = 0LL;
  unint64_t v260 = &v259;
  uint64_t v261 = 0x3032000000LL;
  int v262 = __Block_byref_object_copy__29392;
  unint64_t v263 = __Block_byref_object_dispose__29393;
  id v264 = 0LL;
  uint64_t v253 = 0LL;
  size_t v254 = &v253;
  uint64_t v255 = 0x3032000000LL;
  int v256 = __Block_byref_object_copy__29392;
  char v257 = __Block_byref_object_dispose__29393;
  id v258 = 0LL;
  v252[0] = MEMORY[0x1895F87A8];
  v252[1] = 3221225472LL;
  v252[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_193;
  v252[3] = &unk_189BBB5C8;
  v252[4] = &v259;
  v252[5] = &v271;
  id v14 = v12;
  uint64_t v15 = v252;
  _nw_http_fields_access_value_by_name((uint64_t)v14, (unint64_t)"Client-Connection-Id", v15);

  v251[0] = MEMORY[0x1895F87A8];
  v251[1] = 3221225472LL;
  v251[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_2;
  v251[3] = &unk_189BBB5C8;
  v251[4] = &v253;
  v251[5] = &v265;
  id v16 = v14;
  uint64_t v17 = v251;
  _nw_http_fields_access_value_by_name((uint64_t)v16, (unint64_t)"Server-Connection-Id", v17);

  uint64_t v245 = 0LL;
  int v246 = &v245;
  uint64_t v247 = 0x3032000000LL;
  nw_endpoint_t v248 = __Block_byref_object_copy__29392;
  os_log_type_t v249 = __Block_byref_object_dispose__29393;
  id v250 = 0LL;
  v244[0] = MEMORY[0x1895F87A8];
  v244[1] = 3221225472LL;
  v244[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_3;
  v244[3] = &unk_189BC6448;
  v244[4] = &v245;
  id v18 = v16;
  __int16 v19 = v244;
  _nw_http_request_access_authority((uint64_t)v18, v19);

  uint64_t v240 = 0LL;
  BOOL v241 = &v240;
  uint64_t v242 = 0x2020000000LL;
  char v243 = 0;
  uint64_t v236 = 0LL;
  BOOL v237 = &v236;
  uint64_t v238 = 0x2020000000LL;
  char v239 = 0;
  v235[0] = MEMORY[0x1895F87A8];
  v235[1] = 3221225472LL;
  v235[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_4;
  v235[3] = &unk_189BBB5C8;
  v235[4] = &v240;
  v235[5] = &v236;
  id v20 = v18;
  __int16 v21 = v235;
  _nw_http_request_access_extended_connect_protocol((uint64_t)v20, v21);

  uint64_t v284 = 0LL;
  v234[0] = MEMORY[0x1895F87A8];
  v234[1] = 3221225472LL;
  v234[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_5;
  v234[3] = &__block_descriptor_40_e9_v16__0r_8l;
  v234[4] = &v284;
  id v22 = v20;
  uint64_t v23 = v234;
  _nw_http_fields_access_value_by_name((uint64_t)v22, (unint64_t)"Datagram-Flow-Id", v23);

  uint64_t v228 = 0LL;
  BOOL v229 = &v228;
  uint64_t v230 = 0x3032000000LL;
  v231 = __Block_byref_object_copy__29392;
  nw_endpoint_t v232 = __Block_byref_object_dispose__29393;
  id v233 = 0LL;
  v227[0] = MEMORY[0x1895F87A8];
  v227[1] = 3221225472LL;
  v227[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_6;
  v227[3] = &unk_189BC6448;
  v227[4] = &v228;
  id v24 = v22;
  uint64_t v25 = v227;
  _nw_http_request_access_path((uint64_t)v24, v25);

  uint64_t v26 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v26 + 97))
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v161 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v162 = *(void *)(a1 + 32);
        *(_DWORD *)applier = 136446466;
        *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke_7";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v162;
        _os_log_impl( &dword_181A5C000,  v161,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Reverse proxying, responding 200 OK",  applier,  0x16u);
      }

      uint64_t v26 = *(void *)(a1 + 32);
    }

    BOOL v27 = nw_masque_connection_pair_create((NWConcrete_nw_masque_connection *)v26);
    uint64_t v28 = v27;
    int v29 = v284;
    BYTE2(v27[44]._os_unfair_lock_opaque) = v284;
    if (v29)
    {
      int v30 = BYTE1(v284);
      HIBYTE(v27[44]._os_unfair_lock_opaque) = BYTE1(v284);
      if (v30)
      {
        int v31 = BYTE2(v284);
        LOBYTE(v27[45]._os_unfair_lock_opaque) = BYTE2(v284);
        if (v31)
        {
          int v32 = BYTE3(v284);
          BYTE1(v27[45]._os_unfair_lock_opaque) = BYTE3(v284);
          if (v32)
          {
            int v33 = BYTE4(v284);
            BYTE2(v27[45]._os_unfair_lock_opaque) = BYTE4(v284);
            if (v33)
            {
              int v34 = BYTE5(v284);
              HIBYTE(v27[45]._os_unfair_lock_opaque) = BYTE5(v284);
              if (v34)
              {
                int v35 = BYTE6(v284);
                LOBYTE(v27[46]._os_unfair_lock_opaque) = BYTE6(v284);
                if (v35) {
                  BYTE1(v27[46]._os_unfair_lock_opaque) = 0;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v36 = (dispatch_data_s *)v272[5];
    if (v36)
    {
      *(void *)int buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      uint64_t v289 = 0LL;
      uint64_t v279 = 0LL;
      uint64_t v280 = &v279;
      uint64_t v281 = 0x2000000000LL;
      unint64_t v282 = (os_unfair_lock_s *)((char *)v28 + 74);
      uint64_t v37 = MEMORY[0x1895F87A8];
      *(void *)applier = MEMORY[0x1895F87A8];
      *(void *)&void applier[8] = 0x40000000LL;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      *(void *)os_log_type_t v286 = &unk_189BBF598;
      *(void *)&v286[16] = &v279;
      uint64_t v287 = 20LL;
      *(void *)&v286[8] = buf;
      dispatch_data_apply(v36, applier);
      uint64_t v38 = *(void *)(*(void *)&buf[8] + 24LL);
      _Block_object_dispose(&v279, 8);
      _Block_object_dispose(buf, 8);
      LOWORD(v28[18]._os_unfair_lock_opaque) = v38;
      BOOL v39 = (dispatch_data_s *)v260[5];
      *(void *)int buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      uint64_t v289 = 0LL;
      uint64_t v279 = 0LL;
      uint64_t v280 = &v279;
      uint64_t v281 = 0x2000000000LL;
      unint64_t v282 = v28 + 29;
      if (v39)
      {
        *(void *)applier = v37;
        *(void *)&void applier[8] = 0x40000000LL;
        *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
        *(void *)os_log_type_t v286 = &unk_189BBF598;
        *(void *)&v286[16] = &v279;
        uint64_t v287 = 20LL;
        *(void *)&v286[8] = buf;
        dispatch_data_apply(v39, applier);
      }

      _Block_object_dispose(&v279, 8);
      _Block_object_dispose(buf, 8);
      if (gLogDatapath)
      {
        __nwlog_obj();
        BOOL v163 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v164 = *(void *)(a1 + 32);
          int os_unfair_lock_opaque_low = LOWORD(v28[18]._os_unfair_lock_opaque);
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v164;
          *(_WORD *)&applier[22] = 1024;
          *(_DWORD *)os_log_type_t v286 = os_unfair_lock_opaque_low;
          _os_log_impl( &dword_181A5C000,  v163,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received client connection ID of length %u",  applier,  0x1Cu);
        }
      }
    }

    objc_storeStrong((id *)&v28[60], *(id *)(*(void *)(a1 + 32) + 72LL));
    LOBYTE(v28[62]._os_unfair_lock_opaque) = 1;
    nw_masque_connection_pair_setup_outer_connection(v28, (void *)v246[5], 17, v24);

    goto LABEL_34;
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    BOOL v166 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v166, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v167 = *(void *)(a1 + 32);
      uint64_t v168 = v246[5];
      *(_DWORD *)applier = 136446722;
      *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v167;
      *(_WORD *)&applier[22] = 2112;
      *(void *)os_log_type_t v286 = v168;
      _os_log_impl( &dword_181A5C000,  v166,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received authority %@",  applier,  0x20u);
    }
  }

  if (!v246[5])
  {
    __nwlog_obj();
    id v169 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
    uint64_t v170 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v279) = 0;
    if (__nwlog_fault(v170, buf, &v279))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        uint64_t v171 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v172 = buf[0];
        if (os_log_type_enabled(v171, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          _os_log_impl(&dword_181A5C000, v171, v172, "%{public}s called with null authority_endpoint", applier, 0xCu);
        }
      }

      else if ((_BYTE)v279)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v171 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v174 = buf[0];
        BOOL v175 = os_log_type_enabled(v171, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v175)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v171,  v174,  "%{public}s called with null authority_endpoint, dumping backtrace:%{public}s",  applier,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_169;
        }

        if (v175)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          _os_log_impl( &dword_181A5C000,  v171,  v174,  "%{public}s called with null authority_endpoint, no backtrace",  applier,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v171 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v176 = buf[0];
        if (os_log_type_enabled(v171, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_masque_read_inner_request_on_queue_block_invoke";
          _os_log_impl( &dword_181A5C000,  v171,  v176,  "%{public}s called with null authority_endpoint, backtrace limit exceeded",  applier,  0xCu);
        }
      }
    }

void sub_182046BE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20, _Unwind_Exception *exception_objecta, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, void *a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void *a49)
{
  _Block_object_dispose((const void *)(v56 - 224), 8);
  _Block_object_dispose(&STACK[0x260], 8);

  _Block_object_dispose(&STACK[0x2E8], 8);
  _Block_object_dispose(&STACK[0x308], 8);
  _Block_object_dispose(&STACK[0x350], 8);

  _Block_object_dispose(&STACK[0x3E0], 8);
  _Block_object_dispose(&STACK[0x410], 8);

  _Block_object_dispose(&STACK[0x440], 8);
  _Block_object_dispose(&STACK[0x470], 8);

  _Unwind_Resume(a1);
}

void nw_masque_connection_cancel_on_queue(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3[112] != 255)
  {
    if (v4 && !*((void *)v3 + 15)) {
      objc_storeStrong((id *)v3 + 15, a2);
    }
    nw_dictionary_apply(*((void *)v3 + 7), (uint64_t)&__block_literal_global_329);
    nw_dictionary_apply(*((void *)v3 + 8), (uint64_t)&__block_literal_global_330);
    uint64_t v6 = (nw_connection *)*((void *)v3 + 6);
    if (v6)
    {
      nw_connection_cancel(v6);
      uint64_t v7 = (void *)*((void *)v3 + 6);
      *((void *)v3 + 6) = 0LL;
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *((void *)v3 + 15);
        int v13 = 136446722;
        id v14 = "nw_masque_connection_cancel_on_queue";
        __int16 v15 = 2114;
        id v16 = v3;
        __int16 v17 = 2114;
        uint64_t v18 = v12;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@, error %{public}@",  (uint8_t *)&v13,  0x20u);
      }
    }

    v3[112] = -1;
    id v8 = (void *)*((void *)v3 + 7);
    *((void *)v3 + 7) = 0LL;

    uint64_t v9 = (void *)*((void *)v3 + 8);
    *((void *)v3 + _Block_object_dispose((const void *)(v1 - 176), 8) = 0LL;

    nw_protocol_metadata_t v10 = (void *)*((void *)v3 + 13);
    *((void *)v3 + 13) = 0LL;

    int v3 = 0LL;
  }
}

void sub_18204728C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_191( uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    __nwlog_obj();
    id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v6 = 136446722;
      uint64_t v7 = "nw_masque_read_inner_request_on_queue_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2080;
      uint64_t v11 = a2;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received method %s",  (uint8_t *)&v6,  0x20u);
    }
  }

uint64_t __Block_byref_object_copy__29392(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__29393(uint64_t a1)
{
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_193( uint64_t a1, char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 3 && *__s == 58)
    {
      size_t v5 = v4;
      if (__s[v4 - 1] == 58)
      {
        dispatch_data_t v6 = dispatch_data_create(__s, v4, 0LL, 0LL);
        uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
        __int16 v8 = *(void **)(v7 + 40);
        *(void *)(v7 + 40) = v6;

        dispatch_data_t v12 = dispatch_data_create(__s + 1, v5 - 2, 0LL, 0LL);
        uint64_t v9 = dispatch_data_create_with_transform();
        uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
        uint64_t v11 = *(void **)(v10 + 40);
        *(void *)(v10 + 40) = v9;
      }
    }
  }

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_2( uint64_t a1, char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 3 && *__s == 58)
    {
      size_t v5 = v4;
      if (__s[v4 - 1] == 58)
      {
        dispatch_data_t v6 = dispatch_data_create(__s, v4, 0LL, 0LL);
        uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
        __int16 v8 = *(void **)(v7 + 40);
        *(void *)(v7 + 40) = v6;

        dispatch_data_t v12 = dispatch_data_create(__s + 1, v5 - 2, 0LL, 0LL);
        uint64_t v9 = dispatch_data_create_with_transform();
        uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
        uint64_t v11 = *(void **)(v10 + 40);
        *(void *)(v10 + 40) = v9;
      }
    }
  }

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_3( uint64_t a1, const char *a2)
{
  if (a2)
  {
    nw_endpoint_t url = 0LL;
    asprintf(&url, "tcp://%s", a2);
    nw_endpoint_t v3 = nw_endpoint_create_url(url);
    BOOL v4 = nw_endpoint_copy_host_port_endpoint_for_url(v3);
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
    dispatch_data_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;

    if (url) {
      free(url);
    }
  }

void sub_1820475D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_4( uint64_t result, char *__s1)
{
  if (__s1)
  {
    uint64_t v3 = result;
    uint64_t result = strcmp(__s1, "connect-udp");
    if ((_DWORD)result)
    {
      uint64_t result = strcmp(__s1, "connect-ip");
      if ((_DWORD)result) {
        return result;
      }
      uint64_t v4 = v3 + 40;
    }

    else
    {
      uint64_t v4 = v3 + 32;
    }

    *(_BYTE *)(*(void *)(*(void *)v4 + 8LL) + 24LL) = 1;
  }

  return result;
}

void *___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_5( void *result, char *__s)
{
  if (__s)
  {
    uint64_t v3 = (void *)result[4];
    size_t v4 = strlen(__s);
    return memcpy(v3, __s, v4);
  }

  return result;
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_6( uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = [NSString stringWithUTF8String:a2];
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;
  }

os_unfair_lock_s *nw_masque_connection_pair_create(NWConcrete_nw_masque_connection *a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  nw_connection_t v2 = a1;
  uint64_t v3 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_masque_connection_pair);
  uint64_t v4 = v2;
  if (!v3) {
    goto LABEL_4;
  }
  v46.os_log_type_t receiver = v3;
  v46.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_masque_connection_pair;
  uint64_t v3 = -[NWConcrete_nw_masque_connection init](&v46, sel_init);
  if (v3)
  {
    dispatch_group_t v5 = dispatch_group_create();
    dispatch_data_t v6 = (void *)*((void *)v3 + 29);
    *((void *)v3 + 29) = v5;

    objc_storeStrong((id *)v3 + 2, a1);
    nw_endpoint_t v7 = nw_connection_copy_endpoint(v4[6]);
    __int16 v8 = (void *)*((void *)v3 + 28);
    *((void *)v3 + 2_Block_object_dispose((const void *)(v1 - 176), 8) = v7;

    uint64_t v9 = (void *)*((void *)v3 + 6);
    *((void *)v3 + 6) = 0LL;

    snprintf((char *)v3 + 200, 0x11uLL, "%llx", v3);
    goto LABEL_4;
  }

  __nwlog_obj();
  id v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection_pair initWithInnerConnection:]";
  uint64_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v44 = 0;
  if ((__nwlog_fault(v23, &type, &v44) & 1) != 0)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection_pair initWithInnerConnection:]";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s [super init] failed", buf, 0xCu);
      }
    }

    else if (v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection_pair initWithInnerConnection:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (v32)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection_pair initWithInnerConnection:]";
        _os_log_impl(&dword_181A5C000, v24, v31, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_connection_pair initWithInnerConnection:]";
        _os_log_impl(&dword_181A5C000, v24, v36, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void sub_182047D6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, void *a34)
{
  _Unwind_Resume(a1);
}

void nw_masque_connection_pair_setup_outer_connection(void *a1, void *a2, int a3, void *a4)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v43 = a2;
  id v8 = a4;
  uint64_t v9 = (os_unfair_lock_s *)v7;
  id v10 = v8;
  uint64_t v11 = MEMORY[0x1895F87A8];
  if (v9)
  {
    *(void *)int buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL40nw_masque_connection_pair_handle_headersP36NWConcrete_nw_masque_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke;
    int v68 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BBEF10;
    int v69 = v9;
    nw_http_fields_enumerate(v10, buf);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
  BOOL v27 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v63[0]) = 16;
  LOBYTE(v57) = 0;
  if (__nwlog_fault(v27, v63, &v57))
  {
    if (LOBYTE(v63[0]) == 17)
    {
      __nwlog_obj();
      uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = v63[0];
      if (os_log_type_enabled(v28, v63[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if ((_BYTE)v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = v63[0];
      BOOL v36 = os_log_type_enabled(v28, v63[0]);
      if (backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v35,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_44;
      }

      if (v36)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
        _os_log_impl(&dword_181A5C000, v28, v35, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = v63[0];
      if (os_log_type_enabled(v28, v63[0]))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_headers";
        _os_log_impl( &dword_181A5C000,  v28,  v39,  "%{public}s called with null pair, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182048608( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, id a41)
{
  _Block_object_dispose(&a36, 8);
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_206( uint64_t a1)
{
}

os_unfair_lock_s *nw_masque_listener_pair_create(NWConcrete_nw_masque_connection *a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  nw_connection_t v2 = a1;
  uint64_t v3 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_masque_listener_pair);
  uint64_t v4 = v2;
  if (!v3) {
    goto LABEL_4;
  }
  v46.os_log_type_t receiver = v3;
  v46.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_masque_listener_pair;
  uint64_t v3 = -[NWConcrete_nw_masque_connection init](&v46, sel_init);
  if (v3)
  {
    dispatch_group_t v5 = dispatch_group_create();
    dispatch_data_t v6 = (void *)*((void *)v3 + 12);
    *((void *)v3 + 12) = v5;

    objc_storeStrong((id *)v3 + 2, a1);
    nw_endpoint_t v7 = nw_connection_copy_endpoint(v4[6]);
    id v8 = (void *)*((void *)v3 + 11);
    *((void *)v3 + 11) = v7;

    uint64_t v9 = (void *)*((void *)v3 + 3);
    *((void *)v3 + 3) = 0LL;

    snprintf((char *)v3 + 64, 0x11uLL, "%llx", v3);
    goto LABEL_4;
  }

  __nwlog_obj();
  nw_endpoint_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_listener_pair initWithInnerConnection:]";
  id v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v44 = 0;
  if ((__nwlog_fault(v23, &type, &v44) & 1) != 0)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_listener_pair initWithInnerConnection:]";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s [super init] failed", buf, 0xCu);
      }
    }

    else if (v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      BOOL v32 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_listener_pair initWithInnerConnection:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (v32)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_listener_pair initWithInnerConnection:]";
        _os_log_impl(&dword_181A5C000, v24, v31, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_masque_listener_pair initWithInnerConnection:]";
        _os_log_impl(&dword_181A5C000, v24, v36, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void sub_182048D48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, void *a34)
{
  _Unwind_Resume(a1);
}

void nw_masque_listener_pair_setup_outer_connection_group(void *a1, void *a2)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = MEMORY[0x1895F87A8];
    *(void *)uint64_t v54 = MEMORY[0x1895F87A8];
    *(void *)&v54[8] = 3221225472LL;
    *(void *)&v54[16] = ___ZL38nw_masque_listener_pair_handle_headersP34NWConcrete_nw_masque_listener_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke;
    uint64_t v55 = (void *(*)(uint64_t, uint64_t))&unk_189BBEF10;
    uint64_t v56 = (void (*)(uint64_t))v5;
    nw_http_fields_enumerate(v4, v54);

    secure_udp = nw_parameters_create_secure_udp(&__block_literal_global_18956, &__block_literal_global_91);
    id v8 = secure_udp;
    uint64_t v9 = *(nw_interface **)(*((void *)v5 + 2) + 80LL);
    if (v9) {
      nw_parameters_require_interface(secure_udp, v9);
    }
    nw_parameters_set_proxy_applied(v8, 1);
    if (*((void *)v5 + 16)) {
      nw_parameters_set_reuse_local_address(v8, 1);
    }
    uint64_t v10 = *((void *)v5 + 2);
    uint64_t v11 = *(void *)(v10 + 16);
    nw_endpoint_t v12 = nw_connection_copy_endpoint(*(nw_connection_t *)(v10 + 48));
    *(void *)uint64_t v54 = 0LL;
    *(void *)&v54[8] = v54;
    *(void *)&v54[16] = 0x3032000000LL;
    uint64_t v55 = __Block_byref_object_copy__248;
    uint64_t v56 = __Block_byref_object_dispose__249;
    id v57 = 0LL;
    aBlock[0] = v6;
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke;
    aBlock[3] = &unk_189BC9210;
    uint64_t v51 = v54;
    nw_parameters_t v13 = (nw_connection_group_t *)v5;
    __int16 v50 = v13;
    id v14 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)v5 + 2);
    v14[2](v14);
    os_unfair_lock_unlock((os_unfair_lock_t)v5 + 2);

    uint64_t v15 = *(void *)(*(void *)&v54[8] + 40LL);
    if (v15) {
      (*(void (**)(uint64_t, uint64_t, void, nw_parameters *, nw_endpoint_t, id))(v15 + 16))( v15,  v11,  0LL,  v8,  v12,  v4);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v16 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      uint64_t v17 = *((void *)v5 + 2);
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_setup_outer_connection_group";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v17;
      *(_WORD *)&_BYTE buf[22] = 2112;
      uint64_t v59 = v8;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ creating new outer connection group with parameters %@",  buf,  0x20u);
    }

    uint64_t v18 = nw_connection_group_create_with_parameters(v8);
    nw_connection_group_t v19 = v13[3];
    v13[3] = (nw_connection_group_t)v18;

    nw_connection_group_set_queue(v13[3], *(dispatch_queue_t *)(*((void *)v5 + 2) + 32LL));
    uint64_t v20 = v13[3];
    state_changed_handler[0] = v6;
    state_changed_handler[1] = 3221225472LL;
    state_changed_handler[2] = ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke_311;
    state_changed_handler[3] = &unk_189BC9318;
    uint64_t v21 = v13;
    id v48 = v21;
    nw_connection_group_set_state_changed_handler(v20, state_changed_handler);
    nw_endpoint_t v22 = v21;
    id v23 = v22;
    if (*(void *)(*((void *)v5 + 2) + 48LL))
    {
      id v24 = v13[3];
      if (v24)
      {
        *(void *)int buf = v6;
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = ___ZL44nw_masque_listener_pair_read_outer_datagramsP34NWConcrete_nw_masque_listener_pair_block_invoke;
        uint64_t v59 = (nw_parameters *)&unk_189BBB7E0;
        BOOL v60 = v22;
        nw_connection_group_set_receive_handler(v24, 0xFFFFFFFF, 0, buf);

LABEL_13:
        nw_connection_group_start(v13[3]);

        _Block_object_dispose(v54, 8);
        goto LABEL_14;
      }

      __nwlog_obj();
      os_log_type_t v33 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
      int v30 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v52 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
          _os_log_impl( &dword_181A5C000,  v31,  v34,  "%{public}s called with null pair->mlp_outer_connection_group",  buf,  0xCu);
        }
      }

      else if (v52)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        BOOL v41 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v31,  v46,  "%{public}s called with null pair->mlp_outer_connection_group, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v30) {
            goto LABEL_13;
          }
          goto LABEL_67;
        }

        if (v41)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
          _os_log_impl( &dword_181A5C000,  v31,  v46,  "%{public}s called with null pair->mlp_outer_connection_group, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
          _os_log_impl( &dword_181A5C000,  v31,  v44,  "%{public}s called with null pair->mlp_outer_connection_group, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
      int v30 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v52 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
          _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null pair->mlp_parent->mc_in_connection",  buf,  0xCu);
        }
      }

      else if (v52)
      {
        BOOL v38 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v45 = type;
        BOOL v39 = os_log_type_enabled(v31, type);
        if (v38)
        {
          if (v39)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v38;
            _os_log_impl( &dword_181A5C000,  v31,  v45,  "%{public}s called with null pair->mlp_parent->mc_in_connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v38);
LABEL_66:
          if (!v30) {
            goto LABEL_13;
          }
LABEL_67:
          free(v30);
          goto LABEL_13;
        }

        if (v39)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
          _os_log_impl( &dword_181A5C000,  v31,  v45,  "%{public}s called with null pair->mlp_parent->mc_in_connection, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_outer_datagrams";
          _os_log_impl( &dword_181A5C000,  v31,  v43,  "%{public}s called with null pair->mlp_parent->mc_in_connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_66;
  }

  __nwlog_obj();
  os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)uint64_t v54 = 136446210;
  *(void *)&v54[4] = "nw_masque_listener_pair_setup_outer_connection_group";
  uint64_t v26 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v26, buf, &type))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = buf[0];
      if (os_log_type_enabled(v27, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v54 = 136446210;
        *(void *)&v54[4] = "nw_masque_listener_pair_setup_outer_connection_group";
        _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null pair", v54, 0xCu);
      }
    }

    else if (type)
    {
      BOOL v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = buf[0];
      BOOL v37 = os_log_type_enabled(v27, (os_log_type_t)buf[0]);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)uint64_t v54 = 136446466;
          *(void *)&v54[4] = "nw_masque_listener_pair_setup_outer_connection_group";
          *(_WORD *)&v54[12] = 2082;
          *(void *)&v54[14] = v35;
          _os_log_impl( &dword_181A5C000,  v27,  v36,  "%{public}s called with null pair, dumping backtrace:%{public}s",  v54,  0x16u);
        }

        free(v35);
        goto LABEL_58;
      }

      if (v37)
      {
        *(_DWORD *)uint64_t v54 = 136446210;
        *(void *)&v54[4] = "nw_masque_listener_pair_setup_outer_connection_group";
        _os_log_impl(&dword_181A5C000, v27, v36, "%{public}s called with null pair, no backtrace", v54, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = buf[0];
      if (os_log_type_enabled(v27, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v54 = 136446210;
        *(void *)&v54[4] = "nw_masque_listener_pair_setup_outer_connection_group";
        _os_log_impl( &dword_181A5C000,  v27,  v42,  "%{public}s called with null pair, backtrace limit exceeded",  v54,  0xCu);
      }
    }
  }

void sub_1820497B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_masque_listener_pair_read_inner(NWConcrete_nw_masque_listener_pair *a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  nw_connection_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v28 = "nw_masque_listener_pair_read_inner";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v28 = "nw_masque_listener_pair_read_inner";
          __int16 v29 = 2082;
          int v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v13,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v5) {
          goto LABEL_5;
        }
LABEL_56:
        free(v5);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl(&dword_181A5C000, v6, v13, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl(&dword_181A5C000, v6, v20, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

void sub_182049F54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_213( uint64_t a1)
{
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_215( uint64_t a1)
{
}

id nw_masque_copy_matching_connection_pair(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  uint64_t v18 = 0LL;
  BOOL v19 = &v18;
  uint64_t v20 = 0x3032000000LL;
  os_log_type_t v21 = __Block_byref_object_copy__29392;
  os_log_type_t v22 = __Block_byref_object_dispose__29393;
  id v23 = 0LL;
  os_log_type_t v7 = v5 + 6;
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  v13[2] = ___ZL39nw_masque_copy_matching_connection_pairP31NWConcrete_nw_masque_connectionPU25objcproto14OS_nw_endpoint8NSObjectPKc_block_invoke;
  v13[3] = &unk_189BBEC90;
  id v8 = v5;
  BOOL v14 = v8;
  id v15 = v6;
  os_log_type_t v16 = &v18;
  uint64_t v17 = a3;
  id v9 = v6;
  uint64_t v10 = (void (**)(void))_Block_copy(v13);
  os_unfair_lock_lock(v7);
  v10[2](v10);
  os_unfair_lock_unlock(v7);

  id v11 = (id)v19[5];
  _Block_object_dispose(&v18, 8);

  return v11;
}

void sub_18204A0B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void nw_masque_connection_pair_setup_inner_direct_connections(void *a1, void *a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    nw_parameters_t v5 = nw_connection_copy_parameters(*(nw_connection_t *)(*((void *)v3 + 2) + 48LL));
    nw_parameters_t v6 = v5;
    uint64_t v7 = MEMORY[0x1895F87A8];
    if (!*((void *)v3 + 4))
    {
      id v8 = v5;
      BOOL v9 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v8,  0,  0);

      uint64_t v10 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v9);
      nw_protocol_stack_clear_application_protocols(v10);
      if (nw_protocol_demux_copy_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
      }
      if (nw_protocol_demux_copy_definition::definition)
      {
        id v11 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
        nw_protocol_options_t options = nw_protocol_create_options(v11);
        if (v11) {
          os_release(v11);
        }
      }

      else
      {
        nw_protocol_options_t options = nw_protocol_create_options(0LL);
      }

      nw_protocol_stack_prepend_application_protocol(v10, (nw_protocol_options_t)options);

      os_log_type_t v13 = nw_connection_create_with_connection(*(void **)(*((void *)v3 + 2) + 48LL), (void *)v9);
      BOOL v14 = (void *)*((void *)v3 + 4);
      *((void *)v3 + 4) = v13;

      nw_connection_set_queue(*((nw_connection_t *)v3 + 4), *(dispatch_queue_t *)(*((void *)v3 + 2) + 32LL));
      id v15 = (nw_connection *)*((void *)v3 + 4);
      handler[0] = v7;
      handler[1] = 3221225472LL;
      handler[2] = ___ZL56nw_masque_connection_pair_setup_inner_direct_connectionsP36NWConcrete_nw_masque_connection_pairPU33objcproto22OS_nw_protocol_options8NSObject_block_invoke;
      handler[3] = &unk_189BC9318;
      id v37 = v3;
      nw_connection_set_state_changed_handler(v15, handler);
      nw_connection_start(*((nw_connection_t *)v3 + 4));
    }

    os_log_type_t v16 = v6;
    BOOL v17 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v16,  0,  0);

    uint64_t v18 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v17);
    nw_protocol_stack_clear_application_protocols(v18);
    nw_protocol_stack_prepend_application_protocol(v18, v4);
    BOOL v19 = (nw_connection *)nw_connection_create_with_connection(*(void **)(*((void *)v3 + 2) + 48LL), (void *)v17);
    nw_connection_set_queue(v19, *(dispatch_queue_t *)(*((void *)v3 + 2) + 32LL));
    v33[0] = v7;
    v33[1] = 3221225472LL;
    v33[2] = ___ZL56nw_masque_connection_pair_setup_inner_direct_connectionsP36NWConcrete_nw_masque_connection_pairPU33objcproto22OS_nw_protocol_options8NSObject_block_invoke_326;
    v33[3] = &unk_189BC9490;
    id v20 = v3;
    id v34 = v20;
    os_log_type_t v21 = v19;
    BOOL v35 = v21;
    nw_connection_set_state_changed_handler((nw_connection_t)v21, v33);
    nw_connection_start((nw_connection_t)v21);
    uint64_t v22 = *((void *)v20 + 5);
    if (!v22)
    {
      BOOL v23 = nw_array_create();
      id v24 = (void *)*((void *)v20 + 5);
      *((void *)v20 + 5) = v23;

      uint64_t v22 = *((void *)v20 + 5);
    }

    nw_array_append(v22, v21);
    nw_masque_connection_pair_read_inner_direct((NWConcrete_nw_masque_connection_pair *)v20, v21);

    goto LABEL_13;
  }

  __nwlog_obj();
  char v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  BOOL v41 = "nw_masque_connection_pair_setup_inner_direct_connections";
  uint64_t v26 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v38 = 0;
  if (__nwlog_fault(v26, &type, &v38))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v41 = "nw_masque_connection_pair_setup_inner_direct_connections";
        _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v38)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v41 = "nw_masque_connection_pair_setup_inner_direct_connections";
          __int16 v42 = 2082;
          os_log_type_t v43 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }

      if (v31)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v41 = "nw_masque_connection_pair_setup_inner_direct_connections";
        _os_log_impl(&dword_181A5C000, v27, v30, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v41 = "nw_masque_connection_pair_setup_inner_direct_connections";
        _os_log_impl( &dword_181A5C000,  v27,  v32,  "%{public}s called with null pair, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18204A5CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_216( uint64_t a1)
{
}

uint64_t ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_233( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  nw_parameters_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  [NSString stringWithCString:a4 encoding:5];
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  [*(id *)(a1 + 32) setValue:v7 forHTTPHeaderField:v6];
  if (![v6 caseInsensitiveCompare:@"content-length"]) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v7 integerValue];
  }

  return 1LL;
}

void sub_18204A738(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_237( uint64_t a1)
{
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_2_238( uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  nw_parameters_t v5 = v4;
  if (v4) {
    id v6 = v4;
  }

  [v3 setHTTPBody:v5];
  [MEMORY[0x189601EF8] sharedSession];
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_3_240;
  v10[3] = &unk_189BBB638;
  uint64_t v8 = *(void *)(a1 + 32);
  id v11 = *(id *)(a1 + 40);
  [v7 dataTaskWithRequest:v8 completionHandler:v10];
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 resume];
}

void sub_18204A82C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_244( uint64_t a1)
{
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_2_245( uint64_t a1)
{
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_3_240( uint64_t a1, void *a2, void *a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v25 = a2;
  id v4 = a3;
  if (gLogDatapath)
  {
    __nwlog_obj();
    os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v22 = *(void *)(a1 + 32);
      *(_DWORD *)int buf = 136446722;
      os_log_type_t v33 = "nw_masque_read_inner_request_on_queue_block_invoke_3";
      __int16 v34 = 2114;
      uint64_t v35 = v22;
      __int16 v36 = 1024;
      LODWORD(v37) = [v4 statusCode];
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying %u response to client",  buf,  0x1Cu);
    }
  }

  nw_parameters_t v5 = (void *)_nw_http_response_create((unsigned __int16)[v4 statusCode], 0);
  [v4 allHeaderFields];
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v7 = [v6 countByEnumeratingWithState:&v28 objects:v40 count:16];
  if (v7)
  {
    uint64_t v9 = *(void *)v29;
    *(void *)&__int128 v8 = 136446978LL;
    __int128 v23 = v8;
    do
    {
      uint64_t v10 = 0LL;
      do
      {
        if (*(void *)v29 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(void **)(*((void *)&v28 + 1) + 8 * v10);
        objc_msgSend(v6, "objectForKeyedSubscript:", v11, v23);
        nw_endpoint_t v12 = (void *)objc_claimAutoreleasedReturnValue();
        if (gLogDatapath)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v13 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v14 = *(void *)(a1 + 32);
            *(_DWORD *)int buf = v23;
            os_log_type_t v33 = "nw_masque_read_inner_request_on_queue_block_invoke";
            __int16 v34 = 2114;
            uint64_t v35 = v14;
            __int16 v36 = 2112;
            id v37 = v11;
            __int16 v38 = 2112;
            BOOL v39 = v12;
            _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying response header to client: %@: %@",  buf,  0x2Au);
          }
        }

        nw_http_fields_append(v5, [v11 UTF8String], objc_msgSend(v12, "UTF8String"));

        ++v10;
      }

      while (v7 != v10);
      uint64_t v15 = [v6 countByEnumeratingWithState:&v28 objects:v40 count:16];
      uint64_t v7 = v15;
    }

    while (v15);
  }

  metadata_for_response = nw_http_create_metadata_for_response(v5);
  if (v25) {
    BOOL v17 = (dispatch_data_s *)[v25 _createDispatchData];
  }
  else {
    BOOL v17 = 0LL;
  }
  uint64_t v18 = nw_content_context_create("response");
  nw_content_context_set_metadata_for_protocol(v18, (nw_protocol_metadata_t)metadata_for_response);
  BOOL v19 = *(void **)(a1 + 32);
  id v20 = (nw_connection *)v19[6];
  completion[0] = MEMORY[0x1895F87A8];
  completion[1] = 3221225472LL;
  completion[2] = ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_241;
  completion[3] = &unk_189BC5E68;
  BOOL v27 = v19;
  nw_connection_send(v20, v17, v18, 1, completion);
}

void sub_18204ABE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void ___ZL37nw_masque_read_inner_request_on_queueP31NWConcrete_nw_masque_connection_block_invoke_241( uint64_t a1)
{
}

void ___ZL56nw_masque_connection_pair_setup_inner_direct_connectionsP36NWConcrete_nw_masque_connection_pairPU33objcproto22OS_nw_protocol_options8NSObject_block_invoke( uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5) {
      nw_parameters_t v5 = "unknown";
    }
    else {
      nw_parameters_t v5 = off_189BB9C00[a2];
    }
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(v6 + 32);
    uint64_t v8 = *(void *)(v6 + 16);
    int v9 = 136446978;
    uint64_t v10 = "nw_masque_connection_pair_setup_inner_direct_connections_block_invoke";
    __int16 v11 = 2114;
    uint64_t v12 = v8;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    __int16 v15 = 2080;
    os_log_type_t v16 = v5;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ inner direct send connection to %@ has transitioned to %s",  (uint8_t *)&v9,  0x2Au);
  }
}

void ___ZL56nw_masque_connection_pair_setup_inner_direct_connectionsP36NWConcrete_nw_masque_connection_pairPU33objcproto22OS_nw_protocol_options8NSObject_block_invoke_326( uint64_t a1, unsigned int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5) {
      nw_parameters_t v5 = "unknown";
    }
    else {
      nw_parameters_t v5 = off_189BB9C00[a2];
    }
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 16LL);
    int v8 = 136446978;
    int v9 = "nw_masque_connection_pair_setup_inner_direct_connections_block_invoke";
    __int16 v10 = 2114;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v6;
    __int16 v14 = 2080;
    __int16 v15 = v5;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ inner direct receive connection to %@ has transitioned to %s",  (uint8_t *)&v8,  0x2Au);
  }
}

void nw_masque_connection_pair_read_inner_direct( NWConcrete_nw_masque_connection_pair *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  nw_parameters_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int128 v31 = "nw_masque_connection_pair_read_inner_direct";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v29 = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (v29 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v29;
      if (os_log_type_enabled(v8, v29))
      {
        *(_DWORD *)int buf = 136446210;
        __int128 v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v29;
      BOOL v16 = os_log_type_enabled(v8, v29);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)int buf = 136446466;
          __int128 v31 = "nw_masque_connection_pair_read_inner_direct";
          __int16 v32 = 2082;
          os_log_type_t v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_56:
        free(v7);
        goto LABEL_5;
      }

      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        __int128 v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl(&dword_181A5C000, v8, v15, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = v29;
      if (os_log_type_enabled(v8, v29))
      {
        *(_DWORD *)int buf = 136446210;
        __int128 v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl(&dword_181A5C000, v8, v22, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

void sub_18204B5F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_masque_connection_pair_read_inner_directP36NWConcrete_nw_masque_connection_pairP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void **)(a1 + 32);
  uint64_t v7 = (nw_connection *)v6[6];
  if (v7 && (a4 == 40 || !a4))
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 16LL);
        *(_DWORD *)int buf = 136446722;
        BOOL v21 = "nw_masque_connection_pair_read_inner_direct_block_invoke";
        __int16 v22 = 2114;
        uint64_t v23 = v15;
        __int16 v24 = 1024;
        int v25 = a3;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying batch of %u packets to target",  buf,  0x1Cu);
      }

      uint64_t v6 = *(void **)(a1 + 32);
      uint64_t v7 = (nw_connection *)v6[6];
    }

    batch_block[0] = MEMORY[0x1895F87A8];
    batch_block[1] = 3221225472LL;
    batch_block[2] = ___ZL43nw_masque_connection_pair_read_inner_directP36NWConcrete_nw_masque_connection_pairP24NWConcrete_nw_connection_block_invoke_327;
    batch_block[3] = &unk_189BBB720;
    int v19 = a3;
    uint64_t v18 = a2;
    uint64_t v17 = v6;
    nw_connection_batch(v7, batch_block);
    nw_masque_connection_pair_read_inner_direct( *(NWConcrete_nw_masque_connection_pair **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40));
    __int16 v10 = v17;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(v11 + 16);
      uint64_t v13 = *(void *)(v11 + 48);
      *(_DWORD *)int buf = 136446978;
      BOOL v21 = "nw_masque_connection_pair_read_inner_direct_block_invoke";
      __int16 v22 = 2114;
      uint64_t v23 = v12;
      __int16 v24 = 1024;
      int v25 = a4;
      __int16 v26 = 2112;
      uint64_t v27 = v13;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Stopping reading, error %d, outer %@",  buf,  0x26u);
    }
  }
}

void sub_18204B830( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void ___ZL43nw_masque_connection_pair_read_inner_directP36NWConcrete_nw_masque_connection_pairP24NWConcrete_nw_connection_block_invoke_327( uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 48))
  {
    unint64_t v2 = 0LL;
    uint64_t v3 = MEMORY[0x1895F87A8];
    do
    {
      id v4 = (dispatch_data_s *)*(id *)(*(void *)(a1 + 40) + 8 * v2);
      if (gLogDatapath)
      {
        __nwlog_obj();
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v8 = *(void *)(a1 + 32);
          uint64_t v9 = *(void *)(v8 + 16);
          if (v4)
          {
            uint64_t v11 = *(void *)(v8 + 16);
            size_t size = dispatch_data_get_size(v4);
            uint64_t v9 = v11;
          }

          else
          {
            size_t size = 0LL;
          }

          *(_DWORD *)int buf = 136446722;
          uint64_t v15 = "nw_masque_connection_pair_read_inner_direct_block_invoke";
          __int16 v16 = 2114;
          uint64_t v17 = v9;
          __int16 v18 = 2048;
          size_t v19 = size;
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying %zu bytes directly to target",  buf,  0x20u);
        }
      }

      nw_parameters_t v5 = *(void **)(a1 + 32);
      uint64_t v6 = (nw_connection *)v5[6];
      completion[0] = v3;
      completion[1] = 3221225472LL;
      completion[2] = ___ZL43nw_masque_connection_pair_read_inner_directP36NWConcrete_nw_masque_connection_pairP24NWConcrete_nw_connection_block_invoke_328;
      completion[3] = &unk_189BC5E68;
      uint64_t v13 = v5;
      nw_connection_send(v6, v4, (nw_content_context_t)&__block_literal_global_41831, 1, completion);

      ++v2;
    }

    while (v2 < *(unsigned int *)(a1 + 48));
  }

void sub_18204BA10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_masque_connection_pair_read_inner_directP36NWConcrete_nw_masque_connection_pairP24NWConcrete_nw_connection_block_invoke_328( uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
      int v6 = 136446722;
      uint64_t v7 = "nw_masque_connection_pair_read_inner_direct_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received error sending to outer connection %@",  (uint8_t *)&v6,  0x20u);
    }
  }
}

void ___ZL39nw_masque_copy_matching_connection_pairP31NWConcrete_nw_masque_connectionPU25objcproto14OS_nw_endpoint8NSObjectPKc_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 56LL);
  if (v1)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    v3[2] = ___ZL39nw_masque_copy_matching_connection_pairP31NWConcrete_nw_masque_connectionPU25objcproto14OS_nw_endpoint8NSObjectPKc_block_invoke_2;
    v3[3] = &unk_189BBB830;
    id v4 = *(id *)(a1 + 40);
    __int128 v5 = *(_OWORD *)(a1 + 48);
    nw_dictionary_apply(v1, (uint64_t)v3);
  }

uint64_t ___ZL39nw_masque_copy_matching_connection_pairP31NWConcrete_nw_masque_connectionPU25objcproto14OS_nw_endpoint8NSObjectPKc_block_invoke_2( uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (*((_BYTE *)v5 + 219)
    && nw_endpoint_is_equal(*(void **)(a1 + 32), *((void **)v5 + 28), 0LL)
    && !strcmp(*(const char **)(a1 + 48), (const char *)v5 + 178))
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  return v6;
}

void sub_18204BC4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke( uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v99 = *MEMORY[0x1895F89C0];
  __int16 v8 = a2;
  uint64_t v9 = a3;
  nw_content_context_t context = v9;
  id v76 = a5;
  data = v8;
  if (v8)
  {
    size_t size = dispatch_data_get_size(v8);
    if (!v9 || size)
    {
LABEL_21:
      if (!*(void *)(*(void *)(a1 + 32) + 24LL)
        || v76 && (v20 = v76, int v21 = v20[3], v20, v21 != 40))
      {
        uint64_t v26 = a1;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          uint64_t v27 = *(void *)(*(void *)(v26 + 32) + 16LL);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v27;
          *(_WORD *)&_BYTE buf[22] = 2112;
          uint64_t v92 = (uint64_t)v76;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Stopping reading, error %@",  buf,  0x20u);
        }

        goto LABEL_86;
      }

      if (!data)
      {
        nw_masque_listener_pair_read_inner(*(NWConcrete_nw_masque_listener_pair **)(a1 + 32));
        goto LABEL_87;
      }

      uint64_t v22 = a1;
      size_t v23 = dispatch_data_get_size(data);
      if (v23 <= 6)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v24 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          uint64_t v25 = *(void *)(*(void *)(v22 + 32) + 16LL);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v25;
          *(_WORD *)&_BYTE buf[22] = 2048;
          uint64_t v92 = v23;
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Received too short content (%zu bytes)",  buf,  0x20u);
        }

        nw_masque_listener_pair_read_inner(*(NWConcrete_nw_masque_listener_pair **)(v22 + 32));
        goto LABEL_87;
      }

      uint64_t v12 = data;
      LOBYTE(v85) = 0;
      uint64_t v95 = 0LL;
      BOOL v96 = &v95;
      uint64_t v97 = 0x2000000000LL;
      uint64_t v98 = 0LL;
      uint64_t v87 = 0LL;
      uint64_t v88 = &v87;
      uint64_t v89 = 0x2000000000LL;
      char v90 = &v85;
      uint64_t v28 = MEMORY[0x1895F87A8];
      *(void *)int buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
      uint64_t v92 = (uint64_t)&unk_189BBF598;
      *((void *)&v93 + 1) = &v87;
      uint64_t v94 = 1LL;
      *(void *)&__int128 v93 = &v95;
      dispatch_data_apply((dispatch_data_t)v12, buf);
      _Block_object_dispose(&v87, 8);
      _Block_object_dispose(&v95, 8);
      if (v85 == 6)
      {
        memset(v79, 0, sizeof(v79));
        uint64_t v95 = 0LL;
        BOOL v96 = &v95;
        uint64_t v97 = 0x2000000000LL;
        uint64_t v98 = 0LL;
        uint64_t v87 = 0LL;
        uint64_t v88 = &v87;
        uint64_t v89 = 0x2000000000LL;
        char v90 = (unsigned __int16 *)v79;
        *(void *)int buf = v28;
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
        uint64_t v92 = (uint64_t)&unk_189BBF598;
        *((void *)&v93 + 1) = &v87;
        uint64_t v94 = 19LL;
        *(void *)&__int128 v93 = &v95;
        dispatch_data_apply((dispatch_data_t)v12, buf);
        uint64_t v32 = v96[3];
        _Block_object_dispose(&v87, 8);
        _Block_object_dispose(&v95, 8);
        uint64_t address = 0LL;
        if (v32 == 19)
        {
          *(_DWORD *)&uint8_t buf[4] = 0;
          LODWORD(v92) = 0;
          *(_WORD *)int buf = 7708;
          *(_OWORD *)&buf[8] = *(_OWORD *)&v79[1];
          *(_WORD *)&buf[2] = *(_WORD *)&v79[17];
          uint64_t address = nw_endpoint_create_address((const sockaddr *)buf);
        }

        dispatch_data_t subrange = dispatch_data_create_subrange((dispatch_data_t)v12, 0x13uLL, v23 - 19);
      }

      else
      {
        if (v85 != 4)
        {
LABEL_43:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v35 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            uint64_t v36 = *(void *)(*(void *)(v22 + 32) + 16LL);
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v36;
            _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Failed to parse remote endpoint from datagram",  buf,  0x16u);
          }

          nw_masque_listener_pair_read_inner(*(NWConcrete_nw_masque_listener_pair **)(v22 + 32));
          goto LABEL_86;
        }

        *(_DWORD *)&v79[3] = 0;
        *(_DWORD *)uint64_t v79 = 0;
        uint64_t v95 = 0LL;
        BOOL v96 = &v95;
        uint64_t v97 = 0x2000000000LL;
        uint64_t v98 = 0LL;
        uint64_t v87 = 0LL;
        uint64_t v88 = &v87;
        uint64_t v89 = 0x2000000000LL;
        char v90 = (unsigned __int16 *)v79;
        *(void *)int buf = v28;
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
        uint64_t v92 = (uint64_t)&unk_189BBF598;
        *((void *)&v93 + 1) = &v87;
        uint64_t v94 = 7LL;
        *(void *)&__int128 v93 = &v95;
        dispatch_data_apply((dispatch_data_t)v12, buf);
        uint64_t v29 = v96[3];
        _Block_object_dispose(&v87, 8);
        _Block_object_dispose(&v95, 8);
        uint64_t address = 0LL;
        if (v29 == 7)
        {
          *(void *)&buf[8] = 0LL;
          *(_WORD *)int buf = 528;
          *(_DWORD *)&uint8_t buf[4] = *(_DWORD *)&v79[1];
          *(_WORD *)&buf[2] = *(_WORD *)&v79[5];
          uint64_t address = nw_endpoint_create_address((const sockaddr *)buf);
        }

        dispatch_data_t subrange = dispatch_data_create_subrange((dispatch_data_t)v12, 7uLL, v23 - 7);
      }

      uint64_t v12 = (os_log_s *)subrange;
      if (address)
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          int v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v65 = *(void *)(*(void *)(v22 + 32) + 16LL);
            if (v12) {
              size_t v66 = dispatch_data_get_size((dispatch_data_t)v12);
            }
            else {
              size_t v66 = 0LL;
            }
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v65;
            *(_WORD *)&_BYTE buf[22] = 2048;
            uint64_t v92 = v66;
            LOWORD(v93) = 2112;
            *(void *)((char *)&v93 + 2) = address;
            _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying %zu bytes to target %@",  buf,  0x2Au);
          }
        }

        dispatch_group_enter(*(dispatch_group_t *)(*(void *)(v22 + 32) + 96LL));
        os_log_type_t v33 = *(void **)(v22 + 32);
        uint64_t v34 = (nw_connection_group *)v33[3];
        completion[0] = v28;
        completion[1] = 3221225472LL;
        completion[2] = ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke_322;
        completion[3] = &unk_189BC5E68;
        int v78 = v33;
        nw_connection_group_send_message( v34,  (dispatch_data_t)v12,  address,  (nw_content_context_t)&__block_literal_global_41831,  completion);
        nw_masque_listener_pair_read_inner(*(NWConcrete_nw_masque_listener_pair **)(v22 + 32));

        goto LABEL_86;
      }

      goto LABEL_43;
    }
  }

  else if (!v9)
  {
    goto LABEL_21;
  }

  uint64_t v72 = a1;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  id v11 = (nw_protocol_definition *)(id)nw_protocol_copy_http_definition_http_definition;
  uint64_t v12 = nw_content_context_copy_protocol_metadata(v9, v11);

  if (!v12 || !nw_http_metadata_is_capsule(v12))
  {

    a1 = v72;
    goto LABEL_21;
  }

  capsule_os_log_type_t type = nw_http_metadata_get_capsule_type(v12);
  uint64_t v71 = (dispatch_data_s *)nw_http_metadata_copy_capsule_data(v12);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v14 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v15 = *(void *)(*(void *)(v72 + 32) + 16LL);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v15;
    *(_WORD *)&_BYTE buf[22] = 2048;
    uint64_t v92 = capsule_type;
    LOWORD(v93) = 2112;
    *(void *)((char *)&v93 + 2) = v71;
    _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received capsule type %llx with data %@",  buf,  0x2Au);
  }

  if (capsule_type != 16770306) {
    goto LABEL_85;
  }
  if (!*(void *)(*(void *)(v72 + 32) + 40LL))
  {
    __int16 v16 = nw_dictionary_create();
    uint64_t v17 = *(void *)(v72 + 32);
    __int16 v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;
  }

  if (nw_protocol_demux_copy_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
  }
  if (nw_protocol_demux_copy_definition::definition)
  {
    size_t v19 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
    nw_protocol_options_t options = nw_protocol_create_options(v19);
    if (v19) {
      os_release(v19);
    }
  }

  else
  {
    nw_protocol_options_t options = nw_protocol_create_options(0LL);
  }

  *(_WORD *)uint64_t v79 = 0;
  size_t v37 = dispatch_data_get_size(v71);
  if (v37 <= 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v38 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      goto LABEL_83;
    }
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v37;
    *(_WORD *)&_BYTE buf[22] = 2048;
    uint64_t v92 = 2LL;
    BOOL v39 = "%{public}s insufficient capsule data bytes %zu < %zu";
    os_log_type_t v40 = v38;
    uint32_t v41 = 32;
LABEL_76:
    _os_log_impl(&dword_181A5C000, v40, OS_LOG_TYPE_ERROR, v39, buf, v41);
    goto LABEL_83;
  }

  nw_dispatch_data_copyout_from_offset(v71, (uint64_t)v79, 2LL, 0LL);
  uint64_t v42 = bswap32(*(unsigned __int16 *)v79) >> 16;
  if (v37 != v42 + 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v38 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      goto LABEL_83;
    }
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v37;
    *(_WORD *)&_BYTE buf[22] = 2048;
    uint64_t v92 = 2LL;
    LOWORD(v93) = 1024;
    *(_DWORD *)((char *)&v93 + 2) = v42;
    BOOL v39 = "%{public}s mismatched capsule data bytes %zu != (%zu + %u)";
    os_log_type_t v40 = v38;
    uint32_t v41 = 38;
    goto LABEL_76;
  }

  if (v37 < 3) {
    goto LABEL_84;
  }
  nw_endpoint_t endpoint = 0LL;
  uint64_t v43 = 2LL;
  uint64_t v44 = MEMORY[0x1895F87A8];
  os_log_type_t v45 = v71;
  do
  {
    char v86 = 0;
    nw_dispatch_data_copyout_from_offset(v45, (uint64_t)&v86, 1LL, v43);
    unsigned __int16 v85 = 0;
    nw_dispatch_data_copyout_from_offset(v45, (uint64_t)&v85, 2LL, v43 + 1);
    uint64_t v48 = v43 + 3;
    int v49 = v85;
    size_t v50 = __rev16(v85);
    size_t v70 = v43 + 3 + v50;
    if (v86 != 2)
    {
      if (v86 == 1)
      {
        uint64_t v51 = dispatch_data_create_subrange(v71, v43 + 3, v50);
        *(void *)int buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2020000000LL;
        uint64_t v92 = 0LL;
        if (v49)
        {
          unint64_t v52 = 0LL;
          do
          {
            unsigned __int16 v84 = 0;
            __int16 v83 = 0;
            nw_dispatch_data_copyout_from_offset(v51, (uint64_t)&v84, 2LL, v52);
            uint64_t v55 = *(void *)(*(void *)&buf[8] + 24LL) + 2LL;
            *(void *)(*(void *)&buf[8] + 24LL) = v55;
            nw_dispatch_data_copyout_from_offset(v51, (uint64_t)&v83, 2LL, v55);
            *(void *)(*(void *)&buf[8] + 24LL) += 2LL;
            uint64_t v95 = 0LL;
            BOOL v96 = &v95;
            uint64_t v97 = 0x2020000000LL;
            uint64_t v98 = 0LL;
            applier[0] = v44;
            applier[1] = 3221225472LL;
            applier[2] = ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke_319;
            applier[3] = &unk_189BBB798;
            applier[4] = buf;
            applier[5] = &v95;
            dispatch_data_apply(v51, applier);
            uint64_t v56 = *(void *)(*(void *)&buf[8] + 24LL) + v84;
            *(void *)(*(void *)&buf[8] + 24LL) = v56;
            char v81 = 0;
            nw_dispatch_data_copyout_from_offset(v51, (uint64_t)&v81, 1LL, v56);
            ++*(void *)(*(void *)&buf[8] + 24LL);
            uint64_t v87 = 0LL;
            uint64_t v88 = &v87;
            uint64_t v89 = 0x2020000000LL;
            char v90 = 0LL;
            if (v81)
            {
              v80[0] = v44;
              v80[1] = 3221225472LL;
              v80[2] = ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke_2;
              v80[3] = &unk_189BBB798;
              v80[4] = buf;
              v80[5] = &v87;
              dispatch_data_apply(v51, v80);
              unsigned int v54 = v84;
              *(void *)(*(void *)&buf[8] + 24LL) += v84;
              uint64_t v53 = v88[3];
            }

            else
            {
              uint64_t v53 = 0LL;
              unsigned int v54 = v84;
            }

            nw_demux_options_add_pattern(options, v83, v54, v96[3], v53);
            _Block_object_dispose(&v87, 8);
            _Block_object_dispose(&v95, 8);
            unint64_t v52 = *(void *)(*(void *)&buf[8] + 24LL);
          }

          while (v52 < v50);
        }

        _Block_object_dispose(buf, 8);

        size_t v46 = v70;
        goto LABEL_54;
      }

      size_t v46 = v43 + 3 + v50;
LABEL_67:
      if (v46 != v48) {
        goto LABEL_71;
      }
      goto LABEL_54;
    }

    uint64_t v95 = 0LL;
    BOOL v96 = 0LL;
    nw_dispatch_data_copyout_from_offset(v71, (uint64_t)&v95, 16LL, v43 + 3);
    if (BYTE1(v95) == 30)
    {
      memset(buf, 0, sizeof(buf));
      LODWORD(v92) = 0;
      nw_dispatch_data_copyout_from_offset(v71, (uint64_t)buf, 28LL, v43 + 3);
      size_t v46 = v43 + 3 + v50;
      nw_endpoint_t v57 = nw_endpoint_create_address((const sockaddr *)buf);

      uint64_t v48 = v43 + 31;
    }

    else
    {
      size_t v46 = v43 + 3 + v50;
      if (BYTE1(v95) != 2) {
        goto LABEL_67;
      }
      *(void *)int buf = 0LL;
      *(void *)&buf[8] = 0LL;
      nw_dispatch_data_copyout_from_offset(v71, (uint64_t)buf, 16LL, v43 + 3);
      nw_endpoint_t v57 = nw_endpoint_create_address((const sockaddr *)buf);

      uint64_t v48 = v43 + 19;
    }

    nw_endpoint_t endpoint = v57;
    if (v46 != v48)
    {
LABEL_71:
      __nwlog_obj();
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke_3";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v46;
        *(_WORD *)&_BYTE buf[22] = 2048;
        uint64_t v92 = v48;
        _os_log_impl( &dword_181A5C000,  v58,  OS_LOG_TYPE_ERROR,  "%{public}s mismatched end offset %zu != %zu",  buf,  0x20u);
      }

      goto LABEL_82;
    }

void sub_18204CA90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke_319( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (a5 + a3 >= v5) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4 + v5 - a3;
  }
  return a5 + a3 < v5;
}

BOOL ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (a5 + a3 >= v5) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4 + v5 - a3;
  }
  return a5 + a3 < v5;
}

void nw_masque_listener_pair_setup_inner_direct_connections(void *a1, void *a2, void *a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  unint64_t v5 = a1;
  uint64_t v6 = a2;
  id v36 = a3;
  if (v5)
  {
    nw_parameters_t v7 = nw_connection_copy_parameters(*(nw_connection_t *)(v5[2] + 48LL));
    nw_parameters_t v8 = v7;
    uint64_t v9 = MEMORY[0x1895F87A8];
    if (!v5[6])
    {
      __int16 v10 = v7;
      BOOL v11 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v10,  0,  0);

      uint64_t v12 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v11);
      nw_protocol_stack_clear_application_protocols(v12);
      if (nw_protocol_demux_copy_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
      }
      if (nw_protocol_demux_copy_definition::definition)
      {
        uint64_t v13 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
        nw_protocol_options_t options = nw_protocol_create_options(v13);
        if (v13) {
          os_release(v13);
        }
      }

      else
      {
        nw_protocol_options_t options = nw_protocol_create_options(0LL);
      }

      nw_protocol_stack_prepend_application_protocol(v12, (nw_protocol_options_t)options);

      uint64_t v15 = (nw_connection *)nw_connection_create_with_connection(*(void **)(v5[2] + 48LL), (void *)v11);
      nw_connection_set_queue(v15, *(dispatch_queue_t *)(v5[2] + 32LL));
      handler[0] = v9;
      handler[1] = 3221225472LL;
      handler[2] = ___ZL54nw_masque_listener_pair_setup_inner_direct_connectionsP34NWConcrete_nw_masque_listener_pairPU33objcproto22OS_nw_protocol_options8NSObjectPU25objcproto14OS_nw_endpointS1__block_invoke;
      handler[3] = &unk_189BC9490;
      uint32_t v41 = v5;
      __int16 v16 = v15;
      uint64_t v42 = v16;
      nw_connection_set_state_changed_handler(v16, handler);
      nw_connection_start(v16);
      uint64_t v17 = (void *)v5[6];
      v5[6] = v16;
      __int16 v18 = v16;
    }

    size_t v19 = v8;
    BOOL v20 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v19,  0,  0);

    int v21 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v20);
    nw_protocol_stack_clear_application_protocols(v21);
    if (v6) {
      nw_protocol_stack_prepend_application_protocol(v21, v6);
    }
    uint64_t v22 = (nw_connection *)nw_connection_create_with_connection(*(void **)(v5[2] + 48LL), (void *)v20);
    nw_connection_set_queue(v22, *(dispatch_queue_t *)(v5[2] + 32LL));
    v37[0] = v9;
    v37[1] = 3221225472LL;
    v37[2] = ___ZL54nw_masque_listener_pair_setup_inner_direct_connectionsP34NWConcrete_nw_masque_listener_pairPU33objcproto22OS_nw_protocol_options8NSObjectPU25objcproto14OS_nw_endpointS1__block_invoke_323;
    v37[3] = &unk_189BC9490;
    size_t v23 = v5;
    id v38 = v23;
    __int16 v24 = v22;
    BOOL v39 = v24;
    nw_connection_set_state_changed_handler(v24, v37);
    nw_connection_start(v24);
    uint64_t v25 = v23[7];
    if (!v25)
    {
      BOOL v26 = nw_array_create();
      uint64_t v27 = (void *)v23[7];
      v23[7] = v26;

      uint64_t v25 = v23[7];
    }

    nw_array_append(v25, v24);
    nw_masque_listener_pair_read_inner_direct(v23, v24, v36);

    goto LABEL_15;
  }

  __nwlog_obj();
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  size_t v46 = "nw_masque_listener_pair_setup_inner_direct_connections";
  uint64_t v29 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v44 = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (__nwlog_fault(v29, &v44, &v43))
  {
    if (v44 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = v44;
      if (os_log_type_enabled(v30, v44))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v46 = "nw_masque_listener_pair_setup_inner_direct_connections";
        _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int128 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = v44;
      BOOL v34 = os_log_type_enabled(v30, v44);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)int buf = 136446466;
          size_t v46 = "nw_masque_listener_pair_setup_inner_direct_connections";
          __int16 v47 = 2082;
          uint64_t v48 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v30,  v33,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }

      if (v34)
      {
        *(_DWORD *)int buf = 136446210;
        size_t v46 = "nw_masque_listener_pair_setup_inner_direct_connections";
        _os_log_impl(&dword_181A5C000, v30, v33, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int128 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = v44;
      if (os_log_type_enabled(v30, v44))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v46 = "nw_masque_listener_pair_setup_inner_direct_connections";
        _os_log_impl( &dword_181A5C000,  v30,  v35,  "%{public}s called with null pair, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18204D0F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, void *a25)
{
  _Unwind_Resume(a1);
}

void ___ZL34nw_masque_listener_pair_read_innerP34NWConcrete_nw_masque_listener_pair_block_invoke_322( uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
      int v6 = 136446722;
      nw_parameters_t v7 = "nw_masque_listener_pair_read_inner_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received error sending to outer connection group %@",  (uint8_t *)&v6,  0x20u);
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 96LL));
}

void ___ZL54nw_masque_listener_pair_setup_inner_direct_connectionsP34NWConcrete_nw_masque_listener_pairPU33objcproto22OS_nw_protocol_options8NSObjectPU25objcproto14OS_nw_endpointS1__block_invoke( uint64_t a1, unsigned int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5) {
      uint64_t v5 = "unknown";
    }
    else {
      uint64_t v5 = off_189BB9C00[a2];
    }
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 16LL);
    int v8 = 136446978;
    uint64_t v9 = "nw_masque_listener_pair_setup_inner_direct_connections_block_invoke";
    __int16 v10 = 2114;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v6;
    __int16 v14 = 2080;
    uint64_t v15 = v5;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ inner direct send connection to %@ has transitioned to %s",  (uint8_t *)&v8,  0x2Au);
  }
}

void ___ZL54nw_masque_listener_pair_setup_inner_direct_connectionsP34NWConcrete_nw_masque_listener_pairPU33objcproto22OS_nw_protocol_options8NSObjectPU25objcproto14OS_nw_endpointS1__block_invoke_323( uint64_t a1, unsigned int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    if (a2 > 5) {
      uint64_t v5 = "unknown";
    }
    else {
      uint64_t v5 = off_189BB9C00[a2];
    }
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 16LL);
    int v8 = 136446978;
    uint64_t v9 = "nw_masque_listener_pair_setup_inner_direct_connections_block_invoke";
    __int16 v10 = 2114;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v6;
    __int16 v14 = 2080;
    uint64_t v15 = v5;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ inner direct receive connection to %@ has transitioned to %s",  (uint8_t *)&v8,  0x2Au);
  }
}

void nw_masque_listener_pair_read_inner_direct(void *a1, void *a2, void *a3)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (!v5)
  {
    __nwlog_obj();
    int v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    BOOL v34 = "nw_masque_listener_pair_read_inner_direct";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v34 = "nw_masque_listener_pair_read_inner_direct";
          __int16 v35 = 2082;
          id v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null pair, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_18204DC6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_masque_listener_pair_read_inner_directP34NWConcrete_nw_masque_listener_pairP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObject_block_invoke( void *a1, id *a2, unsigned int a3, int a4)
{
  void v30[2] = *MEMORY[0x1895F89C0];
  if (*(void *)(a1[4] + 24LL) && (a4 == 40 || !a4))
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v22 = *(void *)(a1[4] + 16LL);
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v26 = "nw_masque_listener_pair_read_inner_direct_block_invoke";
        __int16 v27 = 2114;
        uint64_t v28 = v22;
        __int16 v29 = 1024;
        LODWORD(v30[0]) = a3;
        _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying batch of %u packets to target group",  buf,  0x1Cu);
      }
    }

    if (a3)
    {
      uint64_t v8 = a3;
      uint64_t v9 = MEMORY[0x1895F87A8];
      do
      {
        __int16 v10 = (dispatch_data_s *)*a2;
        if (gLogDatapath)
        {
          __nwlog_obj();
          __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v15 = *(void *)(a1[4] + 16LL);
            if (v10) {
              size_t size = dispatch_data_get_size(v10);
            }
            else {
              size_t size = 0LL;
            }
            *(_DWORD *)int buf = 136446722;
            os_log_type_t v26 = "nw_masque_listener_pair_read_inner_direct_block_invoke";
            __int16 v27 = 2114;
            uint64_t v28 = v15;
            __int16 v29 = 2048;
            v30[0] = size;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying %zu bytes directly to target",  buf,  0x20u);
          }
        }

        os_log_type_t v11 = (void *)a1[4];
        __int16 v12 = (nw_endpoint *)a1[5];
        os_log_type_t v13 = (nw_connection_group *)v11[3];
        completion[0] = v9;
        completion[1] = 3221225472LL;
        completion[2] = ___ZL41nw_masque_listener_pair_read_inner_directP34NWConcrete_nw_masque_listener_pairP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObject_block_invoke_324;
        completion[3] = &unk_189BC5E68;
        os_log_type_t v24 = v11;
        nw_connection_group_send_message(v13, v10, v12, (nw_content_context_t)&__block_literal_global_41831, completion);

        ++a2;
        --v8;
      }

      while (v8);
    }

    nw_masque_listener_pair_read_inner_direct(a1[4], a1[6], a1[5]);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = a1[4];
      uint64_t v20 = *(void *)(v18 + 16);
      uint64_t v19 = *(void *)(v18 + 24);
      *(_DWORD *)int buf = 136446978;
      os_log_type_t v26 = "nw_masque_listener_pair_read_inner_direct_block_invoke";
      __int16 v27 = 2114;
      uint64_t v28 = v20;
      __int16 v29 = 1024;
      LODWORD(v30[0]) = a4;
      WORD2(v30[0]) = 2112;
      *(void *)((char *)v30 + 6) = v19;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Stopping reading, error %d, outer %@",  buf,  0x26u);
    }
  }

void sub_18204DFA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_masque_listener_pair_read_inner_directP34NWConcrete_nw_masque_listener_pairP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObject_block_invoke_324( uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
      int v6 = 136446722;
      id v7 = "nw_masque_listener_pair_read_inner_direct_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received error sending to outer connection %@",  (uint8_t *)&v6,  0x20u);
    }
  }
}

uint64_t ___ZL38nw_masque_listener_pair_handle_headersP34NWConcrete_nw_masque_listener_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  [NSString stringWithCString:a2 encoding:5];
  int v6 = (void *)objc_claimAutoreleasedReturnValue();
  [NSString stringWithCString:a4 encoding:5];
  id v7 = (void *)objc_claimAutoreleasedReturnValue();
  __int16 v8 = (id *)*(id *)(a1 + 32);
  id v9 = v6;
  id v10 = v7;
  [NSString stringWithUTF8String:"Listener-Association"];
  id v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (![v9 caseInsensitiveCompare:v11])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      int v15 = 136446722;
      uint64_t v16 = "nw_masque_listener_pair_handle_listener_association_header";
      __int16 v17 = 2112;
      id v18 = v9;
      __int16 v19 = 2112;
      id v20 = v10;
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %@ : %@", (uint8_t *)&v15, 0x20u);
    }

    os_log_type_t v13 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v10];
    if (v13) {
      objc_storeStrong(v8 + 16, v7);
    }
  }

  return 1LL;
}

void sub_18204E27C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__248(uint64_t a1, uint64_t a2)
{
  uint64_t result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__249(uint64_t a1)
{
}

void ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke( uint64_t a1)
{
  unint64_t v2 = _Block_copy(*(const void **)(*(void *)(*(void *)(a1 + 32) + 16LL) + 88LL));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke_311( uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v6 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    if (a2 > 4) {
      id v7 = "<unknown>";
    }
    else {
      id v7 = off_189BB8B98[a2];
    }
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 16LL);
    id v9 = *(void *(**)(uint64_t, uint64_t))(*(void *)(a1 + 32) + 24LL);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_setup_outer_connection_group_block_invoke";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v8;
    *(_WORD *)&_BYTE buf[22] = 2112;
    uint64_t v61 = v9;
    LOWORD(v62) = 2080;
    *(void *)((char *)&v62 + 2) = v7;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ outer connection group to %@ has transitioned to %s",  buf,  0x2Au);
  }

  if (a2 - 3 < 2) {
    goto LABEL_9;
  }
  if (a2 == 2)
  {
    if (*(_BYTE *)(*(void *)(a1 + 32) + 81LL)) {
      goto LABEL_20;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
    {
      uint64_t v26 = *(void *)(a1 + 32);
      uint64_t v27 = *(void *)(v26 + 16);
      uint64_t v28 = *(void *(**)(uint64_t, uint64_t))(v26 + 88);
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_setup_outer_connection_group_block_invoke_2";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v27;
      *(_WORD *)&_BYTE buf[22] = 2112;
      uint64_t v61 = v28;
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ Opened UDP connection group (for %@)",  buf,  0x20u);
    }

    *(_BYTE *)(*(void *)(a1 + 32) + 81LL) = 1;
    uint64_t v29 = *(void *)(a1 + 32);
    if (!*(void *)(v29 + 128))
    {
LABEL_29:
      uint64_t well_known = (void *)_nw_http_response_create_well_known(200LL);
      metadata_for_response = nw_http_create_metadata_for_response(well_known);
      id v38 = nw_content_context_create("response");
      nw_content_context_set_metadata_for_protocol(v38, (nw_protocol_metadata_t)metadata_for_response);
      nw_connection_send( *(nw_connection_t *)(*(void *)(*(void *)(a1 + 32) + 16LL) + 48LL),  0LL,  v38,  1,  &__block_literal_global_24170);

      goto LABEL_20;
    }

    __int16 port = nw_connection_group_get_port(*(void **)(v29 + 24));
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(*(void *)(a1 + 32) + 16LL) + 40LL));
    uint64_t v32 = [*(id *)(*(void *)(a1 + 32) + 128) UTF8String];
    os_log_type_t v33 = (os_unfair_lock_s *)WeakRetained;
    BOOL v34 = v33;
    if (v33)
    {
      if (v32)
      {
        *(void *)int buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = __nw_masque_server_set_listener_association_port_block_invoke;
        uint64_t v61 = (void *(*)(uint64_t, uint64_t))&unk_189BC9418;
        *(void *)&__int128 v62 = v33;
        *((void *)&v62 + 1) = v32;
        __int16 v63 = port;
        __int16 v35 = (void (**)(void))_Block_copy(buf);
        os_unfair_lock_lock(v34 + 4);
        v35[2](v35);
        os_unfair_lock_unlock(v34 + 4);

LABEL_28:
        goto LABEL_29;
      }

      __nwlog_obj();
      char v43 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
      os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v58 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint32_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
          _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null key", buf, 0xCu);
        }
      }

      else if (v58)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint32_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v41, type);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v41,  v49,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v40) {
            goto LABEL_28;
          }
          goto LABEL_64;
        }

        if (v50)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
          _os_log_impl(&dword_181A5C000, v41, v49, "%{public}s called with null key, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint32_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v52 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
          _os_log_impl( &dword_181A5C000,  v41,  v52,  "%{public}s called with null key, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v39 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
      os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v58 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint32_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
          _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null server", buf, 0xCu);
        }
      }

      else if (v58)
      {
        os_log_type_t v45 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint32_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        BOOL v47 = os_log_type_enabled(v41, type);
        if (v45)
        {
          if (v47)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v45;
            _os_log_impl( &dword_181A5C000,  v41,  v46,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v45);
LABEL_63:
          if (!v40) {
            goto LABEL_28;
          }
LABEL_64:
          free(v40);
          goto LABEL_28;
        }

        if (v47)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
          _os_log_impl(&dword_181A5C000, v41, v46, "%{public}s called with null server, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint32_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_server_set_listener_association_port";
          _os_log_impl( &dword_181A5C000,  v41,  v51,  "%{public}s called with null server, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_63;
  }

  if (a2 != 1) {
    goto LABEL_20;
  }
LABEL_9:
  uint64_t v10 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v10 + 81))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v15 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = *(void *)(v16 + 16);
      uint64_t v18 = *(void *)(v16 + 88);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_setup_outer_connection_group_block_invoke";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v17;
      *(_WORD *)&_BYTE buf[22] = 2112;
      uint64_t v61 = v5;
      LOWORD(v62) = 2112;
      *(void *)((char *)&v62 + 2) = v18;
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Failed UDP connection group with error %@ (for %@)",  buf,  0x2Au);
    }

    *(_BYTE *)(*(void *)(a1 + 32) + 81LL) = 1;
    id v11 = (id)_nw_http_response_create_well_known(500LL);
    __int16 v19 = nw_http_create_metadata_for_response(v11);
    id v20 = nw_content_context_create("response");
    nw_content_context_set_metadata_for_protocol(v20, (nw_protocol_metadata_t)v19);
    uint64_t v21 = *(void **)(a1 + 32);
    uint64_t v22 = *(nw_connection **)(v21[2] + 48LL);
    completion[0] = MEMORY[0x1895F87A8];
    completion[1] = 3221225472LL;
    completion[2] = ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke_312;
    completion[3] = &unk_189BC5E68;
    nw_endpoint_t v57 = v21;
    nw_connection_send(v22, 0LL, v20, 1, completion);

    goto LABEL_16;
  }

  if (!*(_BYTE *)(v10 + 82))
  {
    *(_BYTE *)(v10 + 82) = 1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = *(void *)(v12 + 16);
      __int16 v14 = *(void *(**)(uint64_t, uint64_t))(v12 + 88);
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_setup_outer_connection_group_block_invoke_2";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v13;
      *(_WORD *)&_BYTE buf[22] = 2112;
      uint64_t v61 = v14;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v11,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ Closed UDP connection group (for %@)",  buf,  0x20u);
    }

void sub_18204ED34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29)
{
  _Unwind_Resume(a1);
}

void ___ZL44nw_masque_listener_pair_read_outer_datagramsP34NWConcrete_nw_masque_listener_pair_block_invoke( uint64_t a1, void *a2, void *a3, int a4)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  id v7 = a2;
  uint64_t v8 = a3;
  if (v7)
  {
    id v9 = *(nw_connection_group **)(*(void *)(a1 + 32) + 24LL);
    BOOL v10 = !v9 || a4 == 0;
    if (!v10)
    {
      nw_endpoint_t v11 = nw_connection_group_copy_remote_endpoint_for_message(v9, v8);
      nw_endpoint_t v12 = v11;
      if (!v11 || (v13 = v11, int v14 = -[nw_endpoint type](v13, "type"), v13, v14 != 1))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v27 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 16LL);
          *(_DWORD *)buffer = 136446978;
          *(void *)&buffer[4] = "nw_masque_listener_pair_read_outer_datagrams_block_invoke";
          *(_WORD *)&buffer[12] = 2114;
          *(void *)&buffer[14] = v26;
          __int16 v53 = 2048;
          size_t size = dispatch_data_get_size(v7);
          __int16 v55 = 2112;
          nw_endpoint_t v56 = v12;
          _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Unable to proxy %zu bytes, invalid endpoint %@",  buffer,  0x2Au);
        }

        goto LABEL_28;
      }

      uint64_t address = nw_endpoint_get_address(v13);
      int sa_family = address->sa_family;
      if (sa_family != 2 && sa_family != 30)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v27 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          uint64_t v29 = *(void *)(*(void *)(a1 + 32) + 16LL);
          size_t v30 = dispatch_data_get_size(v7);
          int v31 = address->sa_family;
          *(_DWORD *)buffer = 136446978;
          *(void *)&buffer[4] = "nw_masque_listener_pair_read_outer_datagrams_block_invoke";
          *(_WORD *)&buffer[12] = 2114;
          *(void *)&buffer[14] = v29;
          __int16 v53 = 2048;
          size_t size = v30;
          __int16 v55 = 1024;
          LODWORD(v56) = v31;
          _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Unable to proxy %zu bytes, invalid address family %u",  buffer,  0x26u);
        }

void sub_18204F3A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL44nw_masque_listener_pair_read_outer_datagramsP34NWConcrete_nw_masque_listener_pair_block_invoke_315( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL matched = nw_masque_connection_pair_match_demux_pattern(a4, a5, *(void **)(a1 + 32));
  if (matched) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  return !matched;
}

void ___ZL44nw_masque_listener_pair_read_outer_datagramsP34NWConcrete_nw_masque_listener_pair_block_invoke_317( uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
      int v6 = 136446722;
      id v7 = "nw_masque_listener_pair_read_outer_datagrams_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received error sending to inner connection %@",  (uint8_t *)&v6,  0x20u);
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 96LL));
}

BOOL nw_masque_connection_pair_match_demux_pattern(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  int v6 = v5;
  BOOL v7 = 0LL;
  if (a1 && a2 && v5)
  {
    uint64_t v10 = 0LL;
    id v11 = &v10;
    uint64_t v12 = 0x2020000000LL;
    char v13 = 0;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = ___ZL45nw_masque_connection_pair_match_demux_patternPKhmPU33objcproto22OS_nw_protocol_options8NSObject_block_invoke;
    v9[3] = &unk_189BBB770;
    void v9[5] = a2;
    void v9[6] = a1;
    void v9[4] = &v10;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 0x40000000LL;
    v14[2] = __nw_demux_options_enumerate_patterns_block_invoke;
    v14[3] = &unk_189BB9D20;
    void v14[4] = v9;
    nw_protocol_options_access_handle(v5, v14);
    BOOL v7 = *((_BYTE *)v11 + 24) != 0;
    _Block_object_dispose(&v10, 8);
  }

  return v7;
}

uint64_t ___ZL45nw_masque_connection_pair_match_demux_patternPKhmPU33objcproto22OS_nw_protocol_options8NSObject_block_invoke( void *a1, unsigned int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  uint64_t v5 = a2;
  if (a2)
  {
    BOOL v7 = (unsigned __int8 *)a1[6];
    if (a5)
    {
      while (1)
      {
        int v9 = *v7++;
        int v8 = v9;
        int v11 = *a5++;
        int v10 = v11;
        int v12 = *a4++;
        int v13 = (v8 ^ v12) & v10;
        BOOL v14 = v13 != 0;
        if (v13) {
          break;
        }
        if (!--v5) {
          goto LABEL_7;
        }
      }
    }

    else
    {
      while (1)
      {
        int v17 = *v7++;
        int v16 = v17;
        int v18 = *a4++;
        BOOL v19 = v16 == v18;
        BOOL v14 = v16 != v18;
        if (!v19) {
          break;
        }
        if (!--v5) {
          goto LABEL_7;
        }
      }
    }

    char v15 = 0;
  }

  else
  {
LABEL_7:
    BOOL v14 = 0LL;
    char v15 = 1;
  }

  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = v15;
  return v14;
}

void ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke_312( uint64_t a1)
{
}

void ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke_314( uint64_t a1)
{
  unint64_t v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 32LL));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_masque_listener_pair_createP31NWConcrete_nw_masque_connection_block_invoke(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 40) + 83LL) = 0;
}

void ___ZL30nw_masque_listener_pair_createP31NWConcrete_nw_masque_connection_block_invoke_2( uint64_t a1, int a2)
{
  if ((a2 & 0xFFFFFFFE) == 4)
  {
    nw_dictionary_set_value(*(void *)(*(void *)(a1 + 32) + 64LL), (const char *)(*(void *)(a1 + 40) + 64LL), 0LL);
    nw_masque_listener_pair_cancel(*(NWConcrete_nw_masque_listener_pair **)(a1 + 40));
  }

void ___ZL49nw_masque_listener_pair_set_state_changed_handlerP34NWConcrete_nw_masque_listener_pairU13block_pointerFv21nw_connection_state_tPU22objcproto11OS_nw_error8NSObjectE_block_invoke( uint64_t a1)
{
  unint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 32);
  *(void *)(v3 + 32) = v2;
}

void nw_masque_listener_pair_cancel(NWConcrete_nw_masque_listener_pair *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  unint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (dispatch_group_s *)*((void *)v1 + 12);
    id v4 = *(dispatch_queue_s **)(*((void *)v1 + 2) + 32LL);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZL30nw_masque_listener_pair_cancelP34NWConcrete_nw_masque_listener_pair_block_invoke;
    block[3] = &unk_189BC93A0;
    BOOL v14 = v1;
    dispatch_group_notify(v3, v4, block);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  int v18 = "nw_masque_listener_pair_cancel";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v18 = "nw_masque_listener_pair_cancel";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          int v18 = "nw_masque_listener_pair_cancel";
          __int16 v19 = 2082;
          id v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        int v18 = "nw_masque_listener_pair_cancel";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v18 = "nw_masque_listener_pair_cancel";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void ___ZL30nw_masque_listener_pair_cancelP34NWConcrete_nw_masque_listener_pair_block_invoke(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(nw_connection **)(v2[2] + 48LL);
  if (v3)
  {
    nw_connection_cancel(v3);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 16LL);
    uint64_t v5 = *(void **)(v4 + 48);
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  int v6 = (nw_connection_group *)v2[3];
  if (v6)
  {
    nw_connection_group_cancel(v6);
    uint64_t v7 = *(void *)(a1 + 32);
    os_log_type_t v8 = *(void **)(v7 + 24);
    *(void *)(v7 + 24) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  int v9 = (nw_connection *)v2[6];
  if (v9)
  {
    nw_connection_cancel(v9);
    uint64_t v10 = *(void *)(a1 + 32);
    BOOL v11 = *(void **)(v10 + 48);
    *(void *)(v10 + 4_Block_object_dispose(va, 8) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  os_log_type_t v12 = (unsigned __int8 *)v2[7];
  if (v12)
  {
    nw_array_apply(v12, (uint64_t)&__block_literal_global_310);
    uint64_t v13 = *(void *)(a1 + 32);
    BOOL v14 = *(void **)(v13 + 56);
    *(void *)(v13 + 56) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  char v15 = (void *)v2[5];
  v2[5] = 0LL;
}

uint64_t ___ZL30nw_masque_listener_pair_cancelP34NWConcrete_nw_masque_listener_pair_block_invoke_2( int a1, int a2, nw_connection_t connection)
{
  return 1LL;
}

uint64_t ___ZL40nw_masque_connection_pair_handle_headersP36NWConcrete_nw_masque_connection_pairPU29objcproto18OS_nw_http_request8NSObject_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v107 = *MEMORY[0x1895F89C0];
  [NSString stringWithCString:a2 encoding:5];
  uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue();
  [NSString stringWithCString:a4 encoding:5];
  int v6 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v7 = (char *)*(id *)(a1 + 32);
  id v8 = v87;
  id v9 = v6;
  uint64_t v88 = v8;
  uint64_t v89 = v9;
  [NSString stringWithUTF8String:"Prohibit-Interface"];
  char v86 = (void *)objc_claimAutoreleasedReturnValue();
  if (!objc_msgSend(v8, "caseInsensitiveCompare:"))
  {
    unsigned __int16 v84 = v7;
    [v9 componentsSeparatedByString:@","];
    os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v41 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t v101 = 136446722;
      BOOL v102 = "nw_masque_connection_pair_handle_prohibit_interface_header";
      __int16 v103 = 2112;
      id v104 = v8;
      __int16 v105 = 2112;
      id v106 = v40;
      _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %@ : %@", v101, 0x20u);
    }

    __int128 v94 = 0u;
    __int128 v95 = 0u;
    *(_OWORD *)os_log_type_t type = 0u;
    __int128 v93 = 0u;
    id v42 = v40;
    uint64_t v43 = [v42 countByEnumeratingWithState:type objects:buf count:16];
    if (v43)
    {
      char v90 = v7 + 266;
      id v91 = v7 + 267;
      os_log_type_t v44 = v7 + 270;
      os_log_type_t v45 = v7 + 269;
      uint64_t v46 = *(void *)v93;
      do
      {
        for (uint64_t i = 0LL; i != v43; ++i)
        {
          if (*(void *)v93 != v46) {
            objc_enumerationMutation(v42);
          }
          uint64_t v48 = *(void **)(*(void *)&type[8] + 8 * i);
          int v49 = strcmp((const char *)[v48 UTF8String], "wifi");
          uint64_t v50 = v84 + 268;
          if (!v49) {
            goto LABEL_23;
          }
          int v51 = strcmp((const char *)[v48 UTF8String], "cellular");
          uint64_t v50 = v45;
          if (v51)
          {
            int v52 = strcmp((const char *)[v48 UTF8String], "wired");
            uint64_t v50 = v44;
            if (v52)
            {
              int v53 = strcmp((const char *)[v48 UTF8String], "expensive");
              uint64_t v50 = v91;
              if (v53)
              {
                int v54 = strcmp((const char *)[v48 UTF8String], "constrained");
                uint64_t v50 = v90;
                if (v54) {
                  continue;
                }
              }
            }
          }

void sub_182050BC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, id a31)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void ___ZL48nw_masque_connection_pair_setup_outer_connectionP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU29objcproto18OS_nw_http_requestS1__block_invoke( uint64_t a1)
{
  unint64_t v2 = _Block_copy(*(const void **)(*(void *)(*(void *)(a1 + 32) + 16LL) + 88LL));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL48nw_masque_connection_pair_setup_outer_connectionP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU29objcproto18OS_nw_http_requestS1__block_invoke_2( uint64_t a1)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = ___ZL48nw_masque_connection_pair_setup_outer_connectionP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU29objcproto18OS_nw_http_requestS1__block_invoke_3;
  v3[3] = &unk_189BBB680;
  unint64_t v2 = *(dispatch_queue_s **)(a1 + 64);
  id v4 = *(id *)(a1 + 72);
  id v5 = *(id *)(a1 + 32);
  char v7 = *(_BYTE *)(a1 + 96);
  id v6 = *(id *)(a1 + 40);
  dispatch_async(v2, v3);
}

void nw_masque_connection_pair_setup_outer_connection_inner(void *a1, void *a2, int a3, void *a4)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  char v7 = a1;
  id v8 = a2;
  id v9 = a4;
  uint64_t v10 = v9;
  if (!v7)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v48 = "nw_masque_connection_pair_setup_outer_connection_inner";
    id v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v48 = "nw_masque_connection_pair_setup_outer_connection_inner";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type;
      BOOL v34 = os_log_type_enabled(v28, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v48 = "nw_masque_connection_pair_setup_outer_connection_inner";
          __int16 v49 = 2082;
          uint64_t v50 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_69:
        if (!v27) {
          goto LABEL_35;
        }
LABEL_70:
        free(v27);
        goto LABEL_35;
      }

      if (v34)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v48 = "nw_masque_connection_pair_setup_outer_connection_inner";
        _os_log_impl(&dword_181A5C000, v28, v33, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v48 = "nw_masque_connection_pair_setup_outer_connection_inner";
        _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s called with null pair, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_182051580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL54nw_masque_connection_pair_setup_outer_connection_innerP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU27objcproto16OS_nw_parametersS1__block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v136 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    else {
      char v7 = off_189BB9C00[a2];
    }
    uint64_t v8 = *(void *)(a1 + 32);
    id v9 = *(void *(**)(uint64_t, uint64_t))(v8 + 48);
    uint64_t v10 = *(void *)(v8 + 16);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_setup_outer_connection_inner_block_invoke";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v10;
    *(_WORD *)&_BYTE buf[22] = 2112;
    uint64_t v126 = v9;
    *(_WORD *)__int16 v127 = 2080;
    *(void *)&v127[2] = v7;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ outer connection to %@ has transitioned to %s",  buf,  0x2Au);
  }

  [MEMORY[0x1896079D8] processInfo];
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  [v11 processName];
  BOOL v12 = (void *)objc_claimAutoreleasedReturnValue();
  if ((a2 & 0xFFFFFFFE) == 4)
  {
    uint64_t v13 = *(os_unfair_lock_s **)(a1 + 32);
    if (BYTE1(v13[54]._os_unfair_lock_opaque))
    {
      if (BYTE2(v13[54]._os_unfair_lock_opaque))
      {
LABEL_59:
        *(void *)int buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3032000000LL;
        uint64_t v126 = __Block_byref_object_copy__248;
        *(void *)__int16 v127 = __Block_byref_object_dispose__249;
        *(void *)&v127[8] = 0LL;
        aBlock[0] = MEMORY[0x1895F87A8];
        aBlock[1] = 3221225472LL;
        aBlock[2] = ___ZL54nw_masque_connection_pair_setup_outer_connection_innerP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU27objcproto16OS_nw_parametersS1__block_invoke_270;
        aBlock[3] = &unk_189BC9210;
        os_log_type_t v121 = buf;
        uint64_t v120 = v13;
        BOOL v60 = (void (**)(void))_Block_copy(aBlock);
        uint64_t v61 = v13 + 2;
        os_unfair_lock_lock(v61);
        v60[2](v60);
        os_unfair_lock_unlock(v61);

        uint64_t v62 = *(void *)(*(void *)&buf[8] + 40LL);
        if (v62) {
          (*(void (**)(uint64_t, uint64_t, id))(v62 + 16))(v62, a2, v5);
        }

        _Block_object_dispose(buf, 8);
        goto LABEL_62;
      }

      BYTE2(v13[54]._os_unfair_lock_opaque) = 1;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t well_known = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(well_known, OS_LOG_TYPE_INFO))
      {
        id v15 = "IP";
        int v16 = *(unsigned __int8 *)(a1 + 48);
        uint64_t v17 = *(void *)(a1 + 32);
        uint64_t v18 = *(void *)(a1 + 40);
        if (v16 == 6) {
          id v15 = "TCP";
        }
        uint64_t v19 = *(void *)(v17 + 16);
        if (v16 == 17) {
          id v15 = "UDP";
        }
        uint64_t v20 = *(void *)(v17 + 224);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_setup_outer_connection_inner_block_invoke_2";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v19;
        *(_WORD *)&_BYTE buf[22] = 2080;
        uint64_t v126 = (void *(*)(uint64_t, uint64_t))v15;
        *(_WORD *)__int16 v127 = 2112;
        *(void *)&v127[2] = v18;
        *(_WORD *)&v127[10] = 2112;
        *(void *)&v127[12] = v20;
        _os_log_impl( &dword_181A5C000,  well_known,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ Closed %s connection to %@ (for %@)\n",  buf,  0x34u);
      }

void sub_1820527CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_masque_connection_pair_read_outer_datagrams(NWConcrete_nw_masque_connection_pair *a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  unint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_masque_connection_pair_read_outer_datagrams";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v28 = "nw_masque_connection_pair_read_outer_datagrams";
          __int16 v29 = 2082;
          size_t v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v13,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v5) {
          goto LABEL_5;
        }
LABEL_56:
        free(v5);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl(&dword_181A5C000, v6, v13, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl(&dword_181A5C000, v6, v20, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

void sub_182053158( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_masque_connection_pair_read_outer(NWConcrete_nw_masque_connection_pair *a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  unint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_masque_connection_pair_read_outer";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v28 = "nw_masque_connection_pair_read_outer";
          __int16 v29 = 2082;
          size_t v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v13,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v5) {
          goto LABEL_5;
        }
LABEL_56:
        free(v5);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl(&dword_181A5C000, v6, v13, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl(&dword_181A5C000, v6, v20, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

void sub_18205387C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_masque_connection_pair_read_inner(NWConcrete_nw_masque_connection_pair *a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  unint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    uint64_t v28 = "nw_masque_connection_pair_read_inner";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v28 = "nw_masque_connection_pair_read_inner";
          __int16 v29 = 2082;
          size_t v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v13,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v5) {
          goto LABEL_5;
        }
LABEL_56:
        free(v5);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_181A5C000, v6, v13, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_181A5C000, v6, v20, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }

void sub_182053FA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke( uint64_t a1, void *a2, void *a3, BOOL a4, void *a5)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  os_log_type_t v9 = a2;
  uint64_t v10 = a3;
  id v11 = a5;
  BOOL v12 = v9;
  id v71 = v11;
  if (v9)
  {
    size_t size = dispatch_data_get_size(v9);
    if (!v10 || size) {
      goto LABEL_20;
    }
  }

  else if (!v10)
  {
    goto LABEL_20;
  }

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  BOOL v14 = (nw_protocol_definition *)(id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_metadata_t v15 = nw_content_context_copy_protocol_metadata(v10, v14);

  if (v15 && nw_http_metadata_is_capsule(v15))
  {
    capsule_os_log_type_t type = nw_http_metadata_get_capsule_type(v15);
    BOOL v17 = (dispatch_data_s *)nw_http_metadata_copy_capsule_data(v15);
    if (gLogDatapath)
    {
      __nwlog_obj();
      int v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v57 = *(void *)(*(void *)(a1 + 32) + 16LL);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_read_inner_block_invoke";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v57;
        *(_WORD *)&_BYTE buf[22] = 2048;
        unint64_t v83 = capsule_type;
        __int16 v84 = 2112;
        unsigned __int16 v85 = v17;
        _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received capsule type %llx with data %@",  buf,  0x2Au);
      }
    }

    if (capsule_type >> 1 == 8385024)
    {
      if (capsule_type == 16770049) {
        uint64_t v18 = 16770051LL;
      }
      else {
        uint64_t v18 = 16770050LL;
      }
      LOBYTE(__n) = 0;
      nw_dispatch_data_copyout_from_offset(v17, (uint64_t)&__n, 1LL, 0LL);
      memset(__src, 0, 20);
      nw_dispatch_data_copyout_from_offset(v17, (uint64_t)__src, __n, 1LL);
      id v19 = objc_alloc(MEMORY[0x189603F48]);
      os_log_type_t v20 = (void *)[v19 initWithBytes:__src length:__n];
      uint64_t v69 = v18;
      if (gLogDatapath)
      {
        __nwlog_obj();
        char v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v59 = *(void *)(*(void *)(a1 + 32) + 16LL);
          BOOL v60 = "target";
          if (capsule_type == 16770048) {
            BOOL v60 = "client";
          }
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_read_inner_block_invoke";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v59;
          *(_WORD *)&_BYTE buf[22] = 2082;
          unint64_t v83 = (unint64_t)v60;
          __int16 v84 = 2112;
          unsigned __int16 v85 = v20;
          _os_log_impl( &dword_181A5C000,  v58,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received %{public}s CID %@, acking",  buf,  0x2Au);
        }
      }

      size_t v21 = __n;
      uint64_t v22 = *(void *)(a1 + 32);
      if (capsule_type == 16770048)
      {
        *(_WORD *)(v22 + 72) = __n;
        memcpy((void *)(*(void *)(a1 + 32) + 74LL), __src, v21);
        BYTE2(v81) = 0;
        nw_dispatch_data_copyout_from_offset(v17, (uint64_t)&v81 + 2, 1LL, v21 + 1);
        memset(buf, 0, 20);
        nw_dispatch_data_copyout_from_offset(v17, (uint64_t)buf, BYTE2(v81), __n + 2LL);
        *(_WORD *)(*(void *)(a1 + 32) + 94LL) = BYTE2(v81);
        memcpy((void *)(*(void *)(a1 + 32) + 96LL), buf, *(unsigned __int16 *)(*(void *)(a1 + 32) + 94LL));
        if (v20) {
          int v23 = (void *)[v20 _createDispatchData];
        }
        else {
          int v23 = 0LL;
        }
      }

      else
      {
        *(_WORD *)(v22 + 136) = __n;
        memcpy((void *)(*(void *)(a1 + 32) + 138LL), __src, v21);
        if (gLogDatapath)
        {
          __nwlog_obj();
          int v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v64 = *(void *)(*(void *)(a1 + 32) + 16LL);
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_read_inner_block_invoke";
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v64;
            _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Setting up forwarded mode connections",  buf,  0x16u);
          }
        }

        if (nw_protocol_demux_copy_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
        }
        if (nw_protocol_demux_copy_definition::definition)
        {
          uint64_t v32 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
          nw_protocol_options_t options = nw_protocol_create_options(v32);
          if (v32) {
            os_release(v32);
          }
        }

        else
        {
          nw_protocol_options_t options = nw_protocol_create_options(0LL);
        }

        nw_demux_options_add_pattern( options,  1,  *(unsigned __int16 *)(*(void *)(a1 + 32) + 136LL),  *(void *)(a1 + 32) + 138LL,  0LL);
        nw_masque_connection_pair_setup_inner_direct_connections(*(void **)(a1 + 32), options);
        id v47 = objc_alloc_init(MEMORY[0x189603FB8]);
        [v47 appendBytes:&__n length:1];
        [v47 appendBytes:__src length:__n];
        [v47 appendBytes:&__n length:1];
        [v47 appendBytes:__src length:__n];
        buf[0] = 0;
        [v47 appendBytes:buf length:1];
        if (v47) {
          int v23 = (void *)[v47 _createDispatchData];
        }
        else {
          int v23 = 0LL;
        }
      }

      if (v23)
      {
        uint64_t v48 = nw_content_context_create("ack cid");
        metadata_for_capsule = nw_http_create_metadata_for_capsule(v69, v23);
        nw_content_context_set_metadata_for_protocol(v48, (nw_protocol_metadata_t)metadata_for_capsule);
        nw_connection_send( *(nw_connection_t *)(*(void *)(*(void *)(a1 + 32) + 16LL) + 48LL),  0LL,  v48,  1,  &__block_literal_global_24170);
      }
    }

    else if (capsule_type == 16770304)
    {
      if (nw_protocol_demux_copy_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
      }
      if (nw_protocol_demux_copy_definition::definition)
      {
        uint64_t v31 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
        id v70 = nw_protocol_create_options(v31);
        if (v31) {
          os_release(v31);
        }
      }

      else
      {
        id v70 = nw_protocol_create_options(0LL);
      }

      if (!*(void *)(*(void *)(a1 + 32) + 192LL))
      {
        BOOL v34 = nw_demux_create_options();
        uint64_t v35 = *(void *)(a1 + 32);
        int v36 = *(void **)(v35 + 192);
        *(void *)(v35 + 192) = v34;
      }

      size_t v37 = dispatch_data_get_size(v17);
      *(void *)int buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000LL;
      unint64_t v83 = 0LL;
      if (v37)
      {
        size_t v38 = v37;
        unint64_t v39 = 0LL;
        uint64_t v40 = MEMORY[0x1895F87A8];
        do
        {
          int v81 = 0;
          nw_dispatch_data_copyout_from_offset(v17, (uint64_t)&v81 + 2, 2LL, v39);
          uint64_t v43 = *(void *)(*(void *)&buf[8] + 24LL) + 2LL;
          *(void *)(*(void *)&buf[8] + 24LL) = v43;
          nw_dispatch_data_copyout_from_offset(v17, (uint64_t)&v81, 2LL, v43);
          *(void *)(*(void *)&buf[8] + 24LL) += 2LL;
          *(void *)size_t __src = 0LL;
          *(void *)&__src[8] = __src;
          *(void *)&__src[16] = 0x2020000000LL;
          uint64_t v89 = 0LL;
          v80[0] = v40;
          v80[1] = 3221225472LL;
          v80[2] = ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke_305;
          v80[3] = &unk_189BBB798;
          v80[4] = buf;
          v80[5] = __src;
          dispatch_data_apply(v17, v80);
          uint64_t v44 = *(void *)(*(void *)&buf[8] + 24LL) + HIWORD(v81);
          *(void *)(*(void *)&buf[8] + 24LL) = v44;
          char v79 = 0;
          nw_dispatch_data_copyout_from_offset(v17, (uint64_t)&v79, 1LL, v44);
          ++*(void *)(*(void *)&buf[8] + 24LL);
          size_t __n = 0LL;
          p_n = &__n;
          uint64_t v77 = 0x2020000000LL;
          uint64_t v78 = 0LL;
          if (v79)
          {
            applier[0] = v40;
            applier[1] = 3221225472LL;
            applier[2] = ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke_2;
            applier[3] = &unk_189BBB798;
            void applier[4] = buf;
            applier[5] = &__n;
            dispatch_data_apply(v17, applier);
            unsigned int v41 = HIWORD(v81);
            *(void *)(*(void *)&buf[8] + 24LL) += HIWORD(v81);
            uint64_t v42 = p_n[3];
          }

          else
          {
            uint64_t v42 = 0LL;
            unsigned int v41 = HIWORD(v81);
          }

          nw_demux_options_add_pattern( *(void **)(*(void *)(a1 + 32) + 192LL),  v81,  v41,  *(void *)(*(void *)&__src[8] + 24LL),  v42);
          nw_demux_options_add_pattern(v70, v81, HIWORD(v81), *(void *)(*(void *)&__src[8] + 24LL), p_n[3]);
          _Block_object_dispose(&__n, 8);
          _Block_object_dispose(__src, 8);
          unint64_t v39 = *(void *)(*(void *)&buf[8] + 24LL);
        }

        while (v39 < v38);
      }

      if (gLogDatapath)
      {
        __nwlog_obj();
        id v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v66 = *(void *)(*(void *)(a1 + 32) + 16LL);
          *(_DWORD *)size_t __src = 136446466;
          *(void *)&__src[4] = "nw_masque_connection_pair_read_inner_block_invoke_3";
          *(_WORD *)&__src[12] = 2114;
          *(void *)&__src[14] = v66;
          _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Setting up forwarded mode connections",  __src,  0x16u);
        }
      }

      nw_masque_connection_pair_setup_inner_direct_connections(*(void **)(a1 + 32), v70);
      if (gLogDatapath)
      {
        __nwlog_obj();
        id v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v68 = *(void *)(*(void *)(a1 + 32) + 16LL);
          *(_DWORD *)size_t __src = 136446466;
          *(void *)&__src[4] = "nw_masque_connection_pair_read_inner_block_invoke";
          *(_WORD *)&__src[12] = 2114;
          *(void *)&__src[14] = v68;
          _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received demux patterns, acking",  __src,  0x16u);
        }
      }

      BOOL v12 = v9;
      char v45 = nw_content_context_create("ack pattern");
      uint64_t v46 = nw_http_create_metadata_for_capsule(16770305LL, v17);
      nw_content_context_set_metadata_for_protocol(v45, (nw_protocol_metadata_t)v46);
      nw_connection_send( *(nw_connection_t *)(*(void *)(*(void *)(a1 + 32) + 16LL) + 48LL),  0LL,  v45,  1,  &__block_literal_global_24170);

      _Block_object_dispose(buf, 8);
    }

    nw_masque_connection_pair_read_inner(*(NWConcrete_nw_masque_connection_pair **)(a1 + 32));

    goto LABEL_76;
  }

LABEL_20:
  if (*(void *)(*(void *)(a1 + 32) + 48LL))
  {
    if (!v71 || (v24 = v71, int v25 = v24[3], v24, v25 == 40))
    {
      BOOL v26 = 0;
      uint64_t v27 = (nw_content_context *)&__block_literal_global_41831;
      if (!v10 || !a4) {
        goto LABEL_70;
      }
      uint64_t v28 = v10;
      if (v28 != (nw_content_context *)&__block_literal_global_41831
        && v28 != (nw_content_context *)&__block_literal_global_5_41854)
      {
        if (v28 == (nw_content_context *)&__block_literal_global_3_41839
          || v28 == (nw_content_context *)&__block_literal_global_4)
        {
        }

        else
        {
          char v29 = *((_BYTE *)v28 + 118);

          if ((v29 & 1) == 0)
          {
LABEL_30:
            BOOL v26 = 0;
LABEL_70:
            if (gLogDatapath)
            {
              __nwlog_obj();
              id v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
              {
                int v53 = v10;
                uint64_t v54 = *(void *)(*(void *)(a1 + 32) + 16LL);
                if (v12) {
                  size_t v55 = dispatch_data_get_size(v12);
                }
                else {
                  size_t v55 = 0LL;
                }
                uint64_t v61 = "";
                *(_DWORD *)int buf = 136447234;
                uint64_t v62 = ", complete";
                *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_read_inner_block_invoke";
                if (!a4) {
                  uint64_t v62 = "";
                }
                *(_WORD *)&buf[12] = 2114;
                *(void *)&buf[14] = v54;
                *(_WORD *)&_BYTE buf[22] = 2048;
                unint64_t v83 = v55;
                __int16 v84 = 2080;
                if (v26) {
                  uint64_t v61 = ", final";
                }
                unsigned __int16 v85 = (void *)v62;
                __int16 v86 = 2080;
                uint64_t v87 = v61;
                _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying %zu bytes to target%s%s",  buf,  0x34u);
                uint64_t v10 = v53;
              }
            }

            dispatch_group_enter(*(dispatch_group_t *)(*(void *)(a1 + 32) + 232LL));
            uint64_t v50 = *(void **)(a1 + 32);
            int v51 = (nw_connection *)v50[6];
            if (v26) {
              uint64_t v27 = (nw_content_context *)&__block_literal_global_3_41839;
            }
            completion[0] = MEMORY[0x1895F87A8];
            completion[1] = 3221225472LL;
            completion[2] = ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke_308;
            completion[3] = &unk_189BC5E68;
            os_log_type_t v73 = v50;
            nw_connection_send(v51, v12, v27, a4, completion);
            if (!v26) {
              nw_masque_connection_pair_read_inner(*(NWConcrete_nw_masque_connection_pair **)(a1 + 32));
            }
            nw_protocol_metadata_t v15 = v73;
            goto LABEL_76;
          }
        }

        BOOL v26 = *(_BYTE *)(*(void *)(a1 + 32) + 219LL) == 0;
        goto LABEL_70;
      }

      goto LABEL_30;
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  nw_protocol_metadata_t v15 = (nw_protocol_metadata_t)(id)gLogObj;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    uint64_t v30 = *(void *)(*(void *)(a1 + 32) + 16LL);
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_read_inner_block_invoke";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v30;
    *(_WORD *)&_BYTE buf[22] = 2112;
    unint64_t v83 = (unint64_t)v71;
    _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Stopping reading, error %@",  buf,  0x20u);
  }

void sub_182054BE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke_305( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (a5 + a3 >= v5) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4 + v5 - a3;
  }
  return a5 + a3 < v5;
}

BOOL ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (a5 + a3 >= v5) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4 + v5 - a3;
  }
  return a5 + a3 < v5;
}

void ___ZL36nw_masque_connection_pair_read_innerP36NWConcrete_nw_masque_connection_pair_block_invoke_308( uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
      int v6 = 136446722;
      os_log_type_t v7 = "nw_masque_connection_pair_read_inner_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received error sending to outer connection %@",  (uint8_t *)&v6,  0x20u);
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 232LL));
}

void ___ZL36nw_masque_connection_pair_read_outerP36NWConcrete_nw_masque_connection_pair_block_invoke( uint64_t a1, void *a2, void *a3, BOOL a4, void *a5)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a2;
  id v10 = a3;
  id v11 = a5;
  uint64_t v12 = v11;
  os_log_type_t v13 = *(void **)(a1 + 32);
  if (*(void *)(v13[2] + 48LL))
  {
    if (v13[6])
    {
      if (v13[7])
      {
        if (!v11 || (BOOL v14 = v11, v15 = v14[3], v14, v15 == 40))
        {
          if (v10 && a4)
          {
            os_log_type_t v16 = v10;
            if (v16 != (_BYTE *)&__block_literal_global_41831 && v16 != (_BYTE *)&__block_literal_global_5_41854)
            {
              if (v16 == (_BYTE *)&__block_literal_global_3_41839 || v16 == (_BYTE *)&__block_literal_global_4)
              {

                uint64_t v18 = *(void *)(a1 + 32);
              }

              else
              {
                char v17 = v16[118];

                uint64_t v18 = *(void *)(a1 + 32);
                if ((v17 & 1) == 0)
                {
                  BOOL v19 = 0;
                  if (!*(void *)(v18 + 32)) {
                    goto LABEL_25;
                  }
                  unsigned int v22 = *(unsigned __int16 *)(v18 + 72);
                  if (!v22) {
                    goto LABEL_25;
                  }
LABEL_20:
                  if (gLogDatapath)
                  {
                    __nwlog_obj();
                    size_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v39 = *(void *)(*(void *)(a1 + 32) + 16LL);
                      *(_DWORD *)int buf = 136446722;
                      int v49 = "nw_masque_connection_pair_read_outer_block_invoke";
                      __int16 v50 = 2114;
                      uint64_t v51 = v39;
                      __int16 v52 = 2112;
                      size_t v53 = (size_t)v9;
                      _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received content %@",  buf,  0x20u);
                    }

                    unsigned int v22 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 72LL);
                  }

                  __s1[0] = 0LL;
                  __s1[1] = 0LL;
                  int v61 = 0;
                  size_t v23 = nw_dispatch_data_copyout_from_offset(v9, (uint64_t)__s1, v22, 1LL);
                  uint64_t v24 = *(unsigned __int16 **)(a1 + 32);
                  if (v23 == v24[36] && (size_t v25 = v23, !memcmp(__s1, v24 + 37, v23)))
                  {
                    if (v25 == v24[47])
                    {
                      size_t size = dispatch_data_get_size(v9);
                      uint64_t v47 = 0LL;
                      alloc = (void *)dispatch_data_create_alloc();
                      nw_dispatch_data_copyout(v9, 0LL, size);
                      memcpy((void *)1, (const void *)(*(void *)(a1 + 32) + 96LL), v25);
                      BOOL v34 = alloc;

                      if (gLogDatapath)
                      {
                        __nwlog_obj();
                        uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
                        {
                          uint64_t v44 = *(void *)(*(void *)(a1 + 32) + 16LL);
                          *(_DWORD *)int buf = 136446466;
                          int v49 = "nw_masque_connection_pair_read_outer_block_invoke";
                          __int16 v50 = 2114;
                          uint64_t v51 = v44;
                          _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Replaced with Virtual Client CID before proxying",  buf,  0x16u);
                        }
                      }

                      int v26 = 1;
                      uint64_t v9 = v34;
                    }

                    else
                    {
                      int v26 = 1;
                    }
                  }

                  else
                  {
LABEL_25:
                    int v26 = 0;
                  }

                  if (gLogDatapath)
                  {
                    __nwlog_obj();
                    uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v36 = *(void *)(*(void *)(a1 + 32) + 16LL);
                      if (v9) {
                        size_t v37 = dispatch_data_get_size(v9);
                      }
                      else {
                        size_t v37 = 0LL;
                      }
                      uint64_t v40 = "";
                      *(_DWORD *)int buf = 136447490;
                      unsigned int v41 = " directly";
                      int v49 = "nw_masque_connection_pair_read_outer_block_invoke";
                      if (!v26) {
                        unsigned int v41 = "";
                      }
                      __int16 v50 = 2114;
                      uint64_t v51 = v36;
                      uint64_t v42 = ", complete";
                      if (!a4) {
                        uint64_t v42 = "";
                      }
                      __int16 v52 = 2048;
                      size_t v53 = v37;
                      __int16 v54 = 2080;
                      size_t v55 = v41;
                      __int16 v56 = 2080;
                      if (v19) {
                        uint64_t v40 = ", final";
                      }
                      uint64_t v57 = v42;
                      __int16 v58 = 2080;
                      uint64_t v59 = v40;
                      _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying %zu bytes%s to client%s%s",  buf,  0x3Eu);
                    }
                  }

                  dispatch_group_enter(*(dispatch_group_t *)(*(void *)(a1 + 32) + 232LL));
                  uint64_t v27 = *(void *)(a1 + 32);
                  if (v26) {
                    uint64_t v28 = (nw_connection **)(v27 + 32);
                  }
                  else {
                    uint64_t v28 = (nw_connection **)(*(void *)(v27 + 16) + 48LL);
                  }
                  char v29 = *v28;
                  if (*(_BYTE *)(v27 + 219)) {
                    uint64_t v30 = &_nw_content_context_default_message;
                  }
                  else {
                    uint64_t v30 = (const nw_content_context_t *)(v27 + 56);
                  }
                  uint64_t v31 = *v30;
                  v45[0] = MEMORY[0x1895F87A8];
                  v45[1] = 3221225472LL;
                  v45[2] = ___ZL36nw_masque_connection_pair_read_outerP36NWConcrete_nw_masque_connection_pair_block_invoke_300;
                  v45[3] = &unk_189BC5E68;
                  uint64_t v46 = (os_log_s *)(id)v27;
                  nw_connection_send(v29, v9, v31, a4, v45);
                  if (!v19) {
                    nw_masque_connection_pair_read_outer(*(NWConcrete_nw_masque_connection_pair **)(a1 + 32));
                  }
                  os_log_type_t v20 = v46;
                  goto LABEL_36;
                }
              }

              BOOL v19 = *(_BYTE *)(v18 + 219) == 0;
              goto LABEL_20;
            }
          }

          BOOL v19 = 0;
          uint64_t v18 = *(void *)(a1 + 32);
          goto LABEL_20;
        }
      }
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v20 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 16LL);
    *(_DWORD *)int buf = 136446722;
    int v49 = "nw_masque_connection_pair_read_outer_block_invoke";
    __int16 v50 = 2114;
    uint64_t v51 = v21;
    __int16 v52 = 2112;
    size_t v53 = (size_t)v12;
    _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Stopping reading, error %@",  buf,  0x20u);
  }

void sub_1820553C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_masque_connection_pair_read_outerP36NWConcrete_nw_masque_connection_pair_block_invoke_300( uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
      int v6 = 136446722;
      os_log_type_t v7 = "nw_masque_connection_pair_read_outer_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received error sending to inner connection %@",  (uint8_t *)&v6,  0x20u);
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 232LL));
}

void ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke( uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  int v6 = *(void **)(a1 + 32);
  os_log_type_t v7 = (nw_connection *)v6[6];
  if (v7 && (a4 == 40 || !a4))
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 16LL);
        *(_DWORD *)int buf = 136446722;
        uint64_t v21 = "nw_masque_connection_pair_read_outer_datagrams_block_invoke";
        __int16 v22 = 2114;
        uint64_t v23 = v15;
        __int16 v24 = 1024;
        int v25 = a3;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying batch of %u packets to client",  buf,  0x1Cu);
      }

      int v6 = *(void **)(a1 + 32);
      os_log_type_t v7 = (nw_connection *)v6[6];
    }

    batch_block[0] = MEMORY[0x1895F87A8];
    batch_block[1] = 3221225472LL;
    batch_block[2] = ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_291;
    batch_block[3] = &unk_189BBB720;
    int v19 = a3;
    uint64_t v18 = a2;
    char v17 = v6;
    nw_connection_batch(v7, batch_block);
    nw_masque_connection_pair_read_outer_datagrams(*(NWConcrete_nw_masque_connection_pair **)(a1 + 32));
    __int16 v10 = v17;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(v11 + 16);
      uint64_t v13 = *(void *)(v11 + 48);
      *(_DWORD *)int buf = 136446978;
      uint64_t v21 = "nw_masque_connection_pair_read_outer_datagrams_block_invoke";
      __int16 v22 = 2114;
      uint64_t v23 = v12;
      __int16 v24 = 1024;
      int v25 = a4;
      __int16 v26 = 2112;
      uint64_t v27 = v13;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Stopping reading, error %d, outer %@",  buf,  0x26u);
    }
  }
}

void sub_18205570C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_291( uint64_t a1)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 48))
  {
    unint64_t v2 = 0LL;
    uint64_t v3 = MEMORY[0x1895F87A8];
    do
    {
      id v4 = (dispatch_data_s *)*(id *)(*(void *)(a1 + 40) + 8 * v2);
      uint64_t v30 = 0LL;
      uint64_t v31 = &v30;
      uint64_t v32 = 0x2020000000LL;
      char v33 = 0;
      uint64_t v5 = *(void *)(a1 + 32);
      if (*(void *)(v5 + 32))
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 16LL);
            *(_DWORD *)applier = 136446722;
            *(void *)&void applier[4] = "nw_masque_connection_pair_read_outer_datagrams_block_invoke";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v13;
            *(_WORD *)&applier[22] = 2112;
            uint64_t v39 = v4;
            _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received content %@",  applier,  0x20u);
          }

          uint64_t v5 = *(void *)(a1 + 32);
          uint64_t v6 = *(unsigned __int16 *)(v5 + 72);
          if (!*(_WORD *)(v5 + 72))
          {
LABEL_17:
            if (*(void *)(v5 + 192))
            {
              v26[0] = v3;
              v26[1] = 3221225472LL;
              void v26[2] = ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_292;
              v26[3] = &unk_189BBB6F8;
              id v27 = (id)v5;
              uint64_t v28 = &v30;
              dispatch_data_apply(v4, v26);
            }

            goto LABEL_19;
          }
        }

        else
        {
          uint64_t v6 = *(unsigned __int16 *)(v5 + 72);
          if (!*(_WORD *)(v5 + 72)) {
            goto LABEL_17;
          }
        }

        __s1[0] = 0LL;
        __s1[1] = 0LL;
        int v37 = 0;
        size_t v7 = nw_dispatch_data_copyout_from_offset(v4, (uint64_t)__s1, v6, 1LL);
        uint64_t v8 = *(void *)(a1 + 32);
        if (v7 == *(unsigned __int16 *)(v8 + 72))
        {
          size_t v9 = v7;
          if (!memcmp(__s1, (const void *)(v8 + 74), v7))
          {
            *((_BYTE *)v31 + 24) = 1;
            if (v9 == *(unsigned __int16 *)(*(void *)(a1 + 32) + 94LL))
            {
              size_t size = dispatch_data_get_size(v4);
              uint64_t v29 = 0LL;
              alloc = (void *)dispatch_data_create_alloc();
              v35[0] = 0LL;
              v35[1] = v35;
              v35[2] = 0x2000000000LL;
              v35[3] = 0LL;
              v34[0] = 0LL;
              v34[1] = v34;
              v34[2] = 0x2000000000LL;
              v34[3] = v29;
              if (v4)
              {
                *(void *)applier = v3;
                *(void *)&void applier[8] = 0x40000000LL;
                *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
                uint64_t v39 = &unk_189BBF598;
                *((void *)&v40 + 1) = v34;
                size_t v41 = size;
                *(void *)&__int128 v40 = v35;
                dispatch_data_apply(v4, applier);
              }

              _Block_object_dispose(v34, 8);
              _Block_object_dispose(v35, 8);
              memcpy((void *)(v29 + 1), (const void *)(*(void *)(a1 + 32) + 96LL), v9);
              uint64_t v11 = alloc;

              if (gLogDatapath)
              {
                __nwlog_obj();
                uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 16LL);
                  *(_DWORD *)applier = 136446466;
                  *(void *)&void applier[4] = "nw_masque_connection_pair_read_outer_datagrams_block_invoke";
                  *(_WORD *)&applier[12] = 2114;
                  *(void *)&applier[14] = v22;
                  _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Replaced with Virtual Client CID before proxying",  applier,  0x16u);
                }
              }

              id v4 = v11;
            }
          }
        }
      }

void sub_182055C18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_292( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL matched = nw_masque_connection_pair_match_demux_pattern(a4, a5, *(void **)(*(void *)(a1 + 32) + 192LL));
  if (matched) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  return !matched;
}

void ___ZL46nw_masque_connection_pair_read_outer_datagramsP36NWConcrete_nw_masque_connection_pair_block_invoke_295( uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 16LL);
      int v6 = 136446722;
      size_t v7 = "nw_masque_connection_pair_read_outer_datagrams_block_invoke";
      __int16 v8 = 2114;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received error sending to inner connection %@",  (uint8_t *)&v6,  0x20u);
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 232LL));
}

void ___ZL54nw_masque_connection_pair_setup_outer_connection_innerP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU27objcproto16OS_nw_parametersS1__block_invoke_268( uint64_t a1)
{
}

void ___ZL54nw_masque_connection_pair_setup_outer_connection_innerP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU27objcproto16OS_nw_parametersS1__block_invoke_270( uint64_t a1)
{
  unint64_t v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 64LL));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

uint64_t ___ZL54nw_masque_connection_pair_setup_outer_connection_innerP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU27objcproto16OS_nw_parametersS1__block_invoke_280( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = [v3 length];
  uint64_t v5 = ",";
  if (!v4) {
    uint64_t v5 = "";
  }
  objc_msgSend(v3, "appendFormat:", @"%s%s", v5, a2);
  return 1LL;
}

void ___ZL45nw_masque_connection_pair_start_waiting_timerP36NWConcrete_nw_masque_connection_pair_block_invoke( uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 136446722;
    int v6 = "nw_masque_connection_pair_start_waiting_timer_block_invoke";
    __int16 v7 = 2114;
    uint64_t v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ wait timer fired for outer connection %@",  (uint8_t *)&v5,  0x20u);
  }

  nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
}

void ___ZL48nw_masque_connection_pair_setup_outer_connectionP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU29objcproto18OS_nw_http_requestS1__block_invoke_3( uint64_t a1)
{
}

void ___ZL32nw_masque_connection_pair_createP31NWConcrete_nw_masque_connection_block_invoke(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 40) + 220LL) = 0;
}

void ___ZL32nw_masque_connection_pair_createP31NWConcrete_nw_masque_connection_block_invoke_2( uint64_t a1, int a2)
{
  if ((a2 & 0xFFFFFFFE) == 4)
  {
    nw_dictionary_set_value(*(void *)(*(void *)(a1 + 32) + 56LL), (const char *)(*(void *)(a1 + 40) + 200LL), 0LL);
    nw_masque_connection_pair_cancel(*(NWConcrete_nw_masque_connection_pair **)(a1 + 40));
  }

void ___ZL51nw_masque_connection_pair_set_state_changed_handlerP36NWConcrete_nw_masque_connection_pairU13block_pointerFv21nw_connection_state_tPU22objcproto11OS_nw_error8NSObjectE_block_invoke( uint64_t a1)
{
  unint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 64);
  *(void *)(v3 + 64) = v2;
}

void nw_masque_connection_pair_cancel(NWConcrete_nw_masque_connection_pair *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  unint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (dispatch_group_s *)*((void *)v1 + 29);
    uint64_t v4 = *(dispatch_queue_s **)(*((void *)v1 + 2) + 32LL);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZL32nw_masque_connection_pair_cancelP36NWConcrete_nw_masque_connection_pair_block_invoke;
    block[3] = &unk_189BC93A0;
    BOOL v14 = v1;
    dispatch_group_notify(v3, v4, block);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  uint64_t v18 = "nw_masque_connection_pair_cancel";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_masque_connection_pair_cancel";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null pair", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v18 = "nw_masque_connection_pair_cancel";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_masque_connection_pair_cancel";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null pair, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "nw_masque_connection_pair_cancel";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null pair, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void ___ZL32nw_masque_connection_pair_cancelP36NWConcrete_nw_masque_connection_pair_block_invoke(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(nw_connection **)(v2[2] + 48LL);
  if (v3)
  {
    nw_connection_cancel(v3);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 16LL);
    int v5 = *(void **)(v4 + 48);
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  int v6 = (nw_connection *)v2[3];
  if (v6)
  {
    nw_connection_cancel(v6);
    uint64_t v7 = *(void *)(a1 + 32);
    os_log_type_t v8 = *(void **)(v7 + 24);
    *(void *)(v7 + 24) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  __int16 v9 = (nw_connection *)v2[4];
  if (v9)
  {
    nw_connection_cancel(v9);
    uint64_t v10 = *(void *)(a1 + 32);
    BOOL v11 = *(void **)(v10 + 32);
    *(void *)(v10 + 32) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  os_log_type_t v12 = (unsigned __int8 *)v2[5];
  if (v12)
  {
    nw_array_apply(v12, (uint64_t)&__block_literal_global_247);
    uint64_t v13 = *(void *)(a1 + 32);
    BOOL v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  char v15 = (nw_connection *)v2[6];
  if (v15)
  {
    nw_connection_cancel(v15);
    uint64_t v16 = *(void *)(a1 + 32);
    char v17 = *(void **)(v16 + 48);
    *(void *)(v16 + 4_Block_object_dispose(va, 8) = 0LL;

    unint64_t v2 = *(void **)(a1 + 32);
  }

  uint64_t v18 = (void *)v2[24];
  v2[24] = 0LL;

  uint64_t v19 = *(void *)(a1 + 32);
  os_log_type_t v20 = *(void **)(v19 + 56);
  *(void *)(v19 + 56) = 0LL;

  uint64_t v21 = *(void *)(a1 + 32);
  uint64_t v22 = *(void **)(v21 + 64);
  *(void *)(v21 + 64) = 0LL;
}

uint64_t ___ZL32nw_masque_connection_pair_cancelP36NWConcrete_nw_masque_connection_pair_block_invoke_2( int a1, int a2, nw_connection_t connection)
{
  return 1LL;
}

uint64_t ___ZL36nw_masque_connection_cancel_on_queueP31NWConcrete_nw_masque_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke_2( int a1, int a2, NWConcrete_nw_masque_listener_pair *a3)
{
  return 1LL;
}

uint64_t ___ZL36nw_masque_connection_cancel_on_queueP31NWConcrete_nw_masque_connectionPU22objcproto11OS_nw_error8NSObject_block_invoke( int a1, int a2, NWConcrete_nw_masque_connection_pair *a3)
{
  return 1LL;
}

void __nw_masque_connection_set_cancel_handler_block_invoke(uint64_t a1)
{
  unint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 104);
  *(void *)(v3 + 104) = v2;
}

void __nw_masque_connection_cancel_block_invoke(uint64_t a1)
{
}

uint64_t __nw_masque_connection_set_group_identifier_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 16LL) = *(void *)(result + 40);
  return result;
}

BOOL nw_protocol_http_client_create(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  int v5 = (char *)calloc(1uLL, 0x250uLL);
  if (v5)
  {
LABEL_2:
    bzero(v5, 0x250uLL);
    if (gLogDatapath)
    {
      char v15 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446722;
        id v27 = "nw_protocol_http_client_create";
        __int16 v28 = 2082;
        uint64_t v29 = (uint64_t)(v5 + 114);
        __int16 v30 = 2080;
        uint64_t v31 = (uint64_t)" ";
        _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }

    if (nw_protocol_http_client_identifier::onceToken[0] != -1) {
      dispatch_once(nw_protocol_http_client_identifier::onceToken, &__block_literal_global_29737);
    }
    *((void *)v5 + 2) = &nw_protocol_http_client_identifier::protocol_identifier;
    *((void *)v5 + 3) = &nw_protocol_http_client_get_callbacks(void)::protocol_callbacks;
    *((void *)v5 + 5) = v5;
    id v6 = nw_parameters_copy_context(a4);
    char v7 = v5[568];
    if ((v7 & 1) != 0)
    {
      os_log_type_t v8 = (void *)*((void *)v5 + 70);
      if (v8)
      {
        os_release(v8);
        char v7 = v5[568];
      }
    }

    *((void *)v5 + 25) = 0LL;
    *((void *)v5 + 70) = v6;
    v5[568] = v7 | 1;
    *((void *)v5 + 9) = v5 + 200;
    *((void *)v5 + 26) = v5 + 200;
    *((void *)v5 + 27) = 0LL;
    *((void *)v5 + 2_Block_object_dispose(va, 8) = v5 + 216;
    *((void *)v5 + 29) = 0LL;
    *((void *)v5 + 30) = v5 + 232;
    v5[340] = 2;
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
    }
    id v9 = (id)nw_protocol_copy_http_definition_http_definition;
    nw_protocol_plugin_metadata_set_callbacks( (uint64_t)v5,  v9,  (uint64_t)nw_protocol_http_client_create::$_0::__invoke,  (uint64_t)nw_protocol_http_client_create::$_1::__invoke);
    if (v9) {
      os_release(v9);
    }
    uint64_t v10 = *((void *)v5 + 5);
    if (v10)
    {
      uint64_t v11 = *(void *)(v10 + 72);
      if (v11)
      {
        *(void *)(v11 + 112) = nw_protocol_http_client_report_transfer_size;
LABEL_17:
        *((void *)v5 + 11) = v5 + 344;
        nw_protocol_plugin_retry_set_callbacks( (uint64_t)v5,  (uint64_t)nw_protocol_http_client_create::$_2::__invoke,  (uint64_t)nw_protocol_http_client_create::$_3::__invoke,  (uint64_t)nw_protocol_http_client_create::$_4::__invoke,  (uint64_t)nw_protocol_http_client_create::$_5::__invoke);
        *((void *)v5 + _Block_object_dispose(va, 8) = v5 + 104;
        nw_protocol_plugin_name_set_callbacks((uint64_t)v5, (uint64_t)nw_protocol_http_client_create::$_6::__invoke);
        return (BOOL)v5;
      }

      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      id v27 = "nw_protocol_plugin_metadata_set_size_callback";
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v24 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v17 = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_plugin_metadata_set_size_callback";
        uint64_t v19 = "%{public}s called with null metadata_plugin";
        goto LABEL_49;
      }

      if (!v24)
      {
        char v17 = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_plugin_metadata_set_size_callback";
        uint64_t v19 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
        goto LABEL_49;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v23 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          id v27 = "nw_protocol_plugin_metadata_set_size_callback";
          __int16 v28 = 2082;
          uint64_t v29 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v16) {
          goto LABEL_17;
        }
        goto LABEL_51;
      }

      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_plugin_metadata_set_size_callback";
        uint64_t v19 = "%{public}s called with null metadata_plugin, no backtrace";
LABEL_49:
        _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      id v27 = "nw_protocol_plugin_metadata_set_size_callback";
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v24 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v17 = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_plugin_metadata_set_size_callback";
        uint64_t v19 = "%{public}s called with null protocol->handle";
        goto LABEL_49;
      }

      if (!v24)
      {
        char v17 = (os_log_s *)__nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_plugin_metadata_set_size_callback";
        uint64_t v19 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_49;
      }

      os_log_type_t v20 = (char *)__nw_create_backtrace_string();
      char v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (!v20)
      {
        if (!v21) {
          goto LABEL_50;
        }
        *(_DWORD *)int buf = 136446210;
        id v27 = "nw_protocol_plugin_metadata_set_size_callback";
        uint64_t v19 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_49;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        id v27 = "nw_protocol_plugin_metadata_set_size_callback";
        __int16 v28 = 2082;
        uint64_t v29 = (uint64_t)v20;
        _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null protocol->handle, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v20);
    }

void nw_protocol_http_client_create::$_0::__invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v25 = "operator()";
    id v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)int buf = 136446466;
          int v25 = "operator()";
          __int16 v26 = 2082;
          id v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_78:
        if (!v9) {
          return;
        }
        goto LABEL_79;
      }

      if (!v15) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_77;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v25 = "operator()";
    id v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        uint64_t v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_78;
        }
        *(_DWORD *)int buf = 136446210;
        int v25 = "operator()";
        os_log_type_t v12 = "%{public}s called with null http_client, backtrace limit exceeded";
        goto LABEL_77;
      }

      uint64_t v16 = (char *)__nw_create_backtrace_string();
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v17 = os_log_type_enabled(v10, type);
      if (!v16)
      {
        if (!v17) {
          goto LABEL_78;
        }
        *(_DWORD *)int buf = 136446210;
        int v25 = "operator()";
        os_log_type_t v12 = "%{public}s called with null http_client, no backtrace";
        goto LABEL_77;
      }

      if (!v17) {
        goto LABEL_55;
      }
      *(_DWORD *)int buf = 136446466;
      int v25 = "operator()";
      __int16 v26 = 2082;
      id v27 = v16;
      os_log_type_t v18 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
      goto LABEL_54;
    }

    uint64_t v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_78;
    }
    *(_DWORD *)int buf = 136446210;
    int v25 = "operator()";
    os_log_type_t v12 = "%{public}s called with null http_client";
LABEL_77:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_78;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v25 = "operator()";
    id v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        uint64_t v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_78;
        }
        *(_DWORD *)int buf = 136446210;
        int v25 = "operator()";
        os_log_type_t v12 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_77;
      }

      uint64_t v16 = (char *)__nw_create_backtrace_string();
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v19 = os_log_type_enabled(v10, type);
      if (!v16)
      {
        if (!v19) {
          goto LABEL_78;
        }
        *(_DWORD *)int buf = 136446210;
        int v25 = "operator()";
        os_log_type_t v12 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_77;
      }

      if (!v19) {
        goto LABEL_55;
      }
      *(_DWORD *)int buf = 136446466;
      int v25 = "operator()";
      __int16 v26 = 2082;
      id v27 = v16;
      os_log_type_t v18 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_54;
    }

    uint64_t v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_78;
    }
    *(_DWORD *)int buf = 136446210;
    int v25 = "operator()";
    os_log_type_t v12 = "%{public}s called with null other_protocol";
    goto LABEL_77;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v25 = "operator()";
    id v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null metadata";
      goto LABEL_77;
    }

    if (!v22)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_77;
    }

    uint64_t v16 = (char *)__nw_create_backtrace_string();
    uint64_t v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v20 = os_log_type_enabled(v10, type);
    if (!v16)
    {
      if (!v20) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_77;
    }

    if (!v20) {
      goto LABEL_55;
    }
    *(_DWORD *)int buf = 136446466;
    int v25 = "operator()";
    __int16 v26 = 2082;
    id v27 = v16;
    os_log_type_t v18 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_54:
    _os_log_impl(&dword_181A5C000, v10, v11, v18, buf, 0x16u);
    goto LABEL_55;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v25 = "operator()";
    id v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null completion";
      goto LABEL_77;
    }

    if (!v22)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_77;
    }

    uint64_t v16 = (char *)__nw_create_backtrace_string();
    uint64_t v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    BOOL v21 = os_log_type_enabled(v10, type);
    if (!v16)
    {
      if (!v21) {
        goto LABEL_78;
      }
      *(_DWORD *)int buf = 136446210;
      int v25 = "operator()";
      os_log_type_t v12 = "%{public}s called with null completion, no backtrace";
      goto LABEL_77;
    }

    if (v21)
    {
      *(_DWORD *)int buf = 136446466;
      int v25 = "operator()";
      __int16 v26 = 2082;
      id v27 = v16;
      os_log_type_t v18 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_54;
    }

void nw_protocol_http_client_create::$_1::__invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        id v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "operator()";
        id v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_58;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v10) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "operator()";
        id v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_58;
      }

      if (v10)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v19 = "operator()";
        __int16 v20 = 2082;
        BOOL v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
LABEL_59:
      if (!v5) {
        return;
      }
      goto LABEL_60;
    }

    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    id v8 = "%{public}s called with null protocol";
    goto LABEL_58;
  }

  if (!*(void *)(a1 + 40))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        id v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "operator()";
        id v8 = "%{public}s called with null http_client, backtrace limit exceeded";
        goto LABEL_58;
      }

      os_log_type_t v11 = (char *)__nw_create_backtrace_string();
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (!v11)
      {
        if (!v12) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "operator()";
        id v8 = "%{public}s called with null http_client, no backtrace";
        goto LABEL_58;
      }

      if (!v12) {
        goto LABEL_40;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v19 = "operator()";
      __int16 v20 = 2082;
      BOOL v21 = v11;
      uint64_t v13 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
      goto LABEL_39;
    }

    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    id v8 = "%{public}s called with null http_client";
LABEL_58:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_59;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v19 = "operator()";
      id v8 = "%{public}s called with null metadata";
      goto LABEL_58;
    }

    if (!v16)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v19 = "operator()";
      id v8 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_58;
    }

    os_log_type_t v11 = (char *)__nw_create_backtrace_string();
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v14 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v14) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v19 = "operator()";
      id v8 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_58;
    }

    if (!v14) {
      goto LABEL_40;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v19 = "operator()";
    __int16 v20 = 2082;
    BOOL v21 = v11;
    uint64_t v13 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v6, v7, v13, buf, 0x16u);
    goto LABEL_40;
  }

  if (a5)
  {
    (*(void (**)(uint64_t, uint64_t))(a5 + 16))(a5, 1LL);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v19 = "operator()";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    id v8 = "%{public}s called with null completion";
    goto LABEL_58;
  }

  if (!v16)
  {
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    id v8 = "%{public}s called with null completion, backtrace limit exceeded";
    goto LABEL_58;
  }

  os_log_type_t v11 = (char *)__nw_create_backtrace_string();
  id v6 = (os_log_s *)__nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v15 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v15) {
      goto LABEL_59;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "operator()";
    id v8 = "%{public}s called with null completion, no backtrace";
    goto LABEL_58;
  }

  if (v15)
  {
    *(_DWORD *)int buf = 136446466;
    BOOL v19 = "operator()";
    __int16 v20 = 2082;
    BOOL v21 = v11;
    uint64_t v13 = "%{public}s called with null completion, dumping backtrace:%{public}s";
    goto LABEL_39;
  }

void nw_protocol_http_client_report_transfer_size( nw_protocol *a1, nw_protocol_metadata *a2, unsigned int a3, int a4)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
    BOOL v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
      char v24 = "%{public}s called with null protocol";
    }

    else if (v58)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v26 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_103:
        if (!v21) {
          return;
        }
        goto LABEL_104;
      }

      if (!v26) {
        goto LABEL_103;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
      char v24 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
      char v24 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_102;
  }

  uint64_t handle = (void **)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
    BOOL v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v58)
      {
        uint64_t v22 = (os_log_s *)__nwlog_obj();
        os_log_type_t v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_103;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
        char v24 = "%{public}s called with null http_client, backtrace limit exceeded";
        goto LABEL_102;
      }

      id v27 = (char *)__nw_create_backtrace_string();
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v28 = os_log_type_enabled(v22, type);
      if (!v27)
      {
        if (!v28) {
          goto LABEL_103;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
        char v24 = "%{public}s called with null http_client, no backtrace";
        goto LABEL_102;
      }

      if (v28)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_client_report_transfer_size";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v27;
        uint64_t v29 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
LABEL_55:
        _os_log_impl(&dword_181A5C000, v22, v23, v29, buf, 0x16u);
      }

uint64_t nw_protocol_http_client_create::$_2::__invoke( nw_protocol_http_client_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (this)
  {
    if (*((void *)this + 5)) {
      return 0LL;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v15 = "operator()";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v15 = "operator()";
      id v7 = "%{public}s called with null http_client";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v15 = "operator()";
          __int16 v16 = 2082;
          id v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null http_client, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_32:
        if (!v4) {
          return 0LL;
        }
LABEL_33:
        free(v4);
        return 0LL;
      }

      if (!v11) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v15 = "operator()";
      id v7 = "%{public}s called with null http_client, no backtrace";
    }

    else
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v15 = "operator()";
      id v7 = "%{public}s called with null http_client, backtrace limit exceeded";
    }

uint64_t nw_protocol_http_client_create::$_3::__invoke( nw_protocol_http_client_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v18 = "operator()";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v18 = "operator()";
      BOOL v9 = "%{public}s called with null protocol";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      goto LABEL_45;
    }

    if (!v15)
    {
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "operator()";
        BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "operator()";
        BOOL v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    if (!v11) {
      goto LABEL_31;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v18 = "operator()";
    __int16 v19 = 2082;
    uint64_t v20 = backtrace_string;
    char v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_30:
    _os_log_impl(&dword_181A5C000, v7, v8, v12, buf, 0x16u);
    goto LABEL_31;
  }

  uint64_t v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v18 = "operator()";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v18 = "operator()";
      BOOL v9 = "%{public}s called with null http_client";
      goto LABEL_44;
    }

    if (!v15)
    {
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "operator()";
        BOOL v9 = "%{public}s called with null http_client, backtrace limit exceeded";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "operator()";
        BOOL v9 = "%{public}s called with null http_client, no backtrace";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    if (!v13) {
      goto LABEL_31;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v18 = "operator()";
    __int16 v19 = 2082;
    uint64_t v20 = backtrace_string;
    char v12 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
    goto LABEL_30;
  }

  if (a2)
  {
    uint64_t v4 = 1LL;
    buf[0] = 1;
    nw_protocol_notify(a2, v3, 23);
    return v4;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v18 = "operator()";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "operator()";
        BOOL v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v18 = "operator()";
        BOOL v9 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_44;
      }

      goto LABEL_45;
    }

    if (v14)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v18 = "operator()";
      __int16 v19 = 2082;
      uint64_t v20 = backtrace_string;
      char v12 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_30;
    }

uint64_t nw_protocol_http_client_create::$_4::__invoke( nw_protocol_http_client_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v37 = "operator()";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null protocol";
      goto LABEL_72;
    }

    if (!v34)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_72;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v16 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v16) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_72;
    }

    if (!v16) {
      goto LABEL_38;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v37 = "operator()";
    __int16 v38 = 2082;
    os_log_type_t v39 = backtrace_string;
    id v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_37:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_38;
  }

  uint64_t v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v37 = "operator()";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null http_client";
      goto LABEL_72;
    }

    if (!v34)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null http_client, backtrace limit exceeded";
      goto LABEL_72;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null http_client, no backtrace";
      goto LABEL_72;
    }

    if (!v18) {
      goto LABEL_38;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v37 = "operator()";
    __int16 v38 = 2082;
    os_log_type_t v39 = backtrace_string;
    id v17 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
    goto LABEL_37;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v37 = "operator()";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null other_protocol";
      goto LABEL_72;
    }

    if (!v34)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v37 = "operator()";
      BOOL v14 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_72;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v19 = os_log_type_enabled(v12, type);
    if (backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v37 = "operator()";
        __int16 v38 = 2082;
        os_log_type_t v39 = backtrace_string;
        id v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

uint64_t nw_protocol_http_client_create::$_5::__invoke( nw_protocol_http_client_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_client_create::$_6::__invoke( nw_protocol_http_client_create::$_6 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "operator()";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "operator()";
      BOOL v14 = "%{public}s called with null protocol";
LABEL_55:
      _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      goto LABEL_56;
    }

    if (!v20)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "operator()";
        BOOL v14 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_55;
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v16 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "operator()";
        BOOL v14 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_55;
      }

      goto LABEL_56;
    }

    if (!v16) {
      goto LABEL_42;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v23 = "operator()";
    __int16 v24 = 2082;
    os_log_type_t v25 = backtrace_string;
    id v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_41:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_42;
  }

  uint64_t v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "operator()";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "operator()";
      BOOL v14 = "%{public}s called with null http_client";
      goto LABEL_55;
    }

    if (!v20)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "operator()";
        BOOL v14 = "%{public}s called with null http_client, backtrace limit exceeded";
        goto LABEL_55;
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "operator()";
        BOOL v14 = "%{public}s called with null http_client, no backtrace";
        goto LABEL_55;
      }

      goto LABEL_56;
    }

    if (!v18) {
      goto LABEL_42;
    }
    *(_DWORD *)int buf = 136446466;
    os_log_type_t v23 = "operator()";
    __int16 v24 = 2082;
    os_log_type_t v25 = backtrace_string;
    id v17 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
    goto LABEL_41;
  }

  if (a2)
  {
    if (!*(void *)(v3 + 576))
    {
      uint64_t parameters = (void *)nw_protocol_get_parameters((uint64_t)a2);
      if (parameters) {
        id v5 = os_retain(parameters);
      }
      else {
        id v5 = 0LL;
      }
      client_metadata_in_uint64_t parameters = nw_http_messaging_options_find_or_create_client_metadata_in_parameters(v5, v3);
      char v7 = *(_BYTE *)(v3 + 584);
      if ((v7 & 1) != 0)
      {
        id v8 = *(void **)(v3 + 576);
        if (v8)
        {
          os_release(v8);
          char v7 = *(_BYTE *)(v3 + 584);
        }
      }

      *(void *)(v3 + 576) = client_metadata_in_parameters;
      *(_BYTE *)(v3 + 584) = v7 | 1;
      if (v5) {
        os_release(v5);
      }
    }

    BOOL v9 = *(void **)(v3 + 48);
    if (v9)
    {
      nw_protocol_error(v9, v3);
      nw_protocol_disconnected(*(void **)(v3 + 48), v3);
      nw_protocol_set_output_handler(*(void *)(v3 + 48), 0LL);
      nw_protocol_set_input_handler(v3, 0LL);
    }

    return 1LL;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v23 = "operator()";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v20)
    {
      char v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "operator()";
        BOOL v14 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_55;
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v19 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "operator()";
        BOOL v14 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_55;
      }

      goto LABEL_56;
    }

    if (v19)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v23 = "operator()";
      __int16 v24 = 2082;
      os_log_type_t v25 = backtrace_string;
      id v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_41;
    }

void ___ZL37nw_protocol_http_client_get_callbacksv_block_invoke()
{
  qword_18C592A48 = (uint64_t)nw_protocol_common_get_input_frames;
  unk_18C592A50 = nw_protocol_common_get_output_frames;
  qword_18C592A68 = (uint64_t)nw_protocol_common_get_parameters;
  unk_18C592A70 = nw_protocol_common_get_path;
  qword_18C592A78 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_18C592A80 = nw_protocol_common_get_remote_endpoint;
  qword_18C592A08 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_18C592A10 = nw_protocol_common_connect;
  qword_18C592A18 = (uint64_t)nw_protocol_common_disconnect;
  unk_18C592A20 = nw_protocol_common_connected;
  qword_18C592A38 = (uint64_t)nw_protocol_common_input_available;
  unk_18C592A40 = nw_protocol_common_output_available;
  qword_18C592AB8 = (uint64_t)nw_protocol_common_output_finished;
  unk_18C592AC0 = nw_protocol_common_get_output_local_endpoint;
  qword_18C592B00 = (uint64_t)nw_protocol_common_input_flush;
  qword_18C592A28 = (uint64_t)nw_protocol_common_disconnected;
  unk_18C592A30 = nw_protocol_common_error;
  qword_18C592AF0 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_18C592AF8 = nw_protocol_common_reset;
  qword_18C592AA8 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_18C592AB0 = nw_protocol_common_input_finished;
  qword_18C592AC8 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_18C592AD0 = nw_protocol_common_waiting_for_output;
  qword_18C592A88 = (uint64_t)nw_protocol_common_register_notification;
  unk_18C592A90 = nw_protocol_common_unregister_notification;
  qword_18C592A98 = (uint64_t)nw_protocol_common_notify;
  unk_18C592AA0 = nw_protocol_common_updated_path;
  qword_18C592A58 = (uint64_t)nw_protocol_common_finalize_output_frames;
  unk_18C592A60 = nw_protocol_common_link_state;
  qword_18C592AD8 = (uint64_t)nw_protocol_http_client_copy_info;
  nw_protocol_http_client_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  unk_18C592A00 = nw_protocol_http_client_remove_input_handler;
}

uint64_t nw_protocol_http_client_copy_info(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v17 = "nw_protocol_http_client_copy_info";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v17 = "nw_protocol_http_client_copy_info";
        BOOL v9 = "%{public}s called with null protocol";
LABEL_35:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }

uint64_t nw_protocol_http_client_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t handle = (nw_protocol *)a1->handle;
    if (handle)
    {
      if (handle->default_input_handler == a2)
      {
        v15[0] = MEMORY[0x1895F87A8];
        v15[1] = 0x40000000LL;
        void v15[2] = ___ZL44nw_protocol_http_client_remove_input_handlerP11nw_protocolS0_b_block_invoke;
        v15[3] = &__block_descriptor_tmp_6_29882;
        void v15[4] = handle;
        v13[0] = MEMORY[0x1895F87A8];
        v13[1] = 0x40000000LL;
        v13[2] = ___ZL44nw_protocol_http_client_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
        v13[3] = &__block_descriptor_tmp_7_29883;
        char v14 = a3;
        void v13[4] = handle;
        return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v15, (uint64_t)v13);
      }

      else
      {
        if (a2->output_handler == handle) {
          a2->output_handler = 0LL;
        }
        return 1LL;
      }
    }

    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v19 = "nw_protocol_http_client_remove_input_handler";
    id v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "nw_protocol_http_client_remove_input_handler";
        os_log_type_t v8 = "%{public}s called with null http_client";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (!v16)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "nw_protocol_http_client_remove_input_handler";
        os_log_type_t v8 = "%{public}s called with null http_client, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = v17;
    BOOL v12 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "nw_protocol_http_client_remove_input_handler";
        os_log_type_t v8 = "%{public}s called with null http_client, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v12)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v19 = "nw_protocol_http_client_remove_input_handler";
      __int16 v20 = 2082;
      uint64_t v21 = backtrace_string;
      BOOL v11 = "%{public}s called with null http_client, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v19 = "nw_protocol_http_client_remove_input_handler";
  id v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (v17 != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "nw_protocol_http_client_remove_input_handler";
        os_log_type_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = v17;
    BOOL v10 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v19 = "nw_protocol_http_client_remove_input_handler";
        os_log_type_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v10)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v19 = "nw_protocol_http_client_remove_input_handler";
      __int16 v20 = 2082;
      uint64_t v21 = backtrace_string;
      BOOL v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v6, v7, v11, buf, 0x16u);
    }

void ___ZL44nw_protocol_http_client_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (gLogDatapath)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v9 = 136446210;
      BOOL v10 = "nw_protocol_plugin_metadata_teardown";
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v9, 0xCu);
    }
  }

  nw_protocol_plugin_metadata_reset((uint64_t *)(v2 + 200));
  *(void *)(v2 + 32_Block_object_dispose(va, 8) = 0LL;
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = *(_BYTE *)(v3 + 464);
  if ((v4 & 1) != 0)
  {
    id v5 = *(const void **)(v3 + 456);
    if (v5)
    {
      _Block_release(v5);
      char v4 = *(_BYTE *)(v3 + 464);
    }
  }

  *(void *)(v3 + 456) = 0LL;
  *(_BYTE *)(v3 + 464) = v4 | 1;
  char v6 = *(_BYTE *)(v3 + 512);
  if ((v6 & 1) != 0)
  {
    os_log_type_t v7 = *(const void **)(v3 + 504);
    if (v7)
    {
      _Block_release(v7);
      char v6 = *(_BYTE *)(v3 + 512);
    }
  }

  *(void *)(v3 + 504) = 0LL;
  *(_BYTE *)(v3 + 512) = v6 | 1;
}

void ___ZL44nw_protocol_http_client_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 40))
  {
    uint64_t v1 = *(void *)(a1 + 32);
    if ((*(_BYTE *)(v1 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        os_log_type_t v8 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          int v9 = 136446722;
          BOOL v10 = "nw_http_client_destroy";
          __int16 v11 = 2082;
          uint64_t v12 = v1 + 114;
          __int16 v13 = 2080;
          char v14 = " ";
          _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", (uint8_t *)&v9, 0x20u);
        }
      }
    }

    if (*(_DWORD *)(v1 + 552))
    {
      *(_BYTE *)(v1 + 556) |= 0x40u;
      if ((*(_BYTE *)(v1 + 198) & 1) == 0 && gLogDatapath)
      {
        uint64_t v2 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
        {
          int v9 = 136446722;
          BOOL v10 = "nw_http_client_destroy";
          __int16 v11 = 2082;
          uint64_t v12 = v1 + 114;
          __int16 v13 = 2080;
          char v14 = " ";
          _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sdeferring destroy because the request is being reissued",  (uint8_t *)&v9,  0x20u);
        }
      }
    }

    else
    {
      if ((*(_BYTE *)(v1 + 584) & 1) != 0)
      {
        uint64_t v3 = *(void **)(v1 + 576);
        if (v3) {
          os_release(v3);
        }
      }

      *(void *)(v1 + 576) = 0LL;
      if ((*(_BYTE *)(v1 + 568) & 1) != 0)
      {
        char v4 = *(void **)(v1 + 560);
        if (v4) {
          os_release(v4);
        }
      }

      *(void *)(v1 + 560) = 0LL;
      nw_protocol_plugin_retry::~nw_protocol_plugin_retry((nw_protocol_plugin_retry *)(v1 + 344));
      if ((*(_BYTE *)(v1 + 288) & 1) != 0)
      {
        id v5 = *(void **)(v1 + 280);
        if (v5) {
          os_release(v5);
        }
      }

      *(void *)(v1 + 280) = 0LL;
      if ((*(_BYTE *)(v1 + 272) & 1) != 0)
      {
        char v6 = *(void **)(v1 + 264);
        if (v6) {
          os_release(v6);
        }
      }

      *(void *)(v1 + 264) = 0LL;
      if ((*(_BYTE *)(v1 + 256) & 1) != 0)
      {
        os_log_type_t v7 = *(void **)(v1 + 248);
        if (v7) {
          os_release(v7);
        }
      }

      free((void *)v1);
    }
  }

double __nw_protocol_http_client_identifier_block_invoke()
{
  *(void *)&double result = 0x200000005LL;
  qword_18C592758 = 0x200000005LL;
  return result;
}

BOOL nw_nsstring(uint64_t a1)
{
  uint64_t v1 = [NSString stringWithUTF8String:a1];
  if (v1) {
    return v1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  uint64_t v3 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
    return v1;
  }

  __break(1u);
  return result;
}

void nw_tcp_respond_reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  unsigned int v65 = 0;
  uint64_t v9 = nw_frame_unclaimed_bytes(a1, &v65);
  if (v65 <= 0x13)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446722;
    id v67 = "nw_tcp_respond_reset";
    __int16 v68 = 1024;
    *(_DWORD *)uint64_t v69 = v65;
    *(_WORD *)&v69[4] = 2048;
    *(void *)&v69[6] = 20LL;
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v64 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_39;
      }
      *(_DWORD *)int buf = 136446722;
      id v67 = "nw_tcp_respond_reset";
      __int16 v68 = 1024;
      *(_DWORD *)uint64_t v69 = v65;
      *(_WORD *)&v69[4] = 2048;
      *(void *)&v69[6] = 20LL;
      __int16 v13 = "%{public}s Frame is invalid, only has %u bytes, required: %zu";
LABEL_37:
      os_log_type_t v36 = v11;
      os_log_type_t v37 = v12;
      uint32_t v38 = 28;
LABEL_38:
      _os_log_impl(&dword_181A5C000, v36, v37, v13, buf, v38);
      goto LABEL_39;
    }

    if (v64 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_39;
      }
      *(_DWORD *)int buf = 136446722;
      id v67 = "nw_tcp_respond_reset";
      __int16 v68 = 1024;
      *(_DWORD *)uint64_t v69 = v65;
      *(_WORD *)&v69[4] = 2048;
      *(void *)&v69[6] = 20LL;
      __int16 v13 = "%{public}s Frame is invalid, only has %u bytes, required: %zu, backtrace limit exceeded";
      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v11 = (os_log_s *)gLogObj;
    os_log_type_t v12 = type[0];
    BOOL v22 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (!v22) {
        goto LABEL_39;
      }
      *(_DWORD *)int buf = 136446722;
      id v67 = "nw_tcp_respond_reset";
      __int16 v68 = 1024;
      *(_DWORD *)uint64_t v69 = v65;
      *(_WORD *)&v69[4] = 2048;
      *(void *)&v69[6] = 20LL;
      __int16 v13 = "%{public}s Frame is invalid, only has %u bytes, required: %zu, no backtrace";
      goto LABEL_37;
    }

    if (v22)
    {
      *(_DWORD *)int buf = 136446978;
      id v67 = "nw_tcp_respond_reset";
      __int16 v68 = 1024;
      *(_DWORD *)uint64_t v69 = v65;
      *(_WORD *)&v69[4] = 2048;
      *(void *)&v69[6] = 20LL;
      __int16 v70 = 2082;
      id v71 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s Frame is invalid, only has %u bytes, required: %zu, dumping backtrace:%{public}s",  buf,  0x26u);
    }

    free(backtrace_string);
LABEL_39:
    if (!v10) {
      return;
    }
    goto LABEL_40;
  }

  uint64_t v14 = v9;
  if ((*(_BYTE *)(v9 + 13) & 4) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int buf = 136446210;
    id v67 = "nw_tcp_respond_reset";
    __int16 v18 = "%{public}s Attempting to send a RST in reply to a RST";
    BOOL v19 = (os_log_s *)v17;
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    goto LABEL_34;
  }

  uint64_t v15 = 20LL;
  unsigned int v65 = 20;
  int v16 = *(unsigned __int8 *)(a5 + 1);
  if (v16 == 30)
  {
    uint64_t v15 = 60LL;
  }

  else
  {
    if (v16 != 2) {
      goto LABEL_21;
    }
    uint64_t v15 = 40LL;
  }

  unsigned int v65 = v15;
LABEL_21:
  *(void *)os_log_type_t type = 0LL;
  uint64_t v63 = type;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, os_log_type_t *))(*(void *)(a2 + 24) + 88LL))( a2,  a3,  v15,  v15,  1LL,  type) != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v35 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      return;
    }
    *(_DWORD *)int buf = 136446210;
    id v67 = "nw_tcp_respond_reset";
    __int16 v18 = "%{public}s Failed to get output frame to send RST";
    BOOL v19 = (os_log_s *)v35;
    os_log_type_t v20 = OS_LOG_TYPE_INFO;
LABEL_34:
    _os_log_impl(&dword_181A5C000, v19, v20, v18, buf, 0xCu);
    return;
  }

  uint64_t v23 = *(void *)type;
  if (*(void *)type)
  {
    int v24 = *(unsigned __int8 *)(a5 + 1);
    if (v24 != 30)
    {
      if (v24 != 2)
      {
        __int16 v33 = 0;
LABEL_55:
        if (*(void *)(v23 + 112)
          && ((*(_WORD *)(v23 + 204) & 0x100) == 0
           || !g_channel_check_validity
           || g_channel_check_validity(v23, *(void *)(v23 + 88))))
        {
          int v45 = *(_DWORD *)(v23 + 52);
          if (v45)
          {
            uint64_t v46 = *(void *)(v23 + 112);
            if (v46)
            {
              uint64_t v47 = *(unsigned int *)(v23 + 56);
              if ((v45 - (v47 + *(_DWORD *)(v23 + 60))) > 0x13)
              {
                uint64_t v48 = v46 + v47;
                *(_DWORD *)(v48 + 16) = 0;
                *(void *)uint64_t v48 = 0LL;
                *(void *)(v48 + _Block_object_dispose(va, 8) = 0LL;
                *(_WORD *)uint64_t v48 = *(_WORD *)(v14 + 2);
                *(_WORD *)(v48 + 2) = *(_WORD *)v14;
                *(_BYTE *)(v48 + 13) = 4;
                *(_BYTE *)(v48 + 12) = 80;
                *(_WORD *)(v48 + 16) = v33;
                if ((*(_BYTE *)(v14 + 13) & 0x10) != 0)
                {
                  *(_DWORD *)(v48 + 4) = *(_DWORD *)(v14 + 8);
                }

                else
                {
                  unsigned int v49 = bswap32(bswap32(*(_DWORD *)(v14 + 4)) + 1);
                  if ((*(_BYTE *)(v14 + 13) & 2) != 0) {
                    unsigned int v50 = v49;
                  }
                  else {
                    unsigned int v50 = *(_DWORD *)(v14 + 4);
                  }
                  *(_DWORD *)(v48 + _Block_object_dispose(va, 8) = v50;
                  *(_BYTE *)(v48 + 13) = 20;
                }

                unsigned int v54 = 20;
                __int16 v55 = MEMORY[0x186E115BC](v48, 20LL, 0LL);
                if (v55 == -1) {
                  __int16 v57 = -1;
                }
                else {
                  __int16 v57 = ~v55;
                }
                *(_WORD *)(v48 + 16) = v57;
                nw_frame_claim(v23, v56, 20, 0);
                nw_frame_collapse(v23);
                nw_frame_unclaim(v23, v58, 0x14u, 0);
                int v60 = *(unsigned __int8 *)(a5 + 1);
                if (v60 != 2)
                {
                  if (v60 != 30)
                  {
LABEL_96:
                    (*(void (**)(uint64_t, os_log_type_t *))(*(void *)(a2 + 24) + 96LL))(a2, type);
                    return;
                  }

                  unsigned int v54 = 40;
                }

                nw_frame_unclaim(v23, v59, v54, 0);
                goto LABEL_96;
              }
            }
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v51 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446722;
          id v67 = "nw_tcp_respond_reset";
          __int16 v68 = 1024;
          *(_DWORD *)uint64_t v69 = v65;
          *(_WORD *)&v69[4] = 2048;
          *(void *)&v69[6] = 20LL;
LABEL_81:
          _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_ERROR,  "%{public}s nw_frame_unclaimed_bytes reports %u, need at least %zu",  buf,  0x1Cu);
          goto LABEL_82;
        }

        goto LABEL_82;
      }

      if (*(void *)(*(void *)type + 112LL)
        && ((*(_WORD *)(*(void *)type + 204LL) & 0x100) == 0
         || !g_channel_check_validity
         || g_channel_check_validity(*(void *)type, *(void *)(*(void *)type + 88LL)))
        && (int v25 = *(_DWORD *)(v23 + 52)) != 0)
      {
        uint64_t v26 = *(unsigned int *)(v23 + 56);
        unsigned int v27 = v25 - (v26 + *(_DWORD *)(v23 + 60));
        if (v27 > 0x13)
        {
          BOOL v28 = (unsigned __int16 *)(*(void *)(v23 + 112) + v26);
          *(void *)BOOL v28 = 0LL;
          *((void *)v28 + 1) = 0LL;
          *((_DWORD *)v28 + 4) = 0;
          *(_BYTE *)BOOL v28 = 69;
          *(_DWORD *)(v28 + 3) = 117375040;
          unsigned int v29 = *(_DWORD *)(a4 + 4);
          *((_DWORD *)v28 + 3) = v29;
          unsigned int v30 = *(_DWORD *)(a5 + 4);
          *((_DWORD *)v28 + 4) = v30;
          v28[1] = 10240;
          unsigned int v31 = *v28 + (unsigned __int16)v29 + HIWORD(v29) + (unsigned __int16)v30 + HIWORD(v30) + 12095;
          void v28[5] = ~(HIWORD(v31) + v31 + ((HIWORD(v31) + (unsigned __int16)v31) >> 16));
          __int16 v33 = in_pseudo(v30, v29, 0x1A000000u);
          int v34 = 20;
LABEL_53:
          nw_frame_claim(v23, v32, v34, 0);
          goto LABEL_55;
        }
      }

      else
      {
        unsigned int v27 = 0;
      }

      uint64_t v51 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446722;
        id v67 = "nw_tcp_respond_reset";
        __int16 v68 = 1024;
        *(_DWORD *)uint64_t v69 = v27;
        *(_WORD *)&v69[4] = 2048;
        *(void *)&v69[6] = 20LL;
        goto LABEL_81;
      }

uint64_t __nw_quic_parse_dispatch_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, const unsigned __int8 *a4, unint64_t a5)
{
  return nw_quic_parse_internal(a4, a5, *(unsigned __int8 *)(a1 + 40), *(dispatch_data_s ***)(a1 + 32));
}

uint64_t nw_quic_parse_internal( const unsigned __int8 *a1, unint64_t a2, size_t size, dispatch_data_s **a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!(_DWORD)size)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v14 = "nw_quic_parse_internal";
    id v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_quic_parse_internal";
      os_log_type_t v8 = "%{public}s called with null connection_id_length";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v14 = "nw_quic_parse_internal";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null connection_id_length, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (!v10)
      {
LABEL_19:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_quic_parse_internal";
      os_log_type_t v8 = "%{public}s called with null connection_id_length, no backtrace";
    }

    else
    {
      char v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v14 = "nw_quic_parse_internal";
      os_log_type_t v8 = "%{public}s called with null connection_id_length, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_19;
  }

  if ((unint64_t)size + 21 <= a2 && (*(char *)a1 & 0x80000000) == 0)
  {
    *a4 = dispatch_data_create(a1 + 1, size, 0LL, 0LL);
    return 1LL;
  }

  return 0LL;
}

void sub_18205D0F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL48nw_endpoint_resolver_update_path_resolver_lockedP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1, unsigned __int8 *uu)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  uuid_unparse(uu, out);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 80LL);
  if (!v4 || (id v5 = nw_dictionary_copy_value(v4, (uint64_t)out)) == 0LL)
  {
    id v6 = nw_endpoint_handler_copy_association(*(void **)(a1 + 48), 0);
    flow = nw_association_create_flow((uint64_t)v6, 0, 0, 0, 1, uu, 0LL);
    nw_dictionary_set_value(*(void *)(a1 + 40), out, flow);
    os_log_type_t v8 = *(void **)(a1 + 48);
    if (flow)
    {
      int minimize_logging = nw_endpoint_handler_get_minimize_logging(v8);
      char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 48));
      if (minimize_logging)
      {
        if ((logging_disabled & 1) != 0) {
          goto LABEL_17;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v11 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 48));
          unsigned int v27 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 48));
          nw_endpoint_t v28 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 48));
          logging_description = nw_endpoint_get_logging_description(v28);
          unsigned int v30 = nw_endpoint_handler_state_string(*(void **)(a1 + 48));
          unsigned int v31 = nw_endpoint_handler_mode_string(*(void **)(a1 + 48));
          id v32 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 48));
          int v33 = 136448002;
          int v34 = "nw_endpoint_resolver_update_path_resolver_locked_block_invoke";
          __int16 v35 = 2082;
          os_log_type_t v36 = id_string;
          __int16 v37 = 2082;
          uint32_t v38 = v27;
          __int16 v39 = 2082;
          os_log_type_t v40 = logging_description;
          __int16 v41 = 2082;
          uint64_t v42 = v30;
          __int16 v43 = 2082;
          uint64_t v44 = v31;
          __int16 v45 = 2114;
          id v46 = v32;
          __int16 v47 = 2080;
          uint64_t v48 = out;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Registered resolver flow with agent %s",  (uint8_t *)&v33,  0x52u);
        }

        goto LABEL_16;
      }

      if ((logging_disabled & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v11 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v12 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 48));
          __int16 v13 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 48));
          nw_endpoint_t v14 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 48));
          __int16 v15 = nw_endpoint_get_logging_description(v14);
          int v16 = nw_endpoint_handler_state_string(*(void **)(a1 + 48));
          uint64_t v17 = nw_endpoint_handler_mode_string(*(void **)(a1 + 48));
          id v18 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 48));
          int v33 = 136448002;
          int v34 = "nw_endpoint_resolver_update_path_resolver_locked_block_invoke";
          __int16 v35 = 2082;
          os_log_type_t v36 = v12;
          __int16 v37 = 2082;
          uint32_t v38 = v13;
          __int16 v39 = 2082;
          os_log_type_t v40 = v15;
          __int16 v41 = 2082;
          uint64_t v42 = v16;
          __int16 v43 = 2082;
          uint64_t v44 = v17;
          __int16 v45 = 2114;
          id v46 = v18;
          __int16 v47 = 2080;
          uint64_t v48 = out;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Registered resolver flow with agent %s",  (uint8_t *)&v33,  0x52u);
        }

void sub_18205DE14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__30091(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__30092(uint64_t a1)
{
}

BOOL ___ZL48nw_endpoint_resolver_update_path_resolver_lockedP30NWConcrete_nw_endpoint_handler_block_invoke_97( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = nw_path_flow_copy_error(v4);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  os_log_type_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  BOOL v8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) == 0LL;
  return v8;
}

uint64_t ___ZL44nw_endpoint_resolver_array_contains_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  return nw_endpoint_is_equal(*(void **)(a1 + 32), a3, 1LL) ^ 1;
}

uint64_t ___ZL53nw_endpoint_resolver_duplicate_array_without_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;

  return 1LL;
}

void sub_18205DFE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_endpoint_resolver_updateP30NWConcrete_nw_endpoint_handlerPU25objcproto14OS_nw_resolver8NSObject20nw_resolver_status_t_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  nw_endpoint_t v4 = nw_endpoint_handler_copy_endpoint(a3);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  BOOL v8 = *(char **)(v5 + 24);
  os_log_type_t v7 = (char **)(v5 + 24);
  uint64_t v6 = v8;
  int v9 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  logging_description = nw_endpoint_get_logging_description(v4);
  char v11 = "";
  if (!v9) {
    char v11 = ",";
  }
  asprintf(v7, "%s%s%s", v6, v11, logging_description);
  if (v6) {
    free(v6);
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;

  return 1LL;
}

void sub_18205E0CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL27nw_endpoint_resolver_updateP30NWConcrete_nw_endpoint_handlerPU25objcproto14OS_nw_resolver8NSObject20nw_resolver_status_t_block_invoke_105( uint64_t a1)
{
}

void nw_endpoint_resolver_check_desperate_ivan(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = nw_endpoint_handler_copy_resolver(v1);
  uint64_t v3 = v2;
  if ((*((_BYTE *)v2 + 24) & 4) == 0)
  {
    if (*((void *)v2 + 4))
    {
      *((_BYTE *)v2 + 24) |= 4u;
      goto LABEL_8;
    }

    id v4 = nw_endpoint_handler_copy_parameters(v1);
    if (nw_parameters_get_required_address_family(v4)
      || nw_parameters_get_desperate_ivan(v4))
    {
      *((_BYTE *)v3 + 24) |= 4u;
LABEL_7:

      goto LABEL_8;
    }

    id v43 = nw_endpoint_handler_copy_current_path(v1);
    if ((nw_path_is_eligible_for_CrazyIvan46(v43) & 1) == 0)
    {
LABEL_42:

      goto LABEL_7;
    }

    nw_endpoint_t v5 = nw_endpoint_handler_copy_endpoint(v1);
    if (nw_endpoint_get_type(v5) != nw_endpoint_type_host)
    {
LABEL_41:

      goto LABEL_42;
    }

    *((_BYTE *)v3 + 24) |= 0xCu;
    int minimize_logging = nw_endpoint_handler_get_minimize_logging(v1);
    char logging_disabled = nw_endpoint_handler_get_logging_disabled(v1);
    if (minimize_logging)
    {
      if ((logging_disabled & 1) != 0)
      {
LABEL_18:
        uint64_t v17 = *((void *)v3 + 9);
        if (v17)
        {
          nw_queue_cancel_source(v17, v8);
          *((void *)v3 + 9) = 0LL;
        }

        id v18 = nw_endpoint_handler_copy_context(v1);
        v46[0] = MEMORY[0x1895F87A8];
        v46[1] = 3221225472LL;
        v46[2] = ___ZL41nw_endpoint_resolver_check_desperate_ivanP30NWConcrete_nw_endpoint_handler_block_invoke;
        v46[3] = &unk_189BC93A0;
        __int16 v47 = v1;
        *((void *)v3 + 9) = nw_queue_context_create_source(v18, 2, 3, 0, v46, 0LL);

        uint64_t v19 = *((void *)v3 + 9);
        if (v19)
        {
          dispatch_time_t v20 = dispatch_time(0x8000000000000000LL, 2000000000LL);
          nw_queue_set_timer_values(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          nw_queue_activate_source(*((void *)v3 + 9), v21);
LABEL_40:

          goto LABEL_41;
        }

        __nwlog_obj();
        BOOL v22 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)int buf = 136446210;
        unsigned int v49 = "nw_endpoint_resolver_check_desperate_ivan";
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v44 = 0;
        if (__nwlog_fault(v23, &type, &v44))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)int buf = 136446210;
              unsigned int v49 = "nw_endpoint_resolver_check_desperate_ivan";
              _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s nw_queue_context_create_source(timer) failed",  buf,  0xCu);
            }
          }

          else
          {
            if (v44)
            {
              uint64_t v26 = v5;
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              nw_endpoint_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v29 = type;
              BOOL v30 = os_log_type_enabled(v28, type);
              if (backtrace_string)
              {
                if (v30)
                {
                  *(_DWORD *)int buf = 136446466;
                  unsigned int v49 = "nw_endpoint_resolver_check_desperate_ivan";
                  __int16 v50 = 2082;
                  uint64_t v51 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                nw_endpoint_t v5 = v26;
                free(backtrace_string);
              }

              else
              {
                if (v30)
                {
                  *(_DWORD *)int buf = 136446210;
                  unsigned int v49 = "nw_endpoint_resolver_check_desperate_ivan";
                  _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s nw_queue_context_create_source(timer) failed, no backtrace",  buf,  0xCu);
                }

                nw_endpoint_t v5 = v26;
              }

              goto LABEL_38;
            }

            __nwlog_obj();
            int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v31 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)int buf = 136446210;
              unsigned int v49 = "nw_endpoint_resolver_check_desperate_ivan";
              _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

void sub_18205E7A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_resolver_setup_trigger_agent_timer(NWConcrete_nw_endpoint_handler *a1, char a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  nw_endpoint_t v5 = (uint64_t *)nw_endpoint_handler_copy_resolver(v3);
  uint64_t v6 = v5[8];
  if (v6)
  {
    nw_queue_cancel_source(v6, v4);
    v5[8] = 0LL;
  }

  id v7 = nw_endpoint_handler_copy_context(v3);
  v23[0] = MEMORY[0x1895F87A8];
  v23[1] = 3221225472LL;
  void v23[2] = ___ZL46nw_endpoint_resolver_setup_trigger_agent_timerP30NWConcrete_nw_endpoint_handlerb_block_invoke;
  v23[3] = &unk_189BC5EB8;
  uint64_t v8 = v3;
  int v24 = v8;
  char v25 = a2;
  v5[8] = nw_queue_context_create_source(v7, 2, 3, 0, v23, 0LL);

  if (v5[8])
  {
    int64_t int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_tcpconn_trigger_agent_delay,  2000LL);
    uint64_t v10 = v5[8];
    dispatch_time_t v11 = dispatch_time(0x8000000000000000LL, 1000000 * int64_with_default);
    nw_queue_set_timer_values(v10, v11, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    nw_queue_activate_source(v5[8], v12);
    goto LABEL_12;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v13 = (id)gLogObj;
  *(_DWORD *)int buf = 136446210;
  unsigned int v27 = "nw_endpoint_resolver_setup_trigger_agent_timer";
  nw_endpoint_t v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v15 = (os_log_s *)(id)gLogObj;
    os_log_type_t v16 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)int buf = 136446210;
      unsigned int v27 = "nw_endpoint_resolver_setup_trigger_agent_timer";
      _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s nw_queue_context_create_source(trigger_agent_timer) failed",  buf,  0xCu);
    }

void sub_18205EC18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_endpoint_resolver_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1)
{
  return nw_endpoint_resolver_start_next_child(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
}

void ___ZL46nw_endpoint_resolver_setup_trigger_agent_timerP30NWConcrete_nw_endpoint_handlerb_block_invoke( uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (nw_endpoint_handler_trigger_agents(*(void **)(a1 + 32), 1))
  {
    int minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 32));
    char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
    if (!minimize_logging)
    {
      if ((logging_disabled & 1) != 0) {
        return;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        uint64_t v6 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v7 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        logging_description = nw_endpoint_get_logging_description(v7);
        int v9 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        uint64_t v10 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v11 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        uint64_t v12 = v11;
        id v13 = "child flow";
        BOOL v14 = *(_BYTE *)(a1 + 40) == 0;
        int v24 = 136448002;
        char v25 = "nw_endpoint_resolver_setup_trigger_agent_timer_block_invoke";
        __int16 v26 = 2082;
        if (v14) {
          id v13 = "resolution";
        }
        unsigned int v27 = id_string;
        __int16 v28 = 2082;
        os_log_type_t v29 = v6;
        __int16 v30 = 2082;
        os_log_type_t v31 = logging_description;
        __int16 v32 = 2082;
        nw_endpoint_t v33 = v9;
        __int16 v34 = 2082;
        __int16 v35 = v10;
        __int16 v36 = 2114;
        id v37 = v11;
        __int16 v38 = 2082;
        __int16 v39 = v13;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s timed out, trigger ing matching agent",  (uint8_t *)&v24,  0x52u);
      }

      goto LABEL_10;
    }

    if ((logging_disabled & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        __int16 v15 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        os_log_type_t v16 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v17 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        os_log_type_t v18 = nw_endpoint_get_logging_description(v17);
        BOOL v19 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        os_log_type_t v20 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v21 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        BOOL v22 = v21;
        uint64_t v23 = "child flow";
        BOOL v14 = *(_BYTE *)(a1 + 40) == 0;
        int v24 = 136448002;
        char v25 = "nw_endpoint_resolver_setup_trigger_agent_timer_block_invoke";
        __int16 v26 = 2082;
        if (v14) {
          uint64_t v23 = "resolution";
        }
        unsigned int v27 = v15;
        __int16 v28 = 2082;
        os_log_type_t v29 = v16;
        __int16 v30 = 2082;
        os_log_type_t v31 = v18;
        __int16 v32 = 2082;
        nw_endpoint_t v33 = v19;
        __int16 v34 = 2082;
        __int16 v35 = v20;
        __int16 v36 = 2114;
        id v37 = v21;
        __int16 v38 = 2082;
        __int16 v39 = v23;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s timed out, trigger ing matching agent",  (uint8_t *)&v24,  0x52u);
      }

void sub_18205EF78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_endpoint_resolver_check_desperate_ivanP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(a1 + 32);
  if (!v1)
  {
    __nwlog_obj();
    nw_endpoint_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    __int16 v35 = "nw_endpoint_resolver_check_desperate_ivan_block_invoke";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v18, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v35 = "nw_endpoint_resolver_check_desperate_ivan_block_invoke";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v35 = "nw_endpoint_resolver_check_desperate_ivan_block_invoke";
            __int16 v36 = 2082;
            id v37 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v30)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v35 = "nw_endpoint_resolver_check_desperate_ivan_block_invoke";
          _os_log_impl(&dword_181A5C000, v19, v29, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v35 = "nw_endpoint_resolver_check_desperate_ivan_block_invoke";
          _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_18205F54C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_resolver_add_desperate_ivan(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if ((nw_endpoint_handler_get_state(v1) & 0xFFFFFFFE) != 4)
  {
    uint64_t v3 = nw_endpoint_handler_copy_resolver(v1);
    nw_endpoint_t v5 = (uint64_t *)v3;
    if ((*((_BYTE *)v3 + 24) & 0xC) != 0)
    {
      if (!*((void *)v3 + 4))
      {
        *((_BYTE *)v3 + 24) &= ~8u;
        uint64_t v16 = *((void *)v3 + 9);
        if (v16)
        {
          nw_queue_cancel_source(v16, v4);
          v5[9] = 0LL;
        }

        nw_endpoint_t v8 = nw_endpoint_handler_copy_endpoint(v1);
        child_uint64_t parameters = nw_endpoint_resolver_create_child_parameters(v1);
        nw_parameters_set_desperate_ivan((void *)child_parameters, 1);
        inner = nw_endpoint_handler_create_inner( v8,  (void *)child_parameters,  nw_endpoint_resolver_receive_report,  v1,  v1,  0,  0);
        BOOL v2 = inner != 0LL;
        if (inner)
        {
          nw_array_append(v5[5], inner);
        }

        else if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v19 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            id_string = nw_endpoint_handler_get_id_string(v1);
            nw_endpoint_t v33 = nw_endpoint_handler_dry_run_string(v1);
            __int16 v34 = id_string;
            nw_endpoint_t v35 = nw_endpoint_handler_copy_endpoint(v1);
            logging_description = nw_endpoint_get_logging_description(v35);
            id v21 = nw_endpoint_handler_state_string(v1);
            BOOL v22 = nw_endpoint_handler_mode_string(v1);
            id v23 = nw_endpoint_handler_copy_current_path(v1);
            *(_DWORD *)int buf = 136447746;
            id v37 = "nw_endpoint_resolver_add_desperate_ivan";
            __int16 v38 = 2082;
            __int16 v39 = v34;
            __int16 v40 = 2082;
            __int16 v41 = v33;
            __int16 v42 = 2082;
            id v43 = logging_description;
            __int16 v44 = 2082;
            __int16 v45 = v21;
            __int16 v46 = 2082;
            id v47 = v22;
            __int16 v48 = 2114;
            id v49 = v23;
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create Desperat eIvan endpoint handler",  buf,  0x48u);
          }
        }

        goto LABEL_23;
      }

      int minimize_logging = nw_endpoint_handler_get_minimize_logging(v1);
      char logging_disabled = nw_endpoint_handler_get_logging_disabled(v1);
      if (minimize_logging)
      {
        if ((logging_disabled & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          nw_endpoint_t v8 = (nw_endpoint_t)(id)gconnectionLogObj;
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            int v24 = nw_endpoint_handler_get_id_string(v1);
            char v25 = nw_endpoint_handler_dry_run_string(v1);
            nw_endpoint_t v26 = nw_endpoint_handler_copy_endpoint(v1);
            id v27 = nw_endpoint_get_logging_description(v26);
            __int16 v28 = nw_endpoint_handler_state_string(v1);
            os_log_type_t v29 = nw_endpoint_handler_mode_string(v1);
            id v30 = nw_endpoint_handler_copy_current_path(v1);
            *(_DWORD *)int buf = 136447746;
            id v37 = "nw_endpoint_resolver_add_desperate_ivan";
            __int16 v38 = 2082;
            __int16 v39 = v24;
            __int16 v40 = 2082;
            __int16 v41 = v25;
            __int16 v42 = 2082;
            id v43 = v27;
            __int16 v44 = 2082;
            __int16 v45 = v28;
            __int16 v46 = 2082;
            id v47 = v29;
            __int16 v48 = 2114;
            id v49 = v30;
            _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping DesperateIvan be cause already connected",  buf,  0x48u);
          }

          goto LABEL_11;
        }
      }

      else if ((logging_disabled & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        nw_endpoint_t v8 = (nw_endpoint_t)(id)gconnectionLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          int v9 = nw_endpoint_handler_get_id_string(v1);
          nw_endpoint_t v10 = nw_endpoint_handler_dry_run_string(v1);
          nw_endpoint_t v11 = nw_endpoint_handler_copy_endpoint(v1);
          uint64_t v12 = nw_endpoint_get_logging_description(v11);
          id v13 = nw_endpoint_handler_state_string(v1);
          id v14 = nw_endpoint_handler_mode_string(v1);
          id v15 = nw_endpoint_handler_copy_current_path(v1);
          *(_DWORD *)int buf = 136447746;
          id v37 = "nw_endpoint_resolver_add_desperate_ivan";
          __int16 v38 = 2082;
          __int16 v39 = v9;
          __int16 v40 = 2082;
          __int16 v41 = v10;
          __int16 v42 = 2082;
          id v43 = v12;
          __int16 v44 = 2082;
          __int16 v45 = v13;
          __int16 v46 = 2082;
          id v47 = v14;
          __int16 v48 = 2114;
          id v49 = v15;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping DesperateIvan beca use already connected",  buf,  0x48u);
        }

void sub_18205FA44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke( uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    uint64_t v3 = v1;
    uint64_t v4 = v3[29];

    if ((_DWORD)v4 == 1)
    {
      if (nw_endpoint_handler_trigger_agents(*(void **)(a1 + 32), 1))
      {
        if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          nw_endpoint_t v5 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
            nw_endpoint_t v7 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
            nw_endpoint_t v8 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
            logging_description = nw_endpoint_get_logging_description(v8);
            nw_endpoint_t v10 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
            nw_endpoint_t v11 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
            id v12 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
            *(_DWORD *)int buf = 136447746;
            nw_endpoint_t v26 = "nw_endpoint_resolver_receive_report_block_invoke";
            __int16 v27 = 2082;
            __int16 v28 = (void *)id_string;
            __int16 v29 = 2082;
            id v30 = v7;
            __int16 v31 = 2082;
            char v32 = logging_description;
            __int16 v33 = 2082;
            __int16 v34 = v10;
            __int16 v35 = 2082;
            __int16 v36 = v11;
            __int16 v37 = 2114;
            id v38 = v12;
            _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Child flow failed, trying to trigger matching voluntary agents",  buf,  0x48u);
          }
        }

        nw_endpoint_handler_reset_mode(*(void **)(a1 + 32), 0);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        else {
          id v14 = off_189BBBBC0[v4];
        }
        *(_DWORD *)int buf = 136446722;
        nw_endpoint_t v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        __int16 v27 = 2082;
        __int16 v28 = (void *)v14;
        __int16 v29 = 2082;
        id v30 = "resolver";
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    return;
  }

  __nwlog_obj();
  id v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  nw_endpoint_t v26 = "nw_endpoint_resolver_receive_report_block_invoke";
  uint64_t v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        nw_endpoint_t v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)int buf = 136446466;
          nw_endpoint_t v26 = "nw_endpoint_resolver_receive_report_block_invoke";
          __int16 v27 = 2082;
          __int16 v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_34;
      }

      if (v21)
      {
        *(_DWORD *)int buf = 136446210;
        nw_endpoint_t v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)int buf = 136446210;
        nw_endpoint_t v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18205FF30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_110( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_endpoint_t v5 = v4;
  if (*(id *)(a1 + 32) != v4) {
    nw_endpoint_handler_cancel(v4, 0LL, 0);
  }

  return 1LL;
}

void sub_18205FF98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_2( uint64_t a1)
{
}

void ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_111( uint64_t a1)
{
}

uint64_t ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_112( uint64_t a1, uint64_t a2, void *a3)
{
  nw_endpoint_t v4 = nw_endpoint_handler_copy_endpoint(a3);
  int is_equal = nw_endpoint_is_equal(v4, *(void **)(a1 + 32), 31LL);
  if (is_equal) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  uint64_t v6 = is_equal ^ 1u;

  return v6;
}

void sub_18206000C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182061254( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_resolver_get_details_block_invoke(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = nw_endpoint_handler_copy_endpoint(v5);
  int sa_family = nw_endpoint_get_address(v6)->sa_family;
  if (sa_family == 30)
  {
    nw_endpoint_t v8 = (_DWORD **)(a1 + 48);
  }

  else
  {
    if (sa_family != 2) {
      goto LABEL_7;
    }
    nw_endpoint_t v8 = (_DWORD **)(a1 + 40);
  }

  ++**v8;
LABEL_7:
  int v9 = *(_BYTE **)(a1 + 56);
  if (!*v9) {
    *int v9 = sa_family;
  }
LABEL_9:
  if (*(id *)(*(void *)(a1 + 32) + 32LL) == v5) {
    **(_DWORD **)(a1 + 64) = a2;
  }

  return 1LL;
}

void sub_1820614E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_endpoint_for_alternatives(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    char v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
    nw_endpoint_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v8, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null handler", buf, 0xCu);
        }

void sub_182061A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_resolution_provider(void *a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  nw_endpoint_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    nw_endpoint_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v12, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (v21)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v13, v20, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1820621E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_access_resolver_handler(void *a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  nw_endpoint_t v4 = a2;
  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    char v36 = "nw_endpoint_handler_access_resolver_handler";
    id v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v26, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v36 = "nw_endpoint_handler_access_resolver_handler";
          _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null accessor", buf, 0xCu);
        }
      }

      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        BOOL v31 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)int buf = 136446466;
            char v36 = "nw_endpoint_handler_access_resolver_handler";
            __int16 v37 = 2082;
            id v38 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s called with null accessor, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_63;
        }

        if (v31)
        {
          *(_DWORD *)int buf = 136446210;
          char v36 = "nw_endpoint_handler_access_resolver_handler";
          _os_log_impl(&dword_181A5C000, v27, v30, "%{public}s called with null accessor, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)int buf = 136446210;
          char v36 = "nw_endpoint_handler_access_resolver_handler";
          _os_log_impl( &dword_181A5C000,  v27,  v32,  "%{public}s called with null accessor, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182062910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL32nw_endpoint_handler_create_innerPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS_PFbP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS_ESD_S5_jb_block_invoke( uint64_t a1, void *a2)
{
  id v6 = a2;
  if (nw_protocol_options_is_quic((nw_protocol_options_t)v6))
  {
    id v3 = *(void **)(a1 + 32);
    id v4 = nw_parameters_copy_context(*(void **)(a1 + 40));
    BOOL v5 = nw_context_copy_workloop(v4);
    nw_quic_connection_set_trusted_peer_keys(v6, v3, (void *)v5);
  }
}

void sub_1820629F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_handler_create_with_existing_block_invoke(uint64_t a1, void *a2)
{
  BOOL v2 = *(void **)(a1 + 32);
  id v3 = nw_protocol_options_copy(a2);
  nw_protocol_stack_append_application_protocol(v2, v3);
}

void sub_182062A64( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

BOOL nw_endpoint_handler_has_fallback_children(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (!v1)
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v10)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
          _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
          _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182062DD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_endpoint_handler_has_fallback_childrenP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1, void *a2)
{
  BOOL v3 = a2;
  id v4 = v3;
  if (v3->mode == 4 || nw_endpoint_handler_has_fallback_children(v3))
  {
    uint64_t v5 = 0LL;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

void sub_182062E68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_connected_socket_wrapper(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    if (v2[29]._os_unfair_lock_opaque == 2) {
      id v3 = nw_endpoint_flow_copy_connected_socket_wrapper(*(void **)&v2[62]._os_unfair_lock_opaque);
    }
    else {
      id v3 = 0LL;
    }
    os_unfair_lock_unlock(v2 + 28);
    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_handler_copy_connected_socket_wrapper";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_connected_socket_wrapper";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_handler_copy_connected_socket_wrapper";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_connected_socket_wrapper";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_connected_socket_wrapper";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182063138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_fillout_data_transfer_snapshot_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = nw_endpoint_handler_fillout_data_transfer_snapshot( a2,  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(unsigned int *)(a1 + 64));
  if (v3) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return v3 ^ 1u;
}

BOOL nw_endpoint_handler_fillout_tcp_info(void *a1, void *a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  int v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *(void *)uint64_t v39 = 0LL;
    *(void *)&v39[8] = v39;
    *(void *)&v39[16] = 0x2020000000LL;
    char v40 = 0;
    os_unfair_lock_lock(v3 + 28);
    uint64_t v5 = *(void **)&v4[62]._os_unfair_lock_opaque;
    if (v4[29]._os_unfair_lock_opaque != 2)
    {
      v36[0] = MEMORY[0x1895F87A8];
      v36[1] = 3221225472LL;
      v36[2] = __nw_endpoint_handler_fillout_tcp_info_block_invoke;
      v36[3] = &unk_189BBBA80;
      void v36[4] = v39;
      void v36[5] = a2;
      [v5 applyWithHandler:v4 toChildren:v36];
LABEL_27:
      os_unfair_lock_unlock(v4 + 28);
      BOOL v18 = *(_BYTE *)(*(void *)&v39[8] + 24LL) != 0;
      _Block_object_dispose(v39, 8);
      goto LABEL_28;
    }

    id v6 = v5;
    os_log_type_t v7 = v6;
    if (v6)
    {
      os_unfair_lock_lock(v6 + 220);
      os_log_type_t v8 = *(const void **)&v7[198]._os_unfair_lock_opaque;
      if (v8)
      {
        memcpy(a2, v8, 0x198uLL);
        BOOL v9 = 1;
      }

      else
      {
        os_log_type_t v10 = *(void **)&v7[102]._os_unfair_lock_opaque;
        if (v10)
        {
          uint64_t v11 = v10[3];
          if (v11)
          {
            os_log_type_t v12 = *(uint64_t (**)(void))(v11 + 224);
            if (v12)
            {
              *(void *)os_log_type_t type = 0LL;
              char v13 = (void *)v10[5];
              if (v13 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v15 = v10[11];
                if (v15) {
                  v10[11] = v15 + 1;
                }
                char v14 = -1;
              }

              else
              {
                char v14 = 0;
              }

              *(void *)int buf = v10;
              buf[8] = v14;
              os_log_type_t v16 = (void *)v12();
              if (v13 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              }
              if (v16)
              {
                BOOL v9 = *(void *)type == 408LL;
                if (*(void *)type == 408LL) {
                  memcpy(a2, v16, 0x198uLL);
                }
                free(v16);
                goto LABEL_25;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v17 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
                _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s copy_info() returned NULL",  buf,  0xCu);
              }
            }
          }
        }

        BOOL v9 = 0;
      }

uint64_t __nw_endpoint_handler_fillout_tcp_info_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = nw_endpoint_handler_fillout_tcp_info(a2, *(void *)(a1 + 40));
  if (v3) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return v3 ^ 1u;
}

BOOL nw_endpoint_handler_fillout_tcp_connection_info(void *a1, _OWORD *a2)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  int v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *(void *)os_log_type_t type = 0LL;
    id v49 = type;
    uint64_t v50 = 0x2020000000LL;
    char v51 = 0;
    os_unfair_lock_lock(v3 + 28);
    uint64_t v5 = *(void **)&v4[62]._os_unfair_lock_opaque;
    if (v4[29]._os_unfair_lock_opaque != 2)
    {
      v47[0] = MEMORY[0x1895F87A8];
      v47[1] = 3221225472LL;
      v47[2] = __nw_endpoint_handler_fillout_tcp_connection_info_block_invoke;
      v47[3] = &unk_189BBBA80;
      v47[4] = type;
      v47[5] = a2;
      [v5 applyWithHandler:v4 toChildren:v47];
LABEL_28:
      os_unfair_lock_unlock(v4 + 28);
      BOOL v29 = *((_BYTE *)v49 + 24) != 0;
      _Block_object_dispose(type, 8);
      goto LABEL_29;
    }

    id v6 = v5;
    os_log_type_t v7 = v6;
    if (v6)
    {
      os_unfair_lock_lock(v6 + 220);
      os_log_type_t v8 = *(__int128 **)&v7[200]._os_unfair_lock_opaque;
      if (v8)
      {
        __int128 v9 = *v8;
        __int128 v10 = v8[2];
        a2[1] = v8[1];
        a2[2] = v10;
        *a2 = v9;
        __int128 v11 = v8[3];
        __int128 v12 = v8[4];
        __int128 v13 = v8[6];
        a2[5] = v8[5];
        a2[6] = v13;
        a2[3] = v11;
        a2[4] = v12;
        char fd = 1;
      }

      else
      {
        uint64_t v15 = *(void *)&v7[102]._os_unfair_lock_opaque;
        if (v15 && (uint64_t v16 = *(void *)(v15 + 24)) != 0 && (v17 = *(uint64_t (**)(void))(v16 + 224)) != 0LL)
        {
          *(void *)__int16 v52 = 0LL;
          BOOL v18 = (__int128 *)v17();
          if (v18)
          {
            if (*(void *)v52 == 112LL)
            {
              __int128 v19 = *v18;
              __int128 v20 = v18[2];
              a2[1] = v18[1];
              a2[2] = v20;
              *a2 = v19;
              __int128 v21 = v18[3];
              __int128 v22 = v18[4];
              __int128 v23 = v18[6];
              a2[5] = v18[5];
              a2[6] = v23;
              a2[3] = v21;
              a2[4] = v22;
              int v24 = 1;
            }

            else
            {
              int v24 = 0;
            }

            free(v18);
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v28 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_connection_info";
              _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s copy_info() returned NULL", buf, 0xCu);
            }

            int v24 = 0;
          }

          char fd = v24 != 0;
        }

        else
        {
          id v25 = *(id *)&v7[222]._os_unfair_lock_opaque;
          if ((v7[8]._os_unfair_lock_opaque & 2) == 0)
          {
            id v26 = *(void **)&v7[234]._os_unfair_lock_opaque;
            if (v26)
            {
              id v27 = nw_endpoint_handler_copy_connected_socket_wrapper(v26);

              id v25 = v27;
            }
          }

          if (v25)
          {
            *(void *)int buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = __nw_endpoint_flow_fillout_tcp_connection_info_block_invoke;
            __int16 v55 = &__block_descriptor_40_e8_B12__0i8l;
            __int16 v56 = a2;
            char fd = nw_fd_wrapper_get_fd(v25, buf);
          }

          else
          {
            char fd = 0;
          }
        }
      }

      os_unfair_lock_unlock(v7 + 220);
LABEL_27:

      *((_BYTE *)v49 + 24) = fd;
      goto LABEL_28;
    }

    __nwlog_obj();
    os_log_type_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_connection_info";
    char v36 = (char *)_os_log_send_and_compose_impl();

    v52[0] = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (__nwlog_fault(v36, v52, &v53))
    {
      if (v52[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = v52[0];
        if (os_log_type_enabled(v37, v52[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_connection_info";
          _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v53)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = v52[0];
        BOOL v44 = os_log_type_enabled(v37, v52[0]);
        if (backtrace_string)
        {
          if (v44)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_connection_info";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v37,  v43,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_65;
        }

        if (v44)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_connection_info";
          _os_log_impl(&dword_181A5C000, v37, v43, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = v52[0];
        if (os_log_type_enabled(v37, v52[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_connection_info";
          _os_log_impl( &dword_181A5C000,  v37,  v46,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182063FD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_fillout_tcp_connection_info_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = nw_endpoint_handler_fillout_tcp_connection_info(a2, *(void *)(a1 + 40));
  if (v3) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return v3 ^ 1u;
}

BOOL nw_endpoint_handler_fillout_route_stats(void *a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    __int128 v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v26 = "nw_endpoint_handler_fillout_route_stats";
    __int128 v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_endpoint_handler_fillout_route_stats";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (!v23)
    {
      __nwlog_obj();
      __int128 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_endpoint_handler_fillout_route_stats";
        _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int128 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_endpoint_handler_fillout_route_stats";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_37;
    }

    if (v17)
    {
      *(_DWORD *)int buf = 136446466;
      id v26 = "nw_endpoint_handler_fillout_route_stats";
      __int16 v27 = 2082;
      os_log_type_t v28 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_25;
  }

  if (!a2)
  {
    __nwlog_obj();
    __int128 v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int buf = 136446210;
    id v26 = "nw_endpoint_handler_fillout_route_stats";
    __int128 v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)int buf = 136446210;
        id v26 = "nw_endpoint_handler_fillout_route_stats";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null stats", buf, 0xCu);
      }

void sub_182064520(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_triggered_agents_updated(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v155 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  p_triggered_agent_uuids = (id *)&v1->triggered_agent_uuids;
  if (v1->triggered_agent_uuids)
  {
    if (v1->inactive_agent_dictionaries)
    {
      id v4 = (os_log_s *)nw_path_copy_inactive_agent_uuids(v1->current_path, 0);
      uint64_t v5 = v4;
      __int16 v132 = v4;
      if (v4 && xpc_array_get_count(v4))
      {
        xpc_object_t v6 = xpc_array_create(0LL, 0LL);
        if (v6)
        {
          os_log_type_t v7 = v2->inactive_agent_dictionaries;
          current_path = v2->current_path;
          else {
            id v10 = 0LL;
          }
          id v52 = *p_triggered_agent_uuids;
          applier[0] = MEMORY[0x1895F87A8];
          applier[1] = 3221225472LL;
          applier[2] = ___ZL44nw_endpoint_handler_triggered_agents_updatedP30NWConcrete_nw_endpoint_handler_block_invoke;
          applier[3] = &unk_189BC5628;
          uint64_t v126 = v7;
          __int16 v134 = v126;
          id v127 = v10;
          id v135 = v127;
          os_log_type_t v18 = v6;
          uint64_t v136 = v18;
          __int16 v128 = v52;
          xpc_array_apply(v52, applier);
          size_t count = xpc_array_get_count(v18);
          BOOL v11 = count == 0;
          if (count)
          {
            objc_storeStrong(p_triggered_agent_uuids, v6);
            objc_storeStrong((id *)&v2->inactive_agent_dictionaries, v10);
            if (!nw_endpoint_handler_get_minimize_logging(v2))
            {
              __int16 v54 = v2;
              char v55 = *((_BYTE *)v54 + 268);

              if ((v55 & 0x20) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                __int16 v56 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
                {
                  uint64_t v57 = v56;
                  __int16 v58 = v54;

                  uint64_t v59 = v58;
                  char v60 = *((_BYTE *)v54 + 268);

                  if ((v60 & 1) != 0) {
                    id v61 = "dry-run ";
                  }
                  else {
                    id v61 = "";
                  }
                  size_t v130 = v18;
                  nw_endpoint_t v62 = nw_endpoint_handler_copy_endpoint(v59);
                  logging_description = nw_endpoint_get_logging_description(v62);
                  os_log_t log = v62;
                  os_log_type_t v121 = v58 + 168;
                  os_log_type_t v64 = v59;
                  unsigned int v65 = v64;
                  uint64_t v66 = v64[30];
                  else {
                    id v67 = off_189BBBBF0[v66];
                  }
                  uint64_t v120 = v67;

                  uint64_t v92 = v65;
                  __int128 v93 = v92;
                  __int128 v94 = v61;
                  id v95 = "path";
                  switch(*((_DWORD *)v92 + 29))
                  {
                    case 0:
                      break;
                    case 1:
                      id v95 = "resolver";
                      break;
                    case 2:
                      id v95 = nw_endpoint_flow_mode_string(v92[31]);
                      break;
                    case 3:
                      id v95 = "proxy";
                      break;
                    case 4:
                      id v95 = "fallback";
                      break;
                    case 5:
                      id v95 = "transform";
                      break;
                    default:
                      id v95 = "unknown-mode";
                      break;
                  }

                  uint64_t v97 = v93;
                  os_unfair_lock_lock(v97 + 28);
                  uint64_t v98 = v2->current_path;
                  os_unfair_lock_unlock(v97 + 28);

                  *(_DWORD *)int buf = 136448002;
                  uint64_t v140 = "nw_endpoint_handler_triggered_agents_updated";
                  __int16 v141 = 2082;
                  unint64_t v142 = v121;
                  __int16 v143 = 2082;
                  uint64_t v144 = v94;
                  __int16 v145 = 2082;
                  int v146 = logging_description;
                  __int16 v147 = 2082;
                  int v148 = v120;
                  __int16 v149 = 2082;
                  int v150 = v95;
                  __int16 v151 = 2114;
                  int v152 = v98;
                  __int16 v153 = 2048;
                  size_t v154 = count;
                  __int16 v56 = v57;
                  _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %zu triggered agent s not yet updated",  buf,  0x52u);

                  os_log_type_t v18 = v130;
                }

                goto LABEL_97;
              }

void sub_182065610( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, void *a28, void *a29)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_endpoint_handler_path_changeP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v4 = nw_path_interface_prohibited_by_parameters(*(void **)(*(void *)(a1 + 32) + 64LL), v3);
  if (!(_DWORD)v4)
  {
    int minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 32));
    char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
    if (minimize_logging)
    {
      if ((logging_disabled & 1) != 0) {
        goto LABEL_11;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        nw_endpoint_t loga = v8;
        id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        os_log_type_t v18 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v19 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        logging_description = nw_endpoint_get_logging_description(v19);
        char v21 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        __int128 v22 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v23 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)int buf = 136448002;
        __int16 v27 = "nw_endpoint_handler_path_change_block_invoke";
        __int16 v28 = 2082;
        uint64_t v29 = id_string;
        __int16 v30 = 2082;
        BOOL v31 = v18;
        __int16 v32 = 2082;
        BOOL v33 = logging_description;
        __int16 v34 = 2082;
        os_log_type_t v35 = v21;
        __int16 v36 = 2082;
        char v37 = v22;
        __int16 v38 = 2114;
        id v39 = v23;
        __int16 v40 = 2114;
        id v41 = v3;
        BOOL v8 = loga;
        _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] overriding unsatisfied, eligi ble interface: %{public}@",  buf,  0x52u);
      }
    }

    else
    {
      if ((logging_disabled & 1) != 0)
      {
LABEL_11:
        uint64_t v5 = a1 + 48;
        goto LABEL_12;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        os_log_t log = v8;
        __int128 v9 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        id v10 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v11 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        os_log_type_t v12 = nw_endpoint_get_logging_description(v11);
        __int128 v13 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        os_log_type_t v14 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v15 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)int buf = 136448002;
        __int16 v27 = "nw_endpoint_handler_path_change_block_invoke";
        __int16 v28 = 2082;
        uint64_t v29 = v9;
        __int16 v30 = 2082;
        BOOL v31 = v10;
        __int16 v32 = 2082;
        BOOL v33 = v12;
        __int16 v34 = 2082;
        os_log_type_t v35 = v13;
        __int16 v36 = 2082;
        char v37 = v14;
        __int16 v38 = 2114;
        id v39 = v15;
        __int16 v40 = 2114;
        id v41 = v3;
        BOOL v8 = log;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] overriding unsatisfied, eligi ble interface: %{public}@",  buf,  0x52u);
      }
    }

    goto LABEL_11;
  }

  if (nw_interface_get_subtype(v3) == 1002)
  {
    uint64_t v5 = a1 + 40;
LABEL_12:
    *(_BYTE *)(*(void *)(*(void *)v5 + 8LL) + 24LL) = 1;
  }

  return v4;
}

void sub_182065A84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_handle_failure(void *a1)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    if (v1[9])
    {
LABEL_3:
      if (*((_DWORD *)v2 + 29) == 2)
      {
        id v3 = v2[31];
        [v3 cancelWithHandler:v2 forced:0];
      }

      *((_DWORD *)v2 + 30) = 4;
      goto LABEL_33;
    }

    unsigned int v4 = *((unsigned __int8 *)v1 + 268);
    if ((v4 & 8) != 0)
    {
      uint64_t v5 = v1;
      xpc_object_t v6 = v5;
      os_log_type_t v7 = (void *)*((void *)v5 + 4);
      if (v7)
      {
        BOOL v8 = v7;
        uint64_t v9 = v8[12];

        if ((v9 & 0x4000000000LL) != 0)
        {
          unsigned int v31 = v4;
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v10 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v6);
            BOOL v33 = nw_endpoint_handler_dry_run_string(v6);
            nw_endpoint_t v34 = nw_endpoint_handler_copy_endpoint(v6);
            logging_description = nw_endpoint_get_logging_description(v34);
            __int16 v36 = nw_endpoint_handler_state_string(v6);
            char v37 = nw_endpoint_handler_mode_string(v6);
            id v38 = nw_endpoint_handler_copy_current_path(v6);
            *(_DWORD *)int buf = 136447746;
            os_log_type_t v45 = "nw_endpoint_handler_handle_failure";
            __int16 v46 = 2082;
            id v47 = (void *)id_string;
            __int16 v48 = 2082;
            id v49 = v33;
            __int16 v50 = 2082;
            char v51 = logging_description;
            __int16 v52 = 2082;
            char v53 = v36;
            __int16 v54 = 2082;
            char v55 = v37;
            __int16 v56 = 2114;
            id v57 = v38;
            _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] detected better path on p arent handler, restarting evaluation",  buf,  0x48u);

            unsigned int v4 = v31;
          }

          goto LABEL_31;
        }

        if ((*((_BYTE *)v2 + 268) & 0x20) != 0) {
          goto LABEL_32;
        }
LABEL_14:
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v10 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          if ((*((_BYTE *)v2 + 268) & 1) != 0) {
            nw_endpoint_t v11 = "dry-run ";
          }
          else {
            nw_endpoint_t v11 = "";
          }
          nw_endpoint_t v12 = nw_endpoint_handler_copy_endpoint(v6);
          __int128 v13 = nw_endpoint_get_logging_description(v12);
          os_log_type_t v14 = v6 + 42;
          uint64_t v15 = v6[30];
          else {
            os_log_type_t v16 = off_189BBBBF0[v15];
          }
          char v17 = v6;
          os_log_type_t v18 = (os_unfair_lock_s *)v17;
          __int16 v40 = v16;
          nw_endpoint_t v41 = v12;
          nw_endpoint_t v19 = v13;
          os_log_type_t v20 = "path";
          switch(v17[29])
          {
            case 0u:
              break;
            case 1u:
              os_log_type_t v20 = "resolver";
              break;
            case 2u:
              os_log_type_t v20 = nw_endpoint_flow_mode_string(*((void **)v17 + 31));
              break;
            case 3u:
              os_log_type_t v20 = "proxy";
              break;
            case 4u:
              os_log_type_t v20 = "fallback";
              break;
            case 5u:
              os_log_type_t v20 = "transform";
              break;
            default:
              os_log_type_t v20 = "unknown-mode";
              break;
          }

          char v21 = v18 + 28;
          __int128 v22 = v18;
          os_unfair_lock_lock(v18 + 28);
          id v23 = v22[8];
          os_unfair_lock_unlock(v21);

          *(_DWORD *)int buf = 136447746;
          os_log_type_t v45 = "nw_endpoint_handler_handle_failure";
          __int16 v46 = 2082;
          id v47 = v14;
          __int16 v48 = 2082;
          id v49 = v11;
          __int16 v50 = 2082;
          char v51 = v19;
          __int16 v52 = 2082;
          char v53 = v40;
          __int16 v54 = 2082;
          char v55 = v20;
          __int16 v56 = 2114;
          id v57 = v23;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] detected better path on par ent handler, restarting evaluation",  buf,  0x48u);
        }

void sub_1820660EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_trigger_agents(void *a1, int a2)
{
  *(void *)((char *)&v128[2] + 6) = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = nw_path_copy_inactive_agent_uuids(v3[8], a2);
  uint64_t v5 = v4;
  if (v4 && xpc_array_get_count(v4))
  {
    *((_DWORD *)v3 + 20) = 131073;
    nw_endpoint_handler_report(v3, 0LL, (_WORD *)v3 + 40, 0LL);
    xpc_object_t xarray = v5;
    if (v3[13])
    {
LABEL_4:
      xpc_object_t v6 = v3;
      char v7 = *((_BYTE *)v6 + 268);

      if ((v7 & 0x20) != 0)
      {
        uint64_t v20 = 1LL;
        goto LABEL_101;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        os_log_t log = v8;
        uint64_t v9 = v6;

        id v10 = v9;
        char v11 = *((_BYTE *)v6 + 268);

        if ((v11 & 1) != 0) {
          nw_endpoint_t v12 = "dry-run ";
        }
        else {
          nw_endpoint_t v12 = "";
        }
        nw_endpoint_t v13 = nw_endpoint_handler_copy_endpoint(v10);
        logging_description = nw_endpoint_get_logging_description(v13);
        uint64_t v15 = v9 + 168;
        os_log_type_t v16 = v10;
        char v17 = v16;
        uint64_t v18 = v16[30];
        else {
          nw_endpoint_t v19 = off_189BBBBF0[v18];
        }

        os_log_type_t v39 = v17;
        __int16 v40 = v39;
        nw_endpoint_t v41 = "path";
        switch(*((_DWORD *)v39 + 29))
        {
          case 0:
            break;
          case 1:
            nw_endpoint_t v41 = "resolver";
            break;
          case 2:
            nw_endpoint_t v41 = nw_endpoint_flow_mode_string(v39[31]);
            break;
          case 3:
            nw_endpoint_t v41 = "proxy";
            break;
          case 4:
            nw_endpoint_t v41 = "fallback";
            break;
          case 5:
            nw_endpoint_t v41 = "transform";
            break;
          default:
            nw_endpoint_t v41 = "unknown-mode";
            break;
        }

        uint64_t v72 = v40;
        os_unfair_lock_lock(v72 + 28);
        id v73 = v3[8];
        os_unfair_lock_unlock(v72 + 28);

        *(_DWORD *)int buf = 136447746;
        BOOL v114 = "nw_endpoint_handler_trigger_agents";
        __int16 v115 = 2082;
        size_t v116 = v15;
        __int16 v117 = 2082;
        id v118 = v12;
        __int16 v119 = 2082;
        uint64_t v120 = logging_description;
        __int16 v121 = 2082;
        uint64_t v122 = v19;
        __int16 v123 = 2082;
        char v124 = v41;
        __int16 v125 = 2114;
        id v126 = v73;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Already triggered agents",  buf,  0x48u);

LABEL_67:
        uint64_t v20 = 1LL;
        BOOL v8 = log;
        goto LABEL_100;
      }

      uint64_t v20 = 1LL;
LABEL_100:

      uint64_t v5 = xarray;
      goto LABEL_101;
    }

    nw_endpoint_t v34 = v3[11];
    if (v34)
    {
      if (xpc_equal(v34, v5)) {
        goto LABEL_4;
      }
      os_log_type_t v35 = v3[11];
    }

    else
    {
      os_log_type_t v35 = 0LL;
    }

    *((_BYTE *)v3 + 268) &= ~2u;
    v3[11] = 0LL;
    char v42 = v3;

    os_log_type_t v43 = v42[12];
    v42[12] = 0LL;

    uint64_t v44 = v3[13];
    v3[13] = 0LL;

    xpc_object_t v45 = xpc_array_create(0LL, 0LL);
    __int16 v46 = v45;
    if (v45)
    {
      id v47 = v42[7];
      __int16 v48 = v45;
      os_log_t log = v48;
      if (v47)
      {
        id v49 = v48;
        __int16 v50 = (void *)v47[3];
        char v51 = v49;
        int v52 = nw_path_evaluator_trigger_agents(v50, a2, 0, v49);

        if (v52 == 1)
        {
          nw_endpoint_t v62 = v42;
          char v63 = *((_BYTE *)v3 + 268);

          if ((v63 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v64 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
            {
              id_string = nw_endpoint_handler_get_id_string(v62);
              uint64_t v66 = nw_endpoint_handler_dry_run_string(v62);
              nw_endpoint_t v67 = nw_endpoint_handler_copy_endpoint(v62);
              id v68 = nw_endpoint_get_logging_description(v67);
              uint64_t v69 = nw_endpoint_handler_state_string(v62);
              __int16 v70 = nw_endpoint_handler_mode_string(v62);
              id v71 = nw_endpoint_handler_copy_current_path(v62);
              *(_DWORD *)int buf = 136448258;
              BOOL v114 = "nw_endpoint_handler_trigger_agents";
              __int16 v115 = 2082;
              size_t v116 = (void *)id_string;
              __int16 v117 = 2082;
              id v118 = v66;
              __int16 v119 = 2082;
              uint64_t v120 = v68;
              __int16 v121 = 2082;
              uint64_t v122 = v69;
              __int16 v123 = 2082;
              char v124 = v70;
              __int16 v125 = 2114;
              id v126 = v71;
              __int16 v127 = 1024;
              LODWORD(v128[0]) = 1;
              WORD2(v128[0]) = 2082;
              *(void *)((char *)v128 + 6) = "cannot satisfy";
              _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Trigger failed: [%d] %{public}s",  buf,  0x58u);
            }
          }

          goto LABEL_54;
        }

        if (v52)
        {
LABEL_84:
          uint64_t v88 = v42;
          BOOL v89 = (*((_BYTE *)v3 + 268) & 0x20) == 0;

          if (v89)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v90 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
            {
              id v91 = nw_endpoint_handler_get_id_string(v88);
              uint64_t v92 = nw_endpoint_handler_dry_run_string(v88);
              nw_endpoint_t v93 = nw_endpoint_handler_copy_endpoint(v88);
              __int128 v94 = nw_endpoint_get_logging_description(v93);
              id v95 = nw_endpoint_handler_state_string(v88);
              os_log_type_t v96 = nw_endpoint_handler_mode_string(v88);
              id v97 = nw_endpoint_handler_copy_current_path(v88);
              uint64_t v98 = off_189BC56A8[v52];
              *(_DWORD *)int buf = 136448258;
              BOOL v114 = "nw_endpoint_handler_trigger_agents";
              __int16 v115 = 2082;
              size_t v116 = (void *)v91;
              __int16 v117 = 2082;
              id v118 = v92;
              __int16 v119 = 2082;
              uint64_t v120 = v94;
              __int16 v121 = 2082;
              uint64_t v122 = v95;
              __int16 v123 = 2082;
              char v124 = v96;
              __int16 v125 = 2114;
              id v126 = v97;
              __int16 v127 = 1024;
              LODWORD(v128[0]) = v52;
              WORD2(v128[0]) = 2082;
              *(void *)((char *)v128 + 6) = v98;
              _os_log_impl( &dword_181A5C000,  v90,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Trigger failed: [%d] %{public}s",  buf,  0x58u);
            }
          }

void sub_182066FD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_reset_mode(void *a1, int a2)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3->mode_handler;
  -[NWConcrete_nw_endpoint_mode_handler cancelWithHandler:forced:](v4, "cancelWithHandler:forced:", v3, 1LL);

  os_unfair_lock_lock(&v3->lock);
  char v5 = *((_BYTE *)v3 + 268);
  *((_BYTE *)v3 + 26_Block_object_dispose(va, 8) = v5 & 0xE7;
  if ((v5 & 1) != 0 || v3->parent_handler)
  {
    xpc_object_t v6 = 0LL;
    v3->int mode = 0;
LABEL_4:
    mode_handler = v3->mode_handler;
    v3->mode_handler = (NWConcrete_nw_endpoint_mode_handler *)v6;

    goto LABEL_5;
  }

  if (v3->mode != 2)
  {
    v3->int mode = 2;
    xpc_object_t v6 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
    *((_BYTE *)v6 + 32) = *((_BYTE *)v6 + 32) & 0xFC | 1;
    goto LABEL_4;
  }

  nw_endpoint_flow_reset_is_leaf_handler(v3->mode_handler, 0);
LABEL_5:
  v3->uint64_t state = 1;
  os_unfair_lock_unlock(&v3->lock);
  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v3);
  if (a2)
  {
    if (minimize_logging)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      char v11 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v3);
        uint64_t v44 = nw_endpoint_handler_dry_run_string(v3);
        nw_endpoint_t v45 = nw_endpoint_handler_copy_endpoint(v3);
        logging_description = nw_endpoint_get_logging_description(v45);
        id v47 = nw_endpoint_handler_state_string(v3);
        __int16 v48 = nw_endpoint_handler_mode_string(v3);
        id v49 = nw_endpoint_handler_copy_current_path(v3);
        *(_DWORD *)int buf = 136447746;
        char v60 = "nw_endpoint_handler_reset_mode";
        __int16 v61 = 2082;
        nw_endpoint_t v62 = id_string;
        __int16 v63 = 2082;
        os_log_type_t v64 = v44;
        __int16 v65 = 2082;
        uint64_t v66 = logging_description;
        __int16 v67 = 2082;
        id v68 = v47;
        __int16 v69 = 2082;
        __int16 v70 = v48;
        __int16 v71 = 2114;
        id v72 = v49;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] reset, restarting path handling",  buf,  0x48u);
      }
    }

    else
    {
      uint64_t v9 = v3;
      char v10 = *((_BYTE *)v3 + 268);

      if ((v10 & 0x20) != 0)
      {
LABEL_45:
        nw_endpoint_handler_path_change(v3);
        goto LABEL_50;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      char v11 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        nw_endpoint_t v12 = v9;

        nw_endpoint_t v13 = v12;
        char v14 = *((_BYTE *)v3 + 268);

        if ((v14 & 1) != 0) {
          uint64_t v15 = "dry-run ";
        }
        else {
          uint64_t v15 = "";
        }
        nw_endpoint_t v16 = nw_endpoint_handler_copy_endpoint(v13);
        char v17 = nw_endpoint_get_logging_description(v16);
        id v57 = v12 + 168;
        uint64_t v18 = v13;
        nw_endpoint_t v19 = v18;
        uint64_t state = v3->state;
        else {
          char v21 = off_189BBBBF0[state];
        }

        os_log_type_t v35 = v19;
        __int16 v36 = "path";
        switch(*((_DWORD *)v35 + 29))
        {
          case 0:
            break;
          case 1:
            __int16 v36 = "resolver";
            break;
          case 2:
            __int16 v36 = nw_endpoint_flow_mode_string(v3->mode_handler);
            break;
          case 3:
            __int16 v36 = "proxy";
            break;
          case 4:
            __int16 v36 = "fallback";
            break;
          case 5:
            __int16 v36 = "transform";
            break;
          default:
            __int16 v36 = "unknown-mode";
            break;
        }

        os_log_type_t v39 = v35;
        os_unfair_lock_lock(&v3->lock);
        id v40 = v39[8];
        os_unfair_lock_unlock(&v3->lock);

        *(_DWORD *)int buf = 136447746;
        char v60 = "nw_endpoint_handler_reset_mode";
        __int16 v61 = 2082;
        nw_endpoint_t v62 = v57;
        __int16 v63 = 2082;
        os_log_type_t v64 = v15;
        __int16 v65 = 2082;
        uint64_t v66 = v17;
        __int16 v67 = 2082;
        id v68 = v21;
        __int16 v69 = 2082;
        __int16 v70 = v36;
        __int16 v71 = 2114;
        id v72 = v40;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] reset, restarting path handling",  buf,  0x48u);
      }
    }

    goto LABEL_45;
  }

  if (minimize_logging)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v24 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      __int16 v50 = nw_endpoint_handler_get_id_string(v3);
      char v51 = nw_endpoint_handler_dry_run_string(v3);
      nw_endpoint_t v52 = nw_endpoint_handler_copy_endpoint(v3);
      char v53 = nw_endpoint_get_logging_description(v52);
      __int16 v54 = nw_endpoint_handler_state_string(v3);
      id v55 = nw_endpoint_handler_mode_string(v3);
      id v56 = nw_endpoint_handler_copy_current_path(v3);
      *(_DWORD *)int buf = 136447746;
      char v60 = "nw_endpoint_handler_reset_mode";
      __int16 v61 = 2082;
      nw_endpoint_t v62 = v50;
      __int16 v63 = 2082;
      os_log_type_t v64 = v51;
      __int16 v65 = 2082;
      uint64_t v66 = v53;
      __int16 v67 = 2082;
      id v68 = v54;
      __int16 v69 = 2082;
      __int16 v70 = v55;
      __int16 v71 = 2114;
      id v72 = v56;
      _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] reset",  buf,  0x48u);
    }

    goto LABEL_49;
  }

  char v22 = v3;
  char v23 = *((_BYTE *)v3 + 268);

  if ((v23 & 0x20) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v24 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      char v25 = v22;

      id v26 = v25;
      char v27 = *((_BYTE *)v3 + 268);

      if ((v27 & 1) != 0) {
        __int16 v28 = "dry-run ";
      }
      else {
        __int16 v28 = "";
      }
      nw_endpoint_t v29 = nw_endpoint_handler_copy_endpoint(v26);
      BOOL v30 = nw_endpoint_get_logging_description(v29);
      uint64_t v58 = v25 + 168;
      unsigned int v31 = v26;
      uint64_t v32 = v31;
      uint64_t v33 = v3->state;
      else {
        nw_endpoint_t v34 = off_189BBBBF0[v33];
      }

      char v37 = v32;
      id v38 = "path";
      switch(*((_DWORD *)v37 + 29))
      {
        case 0:
          break;
        case 1:
          id v38 = "resolver";
          break;
        case 2:
          id v38 = nw_endpoint_flow_mode_string(v3->mode_handler);
          break;
        case 3:
          id v38 = "proxy";
          break;
        case 4:
          id v38 = "fallback";
          break;
        case 5:
          id v38 = "transform";
          break;
        default:
          id v38 = "unknown-mode";
          break;
      }

      nw_endpoint_t v41 = v37;
      os_unfair_lock_lock(&v3->lock);
      id v42 = v41[8];
      os_unfair_lock_unlock(&v3->lock);

      *(_DWORD *)int buf = 136447746;
      char v60 = "nw_endpoint_handler_reset_mode";
      __int16 v61 = 2082;
      nw_endpoint_t v62 = v58;
      __int16 v63 = 2082;
      os_log_type_t v64 = v28;
      __int16 v65 = 2082;
      uint64_t v66 = v30;
      __int16 v67 = 2082;
      id v68 = v34;
      __int16 v69 = 2082;
      __int16 v70 = v38;
      __int16 v71 = 2114;
      id v72 = v42;
      _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] reset",  buf,  0x48u);
    }